   1               		.file	"switcherator.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               	.global	getSwitchNumber
  11               	getSwitchNumber:
  12               	.LFB11:
  13               		.file 1 "switcherator.c"
   1:switcherator.c **** #ifndef __AVR_ATmega328__
   2:switcherator.c **** #define __AVR_ATmega328__
   3:switcherator.c **** #endif
   4:switcherator.c **** #ifndef F_CPU
   5:switcherator.c **** #define F_CPU 16000000
   6:switcherator.c **** #endif
   7:switcherator.c **** 
   8:switcherator.c **** 
   9:switcherator.c **** #include "switcherator.h"
  10:switcherator.c **** 
  11:switcherator.c **** // globals and such
  12:switcherator.c **** 
  13:switcherator.c **** // First time we are turned on and we have the wrong time
  14:switcherator.c **** static char panicMyClockIsNotSet = 1;
  15:switcherator.c **** 
  16:switcherator.c **** 
  17:switcherator.c **** // clock related
  18:switcherator.c **** static unsigned int ticks = 0; // ticks for the clock
  19:switcherator.c **** static unsigned int globalYear, globalMonth, globalDay, globalHour, globalMinute, globalSecond, dow
  20:switcherator.c **** // dow - Sunday = 0
  21:switcherator.c **** static unsigned long weeklySeconds = 0;
  22:switcherator.c **** // This is 1 on daylight savings day so I don't do it twice
  23:switcherator.c **** static char wasDaylightSavings = 0;
  24:switcherator.c **** static unsigned int daylightSavings[2][2]; // [0][0] = spring month, [0][1] = spring day, etc...
  25:switcherator.c **** 
  26:switcherator.c **** // flags
  27:switcherator.c **** static char newSecond = 0;
  28:switcherator.c **** static char newMinute = 0;
  29:switcherator.c **** static char switchChanged = 0;
  30:switcherator.c **** static char tenthFlag = 0; // 10th of a second(ish) has passed
  31:switcherator.c **** static char failCondition = 3;
  32:switcherator.c **** static char failTimer = 0;
  33:switcherator.c **** #define INDICATOR_PORT PORTD
  34:switcherator.c **** #define INDICATOR_PIN (1 << PIND2)
  35:switcherator.c **** #define INDICATOR_DDR DDRD
  36:switcherator.c **** 
  37:switcherator.c **** // When the switch will turn off (weekly seconds))
  38:switcherator.c **** static unsigned long switchStatus[NUM_SWITCHES];
  39:switcherator.c **** // Coded information for the switches
  40:switcherator.c **** // value of 255 (default) means nothing programmed
  41:switcherator.c **** // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
  42:switcherator.c **** // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
  43:switcherator.c **** // pin is abs(value/2)-the base - PINB3 = (22-16)/2  PINB3 (22-16)%2 = 0 - low (23-16)%2 = 1 - high
  44:switcherator.c **** // 200 = PWM, 201 = PWM rotating hue. PWM always uses PORTD3,PORTD5,PORTD6 for RGB
  45:switcherator.c **** // 202 = Color changing PWM
  46:switcherator.c **** // future - 202 - PWM with other ports. Can't on 328p since radio overlaps pwm pins
  47:switcherator.c **** static char switchStuff[NUM_SWITCHES];
  48:switcherator.c **** 
  49:switcherator.c **** 
  50:switcherator.c **** // strings
  51:switcherator.c **** static char receiveBuffer[30];
  52:switcherator.c **** static char radioReceiveBuffer[30];
  53:switcherator.c **** static char tempIntString[] = "00";
  54:switcherator.c **** static char tempLongString[] = "0000";
  55:switcherator.c **** static char tempHugeString[] = "000000";
  56:switcherator.c **** static char statusMsg[32];
  57:switcherator.c **** 
  58:switcherator.c **** // HardwarePWM
  59:switcherator.c **** static char runHue = 0;
  60:switcherator.c **** static char runColorChanges = 0;
  61:switcherator.c **** // PD3, PD5, PD6 or red,green,blue
  62:switcherator.c **** static char pwmValues[] = {0, 0, 0};
  63:switcherator.c **** static char colorChanges[NUM_COLOR_CHANGES][3];
  64:switcherator.c **** static char pwmIsSet = 0; // if we have pwm set up
  65:switcherator.c **** static int pwmSwitchNumber = 0;
  66:switcherator.c **** 
  67:switcherator.c **** // PWM Override for immediate change
  68:switcherator.c **** static unsigned long immediateChange = 0;
  69:switcherator.c **** static char pwmOldValues[] = {0,0,0};
  70:switcherator.c **** static char pwmChangeValues[] = {0,0,0};
  71:switcherator.c **** 
  72:switcherator.c **** // rotating hue
  73:switcherator.c **** static unsigned int currentHue = 0;
  74:switcherator.c **** static unsigned int hueSpeed = 16;
  75:switcherator.c **** static unsigned int hueCount = 0;
  76:switcherator.c **** static unsigned char littleCount = 0;
  77:switcherator.c **** static unsigned int colorChangeSpeed = 10; // how many 1/10 seconds in each color change
  78:switcherator.c **** static unsigned int colorChangeCount = 0;
  79:switcherator.c **** static unsigned char currentColor = 0;
  80:switcherator.c **** #define Red OCR2B
  81:switcherator.c **** #define Green OCR0B
  82:switcherator.c **** #define Blue OCR0A
  83:switcherator.c **** static unsigned int red = 0;
  84:switcherator.c **** static unsigned int green = 0;
  85:switcherator.c **** static unsigned int blue = 0;
  86:switcherator.c **** static unsigned int bright = 16;
  87:switcherator.c **** static unsigned char oldBright = 16;
  88:switcherator.c **** static char switchBright[NUM_SWITCHES];
  89:switcherator.c **** static unsigned char pwmdir = 0;
  90:switcherator.c **** 
  91:switcherator.c **** 
  92:switcherator.c **** // programs and such kept in EEPROM
  93:switcherator.c **** // 1 byte day of week mask or 0 for everyday
  94:switcherator.c **** // 2 byte start time (seconds in day), 2 bytes duration (seconds), 1 byte additional program
  95:switcherator.c **** // If more than 4 switches are desired it will roll over to an additional program
  96:switcherator.c **** // DssddSSSSP
  97:switcherator.c **** // 0123456789   
  98:switcherator.c **** static unsigned char weeklyProgram[MAX_PROGRAM][10];
  99:switcherator.c **** 
 100:switcherator.c **** // input information
 101:switcherator.c **** // Pp - value of 255 (default) means nothing programmed
 102:switcherator.c **** // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
 103:switcherator.c **** // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
 104:switcherator.c **** // pin is abs(value/2)-the base - PINB3 = (22-16)/2  PINB3 (22-16)%2 = 0 - low (23-16)%2 = 1 - high
 105:switcherator.c **** // pLHsDDPw Pp int pin/port like sw, L%,H% (0,255 - digital), s - 0-127=switch, 128-255 = prog
 106:switcherator.c **** // dur in seconds, poll time in secs or  0 for continuous. w = which rgb (mask);)
 107:switcherator.c **** static unsigned char inputs[NUM_INPUTS][8];
 108:switcherator.c **** 
 109:switcherator.c **** // Times that the PROGRAMS will react to a switch (eg dusk to dawn)
 110:switcherator.c **** // [0]=start,[1]=stop,[2]=days
 111:switcherator.c **** static unsigned long timeLimits[NUM_LIMITS][3];
 112:switcherator.c **** 
 113:switcherator.c **** 
 114:switcherator.c **** // adjust the timer so it can be accurate
 115:switcherator.c **** static long tweakTimer = TIMER_TOTAL;
 116:switcherator.c **** 
 117:switcherator.c **** 
 118:switcherator.c **** 
 119:switcherator.c **** // send receive addresses
 120:switcherator.c **** static uint64_t rx_addr_p0, rx_addr_p1, rx_addr_p2, rx_addr_p3, rx_addr_p4, rx_addr_p5, tx_addr;
 121:switcherator.c **** 
 122:switcherator.c **** int main(void) {
 123:switcherator.c ****     receiveBuffer[0] = 0;
 124:switcherator.c ****     radioReceiveBuffer[0] = 0;
 125:switcherator.c ****     int x = 0;
 126:switcherator.c **** 
 127:switcherator.c ****     INDICATOR_DDR |= INDICATOR_PIN;
 128:switcherator.c ****     for (x = 0; x < 4; x++) {
 129:switcherator.c ****         INDICATOR_PORT |= INDICATOR_PIN;
 130:switcherator.c ****         _delay_ms(50);
 131:switcherator.c ****         INDICATOR_PORT &= ~(INDICATOR_PIN);
 132:switcherator.c ****         _delay_ms(100);
 133:switcherator.c ****     }
 134:switcherator.c ****     INDICATOR_PORT |= INDICATOR_PIN;
 135:switcherator.c **** 
 136:switcherator.c **** 
 137:switcherator.c ****     // set color changes to blank
 138:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 139:switcherator.c ****         colorChanges[x][0] = 0;
 140:switcherator.c ****         colorChanges[x][1] = 1;
 141:switcherator.c ****         colorChanges[x][2] = 0;
 142:switcherator.c ****     }
 143:switcherator.c **** 
 144:switcherator.c ****     // just initializing memory
 145:switcherator.c ****     globalYear = globalMonth = globalDay = globalHour = globalMinute = globalSecond = dow = 0;
 146:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 147:switcherator.c ****         switchStatus[x] = 0;
 148:switcherator.c ****         switchStuff[x] = 255;
 149:switcherator.c ****         switchBright[x] = 16;
 150:switcherator.c ****     }
 151:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 152:switcherator.c ****         inputs[x][0] = 255;
 153:switcherator.c ****     }
 154:switcherator.c ****     sei();
 155:switcherator.c **** 
 156:switcherator.c ****     // initialize programs
 157:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 158:switcherator.c ****         clearTheProgram(x);
 159:switcherator.c ****     }
 160:switcherator.c **** 
 161:switcherator.c **** 
 162:switcherator.c **** 
 163:switcherator.c ****     clockInit();
 164:switcherator.c ****     radioInit();
 165:switcherator.c ****     startRx();
 166:switcherator.c ****     // make sure general init is after radioinit
 167:switcherator.c ****     generalInit();
 168:switcherator.c ****     startClock();
 169:switcherator.c **** 
 170:switcherator.c **** 
 171:switcherator.c **** 
 172:switcherator.c ****     // radio related
 173:switcherator.c ****     int payloadLength = 0;
 174:switcherator.c **** 
 175:switcherator.c ****     
 176:switcherator.c **** 
 177:switcherator.c ****     while (1) {
 178:switcherator.c ****         // what to run every second
 179:switcherator.c ****         if (newSecond == 1) {
 180:switcherator.c ****             newSecond = 0;
 181:switcherator.c ****             timerCheck();
 182:switcherator.c ****             inputCheck();
 183:switcherator.c ****         }
 184:switcherator.c ****         // runs only if a switch changed
 185:switcherator.c ****         if (switchChanged == 1) {
 186:switcherator.c ****             switchChanged = 0;
 187:switcherator.c ****             switchOnOff();
 188:switcherator.c ****         }
 189:switcherator.c ****         if (runHue == 1 && immediateChange == 0) {
 190:switcherator.c ****             runHueFunction();
 191:switcherator.c ****         }
 192:switcherator.c ****         if (runColorChanges == 1 && immediateChange == 0) {
 193:switcherator.c ****             runColorFunction();
 194:switcherator.c ****         }
 195:switcherator.c **** 
 196:switcherator.c ****         // override for immediate change in color
 197:switcherator.c ****         if (immediateChange > 0 && weeklySeconds > immediateChange) {
 198:switcherator.c ****             clearImmediateChange();
 199:switcherator.c ****         }
 200:switcherator.c **** 
 201:switcherator.c ****         if (tenthFlag == 1) {
 202:switcherator.c ****             tenthFlag = 0;
 203:switcherator.c ****             inputTenthCheck();
 204:switcherator.c ****             if (failCondition > 0) {
 205:switcherator.c ****                 flashFail();
 206:switcherator.c ****             }
 207:switcherator.c ****             if (runColorChanges == 1) {
 208:switcherator.c ****                 runColorFunction();
 209:switcherator.c ****             }
 210:switcherator.c ****         }
 211:switcherator.c ****         if (newMinute == 1) {
 212:switcherator.c ****             newMinute = 0;
 213:switcherator.c ****             if (panicMyClockIsNotSet == 1) {
 214:switcherator.c ****                 generalStatus("gsq");
 215:switcherator.c ****             }
 216:switcherator.c ****             radioTest();
 217:switcherator.c ****         }
 218:switcherator.c ****         // check for radio instructions
 219:switcherator.c ****         payloadLength = dynReceive(radioReceiveBuffer);
 220:switcherator.c ****         if (payloadLength > 1) {
 221:switcherator.c ****             // wait so the receiver won't miss our response
 222:switcherator.c ****             _delay_ms(90);
 223:switcherator.c ****             checkCommand(radioReceiveBuffer);
 224:switcherator.c ****             
 225:switcherator.c ****             // clear the buffer
 226:switcherator.c ****             for (x = 0; x < 30; x++) {
 227:switcherator.c ****                 radioReceiveBuffer[x] = 0;
 228:switcherator.c ****                 receiveBuffer[x] = 0;
 229:switcherator.c ****             }
 230:switcherator.c ****         }
 231:switcherator.c ****     }
 232:switcherator.c **** }
 233:switcherator.c **** 
 234:switcherator.c **** /****************************************************************
 235:switcherator.c ****  *
 236:switcherator.c ****  *              All Things Command and Interface Related
 237:switcherator.c ****  *
 238:switcherator.c ****  ****************************************************************/
 239:switcherator.c **** 
 240:switcherator.c **** void checkCommand(char * commandReceived) {
 241:switcherator.c ****     if (commandReceived[0] > 0x60)
 242:switcherator.c ****         commandReceived[0] -= 0x20;
 243:switcherator.c ****     if (commandReceived[1] > 0x60)
 244:switcherator.c ****         commandReceived[1] -= 0x20;
 245:switcherator.c ****     int switchme = commandReceived[0];
 246:switcherator.c ****     switchme <<= 8;
 247:switcherator.c ****     switchme |= commandReceived[1];
 248:switcherator.c ****     switch (switchme) {
 249:switcherator.c ****         case 0x5449: //TI
 250:switcherator.c ****             setClock(commandReceived);
 251:switcherator.c ****             break;
 252:switcherator.c ****         case 0x4453: //DS
 253:switcherator.c ****             setDaylightSavings(commandReceived);
 254:switcherator.c ****             break;
 255:switcherator.c ****         case 0x544C: //TL
 256:switcherator.c ****             setTimeLimits(commandReceived);
 257:switcherator.c ****             break;
 258:switcherator.c ****         case 0x4E53: //NS
 259:switcherator.c ****             setNewSwitch(commandReceived);
 260:switcherator.c ****             break;
 261:switcherator.c ****         case 0x5343: //SC
 262:switcherator.c ****             switchClear(commandReceived);
 263:switcherator.c ****             break;
 264:switcherator.c ****         case 0x5344: //SD
 265:switcherator.c ****             switchDisplay(commandReceived);
 266:switcherator.c ****             break;
 267:switcherator.c ****         case 0x5053: //PS
 268:switcherator.c ****             pwmSetup(commandReceived);
 269:switcherator.c ****             break;
 270:switcherator.c ****         case 0x4348: //CH
 271:switcherator.c ****             cycleHue(commandReceived);
 272:switcherator.c ****             break;
 273:switcherator.c ****         case 0x4864: //HS
 274:switcherator.c ****             setHueSpeed(commandReceived);
 275:switcherator.c ****             break;
 276:switcherator.c ****         case 0x5056: //PV
 277:switcherator.c ****             pwmValueSet(commandReceived);
 278:switcherator.c ****             break;
 279:switcherator.c ****         case 0x4E50: //NP
 280:switcherator.c ****             newProgram(commandReceived);
 281:switcherator.c ****             break;
 282:switcherator.c ****         case 0x4350: //CP
 283:switcherator.c ****             clearProgram(commandReceived);
 284:switcherator.c ****             break;
 285:switcherator.c ****         case 0x5041: //PA
 286:switcherator.c ****             programAddSwitch(commandReceived);
 287:switcherator.c ****             break;
 288:switcherator.c ****         case 0x5044: //PD
 289:switcherator.c ****             programSetDays(commandReceived);
 290:switcherator.c ****             break;
 291:switcherator.c ****         case 0x5054: //PT
 292:switcherator.c ****             programSetTime(commandReceived);
 293:switcherator.c ****             break;
 294:switcherator.c ****         case 0x5049: //PI
 295:switcherator.c ****             programDisplay(commandReceived);
 296:switcherator.c ****             break;
 297:switcherator.c ****         case 0x5353: //SS
 298:switcherator.c ****             startSwitch(commandReceived);
 299:switcherator.c ****             break;
 300:switcherator.c ****         case 0x5350: //SP
 301:switcherator.c ****             startProgram(commandReceived);
 302:switcherator.c ****             break;
 303:switcherator.c ****         case 0x5341: //SA
 304:switcherator.c ****             saveToEEPROM();
 305:switcherator.c ****             break;
 306:switcherator.c ****         case 0x434C: //CL
 307:switcherator.c ****             clearToEEPROM();
 308:switcherator.c ****             break;
 309:switcherator.c ****         case 0x5244: //RD
 310:switcherator.c ****             radioDisplayAddress(commandReceived);
 311:switcherator.c ****             break;
 312:switcherator.c ****         case 0x5243: //RC
 313:switcherator.c ****             radioChangeAddress(commandReceived);
 314:switcherator.c ****             break;
 315:switcherator.c ****         case 0x4149: //AI
 316:switcherator.c ****             setAnalogInput(commandReceived);
 317:switcherator.c ****             break;
 318:switcherator.c ****         case 0x4449: //DI
 319:switcherator.c ****             setDigitalInput(commandReceived);
 320:switcherator.c ****             break;
 321:switcherator.c ****         case 0x4349: //CI
 322:switcherator.c ****             clearInput(commandReceived);
 323:switcherator.c ****             break;
 324:switcherator.c ****         case 0x4354: //CT
 325:switcherator.c ****             clockTweak(commandReceived);
 326:switcherator.c ****             break;
 327:switcherator.c ****         case 0x5057: //PW
 328:switcherator.c ****             pwmSummary();
 329:switcherator.c ****             break;
 330:switcherator.c ****         case 0x4753: //GS
 331:switcherator.c ****             generalStatus(commandReceived);
 332:switcherator.c ****             break;
 333:switcherator.c ****         case 0x4343: //CC
 334:switcherator.c ****             colorChangeSet(commandReceived);
 335:switcherator.c ****             break;
 336:switcherator.c ****         case 0x5342: //sb
 337:switcherator.c ****             switchBrightness(commandReceived);
 338:switcherator.c ****             break;
 339:switcherator.c ****         case 0x4253: //bs
 340:switcherator.c ****             brightnessSet(commandReceived);
 341:switcherator.c ****             break;
 342:switcherator.c ****         case 0x4749: //GI
 343:switcherator.c ****             generalInformation();
 344:switcherator.c ****             break;
 345:switcherator.c ****         case 0x5050: //PP
 346:switcherator.c ****             programsProgrammed();
 347:switcherator.c ****             break;
 348:switcherator.c ****         case 0x5357: //SW
 349:switcherator.c ****             switchesProgrammed();
 350:switcherator.c ****             break;
 351:switcherator.c ****         case 0x4950: //IP
 352:switcherator.c ****             inputsProgrammed();
 353:switcherator.c ****             break;
 354:switcherator.c ****         case 0x534F: //SO
 355:switcherator.c ****             switchesOn();
 356:switcherator.c ****             break;
 357:switcherator.c ****         case 0x4943: //IC
 358:switcherator.c ****             setImmediateChange(commandReceived);
 359:switcherator.c ****             break;
 360:switcherator.c ****         default:
 361:switcherator.c ****             break;
 362:switcherator.c ****     }
 363:switcherator.c **** }
 364:switcherator.c **** 
 365:switcherator.c **** 
 366:switcherator.c **** void fail(int failCode) {
 367:switcherator.c ****     statusMsg[0] = 0;
 368:switcherator.c ****     strcat(statusMsg, "fail:");
 369:switcherator.c ****     returnHex(failCode, tempLongString);
 370:switcherator.c ****     strcat(statusMsg, tempLongString);
 371:switcherator.c ****     sendMessage(statusMsg);
 372:switcherator.c **** }
 373:switcherator.c **** 
 374:switcherator.c **** void ok(void) {
 375:switcherator.c ****     sendMessage("ok");
 376:switcherator.c **** }
 377:switcherator.c **** 
 378:switcherator.c **** 
 379:switcherator.c **** // Helper function to get the switch number from char 3 and 4 of an array
 380:switcherator.c **** 
 381:switcherator.c **** int getSwitchNumber(char * commandReceived) {
  14               		.loc 1 381 0
  15               	.LVL0:
  16               	/* prologue: function */
  17               	/* frame size = 0 */
  18               	/* stack size = 0 */
  19               	.L__stack_usage = 0
 382:switcherator.c ****     int switchNumber = 0;
 383:switcherator.c ****     // get switch number
 384:switcherator.c ****     tempIntString[0] = commandReceived[3];
  20               		.loc 1 384 0
  21 0000 FC01      		movw r30,r24
  22 0002 2381      		ldd r18,Z+3
  23 0004 2093 0000 		sts tempIntString,r18
 385:switcherator.c ****     tempIntString[1] = commandReceived[4];
  24               		.loc 1 385 0
  25 0008 8481      		ldd r24,Z+4
  26               	.LVL1:
  27 000a 8093 0000 		sts tempIntString+1,r24
 386:switcherator.c ****     switchNumber = atoi(tempIntString);
  28               		.loc 1 386 0
  29 000e 80E0      		ldi r24,lo8(tempIntString)
  30 0010 90E0      		ldi r25,hi8(tempIntString)
  31 0012 0C94 0000 		jmp atoi
  32               	.LVL2:
  33               	.LFE11:
  35               	.global	getPort
  37               	getPort:
  38               	.LFB17:
 387:switcherator.c ****     return switchNumber;
 388:switcherator.c **** }
 389:switcherator.c **** 
 390:switcherator.c **** 
 391:switcherator.c **** /****************************************************************
 392:switcherator.c ****  *
 393:switcherator.c ****  *              All Things Switch Related
 394:switcherator.c ****  *
 395:switcherator.c ****  ****************************************************************/
 396:switcherator.c **** // Setup a new switch
 397:switcherator.c **** // NS:S#PpD
 398:switcherator.c **** // 01234567
 399:switcherator.c **** 
 400:switcherator.c **** void setNewSwitch(char * commandReceived) {
 401:switcherator.c ****     int switchNumber = 0;
 402:switcherator.c ****     char port = 0;
 403:switcherator.c ****     unsigned char pinMultiplied = 0;
 404:switcherator.c ****     unsigned char pinSubtractee = 0;
 405:switcherator.c ****     volatile unsigned char *realPort = 0;
 406:switcherator.c ****     volatile unsigned char *realDDR = 0;
 407:switcherator.c ****     char pin = 0;
 408:switcherator.c ****     char originalPin = 0;
 409:switcherator.c ****     char direction = 0;
 410:switcherator.c ****     tempIntString[0] = '0';
 411:switcherator.c ****     tempIntString[1] = commandReceived[6];
 412:switcherator.c ****     pin = atoi(tempIntString);
 413:switcherator.c ****     originalPin = pin;
 414:switcherator.c ****     tempIntString[1] = commandReceived[7];
 415:switcherator.c ****     direction = atoi(tempIntString);
 416:switcherator.c ****     port = commandReceived[5];
 417:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 418:switcherator.c ****     // make sure it is off before doing a new one.
 419:switcherator.c ****     clearTheSwitch(switchNumber);
 420:switcherator.c ****     // get the pin string ready for below
 421:switcherator.c ****     if (port == 'B' || port == 'b') {
 422:switcherator.c ****         realPort = &PORTB;
 423:switcherator.c ****         realDDR = &DDRB;
 424:switcherator.c ****         pinSubtractee = 16;
 425:switcherator.c **** #ifdef PORTA
 426:switcherator.c ****     } else if (port == 'A' || port == 'a') {
 427:switcherator.c ****         realPort = &PORTA;
 428:switcherator.c ****         realDDR = &DDRA;
 429:switcherator.c ****         pinSubtractee = 0;
 430:switcherator.c **** #endif
 431:switcherator.c **** #ifdef PORTC
 432:switcherator.c ****     } else if (port == 'C' || port == 'c') {
 433:switcherator.c ****         realPort = &PORTC;
 434:switcherator.c ****         realDDR = &DDRC;
 435:switcherator.c ****         pinSubtractee = 32;
 436:switcherator.c **** #endif
 437:switcherator.c **** #ifdef PORTD
 438:switcherator.c ****     } else if (port == 'D' || port == 'd') {
 439:switcherator.c ****         realPort = &PORTD;
 440:switcherator.c ****         realDDR = &DDRD;
 441:switcherator.c ****         pinSubtractee = 48;
 442:switcherator.c **** #endif
 443:switcherator.c **** #ifdef PORTE
 444:switcherator.c ****     } else if (port == 'E' || port == 'e') {
 445:switcherator.c ****         realPort = &PORTE;
 446:switcherator.c ****         realDDR = &DDRE;
 447:switcherator.c ****         pinSubtractee = 64;
 448:switcherator.c **** #endif
 449:switcherator.c **** #ifdef PORTF
 450:switcherator.c ****     } else if (port == 'F' || port == 'f') {
 451:switcherator.c ****         realPort = &PORTF;
 452:switcherator.c ****         realDDR = &DDRF;
 453:switcherator.c ****         pinSubtractee = 80;
 454:switcherator.c **** #endif
 455:switcherator.c **** #ifdef PORTG
 456:switcherator.c ****     } else if (port == 'G' || port == 'g') {
 457:switcherator.c ****         realPort = &PORTG;
 458:switcherator.c ****         realDDR = &DDRG;
 459:switcherator.c ****         pinSubtractee = 96;
 460:switcherator.c **** #endif
 461:switcherator.c **** #ifdef PORTH
 462:switcherator.c ****     } else if (port == 'H' || port == 'h') {
 463:switcherator.c ****         realPort = &PORTH;
 464:switcherator.c ****         realDDR = &DDRH;
 465:switcherator.c ****         pinSubtractee = 112;
 466:switcherator.c **** #endif
 467:switcherator.c **** #ifdef PORTI
 468:switcherator.c ****     } else if (port == 'I' || port == 'i') {
 469:switcherator.c ****         realPort = &PORTI;
 470:switcherator.c ****         realDDR = &DDRI;
 471:switcherator.c ****         pinSubtractee = 128;
 472:switcherator.c **** #endif
 473:switcherator.c **** 
 474:switcherator.c ****     }
 475:switcherator.c **** 
 476:switcherator.c **** 
 477:switcherator.c ****     if (realPort == 0) {
 478:switcherator.c ****         fail(2);
 479:switcherator.c ****     } else if ((switchNumber >= NUM_SWITCHES) ||
 480:switcherator.c ****             ((switchNumber == 0) && (commandReceived[3] != '0') && (commandReceived[4] != 0))) {
 481:switcherator.c ****         fail(1);
 482:switcherator.c ****     } else if ((pin > 7) || ((pin == 0) && (commandReceived[6] != '0'))) {
 483:switcherator.c ****         fail(4);
 484:switcherator.c ****     } else {
 485:switcherator.c ****         // set DDR out
 486:switcherator.c ****         *realDDR |= (1 << originalPin);
 487:switcherator.c ****         // double the pin and add 1 if it is high
 488:switcherator.c ****         pinMultiplied = pin * 2;
 489:switcherator.c ****         // turn switch off
 490:switcherator.c ****         pin = pinMultiplied + pinSubtractee;
 491:switcherator.c ****         switchStuff[switchNumber] = pin;
 492:switcherator.c **** 
 493:switcherator.c ****         if (direction == 0) {
 494:switcherator.c ****             // 0 = low is on  1 = high is on
 495:switcherator.c ****             *realPort |= (1 << originalPin);
 496:switcherator.c ****         } else {
 497:switcherator.c ****             *realPort &= ~(1 << originalPin);
 498:switcherator.c ****             switchStuff[switchNumber]++;
 499:switcherator.c ****         }
 500:switcherator.c ****         ok();
 501:switcherator.c ****     }
 502:switcherator.c **** }
 503:switcherator.c **** 
 504:switcherator.c **** // get rid of a switch and turn it off
 505:switcherator.c **** // SC:S#
 506:switcherator.c **** // 01234
 507:switcherator.c **** 
 508:switcherator.c **** void switchClear(char * commandReceived) {
 509:switcherator.c ****     int switchNumber = 0;
 510:switcherator.c ****     // get switch number
 511:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 512:switcherator.c ****     clearTheSwitch(switchNumber);
 513:switcherator.c ****     ok();
 514:switcherator.c **** }
 515:switcherator.c **** 
 516:switcherator.c **** // actual turning switch off (called with new switch as well)
 517:switcherator.c **** 
 518:switcherator.c **** void clearTheSwitch(int switchNumber) {
 519:switcherator.c ****     char port[] = {0};
 520:switcherator.c ****     char pin[] = {0};
 521:switcherator.c ****     char direction[] = {0};
 522:switcherator.c ****     volatile unsigned char *thisPort = 0;
 523:switcherator.c ****     volatile unsigned char *thisDDR = 0;
 524:switcherator.c ****     int realPin = 0;
 525:switcherator.c ****     // Figure out if it is pwm
 526:switcherator.c ****     if (switchStuff[switchNumber] >= 200 && switchStuff[switchNumber] <= 220) {
 527:switcherator.c ****         // if it is something else
 528:switcherator.c ****         pwmClear(switchNumber);
 529:switcherator.c ****         switchStuff[switchNumber] = 255;
 530:switcherator.c ****         return;
 531:switcherator.c ****     }
 532:switcherator.c ****     getPort(switchNumber, port, pin, direction);
 533:switcherator.c ****     if (port[0] == 'B') {
 534:switcherator.c ****         thisPort = &PORTB;
 535:switcherator.c ****         thisDDR = &DDRB;
 536:switcherator.c **** #ifdef PORTA
 537:switcherator.c ****     } else if (port[0] == 'A') {
 538:switcherator.c ****         thisPort = &PORTA;
 539:switcherator.c ****         thisDDR = &DDRA;
 540:switcherator.c **** #endif        
 541:switcherator.c **** #ifdef PORTC
 542:switcherator.c ****     } else if (port[0] == 'C') {
 543:switcherator.c ****         thisPort = &PORTC;
 544:switcherator.c ****         thisDDR = &DDRC;
 545:switcherator.c **** #endif        
 546:switcherator.c **** #ifdef PORTD
 547:switcherator.c ****     } else if (port[0] == 'D') {
 548:switcherator.c ****         thisPort = &PORTD;
 549:switcherator.c ****         thisDDR = &DDRD;
 550:switcherator.c **** #endif        
 551:switcherator.c **** #ifdef PORTE
 552:switcherator.c ****     } else if (port[0] == 'E') {
 553:switcherator.c ****         thisPort = &PORTE;
 554:switcherator.c ****         thisDDR = &DDRE;
 555:switcherator.c **** #endif        
 556:switcherator.c **** #ifdef PORTF
 557:switcherator.c ****     } else if (port[0] == 'F') {
 558:switcherator.c ****         thisPort = &PORTF;
 559:switcherator.c ****         thisDDR = &DDRF;
 560:switcherator.c **** #endif        
 561:switcherator.c **** #ifdef PORTG
 562:switcherator.c ****     } else if (port[0] == 'G') {
 563:switcherator.c ****         thisPort = &PORTG;
 564:switcherator.c ****         thisDDR = &DDRG;
 565:switcherator.c **** #endif        
 566:switcherator.c **** #ifdef PORTH
 567:switcherator.c ****     } else if (port[0] == 'H') {
 568:switcherator.c ****         thisPort = &PORTH;
 569:switcherator.c ****         thisDDR = &DDRH;
 570:switcherator.c **** #endif        
 571:switcherator.c **** #ifdef PORTI
 572:switcherator.c ****     } else if (port[0] == 'I') {
 573:switcherator.c ****         thisPort = &PORTI;
 574:switcherator.c ****         thisDDR = &DDRI;
 575:switcherator.c **** #endif        
 576:switcherator.c ****     }
 577:switcherator.c ****     realPin = pin[0];
 578:switcherator.c ****     *thisDDR &= ~(1 << realPin);
 579:switcherator.c ****     *thisPort &= ~(1 << realPin);
 580:switcherator.c ****     switchStuff[switchNumber] = 255;
 581:switcherator.c **** }
 582:switcherator.c **** 
 583:switcherator.c **** // show a summary of the switches
 584:switcherator.c **** 
 585:switcherator.c **** void switchDisplay(char * commandReceived) {
 586:switcherator.c ****     char port[] = {0};
 587:switcherator.c ****     char pin[] = {0};
 588:switcherator.c ****     char direction[] = {0};
 589:switcherator.c ****     int switchNumber = 0;
 590:switcherator.c ****     int realPin = 0;
 591:switcherator.c ****     char statusMsg[32];
 592:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 593:switcherator.c ****     statusMsg[0] = 0;
 594:switcherator.c ****     // see if this is a pwm switch
 595:switcherator.c ****     if (switchStuff[switchNumber] >= 200 && switchStuff[switchNumber] <= 220) {
 596:switcherator.c ****         // yes pwm
 597:switcherator.c ****         if (switchStuff[switchNumber] % 2 == 0) {
 598:switcherator.c ****             if (switchStuff[switchNumber] == 202) {
 599:switcherator.c ****                 strcat(statusMsg, "CoC");
 600:switcherator.c ****             } else if (switchStuff[switchNumber] == 212) {
 601:switcherator.c ****                 strcat(statusMsg, "Brt");
 602:switcherator.c ****             } else {
 603:switcherator.c ****                 strcat(statusMsg, "Fix");
 604:switcherator.c ****             }
 605:switcherator.c ****         } else {
 606:switcherator.c ****             strcat(statusMsg, "Hue");
 607:switcherator.c ****         }
 608:switcherator.c ****     } else {
 609:switcherator.c ****         getPort(switchNumber, port, pin, direction);
 610:switcherator.c ****         tempIntString[0] = port[0];
 611:switcherator.c ****         tempIntString[1] = 0;
 612:switcherator.c ****         strcat(statusMsg, tempIntString);
 613:switcherator.c ****         realPin = pin[0];
 614:switcherator.c ****         itoa(realPin, tempIntString, 10);
 615:switcherator.c ****         strcat(statusMsg, tempIntString);
 616:switcherator.c ****         if (direction[0] == 0) {
 617:switcherator.c ****             strcat(statusMsg, "L");
 618:switcherator.c ****         } else {
 619:switcherator.c ****             strcat(statusMsg, "H");
 620:switcherator.c ****         }
 621:switcherator.c ****     }
 622:switcherator.c ****     sendMessage(statusMsg);
 623:switcherator.c **** 
 624:switcherator.c **** }
 625:switcherator.c **** 
 626:switcherator.c **** // takes in a switch number and time and turns on the switch
 627:switcherator.c **** // SS S#Durat.
 628:switcherator.c **** // 01234567890
 629:switcherator.c **** 
 630:switcherator.c **** void startSwitch(char * commandReceived) {
 631:switcherator.c ****     unsigned long duration;
 632:switcherator.c ****     int switchNumber = 0;
 633:switcherator.c ****     // get switch number
 634:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 635:switcherator.c ****     if ((switchNumber >= NUM_SWITCHES) || (switchStuff[switchNumber] == 255)) {
 636:switcherator.c ****         fail(1);
 637:switcherator.c ****         return;
 638:switcherator.c ****     }
 639:switcherator.c ****     // get duration
 640:switcherator.c ****     tempHugeString[0] = commandReceived[5];
 641:switcherator.c ****     tempHugeString[1] = commandReceived[6];
 642:switcherator.c ****     tempHugeString[2] = commandReceived[7];
 643:switcherator.c ****     tempHugeString[3] = commandReceived[8];
 644:switcherator.c ****     tempHugeString[4] = commandReceived[9];
 645:switcherator.c ****     tempHugeString[5] = commandReceived[10];
 646:switcherator.c ****     duration = atol(tempHugeString);
 647:switcherator.c ****     if (duration == 0) {
 648:switcherator.c ****         fail(5);
 649:switcherator.c ****         return;
 650:switcherator.c ****     }
 651:switcherator.c ****     // only update the time if it is longer than what the switch is already turned on to
 652:switcherator.c ****     if ((weeklySeconds + duration) > switchStatus[switchNumber])
 653:switcherator.c ****         switchStatus[switchNumber] = (weeklySeconds + duration);
 654:switcherator.c **** 
 655:switcherator.c ****     // see if it is PWM - also won't override immediate change
 656:switcherator.c ****     if (switchStuff[switchNumber] >= 200 && switchStuff[switchNumber] <= 220
 657:switcherator.c ****             && immediateChange == 0) {
 658:switcherator.c ****         // k it is PWM.  See if it is hue
 659:switcherator.c ****         if (switchStuff[switchNumber] == 200) {
 660:switcherator.c ****             // even number so values, not hue
 661:switcherator.c ****             red = pwmValues[0];
 662:switcherator.c ****             green = pwmValues[1];
 663:switcherator.c ****             blue = pwmValues[2];
 664:switcherator.c ****             red = red * bright / 16;
 665:switcherator.c ****             green = green * bright / 16;
 666:switcherator.c ****             blue = blue * bright / 16;
 667:switcherator.c ****             Red = red;
 668:switcherator.c ****             Green = green;
 669:switcherator.c ****             Blue = blue;
 670:switcherator.c ****         } else if (switchStuff[switchNumber] == 202) {
 671:switcherator.c ****             runColorChanges = 1;
 672:switcherator.c ****         } else if (switchStuff[switchNumber] == 212) {
 673:switcherator.c ****             bright = switchBright[switchNumber];
 674:switcherator.c ****         } else {
 675:switcherator.c ****             runHue = 1;
 676:switcherator.c ****         }
 677:switcherator.c **** 
 678:switcherator.c ****     } else {
 679:switcherator.c **** 
 680:switcherator.c ****         // get the port and turn it on
 681:switcherator.c ****         char port[1];
 682:switcherator.c ****         char pin[1];
 683:switcherator.c ****         int realPin = 0;
 684:switcherator.c ****         char direction[1];
 685:switcherator.c ****         volatile unsigned char *thisPort = 0;
 686:switcherator.c ****         getPort(switchNumber, port, pin, direction);
 687:switcherator.c ****         // yeah pointers and casts and whatevers. this fixes it
 688:switcherator.c ****         realPin = pin[0];
 689:switcherator.c ****         if (port[0] == 'B')
 690:switcherator.c ****             thisPort = &PORTB;
 691:switcherator.c **** #ifdef PORTA
 692:switcherator.c ****         else if (port[0] == 'A')
 693:switcherator.c ****             thisPort = &PORTA;
 694:switcherator.c **** #endif
 695:switcherator.c **** #ifdef PORTC
 696:switcherator.c ****         else if (port[0] == 'C')
 697:switcherator.c ****             thisPort = &PORTC;
 698:switcherator.c **** #endif
 699:switcherator.c **** #ifdef PORTD
 700:switcherator.c ****         else if (port[0] == 'D')
 701:switcherator.c ****             thisPort = &PORTD;
 702:switcherator.c **** #endif
 703:switcherator.c **** #ifdef PORTE
 704:switcherator.c ****         else if (port[0] == 'E')
 705:switcherator.c ****             thisPort = &PORTE;
 706:switcherator.c **** #endif
 707:switcherator.c **** #ifdef PORTF
 708:switcherator.c ****         else if (port[0] == 'F')
 709:switcherator.c ****             thisPort = &PORTF;
 710:switcherator.c **** #endif
 711:switcherator.c **** #ifdef PORTG
 712:switcherator.c ****         else if (port[0] == 'G')
 713:switcherator.c ****             thisPort = &PORTG;
 714:switcherator.c **** #endif
 715:switcherator.c **** #ifdef PORTH
 716:switcherator.c ****         else if (port[0] == 'H')
 717:switcherator.c ****             thisPort = &PORTH;
 718:switcherator.c **** #endif
 719:switcherator.c **** #ifdef PORTI
 720:switcherator.c ****         else if (port[0] == 'I')
 721:switcherator.c ****             thisPort = &PORTI;
 722:switcherator.c **** #endif
 723:switcherator.c **** 
 724:switcherator.c ****         // turn it on based on what direction
 725:switcherator.c ****         if (direction[0] == 0) {
 726:switcherator.c ****             *thisPort &= ~(1 << realPin);
 727:switcherator.c ****         } else {
 728:switcherator.c ****             *thisPort |= (1 << realPin);
 729:switcherator.c ****         }
 730:switcherator.c ****     }
 731:switcherator.c ****     ok();
 732:switcherator.c **** }
 733:switcherator.c **** // Takes in a switch number and returns the port (as a letter), pin, direction 0,1, and actual PORT
 734:switcherator.c **** 
 735:switcherator.c **** void getPort(int switchNumber, char * port, char * pin, char * direction) {
  39               		.loc 1 735 0
  40               	.LVL3:
  41               	/* prologue: function */
  42               	/* frame size = 0 */
  43               	/* stack size = 0 */
  44               	.L__stack_usage = 0
  45 0016 FB01      		movw r30,r22
 736:switcherator.c ****     char switchInfo = switchStuff[switchNumber];
  46               		.loc 1 736 0
  47 0018 8050      		subi r24,lo8(-(switchStuff))
  48 001a 9040      		sbci r25,hi8(-(switchStuff))
  49               	.LVL4:
  50 001c DC01      		movw r26,r24
  51 001e 8C91      		ld r24,X
  52               	.LVL5:
 737:switcherator.c ****     if ((switchInfo >= 16 && switchInfo < 32)) {
  53               		.loc 1 737 0
  54 0020 982F      		mov r25,r24
  55 0022 9051      		subi r25,lo8(-(-16))
  56 0024 9031      		cpi r25,lo8(16)
  57 0026 00F4      		brsh .L3
 738:switcherator.c ****         port[0] = 'B';
  58               		.loc 1 738 0
  59 0028 82E4      		ldi r24,lo8(66)
  60               	.LVL6:
  61 002a 8083      		st Z,r24
  62               	.LVL7:
  63 002c 00C0      		rjmp .L4
  64               	.LVL8:
  65               	.L3:
 739:switcherator.c ****         switchInfo -= 16;
 740:switcherator.c ****     } else if (switchInfo < 16) {
  66               		.loc 1 740 0
  67 002e 8031      		cpi r24,lo8(16)
  68 0030 00F4      		brsh .L5
 741:switcherator.c ****         port[0] = 'A';
  69               		.loc 1 741 0
  70 0032 91E4      		ldi r25,lo8(65)
  71 0034 9083      		st Z,r25
  72 0036 982F      		mov r25,r24
  73 0038 00C0      		rjmp .L4
  74               	.L5:
 742:switcherator.c ****         switchInfo -= 0;
 743:switcherator.c ****     } else if (switchInfo < 48) {
  75               		.loc 1 743 0
  76 003a 8033      		cpi r24,lo8(48)
  77 003c 00F4      		brsh .L6
 744:switcherator.c ****         port[0] = 'C';
  78               		.loc 1 744 0
  79 003e 93E4      		ldi r25,lo8(67)
  80 0040 9083      		st Z,r25
 745:switcherator.c ****         switchInfo -= 32;
  81               		.loc 1 745 0
  82 0042 982F      		mov r25,r24
  83 0044 9052      		subi r25,lo8(-(-32))
  84               	.LVL9:
  85 0046 00C0      		rjmp .L4
  86               	.LVL10:
  87               	.L6:
 746:switcherator.c ****     } else if (switchInfo < 64) {
  88               		.loc 1 746 0
  89 0048 8034      		cpi r24,lo8(64)
  90 004a 00F4      		brsh .L7
 747:switcherator.c ****         port[0] = 'D';
  91               		.loc 1 747 0
  92 004c 94E4      		ldi r25,lo8(68)
  93 004e 9083      		st Z,r25
 748:switcherator.c ****         switchInfo -= 48;
  94               		.loc 1 748 0
  95 0050 982F      		mov r25,r24
  96 0052 9053      		subi r25,lo8(-(-48))
  97               	.LVL11:
  98 0054 00C0      		rjmp .L4
  99               	.LVL12:
 100               	.L7:
 749:switcherator.c ****     } else if (switchInfo < 80) {
 101               		.loc 1 749 0
 102 0056 8035      		cpi r24,lo8(80)
 103 0058 00F4      		brsh .L8
 750:switcherator.c ****         port[0] = 'E';
 104               		.loc 1 750 0
 105 005a 95E4      		ldi r25,lo8(69)
 106 005c 9083      		st Z,r25
 751:switcherator.c ****         switchInfo -= 64;
 107               		.loc 1 751 0
 108 005e 982F      		mov r25,r24
 109 0060 9054      		subi r25,lo8(-(-64))
 110               	.LVL13:
 111 0062 00C0      		rjmp .L4
 112               	.LVL14:
 113               	.L8:
 752:switcherator.c ****     } else if (switchInfo < 96) {
 114               		.loc 1 752 0
 115 0064 8036      		cpi r24,lo8(96)
 116 0066 00F4      		brsh .L9
 753:switcherator.c ****         port[0] = 'F';
 117               		.loc 1 753 0
 118 0068 96E4      		ldi r25,lo8(70)
 119 006a 9083      		st Z,r25
 754:switcherator.c ****         switchInfo -= 80;
 120               		.loc 1 754 0
 121 006c 982F      		mov r25,r24
 122 006e 9055      		subi r25,lo8(-(-80))
 123               	.LVL15:
 124 0070 00C0      		rjmp .L4
 125               	.LVL16:
 126               	.L9:
 755:switcherator.c ****     } else if (switchInfo < 112) {
 127               		.loc 1 755 0
 128 0072 8037      		cpi r24,lo8(112)
 129 0074 00F4      		brsh .L10
 756:switcherator.c ****         port[0] = 'G';
 130               		.loc 1 756 0
 131 0076 97E4      		ldi r25,lo8(71)
 132 0078 9083      		st Z,r25
 757:switcherator.c ****         switchInfo -= 96;
 133               		.loc 1 757 0
 134 007a 982F      		mov r25,r24
 135 007c 9056      		subi r25,lo8(-(-96))
 136               	.LVL17:
 137 007e 00C0      		rjmp .L4
 138               	.LVL18:
 139               	.L10:
 758:switcherator.c ****     } else if (switchInfo < 128) {
 140               		.loc 1 758 0
 141 0080 87FD      		sbrc r24,7
 142 0082 00C0      		rjmp .L11
 759:switcherator.c ****         port[0] = 'H';
 143               		.loc 1 759 0
 144 0084 98E4      		ldi r25,lo8(72)
 145 0086 9083      		st Z,r25
 760:switcherator.c ****         switchInfo -= 112;
 146               		.loc 1 760 0
 147 0088 982F      		mov r25,r24
 148 008a 9057      		subi r25,lo8(-(-112))
 149               	.LVL19:
 150 008c 00C0      		rjmp .L4
 151               	.LVL20:
 152               	.L11:
 761:switcherator.c ****     } else if (switchInfo < 144) {
 153               		.loc 1 761 0
 154 008e 8039      		cpi r24,lo8(-112)
 155 0090 00F4      		brsh .L12
 762:switcherator.c ****         port[0] = 'I';
 156               		.loc 1 762 0
 157 0092 99E4      		ldi r25,lo8(73)
 158 0094 9083      		st Z,r25
 763:switcherator.c ****         switchInfo -= 128;
 159               		.loc 1 763 0
 160 0096 982F      		mov r25,r24
 161 0098 9058      		subi r25,lo8(-(-128))
 162               	.LVL21:
 163 009a 00C0      		rjmp .L4
 164               	.LVL22:
 165               	.L12:
 764:switcherator.c ****     } else {
 765:switcherator.c ****         port[0] = '?';
 166               		.loc 1 765 0
 167 009c 8FE3      		ldi r24,lo8(63)
 168               	.LVL23:
 169 009e 8083      		st Z,r24
 766:switcherator.c ****         pin[0] = 0;
 170               		.loc 1 766 0
 171 00a0 FA01      		movw r30,r20
 172 00a2 1082      		st Z,__zero_reg__
 767:switcherator.c ****         direction[0] = 0;
 173               		.loc 1 767 0
 174 00a4 D901      		movw r26,r18
 175               	.LVL24:
 176 00a6 1C92      		st X,__zero_reg__
 768:switcherator.c ****         return;
 177               		.loc 1 768 0
 178 00a8 0895      		ret
 179               	.LVL25:
 180               	.L4:
 769:switcherator.c ****     }
 770:switcherator.c ****     pin[0] = switchInfo / 2;
 181               		.loc 1 770 0
 182 00aa 892F      		mov r24,r25
 183 00ac 8695      		lsr r24
 184 00ae FA01      		movw r30,r20
 185 00b0 8083      		st Z,r24
 771:switcherator.c ****     direction[0] = switchInfo % 2;
 186               		.loc 1 771 0
 187 00b2 9170      		andi r25,lo8(1)
 188               	.LVL26:
 189 00b4 D901      		movw r26,r18
 190 00b6 9C93      		st X,r25
 191 00b8 0895      		ret
 192               	.LFE17:
 194               	.global	pwmClear
 196               	pwmClear:
 197               	.LFB20:
 772:switcherator.c **** }
 773:switcherator.c **** 
 774:switcherator.c **** // assign a secondary brightness to a switch
 775:switcherator.c **** // sb s#16
 776:switcherator.c **** 
 777:switcherator.c **** void switchBrightness(char * commandReceived) {
 778:switcherator.c ****     int switchNumber = getSwitchNumber(commandReceived);
 779:switcherator.c ****     char tempBright = 0;
 780:switcherator.c ****     if (switchNumber >= NUM_SWITCHES) {
 781:switcherator.c ****         fail(1);
 782:switcherator.c ****         return;
 783:switcherator.c ****     }
 784:switcherator.c ****     tempIntString[0] = commandReceived[5];
 785:switcherator.c ****     tempIntString[1] = commandReceived[6];
 786:switcherator.c ****     char brightValue = atoi(tempIntString);
 787:switcherator.c ****     if (brightValue == 0) {
 788:switcherator.c ****         tempBright = switchBright[switchNumber];
 789:switcherator.c ****         itoa(tempBright, tempIntString, 10);
 790:switcherator.c ****         statusMsg[0] = 0;
 791:switcherator.c ****         strcat(statusMsg, "Set @");
 792:switcherator.c ****         strcat(statusMsg, tempIntString);
 793:switcherator.c ****         sendMessage(statusMsg);
 794:switcherator.c ****     } else {
 795:switcherator.c ****         if (brightValue > 16)
 796:switcherator.c ****             brightValue = 16;
 797:switcherator.c ****         clearTheSwitch(switchNumber);
 798:switcherator.c ****         // value to indicate this is brightness
 799:switcherator.c ****         switchStuff[switchNumber] = 212;
 800:switcherator.c ****         switchBright[switchNumber] = brightValue;
 801:switcherator.c ****         ok();
 802:switcherator.c ****     }
 803:switcherator.c **** }
 804:switcherator.c **** 
 805:switcherator.c **** /****************************************************************
 806:switcherator.c ****  *
 807:switcherator.c ****  *              All Things PWM Related
 808:switcherator.c ****  *
 809:switcherator.c ****  ****************************************************************/
 810:switcherator.c **** 
 811:switcherator.c **** // PWM setup.  This is initially  geared for the 328p but the framework
 812:switcherator.c **** // exists for other chips
 813:switcherator.c **** // PS:P#S#DH
 814:switcherator.c **** // 012345678
 815:switcherator.c **** 
 816:switcherator.c **** void pwmSetup(char * commandReceived) {
 817:switcherator.c ****     int x = 0;
 818:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 819:switcherator.c ****         if (switchStuff[x] == 70 || switchStuff[x] == 71 || switchStuff[x] == 74 ||
 820:switcherator.c ****                 switchStuff[x] == 75 || switchStuff[x] == 76 || switchStuff[x] == 77) {
 821:switcherator.c ****             fail(6);
 822:switcherator.c ****             return;
 823:switcherator.c ****         }
 824:switcherator.c ****     }
 825:switcherator.c ****     int switchNumber = 0;
 826:switcherator.c ****     // get switch number
 827:switcherator.c ****     tempIntString[0] = commandReceived[5];
 828:switcherator.c ****     tempIntString[1] = commandReceived[6];
 829:switcherator.c ****     switchNumber = atoi(tempIntString);
 830:switcherator.c ****     clearTheSwitch(switchNumber);
 831:switcherator.c ****     // set up a hue pwm
 832:switcherator.c ****     if (commandReceived[8] == 'H' || commandReceived[8] == 'h' || commandReceived[8] == '1') {
 833:switcherator.c ****         switchStuff[switchNumber] = 201;
 834:switcherator.c ****     } else if (commandReceived[8] == 'C' || commandReceived[8] == 'c') {
 835:switcherator.c ****         switchStuff[switchNumber] = 202;
 836:switcherator.c ****     } else {
 837:switcherator.c ****         switchStuff[switchNumber] = 200;
 838:switcherator.c ****     }
 839:switcherator.c ****     DDRD |= (1 << PIND3) | (1 << PIND5) | (1 << PIND6);
 840:switcherator.c ****     // make sure initial values are 0
 841:switcherator.c ****     Red = 0;
 842:switcherator.c ****     Green = 0;
 843:switcherator.c ****     Blue = 0;
 844:switcherator.c ****     // Set output phase correct whatevers
 845:switcherator.c ****     // set it to inverted if the direction is 0
 846:switcherator.c ****     if (commandReceived[7] == '0') {
 847:switcherator.c ****         pwmdir = 0;
 848:switcherator.c ****         TCCR0A = (1 << COM0A0) | (1 << COM0A1) | (1 << COM0B0) | (1 << COM0B1) | (1 << WGM00);
 849:switcherator.c ****         TCCR2A = (1 << COM2B0) | (1 << COM2B1) | (1 << WGM20);
 850:switcherator.c ****     } else {
 851:switcherator.c ****         pwmdir = 1;
 852:switcherator.c ****         TCCR0A = (1 << COM0A1) | (1 << COM0B1) | (1 << WGM00);
 853:switcherator.c ****         TCCR2A = (1 << COM2B1) | (1 << WGM20);
 854:switcherator.c ****     }
 855:switcherator.c ****     // F_CPU/64 timers
 856:switcherator.c ****     TCCR0B = (1 << CS01) | (1 << CS00);
 857:switcherator.c **** 
 858:switcherator.c ****     TCCR2B = (1 << CS22); // F_CPU/64
 859:switcherator.c ****     pwmIsSet = 1;
 860:switcherator.c ****     pwmSwitchNumber = switchNumber;
 861:switcherator.c ****     // pwm to output
 862:switcherator.c ****     ok();
 863:switcherator.c **** }
 864:switcherator.c **** 
 865:switcherator.c **** // Turn off the PWM - called by clearing the switch
 866:switcherator.c **** 
 867:switcherator.c **** void pwmClear(int switchNumber) {
 198               		.loc 1 867 0
 199               	.LVL27:
 200               	/* prologue: function */
 201               	/* frame size = 0 */
 202               	/* stack size = 0 */
 203               	.L__stack_usage = 0
 868:switcherator.c ****     if (switchStuff[switchNumber] == 212) {
 204               		.loc 1 868 0
 205 00ba 8050      		subi r24,lo8(-(switchStuff))
 206 00bc 9040      		sbci r25,hi8(-(switchStuff))
 207               	.LVL28:
 208 00be FC01      		movw r30,r24
 209 00c0 8081      		ld r24,Z
 210               	.LVL29:
 211 00c2 843D      		cpi r24,lo8(-44)
 212 00c4 01F4      		brne .L15
 869:switcherator.c ****         bright = oldBright;
 213               		.loc 1 869 0
 214 00c6 8091 0000 		lds r24,oldBright
 215 00ca 8093 0000 		sts bright,r24
 216 00ce 1092 0000 		sts bright+1,__zero_reg__
 217 00d2 0895      		ret
 218               	.L15:
 870:switcherator.c ****     } else {
 871:switcherator.c ****         TCCR0A = 0;
 219               		.loc 1 871 0
 220 00d4 14BC      		out 0x24,__zero_reg__
 872:switcherator.c ****         TCCR0B = 0;
 221               		.loc 1 872 0
 222 00d6 15BC      		out 0x25,__zero_reg__
 873:switcherator.c ****         TCCR2A = 0;
 223               		.loc 1 873 0
 224 00d8 1092 B000 		sts 176,__zero_reg__
 874:switcherator.c ****         TCCR2B = 0;
 225               		.loc 1 874 0
 226 00dc 1092 B100 		sts 177,__zero_reg__
 875:switcherator.c ****         Red = 0;
 227               		.loc 1 875 0
 228 00e0 1092 B400 		sts 180,__zero_reg__
 876:switcherator.c ****         Green = 0;
 229               		.loc 1 876 0
 230 00e4 18BC      		out 0x28,__zero_reg__
 877:switcherator.c ****         Blue = 0;
 231               		.loc 1 877 0
 232 00e6 17BC      		out 0x27,__zero_reg__
 878:switcherator.c ****         DDRD &= ~((1 << PIND3)&(1 << PIND5)&(1 << PIND6));
 233               		.loc 1 878 0
 234 00e8 8AB1      		in r24,0xa
 235 00ea 8AB9      		out 0xa,r24
 879:switcherator.c ****         runHue = 0;
 236               		.loc 1 879 0
 237 00ec 1092 0000 		sts runHue,__zero_reg__
 880:switcherator.c ****         runColorChanges = 0;
 238               		.loc 1 880 0
 239 00f0 1092 0000 		sts runColorChanges,__zero_reg__
 881:switcherator.c ****         pwmIsSet = 0;
 240               		.loc 1 881 0
 241 00f4 1092 0000 		sts pwmIsSet,__zero_reg__
 242 00f8 0895      		ret
 243               	.LFE20:
 245               	.global	clearTheSwitch
 247               	clearTheSwitch:
 248               	.LFB14:
 518:switcherator.c **** void clearTheSwitch(int switchNumber) {
 249               		.loc 1 518 0
 250               	.LVL30:
 251 00fa EF92      		push r14
 252               	.LCFI0:
 253 00fc FF92      		push r15
 254               	.LCFI1:
 255 00fe 0F93      		push r16
 256               	.LCFI2:
 257 0100 1F93      		push r17
 258               	.LCFI3:
 259 0102 CF93      		push r28
 260               	.LCFI4:
 261 0104 DF93      		push r29
 262               	.LCFI5:
 263 0106 00D0      		rcall .
 264 0108 1F92      		push __zero_reg__
 265               	.LCFI6:
 266 010a CDB7      		in r28,__SP_L__
 267 010c DEB7      		in r29,__SP_H__
 268               	.LCFI7:
 269               	/* prologue: function */
 270               	/* frame size = 3 */
 271               	/* stack size = 9 */
 272               	.L__stack_usage = 9
 273 010e 8C01      		movw r16,r24
 519:switcherator.c ****     char port[] = {0};
 274               		.loc 1 519 0
 275 0110 1B82      		std Y+3,__zero_reg__
 520:switcherator.c ****     char pin[] = {0};
 276               		.loc 1 520 0
 277 0112 1A82      		std Y+2,__zero_reg__
 521:switcherator.c ****     char direction[] = {0};
 278               		.loc 1 521 0
 279 0114 1982      		std Y+1,__zero_reg__
 280               	.LVL31:
 526:switcherator.c ****     if (switchStuff[switchNumber] >= 200 && switchStuff[switchNumber] <= 220) {
 281               		.loc 1 526 0
 282 0116 80E0      		ldi r24,lo8(switchStuff)
 283 0118 E82E      		mov r14,r24
 284 011a 80E0      		ldi r24,hi8(switchStuff)
 285 011c F82E      		mov r15,r24
 286               	.LVL32:
 287 011e E00E      		add r14,r16
 288 0120 F11E      		adc r15,r17
 289 0122 F701      		movw r30,r14
 290 0124 8081      		ld r24,Z
 291 0126 885C      		subi r24,lo8(-(56))
 292 0128 8531      		cpi r24,lo8(21)
 293 012a 00F4      		brsh .L18
 528:switcherator.c ****         pwmClear(switchNumber);
 294               		.loc 1 528 0
 295 012c C801      		movw r24,r16
 296 012e 0E94 0000 		call pwmClear
 297               	.LVL33:
 529:switcherator.c ****         switchStuff[switchNumber] = 255;
 298               		.loc 1 529 0
 299 0132 8FEF      		ldi r24,lo8(-1)
 300 0134 F701      		movw r30,r14
 301 0136 00C0      		rjmp .L24
 302               	.L18:
 532:switcherator.c ****     getPort(switchNumber, port, pin, direction);
 303               		.loc 1 532 0
 304 0138 9E01      		movw r18,r28
 305 013a 2F5F      		subi r18,-1
 306 013c 3F4F      		sbci r19,-1
 307 013e AE01      		movw r20,r28
 308 0140 4E5F      		subi r20,-2
 309 0142 5F4F      		sbci r21,-1
 310 0144 BE01      		movw r22,r28
 311 0146 6D5F      		subi r22,-3
 312 0148 7F4F      		sbci r23,-1
 313 014a C801      		movw r24,r16
 314 014c 0E94 0000 		call getPort
 315               	.LVL34:
 533:switcherator.c ****     if (port[0] == 'B') {
 316               		.loc 1 533 0
 317 0150 8B81      		ldd r24,Y+3
 318 0152 8234      		cpi r24,lo8(66)
 319 0154 01F0      		breq .L21
 542:switcherator.c ****     } else if (port[0] == 'C') {
 320               		.loc 1 542 0
 321 0156 8334      		cpi r24,lo8(67)
 322 0158 01F0      		breq .L22
 547:switcherator.c ****     } else if (port[0] == 'D') {
 323               		.loc 1 547 0
 324 015a 8434      		cpi r24,lo8(68)
 325 015c 01F0      		breq .L23
 523:switcherator.c ****     volatile unsigned char *thisDDR = 0;
 326               		.loc 1 523 0
 327 015e A0E0      		ldi r26,0
 328 0160 B0E0      		ldi r27,0
 522:switcherator.c ****     volatile unsigned char *thisPort = 0;
 329               		.loc 1 522 0
 330 0162 E0E0      		ldi r30,0
 331 0164 F0E0      		ldi r31,0
 332 0166 00C0      		rjmp .L20
 333               	.L21:
 535:switcherator.c ****         thisDDR = &DDRB;
 334               		.loc 1 535 0
 335 0168 A4E2      		ldi r26,lo8(36)
 336 016a B0E0      		ldi r27,0
 534:switcherator.c ****         thisPort = &PORTB;
 337               		.loc 1 534 0
 338 016c E5E2      		ldi r30,lo8(37)
 339 016e F0E0      		ldi r31,0
 340 0170 00C0      		rjmp .L20
 341               	.L22:
 544:switcherator.c ****         thisDDR = &DDRC;
 342               		.loc 1 544 0
 343 0172 A7E2      		ldi r26,lo8(39)
 344 0174 B0E0      		ldi r27,0
 543:switcherator.c ****         thisPort = &PORTC;
 345               		.loc 1 543 0
 346 0176 E8E2      		ldi r30,lo8(40)
 347 0178 F0E0      		ldi r31,0
 348 017a 00C0      		rjmp .L20
 349               	.L23:
 549:switcherator.c ****         thisDDR = &DDRD;
 350               		.loc 1 549 0
 351 017c AAE2      		ldi r26,lo8(42)
 352 017e B0E0      		ldi r27,0
 548:switcherator.c ****         thisPort = &PORTD;
 353               		.loc 1 548 0
 354 0180 EBE2      		ldi r30,lo8(43)
 355 0182 F0E0      		ldi r31,0
 356               	.L20:
 357               	.LVL35:
 578:switcherator.c ****     *thisDDR &= ~(1 << realPin);
 358               		.loc 1 578 0
 359 0184 2C91      		ld r18,X
 360 0186 81E0      		ldi r24,lo8(1)
 361 0188 90E0      		ldi r25,0
 362 018a 0A80      		ldd r0,Y+2
 363 018c 00C0      		rjmp 2f
 364               		1:
 365 018e 880F      		lsl r24
 366 0190 991F      		rol r25
 367               		2:
 368 0192 0A94      		dec r0
 369 0194 02F4      		brpl 1b
 370 0196 8095      		com r24
 371 0198 2823      		and r18,r24
 372 019a 2C93      		st X,r18
 579:switcherator.c ****     *thisPort &= ~(1 << realPin);
 373               		.loc 1 579 0
 374 019c 9081      		ld r25,Z
 375 019e 9823      		and r25,r24
 376 01a0 9083      		st Z,r25
 580:switcherator.c ****     switchStuff[switchNumber] = 255;
 377               		.loc 1 580 0
 378 01a2 F801      		movw r30,r16
 379               	.LVL36:
 380 01a4 E050      		subi r30,lo8(-(switchStuff))
 381 01a6 F040      		sbci r31,hi8(-(switchStuff))
 382 01a8 8FEF      		ldi r24,lo8(-1)
 383               	.LVL37:
 384               	.L24:
 385 01aa 8083      		st Z,r24
 386               	/* epilogue start */
 581:switcherator.c **** }
 387               		.loc 1 581 0
 388 01ac 0F90      		pop __tmp_reg__
 389 01ae 0F90      		pop __tmp_reg__
 390 01b0 0F90      		pop __tmp_reg__
 391 01b2 DF91      		pop r29
 392 01b4 CF91      		pop r28
 393 01b6 1F91      		pop r17
 394 01b8 0F91      		pop r16
 395               	.LVL38:
 396 01ba FF90      		pop r15
 397 01bc EF90      		pop r14
 398 01be 0895      		ret
 399               	.LFE14:
 401               	.global	runColorFunction
 403               	runColorFunction:
 404               	.LFB26:
 882:switcherator.c ****     }
 883:switcherator.c **** 
 884:switcherator.c **** }
 885:switcherator.c **** 
 886:switcherator.c **** // This just sets up the times for the PWM hues
 887:switcherator.c **** // CH:P#TTTTT 
 888:switcherator.c **** // 0123456789
 889:switcherator.c **** 
 890:switcherator.c **** void cycleHue(char * commandReceived) {
 891:switcherator.c ****     // right now we just have 1 pwm but I could add more
 892:switcherator.c ****     tempLongString[0] = commandReceived[5];
 893:switcherator.c ****     tempLongString[1] = commandReceived[6];
 894:switcherator.c ****     tempLongString[2] = commandReceived[7];
 895:switcherator.c ****     tempLongString[3] = commandReceived[8];
 896:switcherator.c ****     int programNumber = 0;
 897:switcherator.c ****     programNumber = atoi(tempLongString);
 898:switcherator.c ****     if (programNumber > 0)
 899:switcherator.c ****         colorChangeSpeed = programNumber;
 900:switcherator.c ****     ok();
 901:switcherator.c **** }
 902:switcherator.c **** 
 903:switcherator.c **** // Changes the hue speed
 904:switcherator.c **** // HS:xx
 905:switcherator.c **** 
 906:switcherator.c **** void setHueSpeed(char * commandReceived) {
 907:switcherator.c ****     tempIntString[0] = commandReceived[3];
 908:switcherator.c ****     tempIntString[1] = commandReceived[4];
 909:switcherator.c ****     int programNumber = 0;
 910:switcherator.c ****     programNumber = atoi(tempIntString);
 911:switcherator.c ****     if (programNumber > 0)
 912:switcherator.c ****         hueSpeed = programNumber;
 913:switcherator.c ****     ok();
 914:switcherator.c **** }
 915:switcherator.c **** 
 916:switcherator.c **** 
 917:switcherator.c **** // set up the values for a solid pwm
 918:switcherator.c **** // PV:P#,vvv,vvv,vvv
 919:switcherator.c **** // 01234567890123456
 920:switcherator.c **** 
 921:switcherator.c **** void pwmValueSet(char * commandReceived) {
 922:switcherator.c ****     tempLongString[3] = 0;
 923:switcherator.c ****     tempLongString[0] = commandReceived[6];
 924:switcherator.c ****     tempLongString[1] = commandReceived[7];
 925:switcherator.c ****     tempLongString[2] = commandReceived[8];
 926:switcherator.c ****     pwmValues[0] = atoi(tempLongString);
 927:switcherator.c ****     tempLongString[0] = commandReceived[10];
 928:switcherator.c ****     tempLongString[1] = commandReceived[11];
 929:switcherator.c ****     tempLongString[2] = commandReceived[12];
 930:switcherator.c ****     pwmValues[1] = atoi(tempLongString);
 931:switcherator.c ****     tempLongString[0] = commandReceived[14];
 932:switcherator.c ****     tempLongString[1] = commandReceived[15];
 933:switcherator.c ****     tempLongString[2] = commandReceived[16];
 934:switcherator.c ****     pwmValues[2] = atoi(tempLongString);
 935:switcherator.c ****     statusMsg[0] = 0;
 936:switcherator.c ****     ok();
 937:switcherator.c **** }
 938:switcherator.c **** 
 939:switcherator.c **** // add a color to the color change
 940:switcherator.c **** // CC:##,vvv,vvv,vvv
 941:switcherator.c **** // 01234567890123456
 942:switcherator.c **** 
 943:switcherator.c **** void colorChangeSet(char * commandReceived) {
 944:switcherator.c ****     int programNumber = getSwitchNumber(commandReceived);
 945:switcherator.c ****     if (programNumber >= NUM_COLOR_CHANGES) {
 946:switcherator.c ****         fail(7);
 947:switcherator.c ****         return;
 948:switcherator.c ****     }
 949:switcherator.c ****     tempLongString[3] = 0;
 950:switcherator.c ****     tempLongString[0] = commandReceived[6];
 951:switcherator.c ****     tempLongString[1] = commandReceived[7];
 952:switcherator.c ****     tempLongString[2] = commandReceived[8];
 953:switcherator.c ****     colorChanges[programNumber][0] = atoi(tempLongString);
 954:switcherator.c ****     tempLongString[0] = commandReceived[10];
 955:switcherator.c ****     tempLongString[1] = commandReceived[11];
 956:switcherator.c ****     tempLongString[2] = commandReceived[12];
 957:switcherator.c ****     colorChanges[programNumber][1] = atoi(tempLongString);
 958:switcherator.c ****     tempLongString[0] = commandReceived[14];
 959:switcherator.c ****     tempLongString[1] = commandReceived[15];
 960:switcherator.c ****     tempLongString[2] = commandReceived[16];
 961:switcherator.c ****     colorChanges[programNumber][2] = atoi(tempLongString);
 962:switcherator.c ****     ok();
 963:switcherator.c **** }
 964:switcherator.c **** 
 965:switcherator.c **** // show the pwm values & color change values
 966:switcherator.c **** 
 967:switcherator.c **** void pwmSummary(void) {
 968:switcherator.c ****     statusMsg[0] = 0;
 969:switcherator.c ****     strcat(statusMsg, "Val 0x");
 970:switcherator.c ****     int x = 0;
 971:switcherator.c ****     for (x = 0; x < 3; x++) {
 972:switcherator.c ****         if (x > 0)
 973:switcherator.c ****             strcat(statusMsg, ",");
 974:switcherator.c ****         returnHexWithout(pwmValues[x], tempLongString);
 975:switcherator.c ****         strcat(statusMsg, tempLongString);
 976:switcherator.c ****     }
 977:switcherator.c ****     strcat(statusMsg, " dir ");
 978:switcherator.c ****     returnInt(pwmdir, tempLongString);
 979:switcherator.c ****     strcat(statusMsg, tempLongString);
 980:switcherator.c ****     sendMessage(statusMsg);
 981:switcherator.c ****     statusMsg[0] = 0;
 982:switcherator.c ****     strcat(statusMsg, "ColCh:");
 983:switcherator.c ****     int y = 0;
 984:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 985:switcherator.c ****         if (x > 0)
 986:switcherator.c ****             strcat(statusMsg, ",");
 987:switcherator.c ****         strcat(statusMsg, "0x");
 988:switcherator.c ****         if(colorChanges[x][0] == 0 && colorChanges[x][1] == 1 &&
 989:switcherator.c ****                 colorChanges[x][2] == 0)
 990:switcherator.c ****             strcat(statusMsg,"--");
 991:switcherator.c ****         else {
 992:switcherator.c ****             for (y = 0; y < 3; y++) {
 993:switcherator.c ****                 if (y > 0)
 994:switcherator.c ****                     strcat(statusMsg,",");
 995:switcherator.c ****                 returnHexWithout(colorChanges[x][y], tempLongString);
 996:switcherator.c ****                 strcat(statusMsg, tempLongString);
 997:switcherator.c ****             }
 998:switcherator.c ****         }
 999:switcherator.c ****         if (strlen(statusMsg) > 20) {
1000:switcherator.c ****             sendMessage(statusMsg);
1001:switcherator.c ****             statusMsg[6] = 0;
1002:switcherator.c ****         }
1003:switcherator.c ****     }
1004:switcherator.c ****     if(strlen(statusMsg)> 6)
1005:switcherator.c ****         sendMessage(statusMsg);
1006:switcherator.c ****     statusMsg[0] = 0;
1007:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
1008:switcherator.c ****         if ((switchStuff[x] >= 200) && (switchStuff[x] <= 220)) {
1009:switcherator.c ****             strcat(statusMsg, "PWM ");
1010:switcherator.c ****             if (switchStuff[x] == 200) {
1011:switcherator.c ****                 strcat(statusMsg, "static");
1012:switcherator.c ****             } else if (switchStuff[x] == 202) {
1013:switcherator.c ****                 strcat(statusMsg, "ColCh");
1014:switcherator.c ****             } else {
1015:switcherator.c ****                 strcat(statusMsg, "hue");
1016:switcherator.c ****             }
1017:switcherator.c ****             strcat(statusMsg, "on sw# ");
1018:switcherator.c ****             returnInt(x, tempLongString);
1019:switcherator.c ****             strcat(statusMsg, tempLongString);
1020:switcherator.c ****             sendMessage(statusMsg);
1021:switcherator.c ****             statusMsg[0] = 0;
1022:switcherator.c ****         }
1023:switcherator.c ****     }
1024:switcherator.c **** }
1025:switcherator.c **** // HardwarePWM
1026:switcherator.c **** //static char runHue = 0;
1027:switcherator.c **** // PD3, PD5, PD6 or red,green,blue
1028:switcherator.c **** //static char pwmValues[] = {0 , 0 , 0};
1029:switcherator.c **** 
1030:switcherator.c **** // Run color function
1031:switcherator.c **** // goes through the colors and switches them.
1032:switcherator.c **** 
1033:switcherator.c **** void runColorFunction(void) {
 405               		.loc 1 1033 0
 406               	/* prologue: function */
 407               	/* frame size = 0 */
 408               	/* stack size = 0 */
 409               	.L__stack_usage = 0
1034:switcherator.c ****     // delay
1035:switcherator.c ****     colorChangeCount++;
 410               		.loc 1 1035 0
 411 01c0 8091 0000 		lds r24,colorChangeCount
 412 01c4 9091 0000 		lds r25,colorChangeCount+1
 413 01c8 0196      		adiw r24,1
 414 01ca 9093 0000 		sts colorChangeCount+1,r25
 415 01ce 8093 0000 		sts colorChangeCount,r24
1036:switcherator.c ****     if (colorChangeCount < colorChangeSpeed)
 416               		.loc 1 1036 0
 417 01d2 2091 0000 		lds r18,colorChangeSpeed
 418 01d6 3091 0000 		lds r19,colorChangeSpeed+1
 419 01da 8217      		cp r24,r18
 420 01dc 9307      		cpc r25,r19
 421 01de 00F4      		brsh .+2
 422 01e0 00C0      		rjmp .L25
1037:switcherator.c ****         return;
1038:switcherator.c ****     colorChangeCount = 0;
 423               		.loc 1 1038 0
 424 01e2 1092 0000 		sts colorChangeCount+1,__zero_reg__
 425 01e6 1092 0000 		sts colorChangeCount,__zero_reg__
1039:switcherator.c ****     currentColor++;
 426               		.loc 1 1039 0
 427 01ea 8091 0000 		lds r24,currentColor
 428 01ee 8F5F      		subi r24,lo8(-(1))
1040:switcherator.c ****     if (currentColor == NUM_COLOR_CHANGES)
 429               		.loc 1 1040 0
 430 01f0 8630      		cpi r24,lo8(6)
 431 01f2 01F0      		breq .L28
1039:switcherator.c ****     currentColor++;
 432               		.loc 1 1039 0
 433 01f4 8093 0000 		sts currentColor,r24
 434 01f8 00C0      		rjmp .L29
 435               	.L28:
1041:switcherator.c ****         currentColor = 0;
 436               		.loc 1 1041 0
 437 01fa 1092 0000 		sts currentColor,__zero_reg__
 438               	.L29:
1042:switcherator.c ****     if (colorChanges[currentColor][0] == 0 &&
 439               		.loc 1 1042 0
 440 01fe 2091 0000 		lds r18,currentColor
 441 0202 822F      		mov r24,r18
 442 0204 90E0      		ldi r25,0
 443 0206 FC01      		movw r30,r24
 444 0208 EE0F      		lsl r30
 445 020a FF1F      		rol r31
 446 020c E80F      		add r30,r24
 447 020e F91F      		adc r31,r25
 448 0210 E050      		subi r30,lo8(-(colorChanges))
 449 0212 F040      		sbci r31,hi8(-(colorChanges))
 450 0214 8081      		ld r24,Z
 451 0216 8111      		cpse r24,__zero_reg__
 452 0218 00C0      		rjmp .L30
 453               		.loc 1 1042 0 is_stmt 0 discriminator 1
 454 021a 8181      		ldd r24,Z+1
 455 021c 8130      		cpi r24,lo8(1)
 456 021e 01F4      		brne .L30
1043:switcherator.c ****             colorChanges[currentColor][1] == 1 &&
 457               		.loc 1 1043 0 is_stmt 1
 458 0220 8281      		ldd r24,Z+2
 459 0222 8111      		cpse r24,__zero_reg__
 460 0224 00C0      		rjmp .L30
1044:switcherator.c ****             colorChanges[currentColor][2] == 0) {
1045:switcherator.c ****         // this one is blank.
1046:switcherator.c ****         if (currentColor == 0)
 461               		.loc 1 1046 0
 462 0226 2223      		tst r18
 463 0228 01F4      		brne .+2
 464 022a 00C0      		rjmp .L25
1047:switcherator.c ****             return;
1048:switcherator.c ****         currentColor = 0;
 465               		.loc 1 1048 0
 466 022c 1092 0000 		sts currentColor,__zero_reg__
 467               	.L30:
 468               	.LBB12:
 469               	.LBB13:
1049:switcherator.c ****     }
1050:switcherator.c ****     red = colorChanges[currentColor][0];
 470               		.loc 1 1050 0
 471 0230 8091 0000 		lds r24,currentColor
 472 0234 90E0      		ldi r25,0
1051:switcherator.c ****     green = colorChanges[currentColor][1];
 473               		.loc 1 1051 0
 474 0236 FC01      		movw r30,r24
 475 0238 EE0F      		lsl r30
 476 023a FF1F      		rol r31
 477 023c E80F      		add r30,r24
 478 023e F91F      		adc r31,r25
 479 0240 E050      		subi r30,lo8(-(colorChanges))
 480 0242 F040      		sbci r31,hi8(-(colorChanges))
 481 0244 8181      		ldd r24,Z+1
1052:switcherator.c ****     blue = colorChanges[currentColor][2];
 482               		.loc 1 1052 0
 483 0246 A281      		ldd r26,Z+2
1053:switcherator.c ****     red = red * bright / 16;
 484               		.loc 1 1053 0
 485 0248 6091 0000 		lds r22,bright
 486 024c 7091 0000 		lds r23,bright+1
1050:switcherator.c ****     red = colorChanges[currentColor][0];
 487               		.loc 1 1050 0
 488 0250 9081      		ld r25,Z
 489               		.loc 1 1053 0
 490 0252 969F      		mul r25,r22
 491 0254 A001      		movw r20,r0
 492 0256 979F      		mul r25,r23
 493 0258 500D      		add r21,r0
 494 025a 1124      		clr __zero_reg__
 495 025c 34E0      		ldi r19,4
 496               		1:
 497 025e 5695      		lsr r21
 498 0260 4795      		ror r20
 499 0262 3A95      		dec r19
 500 0264 01F4      		brne 1b
 501 0266 5093 0000 		sts red+1,r21
 502 026a 4093 0000 		sts red,r20
1054:switcherator.c ****     green = green * bright / 16;
 503               		.loc 1 1054 0
 504 026e 869F      		mul r24,r22
 505 0270 9001      		movw r18,r0
 506 0272 879F      		mul r24,r23
 507 0274 300D      		add r19,r0
 508 0276 1124      		clr __zero_reg__
 509 0278 54E0      		ldi r21,4
 510               		1:
 511 027a 3695      		lsr r19
 512 027c 2795      		ror r18
 513 027e 5A95      		dec r21
 514 0280 01F4      		brne 1b
 515 0282 3093 0000 		sts green+1,r19
 516 0286 2093 0000 		sts green,r18
1055:switcherator.c ****     blue = blue * bright / 16;
 517               		.loc 1 1055 0
 518 028a A69F      		mul r26,r22
 519 028c C001      		movw r24,r0
 520 028e A79F      		mul r26,r23
 521 0290 900D      		add r25,r0
 522 0292 1124      		clr __zero_reg__
 523 0294 64E0      		ldi r22,4
 524               		1:
 525 0296 9695      		lsr r25
 526 0298 8795      		ror r24
 527 029a 6A95      		dec r22
 528 029c 01F4      		brne 1b
 529 029e 9093 0000 		sts blue+1,r25
 530 02a2 8093 0000 		sts blue,r24
1056:switcherator.c ****     Red = red;
 531               		.loc 1 1056 0
 532 02a6 4093 B400 		sts 180,r20
1057:switcherator.c ****     Green = green;
 533               		.loc 1 1057 0
 534 02aa 28BD      		out 0x28,r18
1058:switcherator.c ****     Blue = blue;
 535               		.loc 1 1058 0
 536 02ac 87BD      		out 0x27,r24
 537               	.L25:
 538 02ae 0895      		ret
 539               	.LBE13:
 540               	.LBE12:
 541               	.LFE26:
 543               	.global	runHueFunction
 545               	runHueFunction:
 546               	.LFB27:
1059:switcherator.c **** }
1060:switcherator.c **** // rotating hue
1061:switcherator.c **** //static int currentHue = 0;
1062:switcherator.c **** //static int hueSpeed = 0;
1063:switcherator.c **** //static char hueCount = 0;
1064:switcherator.c **** //#define Red OCR2B
1065:switcherator.c **** //#define Green OCR0B
1066:switcherator.c **** //#define Blue OCR0A
1067:switcherator.c **** 
1068:switcherator.c **** // go through and rotate the hue based color rotation
1069:switcherator.c **** // static int currentHue = 0;
1070:switcherator.c **** // static char hueSpeed = 0;
1071:switcherator.c **** // static char hueCount = 0;
1072:switcherator.c **** 
1073:switcherator.c **** void runHueFunction(void) {
 547               		.loc 1 1073 0
 548               	/* prologue: function */
 549               	/* frame size = 0 */
 550               	/* stack size = 0 */
 551               	.L__stack_usage = 0
1074:switcherator.c ****     // extra fixed delay
1075:switcherator.c ****     littleCount++;
 552               		.loc 1 1075 0
 553 02b0 8091 0000 		lds r24,littleCount
 554 02b4 8F5F      		subi r24,lo8(-(1))
 555 02b6 8093 0000 		sts littleCount,r24
1076:switcherator.c ****     if (littleCount != 2)
 556               		.loc 1 1076 0
 557 02ba 8230      		cpi r24,lo8(2)
 558 02bc 01F0      		breq .+2
 559 02be 00C0      		rjmp .L35
1077:switcherator.c ****         return;
1078:switcherator.c ****     littleCount = 0;
 560               		.loc 1 1078 0
 561 02c0 1092 0000 		sts littleCount,__zero_reg__
1079:switcherator.c ****     hueCount++;
 562               		.loc 1 1079 0
 563 02c4 8091 0000 		lds r24,hueCount
 564 02c8 9091 0000 		lds r25,hueCount+1
 565 02cc 0196      		adiw r24,1
 566 02ce 9093 0000 		sts hueCount+1,r25
 567 02d2 8093 0000 		sts hueCount,r24
1080:switcherator.c ****     // only run if the count is higher than the "speed"
1081:switcherator.c ****     if (hueCount < hueSpeed) {
 568               		.loc 1 1081 0
 569 02d6 2091 0000 		lds r18,hueSpeed
 570 02da 3091 0000 		lds r19,hueSpeed+1
 571 02de 8217      		cp r24,r18
 572 02e0 9307      		cpc r25,r19
 573 02e2 00F4      		brsh .+2
 574 02e4 00C0      		rjmp .L35
1082:switcherator.c ****         return;
1083:switcherator.c ****     }
1084:switcherator.c ****     hueCount = 0;
 575               		.loc 1 1084 0
 576 02e6 1092 0000 		sts hueCount+1,__zero_reg__
 577 02ea 1092 0000 		sts hueCount,__zero_reg__
1085:switcherator.c ****     if (currentHue < 0x00ff) {
 578               		.loc 1 1085 0
 579 02ee 8091 0000 		lds r24,currentHue
 580 02f2 9091 0000 		lds r25,currentHue+1
 581 02f6 8F3F      		cpi r24,-1
 582 02f8 9105      		cpc r25,__zero_reg__
 583 02fa 00F4      		brsh .L39
1086:switcherator.c ****         red = 255;
 584               		.loc 1 1086 0
 585 02fc 2FEF      		ldi r18,lo8(-1)
 586 02fe 30E0      		ldi r19,0
 587 0300 3093 0000 		sts red+1,r19
 588 0304 2093 0000 		sts red,r18
 589 0308 00C0      		rjmp .L46
 590               	.L39:
1087:switcherator.c ****         green = currentHue;
1088:switcherator.c ****         blue = 0;
1089:switcherator.c ****     } else if (currentHue < 0x01ff) {
 591               		.loc 1 1089 0
 592 030a 8F3F      		cpi r24,-1
 593 030c 21E0      		ldi r18,1
 594 030e 9207      		cpc r25,r18
 595 0310 00F4      		brsh .L41
1090:switcherator.c ****         red = 255 - (currentHue - 0xff);
 596               		.loc 1 1090 0
 597 0312 2EEF      		ldi r18,lo8(-2)
 598 0314 31E0      		ldi r19,lo8(1)
 599 0316 281B      		sub r18,r24
 600 0318 390B      		sbc r19,r25
 601 031a 3093 0000 		sts red+1,r19
 602 031e 2093 0000 		sts red,r18
1091:switcherator.c ****         green = 255;
 603               		.loc 1 1091 0
 604 0322 8FEF      		ldi r24,lo8(-1)
 605 0324 90E0      		ldi r25,0
 606               	.L46:
 607 0326 9093 0000 		sts green+1,r25
 608 032a 8093 0000 		sts green,r24
1092:switcherator.c ****         blue = 0;
 609               		.loc 1 1092 0
 610 032e 1092 0000 		sts blue+1,__zero_reg__
 611 0332 1092 0000 		sts blue,__zero_reg__
 612 0336 00C0      		rjmp .L40
 613               	.L41:
1093:switcherator.c ****     } else if (currentHue < 0x02ff) {
 614               		.loc 1 1093 0
 615 0338 8F3F      		cpi r24,-1
 616 033a 22E0      		ldi r18,2
 617 033c 9207      		cpc r25,r18
 618 033e 00F4      		brsh .L42
1094:switcherator.c ****         red = 0;
 619               		.loc 1 1094 0
 620 0340 1092 0000 		sts red+1,__zero_reg__
 621 0344 1092 0000 		sts red,__zero_reg__
1095:switcherator.c ****         green = 255;
 622               		.loc 1 1095 0
 623 0348 2FEF      		ldi r18,lo8(-1)
 624 034a 30E0      		ldi r19,0
 625 034c 3093 0000 		sts green+1,r19
 626 0350 2093 0000 		sts green,r18
1096:switcherator.c ****         blue = (currentHue - 0x1ff);
 627               		.loc 1 1096 0
 628 0354 8F5F      		subi r24,-1
 629 0356 9140      		sbci r25,1
 630 0358 00C0      		rjmp .L47
 631               	.L42:
1097:switcherator.c ****     } else if (currentHue < 0x03ff) {
 632               		.loc 1 1097 0
 633 035a 8F3F      		cpi r24,-1
 634 035c 23E0      		ldi r18,3
 635 035e 9207      		cpc r25,r18
 636 0360 00F4      		brsh .L43
1098:switcherator.c ****         red = 0;
 637               		.loc 1 1098 0
 638 0362 1092 0000 		sts red+1,__zero_reg__
 639 0366 1092 0000 		sts red,__zero_reg__
1099:switcherator.c ****         green = 255 - (currentHue - 0x2ff);
 640               		.loc 1 1099 0
 641 036a 2EEF      		ldi r18,lo8(-2)
 642 036c 33E0      		ldi r19,lo8(3)
 643 036e 281B      		sub r18,r24
 644 0370 390B      		sbc r19,r25
 645 0372 3093 0000 		sts green+1,r19
 646 0376 2093 0000 		sts green,r18
 647               	.L48:
1100:switcherator.c ****         blue = 255;
 648               		.loc 1 1100 0
 649 037a 8FEF      		ldi r24,lo8(-1)
 650 037c 90E0      		ldi r25,0
 651               	.L47:
 652 037e 9093 0000 		sts blue+1,r25
 653 0382 8093 0000 		sts blue,r24
 654 0386 00C0      		rjmp .L40
 655               	.L43:
1101:switcherator.c ****     } else if (currentHue < 0x04ff) {
 656               		.loc 1 1101 0
 657 0388 8F3F      		cpi r24,-1
 658 038a 24E0      		ldi r18,4
 659 038c 9207      		cpc r25,r18
 660 038e 00F4      		brsh .L44
1102:switcherator.c ****         red = (currentHue - 0x3ff);
 661               		.loc 1 1102 0
 662 0390 8F5F      		subi r24,-1
 663 0392 9340      		sbci r25,3
 664 0394 9093 0000 		sts red+1,r25
 665 0398 8093 0000 		sts red,r24
1103:switcherator.c ****         green = 0;
 666               		.loc 1 1103 0
 667 039c 1092 0000 		sts green+1,__zero_reg__
 668 03a0 1092 0000 		sts green,__zero_reg__
 669 03a4 00C0      		rjmp .L48
 670               	.L44:
1104:switcherator.c ****         blue = 255;
1105:switcherator.c ****     } else if (currentHue < 0x05ff) {
 671               		.loc 1 1105 0
 672 03a6 8F3F      		cpi r24,-1
 673 03a8 25E0      		ldi r18,5
 674 03aa 9207      		cpc r25,r18
 675 03ac 00F4      		brsh .L45
1106:switcherator.c ****         red = 255;
 676               		.loc 1 1106 0
 677 03ae 2FEF      		ldi r18,lo8(-1)
 678 03b0 30E0      		ldi r19,0
 679 03b2 3093 0000 		sts red+1,r19
 680 03b6 2093 0000 		sts red,r18
1107:switcherator.c ****         green = 0;
 681               		.loc 1 1107 0
 682 03ba 1092 0000 		sts green+1,__zero_reg__
 683 03be 1092 0000 		sts green,__zero_reg__
1108:switcherator.c ****         blue = 255 - (currentHue - 0x4ff);
 684               		.loc 1 1108 0
 685 03c2 2EEF      		ldi r18,lo8(-2)
 686 03c4 35E0      		ldi r19,lo8(5)
 687 03c6 281B      		sub r18,r24
 688 03c8 390B      		sbc r19,r25
 689 03ca 3093 0000 		sts blue+1,r19
 690 03ce 2093 0000 		sts blue,r18
 691 03d2 00C0      		rjmp .L40
 692               	.L45:
1109:switcherator.c ****     } else {
1110:switcherator.c ****         red = 255;
 693               		.loc 1 1110 0
 694 03d4 8FEF      		ldi r24,lo8(-1)
 695 03d6 90E0      		ldi r25,0
 696 03d8 9093 0000 		sts red+1,r25
 697 03dc 8093 0000 		sts red,r24
1111:switcherator.c ****         green = 0;
 698               		.loc 1 1111 0
 699 03e0 1092 0000 		sts green+1,__zero_reg__
 700 03e4 1092 0000 		sts green,__zero_reg__
1112:switcherator.c ****         blue = 0;
 701               		.loc 1 1112 0
 702 03e8 1092 0000 		sts blue+1,__zero_reg__
 703 03ec 1092 0000 		sts blue,__zero_reg__
1113:switcherator.c ****         currentHue = 0;
 704               		.loc 1 1113 0
 705 03f0 1092 0000 		sts currentHue+1,__zero_reg__
 706 03f4 1092 0000 		sts currentHue,__zero_reg__
 707               	.L40:
1114:switcherator.c ****     }
1115:switcherator.c ****     red = red * bright / 16;
 708               		.loc 1 1115 0
 709 03f8 6091 0000 		lds r22,bright
 710 03fc 7091 0000 		lds r23,bright+1
 711 0400 8091 0000 		lds r24,red
 712 0404 9091 0000 		lds r25,red+1
 713 0408 689F      		mul r22,r24
 714 040a A001      		movw r20,r0
 715 040c 699F      		mul r22,r25
 716 040e 500D      		add r21,r0
 717 0410 789F      		mul r23,r24
 718 0412 500D      		add r21,r0
 719 0414 1124      		clr r1
 720 0416 E4E0      		ldi r30,4
 721               		1:
 722 0418 5695      		lsr r21
 723 041a 4795      		ror r20
 724 041c EA95      		dec r30
 725 041e 01F4      		brne 1b
 726 0420 5093 0000 		sts red+1,r21
 727 0424 4093 0000 		sts red,r20
1116:switcherator.c ****     green = green * bright / 16;
 728               		.loc 1 1116 0
 729 0428 8091 0000 		lds r24,green
 730 042c 9091 0000 		lds r25,green+1
 731 0430 689F      		mul r22,r24
 732 0432 9001      		movw r18,r0
 733 0434 699F      		mul r22,r25
 734 0436 300D      		add r19,r0
 735 0438 789F      		mul r23,r24
 736 043a 300D      		add r19,r0
 737 043c 1124      		clr r1
 738 043e F4E0      		ldi r31,4
 739               		1:
 740 0440 3695      		lsr r19
 741 0442 2795      		ror r18
 742 0444 FA95      		dec r31
 743 0446 01F4      		brne 1b
 744 0448 3093 0000 		sts green+1,r19
 745 044c 2093 0000 		sts green,r18
1117:switcherator.c ****     blue = blue * bright / 16;
 746               		.loc 1 1117 0
 747 0450 E091 0000 		lds r30,blue
 748 0454 F091 0000 		lds r31,blue+1
 749 0458 6E9F      		mul r22,r30
 750 045a C001      		movw r24,r0
 751 045c 6F9F      		mul r22,r31
 752 045e 900D      		add r25,r0
 753 0460 7E9F      		mul r23,r30
 754 0462 900D      		add r25,r0
 755 0464 1124      		clr r1
 756 0466 A4E0      		ldi r26,4
 757               		1:
 758 0468 9695      		lsr r25
 759 046a 8795      		ror r24
 760 046c AA95      		dec r26
 761 046e 01F4      		brne 1b
 762 0470 9093 0000 		sts blue+1,r25
 763 0474 8093 0000 		sts blue,r24
1118:switcherator.c ****     Red = red;
 764               		.loc 1 1118 0
 765 0478 4093 B400 		sts 180,r20
1119:switcherator.c ****     Green = green;
 766               		.loc 1 1119 0
 767 047c 28BD      		out 0x28,r18
1120:switcherator.c ****     Blue = blue;
 768               		.loc 1 1120 0
 769 047e 87BD      		out 0x27,r24
1121:switcherator.c ****     currentHue++;
 770               		.loc 1 1121 0
 771 0480 8091 0000 		lds r24,currentHue
 772 0484 9091 0000 		lds r25,currentHue+1
 773 0488 0196      		adiw r24,1
 774 048a 9093 0000 		sts currentHue+1,r25
 775 048e 8093 0000 		sts currentHue,r24
 776               	.L35:
 777 0492 0895      		ret
 778               	.LFE27:
 780               	.global	clearImmediateChange
 782               	clearImmediateChange:
 783               	.LFB30:
1122:switcherator.c **** }
1123:switcherator.c **** 
1124:switcherator.c **** // sets the pwm brightness value
1125:switcherator.c **** // bs 16
1126:switcherator.c **** 
1127:switcherator.c **** void brightnessSet(char * commandReceived) {
1128:switcherator.c ****     int brightValue = getSwitchNumber(commandReceived);
1129:switcherator.c ****     if (brightValue == 0) {
1130:switcherator.c ****         // display the brightness
1131:switcherator.c ****         itoa(oldBright, tempIntString, 10);
1132:switcherator.c ****         statusMsg[0] = 0;
1133:switcherator.c ****         strcat(statusMsg, "Set @");
1134:switcherator.c ****         strcat(statusMsg, tempIntString);
1135:switcherator.c ****         strcat(statusMsg, "B@");
1136:switcherator.c ****         itoa(bright, tempIntString, 10);
1137:switcherator.c ****         strcat(statusMsg, tempIntString);
1138:switcherator.c ****         sendMessage(statusMsg);
1139:switcherator.c ****     } else {
1140:switcherator.c ****         if (brightValue > 16)
1141:switcherator.c ****             brightValue = 16;
1142:switcherator.c ****         if (oldBright == bright) {
1143:switcherator.c ****             // currently not being overridden
1144:switcherator.c ****             bright = brightValue;
1145:switcherator.c ****         }
1146:switcherator.c ****         oldBright = brightValue;
1147:switcherator.c ****         switchChanged = 1;
1148:switcherator.c ****         ok();
1149:switcherator.c ****     }
1150:switcherator.c **** }
1151:switcherator.c **** 
1152:switcherator.c **** // sometimes you might want the lights to act like they
1153:switcherator.c **** // are being controlled via DMX or something.  this is how
1154:switcherator.c **** // ic:xxx,xxx,xxx
1155:switcherator.c **** // 01234567890123
1156:switcherator.c **** void setImmediateChange(char * commandReceived) {
1157:switcherator.c ****     tempLongString[3] = 0;
1158:switcherator.c ****     tempLongString[0] = commandReceived[3];
1159:switcherator.c ****     tempLongString[1] = commandReceived[4];
1160:switcherator.c ****     tempLongString[2] = commandReceived[5];
1161:switcherator.c ****     pwmChangeValues[0] = atoi(tempLongString);
1162:switcherator.c ****     tempLongString[0] = commandReceived[7];
1163:switcherator.c ****     tempLongString[1] = commandReceived[8];
1164:switcherator.c ****     tempLongString[2] = commandReceived[9];
1165:switcherator.c ****     pwmChangeValues[1] = atoi(tempLongString);
1166:switcherator.c ****     tempLongString[0] = commandReceived[11];
1167:switcherator.c ****     tempLongString[1] = commandReceived[12];
1168:switcherator.c ****     tempLongString[2] = commandReceived[13];
1169:switcherator.c ****     pwmChangeValues[2] = atoi(tempLongString);
1170:switcherator.c ****     if(pwmChangeValues[0] == 0 && pwmChangeValues[1] == 0 &&
1171:switcherator.c ****             pwmChangeValues[2] == 0) {
1172:switcherator.c ****         fail(0x13);
1173:switcherator.c ****         return;
1174:switcherator.c ****     }
1175:switcherator.c ****      if(pwmIsSet == 1) {
1176:switcherator.c ****         immediateChange = (weeklySeconds + 5);
1177:switcherator.c ****         if(switchStatus[pwmSwitchNumber] < immediateChange)
1178:switcherator.c ****             switchStatus[pwmSwitchNumber] = immediateChange;
1179:switcherator.c ****         pwmOldValues[0] = Red;
1180:switcherator.c ****         pwmOldValues[1] = Green;
1181:switcherator.c ****         pwmOldValues[2] = Blue;
1182:switcherator.c ****         Red = pwmChangeValues[0];
1183:switcherator.c ****         Green = pwmChangeValues[1];
1184:switcherator.c ****         Blue = pwmChangeValues[2];
1185:switcherator.c ****         ok();
1186:switcherator.c ****     } else {
1187:switcherator.c ****         fail(0x14);
1188:switcherator.c ****         return;
1189:switcherator.c ****     }
1190:switcherator.c **** }
1191:switcherator.c **** 
1192:switcherator.c **** 
1193:switcherator.c **** void clearImmediateChange(void) {
 784               		.loc 1 1193 0
 785               	/* prologue: function */
 786               	/* frame size = 0 */
 787               	/* stack size = 0 */
 788               	.L__stack_usage = 0
1194:switcherator.c ****     immediateChange = 0;
 789               		.loc 1 1194 0
 790 0494 1092 0000 		sts immediateChange,__zero_reg__
 791 0498 1092 0000 		sts immediateChange+1,__zero_reg__
 792 049c 1092 0000 		sts immediateChange+2,__zero_reg__
 793 04a0 1092 0000 		sts immediateChange+3,__zero_reg__
1195:switcherator.c ****     Red = pwmOldValues[0];
 794               		.loc 1 1195 0
 795 04a4 8091 0000 		lds r24,pwmOldValues
 796 04a8 8093 B400 		sts 180,r24
1196:switcherator.c ****     Green = pwmOldValues[1];
 797               		.loc 1 1196 0
 798 04ac 8091 0000 		lds r24,pwmOldValues+1
 799 04b0 88BD      		out 0x28,r24
1197:switcherator.c ****     Blue = pwmOldValues[2];
 800               		.loc 1 1197 0
 801 04b2 8091 0000 		lds r24,pwmOldValues+2
 802 04b6 87BD      		out 0x27,r24
1198:switcherator.c ****     switchChanged = 1;
 803               		.loc 1 1198 0
 804 04b8 81E0      		ldi r24,lo8(1)
 805 04ba 8093 0000 		sts switchChanged,r24
 806 04be 0895      		ret
 807               	.LFE30:
 809               	.global	clearTheProgram
 811               	clearTheProgram:
 812               	.LFB33:
1199:switcherator.c **** }
1200:switcherator.c **** 
1201:switcherator.c **** 
1202:switcherator.c **** 
1203:switcherator.c **** /****************************************************************
1204:switcherator.c ****  *
1205:switcherator.c ****  *              All Things Program Related
1206:switcherator.c ****  *
1207:switcherator.c ****  ****************************************************************/
1208:switcherator.c **** 
1209:switcherator.c **** // programs and such kept in EEPROM
1210:switcherator.c **** // 1 byte day of week mask or 0 for everyday
1211:switcherator.c **** // 2 byte start time (minutes), 2 bytes duration (seconds), 1 byte additional program
1212:switcherator.c **** // If more than 4 switches are desired it will roll over to an additional program
1213:switcherator.c **** // DssddSSSSP
1214:switcherator.c **** // 0123456789   
1215:switcherator.c **** //static unsigned char weeklyProgram[MAX_PROGRAM][10];
1216:switcherator.c **** //uart_puts_P("NewProgram, ClearProg, ProgAddSwitch, ProgDays, ProgTime, ProgDispln PN\r\n");
1217:switcherator.c **** //uart_puts_P("NP:P#HHMMDur. - CP:P# - PA:P#S# PD:P#SMTWTFS-PT:P#HHMMDur. PI:P#\r\n");
1218:switcherator.c **** //uart_puts_P("P#=Prog Num,HH=Hour,MM=Min,Dur.=Duration(min) SMTWTFS=1010000=Sun/Tue\r\n");
1219:switcherator.c **** 
1220:switcherator.c **** // Create a new program
1221:switcherator.c **** // NP:HHMMDur.
1222:switcherator.c **** // 0123456789012
1223:switcherator.c **** 
1224:switcherator.c **** void newProgram(char * commandReceived) {
1225:switcherator.c ****     int programNumber = 255;
1226:switcherator.c ****     int hours = 0;
1227:switcherator.c ****     int minutes = 0;
1228:switcherator.c ****     int startTime = 0;
1229:switcherator.c ****     int duration = 0;
1230:switcherator.c ****     int x = 0;
1231:switcherator.c ****     // find an open program;
1232:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
1233:switcherator.c ****         // dont want it to wrap though 0 is a valid program
1234:switcherator.c ****         if (weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) {
1235:switcherator.c ****             // Use this one
1236:switcherator.c ****             programNumber = x;
1237:switcherator.c ****             // end the loop
1238:switcherator.c ****             break;
1239:switcherator.c ****         }
1240:switcherator.c ****     }
1241:switcherator.c ****     if (programNumber == 255) {
1242:switcherator.c ****         fail(8);
1243:switcherator.c ****         return;
1244:switcherator.c ****     }
1245:switcherator.c ****     clearTheProgram(programNumber);
1246:switcherator.c ****     tempIntString[0] = commandReceived[3];
1247:switcherator.c ****     tempIntString[1] = commandReceived[4];
1248:switcherator.c ****     hours = atoi(tempIntString);
1249:switcherator.c ****     tempIntString[0] = commandReceived[5];
1250:switcherator.c ****     tempIntString[1] = commandReceived[6];
1251:switcherator.c ****     minutes = atoi(tempIntString);
1252:switcherator.c ****     tempLongString[0] = commandReceived[7];
1253:switcherator.c ****     tempLongString[1] = commandReceived[8];
1254:switcherator.c ****     tempLongString[2] = commandReceived[9];
1255:switcherator.c ****     tempLongString[3] = commandReceived[10];
1256:switcherator.c ****     duration = atoi(tempLongString);
1257:switcherator.c ****     if (hours >= 24 || (hours == 0 && commandReceived[4] != '0')) {
1258:switcherator.c ****         fail(9);
1259:switcherator.c ****         return;
1260:switcherator.c ****     }
1261:switcherator.c ****     if (minutes >= 60 || (minutes == 0 && commandReceived[6] != '0')) {
1262:switcherator.c ****         fail(0x0a);
1263:switcherator.c ****         return;
1264:switcherator.c ****     }
1265:switcherator.c ****     if (duration == 0) {
1266:switcherator.c ****         fail(0x0b);
1267:switcherator.c ****         return;
1268:switcherator.c ****     }
1269:switcherator.c ****     duration *= 60; // convert to seconds
1270:switcherator.c ****     startTime = (hours * 60);
1271:switcherator.c ****     startTime += minutes; // stored in minutes
1272:switcherator.c ****     int temp = 0;
1273:switcherator.c ****     temp = (startTime >> 8);
1274:switcherator.c ****     weeklyProgram[programNumber][1] = temp;
1275:switcherator.c ****     temp = (startTime & 0xff);
1276:switcherator.c ****     weeklyProgram[programNumber][2] = temp;
1277:switcherator.c ****     temp = (duration >> 8);
1278:switcherator.c ****     weeklyProgram[programNumber][3] = temp;
1279:switcherator.c ****     temp = (duration & 0xff);
1280:switcherator.c ****     weeklyProgram[programNumber][4] = temp;
1281:switcherator.c ****     statusMsg[0] = 0;
1282:switcherator.c ****     strcat(statusMsg, "New prog#");
1283:switcherator.c ****     returnInt(programNumber, tempIntString);
1284:switcherator.c ****     strcat(statusMsg, tempIntString);
1285:switcherator.c ****     sendMessage(statusMsg);
1286:switcherator.c **** }
1287:switcherator.c **** 
1288:switcherator.c **** // clears an existing program
1289:switcherator.c **** // the clearTheProgram does the work so this is the interface
1290:switcherator.c **** // CP:P#
1291:switcherator.c **** // 01234
1292:switcherator.c **** 
1293:switcherator.c **** void clearProgram(char * commandReceived) {
1294:switcherator.c ****     int programNumber = getSwitchNumber(commandReceived);
1295:switcherator.c ****     if (programNumber >= MAX_PROGRAM || (programNumber == 0 && commandReceived[4] != '0')) {
1296:switcherator.c ****         fail(2);
1297:switcherator.c ****     } else {
1298:switcherator.c ****         itoa(programNumber, tempIntString, 10);
1299:switcherator.c ****         ok();
1300:switcherator.c ****         clearTheProgram(programNumber);
1301:switcherator.c ****     }
1302:switcherator.c **** }
1303:switcherator.c **** 
1304:switcherator.c **** // zeros out the program
1305:switcherator.c **** 
1306:switcherator.c **** void clearTheProgram(int programNumber) {
 813               		.loc 1 1306 0
 814               	.LVL39:
 815               	/* prologue: function */
 816               	/* frame size = 0 */
 817               	/* stack size = 0 */
 818               	.L__stack_usage = 0
 819               		.loc 1 1306 0
 820 04c0 2AE0      		ldi r18,lo8(10)
 821 04c2 AC01      		movw r20,r24
 822 04c4 249F      		mul r18,r20
 823 04c6 C001      		movw r24,r0
 824 04c8 259F      		mul r18,r21
 825 04ca 900D      		add r25,r0
 826 04cc 1124      		clr __zero_reg__
 827               	.LVL40:
 828 04ce 8050      		subi r24,lo8(-(weeklyProgram))
 829 04d0 9040      		sbci r25,hi8(-(weeklyProgram))
1307:switcherator.c ****     int x = 0;
1308:switcherator.c ****     // some of these "0" is a valid option so make it 255
1309:switcherator.c ****     for (x = 0; x < 10; x++) {
 830               		.loc 1 1309 0
 831 04d2 20E0      		ldi r18,0
 832 04d4 30E0      		ldi r19,0
1310:switcherator.c ****         weeklyProgram[programNumber][x] = 255;
 833               		.loc 1 1310 0
 834 04d6 4FEF      		ldi r20,lo8(-1)
 835               	.LVL41:
 836               	.L51:
1306:switcherator.c **** void clearTheProgram(int programNumber) {
 837               		.loc 1 1306 0 discriminator 2
 838 04d8 FC01      		movw r30,r24
 839 04da E20F      		add r30,r18
 840 04dc F31F      		adc r31,r19
 841               		.loc 1 1310 0 discriminator 2
 842 04de 4083      		st Z,r20
1309:switcherator.c ****     for (x = 0; x < 10; x++) {
 843               		.loc 1 1309 0 discriminator 2
 844 04e0 2F5F      		subi r18,-1
 845 04e2 3F4F      		sbci r19,-1
 846               	.LVL42:
 847 04e4 2A30      		cpi r18,10
 848 04e6 3105      		cpc r19,__zero_reg__
 849 04e8 01F4      		brne .L51
 850               	/* epilogue start */
1311:switcherator.c ****     }
1312:switcherator.c **** }
 851               		.loc 1 1312 0
 852 04ea 0895      		ret
 853               	.LFE33:
 855               	.global	findOpenSwitch
 857               	findOpenSwitch:
 858               	.LFB35:
1313:switcherator.c **** 
1314:switcherator.c **** // there are multiple switches per program.  This adds them.
1315:switcherator.c **** // For memory constraints each program natively has up to 4
1316:switcherator.c **** // switches.  For more than that another program will be linked
1317:switcherator.c **** // Program in memory:
1318:switcherator.c **** // DssddSSSSP
1319:switcherator.c **** // 0123456789
1320:switcherator.c **** // PA:P#S#
1321:switcherator.c **** // 0123456
1322:switcherator.c **** 
1323:switcherator.c **** void programAddSwitch(char * commandReceived) {
1324:switcherator.c ****     int programNumber = 0;
1325:switcherator.c ****     int switchNumber = 0;
1326:switcherator.c ****     tempIntString[0] = commandReceived[3];
1327:switcherator.c ****     tempIntString[1] = commandReceived[4];
1328:switcherator.c ****     programNumber = atoi(tempIntString);
1329:switcherator.c ****     tempIntString[0] = commandReceived[5];
1330:switcherator.c ****     tempIntString[1] = commandReceived[6];
1331:switcherator.c ****     switchNumber = atoi(tempIntString);
1332:switcherator.c ****     char switches[NUM_SWITCHES];
1333:switcherator.c ****     switches[0] = 0;
1334:switcherator.c ****     int switchCount = programGetSwitches(programNumber, switches);
1335:switcherator.c ****     int x = 0;
1336:switcherator.c ****     // see if the switch is already there
1337:switcherator.c ****     for (x = 0; x < switchCount; x++) {
1338:switcherator.c ****         if (switches[x] == switchNumber) {
1339:switcherator.c ****             fail(0x0c);
1340:switcherator.c ****             return;
1341:switcherator.c ****         }
1342:switcherator.c ****     }
1343:switcherator.c **** 
1344:switcherator.c ****     // check validity 
1345:switcherator.c ****     if ((programNumber >= MAX_PROGRAM) || (programNumber == 0 && commandReceived[4] != '0')) {
1346:switcherator.c ****         fail(2);
1347:switcherator.c ****         return;
1348:switcherator.c ****     }
1349:switcherator.c ****     if ((switchNumber >= NUM_SWITCHES) || (switchNumber == 0 && commandReceived[6] != '0')) {
1350:switcherator.c ****         fail(1);
1351:switcherator.c ****         return;
1352:switcherator.c ****     }
1353:switcherator.c ****     // check for valid program
1354:switcherator.c ****     // The day mask maxes out at 127 - the high but shouldn't be set if it is valid
1355:switcherator.c ****     // unless it is a overflow program in which case the first switch will be set
1356:switcherator.c ****     // 255 = not set
1357:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
1358:switcherator.c ****         fail(0x0d);
1359:switcherator.c ****         return;
1360:switcherator.c ****     }
1361:switcherator.c ****     int noSwitchYet = 1;
1362:switcherator.c ****     int blankSwitch = 0;
1363:switcherator.c ****     int overflowProgram = 255;
1364:switcherator.c ****     // prepare number string for output later
1365:switcherator.c ****     itoa(programNumber, tempIntString, 10);
1366:switcherator.c ****     // see if our program has a valid switch
1367:switcherator.c ****     blankSwitch = findOpenSwitch(programNumber);
1368:switcherator.c ****     while (noSwitchYet == 1) {
1369:switcherator.c ****         if (blankSwitch == 0) {
1370:switcherator.c ****             // our program is full.  Find or make another one
1371:switcherator.c ****             // first check if we already are overflowing.
1372:switcherator.c ****             overflowProgram = weeklyProgram[programNumber][9];
1373:switcherator.c ****             if (overflowProgram == 255) {
1374:switcherator.c ****                 // no overflow.  Need to create one.
1375:switcherator.c ****                 // find blank program slot
1376:switcherator.c ****                 int possibleBlank = 255;
1377:switcherator.c ****                 // yeah I know but programNumber 0 won't be an overflow so there
1378:switcherator.c ****                 for (x = (MAX_PROGRAM - 1); x > 0; x--) {
1379:switcherator.c ****                     // dont want it to wrap though 0 is a valid program
1380:switcherator.c ****                     if (weeklyProgram[x][0] == 255 && weeklyProgram[x][5] == 255) {
1381:switcherator.c ****                         // this is blank
1382:switcherator.c ****                         possibleBlank = x;
1383:switcherator.c ****                         // end the loop
1384:switcherator.c ****                         x = 0;
1385:switcherator.c ****                     }
1386:switcherator.c ****                 }
1387:switcherator.c ****                 if (possibleBlank == 255) {
1388:switcherator.c ****                     // oh oh, no room
1389:switcherator.c ****                     fail(0x0e);
1390:switcherator.c ****                     return;
1391:switcherator.c ****                 }
1392:switcherator.c ****                 // now record the overflow and move forward
1393:switcherator.c ****                 weeklyProgram[programNumber][9] = possibleBlank;
1394:switcherator.c ****                 programNumber = possibleBlank;
1395:switcherator.c ****                 // and now we loop again...
1396:switcherator.c ****             } else {
1397:switcherator.c ****                 // move to overflow program and try again
1398:switcherator.c ****                 programNumber = overflowProgram;
1399:switcherator.c ****             }
1400:switcherator.c ****         } else { // if(blankSwitch == 0)
1401:switcherator.c ****             // we have a program and a slot.  move on.
1402:switcherator.c ****             noSwitchYet = 0;
1403:switcherator.c ****         }
1404:switcherator.c ****     }
1405:switcherator.c ****     weeklyProgram[programNumber][blankSwitch] = switchNumber;
1406:switcherator.c ****     ok();
1407:switcherator.c **** }
1408:switcherator.c **** 
1409:switcherator.c **** // iterates through a program and returns the index of an open switch or 0 if none
1410:switcherator.c **** 
1411:switcherator.c **** int findOpenSwitch(int programNumber) {
 859               		.loc 1 1411 0
 860               	.LVL43:
 861               	/* prologue: function */
 862               	/* frame size = 0 */
 863               	/* stack size = 0 */
 864               	.L__stack_usage = 0
 865               		.loc 1 1411 0
 866 04ec 2AE0      		ldi r18,lo8(10)
 867 04ee AC01      		movw r20,r24
 868 04f0 249F      		mul r18,r20
 869 04f2 C001      		movw r24,r0
 870 04f4 259F      		mul r18,r21
 871 04f6 900D      		add r25,r0
 872 04f8 1124      		clr __zero_reg__
 873               	.LVL44:
 874 04fa 8050      		subi r24,lo8(-(weeklyProgram))
 875 04fc 9040      		sbci r25,hi8(-(weeklyProgram))
1412:switcherator.c ****     int switchIndex = 0;
1413:switcherator.c ****     int x = 0;
1414:switcherator.c ****     for (x = 5; x < 9; x++) {
 876               		.loc 1 1414 0
 877 04fe 25E0      		ldi r18,lo8(5)
 878 0500 30E0      		ldi r19,0
 879               	.LVL45:
 880               	.L55:
1411:switcherator.c **** int findOpenSwitch(int programNumber) {
 881               		.loc 1 1411 0
 882 0502 FC01      		movw r30,r24
 883 0504 E20F      		add r30,r18
 884 0506 F31F      		adc r31,r19
1415:switcherator.c ****         if (weeklyProgram[programNumber][x] == 255) {
 885               		.loc 1 1415 0
 886 0508 4081      		ld r20,Z
 887 050a 4F3F      		cpi r20,lo8(-1)
 888 050c 01F0      		breq .L54
1414:switcherator.c ****     for (x = 5; x < 9; x++) {
 889               		.loc 1 1414 0
 890 050e 2F5F      		subi r18,-1
 891 0510 3F4F      		sbci r19,-1
 892               	.LVL46:
 893 0512 2930      		cpi r18,9
 894 0514 3105      		cpc r19,__zero_reg__
 895 0516 01F4      		brne .L55
1416:switcherator.c ****             // blank switch
1417:switcherator.c ****             switchIndex = x;
1418:switcherator.c ****             return switchIndex;
1419:switcherator.c ****         }
1420:switcherator.c ****     }
1421:switcherator.c ****     return 0;
 896               		.loc 1 1421 0
 897 0518 20E0      		ldi r18,0
 898 051a 30E0      		ldi r19,0
 899               	.LVL47:
 900               	.L54:
1422:switcherator.c **** }
 901               		.loc 1 1422 0
 902 051c C901      		movw r24,r18
 903 051e 0895      		ret
 904               	.LFE35:
 906               	.global	programGetSwitches
 908               	programGetSwitches:
 909               	.LFB39:
1423:switcherator.c **** 
1424:switcherator.c **** // Sets the days a program will run
1425:switcherator.c **** // PD:P#SMTWTFS
1426:switcherator.c **** // 012345678901
1427:switcherator.c **** 
1428:switcherator.c **** void programSetDays(char * commandReceived) {
1429:switcherator.c ****     char tempReallyLongString[] = "0000000";
1430:switcherator.c ****     int programNumber = 0;
1431:switcherator.c ****     long weekLong = 0;
1432:switcherator.c ****     tempIntString[0] = commandReceived[3];
1433:switcherator.c ****     tempIntString[1] = commandReceived[4];
1434:switcherator.c ****     programNumber = atoi(tempIntString);
1435:switcherator.c ****     tempReallyLongString[0] = commandReceived[5];
1436:switcherator.c ****     tempReallyLongString[1] = commandReceived[6];
1437:switcherator.c ****     tempReallyLongString[2] = commandReceived[7];
1438:switcherator.c ****     tempReallyLongString[3] = commandReceived[8];
1439:switcherator.c ****     tempReallyLongString[4] = commandReceived[9];
1440:switcherator.c ****     tempReallyLongString[5] = commandReceived[10];
1441:switcherator.c ****     tempReallyLongString[6] = commandReceived[11];
1442:switcherator.c ****     weekLong = strtol(tempReallyLongString, 0, 2);
1443:switcherator.c ****     if ((programNumber >= MAX_PROGRAM) || (programNumber == 0 && commandReceived[4] != '0')) {
1444:switcherator.c ****         fail(2);
1445:switcherator.c ****         return;
1446:switcherator.c ****     }
1447:switcherator.c ****     // check for valid program
1448:switcherator.c ****     // The day mask maxes out at 127 - the high but shouldn't be set if it is valid
1449:switcherator.c ****     // unless it is a overflow program in which case the first switch will be set
1450:switcherator.c ****     // 255 = not set
1451:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
1452:switcherator.c ****         fail(0x0d);
1453:switcherator.c ****         return;
1454:switcherator.c ****     }
1455:switcherator.c ****     if ((weekLong & 0x7f) == 0) {
1456:switcherator.c ****         fail(0x0f);
1457:switcherator.c ****         return;
1458:switcherator.c ****     }
1459:switcherator.c ****     char weekdays = (weekLong & 0x7f);
1460:switcherator.c ****     weeklyProgram[programNumber][0] = weekdays;
1461:switcherator.c ****     ok();
1462:switcherator.c **** }
1463:switcherator.c **** 
1464:switcherator.c **** // DssddSSSSP
1465:switcherator.c **** // 0123456789   
1466:switcherator.c **** // PT:P#HHMMDur.
1467:switcherator.c **** // 0123456789012
1468:switcherator.c **** 
1469:switcherator.c **** void programSetTime(char * commandReceived) {
1470:switcherator.c ****     int programNumber = 0;
1471:switcherator.c ****     int hours = 0;
1472:switcherator.c ****     int minutes = 0;
1473:switcherator.c ****     int startTime = 0;
1474:switcherator.c ****     int duration = 0;
1475:switcherator.c ****     tempIntString[0] = commandReceived[3];
1476:switcherator.c ****     tempIntString[1] = commandReceived[4];
1477:switcherator.c ****     programNumber = atoi(tempIntString);
1478:switcherator.c ****     if (programNumber >= MAX_PROGRAM || (programNumber == 0 && commandReceived[4] != '0')) {
1479:switcherator.c ****         fail(2);
1480:switcherator.c ****         return;
1481:switcherator.c ****     }
1482:switcherator.c ****     // check for valid program
1483:switcherator.c ****     // The day mask maxes out at 127 - the high but shouldn't be set if it is valid
1484:switcherator.c ****     // unless it is a overflow program in which case the first switch will be set
1485:switcherator.c ****     // 255 = not set
1486:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
1487:switcherator.c ****         fail(0x0d);
1488:switcherator.c ****         return;
1489:switcherator.c ****     }
1490:switcherator.c ****     tempIntString[0] = commandReceived[5];
1491:switcherator.c ****     tempIntString[1] = commandReceived[6];
1492:switcherator.c ****     hours = atoi(tempIntString);
1493:switcherator.c ****     tempIntString[0] = commandReceived[7];
1494:switcherator.c ****     tempIntString[1] = commandReceived[8];
1495:switcherator.c ****     minutes = atoi(tempIntString);
1496:switcherator.c ****     tempLongString[0] = commandReceived[9];
1497:switcherator.c ****     tempLongString[1] = commandReceived[10];
1498:switcherator.c ****     tempLongString[2] = commandReceived[11];
1499:switcherator.c ****     tempLongString[3] = commandReceived[12];
1500:switcherator.c ****     duration = atoi(tempLongString);
1501:switcherator.c ****     if (hours >= 24 || (hours == 0 && commandReceived[6] != '0')) {
1502:switcherator.c ****         fail(9);
1503:switcherator.c ****         return;
1504:switcherator.c ****     }
1505:switcherator.c ****     if (minutes >= 60 || (minutes == 0 && commandReceived[8] != '0')) {
1506:switcherator.c ****         fail(0x0a);
1507:switcherator.c ****         return;
1508:switcherator.c ****     }
1509:switcherator.c ****     if (duration == 0) {
1510:switcherator.c ****         fail(0x0b);
1511:switcherator.c ****         return;
1512:switcherator.c ****     }
1513:switcherator.c ****     duration *= 60; // convert to seconds
1514:switcherator.c ****     startTime = (hours * 60);
1515:switcherator.c ****     startTime += minutes; // stored in minutes
1516:switcherator.c ****     int temp = 0;
1517:switcherator.c ****     temp = (startTime >> 8);
1518:switcherator.c ****     weeklyProgram[programNumber][1] = temp;
1519:switcherator.c ****     temp = (startTime & 0xff);
1520:switcherator.c ****     weeklyProgram[programNumber][2] = temp;
1521:switcherator.c ****     temp = (duration >> 8);
1522:switcherator.c ****     weeklyProgram[programNumber][3] = temp;
1523:switcherator.c ****     temp = (duration & 0xff);
1524:switcherator.c ****     weeklyProgram[programNumber][4] = temp;
1525:switcherator.c ****     ok();
1526:switcherator.c **** }
1527:switcherator.c **** 
1528:switcherator.c **** void programDisplay(char * commandReceived) {
1529:switcherator.c ****     int x = 0;
1530:switcherator.c ****     int programNumber = 0;
1531:switcherator.c ****     tempIntString[0] = commandReceived[3];
1532:switcherator.c ****     tempIntString[1] = commandReceived[4];
1533:switcherator.c ****     programNumber = atoi(tempIntString);
1534:switcherator.c ****     statusMsg[0] = 0;
1535:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
1536:switcherator.c ****         strcat(statusMsg, "Prog#");
1537:switcherator.c ****         returnInt(programNumber, tempIntString);
1538:switcherator.c ****         strcat(statusMsg, tempIntString);
1539:switcherator.c ****         strcat(statusMsg, "blank.");
1540:switcherator.c ****         sendMessage(statusMsg);
1541:switcherator.c ****         return;
1542:switcherator.c ****     }
1543:switcherator.c ****     char switches[NUM_SWITCHES];
1544:switcherator.c ****     switches[0] = 0;
1545:switcherator.c ****     int switchCount = 0;
1546:switcherator.c ****     switchCount = programGetSwitches(programNumber, switches);
1547:switcherator.c ****     statusMsg[0] = 0;
1548:switcherator.c ****     strcat(statusMsg, "Prog#");
1549:switcherator.c ****     itoa(programNumber, tempIntString, 10);
1550:switcherator.c ****     strcat(statusMsg, tempIntString);
1551:switcherator.c ****     if (switchCount == 0) {
1552:switcherator.c ****         strcat(switches, "S:-");
1553:switcherator.c ****     } else {
1554:switcherator.c ****         int temp = 0;
1555:switcherator.c ****         strcat(statusMsg, "S");
1556:switcherator.c ****         for (x = 0; x < switchCount; x++) {
1557:switcherator.c ****             if(strlen(statusMsg)>30) {
1558:switcherator.c ****                 sendMessage(statusMsg);
1559:switcherator.c ****                 statusMsg[6] = 0;
1560:switcherator.c ****             }
1561:switcherator.c ****             strcat(statusMsg, ":");
1562:switcherator.c ****             temp = switches[x];
1563:switcherator.c ****             itoa(temp, tempIntString, 10);
1564:switcherator.c ****             strcat(statusMsg, tempIntString);
1565:switcherator.c ****         }
1566:switcherator.c ****     }
1567:switcherator.c ****     sendMessage(statusMsg);
1568:switcherator.c ****     statusMsg[0] = 0;
1569:switcherator.c ****     unsigned int time = 0;
1570:switcherator.c ****     time = weeklyProgram[programNumber][1];
1571:switcherator.c ****     time <<= 8;
1572:switcherator.c ****     time |= weeklyProgram[programNumber][2];
1573:switcherator.c ****     unsigned int hours = (time / 60);
1574:switcherator.c ****     unsigned int minutes = (time - (hours * 60));
1575:switcherator.c ****     time = weeklyProgram[programNumber][3];
1576:switcherator.c ****     time <<= 8;
1577:switcherator.c ****     time |= weeklyProgram[programNumber][4];
1578:switcherator.c ****     int duration = (time / 60);
1579:switcherator.c ****     char weekdays = 0;
1580:switcherator.c ****     weekdays = weeklyProgram[programNumber][0];
1581:switcherator.c ****     strcat(statusMsg, "T-");
1582:switcherator.c ****     itoa(hours, tempIntString, 10);
1583:switcherator.c ****     strcat(statusMsg, tempIntString);
1584:switcherator.c ****     strcat(statusMsg, ":");
1585:switcherator.c ****     itoa(minutes, tempIntString, 10);
1586:switcherator.c ****     strcat(statusMsg, tempIntString);
1587:switcherator.c ****     strcat(statusMsg, " Dur:");
1588:switcherator.c ****     itoa(duration, tempLongString, 10);
1589:switcherator.c ****     strcat(statusMsg, tempLongString);
1590:switcherator.c ****     strcat(statusMsg, " D:");
1591:switcherator.c ****     if (weekdays == 255) {
1592:switcherator.c ****         strcat(statusMsg, "-------");
1593:switcherator.c ****         sendMessage(statusMsg);
1594:switcherator.c ****         return;
1595:switcherator.c ****     }
1596:switcherator.c ****     if (weekdays & 0x40) {
1597:switcherator.c ****         strcat(statusMsg, "S");
1598:switcherator.c ****     } else {
1599:switcherator.c ****         strcat(statusMsg, "-");
1600:switcherator.c ****     }
1601:switcherator.c ****     if (weekdays & 0x20) {
1602:switcherator.c ****         strcat(statusMsg, "M");
1603:switcherator.c ****     } else {
1604:switcherator.c ****         strcat(statusMsg, "-");
1605:switcherator.c ****     }
1606:switcherator.c ****     if (weekdays & 0x10) {
1607:switcherator.c ****         strcat(statusMsg, "T");
1608:switcherator.c ****     } else {
1609:switcherator.c ****         strcat(statusMsg, "-");
1610:switcherator.c ****     }
1611:switcherator.c ****     if (weekdays & 0x08) {
1612:switcherator.c ****         strcat(statusMsg, "W");
1613:switcherator.c ****     } else {
1614:switcherator.c ****         strcat(statusMsg, "-");
1615:switcherator.c ****     }
1616:switcherator.c ****     if (weekdays & 0x04) {
1617:switcherator.c ****         strcat(statusMsg, "T");
1618:switcherator.c ****     } else {
1619:switcherator.c ****         strcat(statusMsg, "-");
1620:switcherator.c ****     }
1621:switcherator.c ****     if (weekdays & 0x02) {
1622:switcherator.c ****         strcat(statusMsg, "F");
1623:switcherator.c ****     } else {
1624:switcherator.c ****         strcat(statusMsg, "-");
1625:switcherator.c ****     }
1626:switcherator.c ****     if (weekdays & 0x01) {
1627:switcherator.c ****         strcat(statusMsg, "S");
1628:switcherator.c ****     } else {
1629:switcherator.c ****         strcat(statusMsg, "-");
1630:switcherator.c ****     }
1631:switcherator.c **** 
1632:switcherator.c ****     sendMessage(statusMsg);
1633:switcherator.c **** }
1634:switcherator.c **** 
1635:switcherator.c **** // get the switches for a program
1636:switcherator.c **** // char * switches should be set as large as NUM_SWITCHES
1637:switcherator.c **** // so you don't overflow
1638:switcherator.c **** 
1639:switcherator.c **** int programGetSwitches(int programNumber, char * switches) {
 910               		.loc 1 1639 0
 911               	.LVL48:
 912 0520 CF93      		push r28
 913               	.LCFI8:
 914 0522 DF93      		push r29
 915               	.LCFI9:
 916               	/* prologue: function */
 917               	/* frame size = 0 */
 918               	/* stack size = 2 */
 919               	.L__stack_usage = 2
 920               	.LVL49:
1640:switcherator.c ****     int element = 0;
 921               		.loc 1 1640 0
 922 0524 20E0      		ldi r18,0
 923 0526 30E0      		ldi r19,0
1639:switcherator.c **** int programGetSwitches(int programNumber, char * switches) {
 924               		.loc 1 1639 0
 925 0528 CAE0      		ldi r28,lo8(10)
 926               	.LVL50:
 927               	.L61:
 928 052a F901      		movw r30,r18
 929 052c 3496      		adiw r30,4
 930 052e C89F      		mul r28,r24
 931 0530 A001      		movw r20,r0
 932 0532 C99F      		mul r28,r25
 933 0534 500D      		add r21,r0
 934 0536 1124      		clr __zero_reg__
 935 0538 421B      		sub r20,r18
 936 053a 530B      		sbc r21,r19
 937 053c 4050      		subi r20,lo8(-(weeklyProgram))
 938 053e 5040      		sbci r21,hi8(-(weeklyProgram))
 939               	.LVL51:
 940               	.L60:
 941 0540 DA01      		movw r26,r20
 942 0542 A20F      		add r26,r18
 943 0544 B31F      		adc r27,r19
1641:switcherator.c ****     int x = 0;
1642:switcherator.c ****     // start loading the switch array
1643:switcherator.c ****     while (1) {
1644:switcherator.c ****         for (x = 5; x < 9; x++) {
1645:switcherator.c ****             if (weeklyProgram[programNumber][x] == 255) {
 944               		.loc 1 1645 0
 945 0546 1596      		adiw r26,5
 946 0548 DC91      		ld r29,X
 947 054a DF3F      		cpi r29,lo8(-1)
 948 054c 01F0      		breq .L59
1639:switcherator.c **** int programGetSwitches(int programNumber, char * switches) {
 949               		.loc 1 1639 0
 950 054e DB01      		movw r26,r22
 951 0550 A20F      		add r26,r18
 952 0552 B31F      		adc r27,r19
1646:switcherator.c ****                 // blank switch we are done
1647:switcherator.c ****                 return element;
1648:switcherator.c ****             } else {
1649:switcherator.c ****                 switches[element] = weeklyProgram[programNumber][x];
 953               		.loc 1 1649 0
 954 0554 DC93      		st X,r29
1650:switcherator.c ****                 element++;
 955               		.loc 1 1650 0
 956 0556 2F5F      		subi r18,-1
 957 0558 3F4F      		sbci r19,-1
 958               	.LVL52:
1644:switcherator.c ****         for (x = 5; x < 9; x++) {
 959               		.loc 1 1644 0
 960 055a 2E17      		cp r18,r30
 961 055c 3F07      		cpc r19,r31
 962 055e 01F4      		brne .L60
1651:switcherator.c ****             }
1652:switcherator.c ****         } // for x=5-9
1653:switcherator.c ****         // see if this program iterates around
1654:switcherator.c ****         if (weeklyProgram[programNumber][9] == 255) {
 963               		.loc 1 1654 0
 964 0560 C89F      		mul r28,r24
 965 0562 F001      		movw r30,r0
 966 0564 C99F      		mul r28,r25
 967 0566 F00D      		add r31,r0
 968 0568 1124      		clr __zero_reg__
 969 056a E050      		subi r30,lo8(-(weeklyProgram))
 970 056c F040      		sbci r31,hi8(-(weeklyProgram))
 971 056e 8185      		ldd r24,Z+9
 972               	.LVL53:
 973 0570 8F3F      		cpi r24,lo8(-1)
 974 0572 01F0      		breq .L59
1655:switcherator.c ****             // we are done;
1656:switcherator.c ****             return element;
1657:switcherator.c ****         } else {
1658:switcherator.c ****             // move to the next programNumber and continue
1659:switcherator.c ****             programNumber = weeklyProgram[programNumber][9];
 975               		.loc 1 1659 0
 976 0574 90E0      		ldi r25,0
 977               	.LVL54:
1660:switcherator.c ****         }
1661:switcherator.c ****     }
 978               		.loc 1 1661 0
 979 0576 00C0      		rjmp .L61
 980               	.LVL55:
 981               	.L59:
1662:switcherator.c **** }
 982               		.loc 1 1662 0
 983 0578 C901      		movw r24,r18
 984               	/* epilogue start */
 985 057a DF91      		pop r29
 986 057c CF91      		pop r28
 987 057e 0895      		ret
 988               	.LFE39:
 990               	.global	startTheProgram
 992               	startTheProgram:
 993               	.LFB41:
1663:switcherator.c **** 
1664:switcherator.c **** // takes in a program number and time and turns on the program
1665:switcherator.c **** // SP P#Durat.
1666:switcherator.c **** // 01234567890
1667:switcherator.c **** 
1668:switcherator.c **** void startProgram(char * commandReceived) {
1669:switcherator.c ****     unsigned long duration;
1670:switcherator.c ****     int programNumber = 0;
1671:switcherator.c ****     // get switch number
1672:switcherator.c ****     tempIntString[0] = commandReceived[3];
1673:switcherator.c ****     tempIntString[1] = commandReceived[4];
1674:switcherator.c ****     programNumber = atoi(tempIntString);
1675:switcherator.c ****     if (programNumber >= MAX_PROGRAM) {
1676:switcherator.c ****         fail(2);
1677:switcherator.c ****         return;
1678:switcherator.c ****     }
1679:switcherator.c ****     // get duration
1680:switcherator.c ****     tempHugeString[0] = commandReceived[5];
1681:switcherator.c ****     tempHugeString[1] = commandReceived[6];
1682:switcherator.c ****     tempHugeString[2] = commandReceived[7];
1683:switcherator.c ****     tempHugeString[3] = commandReceived[8];
1684:switcherator.c ****     tempHugeString[4] = commandReceived[9];
1685:switcherator.c ****     tempHugeString[5] = commandReceived[10];
1686:switcherator.c ****     duration = atol(tempHugeString);
1687:switcherator.c ****     startTheProgram(programNumber, duration, 0);
1688:switcherator.c ****     ok();
1689:switcherator.c **** }
1690:switcherator.c **** 
1691:switcherator.c **** void startTheProgram(int programNumber, int duration, long time) {
 994               		.loc 1 1691 0
 995               	.LVL56:
 996 0580 8F92      		push r8
 997               	.LCFI10:
 998 0582 9F92      		push r9
 999               	.LCFI11:
 1000 0584 AF92      		push r10
 1001               	.LCFI12:
 1002 0586 BF92      		push r11
 1003               	.LCFI13:
 1004 0588 CF92      		push r12
 1005               	.LCFI14:
 1006 058a DF92      		push r13
 1007               	.LCFI15:
 1008 058c EF92      		push r14
 1009               	.LCFI16:
 1010 058e FF92      		push r15
 1011               	.LCFI17:
 1012 0590 1F93      		push r17
 1013               	.LCFI18:
 1014 0592 CF93      		push r28
 1015               	.LCFI19:
 1016 0594 DF93      		push r29
 1017               	.LCFI20:
 1018 0596 CDB7      		in r28,__SP_L__
 1019 0598 DEB7      		in r29,__SP_H__
 1020               	.LCFI21:
 1021 059a 6497      		sbiw r28,20
 1022               	.LCFI22:
 1023 059c 0FB6      		in __tmp_reg__,__SREG__
 1024 059e F894      		cli
 1025 05a0 DEBF      		out __SP_H__,r29
 1026 05a2 0FBE      		out __SREG__,__tmp_reg__
 1027 05a4 CDBF      		out __SP_L__,r28
 1028               	/* prologue: function */
 1029               	/* frame size = 20 */
 1030               	/* stack size = 31 */
 1031               	.L__stack_usage = 31
 1032 05a6 4B01      		movw r8,r22
 1033               	.LVL57:
1692:switcherator.c ****     char switches[NUM_SWITCHES];
1693:switcherator.c ****     int switchCount = 0;
1694:switcherator.c ****     int thisSwitch = 0;
1695:switcherator.c ****     int x = 0;
1696:switcherator.c **** 
1697:switcherator.c ****     if (duration == 0) {
 1034               		.loc 1 1697 0
 1035 05a8 6115      		cp r22,__zero_reg__
 1036 05aa 7105      		cpc r23,__zero_reg__
 1037 05ac 01F4      		brne .L70
 1038               	.LVL58:
1698:switcherator.c ****         // get the duration since we weren't fed it
1699:switcherator.c ****         duration = weeklyProgram[programNumber][3];
1700:switcherator.c ****         duration <<= 8;
1701:switcherator.c ****         duration = weeklyProgram[programNumber][4];
 1039               		.loc 1 1701 0
 1040 05ae 6AE0      		ldi r22,lo8(10)
 1041 05b0 689F      		mul r22,r24
 1042 05b2 F001      		movw r30,r0
 1043 05b4 699F      		mul r22,r25
 1044 05b6 F00D      		add r31,r0
 1045 05b8 1124      		clr __zero_reg__
 1046 05ba E050      		subi r30,lo8(-(weeklyProgram))
 1047 05bc F040      		sbci r31,hi8(-(weeklyProgram))
 1048 05be 8480      		ldd r8,Z+4
 1049 05c0 912C      		mov r9,__zero_reg__
 1050               	.LVL59:
 1051               	.L70:
1702:switcherator.c ****     }
1703:switcherator.c ****     switchCount = programGetSwitches(programNumber, switches);
 1052               		.loc 1 1703 0
 1053 05c2 BE01      		movw r22,r28
 1054 05c4 6F5F      		subi r22,-1
 1055 05c6 7F4F      		sbci r23,-1
 1056 05c8 298B      		std Y+17,r18
 1057 05ca 3A8B      		std Y+18,r19
 1058 05cc 4B8B      		std Y+19,r20
 1059 05ce 5C8B      		std Y+20,r21
 1060 05d0 0E94 0000 		call programGetSwitches
 1061               	.LVL60:
 1062 05d4 AA24      		clr r10
 1063 05d6 97FC      		sbrc r9,7
 1064 05d8 A094      		com r10
 1065 05da BA2C      		mov r11,r10
 1066 05dc C090 0000 		lds r12,weeklySeconds
 1067 05e0 D090 0000 		lds r13,weeklySeconds+1
 1068 05e4 E090 0000 		lds r14,weeklySeconds+2
 1069 05e8 F090 0000 		lds r15,weeklySeconds+3
1704:switcherator.c ****     // see if we were fed the start time so we don't go too long
1705:switcherator.c ****     // this may run multiple times
1706:switcherator.c ****     if (time == 0) {
 1070               		.loc 1 1706 0
 1071 05ec 2989      		ldd r18,Y+17
 1072 05ee 3A89      		ldd r19,Y+18
 1073 05f0 4B89      		ldd r20,Y+19
 1074 05f2 5C89      		ldd r21,Y+20
 1075 05f4 2115      		cp r18,__zero_reg__
 1076 05f6 3105      		cpc r19,__zero_reg__
 1077 05f8 4105      		cpc r20,__zero_reg__
 1078 05fa 5105      		cpc r21,__zero_reg__
 1079 05fc 01F4      		brne .L71
1707:switcherator.c ****         time = weeklySeconds + duration;
 1080               		.loc 1 1707 0
 1081 05fe A501      		movw r20,r10
 1082 0600 9401      		movw r18,r8
 1083 0602 2C0D      		add r18,r12
 1084 0604 3D1D      		adc r19,r13
 1085 0606 4E1D      		adc r20,r14
 1086 0608 5F1D      		adc r21,r15
 1087               	.LVL61:
 1088               	.L71:
1708:switcherator.c ****     }
1709:switcherator.c ****     for (x = 0; x < switchCount; x++) {
1710:switcherator.c ****         thisSwitch = switches[x];
1711:switcherator.c ****         // only update the time if it is longer than what the switch is already turned on to
1712:switcherator.c ****         if ((weeklySeconds + duration) > switchStatus[thisSwitch])
 1089               		.loc 1 1712 0
 1090 060a C80C      		add r12,r8
 1091 060c D91C      		adc r13,r9
 1092 060e EA1C      		adc r14,r10
 1093 0610 FB1C      		adc r15,r11
 1094 0612 FE01      		movw r30,r28
 1095 0614 3196      		adiw r30,1
1691:switcherator.c **** void startTheProgram(int programNumber, int duration, long time) {
 1096               		.loc 1 1691 0
 1097 0616 BF01      		movw r22,r30
1709:switcherator.c ****     for (x = 0; x < switchCount; x++) {
 1098               		.loc 1 1709 0
 1099 0618 00C0      		rjmp .L77
 1100               	.LVL62:
 1101               	.L74:
1710:switcherator.c ****         thisSwitch = switches[x];
 1102               		.loc 1 1710 0
 1103 061a A191      		ld r26,Z+
 1104               	.LVL63:
 1105               		.loc 1 1712 0
 1106 061c 14E0      		ldi r17,lo8(4)
 1107 061e A19F      		mul r26,r17
 1108 0620 D001      		movw r26,r0
 1109 0622 1124      		clr __zero_reg__
 1110               	.LVL64:
 1111 0624 A050      		subi r26,lo8(-(switchStatus))
 1112 0626 B040      		sbci r27,hi8(-(switchStatus))
 1113 0628 8D90      		ld r8,X+
 1114 062a 9D90      		ld r9,X+
 1115 062c AD90      		ld r10,X+
 1116 062e BC90      		ld r11,X
 1117 0630 1397      		sbiw r26,3
 1118 0632 8C14      		cp r8,r12
 1119 0634 9D04      		cpc r9,r13
 1120 0636 AE04      		cpc r10,r14
 1121 0638 BF04      		cpc r11,r15
 1122 063a 00F4      		brsh .L77
1713:switcherator.c ****             switchStatus[thisSwitch] = time;
 1123               		.loc 1 1713 0
 1124 063c 2D93      		st X+,r18
 1125 063e 3D93      		st X+,r19
 1126 0640 4D93      		st X+,r20
 1127 0642 5C93      		st X,r21
 1128 0644 1397      		sbiw r26,3
 1129               	.LVL65:
 1130               	.L77:
1691:switcherator.c **** void startTheProgram(int programNumber, int duration, long time) {
 1131               		.loc 1 1691 0 discriminator 1
 1132 0646 DF01      		movw r26,r30
 1133 0648 A61B      		sub r26,r22
 1134 064a B70B      		sbc r27,r23
1709:switcherator.c ****     for (x = 0; x < switchCount; x++) {
 1135               		.loc 1 1709 0 discriminator 1
 1136 064c A817      		cp r26,r24
 1137 064e B907      		cpc r27,r25
 1138 0650 04F0      		brlt .L74
1714:switcherator.c ****     }
1715:switcherator.c ****     switchChanged = 1;
 1139               		.loc 1 1715 0
 1140 0652 81E0      		ldi r24,lo8(1)
 1141               	.LVL66:
 1142 0654 8093 0000 		sts switchChanged,r24
 1143               	/* epilogue start */
1716:switcherator.c **** }
 1144               		.loc 1 1716 0
 1145 0658 6496      		adiw r28,20
 1146 065a 0FB6      		in __tmp_reg__,__SREG__
 1147 065c F894      		cli
 1148 065e DEBF      		out __SP_H__,r29
 1149 0660 0FBE      		out __SREG__,__tmp_reg__
 1150 0662 CDBF      		out __SP_L__,r28
 1151 0664 DF91      		pop r29
 1152 0666 CF91      		pop r28
 1153 0668 1F91      		pop r17
 1154 066a FF90      		pop r15
 1155 066c EF90      		pop r14
 1156 066e DF90      		pop r13
 1157 0670 CF90      		pop r12
 1158 0672 BF90      		pop r11
 1159 0674 AF90      		pop r10
 1160 0676 9F90      		pop r9
 1161 0678 8F90      		pop r8
 1162 067a 0895      		ret
 1163               	.LFE41:
 1165               	.global	readEEPROM
 1167               	readEEPROM:
 1168               	.LFB43:
1717:switcherator.c **** 
1718:switcherator.c **** 
1719:switcherator.c **** /****************************************************************
1720:switcherator.c ****  *
1721:switcherator.c ****  *              All Things EEPROM Related
1722:switcherator.c ****  *
1723:switcherator.c ****  ****************************************************************/
1724:switcherator.c **** 
1725:switcherator.c **** // Get variables out of EEPROM and set things up
1726:switcherator.c **** 
1727:switcherator.c **** void generalInit(void) {
1728:switcherator.c ****     // read the program info
1729:switcherator.c ****     char tempStuff[14];
1730:switcherator.c ****     int x = 0;
1731:switcherator.c ****     // Go through the addresses and assign them if set
1732:switcherator.c ****     // decided later that this is a really bad idea. gets corrupted.  use default
1733:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_TX, RADIO_ADDR_TX_BYTES) == 1) {
1734:switcherator.c ****         tx_addr = formatAddress(tempStuff);
1735:switcherator.c ****         writeAddr(TX_ADDR, tx_addr);
1736:switcherator.c ****     }
1737:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R0, RADIO_ADDR_R0_BYTES) == 1) {
1738:switcherator.c ****         rx_addr_p0 = formatAddress(tempStuff);
1739:switcherator.c ****         writeAddr(RX_ADDR_P0, rx_addr_p0);
1740:switcherator.c ****     }
1741:switcherator.c **** 
1742:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R1, RADIO_ADDR_R1_BYTES) == 1) {
1743:switcherator.c ****         rx_addr_p1 = formatAddress(tempStuff);
1744:switcherator.c ****         writeAddr(RX_ADDR_P1, rx_addr_p1);
1745:switcherator.c ****     }
1746:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R2, RADIO_ADDR_R2_BYTES) == 1) {
1747:switcherator.c ****         rx_addr_p2 = tempStuff[0];
1748:switcherator.c ****         writeAddr(RX_ADDR_P2, rx_addr_p2);
1749:switcherator.c ****     }
1750:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R3, RADIO_ADDR_R3_BYTES) == 1) {
1751:switcherator.c ****         rx_addr_p3 = tempStuff[0];
1752:switcherator.c ****         writeAddr(RX_ADDR_P3, rx_addr_p3);
1753:switcherator.c ****     }
1754:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R4, RADIO_ADDR_R4_BYTES) == 1) {
1755:switcherator.c ****         rx_addr_p4 = tempStuff[0];
1756:switcherator.c ****         writeAddr(RX_ADDR_P4, rx_addr_p4);
1757:switcherator.c ****     }
1758:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R5, RADIO_ADDR_R5_BYTES) == 1) {
1759:switcherator.c ****         rx_addr_p5 = tempStuff[0];
1760:switcherator.c ****         writeAddr(RX_ADDR_P5, rx_addr_p5);
1761:switcherator.c ****     }
1762:switcherator.c ****     if (readEEPROM(tempStuff, TWEAK_TIMER, TWEAK_TIMER_BYTES) == 1) {
1763:switcherator.c ****         tweakTimer = tempStuff[0];
1764:switcherator.c ****         tweakTimer <<= 8;
1765:switcherator.c ****         tweakTimer |= tempStuff[1];
1766:switcherator.c ****     }
1767:switcherator.c **** 
1768:switcherator.c **** 
1769:switcherator.c ****     // process daylight savings
1770:switcherator.c ****     if (readEEPROM(tempStuff, DAYLIGHT_SAVE, DAYLIGHT_SAVE_BYTES) == 1) {
1771:switcherator.c ****         // Spring month
1772:switcherator.c ****         daylightSavings[0][0] = ((tempStuff[0] << 8) | (tempStuff[1]));
1773:switcherator.c ****         // Spring day
1774:switcherator.c ****         daylightSavings[0][1] = ((tempStuff[2] << 8) | (tempStuff[3]));
1775:switcherator.c ****         // Fall month
1776:switcherator.c ****         daylightSavings[1][0] = ((tempStuff[4] << 8) | (tempStuff[5]));
1777:switcherator.c ****         // Fall day
1778:switcherator.c ****         daylightSavings[1][1] = ((tempStuff[6] << 8) | (tempStuff[7]));
1779:switcherator.c ****     }
1780:switcherator.c **** 
1781:switcherator.c **** 
1782:switcherator.c ****     // switches
1783:switcherator.c ****     if (readEEPROM(switchStuff, SWITCH_STUFF, SWITCH_STUFF_BYTES) == 1) {
1784:switcherator.c ****         readEEPROM(switchBright, BRIGHTNESS, BRIGHTNESS_BYTES);
1785:switcherator.c ****         volatile unsigned char *realPort = 0;
1786:switcherator.c ****         volatile unsigned char *realDDR = 0;
1787:switcherator.c ****         char realPin = 0;
1788:switcherator.c ****         char temp = 0;
1789:switcherator.c ****         // Pp - value of 255 (default) means nothing programmed
1790:switcherator.c ****         // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
1791:switcherator.c ****         // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
1792:switcherator.c ****         for (x = 0; x < NUM_SWITCHES; x++) {
1793:switcherator.c ****             temp = switchStuff[x];
1794:switcherator.c ****             if (temp > 15 && temp < 32) {
1795:switcherator.c ****                 realPort = &PORTB;
1796:switcherator.c ****                 realDDR = &DDRB;
1797:switcherator.c ****                 temp -= 16;
1798:switcherator.c **** #ifdef PINA
1799:switcherator.c ****             } else if (temp < 16) {
1800:switcherator.c ****                 realPort = &PORTA;
1801:switcherator.c ****                 realDDR = &DDRA;
1802:switcherator.c ****                 temp -= 0;
1803:switcherator.c **** #endif
1804:switcherator.c **** #ifdef PINC
1805:switcherator.c ****             } else if (temp < 48) {
1806:switcherator.c ****                 realPort = &PORTC;
1807:switcherator.c ****                 realDDR = &DDRC;
1808:switcherator.c ****                 temp -= 32;
1809:switcherator.c **** #endif
1810:switcherator.c **** #ifdef PIND
1811:switcherator.c ****             } else if (temp < 64) {
1812:switcherator.c ****                 realPort = &PORTD;
1813:switcherator.c ****                 realDDR = &DDRD;
1814:switcherator.c ****                 temp -= 48;
1815:switcherator.c **** #endif
1816:switcherator.c **** #ifdef PINE
1817:switcherator.c ****             } else if (temp < 80) {
1818:switcherator.c ****                 realPort = &PORTE;
1819:switcherator.c ****                 realDDR = &DDRE;
1820:switcherator.c ****                 temp -= 64;
1821:switcherator.c **** #endif
1822:switcherator.c **** #ifdef PINF
1823:switcherator.c ****             } else if (temp < 96) {
1824:switcherator.c ****                 realPort = &PORTF;
1825:switcherator.c ****                 realDDR = &DDRF;
1826:switcherator.c ****                 temp -= 80;
1827:switcherator.c **** #endif
1828:switcherator.c **** #ifdef PING
1829:switcherator.c ****             } else if (temp < 112) {
1830:switcherator.c ****                 realPort = &PORTG;
1831:switcherator.c ****                 realDDR = &DDRG;
1832:switcherator.c ****                 temp -= 96;
1833:switcherator.c **** #endif
1834:switcherator.c **** #ifdef PINH
1835:switcherator.c ****             } else if (temp < 128) {
1836:switcherator.c ****                 realPort = &PORTH;
1837:switcherator.c ****                 realDDR = &DDRH;
1838:switcherator.c ****                 temp -= 112;
1839:switcherator.c **** #endif
1840:switcherator.c **** #ifdef PINI
1841:switcherator.c ****             } else if (temp < 144) {
1842:switcherator.c ****                 realPort = &PORTI;
1843:switcherator.c ****                 realDDR = &DDRI;
1844:switcherator.c ****                 temp -= 128;
1845:switcherator.c **** #endif
1846:switcherator.c ****                 // pwm setup
1847:switcherator.c ****             } else {
1848:switcherator.c ****                 continue;
1849:switcherator.c ****             }
1850:switcherator.c ****             realPin = (temp / 2);
1851:switcherator.c ****             *realDDR |= (1 << realPin);
1852:switcherator.c ****             // figure out direction
1853:switcherator.c ****             if (temp % 2 == 0) {
1854:switcherator.c ****                 // 0 = low is on  1 = high is on
1855:switcherator.c ****                 *realPort |= (1 << realPin);
1856:switcherator.c ****             } else {
1857:switcherator.c ****                 *realPort &= ~(1 << realPin);
1858:switcherator.c ****             }
1859:switcherator.c ****         }
1860:switcherator.c ****     } else {
1861:switcherator.c ****         for (x = 0; x < NUM_SWITCHES; x++)
1862:switcherator.c ****             switchStuff[x] = 255;
1863:switcherator.c ****     }
1864:switcherator.c **** 
1865:switcherator.c ****     int memoryMarker = 0;
1866:switcherator.c ****     int y = 0;
1867:switcherator.c ****     // get the programs
1868:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
1869:switcherator.c ****         memoryMarker = (WEEKLY_PROGRAM + (x * WEEKLY_PROGRAM_BYTES));
1870:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, WEEKLY_PROGRAM_BYTES) == 1) {
1871:switcherator.c ****             for (y = 0; y < 10; y++) {
1872:switcherator.c ****                 weeklyProgram[x][y] = tempStuff[y];
1873:switcherator.c ****             }
1874:switcherator.c ****         }
1875:switcherator.c ****     }
1876:switcherator.c ****     // get the inputs
1877:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
1878:switcherator.c ****         memoryMarker = (INPUT + (x * INPUT_BYTES));
1879:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, INPUT_BYTES) == 1) {
1880:switcherator.c ****             for (y = 0; y < 8; y++) {
1881:switcherator.c ****                 inputs[x][y] = tempStuff[y];
1882:switcherator.c ****             }
1883:switcherator.c ****         }
1884:switcherator.c ****     }
1885:switcherator.c ****     // get the time limits
1886:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++) {
1887:switcherator.c ****         memoryMarker = (LIMIT + (x * LIMIT_BYTES));
1888:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, LIMIT_BYTES) == 1) {
1889:switcherator.c ****             for (y = 0; y < 3; y++) {
1890:switcherator.c ****                 timeLimits[x][y] = tempStuff[y];
1891:switcherator.c ****             }
1892:switcherator.c ****         }
1893:switcherator.c ****     }
1894:switcherator.c **** 
1895:switcherator.c ****     if (readEEPROM(tempStuff, PWM_DIR, PWM_DIR_BYTES) == 1) {
1896:switcherator.c ****         DDRD |= (1 << PIND3) | (1 << PIND5) | (1 << PIND6);
1897:switcherator.c ****         // make sure initial values are 0
1898:switcherator.c ****         Red = 0;
1899:switcherator.c ****         Green = 0;
1900:switcherator.c ****         Blue = 0;
1901:switcherator.c ****         // Set output phase correct whatevers
1902:switcherator.c ****         // set it to inverted if the direction is 0
1903:switcherator.c ****         if (tempStuff[0] == 0) {
1904:switcherator.c ****             TCCR0A = (1 << COM0A0) | (1 << COM0A1) | (1 << COM0B0) | (1 << COM0B1) | (1 << WGM00);
1905:switcherator.c ****             TCCR2A = (1 << COM2B0) | (1 << COM2B1) | (1 << WGM20);
1906:switcherator.c ****             pwmdir = 0;
1907:switcherator.c ****         } else {
1908:switcherator.c ****             TCCR0A = (1 << COM0A1) | (1 << COM0B1) | (1 << WGM00);
1909:switcherator.c ****             TCCR2A = (1 << COM2B1) | (1 << WGM20);
1910:switcherator.c ****             pwmdir = 1;
1911:switcherator.c ****         }
1912:switcherator.c ****         // F_CPU/64 timers
1913:switcherator.c ****         TCCR0B = (1 << CS01) | (1 << CS00);
1914:switcherator.c **** 
1915:switcherator.c ****         TCCR2B = (1 << CS22); // F_CPU/64
1916:switcherator.c ****     }
1917:switcherator.c **** 
1918:switcherator.c ****     // get the pwm value bytes
1919:switcherator.c ****     memoryMarker = (PWM_VALUE);
1920:switcherator.c ****     if (readEEPROM(tempStuff, memoryMarker, PWM_VALUE_BYTES) == 1) {
1921:switcherator.c ****         pwmValues[0] = tempStuff[0];
1922:switcherator.c ****         pwmValues[1] = tempStuff[1];
1923:switcherator.c ****         pwmValues[2] = tempStuff[2];
1924:switcherator.c ****     }
1925:switcherator.c ****     // get the color change
1926:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
1927:switcherator.c ****         memoryMarker = (COLOR_CHANGE + (x * COLOR_CHANGE_BYTES));
1928:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, PWM_VALUE_BYTES) == 1) {
1929:switcherator.c ****             for (y = 0; y < 3; y++) {
1930:switcherator.c ****                 colorChanges[x][y] = tempStuff[y];
1931:switcherator.c ****             }
1932:switcherator.c ****         }
1933:switcherator.c ****     }
1934:switcherator.c **** }
1935:switcherator.c **** 
1936:switcherator.c **** int readEEPROM(char * data, int memLocation, int memBytes) {
 1169               		.loc 1 1936 0
 1170               	.LVL67:
 1171 067c EF92      		push r14
 1172               	.LCFI23:
 1173 067e FF92      		push r15
 1174               	.LCFI24:
 1175 0680 0F93      		push r16
 1176               	.LCFI25:
 1177 0682 1F93      		push r17
 1178               	.LCFI26:
 1179 0684 CF93      		push r28
 1180               	.LCFI27:
 1181 0686 DF93      		push r29
 1182               	.LCFI28:
 1183               	/* prologue: function */
 1184               	/* frame size = 0 */
 1185               	/* stack size = 6 */
 1186               	.L__stack_usage = 6
 1187 0688 7C01      		movw r14,r24
 1188 068a EB01      		movw r28,r22
 1189 068c 8A01      		movw r16,r20
 1190               	.LVL68:
 1191 068e FC01      		movw r30,r24
1937:switcherator.c ****     uint16_t checkProgram;
1938:switcherator.c ****     int x = 0;
1939:switcherator.c ****     for (x = 0; x < 14; x++) {
 1192               		.loc 1 1939 0
 1193 0690 20E0      		ldi r18,0
 1194 0692 30E0      		ldi r19,0
 1195               	.LVL69:
 1196               	.L79:
1940:switcherator.c ****         data[x] = 0;
 1197               		.loc 1 1940 0 discriminator 2
 1198 0694 1192      		st Z+,__zero_reg__
1939:switcherator.c ****     for (x = 0; x < 14; x++) {
 1199               		.loc 1 1939 0 discriminator 2
 1200 0696 2F5F      		subi r18,-1
 1201 0698 3F4F      		sbci r19,-1
 1202               	.LVL70:
 1203 069a 2E30      		cpi r18,14
 1204 069c 3105      		cpc r19,__zero_reg__
 1205 069e 01F4      		brne .L79
1941:switcherator.c ****     }
1942:switcherator.c ****     // see if it has been programmed
1943:switcherator.c ****     checkProgram = eeprom_read_word((uint16_t*) memLocation);
 1206               		.loc 1 1943 0
 1207 06a0 CE01      		movw r24,r28
 1208 06a2 0E94 0000 		call __eerd_word_m328
 1209               	.LVL71:
1944:switcherator.c ****     // "DW" = 68,87 = 0x4457
1945:switcherator.c ****     if (checkProgram == 0x4457) {
 1210               		.loc 1 1945 0
 1211 06a6 8735      		cpi r24,87
 1212 06a8 9444      		sbci r25,68
 1213 06aa 01F4      		brne .L81
 1214               	.LVL72:
 1215               	.LBB16:
 1216               	.LBB17:
1946:switcherator.c ****         // we've written here before. now get the data (except marker)
1947:switcherator.c ****         eeprom_read_block((void*) data, (const void*) (memLocation + 2), (memBytes - 2));
 1217               		.loc 1 1947 0
 1218 06ac A801      		movw r20,r16
 1219 06ae 4250      		subi r20,2
 1220 06b0 5109      		sbc r21,__zero_reg__
 1221 06b2 BE01      		movw r22,r28
 1222 06b4 6E5F      		subi r22,-2
 1223 06b6 7F4F      		sbci r23,-1
 1224 06b8 C701      		movw r24,r14
 1225               	.LVL73:
 1226 06ba 0E94 0000 		call __eerd_block_m328
 1227               	.LVL74:
 1228 06be 21E0      		ldi r18,lo8(1)
 1229 06c0 30E0      		ldi r19,0
 1230 06c2 00C0      		rjmp .L80
 1231               	.LVL75:
 1232               	.L81:
 1233               	.LBE17:
 1234               	.LBE16:
1948:switcherator.c ****         return 1;
1949:switcherator.c ****     } else {
1950:switcherator.c ****         return 0;
 1235               		.loc 1 1950 0
 1236 06c4 20E0      		ldi r18,0
 1237 06c6 30E0      		ldi r19,0
 1238               	.LVL76:
 1239               	.L80:
1951:switcherator.c ****     }
1952:switcherator.c **** }
 1240               		.loc 1 1952 0
 1241 06c8 C901      		movw r24,r18
 1242               	/* epilogue start */
 1243 06ca DF91      		pop r29
 1244 06cc CF91      		pop r28
 1245               	.LVL77:
 1246 06ce 1F91      		pop r17
 1247 06d0 0F91      		pop r16
 1248               	.LVL78:
 1249 06d2 FF90      		pop r15
 1250 06d4 EF90      		pop r14
 1251               	.LVL79:
 1252 06d6 0895      		ret
 1253               	.LFE43:
 1255               	.global	writeEEPROM
 1257               	writeEEPROM:
 1258               	.LFB44:
1953:switcherator.c **** 
1954:switcherator.c **** void writeEEPROM(char * data, int memLocation, int memBytes) {
 1259               		.loc 1 1954 0
 1260               	.LVL80:
 1261 06d8 CF93      		push r28
 1262               	.LCFI29:
 1263 06da DF93      		push r29
 1264               	.LCFI30:
 1265               	/* prologue: function */
 1266               	/* frame size = 0 */
 1267               	/* stack size = 2 */
 1268               	.L__stack_usage = 2
 1269 06dc EB01      		movw r28,r22
 1270               	.LVL81:
1955:switcherator.c ****     uint16_t marker = 0x4457; // "DW" in ascii
1956:switcherator.c ****     eeprom_update_block((const void*) data, (void*) (memLocation + 2), (memBytes - 2));
 1271               		.loc 1 1956 0
 1272 06de 4250      		subi r20,2
 1273 06e0 5109      		sbc r21,__zero_reg__
 1274               	.LVL82:
 1275 06e2 6E5F      		subi r22,-2
 1276 06e4 7F4F      		sbci r23,-1
 1277               	.LVL83:
 1278 06e6 0E94 0000 		call __eeupd_block_m328
 1279               	.LVL84:
1957:switcherator.c ****     eeprom_update_word((uint16_t*) memLocation, marker);
 1280               		.loc 1 1957 0
 1281 06ea 67E5      		ldi r22,lo8(87)
 1282 06ec 74E4      		ldi r23,lo8(68)
 1283 06ee CE01      		movw r24,r28
 1284               	/* epilogue start */
1958:switcherator.c **** }
 1285               		.loc 1 1958 0
 1286 06f0 DF91      		pop r29
 1287 06f2 CF91      		pop r28
 1288               	.LVL85:
1957:switcherator.c ****     eeprom_update_word((uint16_t*) memLocation, marker);
 1289               		.loc 1 1957 0
 1290 06f4 0C94 0000 		jmp __eeupd_word_m328
 1291               	.LVL86:
 1292               	.LFE44:
 1294               	.global	clearEEPROM
 1296               	clearEEPROM:
 1297               	.LFB45:
1959:switcherator.c **** 
1960:switcherator.c **** void clearEEPROM(int memLocation) {
 1298               		.loc 1 1960 0
 1299               	.LVL87:
 1300               	/* prologue: function */
 1301               	/* frame size = 0 */
 1302               	/* stack size = 0 */
 1303               	.L__stack_usage = 0
1961:switcherator.c ****     uint16_t marker = 0x0000; // blank it out
1962:switcherator.c ****     eeprom_update_word((uint16_t*) memLocation, marker);
 1304               		.loc 1 1962 0
 1305 06f8 60E0      		ldi r22,0
 1306 06fa 70E0      		ldi r23,0
 1307 06fc 0C94 0000 		jmp __eeupd_word_m328
 1308               	.LVL88:
 1309               	.LFE45:
 1311               	.global	clockInit
 1313               	clockInit:
 1314               	.LFB48:
1963:switcherator.c **** }
1964:switcherator.c **** 
1965:switcherator.c **** void saveToEEPROM(void) {
1966:switcherator.c ****     char tempStuff[14];
1967:switcherator.c ****     int x = 0;
1968:switcherator.c ****     // Go through the addresses and assign them if set
1969:switcherator.c ****     if (tx_addr > 0) {
1970:switcherator.c ****         unformatAddress(tx_addr, tempStuff);
1971:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_TX, RADIO_ADDR_TX_BYTES);
1972:switcherator.c ****     }
1973:switcherator.c ****     if (rx_addr_p0 > 0) {
1974:switcherator.c ****         unformatAddress(rx_addr_p0, tempStuff);
1975:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R0, RADIO_ADDR_R0_BYTES);
1976:switcherator.c ****     }
1977:switcherator.c ****     if (rx_addr_p1 > 0) {
1978:switcherator.c ****         unformatAddress(rx_addr_p1, tempStuff);
1979:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R1, RADIO_ADDR_R1_BYTES);
1980:switcherator.c ****     }
1981:switcherator.c ****     if (rx_addr_p2 > 0) {
1982:switcherator.c ****         tempStuff[0] = rx_addr_p2;
1983:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R2, RADIO_ADDR_R2_BYTES);
1984:switcherator.c ****     }
1985:switcherator.c ****     if (rx_addr_p3 > 0) {
1986:switcherator.c ****         tempStuff[0] = rx_addr_p3;
1987:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R3, RADIO_ADDR_R3_BYTES);
1988:switcherator.c ****     }
1989:switcherator.c ****     if (rx_addr_p4 > 0) {
1990:switcherator.c ****         tempStuff[0] = rx_addr_p4;
1991:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R4, RADIO_ADDR_R4_BYTES);
1992:switcherator.c ****     }
1993:switcherator.c ****     if (rx_addr_p5 > 0) {
1994:switcherator.c ****         tempStuff[0] = rx_addr_p5;
1995:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R5, RADIO_ADDR_R5_BYTES);
1996:switcherator.c ****     }
1997:switcherator.c **** 
1998:switcherator.c ****     if (tweakTimer != 0) {
1999:switcherator.c ****         tempStuff[0] = tweakTimer >> 8;
2000:switcherator.c ****         tempStuff[1] = (tweakTimer & 0xff);
2001:switcherator.c ****         writeEEPROM(tempStuff, TWEAK_TIMER, TWEAK_TIMER_BYTES);
2002:switcherator.c ****     }
2003:switcherator.c **** 
2004:switcherator.c **** 
2005:switcherator.c **** 
2006:switcherator.c ****     if (daylightSavings[0][0] > 0) {
2007:switcherator.c ****         tempStuff[0] = (daylightSavings[0][0] >> 8);
2008:switcherator.c ****         tempStuff[1] = (daylightSavings[0][0] & 0xff);
2009:switcherator.c ****         tempStuff[2] = (daylightSavings[0][1] >> 8);
2010:switcherator.c ****         tempStuff[3] = (daylightSavings[0][1] & 0xff);
2011:switcherator.c ****         tempStuff[4] = (daylightSavings[1][0] >> 8);
2012:switcherator.c ****         tempStuff[5] = (daylightSavings[1][0] & 0xff);
2013:switcherator.c ****         tempStuff[6] = (daylightSavings[1][1] >> 8);
2014:switcherator.c ****         tempStuff[7] = (daylightSavings[1][1] & 0xff);
2015:switcherator.c ****         writeEEPROM(tempStuff, DAYLIGHT_SAVE, DAYLIGHT_SAVE_BYTES);
2016:switcherator.c ****     }
2017:switcherator.c ****     char setupaSwitch = 0;
2018:switcherator.c ****     char setupPWM = 0;
2019:switcherator.c **** 
2020:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
2021:switcherator.c ****         if (switchStuff[x] < 255)
2022:switcherator.c ****             setupaSwitch = 1;
2023:switcherator.c ****         if (switchStuff[x] >= 200 && switchStuff[x] <= 230)
2024:switcherator.c ****             setupPWM = 1;
2025:switcherator.c ****     }
2026:switcherator.c ****     if (setupaSwitch == 1) {
2027:switcherator.c ****         writeEEPROM(switchStuff, SWITCH_STUFF, SWITCH_STUFF_BYTES);
2028:switcherator.c ****         writeEEPROM(switchBright, BRIGHTNESS, BRIGHTNESS_BYTES);
2029:switcherator.c ****     }
2030:switcherator.c ****     tempStuff[0] = pwmdir;
2031:switcherator.c ****     if (setupPWM == 1)
2032:switcherator.c ****         writeEEPROM(tempStuff, PWM_DIR, PWM_DIR_BYTES);
2033:switcherator.c **** 
2034:switcherator.c ****     int memoryMarker;
2035:switcherator.c **** 
2036:switcherator.c **** 
2037:switcherator.c **** 
2038:switcherator.c **** 
2039:switcherator.c ****     // save the programs
2040:switcherator.c ****     int y = 0;
2041:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
2042:switcherator.c ****         memoryMarker = (WEEKLY_PROGRAM + (x * WEEKLY_PROGRAM_BYTES));
2043:switcherator.c ****         if (weeklyProgram[x][0] != 255 || weeklyProgram[x][1] != 255) {
2044:switcherator.c ****             for (y = 0; y < 10; y++)
2045:switcherator.c ****                 tempStuff[y] = weeklyProgram[x][y];
2046:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, WEEKLY_PROGRAM_BYTES);
2047:switcherator.c ****         }
2048:switcherator.c ****     }
2049:switcherator.c **** 
2050:switcherator.c ****     // save the inputs
2051:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
2052:switcherator.c ****         memoryMarker = (INPUT + (x * INPUT_BYTES));
2053:switcherator.c ****         if (inputs[x][0] != 255) {
2054:switcherator.c ****             for (y = 0; y < 8; y++) {
2055:switcherator.c ****                 tempStuff[y] = inputs[x][y];
2056:switcherator.c ****             }
2057:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, INPUT_BYTES);
2058:switcherator.c ****         }
2059:switcherator.c ****     }
2060:switcherator.c **** 
2061:switcherator.c ****     // save the time limits
2062:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++) {
2063:switcherator.c ****         memoryMarker = (LIMIT + (x * LIMIT_BYTES));
2064:switcherator.c ****         if (timeLimits[x][2] > 0) {
2065:switcherator.c ****             for (y = 0; y < 3; y++) {
2066:switcherator.c ****                 tempStuff[y] = timeLimits[x][y];
2067:switcherator.c ****             }
2068:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, INPUT_BYTES);
2069:switcherator.c ****         }
2070:switcherator.c ****     }
2071:switcherator.c **** 
2072:switcherator.c **** 
2073:switcherator.c ****     // save the pwm value bytes
2074:switcherator.c ****     memoryMarker = (PWM_VALUE);
2075:switcherator.c ****     if (pwmValues[0] != 0 || pwmValues[1] != 0 || pwmValues[2] != 0) {
2076:switcherator.c ****         for (y = 0; y < 3; y++) {
2077:switcherator.c ****             tempStuff[y] = pwmValues[y];
2078:switcherator.c ****         }
2079:switcherator.c ****         writeEEPROM(tempStuff, memoryMarker, PWM_VALUE_BYTES);
2080:switcherator.c ****     }
2081:switcherator.c **** 
2082:switcherator.c ****     // save the color change
2083:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
2084:switcherator.c ****         memoryMarker = (COLOR_CHANGE + (x * COLOR_CHANGE_BYTES));
2085:switcherator.c ****         if (colorChanges[0][0] != 0 || colorChanges[0][1] != 1 || colorChanges[0][2] != 0) {
2086:switcherator.c ****             for (y = 0; y < 3; y++) {
2087:switcherator.c ****                 tempStuff[y] = inputs[x][y];
2088:switcherator.c ****             }
2089:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, COLOR_CHANGE_BYTES);
2090:switcherator.c ****         }
2091:switcherator.c ****     }
2092:switcherator.c ****     ok();
2093:switcherator.c **** }
2094:switcherator.c **** 
2095:switcherator.c **** void clearToEEPROM(void) {
2096:switcherator.c ****     int x = 0;
2097:switcherator.c ****     clearEEPROM(DAYLIGHT_SAVE);
2098:switcherator.c ****     clearEEPROM(RADIO_ADDR_TX);
2099:switcherator.c ****     clearEEPROM(RADIO_ADDR_R0);
2100:switcherator.c ****     clearEEPROM(RADIO_ADDR_R1);
2101:switcherator.c ****     clearEEPROM(RADIO_ADDR_R2);
2102:switcherator.c ****     clearEEPROM(RADIO_ADDR_R3);
2103:switcherator.c ****     clearEEPROM(RADIO_ADDR_R4);
2104:switcherator.c ****     clearEEPROM(RADIO_ADDR_R5);
2105:switcherator.c ****     clearEEPROM(SWITCH_STUFF);
2106:switcherator.c ****     clearEEPROM(PWM_DIR);
2107:switcherator.c ****     clearEEPROM(BRIGHTNESS);
2108:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++)
2109:switcherator.c ****         clearEEPROM((INPUT + (x * INPUT_BYTES)));
2110:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++)
2111:switcherator.c ****         clearEEPROM((LIMIT + (x * LIMIT_BYTES)));
2112:switcherator.c ****     clearEEPROM(PWM_VALUE);
2113:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++)
2114:switcherator.c ****         clearEEPROM((COLOR_CHANGE + (x * COLOR_CHANGE_BYTES)));
2115:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++)
2116:switcherator.c ****         clearEEPROM((WEEKLY_PROGRAM + (x * WEEKLY_PROGRAM_BYTES)));
2117:switcherator.c ****     clearEEPROM(TWEAK_TIMER);
2118:switcherator.c ****     ok();
2119:switcherator.c **** }
2120:switcherator.c **** 
2121:switcherator.c **** /****************************************************************
2122:switcherator.c ****  *
2123:switcherator.c ****  *              All Things Clock Related
2124:switcherator.c ****  *
2125:switcherator.c ****  ****************************************************************/
2126:switcherator.c **** 
2127:switcherator.c **** 
2128:switcherator.c **** // initialize the clock
2129:switcherator.c **** 
2130:switcherator.c **** void clockInit(void) {
 1315               		.loc 1 2130 0
 1316               	/* prologue: function */
 1317               	/* frame size = 0 */
 1318               	/* stack size = 0 */
 1319               	.L__stack_usage = 0
2131:switcherator.c ****     // Set CTC mode (clear timer on compare)
2132:switcherator.c ****     TCCR1A = 0;
 1320               		.loc 1 2132 0
 1321 0700 1092 8000 		sts 128,__zero_reg__
2133:switcherator.c ****     TCCR1B = (1 << WGM12);
 1322               		.loc 1 2133 0
 1323 0704 88E0      		ldi r24,lo8(8)
 1324 0706 8093 8100 		sts 129,r24
2134:switcherator.c ****     OCR1A = TIMER_RESET;
 1325               		.loc 1 2134 0
 1326 070a 1092 8900 		sts 136+1,__zero_reg__
 1327 070e 1092 8800 		sts 136,__zero_reg__
2135:switcherator.c ****     TIMSK1 = (1 << OCIE1A); // set interrupt
 1328               		.loc 1 2135 0
 1329 0712 82E0      		ldi r24,lo8(2)
 1330 0714 8093 6F00 		sts 111,r24
 1331 0718 0895      		ret
 1332               	.LFE48:
 1334               	.global	startClock
 1336               	startClock:
 1337               	.LFB51:
2136:switcherator.c **** }
2137:switcherator.c **** 
2138:switcherator.c **** // we received a time command.  set the clock
2139:switcherator.c **** // Must be this format:
2140:switcherator.c **** // TI:MMDDYYYYHHMMSS
2141:switcherator.c **** // 012345678901234567
2142:switcherator.c **** 
2143:switcherator.c **** void setClock(char * commandReceived) {
2144:switcherator.c ****     long tempInt;
2145:switcherator.c ****     // iterate through and get the times.
2146:switcherator.c ****     tempLongString[0] = '0';
2147:switcherator.c ****     tempLongString[1] = '0';
2148:switcherator.c ****     // Can't see a good loop so just get to it.
2149:switcherator.c ****     // Month
2150:switcherator.c ****     tempLongString[2] = commandReceived[3];
2151:switcherator.c ****     tempLongString[3] = commandReceived[4];
2152:switcherator.c ****     globalMonth = atoi(tempLongString);
2153:switcherator.c ****     // Day
2154:switcherator.c ****     tempLongString[2] = commandReceived[5];
2155:switcherator.c ****     tempLongString[3] = commandReceived[6];
2156:switcherator.c ****     globalDay = atoi(tempLongString);
2157:switcherator.c ****     // hour
2158:switcherator.c ****     tempLongString[2] = commandReceived[11];
2159:switcherator.c ****     tempLongString[3] = commandReceived[12];
2160:switcherator.c ****     globalHour = atoi(tempLongString);
2161:switcherator.c ****     // minute
2162:switcherator.c ****     tempLongString[2] = commandReceived[13];
2163:switcherator.c ****     tempLongString[3] = commandReceived[14];
2164:switcherator.c ****     globalMinute = atoi(tempLongString);
2165:switcherator.c ****     // second
2166:switcherator.c ****     tempLongString[2] = commandReceived[15];
2167:switcherator.c ****     tempLongString[3] = commandReceived[16];
2168:switcherator.c ****     globalSecond = atoi(tempLongString);
2169:switcherator.c ****     // year
2170:switcherator.c ****     tempLongString[0] = commandReceived[7];
2171:switcherator.c ****     tempLongString[1] = commandReceived[8];
2172:switcherator.c ****     tempLongString[2] = commandReceived[9];
2173:switcherator.c ****     tempLongString[3] = commandReceived[10];
2174:switcherator.c ****     globalYear = atoi(tempLongString);
2175:switcherator.c ****     dow = getWeekday(globalYear, globalMonth, globalDay); // get day of week
2176:switcherator.c ****     tempInt = dow;
2177:switcherator.c ****     tempInt = tempInt * 24 * 60 * 60;
2178:switcherator.c ****     weeklySeconds = tempInt;
2179:switcherator.c ****     tempInt = globalHour;
2180:switcherator.c ****     tempInt = tempInt * 60 * 60;
2181:switcherator.c ****     weeklySeconds += tempInt;
2182:switcherator.c ****     tempInt = globalMinute;
2183:switcherator.c ****     tempInt = tempInt * 60;
2184:switcherator.c ****     weeklySeconds += tempInt;
2185:switcherator.c ****     weeklySeconds += globalSecond;
2186:switcherator.c ****     clockString();
2187:switcherator.c ****     sendMessage(statusMsg);
2188:switcherator.c ****     stopClock();
2189:switcherator.c ****     startClock();
2190:switcherator.c ****     panicMyClockIsNotSet = 0;
2191:switcherator.c ****     if(failCondition == 3) {
2192:switcherator.c ****         clearFail();      
2193:switcherator.c ****     }
2194:switcherator.c **** }
2195:switcherator.c **** 
2196:switcherator.c **** 
2197:switcherator.c **** // Change the clock values to a string
2198:switcherator.c **** 
2199:switcherator.c **** void clockString(void) {
2200:switcherator.c ****     statusMsg[0] = 0;
2201:switcherator.c **** 
2202:switcherator.c ****     strcat(statusMsg, " ");
2203:switcherator.c ****     returnInt(globalMonth, tempIntString);
2204:switcherator.c ****     strcat(statusMsg, tempIntString);
2205:switcherator.c ****     strcat(statusMsg, "/");
2206:switcherator.c ****     returnInt(globalDay, tempIntString);
2207:switcherator.c ****     strcat(statusMsg, tempIntString);
2208:switcherator.c ****     strcat(statusMsg, "/");
2209:switcherator.c ****     itoa(globalYear, tempIntString, 10);
2210:switcherator.c ****     strcat(statusMsg, tempIntString);
2211:switcherator.c ****     strcat(statusMsg, " ");
2212:switcherator.c ****     returnInt(globalHour, tempIntString);
2213:switcherator.c ****     strcat(statusMsg, tempIntString);
2214:switcherator.c ****     strcat(statusMsg, ":");
2215:switcherator.c ****     returnInt(globalMinute, tempIntString);
2216:switcherator.c ****     strcat(statusMsg, tempIntString);
2217:switcherator.c ****     strcat(statusMsg, ":");
2218:switcherator.c ****     returnInt(globalSecond, tempIntString);
2219:switcherator.c ****     strcat(statusMsg, tempIntString);
2220:switcherator.c **** }
2221:switcherator.c **** 
2222:switcherator.c **** // start the clock
2223:switcherator.c **** 
2224:switcherator.c **** void startClock(void) {
 1338               		.loc 1 2224 0
 1339               	/* prologue: function */
 1340               	/* frame size = 0 */
 1341               	/* stack size = 0 */
 1342               	.L__stack_usage = 0
2225:switcherator.c ****     TCNT1 = 65535;
 1343               		.loc 1 2225 0
 1344 071a 8FEF      		ldi r24,lo8(-1)
 1345 071c 9FEF      		ldi r25,lo8(-1)
 1346 071e 9093 8500 		sts 132+1,r25
 1347 0722 8093 8400 		sts 132,r24
2226:switcherator.c ****     TCCR1B |= TIMER_CLOCK_SEL;
 1348               		.loc 1 2226 0
 1349 0726 E1E8      		ldi r30,lo8(-127)
 1350 0728 F0E0      		ldi r31,0
 1351 072a 8081      		ld r24,Z
 1352 072c 8560      		ori r24,lo8(5)
 1353 072e 8083      		st Z,r24
 1354 0730 0895      		ret
 1355               	.LFE51:
 1357               	.global	stopClock
 1359               	stopClock:
 1360               	.LFB52:
2227:switcherator.c **** }
2228:switcherator.c **** 
2229:switcherator.c **** void stopClock(void) {
 1361               		.loc 1 2229 0
 1362               	/* prologue: function */
 1363               	/* frame size = 0 */
 1364               	/* stack size = 0 */
 1365               	.L__stack_usage = 0
2230:switcherator.c ****     TCCR1B &= ~(TIMER_CLOCK_SEL);
 1366               		.loc 1 2230 0
 1367 0732 E1E8      		ldi r30,lo8(-127)
 1368 0734 F0E0      		ldi r31,0
 1369 0736 8081      		ld r24,Z
 1370 0738 8A7F      		andi r24,lo8(-6)
 1371 073a 8083      		st Z,r24
 1372 073c 0895      		ret
 1373               	.LFE52:
 1375               	.global	getWeekday
 1377               	getWeekday:
 1378               	.LFB53:
2231:switcherator.c **** }
2232:switcherator.c **** 
2233:switcherator.c **** // returns the weekday - sunday = 0
2234:switcherator.c **** 
2235:switcherator.c **** int getWeekday(int year, int month, int day) {
 1379               		.loc 1 2235 0
 1380               	.LVL89:
 1381 073e CF93      		push r28
 1382               	.LCFI31:
 1383 0740 DF93      		push r29
 1384               	.LCFI32:
 1385               	/* prologue: function */
 1386               	/* frame size = 0 */
 1387               	/* stack size = 2 */
 1388               	.L__stack_usage = 2
 1389 0742 FB01      		movw r30,r22
 1390 0744 EA01      		movw r28,r20
2236:switcherator.c ****     int adjustment, mm, yy;
2237:switcherator.c **** 
2238:switcherator.c ****     adjustment = (14 - month) / 12; // Jan is 13, feb is 14 in calculation
 1391               		.loc 1 2238 0
 1392 0746 8EE0      		ldi r24,lo8(14)
 1393 0748 90E0      		ldi r25,0
 1394               	.LVL90:
 1395 074a 861B      		sub r24,r22
 1396 074c 970B      		sbc r25,r23
 1397 074e 6CE0      		ldi r22,lo8(12)
 1398 0750 70E0      		ldi r23,0
 1399               	.LVL91:
 1400 0752 0E94 0000 		call __divmodhi4
 1401               	.LVL92:
2239:switcherator.c ****     mm = month + 12 * adjustment - 2;
2240:switcherator.c ****     yy = globalYear - adjustment;
 1402               		.loc 1 2240 0
 1403 0756 2091 0000 		lds r18,globalYear
 1404 075a 3091 0000 		lds r19,globalYear+1
 1405 075e 261B      		sub r18,r22
 1406 0760 370B      		sbc r19,r23
 1407               	.LVL93:
2239:switcherator.c ****     mm = month + 12 * adjustment - 2;
 1408               		.loc 1 2239 0
 1409 0762 8CE0      		ldi r24,lo8(12)
 1410 0764 869F      		mul r24,r22
 1411 0766 A001      		movw r20,r0
 1412 0768 879F      		mul r24,r23
 1413 076a 500D      		add r21,r0
 1414 076c 1124      		clr __zero_reg__
 1415               	.LVL94:
 1416 076e 4E0F      		add r20,r30
 1417 0770 5F1F      		adc r21,r31
 1418 0772 4250      		subi r20,2
 1419 0774 5109      		sbc r21,__zero_reg__
2241:switcherator.c ****     return ((day + (13 * mm - 1) / 5 + yy + yy / 4 - yy / 100 + yy / 400) % 7);
 1420               		.loc 1 2241 0
 1421 0776 6DE0      		ldi r22,lo8(13)
 1422               	.LVL95:
 1423 0778 649F      		mul r22,r20
 1424 077a C001      		movw r24,r0
 1425 077c 659F      		mul r22,r21
 1426 077e 900D      		add r25,r0
 1427 0780 1124      		clr __zero_reg__
 1428 0782 0197      		sbiw r24,1
 1429 0784 65E0      		ldi r22,lo8(5)
 1430 0786 70E0      		ldi r23,0
 1431 0788 0E94 0000 		call __divmodhi4
 1432 078c C60F      		add r28,r22
 1433 078e D71F      		adc r29,r23
 1434               	.LVL96:
 1435 0790 C20F      		add r28,r18
 1436 0792 D31F      		adc r29,r19
 1437 0794 F901      		movw r30,r18
 1438               	.LVL97:
 1439 0796 37FD      		sbrc r19,7
 1440 0798 3396      		adiw r30,3
 1441               	.L89:
 1442 079a F595      		asr r31
 1443 079c E795      		ror r30
 1444 079e F595      		asr r31
 1445 07a0 E795      		ror r30
 1446 07a2 EC0F      		add r30,r28
 1447 07a4 FD1F      		adc r31,r29
 1448 07a6 C901      		movw r24,r18
 1449 07a8 6CE9      		ldi r22,lo8(-100)
 1450 07aa 7FEF      		ldi r23,lo8(-1)
 1451 07ac 0E94 0000 		call __divmodhi4
 1452 07b0 E60F      		add r30,r22
 1453 07b2 F71F      		adc r31,r23
 1454 07b4 C901      		movw r24,r18
 1455 07b6 60E9      		ldi r22,lo8(-112)
 1456 07b8 71E0      		ldi r23,lo8(1)
 1457 07ba 0E94 0000 		call __divmodhi4
 1458 07be E60F      		add r30,r22
 1459 07c0 F71F      		adc r31,r23
 1460 07c2 CF01      		movw r24,r30
 1461 07c4 67E0      		ldi r22,lo8(7)
 1462 07c6 70E0      		ldi r23,0
 1463 07c8 0E94 0000 		call __divmodhi4
 1464               	/* epilogue start */
2242:switcherator.c **** }
 1465               		.loc 1 2242 0
 1466 07cc DF91      		pop r29
 1467 07ce CF91      		pop r28
 1468 07d0 0895      		ret
 1469               	.LFE53:
 1471               		.section	.rodata
 1472               	.LC0:
 1473 0000 0000      		.word	0
 1474 0002 1F00      		.word	31
 1475 0004 1C00      		.word	28
 1476 0006 1F00      		.word	31
 1477 0008 1E00      		.word	30
 1478 000a 1F00      		.word	31
 1479 000c 1E00      		.word	30
 1480 000e 1F00      		.word	31
 1481 0010 1F00      		.word	31
 1482 0012 1E00      		.word	30
 1483 0014 1F00      		.word	31
 1484 0016 1E00      		.word	30
 1485               		.text
 1486               	.global	getDayofYear
 1488               	getDayofYear:
 1489               	.LFB54:
2243:switcherator.c **** 
2244:switcherator.c **** // returns the day of the year (1 - 365 or 366)
2245:switcherator.c **** 
2246:switcherator.c **** int getDayofYear(int year, int month, int day) {
 1490               		.loc 1 2246 0
 1491               	.LVL98:
 1492 07d2 CF93      		push r28
 1493               	.LCFI33:
 1494 07d4 DF93      		push r29
 1495               	.LCFI34:
 1496 07d6 CDB7      		in r28,__SP_L__
 1497 07d8 DEB7      		in r29,__SP_H__
 1498               	.LCFI35:
 1499 07da 6897      		sbiw r28,24
 1500               	.LCFI36:
 1501 07dc 0FB6      		in __tmp_reg__,__SREG__
 1502 07de F894      		cli
 1503 07e0 DEBF      		out __SP_H__,r29
 1504 07e2 0FBE      		out __SREG__,__tmp_reg__
 1505 07e4 CDBF      		out __SP_L__,r28
 1506               	/* prologue: function */
 1507               	/* frame size = 24 */
 1508               	/* stack size = 26 */
 1509               	.L__stack_usage = 26
2247:switcherator.c ****     int months[12] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30};
 1510               		.loc 1 2247 0
 1511 07e6 28E1      		ldi r18,lo8(24)
 1512 07e8 E0E0      		ldi r30,lo8(.LC0)
 1513 07ea F0E0      		ldi r31,hi8(.LC0)
 1514 07ec DE01      		movw r26,r28
 1515 07ee 1196      		adiw r26,1
 1516               		0:
 1517 07f0 0190      		ld r0,Z+
 1518 07f2 0D92      		st X+,r0
 1519 07f4 2A95      		dec r18
 1520 07f6 01F4      		brne 0b
 1521               	.LVL99:
2248:switcherator.c ****     int x = 0;
2249:switcherator.c ****     // adjust feb for leap year
2250:switcherator.c ****     if ((year % 4) == 0)
 1522               		.loc 1 2250 0
 1523 07f8 8370      		andi r24,3
 1524 07fa 9927      		clr r25
 1525               	.LVL100:
 1526 07fc 892B      		or r24,r25
 1527 07fe 01F4      		brne .L91
2251:switcherator.c ****         months[3] = 29;
 1528               		.loc 1 2251 0
 1529 0800 8DE1      		ldi r24,lo8(29)
 1530 0802 90E0      		ldi r25,0
 1531 0804 9887      		std Y+8,r25
 1532 0806 8F83      		std Y+7,r24
 1533               	.L91:
 1534               	.LVL101:
 1535 0808 FE01      		movw r30,r28
 1536 080a 3196      		adiw r30,1
2252:switcherator.c ****     // start with the day of the month, then add amounts for each month
2253:switcherator.c ****     int doy = day;
 1537               		.loc 1 2253 0
 1538 080c 9A01      		movw r18,r20
2254:switcherator.c ****     for (x = 0; x < month; x++) {
 1539               		.loc 1 2254 0
 1540 080e 80E0      		ldi r24,0
 1541 0810 90E0      		ldi r25,0
 1542 0812 00C0      		rjmp .L92
 1543               	.LVL102:
 1544               	.L93:
2255:switcherator.c ****         doy += months[x];
 1545               		.loc 1 2255 0 discriminator 2
 1546 0814 4191      		ld r20,Z+
 1547 0816 5191      		ld r21,Z+
 1548 0818 240F      		add r18,r20
 1549 081a 351F      		adc r19,r21
 1550               	.LVL103:
2254:switcherator.c ****     for (x = 0; x < month; x++) {
 1551               		.loc 1 2254 0 discriminator 2
 1552 081c 0196      		adiw r24,1
 1553               	.LVL104:
 1554               	.L92:
2254:switcherator.c ****     for (x = 0; x < month; x++) {
 1555               		.loc 1 2254 0 is_stmt 0 discriminator 1
 1556 081e 8617      		cp r24,r22
 1557 0820 9707      		cpc r25,r23
 1558 0822 04F0      		brlt .L93
2256:switcherator.c ****     }
2257:switcherator.c ****     return doy;
2258:switcherator.c **** }
 1559               		.loc 1 2258 0 is_stmt 1
 1560 0824 C901      		movw r24,r18
 1561               	.LVL105:
 1562               	/* epilogue start */
 1563 0826 6896      		adiw r28,24
 1564 0828 0FB6      		in __tmp_reg__,__SREG__
 1565 082a F894      		cli
 1566 082c DEBF      		out __SP_H__,r29
 1567 082e 0FBE      		out __SREG__,__tmp_reg__
 1568 0830 CDBF      		out __SP_L__,r28
 1569 0832 DF91      		pop r29
 1570 0834 CF91      		pop r28
 1571 0836 0895      		ret
 1572               	.LFE54:
 1574               	.global	checkDaylightSavings
 1576               	checkDaylightSavings:
 1577               	.LFB56:
2259:switcherator.c **** 
2260:switcherator.c **** // Sets up the days we do daylight savings
2261:switcherator.c **** // DS:MMDD MMDD
2262:switcherator.c **** // 012345678901
2263:switcherator.c **** 
2264:switcherator.c **** void setDaylightSavings(char * commandReceived) {
2265:switcherator.c ****     int dlInt;
2266:switcherator.c ****     tempIntString[0] = commandReceived[3];
2267:switcherator.c ****     tempIntString[1] = commandReceived[4];
2268:switcherator.c ****     dlInt = atoi(tempIntString);
2269:switcherator.c ****     daylightSavings[0][0] = dlInt;
2270:switcherator.c ****     tempIntString[0] = commandReceived[5];
2271:switcherator.c ****     tempIntString[1] = commandReceived[6];
2272:switcherator.c ****     dlInt = atoi(tempIntString);
2273:switcherator.c ****     daylightSavings[0][1] = dlInt;
2274:switcherator.c ****     tempIntString[0] = commandReceived[8];
2275:switcherator.c ****     tempIntString[1] = commandReceived[9];
2276:switcherator.c ****     dlInt = atoi(tempIntString);
2277:switcherator.c ****     daylightSavings[1][0] = dlInt;
2278:switcherator.c ****     tempIntString[0] = commandReceived[10];
2279:switcherator.c ****     tempIntString[1] = commandReceived[11];
2280:switcherator.c ****     dlInt = atoi(tempIntString);
2281:switcherator.c ****     daylightSavings[1][1] = dlInt;
2282:switcherator.c ****     ok();
2283:switcherator.c **** }
2284:switcherator.c **** 
2285:switcherator.c **** // Decide if this 3:00am is daylight savings and adjust accordingly
2286:switcherator.c **** 
2287:switcherator.c **** void checkDaylightSavings(void) {
 1578               		.loc 1 2287 0
 1579               	/* prologue: function */
 1580               	/* frame size = 0 */
 1581               	/* stack size = 0 */
 1582               	.L__stack_usage = 0
2288:switcherator.c ****     // have we adjusted for daylight savings?
2289:switcherator.c ****     if (wasDaylightSavings == 1)
 1583               		.loc 1 2289 0
 1584 0838 8091 0000 		lds r24,wasDaylightSavings
 1585 083c 8130      		cpi r24,lo8(1)
 1586 083e 01F0      		breq .L94
2290:switcherator.c ****         return;
2291:switcherator.c ****     if (globalMonth == daylightSavings[0][0] && globalDay == daylightSavings[0][1]) {
 1587               		.loc 1 2291 0
 1588 0840 8091 0000 		lds r24,globalMonth
 1589 0844 9091 0000 		lds r25,globalMonth+1
 1590 0848 2091 0000 		lds r18,daylightSavings
 1591 084c 3091 0000 		lds r19,daylightSavings+1
 1592 0850 8217      		cp r24,r18
 1593 0852 9307      		cpc r25,r19
 1594 0854 01F4      		brne .L96
 1595               		.loc 1 2291 0 is_stmt 0 discriminator 1
 1596 0856 4091 0000 		lds r20,globalDay
 1597 085a 5091 0000 		lds r21,globalDay+1
 1598 085e 2091 0000 		lds r18,daylightSavings+2
 1599 0862 3091 0000 		lds r19,daylightSavings+2+1
 1600 0866 4217      		cp r20,r18
 1601 0868 5307      		cpc r21,r19
 1602 086a 01F4      		brne .L96
2292:switcherator.c ****         wasDaylightSavings = 1;
 1603               		.loc 1 2292 0 is_stmt 1
 1604 086c 81E0      		ldi r24,lo8(1)
 1605 086e 8093 0000 		sts wasDaylightSavings,r24
2293:switcherator.c ****         globalHour++;
 1606               		.loc 1 2293 0
 1607 0872 8091 0000 		lds r24,globalHour
 1608 0876 9091 0000 		lds r25,globalHour+1
 1609 087a 0196      		adiw r24,1
 1610 087c 00C0      		rjmp .L100
 1611               	.L96:
2294:switcherator.c ****     } else if (globalMonth == daylightSavings[1][0] && globalDay == daylightSavings[1][1]) {
 1612               		.loc 1 2294 0
 1613 087e 2091 0000 		lds r18,daylightSavings+4
 1614 0882 3091 0000 		lds r19,daylightSavings+4+1
 1615 0886 8217      		cp r24,r18
 1616 0888 9307      		cpc r25,r19
 1617 088a 01F4      		brne .L94
 1618               		.loc 1 2294 0 is_stmt 0 discriminator 1
 1619 088c 2091 0000 		lds r18,globalDay
 1620 0890 3091 0000 		lds r19,globalDay+1
 1621 0894 8091 0000 		lds r24,daylightSavings+6
 1622 0898 9091 0000 		lds r25,daylightSavings+6+1
 1623 089c 2817      		cp r18,r24
 1624 089e 3907      		cpc r19,r25
 1625 08a0 01F4      		brne .L94
2295:switcherator.c ****         wasDaylightSavings = 1;
 1626               		.loc 1 2295 0 is_stmt 1
 1627 08a2 81E0      		ldi r24,lo8(1)
 1628 08a4 8093 0000 		sts wasDaylightSavings,r24
2296:switcherator.c ****         globalHour--;
 1629               		.loc 1 2296 0
 1630 08a8 8091 0000 		lds r24,globalHour
 1631 08ac 9091 0000 		lds r25,globalHour+1
 1632 08b0 0197      		sbiw r24,1
 1633               	.L100:
 1634 08b2 9093 0000 		sts globalHour+1,r25
 1635 08b6 8093 0000 		sts globalHour,r24
 1636               	.L94:
 1637 08ba 0895      		ret
 1638               	.LFE56:
 1640               	.global	advanceDay
 1642               	advanceDay:
 1643               	.LFB57:
2297:switcherator.c ****     }
2298:switcherator.c **** }
2299:switcherator.c **** 
2300:switcherator.c **** // Advance a day in the calendar. 
2301:switcherator.c **** 
2302:switcherator.c **** void advanceDay(void) {
 1644               		.loc 1 2302 0
 1645               	/* prologue: function */
 1646               	/* frame size = 0 */
 1647               	/* stack size = 0 */
 1648               	.L__stack_usage = 0
 1649               	.LVL106:
2303:switcherator.c ****     int x = 0;
2304:switcherator.c ****     // Reset the daylight savings for next time
2305:switcherator.c ****     wasDaylightSavings = 0;
 1650               		.loc 1 2305 0
 1651 08bc 1092 0000 		sts wasDaylightSavings,__zero_reg__
2306:switcherator.c ****     // start with dow
2307:switcherator.c ****     dow++;
 1652               		.loc 1 2307 0
 1653 08c0 8091 0000 		lds r24,dow
 1654 08c4 9091 0000 		lds r25,dow+1
 1655 08c8 0196      		adiw r24,1
 1656 08ca 9093 0000 		sts dow+1,r25
 1657 08ce 8093 0000 		sts dow,r24
2308:switcherator.c ****     if (dow == 7) {
 1658               		.loc 1 2308 0
 1659 08d2 0797      		sbiw r24,7
 1660 08d4 01F0      		breq .L102
 1661               	.LVL107:
 1662               	.L107:
2309:switcherator.c ****         // reset it to Sunday
2310:switcherator.c ****         dow = 0;
2311:switcherator.c ****         weeklySeconds = 0;
2312:switcherator.c ****         // switchStatus might be more than a week (604,800 seconds)
2313:switcherator.c ****         for (x = 0; x < NUM_SWITCHES; x++) {
2314:switcherator.c ****             if (switchStatus[x] >= 604800)
2315:switcherator.c ****                 switchStatus[x] -= 604800;
2316:switcherator.c ****         }
2317:switcherator.c ****     }
2318:switcherator.c ****     // then the day
2319:switcherator.c ****     globalDay++;
 1663               		.loc 1 2319 0
 1664 08d6 2091 0000 		lds r18,globalDay
 1665 08da 3091 0000 		lds r19,globalDay+1
 1666 08de 2F5F      		subi r18,-1
 1667 08e0 3F4F      		sbci r19,-1
 1668 08e2 3093 0000 		sts globalDay+1,r19
 1669 08e6 2093 0000 		sts globalDay,r18
2320:switcherator.c ****     // If we aren't advancing a month just move on
2321:switcherator.c ****     if (globalDay <= 28) {
 1670               		.loc 1 2321 0
 1671 08ea 2D31      		cpi r18,29
 1672 08ec 3105      		cpc r19,__zero_reg__
 1673 08ee 00F4      		brsh .L140
 1674 08f0 0895      		ret
 1675               	.LVL108:
 1676               	.L102:
2310:switcherator.c ****         dow = 0;
 1677               		.loc 1 2310 0
 1678 08f2 1092 0000 		sts dow+1,__zero_reg__
 1679 08f6 1092 0000 		sts dow,__zero_reg__
2311:switcherator.c ****         weeklySeconds = 0;
 1680               		.loc 1 2311 0
 1681 08fa 1092 0000 		sts weeklySeconds,__zero_reg__
 1682 08fe 1092 0000 		sts weeklySeconds+1,__zero_reg__
 1683 0902 1092 0000 		sts weeklySeconds+2,__zero_reg__
 1684 0906 1092 0000 		sts weeklySeconds+3,__zero_reg__
 1685 090a E0E0      		ldi r30,lo8(switchStatus)
 1686 090c F0E0      		ldi r31,hi8(switchStatus)
 1687               	.LVL109:
 1688               	.L106:
2314:switcherator.c ****             if (switchStatus[x] >= 604800)
 1689               		.loc 1 2314 0
 1690 090e 8081      		ld r24,Z
 1691 0910 9181      		ldd r25,Z+1
 1692 0912 A281      		ldd r26,Z+2
 1693 0914 B381      		ldd r27,Z+3
 1694 0916 8038      		cpi r24,-128
 1695 0918 2AE3      		ldi r18,58
 1696 091a 9207      		cpc r25,r18
 1697 091c 29E0      		ldi r18,9
 1698 091e A207      		cpc r26,r18
 1699 0920 B105      		cpc r27,__zero_reg__
 1700 0922 00F0      		brlo .L105
2315:switcherator.c ****                 switchStatus[x] -= 604800;
 1701               		.loc 1 2315 0
 1702 0924 8058      		subi r24,-128
 1703 0926 9A43      		sbci r25,58
 1704 0928 A940      		sbci r26,9
 1705 092a B109      		sbc r27,__zero_reg__
 1706 092c 8083      		st Z,r24
 1707 092e 9183      		std Z+1,r25
 1708 0930 A283      		std Z+2,r26
 1709 0932 B383      		std Z+3,r27
 1710               	.L105:
 1711 0934 3496      		adiw r30,4
2313:switcherator.c ****         for (x = 0; x < NUM_SWITCHES; x++) {
 1712               		.loc 1 2313 0
 1713 0936 80E0      		ldi r24,hi8(switchStatus+64)
 1714 0938 E030      		cpi r30,lo8(switchStatus+64)
 1715 093a F807      		cpc r31,r24
 1716 093c 01F4      		brne .L106
 1717 093e 00C0      		rjmp .L107
 1718               	.L140:
2322:switcherator.c ****         return;
2323:switcherator.c ****     }
2324:switcherator.c ****     // possibly advancing a month
2325:switcherator.c ****     switch (globalMonth) {
 1719               		.loc 1 2325 0
 1720 0940 8091 0000 		lds r24,globalMonth
 1721 0944 9091 0000 		lds r25,globalMonth+1
 1722 0948 8630      		cpi r24,6
 1723 094a 9105      		cpc r25,__zero_reg__
 1724 094c 01F0      		breq .L110
 1725 094e 00F4      		brsh .L112
 1726 0950 8330      		cpi r24,3
 1727 0952 9105      		cpc r25,__zero_reg__
 1728 0954 01F0      		breq .L108
 1729 0956 00F4      		brsh .L113
 1730 0958 8130      		cpi r24,1
 1731 095a 9105      		cpc r25,__zero_reg__
 1732 095c 01F0      		breq .L108
 1733 095e 0297      		sbiw r24,2
 1734 0960 01F0      		breq .+2
 1735 0962 00C0      		rjmp .L101
 1736 0964 00C0      		rjmp .L109
 1737               	.L113:
 1738 0966 8430      		cpi r24,4
 1739 0968 9105      		cpc r25,__zero_reg__
 1740 096a 01F0      		breq .L110
 1741 096c 8530      		cpi r24,5
 1742 096e 9105      		cpc r25,__zero_reg__
 1743 0970 01F0      		breq .+2
 1744 0972 00C0      		rjmp .L101
 1745 0974 00C0      		rjmp .L108
 1746               	.L112:
 1747 0976 8930      		cpi r24,9
 1748 0978 9105      		cpc r25,__zero_reg__
 1749 097a 01F0      		breq .L110
 1750 097c 00F0      		brlo .L108
 1751 097e 8B30      		cpi r24,11
 1752 0980 9105      		cpc r25,__zero_reg__
 1753 0982 01F0      		breq .L110
 1754 0984 00F0      		brlo .L108
 1755 0986 0C97      		sbiw r24,12
 1756 0988 01F4      		brne .L101
 1757 098a 00C0      		rjmp .L111
 1758               	.L110:
2326:switcherator.c ****         // 30 days have september, april, june and november
2327:switcherator.c ****         case 4:
2328:switcherator.c ****         case 6:
2329:switcherator.c ****         case 9:
2330:switcherator.c ****         case 11:
2331:switcherator.c ****             if (globalDay > 30) {
 1759               		.loc 1 2331 0
 1760 098c 2F31      		cpi r18,31
 1761 098e 3105      		cpc r19,__zero_reg__
 1762 0990 00F0      		brlo .L101
 1763 0992 00C0      		rjmp .L142
 1764               	.L108:
2332:switcherator.c ****                 globalDay = 1;
2333:switcherator.c ****                 globalMonth++;
2334:switcherator.c ****             } else {
2335:switcherator.c ****                 return;
2336:switcherator.c ****             }
2337:switcherator.c ****             break;
2338:switcherator.c ****         case 1:
2339:switcherator.c ****         case 3:
2340:switcherator.c ****         case 5:
2341:switcherator.c ****         case 7:
2342:switcherator.c ****         case 8:
2343:switcherator.c ****         case 10:
2344:switcherator.c ****             if (globalDay > 31) {
 1765               		.loc 1 2344 0
 1766 0994 2032      		cpi r18,32
 1767 0996 3105      		cpc r19,__zero_reg__
 1768 0998 00F0      		brlo .L101
 1769               	.L142:
2345:switcherator.c ****                 globalDay = 1;
 1770               		.loc 1 2345 0
 1771 099a 21E0      		ldi r18,lo8(1)
 1772 099c 30E0      		ldi r19,0
 1773 099e 3093 0000 		sts globalDay+1,r19
 1774 09a2 2093 0000 		sts globalDay,r18
2346:switcherator.c ****                 globalMonth++;
 1775               		.loc 1 2346 0
 1776 09a6 0196      		adiw r24,1
 1777 09a8 00C0      		rjmp .L141
 1778               	.L111:
2347:switcherator.c ****             } else {
2348:switcherator.c ****                 return;
2349:switcherator.c ****             }
2350:switcherator.c ****             break;
2351:switcherator.c ****         case 12:
2352:switcherator.c ****             if (globalDay > 31) {
 1779               		.loc 1 2352 0
 1780 09aa 2032      		cpi r18,32
 1781 09ac 3105      		cpc r19,__zero_reg__
 1782 09ae 00F0      		brlo .L101
2353:switcherator.c ****                 // happy new year
2354:switcherator.c ****                 globalDay = 1;
 1783               		.loc 1 2354 0
 1784 09b0 81E0      		ldi r24,lo8(1)
 1785 09b2 90E0      		ldi r25,0
 1786 09b4 9093 0000 		sts globalDay+1,r25
 1787 09b8 8093 0000 		sts globalDay,r24
2355:switcherator.c ****                 globalMonth = 1;
 1788               		.loc 1 2355 0
 1789 09bc 9093 0000 		sts globalMonth+1,r25
 1790 09c0 8093 0000 		sts globalMonth,r24
2356:switcherator.c ****                 globalYear++;
 1791               		.loc 1 2356 0
 1792 09c4 8091 0000 		lds r24,globalYear
 1793 09c8 9091 0000 		lds r25,globalYear+1
 1794 09cc 0196      		adiw r24,1
 1795 09ce 9093 0000 		sts globalYear+1,r25
 1796 09d2 8093 0000 		sts globalYear,r24
2357:switcherator.c ****             } else {
2358:switcherator.c ****                 return;
2359:switcherator.c ****             }
2360:switcherator.c ****             break;
 1797               		.loc 1 2360 0
 1798 09d6 0895      		ret
 1799               	.L109:
2361:switcherator.c ****         case 2:
2362:switcherator.c ****             // leap year?
2363:switcherator.c ****             if (globalYear % 4 == 0) {
 1800               		.loc 1 2363 0
 1801 09d8 8091 0000 		lds r24,globalYear
 1802 09dc 9091 0000 		lds r25,globalYear+1
 1803 09e0 8370      		andi r24,3
 1804 09e2 9927      		clr r25
 1805 09e4 892B      		or r24,r25
 1806 09e6 01F4      		brne .L114
2364:switcherator.c ****                 // yes
2365:switcherator.c ****                 if (globalDay > 29) {
 1807               		.loc 1 2365 0
 1808 09e8 2D31      		cpi r18,29
 1809 09ea 3105      		cpc r19,__zero_reg__
 1810 09ec 01F0      		breq .L101
 1811               	.L114:
2366:switcherator.c ****                     globalDay = 1;
2367:switcherator.c ****                     globalMonth++;
2368:switcherator.c ****                 } else {
2369:switcherator.c ****                     return;
2370:switcherator.c ****                 }
2371:switcherator.c ****             } else {
2372:switcherator.c ****                 if (globalDay > 28) {
2373:switcherator.c ****                     globalDay = 1;
 1812               		.loc 1 2373 0
 1813 09ee 81E0      		ldi r24,lo8(1)
 1814 09f0 90E0      		ldi r25,0
 1815 09f2 9093 0000 		sts globalDay+1,r25
 1816 09f6 8093 0000 		sts globalDay,r24
2374:switcherator.c ****                     globalMonth++;
 1817               		.loc 1 2374 0
 1818 09fa 83E0      		ldi r24,lo8(3)
 1819 09fc 90E0      		ldi r25,0
 1820               	.L141:
 1821 09fe 9093 0000 		sts globalMonth+1,r25
 1822 0a02 8093 0000 		sts globalMonth,r24
 1823               	.L101:
 1824 0a06 0895      		ret
 1825               	.LFE57:
 1827               	.global	timerCheck
 1829               	timerCheck:
 1830               	.LFB58:
2375:switcherator.c ****                 } else {
2376:switcherator.c ****                     return;
2377:switcherator.c ****                 }
2378:switcherator.c ****             }
2379:switcherator.c ****             break;
2380:switcherator.c ****     }
2381:switcherator.c ****     return;
2382:switcherator.c **** }
2383:switcherator.c **** 
2384:switcherator.c **** // runs every second.  Checks to see if we need to turn something on or off
2385:switcherator.c **** 
2386:switcherator.c **** void timerCheck(void) {
 1831               		.loc 1 2386 0
 1832 0a08 6F92      		push r6
 1833               	.LCFI37:
 1834 0a0a 7F92      		push r7
 1835               	.LCFI38:
 1836 0a0c 8F92      		push r8
 1837               	.LCFI39:
 1838 0a0e 9F92      		push r9
 1839               	.LCFI40:
 1840 0a10 AF92      		push r10
 1841               	.LCFI41:
 1842 0a12 BF92      		push r11
 1843               	.LCFI42:
 1844 0a14 CF92      		push r12
 1845               	.LCFI43:
 1846 0a16 DF92      		push r13
 1847               	.LCFI44:
 1848 0a18 EF92      		push r14
 1849               	.LCFI45:
 1850 0a1a FF92      		push r15
 1851               	.LCFI46:
 1852 0a1c 0F93      		push r16
 1853               	.LCFI47:
 1854 0a1e 1F93      		push r17
 1855               	.LCFI48:
 1856 0a20 CF93      		push r28
 1857               	.LCFI49:
 1858 0a22 DF93      		push r29
 1859               	.LCFI50:
 1860               	/* prologue: function */
 1861               	/* frame size = 0 */
 1862               	/* stack size = 14 */
 1863               	.L__stack_usage = 14
 1864               	.LVL110:
2387:switcherator.c ****     int x = 0;
2388:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
2389:switcherator.c ****         // see if something should turn off
2390:switcherator.c ****         if ((switchStatus[x] > 0) && (switchStatus[x] < weeklySeconds)) {
 1865               		.loc 1 2390 0
 1866 0a24 4091 0000 		lds r20,weeklySeconds
 1867 0a28 5091 0000 		lds r21,weeklySeconds+1
 1868 0a2c 6091 0000 		lds r22,weeklySeconds+2
 1869 0a30 7091 0000 		lds r23,weeklySeconds+3
 1870 0a34 2091 0000 		lds r18,switchChanged
 1871 0a38 E0E0      		ldi r30,lo8(switchStatus)
 1872 0a3a F0E0      		ldi r31,hi8(switchStatus)
 1873               	.LVL111:
 1874               	.L145:
 1875 0a3c 8081      		ld r24,Z
 1876 0a3e 9181      		ldd r25,Z+1
 1877 0a40 A281      		ldd r26,Z+2
 1878 0a42 B381      		ldd r27,Z+3
 1879 0a44 0097      		sbiw r24,0
 1880 0a46 A105      		cpc r26,__zero_reg__
 1881 0a48 B105      		cpc r27,__zero_reg__
 1882 0a4a 01F0      		breq .L144
 1883               		.loc 1 2390 0 is_stmt 0 discriminator 1
 1884 0a4c 8417      		cp r24,r20
 1885 0a4e 9507      		cpc r25,r21
 1886 0a50 A607      		cpc r26,r22
 1887 0a52 B707      		cpc r27,r23
 1888 0a54 00F4      		brsh .L144
2391:switcherator.c ****             switchChanged = 1;
2392:switcherator.c ****             switchStatus[x] = 0;
 1889               		.loc 1 2392 0 is_stmt 1
 1890 0a56 1082      		st Z,__zero_reg__
 1891 0a58 1182      		std Z+1,__zero_reg__
 1892 0a5a 1282      		std Z+2,__zero_reg__
 1893 0a5c 1382      		std Z+3,__zero_reg__
2391:switcherator.c ****             switchChanged = 1;
 1894               		.loc 1 2391 0
 1895 0a5e 21E0      		ldi r18,lo8(1)
 1896               	.L144:
 1897 0a60 3496      		adiw r30,4
2388:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 1898               		.loc 1 2388 0
 1899 0a62 80E0      		ldi r24,hi8(switchStatus+64)
 1900 0a64 E030      		cpi r30,lo8(switchStatus+64)
 1901 0a66 F807      		cpc r31,r24
 1902 0a68 01F4      		brne .L145
 1903 0a6a 2093 0000 		sts switchChanged,r18
 1904 0a6e C0E0      		ldi r28,lo8(weeklyProgram+4)
 1905 0a70 D0E0      		ldi r29,hi8(weeklyProgram+4)
 1906 0a72 00E0      		ldi r16,0
 1907 0a74 10E0      		ldi r17,0
2393:switcherator.c ****         }
2394:switcherator.c ****     }
2395:switcherator.c ****     // see if something should turn on
2396:switcherator.c ****     // weeklyProgram format
2397:switcherator.c ****     // DssddSSSSP
2398:switcherator.c ****     // 0123456789
2399:switcherator.c ****     long time;
2400:switcherator.c ****     int today = 0;
2401:switcherator.c ****     int duration = 0;
2402:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
2403:switcherator.c ****         // check if there is a valid program
2404:switcherator.c ****         if (weeklyProgram[x][0] != 255 && weeklyProgram[x][1] != 255) { // yes
2405:switcherator.c ****             // see if it goes today
2406:switcherator.c ****             // if dow = 0 (sunday) the program stores this as 0x40 then down from there
2407:switcherator.c ****             today = (0x40 >> dow);
 1908               		.loc 1 2407 0
 1909 0a76 30E4      		ldi r19,lo8(64)
 1910 0a78 C32E      		mov r12,r19
 1911 0a7a D12C      		mov r13,__zero_reg__
 1912               	.L147:
2386:switcherator.c **** void timerCheck(void) {
 1913               		.loc 1 2386 0
 1914 0a7c FE01      		movw r30,r28
 1915 0a7e 3497      		sbiw r30,4
2404:switcherator.c ****         if (weeklyProgram[x][0] != 255 && weeklyProgram[x][1] != 255) { // yes
 1916               		.loc 1 2404 0
 1917 0a80 8081      		ld r24,Z
 1918 0a82 8F3F      		cpi r24,lo8(-1)
 1919 0a84 01F4      		brne .+2
 1920 0a86 00C0      		rjmp .L146
2386:switcherator.c **** void timerCheck(void) {
 1921               		.loc 1 2386 0 discriminator 1
 1922 0a88 FE01      		movw r30,r28
 1923 0a8a 3397      		sbiw r30,3
2404:switcherator.c ****         if (weeklyProgram[x][0] != 255 && weeklyProgram[x][1] != 255) { // yes
 1924               		.loc 1 2404 0 discriminator 1
 1925 0a8c 2081      		ld r18,Z
 1926 0a8e 2F3F      		cpi r18,lo8(-1)
 1927 0a90 01F4      		brne .+2
 1928 0a92 00C0      		rjmp .L146
 1929               		.loc 1 2407 0
 1930 0a94 7090 0000 		lds r7,dow
 1931 0a98 6090 0000 		lds r6,dow+1
 1932               	.LVL112:
2408:switcherator.c ****             // k is today the day?
2409:switcherator.c ****             if (weeklyProgram[x][0] & today) {
 1933               		.loc 1 2409 0
 1934 0a9c 90E0      		ldi r25,0
2407:switcherator.c ****             today = (0x40 >> dow);
 1935               		.loc 1 2407 0
 1936 0a9e A601      		movw r20,r12
 1937 0aa0 072C      		mov r0,r7
 1938 0aa2 00C0      		rjmp 2f
 1939               		1:
 1940 0aa4 5595      		asr r21
 1941 0aa6 4795      		ror r20
 1942               		2:
 1943 0aa8 0A94      		dec r0
 1944 0aaa 02F4      		brpl 1b
 1945               		.loc 1 2409 0
 1946 0aac 8423      		and r24,r20
 1947 0aae 9523      		and r25,r21
 1948 0ab0 892B      		or r24,r25
 1949 0ab2 01F4      		brne .+2
 1950 0ab4 00C0      		rjmp .L146
2410:switcherator.c **** 
2411:switcherator.c ****                 // yes we run today
2412:switcherator.c ****                 time = weeklyProgram[x][1];
 1951               		.loc 1 2412 0
 1952 0ab6 822F      		mov r24,r18
 1953 0ab8 90E0      		ldi r25,0
 1954 0aba A0E0      		ldi r26,0
 1955 0abc B0E0      		ldi r27,0
 1956               	.LVL113:
2413:switcherator.c ****                 time <<= 8;
 1957               		.loc 1 2413 0
 1958 0abe 2227      		clr r18
 1959 0ac0 382F      		mov r19,r24
 1960 0ac2 492F      		mov r20,r25
 1961 0ac4 5A2F      		mov r21,r26
 1962               	.LVL114:
2386:switcherator.c **** void timerCheck(void) {
 1963               		.loc 1 2386 0
 1964 0ac6 FE01      		movw r30,r28
 1965 0ac8 3297      		sbiw r30,2
2414:switcherator.c ****                 time |= weeklyProgram[x][2];
 1966               		.loc 1 2414 0
 1967 0aca 8081      		ld r24,Z
 1968 0acc 282B      		or r18,r24
 1969               	.LVL115:
2415:switcherator.c ****                 // weeklyProgram is stored in minutes
2416:switcherator.c ****                 time *= 60;
 1970               		.loc 1 2416 0
 1971 0ace ACE3      		ldi r26,lo8(60)
 1972 0ad0 B0E0      		ldi r27,0
 1973 0ad2 0E94 0000 		call __muluhisi3
 1974 0ad6 4B01      		movw r8,r22
 1975 0ad8 5C01      		movw r10,r24
 1976               	.LVL116:
2386:switcherator.c **** void timerCheck(void) {
 1977               		.loc 1 2386 0
 1978 0ada FE01      		movw r30,r28
 1979 0adc 3197      		sbiw r30,1
2417:switcherator.c ****                 duration = weeklyProgram[x][3];
 1980               		.loc 1 2417 0
 1981 0ade F081      		ld r31,Z
 1982               	.LVL117:
2418:switcherator.c ****                 duration <<= 8;
2419:switcherator.c ****                 duration |= weeklyProgram[x][4];
 1983               		.loc 1 2419 0
 1984 0ae0 E881      		ld r30,Y
 1985               	.LVL118:
2420:switcherator.c ****                 time += (dow * 86400); //seconds in day
 1986               		.loc 1 2420 0
 1987 0ae2 A72D      		mov r26,r7
 1988 0ae4 B62D      		mov r27,r6
 1989 0ae6 20E8      		ldi r18,lo8(-128)
 1990 0ae8 31E5      		ldi r19,lo8(81)
 1991 0aea 41E0      		ldi r20,lo8(1)
 1992 0aec 50E0      		ldi r21,0
 1993 0aee 0E94 0000 		call __muluhisi3
 1994 0af2 860E      		add r8,r22
 1995 0af4 971E      		adc r9,r23
 1996 0af6 A81E      		adc r10,r24
 1997 0af8 B91E      		adc r11,r25
 1998               	.LVL119:
2421:switcherator.c ****                 // check if we are between start & stop time
2422:switcherator.c ****                 if ((weeklySeconds >= time) && (weeklySeconds < (time + duration))) {
 1999               		.loc 1 2422 0
 2000 0afa 4091 0000 		lds r20,weeklySeconds
 2001 0afe 5091 0000 		lds r21,weeklySeconds+1
 2002 0b02 6091 0000 		lds r22,weeklySeconds+2
 2003 0b06 7091 0000 		lds r23,weeklySeconds+3
 2004 0b0a 4815      		cp r20,r8
 2005 0b0c 5905      		cpc r21,r9
 2006 0b0e 6A05      		cpc r22,r10
 2007 0b10 7B05      		cpc r23,r11
 2008 0b12 00F0      		brlo .L146
2418:switcherator.c ****                 duration <<= 8;
 2009               		.loc 1 2418 0 discriminator 1
 2010 0b14 FF2E      		mov r15,r31
 2011 0b16 E12C      		mov r14,__zero_reg__
2419:switcherator.c ****                 duration |= weeklyProgram[x][4];
 2012               		.loc 1 2419 0 discriminator 1
 2013 0b18 C701      		movw r24,r14
 2014 0b1a 8E2B      		or r24,r30
 2015               		.loc 1 2422 0 discriminator 1
 2016 0b1c AA27      		clr r26
 2017 0b1e 97FD      		sbrc r25,7
 2018 0b20 A095      		com r26
 2019 0b22 BA2F      		mov r27,r26
 2020 0b24 880D      		add r24,r8
 2021 0b26 991D      		adc r25,r9
 2022 0b28 AA1D      		adc r26,r10
 2023 0b2a BB1D      		adc r27,r11
 2024 0b2c 4817      		cp r20,r24
 2025 0b2e 5907      		cpc r21,r25
 2026 0b30 6A07      		cpc r22,r26
 2027 0b32 7B07      		cpc r23,r27
 2028 0b34 00F4      		brsh .L146
2423:switcherator.c ****                     // feed time to it so the end time won't change
2424:switcherator.c ****                     startTheProgram(x, 0, time);
 2029               		.loc 1 2424 0
 2030 0b36 A501      		movw r20,r10
 2031 0b38 9401      		movw r18,r8
 2032 0b3a 60E0      		ldi r22,0
 2033 0b3c 70E0      		ldi r23,0
 2034 0b3e C801      		movw r24,r16
 2035 0b40 0E94 0000 		call startTheProgram
 2036               	.LVL120:
 2037               	.L146:
2402:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 2038               		.loc 1 2402 0
 2039 0b44 0F5F      		subi r16,-1
 2040 0b46 1F4F      		sbci r17,-1
 2041               	.LVL121:
 2042 0b48 2A96      		adiw r28,10
 2043 0b4a 0431      		cpi r16,20
 2044 0b4c 1105      		cpc r17,__zero_reg__
 2045 0b4e 01F0      		breq .+2
 2046 0b50 00C0      		rjmp .L147
 2047               	/* epilogue start */
2425:switcherator.c ****                 }
2426:switcherator.c ****             }
2427:switcherator.c ****         }
2428:switcherator.c ****     }
2429:switcherator.c **** }
 2048               		.loc 1 2429 0
 2049 0b52 DF91      		pop r29
 2050 0b54 CF91      		pop r28
 2051 0b56 1F91      		pop r17
 2052 0b58 0F91      		pop r16
 2053               	.LVL122:
 2054 0b5a FF90      		pop r15
 2055 0b5c EF90      		pop r14
 2056 0b5e DF90      		pop r13
 2057 0b60 CF90      		pop r12
 2058 0b62 BF90      		pop r11
 2059 0b64 AF90      		pop r10
 2060 0b66 9F90      		pop r9
 2061 0b68 8F90      		pop r8
 2062 0b6a 7F90      		pop r7
 2063 0b6c 6F90      		pop r6
 2064 0b6e 0895      		ret
 2065               	.LFE58:
 2067               	.global	switchOnOff
 2069               	switchOnOff:
 2070               	.LFB59:
2430:switcherator.c **** 
2431:switcherator.c **** // iterate through the switches and turn them on or off
2432:switcherator.c **** 
2433:switcherator.c **** void switchOnOff(void) {
 2071               		.loc 1 2433 0
 2072 0b70 7F92      		push r7
 2073               	.LCFI51:
 2074 0b72 8F92      		push r8
 2075               	.LCFI52:
 2076 0b74 9F92      		push r9
 2077               	.LCFI53:
 2078 0b76 AF92      		push r10
 2079               	.LCFI54:
 2080 0b78 BF92      		push r11
 2081               	.LCFI55:
 2082 0b7a CF92      		push r12
 2083               	.LCFI56:
 2084 0b7c DF92      		push r13
 2085               	.LCFI57:
 2086 0b7e EF92      		push r14
 2087               	.LCFI58:
 2088 0b80 FF92      		push r15
 2089               	.LCFI59:
 2090 0b82 0F93      		push r16
 2091               	.LCFI60:
 2092 0b84 1F93      		push r17
 2093               	.LCFI61:
 2094 0b86 CF93      		push r28
 2095               	.LCFI62:
 2096 0b88 DF93      		push r29
 2097               	.LCFI63:
 2098 0b8a 00D0      		rcall .
 2099 0b8c 1F92      		push __zero_reg__
 2100               	.LCFI64:
 2101 0b8e CDB7      		in r28,__SP_L__
 2102 0b90 DEB7      		in r29,__SP_H__
 2103               	.LCFI65:
 2104               	/* prologue: function */
 2105               	/* frame size = 3 */
 2106               	/* stack size = 16 */
 2107               	.L__stack_usage = 16
 2108               	.LVL123:
 2109 0b92 10E0      		ldi r17,lo8(switchStuff)
 2110 0b94 812E      		mov r8,r17
 2111 0b96 10E0      		ldi r17,hi8(switchStuff)
 2112 0b98 912E      		mov r9,r17
 2113 0b9a 00E0      		ldi r16,lo8(switchStatus)
 2114 0b9c C02E      		mov r12,r16
 2115 0b9e 00E0      		ldi r16,hi8(switchStatus)
 2116 0ba0 D02E      		mov r13,r16
2434:switcherator.c ****     char port[1];
2435:switcherator.c ****     char pin[1];
2436:switcherator.c ****     int realPin = 0;
2437:switcherator.c ****     int x = 0;
2438:switcherator.c ****     char direction[1];
2439:switcherator.c ****     volatile unsigned char *thisPort = 0;
 2117               		.loc 1 2439 0
 2118 0ba2 00E0      		ldi r16,0
 2119 0ba4 10E0      		ldi r17,0
2440:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 2120               		.loc 1 2440 0
 2121 0ba6 E12C      		mov r14,__zero_reg__
 2122 0ba8 F12C      		mov r15,__zero_reg__
2441:switcherator.c ****         // see if a switch is set up
2442:switcherator.c ****         if (switchStuff[x] != 255) {
2443:switcherator.c ****             // find out if this is pwm
2444:switcherator.c ****             if (switchStuff[x] >= 200 && switchStuff[x] <= 220) {
2445:switcherator.c ****                 // are we turning it on or off
2446:switcherator.c ****                 if (switchStatus[x] == 0) {
2447:switcherator.c ****                     // turning it off
2448:switcherator.c ****                     if (switchStuff[x] == 200) {
2449:switcherator.c ****                         Red = 0;
2450:switcherator.c ****                         Green = 0;
2451:switcherator.c ****                         Blue = 0;
2452:switcherator.c ****                     } else if (switchStuff[x] == 201) {
2453:switcherator.c ****                         Red = 0;
2454:switcherator.c ****                         Green = 0;
2455:switcherator.c ****                         Blue = 0;
2456:switcherator.c ****                         runHue = 0;
2457:switcherator.c ****                     } else if (switchStuff[x] == 202) {
2458:switcherator.c ****                         Red = 0;
2459:switcherator.c ****                         Green = 0;
2460:switcherator.c ****                         Blue = 0;
2461:switcherator.c ****                         runColorChanges = 0;
2462:switcherator.c ****                     } else if (switchStuff[x] == 212) {
2463:switcherator.c ****                         bright = oldBright;
2464:switcherator.c ****                     }
2465:switcherator.c ****                     // now don't override if we are changing it ourselves
2466:switcherator.c ****                 } else if (immediateChange == 0){
2467:switcherator.c ****                     // turn it on
2468:switcherator.c ****                     // decide if it is a changing hue or static values
2469:switcherator.c ****                     if (switchStuff[x] == 200) {
2470:switcherator.c ****                         // even numbers are static colors;
2471:switcherator.c ****                         red = pwmValues[0];
2472:switcherator.c ****                         green = pwmValues[1];
2473:switcherator.c ****                         blue = pwmValues[2];
2474:switcherator.c ****                         red = red * bright / 16;
2475:switcherator.c ****                         green = green * bright / 16;
2476:switcherator.c ****                         blue = blue * bright / 16;
2477:switcherator.c ****                         Red = red;
2478:switcherator.c ****                         Green = green;
2479:switcherator.c ****                         Blue = blue;
2480:switcherator.c ****                     } else if (switchStuff[x] == 202) {
2481:switcherator.c ****                         runColorChanges = 1;
2482:switcherator.c ****                     } else if (switchStuff[x] == 212) {
2483:switcherator.c ****                         // change the brightness
2484:switcherator.c ****                         bright = switchBright[x];
2485:switcherator.c ****                     } else {
2486:switcherator.c ****                         // get the hue cycle going
2487:switcherator.c ****                         runHue = 1;
2488:switcherator.c ****                     }
2489:switcherator.c ****                 }
2490:switcherator.c ****                 continue;
2491:switcherator.c ****             }
2492:switcherator.c ****             // switch is set up. Get details
2493:switcherator.c ****             getPort(x, port, pin, direction);
2494:switcherator.c ****             // yeah pointers and casts and whatevers. this fixes it
2495:switcherator.c ****             realPin = pin[0];
2496:switcherator.c ****             if (port[0] == 'B')
2497:switcherator.c ****                 thisPort = &PORTB;
2498:switcherator.c **** #ifdef PORTA
2499:switcherator.c ****             else if (port[0] == 'A')
2500:switcherator.c ****                 thisPort = &PORTA;
2501:switcherator.c **** #endif
2502:switcherator.c **** #ifdef PORTC
2503:switcherator.c ****             else if (port[0] == 'C')
2504:switcherator.c ****                 thisPort = &PORTC;
2505:switcherator.c **** #endif
2506:switcherator.c **** #ifdef PORTD
2507:switcherator.c ****             else if (port[0] == 'D')
2508:switcherator.c ****                 thisPort = &PORTD;
2509:switcherator.c **** #endif
2510:switcherator.c **** #ifdef PORTE
2511:switcherator.c ****             else if (port[0] == 'E')
2512:switcherator.c ****                 thisPort = &PORTE;
2513:switcherator.c **** #endif
2514:switcherator.c **** #ifdef PORTF
2515:switcherator.c ****             else if (port[0] == 'F')
2516:switcherator.c ****                 thisPort = &PORTF;
2517:switcherator.c **** #endif
2518:switcherator.c **** #ifdef PORTG
2519:switcherator.c ****             else if (port[0] == 'G')
2520:switcherator.c ****                 thisPort = &PORTG;
2521:switcherator.c **** #endif
2522:switcherator.c **** #ifdef PORTH
2523:switcherator.c ****             else if (port[0] == 'H')
2524:switcherator.c ****                 thisPort = &PORTH;
2525:switcherator.c **** #endif
2526:switcherator.c **** #ifdef PORTI
2527:switcherator.c ****             else if (port[0] == 'I')
2528:switcherator.c ****                 thisPort = &PORTI;
2529:switcherator.c **** #endif
2530:switcherator.c ****             // k we have the port - now decide if we are turning it on or off and turn it on/off
2531:switcherator.c ****             if (switchStatus[x] == 0) {
2532:switcherator.c ****                 // turning it off
2533:switcherator.c ****                 if (direction[0] == 0) {
2534:switcherator.c ****                     *thisPort |= (1 << realPin);
2535:switcherator.c ****                 } else {
2536:switcherator.c ****                     *thisPort &= ~(1 << realPin);
2537:switcherator.c ****                 }
2538:switcherator.c ****             } else {
2539:switcherator.c ****                 // turning it on
2540:switcherator.c ****                 if (direction[0] == 0) {
2541:switcherator.c ****                     *thisPort &= ~(1 << realPin);
2542:switcherator.c ****                 } else {
2543:switcherator.c ****                     *thisPort |= (1 << realPin);
 2123               		.loc 1 2543 0
 2124 0baa AA24      		clr r10
 2125 0bac A394      		inc r10
 2126 0bae B12C      		mov r11,__zero_reg__
2487:switcherator.c ****                         runHue = 1;
 2127               		.loc 1 2487 0
 2128 0bb0 7724      		clr r7
 2129 0bb2 7394      		inc r7
 2130               	.LVL124:
 2131               	.L176:
2442:switcherator.c ****         if (switchStuff[x] != 255) {
 2132               		.loc 1 2442 0
 2133 0bb4 F401      		movw r30,r8
 2134 0bb6 2191      		ld r18,Z+
 2135 0bb8 4F01      		movw r8,r30
 2136 0bba 2F3F      		cpi r18,lo8(-1)
 2137 0bbc 01F4      		brne .+2
 2138 0bbe 00C0      		rjmp .L163
2444:switcherator.c ****             if (switchStuff[x] >= 200 && switchStuff[x] <= 220) {
 2139               		.loc 1 2444 0
 2140 0bc0 822F      		mov r24,r18
 2141 0bc2 885C      		subi r24,lo8(-(56))
 2142 0bc4 8531      		cpi r24,lo8(21)
 2143 0bc6 00F0      		brlo .+2
 2144 0bc8 00C0      		rjmp .L164
2446:switcherator.c ****                 if (switchStatus[x] == 0) {
 2145               		.loc 1 2446 0
 2146 0bca F601      		movw r30,r12
 2147 0bcc 8081      		ld r24,Z
 2148 0bce 9181      		ldd r25,Z+1
 2149 0bd0 A281      		ldd r26,Z+2
 2150 0bd2 B381      		ldd r27,Z+3
 2151 0bd4 892B      		or r24,r25
 2152 0bd6 8A2B      		or r24,r26
 2153 0bd8 8B2B      		or r24,r27
 2154 0bda 01F4      		brne .L165
2448:switcherator.c ****                     if (switchStuff[x] == 200) {
 2155               		.loc 1 2448 0
 2156 0bdc 283C      		cpi r18,lo8(-56)
 2157 0bde 01F4      		brne .L166
2449:switcherator.c ****                         Red = 0;
 2158               		.loc 1 2449 0
 2159 0be0 1092 B400 		sts 180,__zero_reg__
2450:switcherator.c ****                         Green = 0;
 2160               		.loc 1 2450 0
 2161 0be4 18BC      		out 0x28,__zero_reg__
2451:switcherator.c ****                         Blue = 0;
 2162               		.loc 1 2451 0
 2163 0be6 17BC      		out 0x27,__zero_reg__
 2164 0be8 00C0      		rjmp .L163
 2165               	.L166:
2452:switcherator.c ****                     } else if (switchStuff[x] == 201) {
 2166               		.loc 1 2452 0
 2167 0bea 293C      		cpi r18,lo8(-55)
 2168 0bec 01F4      		brne .L167
2453:switcherator.c ****                         Red = 0;
 2169               		.loc 1 2453 0
 2170 0bee 1092 B400 		sts 180,__zero_reg__
2454:switcherator.c ****                         Green = 0;
 2171               		.loc 1 2454 0
 2172 0bf2 18BC      		out 0x28,__zero_reg__
2455:switcherator.c ****                         Blue = 0;
 2173               		.loc 1 2455 0
 2174 0bf4 17BC      		out 0x27,__zero_reg__
2456:switcherator.c ****                         runHue = 0;
 2175               		.loc 1 2456 0
 2176 0bf6 1092 0000 		sts runHue,__zero_reg__
 2177 0bfa 00C0      		rjmp .L163
 2178               	.L167:
2457:switcherator.c ****                     } else if (switchStuff[x] == 202) {
 2179               		.loc 1 2457 0
 2180 0bfc 2A3C      		cpi r18,lo8(-54)
 2181 0bfe 01F4      		brne .L168
2458:switcherator.c ****                         Red = 0;
 2182               		.loc 1 2458 0
 2183 0c00 1092 B400 		sts 180,__zero_reg__
2459:switcherator.c ****                         Green = 0;
 2184               		.loc 1 2459 0
 2185 0c04 18BC      		out 0x28,__zero_reg__
2460:switcherator.c ****                         Blue = 0;
 2186               		.loc 1 2460 0
 2187 0c06 17BC      		out 0x27,__zero_reg__
2461:switcherator.c ****                         runColorChanges = 0;
 2188               		.loc 1 2461 0
 2189 0c08 1092 0000 		sts runColorChanges,__zero_reg__
 2190 0c0c 00C0      		rjmp .L163
 2191               	.L168:
2462:switcherator.c ****                     } else if (switchStuff[x] == 212) {
 2192               		.loc 1 2462 0
 2193 0c0e 243D      		cpi r18,lo8(-44)
 2194 0c10 01F0      		breq .+2
 2195 0c12 00C0      		rjmp .L163
2463:switcherator.c ****                         bright = oldBright;
 2196               		.loc 1 2463 0
 2197 0c14 8091 0000 		lds r24,oldBright
 2198 0c18 00C0      		rjmp .L185
 2199               	.L165:
2466:switcherator.c ****                 } else if (immediateChange == 0){
 2200               		.loc 1 2466 0
 2201 0c1a 8091 0000 		lds r24,immediateChange
 2202 0c1e 9091 0000 		lds r25,immediateChange+1
 2203 0c22 A091 0000 		lds r26,immediateChange+2
 2204 0c26 B091 0000 		lds r27,immediateChange+3
 2205 0c2a 892B      		or r24,r25
 2206 0c2c 8A2B      		or r24,r26
 2207 0c2e 8B2B      		or r24,r27
 2208 0c30 01F0      		breq .+2
 2209 0c32 00C0      		rjmp .L163
2469:switcherator.c ****                     if (switchStuff[x] == 200) {
 2210               		.loc 1 2469 0
 2211 0c34 283C      		cpi r18,lo8(-56)
 2212 0c36 01F4      		brne .L169
2472:switcherator.c ****                         green = pwmValues[1];
 2213               		.loc 1 2472 0
 2214 0c38 8091 0000 		lds r24,pwmValues+1
2473:switcherator.c ****                         blue = pwmValues[2];
 2215               		.loc 1 2473 0
 2216 0c3c E091 0000 		lds r30,pwmValues+2
2474:switcherator.c ****                         red = red * bright / 16;
 2217               		.loc 1 2474 0
 2218 0c40 6091 0000 		lds r22,bright
 2219 0c44 7091 0000 		lds r23,bright+1
2471:switcherator.c ****                         red = pwmValues[0];
 2220               		.loc 1 2471 0
 2221 0c48 9091 0000 		lds r25,pwmValues
2474:switcherator.c ****                         red = red * bright / 16;
 2222               		.loc 1 2474 0
 2223 0c4c 969F      		mul r25,r22
 2224 0c4e A001      		movw r20,r0
 2225 0c50 979F      		mul r25,r23
 2226 0c52 500D      		add r21,r0
 2227 0c54 1124      		clr __zero_reg__
 2228 0c56 F4E0      		ldi r31,4
 2229               		1:
 2230 0c58 5695      		lsr r21
 2231 0c5a 4795      		ror r20
 2232 0c5c FA95      		dec r31
 2233 0c5e 01F4      		brne 1b
 2234 0c60 5093 0000 		sts red+1,r21
 2235 0c64 4093 0000 		sts red,r20
2475:switcherator.c ****                         green = green * bright / 16;
 2236               		.loc 1 2475 0
 2237 0c68 869F      		mul r24,r22
 2238 0c6a 9001      		movw r18,r0
 2239 0c6c 879F      		mul r24,r23
 2240 0c6e 300D      		add r19,r0
 2241 0c70 1124      		clr __zero_reg__
 2242 0c72 A4E0      		ldi r26,4
 2243               		1:
 2244 0c74 3695      		lsr r19
 2245 0c76 2795      		ror r18
 2246 0c78 AA95      		dec r26
 2247 0c7a 01F4      		brne 1b
 2248 0c7c 3093 0000 		sts green+1,r19
 2249 0c80 2093 0000 		sts green,r18
2476:switcherator.c ****                         blue = blue * bright / 16;
 2250               		.loc 1 2476 0
 2251 0c84 E69F      		mul r30,r22
 2252 0c86 C001      		movw r24,r0
 2253 0c88 E79F      		mul r30,r23
 2254 0c8a 900D      		add r25,r0
 2255 0c8c 1124      		clr __zero_reg__
 2256 0c8e B4E0      		ldi r27,4
 2257               		1:
 2258 0c90 9695      		lsr r25
 2259 0c92 8795      		ror r24
 2260 0c94 BA95      		dec r27
 2261 0c96 01F4      		brne 1b
 2262 0c98 9093 0000 		sts blue+1,r25
 2263 0c9c 8093 0000 		sts blue,r24
2477:switcherator.c ****                         Red = red;
 2264               		.loc 1 2477 0
 2265 0ca0 4093 B400 		sts 180,r20
2478:switcherator.c ****                         Green = green;
 2266               		.loc 1 2478 0
 2267 0ca4 28BD      		out 0x28,r18
2479:switcherator.c ****                         Blue = blue;
 2268               		.loc 1 2479 0
 2269 0ca6 87BD      		out 0x27,r24
 2270 0ca8 00C0      		rjmp .L163
 2271               	.L169:
2480:switcherator.c ****                     } else if (switchStuff[x] == 202) {
 2272               		.loc 1 2480 0
 2273 0caa 2A3C      		cpi r18,lo8(-54)
 2274 0cac 01F4      		brne .L170
2481:switcherator.c ****                         runColorChanges = 1;
 2275               		.loc 1 2481 0
 2276 0cae 7092 0000 		sts runColorChanges,r7
 2277 0cb2 00C0      		rjmp .L163
 2278               	.L170:
2482:switcherator.c ****                     } else if (switchStuff[x] == 212) {
 2279               		.loc 1 2482 0
 2280 0cb4 243D      		cpi r18,lo8(-44)
 2281 0cb6 01F4      		brne .L171
2433:switcherator.c **** void switchOnOff(void) {
 2282               		.loc 1 2433 0
 2283 0cb8 F701      		movw r30,r14
 2284 0cba E050      		subi r30,lo8(-(switchBright))
 2285 0cbc F040      		sbci r31,hi8(-(switchBright))
2484:switcherator.c ****                         bright = switchBright[x];
 2286               		.loc 1 2484 0
 2287 0cbe 8081      		ld r24,Z
 2288               	.L185:
 2289 0cc0 8093 0000 		sts bright,r24
 2290 0cc4 1092 0000 		sts bright+1,__zero_reg__
 2291 0cc8 00C0      		rjmp .L163
 2292               	.L171:
2487:switcherator.c ****                         runHue = 1;
 2293               		.loc 1 2487 0
 2294 0cca 7092 0000 		sts runHue,r7
 2295 0cce 00C0      		rjmp .L163
 2296               	.L164:
2493:switcherator.c ****             getPort(x, port, pin, direction);
 2297               		.loc 1 2493 0
 2298 0cd0 9E01      		movw r18,r28
 2299 0cd2 2F5F      		subi r18,-1
 2300 0cd4 3F4F      		sbci r19,-1
 2301 0cd6 AE01      		movw r20,r28
 2302 0cd8 4E5F      		subi r20,-2
 2303 0cda 5F4F      		sbci r21,-1
 2304 0cdc BE01      		movw r22,r28
 2305 0cde 6D5F      		subi r22,-3
 2306 0ce0 7F4F      		sbci r23,-1
 2307 0ce2 C701      		movw r24,r14
 2308 0ce4 0E94 0000 		call getPort
 2309               	.LVL125:
2495:switcherator.c ****             realPin = pin[0];
 2310               		.loc 1 2495 0
 2311 0ce8 2A81      		ldd r18,Y+2
2496:switcherator.c ****             if (port[0] == 'B')
 2312               		.loc 1 2496 0
 2313 0cea 8B81      		ldd r24,Y+3
 2314 0cec 8234      		cpi r24,lo8(66)
 2315 0cee 01F0      		breq .L177
2503:switcherator.c ****             else if (port[0] == 'C')
 2316               		.loc 1 2503 0
 2317 0cf0 8334      		cpi r24,lo8(67)
 2318 0cf2 01F0      		breq .L178
2507:switcherator.c ****             else if (port[0] == 'D')
 2319               		.loc 1 2507 0
 2320 0cf4 8434      		cpi r24,lo8(68)
 2321 0cf6 01F4      		brne .L172
 2322 0cf8 00C0      		rjmp .L179
 2323               	.L177:
2497:switcherator.c ****                 thisPort = &PORTB;
 2324               		.loc 1 2497 0
 2325 0cfa 05E2      		ldi r16,lo8(37)
 2326 0cfc 10E0      		ldi r17,0
 2327 0cfe 00C0      		rjmp .L172
 2328               	.L178:
2504:switcherator.c ****                 thisPort = &PORTC;
 2329               		.loc 1 2504 0
 2330 0d00 08E2      		ldi r16,lo8(40)
 2331 0d02 10E0      		ldi r17,0
 2332 0d04 00C0      		rjmp .L172
 2333               	.L179:
2508:switcherator.c ****                 thisPort = &PORTD;
 2334               		.loc 1 2508 0
 2335 0d06 0BE2      		ldi r16,lo8(43)
 2336 0d08 10E0      		ldi r17,0
 2337               	.L172:
 2338               	.LVL126:
2531:switcherator.c ****             if (switchStatus[x] == 0) {
 2339               		.loc 1 2531 0
 2340 0d0a F601      		movw r30,r12
 2341 0d0c 8081      		ld r24,Z
 2342 0d0e 9181      		ldd r25,Z+1
 2343 0d10 A281      		ldd r26,Z+2
 2344 0d12 B381      		ldd r27,Z+3
 2345 0d14 3981      		ldd r19,Y+1
2534:switcherator.c ****                     *thisPort |= (1 << realPin);
 2346               		.loc 1 2534 0
 2347 0d16 F801      		movw r30,r16
2531:switcherator.c ****             if (switchStatus[x] == 0) {
 2348               		.loc 1 2531 0
 2349 0d18 892B      		or r24,r25
 2350 0d1a 8A2B      		or r24,r26
 2351 0d1c 8B2B      		or r24,r27
 2352 0d1e 01F4      		brne .L173
2533:switcherator.c ****                 if (direction[0] == 0) {
 2353               		.loc 1 2533 0
 2354 0d20 3111      		cpse r19,__zero_reg__
 2355 0d22 00C0      		rjmp .L186
 2356 0d24 00C0      		rjmp .L175
 2357               	.L173:
2540:switcherator.c ****                 if (direction[0] == 0) {
 2358               		.loc 1 2540 0
 2359 0d26 3111      		cpse r19,__zero_reg__
 2360 0d28 00C0      		rjmp .L175
 2361               	.L186:
2541:switcherator.c ****                     *thisPort &= ~(1 << realPin);
 2362               		.loc 1 2541 0
 2363 0d2a 3081      		ld r19,Z
 2364 0d2c C501      		movw r24,r10
 2365 0d2e 022E      		mov r0,r18
 2366 0d30 00C0      		rjmp 2f
 2367               		1:
 2368 0d32 880F      		lsl r24
 2369               		2:
 2370 0d34 0A94      		dec r0
 2371 0d36 02F4      		brpl 1b
 2372 0d38 8095      		com r24
 2373 0d3a 3823      		and r19,r24
 2374 0d3c 00C0      		rjmp .L184
 2375               	.L175:
 2376               		.loc 1 2543 0
 2377 0d3e 3081      		ld r19,Z
 2378 0d40 C501      		movw r24,r10
 2379 0d42 022E      		mov r0,r18
 2380 0d44 00C0      		rjmp 2f
 2381               		1:
 2382 0d46 880F      		lsl r24
 2383               		2:
 2384 0d48 0A94      		dec r0
 2385 0d4a 02F4      		brpl 1b
 2386 0d4c 382B      		or r19,r24
 2387               	.L184:
 2388 0d4e 3083      		st Z,r19
 2389               	.LVL127:
 2390               	.L163:
2440:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 2391               		.loc 1 2440 0
 2392 0d50 FFEF      		ldi r31,-1
 2393 0d52 EF1A      		sub r14,r31
 2394 0d54 FF0A      		sbc r15,r31
 2395               	.LVL128:
 2396 0d56 84E0      		ldi r24,4
 2397 0d58 C80E      		add r12,r24
 2398 0d5a D11C      		adc r13,__zero_reg__
 2399 0d5c E0E1      		ldi r30,16
 2400 0d5e EE16      		cp r14,r30
 2401 0d60 F104      		cpc r15,__zero_reg__
 2402 0d62 01F0      		breq .+2
 2403 0d64 00C0      		rjmp .L176
 2404               	/* epilogue start */
2544:switcherator.c ****                 }
2545:switcherator.c ****             }
2546:switcherator.c ****         }
2547:switcherator.c ****     }
2548:switcherator.c **** }
 2405               		.loc 1 2548 0
 2406 0d66 0F90      		pop __tmp_reg__
 2407 0d68 0F90      		pop __tmp_reg__
 2408 0d6a 0F90      		pop __tmp_reg__
 2409 0d6c DF91      		pop r29
 2410 0d6e CF91      		pop r28
 2411 0d70 1F91      		pop r17
 2412 0d72 0F91      		pop r16
 2413               	.LVL129:
 2414 0d74 FF90      		pop r15
 2415 0d76 EF90      		pop r14
 2416               	.LVL130:
 2417 0d78 DF90      		pop r13
 2418 0d7a CF90      		pop r12
 2419 0d7c BF90      		pop r11
 2420 0d7e AF90      		pop r10
 2421 0d80 9F90      		pop r9
 2422 0d82 8F90      		pop r8
 2423 0d84 7F90      		pop r7
 2424 0d86 0895      		ret
 2425               	.LFE59:
 2427               		.section	.rodata.str1.1,"aMS",@progbits,1
 2428               	.LC1:
 2429 0000 3000      		.string	"0"
 2430               		.text
 2431               	.global	returnInt
 2433               	returnInt:
 2434               	.LFB68:
2549:switcherator.c **** 
2550:switcherator.c **** // sets the time limits for switches to affect progams
2551:switcherator.c **** // TL:##HHMMHHMMddddddd
2552:switcherator.c **** // 01234567890123456789
2553:switcherator.c **** 
2554:switcherator.c **** void setTimeLimits(char * commandReceived) {
2555:switcherator.c ****     char tempReallyLongString[] = "0000000";
2556:switcherator.c ****     int programNumber = 0;
2557:switcherator.c ****     long weekLong = 0;
2558:switcherator.c ****     long startTime = 0;
2559:switcherator.c ****     long stopTime = 0;
2560:switcherator.c ****     int x = 0;
2561:switcherator.c ****     statusMsg[0] = 0;
2562:switcherator.c ****     unsigned int startHour, startMinute, stopHour, stopMinute;
2563:switcherator.c ****     tempIntString[0] = commandReceived[3];
2564:switcherator.c ****     tempIntString[1] = commandReceived[4];
2565:switcherator.c ****     programNumber = atoi(tempIntString);
2566:switcherator.c ****     if (programNumber > NUM_LIMITS) {
2567:switcherator.c ****         fail(0x10);
2568:switcherator.c ****         return;
2569:switcherator.c ****     }
2570:switcherator.c ****     if (commandReceived[5] == 'x' || commandReceived[5] == 'x') {
2571:switcherator.c ****         timeLimits[programNumber][2] = 0;
2572:switcherator.c ****         ok();
2573:switcherator.c ****         return;
2574:switcherator.c ****     }
2575:switcherator.c ****     if (commandReceived[5] == '?') {
2576:switcherator.c ****         // show the limit.
2577:switcherator.c ****         startTime = timeLimits[programNumber][0];
2578:switcherator.c ****         stopTime = timeLimits[programNumber][1];
2579:switcherator.c ****         strcat(statusMsg, "Start:");
2580:switcherator.c ****         startHour = (startTime / 60 / 60);
2581:switcherator.c ****         returnInt(startHour, tempLongString);
2582:switcherator.c ****         strcat(statusMsg, tempLongString);
2583:switcherator.c ****         startMinute = ((startTime - (startHour * 60 * 60)) / 60);
2584:switcherator.c ****         strcat(statusMsg, ":");
2585:switcherator.c ****         returnInt(startMinute, tempLongString);
2586:switcherator.c ****         strcat(statusMsg, tempLongString);
2587:switcherator.c ****         strcat(statusMsg, "Stop:");
2588:switcherator.c ****         stopHour = (startTime / 60 / 60);
2589:switcherator.c ****         returnInt(stopHour, tempLongString);
2590:switcherator.c ****         strcat(statusMsg, tempLongString);
2591:switcherator.c ****         stopMinute = ((startTime - (stopHour * 60 * 60)) / 60);
2592:switcherator.c ****         strcat(statusMsg, ":");
2593:switcherator.c ****         returnInt(stopMinute, tempLongString);
2594:switcherator.c ****         strcat(statusMsg, tempLongString);
2595:switcherator.c ****         sendMessage(statusMsg);
2596:switcherator.c ****         return;
2597:switcherator.c ****     }
2598:switcherator.c ****     for (x = 0; x < 7; x++) {
2599:switcherator.c ****         tempReallyLongString[x] = commandReceived[x + 13];
2600:switcherator.c ****     }
2601:switcherator.c ****     weekLong = strtol(tempReallyLongString, 0, 2);
2602:switcherator.c ****     tempIntString[0] = commandReceived[5];
2603:switcherator.c ****     tempIntString[1] = commandReceived[6];
2604:switcherator.c ****     startHour = atoi(tempIntString);
2605:switcherator.c ****     tempIntString[0] = commandReceived[7];
2606:switcherator.c ****     tempIntString[1] = commandReceived[8];
2607:switcherator.c ****     startMinute = atoi(tempIntString);
2608:switcherator.c ****     tempIntString[0] = commandReceived[9];
2609:switcherator.c ****     tempIntString[1] = commandReceived[10];
2610:switcherator.c ****     stopHour = atoi(tempIntString);
2611:switcherator.c ****     tempIntString[0] = commandReceived[11];
2612:switcherator.c ****     tempIntString[1] = commandReceived[12];
2613:switcherator.c ****     stopMinute = atoi(tempIntString);
2614:switcherator.c ****     if (startHour > 23 || stopHour > 23) {
2615:switcherator.c ****         fail(0x09);
2616:switcherator.c ****         return;
2617:switcherator.c ****     }
2618:switcherator.c ****     if (startMinute > 59 || stopMinute > 59) {
2619:switcherator.c ****         fail(0x0A);
2620:switcherator.c ****         return;
2621:switcherator.c ****     }
2622:switcherator.c ****     startTime = startHour;
2623:switcherator.c ****     startTime = startTime * 60 * 60;
2624:switcherator.c ****     startTime += (startMinute * 60);
2625:switcherator.c ****     stopTime = stopHour;
2626:switcherator.c ****     stopTime = stopTime * 60 * 60;
2627:switcherator.c ****     stopTime += (stopMinute * 60);
2628:switcherator.c ****     timeLimits[programNumber][0] = startTime;
2629:switcherator.c ****     timeLimits[programNumber][1] = stopTime;
2630:switcherator.c ****     timeLimits[programNumber][2] = weekLong;
2631:switcherator.c ****     ok();
2632:switcherator.c **** 
2633:switcherator.c **** }
2634:switcherator.c **** 
2635:switcherator.c **** // take in 3 digits to tweak the clock time
2636:switcherator.c **** // CT xxxx
2637:switcherator.c **** 
2638:switcherator.c **** void clockTweak(char * commandReceived) {
2639:switcherator.c ****     int x = 0;
2640:switcherator.c ****     for (x = 0; x < 4; x++) {
2641:switcherator.c ****         tempLongString[x] = commandReceived[(x + 3)];
2642:switcherator.c ****     }
2643:switcherator.c ****     int adjustment = atoi(tempLongString);
2644:switcherator.c ****     if (adjustment == 0) {
2645:switcherator.c ****         itoa(tweakTimer, tempLongString, 10);
2646:switcherator.c ****         statusMsg[0] = 0;
2647:switcherator.c ****         strcat(statusMsg, "Curr Tweak:");
2648:switcherator.c ****         strcat(statusMsg, tempLongString);
2649:switcherator.c ****         sendMessage(statusMsg);
2650:switcherator.c ****         return;
2651:switcherator.c ****     }
2652:switcherator.c ****     tweakTimer += adjustment;
2653:switcherator.c ****     ok();
2654:switcherator.c **** }
2655:switcherator.c **** 
2656:switcherator.c **** /****************************************************************
2657:switcherator.c ****  *
2658:switcherator.c ****  *              All Things debug and output Related
2659:switcherator.c ****  *
2660:switcherator.c ****  ****************************************************************/
2661:switcherator.c **** 
2662:switcherator.c **** 
2663:switcherator.c **** 
2664:switcherator.c **** 
2665:switcherator.c **** 
2666:switcherator.c **** 
2667:switcherator.c **** // sends a general status
2668:switcherator.c **** // basically an overview of the system
2669:switcherator.c **** 
2670:switcherator.c **** void generalStatus(char * commandReceived) {
2671:switcherator.c ****     statusMsg[0] = 0;
2672:switcherator.c ****     tempIntString[0] = commandReceived[2];
2673:switcherator.c ****     tempIntString[1] = commandReceived[3];
2674:switcherator.c **** 
2675:switcherator.c **** 
2676:switcherator.c ****     if (panicMyClockIsNotSet == 1) {
2677:switcherator.c ****         strcat(statusMsg, " T:xx/xx/xxxx xx:xx:xx");
2678:switcherator.c ****     } else {
2679:switcherator.c ****         strcat(statusMsg, " T:");
2680:switcherator.c ****         returnInt(globalMonth, tempLongString);
2681:switcherator.c ****         strcat(statusMsg, tempLongString);
2682:switcherator.c ****         strcat(statusMsg, "/");
2683:switcherator.c ****         returnInt(globalDay, tempLongString);
2684:switcherator.c ****         strcat(statusMsg, tempLongString);
2685:switcherator.c ****         strcat(statusMsg, "/");
2686:switcherator.c ****         returnInt(globalYear, tempLongString);
2687:switcherator.c ****         strcat(statusMsg, tempLongString);
2688:switcherator.c ****         strcat(statusMsg, " ");
2689:switcherator.c ****         returnInt(globalHour, tempLongString);
2690:switcherator.c ****         strcat(statusMsg, tempLongString);
2691:switcherator.c ****         strcat(statusMsg, ":");
2692:switcherator.c ****         returnInt(globalMinute, tempLongString);
2693:switcherator.c ****         strcat(statusMsg, tempLongString);
2694:switcherator.c ****         strcat(statusMsg, ":");
2695:switcherator.c ****         returnInt(globalSecond, tempLongString);
2696:switcherator.c ****         strcat(statusMsg, tempLongString);
2697:switcherator.c ****     }
2698:switcherator.c ****     sendMessage(statusMsg);
2699:switcherator.c ****     statusMsg[0] = 0;
2700:switcherator.c ****     if (commandReceived[2] == 'q')
2701:switcherator.c ****         return;
2702:switcherator.c **** 
2703:switcherator.c ****     programsProgrammed();
2704:switcherator.c ****     switchesProgrammed();
2705:switcherator.c ****     inputsProgrammed();
2706:switcherator.c ****     switchesOn();
2707:switcherator.c **** }
2708:switcherator.c **** 
2709:switcherator.c **** // returns a basic view of the capabilities
2710:switcherator.c **** void generalInformation(void) {
2711:switcherator.c ****     statusMsg[0] = 0;
2712:switcherator.c ****     strcat(statusMsg,"Pr,");
2713:switcherator.c ****     int count = 0;
2714:switcherator.c ****     int x;
2715:switcherator.c ****     for(x=0;x<MAX_PROGRAM;x++) {
2716:switcherator.c ****         if(weeklyProgram[x][0] < 255 || weeklyProgram[x][1] < 255) 
2717:switcherator.c ****             count++;
2718:switcherator.c ****     }
2719:switcherator.c ****     returnInt(count,tempLongString);
2720:switcherator.c ****     strcat(statusMsg,tempLongString);
2721:switcherator.c ****     strcat(statusMsg,"/");
2722:switcherator.c ****     returnInt(MAX_PROGRAM,tempLongString);
2723:switcherator.c ****     strcat(statusMsg,tempLongString);
2724:switcherator.c ****     strcat(statusMsg,",Sw,");
2725:switcherator.c ****     count = 0;
2726:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
2727:switcherator.c ****         if (switchStuff[x] < 255)
2728:switcherator.c ****             count ++;
2729:switcherator.c ****     }
2730:switcherator.c ****     returnInt(count,tempLongString);
2731:switcherator.c ****     strcat(statusMsg,tempLongString);
2732:switcherator.c ****     strcat(statusMsg,"/");
2733:switcherator.c ****     returnInt(NUM_SWITCHES,tempLongString);
2734:switcherator.c ****     strcat(statusMsg,tempLongString);
2735:switcherator.c ****     sendMessage(statusMsg);
2736:switcherator.c ****     statusMsg[0] = 0;
2737:switcherator.c ****     strcat(statusMsg,",In,");
2738:switcherator.c ****     count = 0;
2739:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
2740:switcherator.c ****         if (inputs[x][0] < 255)
2741:switcherator.c ****             count ++;
2742:switcherator.c ****     }
2743:switcherator.c ****     returnInt(count,tempLongString);
2744:switcherator.c ****     strcat(statusMsg,tempLongString);
2745:switcherator.c ****     strcat(statusMsg,"/");
2746:switcherator.c ****     returnInt(NUM_INPUTS,tempLongString);
2747:switcherator.c ****     strcat(statusMsg,tempLongString);
2748:switcherator.c ****     strcat(statusMsg,",Li,");
2749:switcherator.c ****     count = 0;
2750:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++) {
2751:switcherator.c ****         if (inputs[x][2] > 0)
2752:switcherator.c ****             count ++;
2753:switcherator.c ****     }
2754:switcherator.c ****     returnInt(count,tempLongString);
2755:switcherator.c ****     strcat(statusMsg,tempLongString);
2756:switcherator.c ****     strcat(statusMsg,"/");
2757:switcherator.c ****     returnInt(NUM_LIMITS,tempLongString);
2758:switcherator.c ****     strcat(statusMsg,tempLongString);
2759:switcherator.c ****     strcat(statusMsg,",CC,");
2760:switcherator.c ****     count = 0;
2761:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
2762:switcherator.c ****         if (colorChanges[x][0] != 0 || colorChanges[x][1] != 1 || colorChanges[x][2] != 0)
2763:switcherator.c ****             count ++;
2764:switcherator.c ****     }
2765:switcherator.c ****     returnInt(count,tempLongString);
2766:switcherator.c ****     strcat(statusMsg,tempLongString);
2767:switcherator.c ****     strcat(statusMsg,"/");
2768:switcherator.c ****     returnInt(NUM_COLOR_CHANGES,tempLongString);
2769:switcherator.c ****     strcat(statusMsg,tempLongString);
2770:switcherator.c ****     sendMessage(statusMsg);
2771:switcherator.c **** }
2772:switcherator.c **** 
2773:switcherator.c **** // transmits Y or N for which programs have been programmed
2774:switcherator.c **** void programsProgrammed(void) {
2775:switcherator.c ****     statusMsg[0] = 0;
2776:switcherator.c ****     strcat(statusMsg, "Progs:");
2777:switcherator.c ****     int x;
2778:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
2779:switcherator.c ****         if (weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) {
2780:switcherator.c ****             strcat(statusMsg, "n");
2781:switcherator.c ****         } else {
2782:switcherator.c ****             strcat(statusMsg, "y");
2783:switcherator.c ****         }
2784:switcherator.c ****         // can only send 32 bytes at a time
2785:switcherator.c ****         if (strlen(statusMsg) > 30) {
2786:switcherator.c ****             sendMessage(statusMsg);
2787:switcherator.c ****             statusMsg[6] = 0;
2788:switcherator.c ****         }
2789:switcherator.c ****     }
2790:switcherator.c ****     sendMessage(statusMsg);    
2791:switcherator.c **** }
2792:switcherator.c **** // transmits Y or N for which switches have been programmed
2793:switcherator.c **** void switchesProgrammed(void) {
2794:switcherator.c ****     statusMsg[0] = 0;
2795:switcherator.c ****     strcat(statusMsg, "Swi:");
2796:switcherator.c ****     int x;
2797:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
2798:switcherator.c **** 
2799:switcherator.c ****         if (switchStuff[x] == 255) {
2800:switcherator.c ****             strcat(statusMsg, "n");
2801:switcherator.c ****         } else {
2802:switcherator.c ****             strcat(statusMsg, "y");
2803:switcherator.c ****         }
2804:switcherator.c ****         // can only send 32 bytes at a time
2805:switcherator.c ****         if (strlen(statusMsg) > 30) {
2806:switcherator.c ****             sendMessage(statusMsg);
2807:switcherator.c ****             statusMsg[4] = 0;
2808:switcherator.c ****         }
2809:switcherator.c ****     }
2810:switcherator.c ****     sendMessage(statusMsg);
2811:switcherator.c **** }
2812:switcherator.c **** 
2813:switcherator.c **** // transmits Y or N for which inputs have been programmed
2814:switcherator.c **** void inputsProgrammed(void) {
2815:switcherator.c ****     statusMsg[0] = 0;
2816:switcherator.c ****     strcat(statusMsg, "Inp:");
2817:switcherator.c ****     int x;
2818:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
2819:switcherator.c ****         if (inputs[x][0] == 255) {
2820:switcherator.c ****             strcat(statusMsg, "n");
2821:switcherator.c ****         } else {
2822:switcherator.c ****             strcat(statusMsg, "y");
2823:switcherator.c ****         }
2824:switcherator.c ****         // can only send 32 bytes at a time
2825:switcherator.c ****         if (strlen(statusMsg) > 30) {
2826:switcherator.c ****             sendMessage(statusMsg);
2827:switcherator.c ****             statusMsg[4] = 0;
2828:switcherator.c ****         }
2829:switcherator.c ****     }
2830:switcherator.c ****     sendMessage(statusMsg);
2831:switcherator.c **** }
2832:switcherator.c **** 
2833:switcherator.c **** // transmits Y or N for which switches are currently turned on
2834:switcherator.c **** void switchesOn(void) {
2835:switcherator.c ****     statusMsg[0] = 0;
2836:switcherator.c ****     strcat(statusMsg, "SwOn:");
2837:switcherator.c ****     int x;
2838:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
2839:switcherator.c ****         if (switchStatus[x] > 0) {
2840:switcherator.c ****             strcat(statusMsg, "y");
2841:switcherator.c ****         } else {
2842:switcherator.c ****             strcat(statusMsg, "n");
2843:switcherator.c ****         }
2844:switcherator.c ****         if (strlen(statusMsg) > 30) {
2845:switcherator.c ****             sendMessage(statusMsg);
2846:switcherator.c ****             statusMsg[5] = 0;
2847:switcherator.c ****         }
2848:switcherator.c ****     }
2849:switcherator.c ****     sendMessage(statusMsg);
2850:switcherator.c **** }
2851:switcherator.c **** 
2852:switcherator.c **** void returnInt(int number, char * thisString) {
 2435               		.loc 1 2852 0
 2436               	.LVL131:
 2437 0d88 CF93      		push r28
 2438               	.LCFI66:
 2439 0d8a DF93      		push r29
 2440               	.LCFI67:
 2441               	/* prologue: function */
 2442               	/* frame size = 0 */
 2443               	/* stack size = 2 */
 2444               	.L__stack_usage = 2
 2445 0d8c EB01      		movw r28,r22
2853:switcherator.c ****     thisString[0] = 0;
 2446               		.loc 1 2853 0
 2447 0d8e 1882      		st Y,__zero_reg__
2854:switcherator.c ****     itoa(number, tempHugeString, 10);
 2448               		.loc 1 2854 0
 2449 0d90 4AE0      		ldi r20,lo8(10)
 2450 0d92 50E0      		ldi r21,0
 2451 0d94 60E0      		ldi r22,lo8(tempHugeString)
 2452 0d96 70E0      		ldi r23,hi8(tempHugeString)
 2453               	.LVL132:
 2454 0d98 0E94 0000 		call itoa
 2455               	.LVL133:
2855:switcherator.c ****     if (strlen(tempHugeString) == 1)
 2456               		.loc 1 2855 0
 2457 0d9c E0E0      		ldi r30,lo8(tempHugeString)
 2458 0d9e F0E0      		ldi r31,hi8(tempHugeString)
 2459               		0:
 2460 0da0 0190      		ld __tmp_reg__,Z+
 2461 0da2 0020      		tst __tmp_reg__
 2462 0da4 01F4      		brne 0b
 2463 0da6 E050      		subi r30,lo8(tempHugeString+2)
 2464 0da8 F040      		sbci r31,hi8(tempHugeString+2)
 2465 0daa 01F4      		brne .L188
2856:switcherator.c ****         strcat(thisString, "0");
 2466               		.loc 1 2856 0
 2467 0dac 60E0      		ldi r22,lo8(.LC1)
 2468 0dae 70E0      		ldi r23,hi8(.LC1)
 2469 0db0 CE01      		movw r24,r28
 2470 0db2 0E94 0000 		call strcat
 2471               	.LVL134:
 2472               	.L188:
2857:switcherator.c ****     strcat(thisString, tempHugeString);
 2473               		.loc 1 2857 0
 2474 0db6 60E0      		ldi r22,lo8(tempHugeString)
 2475 0db8 70E0      		ldi r23,hi8(tempHugeString)
 2476 0dba CE01      		movw r24,r28
 2477               	/* epilogue start */
2858:switcherator.c **** }
 2478               		.loc 1 2858 0
 2479 0dbc DF91      		pop r29
 2480 0dbe CF91      		pop r28
 2481               	.LVL135:
2857:switcherator.c ****     strcat(thisString, tempHugeString);
 2482               		.loc 1 2857 0
 2483 0dc0 0C94 0000 		jmp strcat
 2484               	.LVL136:
 2485               	.LFE68:
 2487               		.section	.rodata.str1.1
 2488               	.LC2:
 2489 0002 2000      		.string	" "
 2490               	.LC3:
 2491 0004 2F00      		.string	"/"
 2492               	.LC4:
 2493 0006 3A00      		.string	":"
 2494               		.text
 2495               	.global	clockString
 2497               	clockString:
 2498               	.LFB50:
2199:switcherator.c **** void clockString(void) {
 2499               		.loc 1 2199 0
 2500               	/* prologue: function */
 2501               	/* frame size = 0 */
 2502               	/* stack size = 0 */
 2503               	.L__stack_usage = 0
2200:switcherator.c ****     statusMsg[0] = 0;
 2504               		.loc 1 2200 0
 2505 0dc4 1092 0000 		sts statusMsg,__zero_reg__
2202:switcherator.c ****     strcat(statusMsg, " ");
 2506               		.loc 1 2202 0
 2507 0dc8 60E0      		ldi r22,lo8(.LC2)
 2508 0dca 70E0      		ldi r23,hi8(.LC2)
 2509 0dcc 80E0      		ldi r24,lo8(statusMsg)
 2510 0dce 90E0      		ldi r25,hi8(statusMsg)
 2511 0dd0 0E94 0000 		call strcat
 2512               	.LVL137:
2203:switcherator.c ****     returnInt(globalMonth, tempIntString);
 2513               		.loc 1 2203 0
 2514 0dd4 60E0      		ldi r22,lo8(tempIntString)
 2515 0dd6 70E0      		ldi r23,hi8(tempIntString)
 2516 0dd8 8091 0000 		lds r24,globalMonth
 2517 0ddc 9091 0000 		lds r25,globalMonth+1
 2518 0de0 0E94 0000 		call returnInt
 2519               	.LVL138:
2204:switcherator.c ****     strcat(statusMsg, tempIntString);
 2520               		.loc 1 2204 0
 2521 0de4 60E0      		ldi r22,lo8(tempIntString)
 2522 0de6 70E0      		ldi r23,hi8(tempIntString)
 2523 0de8 80E0      		ldi r24,lo8(statusMsg)
 2524 0dea 90E0      		ldi r25,hi8(statusMsg)
 2525 0dec 0E94 0000 		call strcat
 2526               	.LVL139:
2205:switcherator.c ****     strcat(statusMsg, "/");
 2527               		.loc 1 2205 0
 2528 0df0 60E0      		ldi r22,lo8(.LC3)
 2529 0df2 70E0      		ldi r23,hi8(.LC3)
 2530 0df4 80E0      		ldi r24,lo8(statusMsg)
 2531 0df6 90E0      		ldi r25,hi8(statusMsg)
 2532 0df8 0E94 0000 		call strcat
 2533               	.LVL140:
2206:switcherator.c ****     returnInt(globalDay, tempIntString);
 2534               		.loc 1 2206 0
 2535 0dfc 60E0      		ldi r22,lo8(tempIntString)
 2536 0dfe 70E0      		ldi r23,hi8(tempIntString)
 2537 0e00 8091 0000 		lds r24,globalDay
 2538 0e04 9091 0000 		lds r25,globalDay+1
 2539 0e08 0E94 0000 		call returnInt
 2540               	.LVL141:
2207:switcherator.c ****     strcat(statusMsg, tempIntString);
 2541               		.loc 1 2207 0
 2542 0e0c 60E0      		ldi r22,lo8(tempIntString)
 2543 0e0e 70E0      		ldi r23,hi8(tempIntString)
 2544 0e10 80E0      		ldi r24,lo8(statusMsg)
 2545 0e12 90E0      		ldi r25,hi8(statusMsg)
 2546 0e14 0E94 0000 		call strcat
 2547               	.LVL142:
2208:switcherator.c ****     strcat(statusMsg, "/");
 2548               		.loc 1 2208 0
 2549 0e18 60E0      		ldi r22,lo8(.LC3)
 2550 0e1a 70E0      		ldi r23,hi8(.LC3)
 2551 0e1c 80E0      		ldi r24,lo8(statusMsg)
 2552 0e1e 90E0      		ldi r25,hi8(statusMsg)
 2553 0e20 0E94 0000 		call strcat
 2554               	.LVL143:
2209:switcherator.c ****     itoa(globalYear, tempIntString, 10);
 2555               		.loc 1 2209 0
 2556 0e24 4AE0      		ldi r20,lo8(10)
 2557 0e26 50E0      		ldi r21,0
 2558 0e28 60E0      		ldi r22,lo8(tempIntString)
 2559 0e2a 70E0      		ldi r23,hi8(tempIntString)
 2560 0e2c 8091 0000 		lds r24,globalYear
 2561 0e30 9091 0000 		lds r25,globalYear+1
 2562 0e34 0E94 0000 		call itoa
 2563               	.LVL144:
2210:switcherator.c ****     strcat(statusMsg, tempIntString);
 2564               		.loc 1 2210 0
 2565 0e38 60E0      		ldi r22,lo8(tempIntString)
 2566 0e3a 70E0      		ldi r23,hi8(tempIntString)
 2567 0e3c 80E0      		ldi r24,lo8(statusMsg)
 2568 0e3e 90E0      		ldi r25,hi8(statusMsg)
 2569 0e40 0E94 0000 		call strcat
 2570               	.LVL145:
2211:switcherator.c ****     strcat(statusMsg, " ");
 2571               		.loc 1 2211 0
 2572 0e44 60E0      		ldi r22,lo8(.LC2)
 2573 0e46 70E0      		ldi r23,hi8(.LC2)
 2574 0e48 80E0      		ldi r24,lo8(statusMsg)
 2575 0e4a 90E0      		ldi r25,hi8(statusMsg)
 2576 0e4c 0E94 0000 		call strcat
 2577               	.LVL146:
2212:switcherator.c ****     returnInt(globalHour, tempIntString);
 2578               		.loc 1 2212 0
 2579 0e50 60E0      		ldi r22,lo8(tempIntString)
 2580 0e52 70E0      		ldi r23,hi8(tempIntString)
 2581 0e54 8091 0000 		lds r24,globalHour
 2582 0e58 9091 0000 		lds r25,globalHour+1
 2583 0e5c 0E94 0000 		call returnInt
 2584               	.LVL147:
2213:switcherator.c ****     strcat(statusMsg, tempIntString);
 2585               		.loc 1 2213 0
 2586 0e60 60E0      		ldi r22,lo8(tempIntString)
 2587 0e62 70E0      		ldi r23,hi8(tempIntString)
 2588 0e64 80E0      		ldi r24,lo8(statusMsg)
 2589 0e66 90E0      		ldi r25,hi8(statusMsg)
 2590 0e68 0E94 0000 		call strcat
 2591               	.LVL148:
2214:switcherator.c ****     strcat(statusMsg, ":");
 2592               		.loc 1 2214 0
 2593 0e6c 60E0      		ldi r22,lo8(.LC4)
 2594 0e6e 70E0      		ldi r23,hi8(.LC4)
 2595 0e70 80E0      		ldi r24,lo8(statusMsg)
 2596 0e72 90E0      		ldi r25,hi8(statusMsg)
 2597 0e74 0E94 0000 		call strcat
 2598               	.LVL149:
2215:switcherator.c ****     returnInt(globalMinute, tempIntString);
 2599               		.loc 1 2215 0
 2600 0e78 60E0      		ldi r22,lo8(tempIntString)
 2601 0e7a 70E0      		ldi r23,hi8(tempIntString)
 2602 0e7c 8091 0000 		lds r24,globalMinute
 2603 0e80 9091 0000 		lds r25,globalMinute+1
 2604 0e84 0E94 0000 		call returnInt
 2605               	.LVL150:
2216:switcherator.c ****     strcat(statusMsg, tempIntString);
 2606               		.loc 1 2216 0
 2607 0e88 60E0      		ldi r22,lo8(tempIntString)
 2608 0e8a 70E0      		ldi r23,hi8(tempIntString)
 2609 0e8c 80E0      		ldi r24,lo8(statusMsg)
 2610 0e8e 90E0      		ldi r25,hi8(statusMsg)
 2611 0e90 0E94 0000 		call strcat
 2612               	.LVL151:
2217:switcherator.c ****     strcat(statusMsg, ":");
 2613               		.loc 1 2217 0
 2614 0e94 60E0      		ldi r22,lo8(.LC4)
 2615 0e96 70E0      		ldi r23,hi8(.LC4)
 2616 0e98 80E0      		ldi r24,lo8(statusMsg)
 2617 0e9a 90E0      		ldi r25,hi8(statusMsg)
 2618 0e9c 0E94 0000 		call strcat
 2619               	.LVL152:
2218:switcherator.c ****     returnInt(globalSecond, tempIntString);
 2620               		.loc 1 2218 0
 2621 0ea0 60E0      		ldi r22,lo8(tempIntString)
 2622 0ea2 70E0      		ldi r23,hi8(tempIntString)
 2623 0ea4 8091 0000 		lds r24,globalSecond
 2624 0ea8 9091 0000 		lds r25,globalSecond+1
 2625 0eac 0E94 0000 		call returnInt
 2626               	.LVL153:
2219:switcherator.c ****     strcat(statusMsg, tempIntString);
 2627               		.loc 1 2219 0
 2628 0eb0 60E0      		ldi r22,lo8(tempIntString)
 2629 0eb2 70E0      		ldi r23,hi8(tempIntString)
 2630 0eb4 80E0      		ldi r24,lo8(statusMsg)
 2631 0eb6 90E0      		ldi r25,hi8(statusMsg)
 2632 0eb8 0C94 0000 		jmp strcat
 2633               	.LVL154:
 2634               	.LFE50:
 2636               		.section	.rodata.str1.1
 2637               	.LC5:
 2638 0008 3078 00   		.string	"0x"
 2639               		.text
 2640               	.global	returnHex
 2642               	returnHex:
 2643               	.LFB69:
2859:switcherator.c **** 
2860:switcherator.c **** void returnHex(unsigned int number, char * thisString) {
 2644               		.loc 1 2860 0
 2645               	.LVL155:
 2646 0ebc 0F93      		push r16
 2647               	.LCFI68:
 2648 0ebe 1F93      		push r17
 2649               	.LCFI69:
 2650 0ec0 CF93      		push r28
 2651               	.LCFI70:
 2652 0ec2 DF93      		push r29
 2653               	.LCFI71:
 2654               	/* prologue: function */
 2655               	/* frame size = 0 */
 2656               	/* stack size = 4 */
 2657               	.L__stack_usage = 4
 2658 0ec4 8C01      		movw r16,r24
 2659 0ec6 EB01      		movw r28,r22
2861:switcherator.c ****     thisString[0] = 0;
 2660               		.loc 1 2861 0
 2661 0ec8 1882      		st Y,__zero_reg__
2862:switcherator.c ****     strcat(thisString, "0x");
 2662               		.loc 1 2862 0
 2663 0eca 60E0      		ldi r22,lo8(.LC5)
 2664 0ecc 70E0      		ldi r23,hi8(.LC5)
 2665               	.LVL156:
 2666 0ece CE01      		movw r24,r28
 2667               	.LVL157:
 2668 0ed0 0E94 0000 		call strcat
 2669               	.LVL158:
2863:switcherator.c ****     itoa(number, tempHugeString, 16);
 2670               		.loc 1 2863 0
 2671 0ed4 40E1      		ldi r20,lo8(16)
 2672 0ed6 50E0      		ldi r21,0
 2673 0ed8 60E0      		ldi r22,lo8(tempHugeString)
 2674 0eda 70E0      		ldi r23,hi8(tempHugeString)
 2675 0edc C801      		movw r24,r16
 2676 0ede 0E94 0000 		call itoa
 2677               	.LVL159:
2864:switcherator.c ****     if (strlen(tempHugeString) == 1 || strlen(tempHugeString) == 3)
 2678               		.loc 1 2864 0
 2679 0ee2 E0E0      		ldi r30,lo8(tempHugeString)
 2680 0ee4 F0E0      		ldi r31,hi8(tempHugeString)
 2681               		0:
 2682 0ee6 0190      		ld __tmp_reg__,Z+
 2683 0ee8 0020      		tst __tmp_reg__
 2684 0eea 01F4      		brne 0b
 2685 0eec 3197      		sbiw r30,1
 2686 0eee E050      		subi r30,lo8(tempHugeString)
 2687 0ef0 F040      		sbci r31,hi8(tempHugeString)
 2688 0ef2 E130      		cpi r30,1
 2689 0ef4 F105      		cpc r31,__zero_reg__
 2690 0ef6 01F0      		breq .L191
 2691               		.loc 1 2864 0 is_stmt 0 discriminator 1
 2692 0ef8 3397      		sbiw r30,3
 2693 0efa 01F4      		brne .L192
 2694               	.L191:
2865:switcherator.c ****         strcat(thisString, "0");
 2695               		.loc 1 2865 0 is_stmt 1
 2696 0efc 60E0      		ldi r22,lo8(.LC1)
 2697 0efe 70E0      		ldi r23,hi8(.LC1)
 2698 0f00 CE01      		movw r24,r28
 2699 0f02 0E94 0000 		call strcat
 2700               	.LVL160:
 2701               	.L192:
2866:switcherator.c ****     strcat(thisString, tempHugeString);
 2702               		.loc 1 2866 0
 2703 0f06 60E0      		ldi r22,lo8(tempHugeString)
 2704 0f08 70E0      		ldi r23,hi8(tempHugeString)
 2705 0f0a CE01      		movw r24,r28
 2706               	/* epilogue start */
2867:switcherator.c **** }
 2707               		.loc 1 2867 0
 2708 0f0c DF91      		pop r29
 2709 0f0e CF91      		pop r28
 2710               	.LVL161:
 2711 0f10 1F91      		pop r17
 2712 0f12 0F91      		pop r16
 2713               	.LVL162:
2866:switcherator.c ****     strcat(thisString, tempHugeString);
 2714               		.loc 1 2866 0
 2715 0f14 0C94 0000 		jmp strcat
 2716               	.LVL163:
 2717               	.LFE69:
 2719               	.global	returnHexWithout
 2721               	returnHexWithout:
 2722               	.LFB70:
2868:switcherator.c **** 
2869:switcherator.c **** 
2870:switcherator.c **** 
2871:switcherator.c **** // print hex without 0x
2872:switcherator.c **** 
2873:switcherator.c **** void returnHexWithout(unsigned int number, char * tempMe) {
 2723               		.loc 1 2873 0
 2724               	.LVL164:
 2725 0f18 CF93      		push r28
 2726               	.LCFI72:
 2727 0f1a DF93      		push r29
 2728               	.LCFI73:
 2729               	/* prologue: function */
 2730               	/* frame size = 0 */
 2731               	/* stack size = 2 */
 2732               	.L__stack_usage = 2
 2733 0f1c EB01      		movw r28,r22
2874:switcherator.c ****     tempMe[0] = 0;
 2734               		.loc 1 2874 0
 2735 0f1e 1882      		st Y,__zero_reg__
2875:switcherator.c ****     itoa(number, tempHugeString, 16);
 2736               		.loc 1 2875 0
 2737 0f20 40E1      		ldi r20,lo8(16)
 2738 0f22 50E0      		ldi r21,0
 2739 0f24 60E0      		ldi r22,lo8(tempHugeString)
 2740 0f26 70E0      		ldi r23,hi8(tempHugeString)
 2741               	.LVL165:
 2742 0f28 0E94 0000 		call itoa
 2743               	.LVL166:
2876:switcherator.c ****     if (strlen(tempHugeString) == 1 || strlen(tempHugeString) == 3)
 2744               		.loc 1 2876 0
 2745 0f2c E0E0      		ldi r30,lo8(tempHugeString)
 2746 0f2e F0E0      		ldi r31,hi8(tempHugeString)
 2747               		0:
 2748 0f30 0190      		ld __tmp_reg__,Z+
 2749 0f32 0020      		tst __tmp_reg__
 2750 0f34 01F4      		brne 0b
 2751 0f36 3197      		sbiw r30,1
 2752 0f38 E050      		subi r30,lo8(tempHugeString)
 2753 0f3a F040      		sbci r31,hi8(tempHugeString)
 2754 0f3c E130      		cpi r30,1
 2755 0f3e F105      		cpc r31,__zero_reg__
 2756 0f40 01F0      		breq .L197
 2757               		.loc 1 2876 0 is_stmt 0 discriminator 1
 2758 0f42 3397      		sbiw r30,3
 2759 0f44 01F4      		brne .L198
 2760               	.L197:
2877:switcherator.c ****         strcat(tempMe, "0");
 2761               		.loc 1 2877 0 is_stmt 1
 2762 0f46 60E0      		ldi r22,lo8(.LC1)
 2763 0f48 70E0      		ldi r23,hi8(.LC1)
 2764 0f4a CE01      		movw r24,r28
 2765 0f4c 0E94 0000 		call strcat
 2766               	.LVL167:
 2767               	.L198:
2878:switcherator.c ****     strcat(tempMe, tempHugeString);
 2768               		.loc 1 2878 0
 2769 0f50 60E0      		ldi r22,lo8(tempHugeString)
 2770 0f52 70E0      		ldi r23,hi8(tempHugeString)
 2771 0f54 CE01      		movw r24,r28
 2772               	/* epilogue start */
2879:switcherator.c **** }
 2773               		.loc 1 2879 0
 2774 0f56 DF91      		pop r29
 2775 0f58 CF91      		pop r28
 2776               	.LVL168:
2878:switcherator.c ****     strcat(tempMe, tempHugeString);
 2777               		.loc 1 2878 0
 2778 0f5a 0C94 0000 		jmp strcat
 2779               	.LVL169:
 2780               	.LFE70:
 2782               	.global	formatAddress
 2784               	formatAddress:
 2785               	.LFB73:
2880:switcherator.c **** 
2881:switcherator.c **** // Clock interrupt - fires when the compare is off
2882:switcherator.c **** 
2883:switcherator.c **** /****************************************************************
2884:switcherator.c ****  *
2885:switcherator.c ****  *              All Things Radio Related
2886:switcherator.c ****  *
2887:switcherator.c ****  ****************************************************************/
2888:switcherator.c **** 
2889:switcherator.c **** // initialize the radio
2890:switcherator.c **** 
2891:switcherator.c **** void radioInit(void) {
2892:switcherator.c ****     nrfInit();
2893:switcherator.c ****     rx_addr_p0 = SET_RX_ADDR_P0;
2894:switcherator.c ****     tx_addr = SET_TX_ADDR;
2895:switcherator.c ****     // use defaults the radio has
2896:switcherator.c ****     rx_addr_p1 = readAddr(RX_ADDR_P1);
2897:switcherator.c ****     rx_addr_p2 = readAddr(RX_ADDR_P2);
2898:switcherator.c ****     rx_addr_p3 = readAddr(RX_ADDR_P3);
2899:switcherator.c ****     rx_addr_p4 = readAddr(RX_ADDR_P4);
2900:switcherator.c ****     rx_addr_p5 = readAddr(RX_ADDR_P5);
2901:switcherator.c **** 
2902:switcherator.c ****     writeReg(RF_SETUP, SET_RF_SETUP);
2903:switcherator.c ****     writeAddr(RX_ADDR_P0, rx_addr_p0);
2904:switcherator.c ****     writeAddr(TX_ADDR, tx_addr);
2905:switcherator.c ****     writeReg(DYNPD, SET_DYNPD);
2906:switcherator.c ****     writeReg(FEATURE, SET_FEATURE);
2907:switcherator.c ****     writeReg(RF_CH, SET_RF_CH);
2908:switcherator.c ****     writeReg(CONFIG, SET_CONFIG);
2909:switcherator.c ****     writeReg(SETUP_RETR, SET_SETUP_RETR);
2910:switcherator.c **** 
2911:switcherator.c ****     // We've written the address - now see if we get the same result
2912:switcherator.c ****     radioTest();
2913:switcherator.c **** 
2914:switcherator.c ****     startRadio();
2915:switcherator.c **** 
2916:switcherator.c **** }
2917:switcherator.c **** 
2918:switcherator.c **** // radio test - just make sure it is still working
2919:switcherator.c **** int radioTest(void) {
2920:switcherator.c ****     uint64_t test_addr;
2921:switcherator.c ****     test_addr = readAddr(RX_ADDR_P0);    
2922:switcherator.c ****     if (test_addr != rx_addr_p0) {
2923:switcherator.c ****         // nope.  broken
2924:switcherator.c ****         failCondition = 1;
2925:switcherator.c ****         return -1;
2926:switcherator.c ****     }
2927:switcherator.c ****     if(failCondition == 1 || failCondition == 2)
2928:switcherator.c ****         clearFail();
2929:switcherator.c ****     return 1;
2930:switcherator.c **** }
2931:switcherator.c **** 
2932:switcherator.c **** // Take in an address and return a long long with the number
2933:switcherator.c **** 
2934:switcherator.c **** uint64_t formatAddress(char * address) {
 2786               		.loc 1 2934 0
 2787               	.LVL170:
 2788 0f5e 0F93      		push r16
 2789               	.LCFI74:
 2790 0f60 CF93      		push r28
 2791               	.LCFI75:
 2792               	/* prologue: function */
 2793               	/* frame size = 0 */
 2794               	/* stack size = 2 */
 2795               	.L__stack_usage = 2
 2796               	.LVL171:
 2797 0f62 DC01      		movw r26,r24
2935:switcherator.c ****     int x = 0;
2936:switcherator.c ****     uint64_t newAddress = 0;
 2798               		.loc 1 2936 0
 2799 0f64 20E0      		ldi r18,0
 2800 0f66 30E0      		ldi r19,0
 2801 0f68 40E0      		ldi r20,0
 2802 0f6a 50E0      		ldi r21,0
 2803 0f6c 60E0      		ldi r22,0
 2804 0f6e 70E0      		ldi r23,0
 2805 0f70 80E0      		ldi r24,0
 2806               	.LVL172:
 2807 0f72 90E0      		ldi r25,0
2937:switcherator.c ****     int tempInt;
2938:switcherator.c ****     for (x = 0; x < 5; x++) {
 2808               		.loc 1 2938 0
 2809 0f74 E0E0      		ldi r30,0
 2810 0f76 F0E0      		ldi r31,0
 2811               	.LVL173:
 2812               	.L205:
2939:switcherator.c ****         tempInt = address[x];
 2813               		.loc 1 2939 0
 2814 0f78 CD91      		ld r28,X+
 2815               	.LVL174:
 2816 0f7a C22B      		or r28,r18
 2817               	.LVL175:
2940:switcherator.c ****         if (x < 4) {
2941:switcherator.c ****             newAddress |= (tempInt);
2942:switcherator.c ****             newAddress <<= 8;
 2818               		.loc 1 2942 0
 2819 0f7c 2C2F      		mov r18,r28
2940:switcherator.c ****         if (x < 4) {
 2820               		.loc 1 2940 0
 2821 0f7e E430      		cpi r30,4
 2822 0f80 F105      		cpc r31,__zero_reg__
 2823 0f82 01F0      		breq .L204
 2824               		.loc 1 2942 0
 2825 0f84 08E0      		ldi r16,lo8(8)
 2826 0f86 0E94 0000 		call __ashldi3
 2827               	.LVL176:
 2828               	.L204:
2938:switcherator.c ****     for (x = 0; x < 5; x++) {
 2829               		.loc 1 2938 0
 2830 0f8a 3196      		adiw r30,1
 2831               	.LVL177:
 2832 0f8c E530      		cpi r30,5
 2833 0f8e F105      		cpc r31,__zero_reg__
 2834 0f90 01F4      		brne .L205
 2835               	/* epilogue start */
2943:switcherator.c ****         } else
2944:switcherator.c ****             newAddress |= tempInt;
2945:switcherator.c ****     }
2946:switcherator.c ****     return newAddress;
2947:switcherator.c **** }
 2836               		.loc 1 2947 0
 2837 0f92 CF91      		pop r28
 2838 0f94 0F91      		pop r16
 2839 0f96 0895      		ret
 2840               	.LFE73:
 2842               	.global	generalInit
 2844               	generalInit:
 2845               	.LFB42:
1727:switcherator.c **** void generalInit(void) {
 2846               		.loc 1 1727 0
 2847 0f98 EF92      		push r14
 2848               	.LCFI76:
 2849 0f9a FF92      		push r15
 2850               	.LCFI77:
 2851 0f9c 0F93      		push r16
 2852               	.LCFI78:
 2853 0f9e 1F93      		push r17
 2854               	.LCFI79:
 2855 0fa0 CF93      		push r28
 2856               	.LCFI80:
 2857 0fa2 DF93      		push r29
 2858               	.LCFI81:
 2859 0fa4 CDB7      		in r28,__SP_L__
 2860 0fa6 DEB7      		in r29,__SP_H__
 2861               	.LCFI82:
 2862 0fa8 2E97      		sbiw r28,14
 2863               	.LCFI83:
 2864 0faa 0FB6      		in __tmp_reg__,__SREG__
 2865 0fac F894      		cli
 2866 0fae DEBF      		out __SP_H__,r29
 2867 0fb0 0FBE      		out __SREG__,__tmp_reg__
 2868 0fb2 CDBF      		out __SP_L__,r28
 2869               	/* prologue: function */
 2870               	/* frame size = 14 */
 2871               	/* stack size = 20 */
 2872               	.L__stack_usage = 20
 2873               	.LVL178:
1733:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_TX, RADIO_ADDR_TX_BYTES) == 1) {
 2874               		.loc 1 1733 0
 2875 0fb4 47E0      		ldi r20,lo8(7)
 2876 0fb6 50E0      		ldi r21,0
 2877 0fb8 6EE0      		ldi r22,lo8(14)
 2878 0fba 70E0      		ldi r23,0
 2879 0fbc CE01      		movw r24,r28
 2880 0fbe 0196      		adiw r24,1
 2881 0fc0 0E94 0000 		call readEEPROM
 2882               	.LVL179:
 2883 0fc4 0197      		sbiw r24,1
 2884 0fc6 01F4      		brne .L208
1734:switcherator.c ****         tx_addr = formatAddress(tempStuff);
 2885               		.loc 1 1734 0
 2886 0fc8 CE01      		movw r24,r28
 2887 0fca 0196      		adiw r24,1
 2888 0fcc 0E94 0000 		call formatAddress
 2889               	.LVL180:
 2890 0fd0 2093 0000 		sts tx_addr,r18
 2891 0fd4 3093 0000 		sts tx_addr+1,r19
 2892 0fd8 4093 0000 		sts tx_addr+2,r20
 2893 0fdc 5093 0000 		sts tx_addr+3,r21
 2894 0fe0 6093 0000 		sts tx_addr+4,r22
 2895 0fe4 7093 0000 		sts tx_addr+5,r23
 2896 0fe8 8093 0000 		sts tx_addr+6,r24
 2897 0fec 9093 0000 		sts tx_addr+7,r25
1735:switcherator.c ****         writeAddr(TX_ADDR, tx_addr);
 2898               		.loc 1 1735 0
 2899 0ff0 8901      		movw r16,r18
 2900 0ff2 9A01      		movw r18,r20
 2901 0ff4 AB01      		movw r20,r22
 2902 0ff6 BC01      		movw r22,r24
 2903 0ff8 80E1      		ldi r24,lo8(16)
 2904 0ffa 0E94 0000 		call writeAddr
 2905               	.LVL181:
 2906               	.L208:
1737:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R0, RADIO_ADDR_R0_BYTES) == 1) {
 2907               		.loc 1 1737 0
 2908 0ffe 47E0      		ldi r20,lo8(7)
 2909 1000 50E0      		ldi r21,0
 2910 1002 65E1      		ldi r22,lo8(21)
 2911 1004 70E0      		ldi r23,0
 2912 1006 CE01      		movw r24,r28
 2913 1008 0196      		adiw r24,1
 2914 100a 0E94 0000 		call readEEPROM
 2915               	.LVL182:
 2916 100e 0197      		sbiw r24,1
 2917 1010 01F4      		brne .L209
1738:switcherator.c ****         rx_addr_p0 = formatAddress(tempStuff);
 2918               		.loc 1 1738 0
 2919 1012 CE01      		movw r24,r28
 2920 1014 0196      		adiw r24,1
 2921 1016 0E94 0000 		call formatAddress
 2922               	.LVL183:
 2923 101a 2093 0000 		sts rx_addr_p0,r18
 2924 101e 3093 0000 		sts rx_addr_p0+1,r19
 2925 1022 4093 0000 		sts rx_addr_p0+2,r20
 2926 1026 5093 0000 		sts rx_addr_p0+3,r21
 2927 102a 6093 0000 		sts rx_addr_p0+4,r22
 2928 102e 7093 0000 		sts rx_addr_p0+5,r23
 2929 1032 8093 0000 		sts rx_addr_p0+6,r24
 2930 1036 9093 0000 		sts rx_addr_p0+7,r25
1739:switcherator.c ****         writeAddr(RX_ADDR_P0, rx_addr_p0);
 2931               		.loc 1 1739 0
 2932 103a 8901      		movw r16,r18
 2933 103c 9A01      		movw r18,r20
 2934 103e AB01      		movw r20,r22
 2935 1040 BC01      		movw r22,r24
 2936 1042 8AE0      		ldi r24,lo8(10)
 2937 1044 0E94 0000 		call writeAddr
 2938               	.LVL184:
 2939               	.L209:
1742:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R1, RADIO_ADDR_R1_BYTES) == 1) {
 2940               		.loc 1 1742 0
 2941 1048 47E0      		ldi r20,lo8(7)
 2942 104a 50E0      		ldi r21,0
 2943 104c 6CE1      		ldi r22,lo8(28)
 2944 104e 70E0      		ldi r23,0
 2945 1050 CE01      		movw r24,r28
 2946 1052 0196      		adiw r24,1
 2947 1054 0E94 0000 		call readEEPROM
 2948               	.LVL185:
 2949 1058 0197      		sbiw r24,1
 2950 105a 01F4      		brne .L210
1743:switcherator.c ****         rx_addr_p1 = formatAddress(tempStuff);
 2951               		.loc 1 1743 0
 2952 105c CE01      		movw r24,r28
 2953 105e 0196      		adiw r24,1
 2954 1060 0E94 0000 		call formatAddress
 2955               	.LVL186:
 2956 1064 2093 0000 		sts rx_addr_p1,r18
 2957 1068 3093 0000 		sts rx_addr_p1+1,r19
 2958 106c 4093 0000 		sts rx_addr_p1+2,r20
 2959 1070 5093 0000 		sts rx_addr_p1+3,r21
 2960 1074 6093 0000 		sts rx_addr_p1+4,r22
 2961 1078 7093 0000 		sts rx_addr_p1+5,r23
 2962 107c 8093 0000 		sts rx_addr_p1+6,r24
 2963 1080 9093 0000 		sts rx_addr_p1+7,r25
1744:switcherator.c ****         writeAddr(RX_ADDR_P1, rx_addr_p1);
 2964               		.loc 1 1744 0
 2965 1084 8901      		movw r16,r18
 2966 1086 9A01      		movw r18,r20
 2967 1088 AB01      		movw r20,r22
 2968 108a BC01      		movw r22,r24
 2969 108c 8BE0      		ldi r24,lo8(11)
 2970 108e 0E94 0000 		call writeAddr
 2971               	.LVL187:
 2972               	.L210:
1746:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R2, RADIO_ADDR_R2_BYTES) == 1) {
 2973               		.loc 1 1746 0
 2974 1092 43E0      		ldi r20,lo8(3)
 2975 1094 50E0      		ldi r21,0
 2976 1096 63E2      		ldi r22,lo8(35)
 2977 1098 70E0      		ldi r23,0
 2978 109a CE01      		movw r24,r28
 2979 109c 0196      		adiw r24,1
 2980 109e 0E94 0000 		call readEEPROM
 2981               	.LVL188:
 2982 10a2 0197      		sbiw r24,1
 2983 10a4 01F4      		brne .L211
1747:switcherator.c ****         rx_addr_p2 = tempStuff[0];
 2984               		.loc 1 1747 0
 2985 10a6 0981      		ldd r16,Y+1
 2986 10a8 0093 0000 		sts rx_addr_p2,r16
 2987 10ac 1092 0000 		sts rx_addr_p2+1,__zero_reg__
 2988 10b0 1092 0000 		sts rx_addr_p2+2,__zero_reg__
 2989 10b4 1092 0000 		sts rx_addr_p2+3,__zero_reg__
 2990 10b8 1092 0000 		sts rx_addr_p2+4,__zero_reg__
 2991 10bc 1092 0000 		sts rx_addr_p2+5,__zero_reg__
 2992 10c0 1092 0000 		sts rx_addr_p2+6,__zero_reg__
 2993 10c4 1092 0000 		sts rx_addr_p2+7,__zero_reg__
1748:switcherator.c ****         writeAddr(RX_ADDR_P2, rx_addr_p2);
 2994               		.loc 1 1748 0
 2995 10c8 10E0      		ldi r17,0
 2996 10ca 20E0      		ldi r18,0
 2997 10cc 30E0      		ldi r19,0
 2998 10ce 40E0      		ldi r20,0
 2999 10d0 50E0      		ldi r21,0
 3000 10d2 60E0      		ldi r22,0
 3001 10d4 70E0      		ldi r23,0
 3002 10d6 8CE0      		ldi r24,lo8(12)
 3003 10d8 0E94 0000 		call writeAddr
 3004               	.LVL189:
 3005               	.L211:
1750:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R3, RADIO_ADDR_R3_BYTES) == 1) {
 3006               		.loc 1 1750 0
 3007 10dc 43E0      		ldi r20,lo8(3)
 3008 10de 50E0      		ldi r21,0
 3009 10e0 66E2      		ldi r22,lo8(38)
 3010 10e2 70E0      		ldi r23,0
 3011 10e4 CE01      		movw r24,r28
 3012 10e6 0196      		adiw r24,1
 3013 10e8 0E94 0000 		call readEEPROM
 3014               	.LVL190:
 3015 10ec 0197      		sbiw r24,1
 3016 10ee 01F4      		brne .L212
1751:switcherator.c ****         rx_addr_p3 = tempStuff[0];
 3017               		.loc 1 1751 0
 3018 10f0 0981      		ldd r16,Y+1
 3019 10f2 0093 0000 		sts rx_addr_p3,r16
 3020 10f6 1092 0000 		sts rx_addr_p3+1,__zero_reg__
 3021 10fa 1092 0000 		sts rx_addr_p3+2,__zero_reg__
 3022 10fe 1092 0000 		sts rx_addr_p3+3,__zero_reg__
 3023 1102 1092 0000 		sts rx_addr_p3+4,__zero_reg__
 3024 1106 1092 0000 		sts rx_addr_p3+5,__zero_reg__
 3025 110a 1092 0000 		sts rx_addr_p3+6,__zero_reg__
 3026 110e 1092 0000 		sts rx_addr_p3+7,__zero_reg__
1752:switcherator.c ****         writeAddr(RX_ADDR_P3, rx_addr_p3);
 3027               		.loc 1 1752 0
 3028 1112 10E0      		ldi r17,0
 3029 1114 20E0      		ldi r18,0
 3030 1116 30E0      		ldi r19,0
 3031 1118 40E0      		ldi r20,0
 3032 111a 50E0      		ldi r21,0
 3033 111c 60E0      		ldi r22,0
 3034 111e 70E0      		ldi r23,0
 3035 1120 8DE0      		ldi r24,lo8(13)
 3036 1122 0E94 0000 		call writeAddr
 3037               	.LVL191:
 3038               	.L212:
1754:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R4, RADIO_ADDR_R4_BYTES) == 1) {
 3039               		.loc 1 1754 0
 3040 1126 43E0      		ldi r20,lo8(3)
 3041 1128 50E0      		ldi r21,0
 3042 112a 69E2      		ldi r22,lo8(41)
 3043 112c 70E0      		ldi r23,0
 3044 112e CE01      		movw r24,r28
 3045 1130 0196      		adiw r24,1
 3046 1132 0E94 0000 		call readEEPROM
 3047               	.LVL192:
 3048 1136 0197      		sbiw r24,1
 3049 1138 01F4      		brne .L213
1755:switcherator.c ****         rx_addr_p4 = tempStuff[0];
 3050               		.loc 1 1755 0
 3051 113a 0981      		ldd r16,Y+1
 3052 113c 0093 0000 		sts rx_addr_p4,r16
 3053 1140 1092 0000 		sts rx_addr_p4+1,__zero_reg__
 3054 1144 1092 0000 		sts rx_addr_p4+2,__zero_reg__
 3055 1148 1092 0000 		sts rx_addr_p4+3,__zero_reg__
 3056 114c 1092 0000 		sts rx_addr_p4+4,__zero_reg__
 3057 1150 1092 0000 		sts rx_addr_p4+5,__zero_reg__
 3058 1154 1092 0000 		sts rx_addr_p4+6,__zero_reg__
 3059 1158 1092 0000 		sts rx_addr_p4+7,__zero_reg__
1756:switcherator.c ****         writeAddr(RX_ADDR_P4, rx_addr_p4);
 3060               		.loc 1 1756 0
 3061 115c 10E0      		ldi r17,0
 3062 115e 20E0      		ldi r18,0
 3063 1160 30E0      		ldi r19,0
 3064 1162 40E0      		ldi r20,0
 3065 1164 50E0      		ldi r21,0
 3066 1166 60E0      		ldi r22,0
 3067 1168 70E0      		ldi r23,0
 3068 116a 8EE0      		ldi r24,lo8(14)
 3069 116c 0E94 0000 		call writeAddr
 3070               	.LVL193:
 3071               	.L213:
1758:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R5, RADIO_ADDR_R5_BYTES) == 1) {
 3072               		.loc 1 1758 0
 3073 1170 43E0      		ldi r20,lo8(3)
 3074 1172 50E0      		ldi r21,0
 3075 1174 6CE2      		ldi r22,lo8(44)
 3076 1176 70E0      		ldi r23,0
 3077 1178 CE01      		movw r24,r28
 3078 117a 0196      		adiw r24,1
 3079 117c 0E94 0000 		call readEEPROM
 3080               	.LVL194:
 3081 1180 0197      		sbiw r24,1
 3082 1182 01F4      		brne .L214
1759:switcherator.c ****         rx_addr_p5 = tempStuff[0];
 3083               		.loc 1 1759 0
 3084 1184 0981      		ldd r16,Y+1
 3085 1186 0093 0000 		sts rx_addr_p5,r16
 3086 118a 1092 0000 		sts rx_addr_p5+1,__zero_reg__
 3087 118e 1092 0000 		sts rx_addr_p5+2,__zero_reg__
 3088 1192 1092 0000 		sts rx_addr_p5+3,__zero_reg__
 3089 1196 1092 0000 		sts rx_addr_p5+4,__zero_reg__
 3090 119a 1092 0000 		sts rx_addr_p5+5,__zero_reg__
 3091 119e 1092 0000 		sts rx_addr_p5+6,__zero_reg__
 3092 11a2 1092 0000 		sts rx_addr_p5+7,__zero_reg__
1760:switcherator.c ****         writeAddr(RX_ADDR_P5, rx_addr_p5);
 3093               		.loc 1 1760 0
 3094 11a6 10E0      		ldi r17,0
 3095 11a8 20E0      		ldi r18,0
 3096 11aa 30E0      		ldi r19,0
 3097 11ac 40E0      		ldi r20,0
 3098 11ae 50E0      		ldi r21,0
 3099 11b0 60E0      		ldi r22,0
 3100 11b2 70E0      		ldi r23,0
 3101 11b4 8FE0      		ldi r24,lo8(15)
 3102 11b6 0E94 0000 		call writeAddr
 3103               	.LVL195:
 3104               	.L214:
1762:switcherator.c ****     if (readEEPROM(tempStuff, TWEAK_TIMER, TWEAK_TIMER_BYTES) == 1) {
 3105               		.loc 1 1762 0
 3106 11ba 44E0      		ldi r20,lo8(4)
 3107 11bc 50E0      		ldi r21,0
 3108 11be 61E9      		ldi r22,lo8(-111)
 3109 11c0 71E0      		ldi r23,lo8(1)
 3110 11c2 CE01      		movw r24,r28
 3111 11c4 0196      		adiw r24,1
 3112 11c6 0E94 0000 		call readEEPROM
 3113               	.LVL196:
 3114 11ca 0197      		sbiw r24,1
 3115 11cc 01F4      		brne .L215
1763:switcherator.c ****         tweakTimer = tempStuff[0];
 3116               		.loc 1 1763 0
 3117 11ce 8981      		ldd r24,Y+1
 3118 11d0 90E0      		ldi r25,0
 3119 11d2 A0E0      		ldi r26,0
 3120 11d4 B0E0      		ldi r27,0
1764:switcherator.c ****         tweakTimer <<= 8;
 3121               		.loc 1 1764 0
 3122 11d6 BA2F      		mov r27,r26
 3123 11d8 A92F      		mov r26,r25
 3124 11da 982F      		mov r25,r24
 3125 11dc 8827      		clr r24
1765:switcherator.c ****         tweakTimer |= tempStuff[1];
 3126               		.loc 1 1765 0
 3127 11de 2A81      		ldd r18,Y+2
 3128 11e0 822B      		or r24,r18
 3129 11e2 8093 0000 		sts tweakTimer,r24
 3130 11e6 9093 0000 		sts tweakTimer+1,r25
 3131 11ea A093 0000 		sts tweakTimer+2,r26
 3132 11ee B093 0000 		sts tweakTimer+3,r27
 3133               	.L215:
1770:switcherator.c ****     if (readEEPROM(tempStuff, DAYLIGHT_SAVE, DAYLIGHT_SAVE_BYTES) == 1) {
 3134               		.loc 1 1770 0
 3135 11f2 4AE0      		ldi r20,lo8(10)
 3136 11f4 50E0      		ldi r21,0
 3137 11f6 66E0      		ldi r22,lo8(6)
 3138 11f8 70E0      		ldi r23,0
 3139 11fa CE01      		movw r24,r28
 3140 11fc 0196      		adiw r24,1
 3141 11fe 0E94 0000 		call readEEPROM
 3142               	.LVL197:
 3143 1202 0197      		sbiw r24,1
 3144 1204 01F4      		brne .L216
1772:switcherator.c ****         daylightSavings[0][0] = ((tempStuff[0] << 8) | (tempStuff[1]));
 3145               		.loc 1 1772 0
 3146 1206 9981      		ldd r25,Y+1
 3147 1208 80E0      		ldi r24,0
 3148 120a 2A81      		ldd r18,Y+2
 3149 120c 822B      		or r24,r18
 3150 120e 9093 0000 		sts daylightSavings+1,r25
 3151 1212 8093 0000 		sts daylightSavings,r24
1774:switcherator.c ****         daylightSavings[0][1] = ((tempStuff[2] << 8) | (tempStuff[3]));
 3152               		.loc 1 1774 0
 3153 1216 9B81      		ldd r25,Y+3
 3154 1218 80E0      		ldi r24,0
 3155 121a 2C81      		ldd r18,Y+4
 3156 121c 822B      		or r24,r18
 3157 121e 9093 0000 		sts daylightSavings+2+1,r25
 3158 1222 8093 0000 		sts daylightSavings+2,r24
1776:switcherator.c ****         daylightSavings[1][0] = ((tempStuff[4] << 8) | (tempStuff[5]));
 3159               		.loc 1 1776 0
 3160 1226 9D81      		ldd r25,Y+5
 3161 1228 80E0      		ldi r24,0
 3162 122a 2E81      		ldd r18,Y+6
 3163 122c 822B      		or r24,r18
 3164 122e 9093 0000 		sts daylightSavings+4+1,r25
 3165 1232 8093 0000 		sts daylightSavings+4,r24
1778:switcherator.c ****         daylightSavings[1][1] = ((tempStuff[6] << 8) | (tempStuff[7]));
 3166               		.loc 1 1778 0
 3167 1236 9F81      		ldd r25,Y+7
 3168 1238 80E0      		ldi r24,0
 3169 123a 2885      		ldd r18,Y+8
 3170 123c 822B      		or r24,r18
 3171 123e 9093 0000 		sts daylightSavings+6+1,r25
 3172 1242 8093 0000 		sts daylightSavings+6,r24
 3173               	.L216:
1783:switcherator.c ****     if (readEEPROM(switchStuff, SWITCH_STUFF, SWITCH_STUFF_BYTES) == 1) {
 3174               		.loc 1 1783 0
 3175 1246 42E1      		ldi r20,lo8(18)
 3176 1248 50E0      		ldi r21,0
 3177 124a 60E3      		ldi r22,lo8(48)
 3178 124c 70E0      		ldi r23,0
 3179 124e 80E0      		ldi r24,lo8(switchStuff)
 3180 1250 90E0      		ldi r25,hi8(switchStuff)
 3181 1252 0E94 0000 		call readEEPROM
 3182               	.LVL198:
 3183 1256 0197      		sbiw r24,1
 3184 1258 01F0      		breq .+2
 3185 125a 00C0      		rjmp .L217
 3186               	.LBB18:
1784:switcherator.c ****         readEEPROM(switchBright, BRIGHTNESS, BRIGHTNESS_BYTES);
 3187               		.loc 1 1784 0
 3188 125c 42E1      		ldi r20,lo8(18)
 3189 125e 50E0      		ldi r21,0
 3190 1260 68E9      		ldi r22,lo8(-104)
 3191 1262 71E0      		ldi r23,lo8(1)
 3192 1264 80E0      		ldi r24,lo8(switchBright)
 3193 1266 90E0      		ldi r25,hi8(switchBright)
 3194 1268 0E94 0000 		call readEEPROM
 3195               	.LVL199:
 3196 126c 80E0      		ldi r24,lo8(switchStuff)
 3197 126e 90E0      		ldi r25,hi8(switchStuff)
1851:switcherator.c ****             *realDDR |= (1 << realPin);
 3198               		.loc 1 1851 0
 3199 1270 41E0      		ldi r20,lo8(1)
 3200 1272 50E0      		ldi r21,0
 3201               	.LVL200:
 3202               	.L222:
1793:switcherator.c ****             temp = switchStuff[x];
 3203               		.loc 1 1793 0
 3204 1274 FC01      		movw r30,r24
 3205 1276 2191      		ld r18,Z+
 3206 1278 CF01      		movw r24,r30
 3207               	.LVL201:
1794:switcherator.c ****             if (temp > 15 && temp < 32) {
 3208               		.loc 1 1794 0
 3209 127a 622F      		mov r22,r18
 3210 127c 6051      		subi r22,lo8(-(-16))
 3211 127e 6031      		cpi r22,lo8(16)
 3212 1280 00F0      		brlo .L243
1805:switcherator.c ****             } else if (temp < 48) {
 3213               		.loc 1 1805 0
 3214 1282 2033      		cpi r18,lo8(48)
 3215 1284 00F4      		brsh .L219
 3216               	.LVL202:
1808:switcherator.c ****                 temp -= 32;
 3217               		.loc 1 1808 0
 3218 1286 6051      		subi r22,lo8(-(-16))
 3219               	.LVL203:
1807:switcherator.c ****                 realDDR = &DDRC;
 3220               		.loc 1 1807 0
 3221 1288 A7E2      		ldi r26,lo8(39)
 3222 128a B0E0      		ldi r27,0
1806:switcherator.c ****                 realPort = &PORTC;
 3223               		.loc 1 1806 0
 3224 128c E8E2      		ldi r30,lo8(40)
 3225 128e F0E0      		ldi r31,0
 3226 1290 00C0      		rjmp .L218
 3227               	.LVL204:
 3228               	.L219:
1811:switcherator.c ****             } else if (temp < 64) {
 3229               		.loc 1 1811 0
 3230 1292 2034      		cpi r18,lo8(64)
 3231 1294 00F4      		brsh .L220
 3232               	.LVL205:
1814:switcherator.c ****                 temp -= 48;
 3233               		.loc 1 1814 0
 3234 1296 622F      		mov r22,r18
 3235 1298 6053      		subi r22,lo8(-(-48))
 3236               	.LVL206:
1813:switcherator.c ****                 realDDR = &DDRD;
 3237               		.loc 1 1813 0
 3238 129a AAE2      		ldi r26,lo8(42)
 3239 129c B0E0      		ldi r27,0
1812:switcherator.c ****                 realPort = &PORTD;
 3240               		.loc 1 1812 0
 3241 129e EBE2      		ldi r30,lo8(43)
 3242 12a0 F0E0      		ldi r31,0
 3243 12a2 00C0      		rjmp .L218
 3244               	.LVL207:
 3245               	.L243:
1796:switcherator.c ****                 realDDR = &DDRB;
 3246               		.loc 1 1796 0
 3247 12a4 A4E2      		ldi r26,lo8(36)
 3248 12a6 B0E0      		ldi r27,0
1795:switcherator.c ****                 realPort = &PORTB;
 3249               		.loc 1 1795 0
 3250 12a8 E5E2      		ldi r30,lo8(37)
 3251 12aa F0E0      		ldi r31,0
 3252               	.LVL208:
 3253               	.L218:
1851:switcherator.c ****             *realDDR |= (1 << realPin);
 3254               		.loc 1 1851 0
 3255 12ac 7C91      		ld r23,X
1850:switcherator.c ****             realPin = (temp / 2);
 3256               		.loc 1 1850 0
 3257 12ae 262F      		mov r18,r22
 3258 12b0 2695      		lsr r18
 3259               	.LVL209:
1851:switcherator.c ****             *realDDR |= (1 << realPin);
 3260               		.loc 1 1851 0
 3261 12b2 8A01      		movw r16,r20
 3262 12b4 00C0      		rjmp 2f
 3263               		1:
 3264 12b6 000F      		lsl r16
 3265 12b8 111F      		rol r17
 3266               		2:
 3267 12ba 2A95      		dec r18
 3268 12bc 02F4      		brpl 1b
 3269 12be 9801      		movw r18,r16
 3270               	.LVL210:
 3271 12c0 702B      		or r23,r16
 3272 12c2 7C93      		st X,r23
1853:switcherator.c ****             if (temp % 2 == 0) {
 3273               		.loc 1 1853 0
 3274 12c4 60FD      		sbrc r22,0
 3275 12c6 00C0      		rjmp .L221
1855:switcherator.c ****                 *realPort |= (1 << realPin);
 3276               		.loc 1 1855 0
 3277 12c8 2081      		ld r18,Z
 3278 12ca 202B      		or r18,r16
 3279 12cc 00C0      		rjmp .L254
 3280               	.L221:
1857:switcherator.c ****                 *realPort &= ~(1 << realPin);
 3281               		.loc 1 1857 0
 3282 12ce 3081      		ld r19,Z
 3283 12d0 2095      		com r18
 3284 12d2 2323      		and r18,r19
 3285               	.L254:
 3286 12d4 2083      		st Z,r18
 3287               	.LVL211:
 3288               	.L220:
1792:switcherator.c ****         for (x = 0; x < NUM_SWITCHES; x++) {
 3289               		.loc 1 1792 0
 3290 12d6 10E0      		ldi r17,hi8(switchStuff+16)
 3291 12d8 8030      		cpi r24,lo8(switchStuff+16)
 3292 12da 9107      		cpc r25,r17
 3293 12dc 01F4      		brne .L222
 3294               	.L225:
 3295               	.LVL212:
 3296 12de 40E0      		ldi r20,lo8(weeklyProgram)
 3297 12e0 E42E      		mov r14,r20
 3298 12e2 40E0      		ldi r20,hi8(weeklyProgram)
 3299 12e4 F42E      		mov r15,r20
1812:switcherator.c ****                 realPort = &PORTD;
 3300               		.loc 1 1812 0
 3301 12e6 01EA      		ldi r16,lo8(-95)
 3302 12e8 10E0      		ldi r17,0
 3303 12ea 00C0      		rjmp .L223
 3304               	.L217:
 3305 12ec E0E0      		ldi r30,lo8(switchStuff)
 3306 12ee F0E0      		ldi r31,hi8(switchStuff)
 3307               	.LBE18:
1862:switcherator.c ****             switchStuff[x] = 255;
 3308               		.loc 1 1862 0
 3309 12f0 8FEF      		ldi r24,lo8(-1)
 3310               	.LVL213:
 3311               	.L224:
1862:switcherator.c ****             switchStuff[x] = 255;
 3312               		.loc 1 1862 0 is_stmt 0 discriminator 2
 3313 12f2 8193      		st Z+,r24
1861:switcherator.c ****         for (x = 0; x < NUM_SWITCHES; x++)
 3314               		.loc 1 1861 0 is_stmt 1 discriminator 2
 3315 12f4 20E0      		ldi r18,hi8(switchStuff+16)
 3316 12f6 E030      		cpi r30,lo8(switchStuff+16)
 3317 12f8 F207      		cpc r31,r18
 3318 12fa 01F4      		brne .L224
 3319 12fc 00C0      		rjmp .L225
 3320               	.L223:
 3321               	.LVL214:
1870:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, WEEKLY_PROGRAM_BYTES) == 1) {
 3322               		.loc 1 1870 0
 3323 12fe 4CE0      		ldi r20,lo8(12)
 3324 1300 50E0      		ldi r21,0
 3325 1302 B801      		movw r22,r16
 3326 1304 CE01      		movw r24,r28
 3327 1306 0196      		adiw r24,1
 3328 1308 0E94 0000 		call readEEPROM
 3329               	.LVL215:
 3330 130c 0197      		sbiw r24,1
 3331 130e 01F0      		breq .L226
 3332               	.L229:
 3333 1310 045F      		subi r16,-12
 3334 1312 1F4F      		sbci r17,-1
 3335               	.LVL216:
 3336 1314 8AE0      		ldi r24,10
 3337 1316 E80E      		add r14,r24
 3338 1318 F11C      		adc r15,__zero_reg__
1868:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 3339               		.loc 1 1868 0
 3340 131a 0139      		cpi r16,-111
 3341 131c 91E0      		ldi r25,1
 3342 131e 1907      		cpc r17,r25
 3343 1320 01F4      		brne .L223
 3344 1322 00C0      		rjmp .L252
 3345               	.LVL217:
 3346               	.L226:
 3347 1324 FE01      		movw r30,r28
 3348 1326 3196      		adiw r30,1
1870:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, WEEKLY_PROGRAM_BYTES) == 1) {
 3349               		.loc 1 1870 0
 3350 1328 80E0      		ldi r24,0
 3351 132a 90E0      		ldi r25,0
 3352               	.L228:
1872:switcherator.c ****                 weeklyProgram[x][y] = tempStuff[y];
 3353               		.loc 1 1872 0 discriminator 2
 3354 132c 2191      		ld r18,Z+
1727:switcherator.c **** void generalInit(void) {
 3355               		.loc 1 1727 0 discriminator 2
 3356 132e D701      		movw r26,r14
 3357 1330 A80F      		add r26,r24
 3358 1332 B91F      		adc r27,r25
1872:switcherator.c ****                 weeklyProgram[x][y] = tempStuff[y];
 3359               		.loc 1 1872 0 discriminator 2
 3360 1334 2C93      		st X,r18
1871:switcherator.c ****             for (y = 0; y < 10; y++) {
 3361               		.loc 1 1871 0 discriminator 2
 3362 1336 0196      		adiw r24,1
 3363               	.LVL218:
 3364 1338 8A30      		cpi r24,10
 3365 133a 9105      		cpc r25,__zero_reg__
 3366 133c 01F4      		brne .L228
 3367 133e 00C0      		rjmp .L229
 3368               	.LVL219:
 3369               	.L252:
 3370 1340 30E0      		ldi r19,lo8(inputs)
 3371 1342 E32E      		mov r14,r19
 3372 1344 30E0      		ldi r19,hi8(inputs)
 3373 1346 F32E      		mov r15,r19
1868:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 3374               		.loc 1 1868 0
 3375 1348 02E4      		ldi r16,lo8(66)
 3376 134a 10E0      		ldi r17,0
 3377               	.LVL220:
 3378               	.L231:
1879:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, INPUT_BYTES) == 1) {
 3379               		.loc 1 1879 0
 3380 134c 4AE0      		ldi r20,lo8(10)
 3381 134e 50E0      		ldi r21,0
 3382 1350 B801      		movw r22,r16
 3383 1352 CE01      		movw r24,r28
 3384 1354 0196      		adiw r24,1
 3385 1356 0E94 0000 		call readEEPROM
 3386               	.LVL221:
 3387 135a 0197      		sbiw r24,1
 3388 135c 01F0      		breq .L230
 3389               	.L234:
 3390 135e 065F      		subi r16,-10
 3391 1360 1F4F      		sbci r17,-1
 3392               	.LVL222:
 3393 1362 E8E0      		ldi r30,8
 3394 1364 EE0E      		add r14,r30
 3395 1366 F11C      		adc r15,__zero_reg__
1877:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 3396               		.loc 1 1877 0
 3397 1368 0A36      		cpi r16,106
 3398 136a 1105      		cpc r17,__zero_reg__
 3399 136c 01F4      		brne .L231
 3400 136e 00C0      		rjmp .L253
 3401               	.LVL223:
 3402               	.L230:
 3403 1370 FE01      		movw r30,r28
 3404 1372 3196      		adiw r30,1
1879:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, INPUT_BYTES) == 1) {
 3405               		.loc 1 1879 0
 3406 1374 80E0      		ldi r24,0
 3407 1376 90E0      		ldi r25,0
 3408               	.L233:
1881:switcherator.c ****                 inputs[x][y] = tempStuff[y];
 3409               		.loc 1 1881 0 discriminator 2
 3410 1378 2191      		ld r18,Z+
1727:switcherator.c **** void generalInit(void) {
 3411               		.loc 1 1727 0 discriminator 2
 3412 137a D701      		movw r26,r14
 3413 137c A80F      		add r26,r24
 3414 137e B91F      		adc r27,r25
1881:switcherator.c ****                 inputs[x][y] = tempStuff[y];
 3415               		.loc 1 1881 0 discriminator 2
 3416 1380 2C93      		st X,r18
1880:switcherator.c ****             for (y = 0; y < 8; y++) {
 3417               		.loc 1 1880 0 discriminator 2
 3418 1382 0196      		adiw r24,1
 3419               	.LVL224:
 3420 1384 8830      		cpi r24,8
 3421 1386 9105      		cpc r25,__zero_reg__
 3422 1388 01F4      		brne .L233
 3423 138a 00C0      		rjmp .L234
 3424               	.LVL225:
 3425               	.L253:
 3426 138c 00E0      		ldi r16,lo8(timeLimits)
 3427 138e 10E0      		ldi r17,hi8(timeLimits)
 3428               	.LVL226:
1877:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 3429               		.loc 1 1877 0
 3430 1390 2AE6      		ldi r18,lo8(106)
 3431 1392 E22E      		mov r14,r18
 3432 1394 F12C      		mov r15,__zero_reg__
 3433               	.L236:
 3434               	.LVL227:
1888:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, LIMIT_BYTES) == 1) {
 3435               		.loc 1 1888 0
 3436 1396 45E0      		ldi r20,lo8(5)
 3437 1398 50E0      		ldi r21,0
 3438 139a B701      		movw r22,r14
 3439 139c CE01      		movw r24,r28
 3440 139e 0196      		adiw r24,1
 3441 13a0 0E94 0000 		call readEEPROM
 3442               	.LVL228:
 3443 13a4 0197      		sbiw r24,1
 3444 13a6 01F4      		brne .L235
 3445               	.LVL229:
1890:switcherator.c ****                 timeLimits[x][y] = tempStuff[y];
 3446               		.loc 1 1890 0 discriminator 1
 3447 13a8 8981      		ldd r24,Y+1
 3448 13aa 90E0      		ldi r25,0
 3449 13ac A0E0      		ldi r26,0
 3450 13ae B0E0      		ldi r27,0
 3451 13b0 F801      		movw r30,r16
 3452 13b2 8083      		st Z,r24
 3453 13b4 9183      		std Z+1,r25
 3454 13b6 A283      		std Z+2,r26
 3455 13b8 B383      		std Z+3,r27
 3456               	.LVL230:
 3457 13ba 8A81      		ldd r24,Y+2
 3458 13bc 90E0      		ldi r25,0
 3459 13be A0E0      		ldi r26,0
 3460 13c0 B0E0      		ldi r27,0
 3461 13c2 8483      		std Z+4,r24
 3462 13c4 9583      		std Z+5,r25
 3463 13c6 A683      		std Z+6,r26
 3464 13c8 B783      		std Z+7,r27
 3465               	.LVL231:
 3466 13ca 8B81      		ldd r24,Y+3
 3467 13cc 90E0      		ldi r25,0
 3468 13ce A0E0      		ldi r26,0
 3469 13d0 B0E0      		ldi r27,0
 3470 13d2 8087      		std Z+8,r24
 3471 13d4 9187      		std Z+9,r25
 3472 13d6 A287      		std Z+10,r26
 3473 13d8 B387      		std Z+11,r27
 3474               	.LVL232:
 3475               	.L235:
 3476 13da F5E0      		ldi r31,5
 3477 13dc EF0E      		add r14,r31
 3478 13de F11C      		adc r15,__zero_reg__
 3479               	.LVL233:
 3480 13e0 045F      		subi r16,-12
 3481 13e2 1F4F      		sbci r17,-1
1886:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++) {
 3482               		.loc 1 1886 0
 3483 13e4 2EE7      		ldi r18,126
 3484 13e6 E216      		cp r14,r18
 3485 13e8 F104      		cpc r15,__zero_reg__
 3486 13ea 01F4      		brne .L236
1895:switcherator.c ****     if (readEEPROM(tempStuff, PWM_DIR, PWM_DIR_BYTES) == 1) {
 3487               		.loc 1 1895 0
 3488 13ec 43E0      		ldi r20,lo8(3)
 3489 13ee 50E0      		ldi r21,0
 3490 13f0 65E9      		ldi r22,lo8(-107)
 3491 13f2 71E0      		ldi r23,lo8(1)
 3492 13f4 CE01      		movw r24,r28
 3493 13f6 0196      		adiw r24,1
 3494 13f8 0E94 0000 		call readEEPROM
 3495               	.LVL234:
 3496 13fc 0197      		sbiw r24,1
 3497 13fe 01F4      		brne .L237
1896:switcherator.c ****         DDRD |= (1 << PIND3) | (1 << PIND5) | (1 << PIND6);
 3498               		.loc 1 1896 0
 3499 1400 8AB1      		in r24,0xa
 3500 1402 8866      		ori r24,lo8(104)
 3501 1404 8AB9      		out 0xa,r24
1898:switcherator.c ****         Red = 0;
 3502               		.loc 1 1898 0
 3503 1406 1092 B400 		sts 180,__zero_reg__
1899:switcherator.c ****         Green = 0;
 3504               		.loc 1 1899 0
 3505 140a 18BC      		out 0x28,__zero_reg__
1900:switcherator.c ****         Blue = 0;
 3506               		.loc 1 1900 0
 3507 140c 17BC      		out 0x27,__zero_reg__
1903:switcherator.c ****         if (tempStuff[0] == 0) {
 3508               		.loc 1 1903 0
 3509 140e 8981      		ldd r24,Y+1
 3510 1410 8111      		cpse r24,__zero_reg__
 3511 1412 00C0      		rjmp .L238
1904:switcherator.c ****             TCCR0A = (1 << COM0A0) | (1 << COM0A1) | (1 << COM0B0) | (1 << COM0B1) | (1 << WGM00);
 3512               		.loc 1 1904 0
 3513 1414 81EF      		ldi r24,lo8(-15)
 3514 1416 84BD      		out 0x24,r24
1905:switcherator.c ****             TCCR2A = (1 << COM2B0) | (1 << COM2B1) | (1 << WGM20);
 3515               		.loc 1 1905 0
 3516 1418 81E3      		ldi r24,lo8(49)
 3517 141a 8093 B000 		sts 176,r24
1906:switcherator.c ****             pwmdir = 0;
 3518               		.loc 1 1906 0
 3519 141e 1092 0000 		sts pwmdir,__zero_reg__
 3520 1422 00C0      		rjmp .L239
 3521               	.L238:
1908:switcherator.c ****             TCCR0A = (1 << COM0A1) | (1 << COM0B1) | (1 << WGM00);
 3522               		.loc 1 1908 0
 3523 1424 81EA      		ldi r24,lo8(-95)
 3524 1426 84BD      		out 0x24,r24
1909:switcherator.c ****             TCCR2A = (1 << COM2B1) | (1 << WGM20);
 3525               		.loc 1 1909 0
 3526 1428 81E2      		ldi r24,lo8(33)
 3527 142a 8093 B000 		sts 176,r24
1910:switcherator.c ****             pwmdir = 1;
 3528               		.loc 1 1910 0
 3529 142e 81E0      		ldi r24,lo8(1)
 3530 1430 8093 0000 		sts pwmdir,r24
 3531               	.L239:
1913:switcherator.c ****         TCCR0B = (1 << CS01) | (1 << CS00);
 3532               		.loc 1 1913 0
 3533 1434 83E0      		ldi r24,lo8(3)
 3534 1436 85BD      		out 0x25,r24
1915:switcherator.c ****         TCCR2B = (1 << CS22); // F_CPU/64
 3535               		.loc 1 1915 0
 3536 1438 84E0      		ldi r24,lo8(4)
 3537 143a 8093 B100 		sts 177,r24
 3538               	.L237:
 3539               	.LVL235:
1920:switcherator.c ****     if (readEEPROM(tempStuff, memoryMarker, PWM_VALUE_BYTES) == 1) {
 3540               		.loc 1 1920 0
 3541 143e 45E0      		ldi r20,lo8(5)
 3542 1440 50E0      		ldi r21,0
 3543 1442 6EE7      		ldi r22,lo8(126)
 3544 1444 70E0      		ldi r23,0
 3545 1446 CE01      		movw r24,r28
 3546 1448 0196      		adiw r24,1
 3547 144a 0E94 0000 		call readEEPROM
 3548               	.LVL236:
 3549 144e 0197      		sbiw r24,1
 3550 1450 01F4      		brne .L240
1921:switcherator.c ****         pwmValues[0] = tempStuff[0];
 3551               		.loc 1 1921 0
 3552 1452 8981      		ldd r24,Y+1
 3553 1454 8093 0000 		sts pwmValues,r24
1922:switcherator.c ****         pwmValues[1] = tempStuff[1];
 3554               		.loc 1 1922 0
 3555 1458 8A81      		ldd r24,Y+2
 3556 145a 8093 0000 		sts pwmValues+1,r24
1923:switcherator.c ****         pwmValues[2] = tempStuff[2];
 3557               		.loc 1 1923 0
 3558 145e 8B81      		ldd r24,Y+3
 3559 1460 8093 0000 		sts pwmValues+2,r24
 3560               	.L240:
 3561               	.LVL237:
 3562 1464 00E0      		ldi r16,lo8(colorChanges+2)
 3563 1466 10E0      		ldi r17,hi8(colorChanges+2)
1877:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 3564               		.loc 1 1877 0 discriminator 1
 3565 1468 93E8      		ldi r25,lo8(-125)
 3566 146a E92E      		mov r14,r25
 3567 146c F12C      		mov r15,__zero_reg__
 3568               	.LVL238:
 3569               	.L242:
1928:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, PWM_VALUE_BYTES) == 1) {
 3570               		.loc 1 1928 0
 3571 146e 45E0      		ldi r20,lo8(5)
 3572 1470 50E0      		ldi r21,0
 3573 1472 B701      		movw r22,r14
 3574 1474 CE01      		movw r24,r28
 3575 1476 0196      		adiw r24,1
 3576 1478 0E94 0000 		call readEEPROM
 3577               	.LVL239:
 3578 147c 0197      		sbiw r24,1
 3579 147e 01F4      		brne .L241
 3580               	.LVL240:
1727:switcherator.c **** void generalInit(void) {
 3581               		.loc 1 1727 0 discriminator 1
 3582 1480 F801      		movw r30,r16
 3583 1482 3297      		sbiw r30,2
1930:switcherator.c ****                 colorChanges[x][y] = tempStuff[y];
 3584               		.loc 1 1930 0 discriminator 1
 3585 1484 8981      		ldd r24,Y+1
 3586 1486 8083      		st Z,r24
 3587               	.LVL241:
1727:switcherator.c **** void generalInit(void) {
 3588               		.loc 1 1727 0 discriminator 1
 3589 1488 F801      		movw r30,r16
 3590 148a 3197      		sbiw r30,1
1930:switcherator.c ****                 colorChanges[x][y] = tempStuff[y];
 3591               		.loc 1 1930 0 discriminator 1
 3592 148c 8A81      		ldd r24,Y+2
 3593 148e 8083      		st Z,r24
 3594               	.LVL242:
 3595 1490 8B81      		ldd r24,Y+3
 3596 1492 F801      		movw r30,r16
 3597 1494 8083      		st Z,r24
 3598               	.LVL243:
 3599               	.L241:
 3600 1496 F5E0      		ldi r31,5
 3601 1498 EF0E      		add r14,r31
 3602 149a F11C      		adc r15,__zero_reg__
 3603               	.LVL244:
 3604 149c 0D5F      		subi r16,-3
 3605 149e 1F4F      		sbci r17,-1
1926:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 3606               		.loc 1 1926 0
 3607 14a0 21EA      		ldi r18,-95
 3608 14a2 E216      		cp r14,r18
 3609 14a4 F104      		cpc r15,__zero_reg__
 3610 14a6 01F4      		brne .L242
 3611               	/* epilogue start */
1934:switcherator.c **** }
 3612               		.loc 1 1934 0
 3613 14a8 2E96      		adiw r28,14
 3614 14aa 0FB6      		in __tmp_reg__,__SREG__
 3615 14ac F894      		cli
 3616 14ae DEBF      		out __SP_H__,r29
 3617 14b0 0FBE      		out __SREG__,__tmp_reg__
 3618 14b2 CDBF      		out __SP_L__,r28
 3619 14b4 DF91      		pop r29
 3620 14b6 CF91      		pop r28
 3621 14b8 1F91      		pop r17
 3622 14ba 0F91      		pop r16
 3623 14bc FF90      		pop r15
 3624 14be EF90      		pop r14
 3625               	.LVL245:
 3626 14c0 0895      		ret
 3627               	.LFE42:
 3629               	.global	unformatAddress
 3631               	unformatAddress:
 3632               	.LFB76:
2948:switcherator.c **** 
2949:switcherator.c **** // send receive addresses
2950:switcherator.c **** //static uint64_t rx_addr_p0, rx_addr_p1, rx_addr_p2, rx_addr_p3, rx_addr_p4, rx_addr_p5, tx_addr;
2951:switcherator.c **** 
2952:switcherator.c **** // display's a given address
2953:switcherator.c **** //RD:N RC:N 0xnnnnnnnnnn
2954:switcherator.c **** //0123
2955:switcherator.c **** 
2956:switcherator.c **** void radioDisplayAddress(char * commandReceived) {
2957:switcherator.c ****     int x = 0;
2958:switcherator.c ****     char tempRadioString[6];
2959:switcherator.c ****     statusMsg[0] = 0;
2960:switcherator.c ****     if(commandReceived[3] == '1') {
2961:switcherator.c ****         unformatAddress(rx_addr_p1, tempRadioString);
2962:switcherator.c ****         strcat(statusMsg, "r1-0x");
2963:switcherator.c ****     } else if(commandReceived[3] == '2') {
2964:switcherator.c ****         unformatAddress(rx_addr_p2, tempRadioString);
2965:switcherator.c ****         strcat(statusMsg, "r2-0x");
2966:switcherator.c ****     } else if(commandReceived[3] == '3') {
2967:switcherator.c ****         unformatAddress(rx_addr_p3, tempRadioString);
2968:switcherator.c ****         strcat(statusMsg, "r3-0x");
2969:switcherator.c ****     } else if(commandReceived[3] == '4') {
2970:switcherator.c ****         unformatAddress(rx_addr_p4, tempRadioString);
2971:switcherator.c ****         strcat(statusMsg, "r4-0x");
2972:switcherator.c ****     } else if (commandReceived[3] == '5') {
2973:switcherator.c ****         unformatAddress(rx_addr_p5, tempRadioString);
2974:switcherator.c ****         strcat(statusMsg, "r5-0x");
2975:switcherator.c ****     } else if (commandReceived[3] == 'T') {
2976:switcherator.c ****         unformatAddress(tx_addr, tempRadioString);
2977:switcherator.c ****         strcat(statusMsg, "t-0x");
2978:switcherator.c ****     } else {
2979:switcherator.c ****         unformatAddress(rx_addr_p0, tempRadioString);
2980:switcherator.c ****         strcat(statusMsg, "r0-0x");
2981:switcherator.c ****     }
2982:switcherator.c ****     for (x = 0; x < 5; x++) {
2983:switcherator.c ****         returnHexWithout(tempRadioString[x], tempLongString);
2984:switcherator.c ****         strcat(statusMsg, tempLongString);
2985:switcherator.c ****     }
2986:switcherator.c ****     sendMessage(statusMsg);
2987:switcherator.c **** }
2988:switcherator.c **** 
2989:switcherator.c **** // change the radio address
2990:switcherator.c **** // send receive addresses
2991:switcherator.c **** //static uint64_t rx_addr_p0, rx_addr_p1, rx_addr_p2, rx_addr_p3, rx_addr_p4, rx_addr_p5, tx_addr;
2992:switcherator.c **** 
2993:switcherator.c **** //RD:N RC:N 0xnnnnnnnnnn
2994:switcherator.c **** //     01234567890123456
2995:switcherator.c **** 
2996:switcherator.c **** void radioChangeAddress(char * commandReceived) {
2997:switcherator.c ****     int x = 0;
2998:switcherator.c ****     statusMsg[0] = 0;
2999:switcherator.c ****     int tempInt = 0;
3000:switcherator.c ****     uint64_t newAddress = 0;
3001:switcherator.c ****     char tempString[] = "0x00";
3002:switcherator.c ****     char tempRadioString[] = "00000";
3003:switcherator.c ****     for (x = 0; x < 5; x++) {
3004:switcherator.c ****         tempString[2] = commandReceived[((x * 2) + 7)];
3005:switcherator.c ****         tempString[3] = commandReceived[((x * 2) + 8)];
3006:switcherator.c ****         tempInt = strtol(tempString, 0, 0);
3007:switcherator.c ****         newAddress |= tempInt;
3008:switcherator.c ****         if (x < 4)
3009:switcherator.c ****             newAddress <<= 8;
3010:switcherator.c ****     }
3011:switcherator.c ****     switch (commandReceived[3]) {
3012:switcherator.c ****         case '0':
3013:switcherator.c ****             rx_addr_p0 = newAddress;
3014:switcherator.c ****             strcat(statusMsg, "r0 0x");
3015:switcherator.c ****             writeAddr(RX_ADDR_P0, newAddress);
3016:switcherator.c ****             break;
3017:switcherator.c ****         case '1':
3018:switcherator.c ****             rx_addr_p1 = newAddress;
3019:switcherator.c ****             strcat(statusMsg, "r1 0x");
3020:switcherator.c ****             writeAddr(RX_ADDR_P1, newAddress);
3021:switcherator.c ****             break;
3022:switcherator.c ****         case '2':
3023:switcherator.c ****             rx_addr_p2 = newAddress;
3024:switcherator.c ****             strcat(statusMsg, "r2 0x");
3025:switcherator.c ****             writeAddr(RX_ADDR_P2, newAddress);
3026:switcherator.c ****             break;
3027:switcherator.c ****         case '3':
3028:switcherator.c ****             rx_addr_p3 = newAddress;
3029:switcherator.c ****             strcat(statusMsg, "r3 0x");
3030:switcherator.c ****             writeAddr(RX_ADDR_P3, newAddress);
3031:switcherator.c ****             break;
3032:switcherator.c ****         case '4':
3033:switcherator.c ****             rx_addr_p4 = newAddress;
3034:switcherator.c ****             strcat(statusMsg, "r4 0x");
3035:switcherator.c ****             writeAddr(RX_ADDR_P4, newAddress);
3036:switcherator.c ****             break;
3037:switcherator.c ****         case '5':
3038:switcherator.c ****             rx_addr_p5 = newAddress;
3039:switcherator.c ****             strcat(statusMsg, "r5 0x");
3040:switcherator.c ****             writeAddr(RX_ADDR_P5, newAddress);
3041:switcherator.c ****             break;
3042:switcherator.c ****         case 'T':
3043:switcherator.c ****             tx_addr = newAddress;
3044:switcherator.c ****             strcat(statusMsg, "t 0x");
3045:switcherator.c ****             writeAddr(TX_ADDR, newAddress);
3046:switcherator.c ****             break;
3047:switcherator.c ****     }
3048:switcherator.c ****     unformatAddress(newAddress, tempRadioString);
3049:switcherator.c ****     for (x = 0; x < 5; x++) {
3050:switcherator.c ****         returnHexWithout(tempRadioString[x], tempLongString);
3051:switcherator.c ****         strcat(statusMsg, tempLongString);
3052:switcherator.c ****     }
3053:switcherator.c ****     sendMessage(statusMsg);
3054:switcherator.c **** }
3055:switcherator.c **** 
3056:switcherator.c **** 
3057:switcherator.c **** // take the int and return the array
3058:switcherator.c **** 
3059:switcherator.c **** void unformatAddress(uint64_t oldAddress, char * formattedAddress) {
 3633               		.loc 1 3059 0
 3634               	.LVL246:
 3635 14c2 0F93      		push r16
 3636               	.LCFI84:
 3637 14c4 1F93      		push r17
 3638               	.LCFI85:
 3639               	/* prologue: function */
 3640               	/* frame size = 0 */
 3641               	/* stack size = 2 */
 3642               	.L__stack_usage = 2
 3643 14c6 F801      		movw r30,r16
 3644               	.LVL247:
3060:switcherator.c ****     uint64_t tempInt = oldAddress;
3061:switcherator.c ****     formattedAddress[4] = (tempInt & 0xff);
 3645               		.loc 1 3061 0
 3646 14c8 2483      		std Z+4,r18
3062:switcherator.c ****     tempInt >>= 8;
 3647               		.loc 1 3062 0
 3648 14ca 08E0      		ldi r16,lo8(8)
 3649               	.LVL248:
 3650 14cc 0E94 0000 		call __lshrdi3
 3651               	.LVL249:
3063:switcherator.c ****     formattedAddress[3] = (tempInt & 0xff);
 3652               		.loc 1 3063 0
 3653 14d0 2383      		std Z+3,r18
3064:switcherator.c ****     tempInt >>= 8;
 3654               		.loc 1 3064 0
 3655 14d2 0E94 0000 		call __lshrdi3
 3656               	.LVL250:
3065:switcherator.c ****     formattedAddress[2] = (tempInt & 0xff);
 3657               		.loc 1 3065 0
 3658 14d6 2283      		std Z+2,r18
3066:switcherator.c ****     tempInt >>= 8;
 3659               		.loc 1 3066 0
 3660 14d8 0E94 0000 		call __lshrdi3
 3661               	.LVL251:
3067:switcherator.c ****     formattedAddress[1] = (tempInt & 0xff);
 3662               		.loc 1 3067 0
 3663 14dc 2183      		std Z+1,r18
 3664               	.LVL252:
3068:switcherator.c ****     tempInt >>= 8;
 3665               		.loc 1 3068 0
 3666 14de 0E94 0000 		call __lshrdi3
 3667               	.LVL253:
3069:switcherator.c ****     formattedAddress[0] = (tempInt & 0xff);
 3668               		.loc 1 3069 0
 3669 14e2 2083      		st Z,r18
 3670               	/* epilogue start */
3070:switcherator.c **** }
 3671               		.loc 1 3070 0
 3672 14e4 1F91      		pop r17
 3673 14e6 0F91      		pop r16
 3674 14e8 0895      		ret
 3675               	.LFE76:
 3677               	.global	getInput
 3679               	getInput:
 3680               	.LFB82:
3071:switcherator.c **** 
3072:switcherator.c **** void sendMessage(char * myResponse) {
3073:switcherator.c ****     stopRx();
3074:switcherator.c ****     _delay_us(100);
3075:switcherator.c ****     int transmitLength = strlen(myResponse);
3076:switcherator.c ****     if(!transmit(myResponse, transmitLength)) {
3077:switcherator.c ****         failCondition = 2;
3078:switcherator.c ****     } else {
3079:switcherator.c ****         failCondition = 0;
3080:switcherator.c ****         clearFail();
3081:switcherator.c ****     }
3082:switcherator.c ****     startRx();
3083:switcherator.c **** }
3084:switcherator.c **** 
3085:switcherator.c **** 
3086:switcherator.c **** /****************************************************************
3087:switcherator.c ****  *
3088:switcherator.c ****  *              All Things Input Related
3089:switcherator.c ****  *
3090:switcherator.c ****  ****************************************************************/
3091:switcherator.c **** 
3092:switcherator.c **** // sets up an input on one of the analog pins
3093:switcherator.c **** // DI:##Ppx?##DuraPO
3094:switcherator.c **** // AI:##PpLLLHHH?##DuraPOw
3095:switcherator.c **** // 0123456789012345678901234
3096:switcherator.c **** // int Port/pin like switches, low%,high%, switch/program, dur, poll time
3097:switcherator.c **** // inputs[NUM_INPUTS]
3098:switcherator.c **** 
3099:switcherator.c **** void setAnalogInput(char * commandReceived) {
3100:switcherator.c ****     int x = 0;
3101:switcherator.c ****     int inputNumber, lowPercent, highPercent, pollTime, outputNum, duration;
3102:switcherator.c ****     char pin = 0;
3103:switcherator.c ****     inputNumber = lowPercent = highPercent = pollTime = outputNum = duration = 0;
3104:switcherator.c ****     int switchNumber = 0;
3105:switcherator.c ****     long temp = 0;
3106:switcherator.c ****     char whichRGB = 0;
3107:switcherator.c ****     tempIntString[0] = commandReceived[3];
3108:switcherator.c ****     tempIntString[1] = commandReceived[4];
3109:switcherator.c ****     inputNumber = atoi(tempIntString);
3110:switcherator.c ****     if (inputNumber >= NUM_INPUTS) {
3111:switcherator.c ****         fail(0x11);
3112:switcherator.c ****         return;
3113:switcherator.c ****     }
3114:switcherator.c ****     tempIntString[0] = '0';
3115:switcherator.c ****     tempIntString[1] = commandReceived[6];
3116:switcherator.c ****     pin = atoi(tempIntString);
3117:switcherator.c ****     if (pin > 7) {
3118:switcherator.c ****         fail(0x04);
3119:switcherator.c ****         return;
3120:switcherator.c ****     }
3121:switcherator.c **** 
3122:switcherator.c ****     tempIntString[0] = commandReceived[14];
3123:switcherator.c ****     tempIntString[1] = commandReceived[15];
3124:switcherator.c ****     switchNumber = atoi(tempIntString);
3125:switcherator.c **** 
3126:switcherator.c ****     tempIntString[0] = commandReceived[20];
3127:switcherator.c ****     tempIntString[1] = commandReceived[21];
3128:switcherator.c ****     pollTime = atoi(tempIntString);
3129:switcherator.c **** 
3130:switcherator.c ****     tempIntString[0] = '0';
3131:switcherator.c ****     tempIntString[1] = commandReceived[22];
3132:switcherator.c ****     whichRGB = atoi(tempIntString);
3133:switcherator.c **** 
3134:switcherator.c ****     tempLongString[0] = '0';
3135:switcherator.c ****     tempLongString[1] = commandReceived[7];
3136:switcherator.c ****     tempLongString[2] = commandReceived[8];
3137:switcherator.c ****     tempLongString[3] = commandReceived[9];
3138:switcherator.c ****     lowPercent = atoi(tempLongString);
3139:switcherator.c ****     tempLongString[1] = commandReceived[10];
3140:switcherator.c ****     tempLongString[2] = commandReceived[11];
3141:switcherator.c ****     tempLongString[3] = commandReceived[12];
3142:switcherator.c ****     highPercent = atoi(tempLongString);
3143:switcherator.c **** 
3144:switcherator.c ****     tempLongString[0] = commandReceived[16];
3145:switcherator.c ****     tempLongString[1] = commandReceived[17];
3146:switcherator.c ****     tempLongString[2] = commandReceived[18];
3147:switcherator.c ****     tempLongString[3] = commandReceived[19];
3148:switcherator.c ****     duration = atoi(tempLongString);
3149:switcherator.c **** 
3150:switcherator.c ****     // pLHsDDP p int pin/port like sw, L%,H% (0,255 - digital), s - 0-127=switch, 128-255 = prog
3151:switcherator.c ****     // 0123456
3152:switcherator.c ****     // dur in seconds, poll time in secs or  0 for continuous. 
3153:switcherator.c ****     // #= analogIn num, p=pin, LLL=low%, HHH=High%,? = 'P'rog or 'S', ## = num
3154:switcherator.c ****     // Durat. = duration in seconds, POLL = poll time in seconds or 0 for 1/10
3155:switcherator.c ****     if (commandReceived[5] != 'C' && commandReceived[5] != 'c') {
3156:switcherator.c ****         fail(0x03);
3157:switcherator.c ****         return;
3158:switcherator.c ****     }
3159:switcherator.c ****     // Port / Pin
3160:switcherator.c ****     // value of 255 (default) means nothing programmed
3161:switcherator.c ****     // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
3162:switcherator.c ****     // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
3163:switcherator.c ****     // pin is abs(value/2)-the base - PINB3 = (22-16)/2  PINB3 (22-16)%2 = 0 - low (23-16)%2 = 1 - 
3164:switcherator.c ****     // port is C.  This is analog in so its not normal but need to set the DDR anyway
3165:switcherator.c ****     // get the pin
3166:switcherator.c ****     temp = pin * 2;
3167:switcherator.c ****     // add # for port C
3168:switcherator.c ****     temp += 32;
3169:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
3170:switcherator.c ****         if (switchStuff[x] == temp) {
3171:switcherator.c **** 
3172:switcherator.c ****             fail(0x12);
3173:switcherator.c ****             return;
3174:switcherator.c ****         }
3175:switcherator.c ****     }
3176:switcherator.c ****     inputs[inputNumber][0] = temp;
3177:switcherator.c ****     DDRC &= ~(1 << pin);
3178:switcherator.c ****     temp = lowPercent;
3179:switcherator.c ****     temp = temp * 255;
3180:switcherator.c ****     temp = temp / 100;
3181:switcherator.c ****     inputs[inputNumber][1] = temp;
3182:switcherator.c ****     temp = highPercent;
3183:switcherator.c ****     temp = temp * 255;
3184:switcherator.c ****     temp = temp / 100;
3185:switcherator.c ****     if (temp == 255) // if the top is 255 we need it to be 254 so its not digital
3186:switcherator.c ****         temp = 254;
3187:switcherator.c **** 
3188:switcherator.c ****     inputs[inputNumber][2] = temp;
3189:switcherator.c ****     // 128 switches and 128 programs possible
3190:switcherator.c ****     if (commandReceived[13] == 'P' || commandReceived[13] == 'p') {
3191:switcherator.c ****         switchNumber += 128;
3192:switcherator.c ****     }
3193:switcherator.c ****     inputs[inputNumber][3] = switchNumber;
3194:switcherator.c ****     temp = duration >> 8;
3195:switcherator.c ****     inputs[inputNumber][4] = temp;
3196:switcherator.c ****     temp = duration & 0xff;
3197:switcherator.c ****     inputs[inputNumber][5] = temp;
3198:switcherator.c **** 
3199:switcherator.c **** 
3200:switcherator.c ****     if (pollTime > 255)
3201:switcherator.c ****         pollTime = 255;
3202:switcherator.c ****     inputs[inputNumber][6] = pollTime;
3203:switcherator.c **** 
3204:switcherator.c ****     // if we are using a RGB switch then which ones do we activate (mask)
3205:switcherator.c ****     if (whichRGB > 7)
3206:switcherator.c ****         whichRGB = 7;
3207:switcherator.c ****     inputs[inputNumber][7] = whichRGB;
3208:switcherator.c **** 
3209:switcherator.c **** 
3210:switcherator.c ****     // set ADMUX when we do a conversion
3211:switcherator.c ****     // Set prescaler 1/32. why not... ;-)
3212:switcherator.c ****     ADCSRA |= (1 << ADPS2) || (1 << ADPS0);
3213:switcherator.c **** 
3214:switcherator.c **** 
3215:switcherator.c ****     ok();
3216:switcherator.c **** }
3217:switcherator.c **** 
3218:switcherator.c **** // set up an input on a regular pin
3219:switcherator.c **** // DI:##Ppx?##DuraPO
3220:switcherator.c **** // 012345678901234567890
3221:switcherator.c **** // #=digital in num, P=Port,p=pin, x=High or Low, ?='P'rog or 'S'witch,
3222:switcherator.c **** // ## = prog/switch num, Durat.=duration in seconds, POLL=poll time in sec or 0 for 1/10
3223:switcherator.c **** 
3224:switcherator.c **** void setDigitalInput(char * commandReceived) {
3225:switcherator.c ****     int x = 0;
3226:switcherator.c ****     int inputNumber, pollTime, outputNum, duration;
3227:switcherator.c ****     volatile unsigned char *realDDR = 0;
3228:switcherator.c ****     volatile unsigned char *realPort = 0;
3229:switcherator.c ****     char pin = 0;
3230:switcherator.c ****     inputNumber = pollTime = outputNum = duration = 0;
3231:switcherator.c ****     int switchNumber = 0;
3232:switcherator.c ****     int temp = 0;
3233:switcherator.c ****     tempIntString[0] = commandReceived[3];
3234:switcherator.c ****     tempIntString[1] = commandReceived[4];
3235:switcherator.c ****     inputNumber = atoi(tempIntString);
3236:switcherator.c ****     if (inputNumber >= NUM_INPUTS) {
3237:switcherator.c ****         fail(0x11);
3238:switcherator.c ****         return;
3239:switcherator.c ****     }
3240:switcherator.c ****     tempIntString[0] = '0';
3241:switcherator.c ****     tempIntString[1] = commandReceived[6];
3242:switcherator.c ****     pin = atoi(tempIntString);
3243:switcherator.c ****     if (pin > 7) {
3244:switcherator.c ****         fail(0x04);
3245:switcherator.c ****         return;
3246:switcherator.c ****     }
3247:switcherator.c **** 
3248:switcherator.c ****     tempIntString[0] = commandReceived[9];
3249:switcherator.c ****     tempIntString[1] = commandReceived[10];
3250:switcherator.c ****     switchNumber = atoi(tempIntString);
3251:switcherator.c **** 
3252:switcherator.c ****     tempIntString[0] = commandReceived[15];
3253:switcherator.c ****     tempIntString[1] = commandReceived[16];
3254:switcherator.c ****     pollTime = atoi(tempIntString);
3255:switcherator.c **** 
3256:switcherator.c ****     tempLongString[0] = commandReceived[11];
3257:switcherator.c ****     tempLongString[1] = commandReceived[12];
3258:switcherator.c ****     tempLongString[2] = commandReceived[13];
3259:switcherator.c ****     tempLongString[3] = commandReceived[14];
3260:switcherator.c ****     duration = atoi(tempLongString);
3261:switcherator.c ****     // if we are activating a program
3262:switcherator.c ****     if (commandReceived[8] == 'P' || commandReceived[8] == 'p') {
3263:switcherator.c ****         switchNumber += 128;
3264:switcherator.c ****     }
3265:switcherator.c ****     temp = pin * 2;
3266:switcherator.c ****     if (commandReceived[5] == 'B' || commandReceived[5] == 'b') {
3267:switcherator.c ****         realDDR = &DDRB;
3268:switcherator.c ****         realPort = &PORTB;
3269:switcherator.c ****         temp += 16;
3270:switcherator.c **** #ifdef PORTA
3271:switcherator.c ****     } else if (commandReceived[5] == 'A' || commandReceived[5] == 'a') {
3272:switcherator.c ****         realDDR = &DDRA;
3273:switcherator.c ****         realPort = &PORTA;
3274:switcherator.c ****         temp += 0;
3275:switcherator.c **** #endif        
3276:switcherator.c **** #ifdef PORTC
3277:switcherator.c ****     } else if (commandReceived[5] == 'C' || commandReceived[5] == 'c') {
3278:switcherator.c ****         realDDR = &DDRC;
3279:switcherator.c ****         realPort = &PORTC;
3280:switcherator.c ****         temp += 32;
3281:switcherator.c **** #endif        
3282:switcherator.c **** #ifdef PORTD
3283:switcherator.c ****     } else if (commandReceived[5] == 'D' || commandReceived[5] == 'd') {
3284:switcherator.c ****         realDDR = &DDRD;
3285:switcherator.c ****         realPort = &PORTD;
3286:switcherator.c ****         temp += 48;
3287:switcherator.c **** #endif        
3288:switcherator.c **** #ifdef PORTE
3289:switcherator.c ****     } else if (commandReceived[5] == 'E' || commandReceived[5] == 'e') {
3290:switcherator.c ****         realDDR = &DDRE;
3291:switcherator.c ****         realPort = &PORTE;
3292:switcherator.c ****         temp += 64;
3293:switcherator.c **** #endif        
3294:switcherator.c **** #ifdef PORTF
3295:switcherator.c ****     } else if (commandReceived[5] == 'F' || commandReceived[5] == 'f') {
3296:switcherator.c ****         realDDR = &DDRF;
3297:switcherator.c ****         realPort = &PORTF;
3298:switcherator.c ****         temp += 80;
3299:switcherator.c **** #endif        
3300:switcherator.c **** #ifdef PORTG
3301:switcherator.c ****     } else if (commandReceived[5] == 'G' || commandReceived[5] == 'g') {
3302:switcherator.c ****         realDDR = &DDRG;
3303:switcherator.c ****         realPort = &PORTG;
3304:switcherator.c ****         temp += 96;
3305:switcherator.c **** #endif        
3306:switcherator.c **** #ifdef PORTH
3307:switcherator.c ****     } else if (commandReceived[5] == 'H' || commandReceived[5] == 'h') {
3308:switcherator.c ****         realDDR = &DDRH;
3309:switcherator.c ****         realPort = &PORTH;
3310:switcherator.c ****         temp += 112;
3311:switcherator.c **** #endif        
3312:switcherator.c **** #ifdef PORTI
3313:switcherator.c ****     } else if (commandReceived[5] == 'I' || commandReceived[5] == 'i') {
3314:switcherator.c ****         realDDR = &DDRI;
3315:switcherator.c ****         realPort = &PORTI;
3316:switcherator.c ****         temp += 128;
3317:switcherator.c **** #endif        
3318:switcherator.c ****     }
3319:switcherator.c ****     // value of 255 (default) means nothing programmed
3320:switcherator.c ****     // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
3321:switcherator.c ****     // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
3322:switcherator.c ****     // pin is abs(value/2)-the base - PINB3 = (22-16)/2  PINB3 (22-16)%2 = 0 - low (23-16)%2 = 1 - 
3323:switcherator.c ****     // port is C.  This is analog in so its not normal but need to set the DDR anyway
3324:switcherator.c ****     // get the pin
3325:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
3326:switcherator.c ****         if (switchStuff[x] == temp || switchStuff[x] == (temp + 1)) {
3327:switcherator.c ****             fail(0x12);
3328:switcherator.c ****             return;
3329:switcherator.c ****         }
3330:switcherator.c ****     }
3331:switcherator.c **** 
3332:switcherator.c ****     inputs[inputNumber][0] = temp;
3333:switcherator.c **** 
3334:switcherator.c ****     if (commandReceived[7] == 'H' || commandReceived[7] == 'h' ||
3335:switcherator.c ****             commandReceived[7] == '1') {
3336:switcherator.c ****         inputs[inputNumber][1] = 0;
3337:switcherator.c ****         inputs[inputNumber][2] = 255;
3338:switcherator.c ****     } else {
3339:switcherator.c ****         inputs[inputNumber][1] = 255;
3340:switcherator.c ****         inputs[inputNumber][2] = 0;
3341:switcherator.c ****     }
3342:switcherator.c ****     inputs[inputNumber][3] = switchNumber;
3343:switcherator.c ****     temp = duration >> 8;
3344:switcherator.c ****     inputs[inputNumber][4] = temp;
3345:switcherator.c ****     temp = duration & 0xff;
3346:switcherator.c ****     inputs[inputNumber][5] = temp;
3347:switcherator.c **** 
3348:switcherator.c ****     if (pollTime > 255)
3349:switcherator.c ****         pollTime = 255;
3350:switcherator.c ****     inputs[inputNumber][6] = pollTime;
3351:switcherator.c **** 
3352:switcherator.c ****     *realDDR &= ~(1 << pin);
3353:switcherator.c ****     *realPort |= (1 << pin);
3354:switcherator.c **** 
3355:switcherator.c ****     ok();
3356:switcherator.c ****     // DI:##Ppx?##DuraPO
3357:switcherator.c ****     // 012345678901234567890
3358:switcherator.c **** }
3359:switcherator.c **** 
3360:switcherator.c **** // inputs[NUM_INPUTS] - is the following
3361:switcherator.c **** // pLHsDDP p int pin/port like sw, L%,H% (0,255 - digital), s - 0-127=switch, 128-255 = prog
3362:switcherator.c **** // 0123456
3363:switcherator.c **** // Port / Pin
3364:switcherator.c **** // value of 255 (default) means nothing programmed
3365:switcherator.c **** // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
3366:switcherator.c **** // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
3367:switcherator.c **** 
3368:switcherator.c **** // see if we check any inputs this second
3369:switcherator.c **** 
3370:switcherator.c **** void inputCheck(void) {
3371:switcherator.c ****     int x = 0;
3372:switcherator.c ****     int pollTime = 0;
3373:switcherator.c ****     // figure out if we care about our inputs
3374:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
3375:switcherator.c ****         // see if it is a valid input
3376:switcherator.c ****         if (inputs[x][0] == 255)
3377:switcherator.c ****             continue; // not valid. Skip
3378:switcherator.c ****         pollTime = inputs[x][6];
3379:switcherator.c ****         // see if it is one we check continuously or every second
3380:switcherator.c ****         if (pollTime == 0 || pollTime == 1) {
3381:switcherator.c ****             getInput(x);
3382:switcherator.c ****             // see if we it is the right second otherwise
3383:switcherator.c ****         } else if (weeklySeconds % pollTime == 0) {
3384:switcherator.c ****             getInput(x);
3385:switcherator.c ****         }
3386:switcherator.c ****     }
3387:switcherator.c **** }
3388:switcherator.c **** 
3389:switcherator.c **** // see if we check inputs continuously (every 10th)
3390:switcherator.c **** 
3391:switcherator.c **** void inputTenthCheck(void) {
3392:switcherator.c ****     int x = 0;
3393:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
3394:switcherator.c ****         // see if it is valid and marked continuously
3395:switcherator.c ****         if (inputs[x][0] != 255 && inputs[x][6] == 0)
3396:switcherator.c ****             getInput(x);
3397:switcherator.c ****     }
3398:switcherator.c **** }
3399:switcherator.c **** 
3400:switcherator.c **** // inputs[NUM_INPUTS] - is the following
3401:switcherator.c **** // pLHsDDPw p int pin/port like sw, L%,H% (0,255 - digital), s - 0-127=switch, 128-255 = prog
3402:switcherator.c **** // 01234567 - w= which analog out if needed
3403:switcherator.c **** // Port / Pin
3404:switcherator.c **** // value of 255 (default) means nothing programmed
3405:switcherator.c **** // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
3406:switcherator.c **** // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
3407:switcherator.c **** 
3408:switcherator.c **** 
3409:switcherator.c **** // actually check the input and do something based on that
3410:switcherator.c **** 
3411:switcherator.c **** void getInput(int inputNumber) {
 3681               		.loc 1 3411 0
 3682               	.LVL254:
 3683 14ea 2F92      		push r2
 3684               	.LCFI86:
 3685 14ec 3F92      		push r3
 3686               	.LCFI87:
 3687 14ee 4F92      		push r4
 3688               	.LCFI88:
 3689 14f0 5F92      		push r5
 3690               	.LCFI89:
 3691 14f2 6F92      		push r6
 3692               	.LCFI90:
 3693 14f4 7F92      		push r7
 3694               	.LCFI91:
 3695 14f6 8F92      		push r8
 3696               	.LCFI92:
 3697 14f8 9F92      		push r9
 3698               	.LCFI93:
 3699 14fa AF92      		push r10
 3700               	.LCFI94:
 3701 14fc BF92      		push r11
 3702               	.LCFI95:
 3703 14fe CF92      		push r12
 3704               	.LCFI96:
 3705 1500 DF92      		push r13
 3706               	.LCFI97:
 3707 1502 EF92      		push r14
 3708               	.LCFI98:
 3709 1504 FF92      		push r15
 3710               	.LCFI99:
 3711 1506 0F93      		push r16
 3712               	.LCFI100:
 3713 1508 1F93      		push r17
 3714               	.LCFI101:
 3715 150a CF93      		push r28
 3716               	.LCFI102:
 3717 150c DF93      		push r29
 3718               	.LCFI103:
 3719 150e CDB7      		in r28,__SP_L__
 3720 1510 DEB7      		in r29,__SP_H__
 3721               	.LCFI104:
 3722 1512 2C97      		sbiw r28,12
 3723               	.LCFI105:
 3724 1514 0FB6      		in __tmp_reg__,__SREG__
 3725 1516 F894      		cli
 3726 1518 DEBF      		out __SP_H__,r29
 3727 151a 0FBE      		out __SREG__,__tmp_reg__
 3728 151c CDBF      		out __SP_L__,r28
 3729               	/* prologue: function */
 3730               	/* frame size = 12 */
 3731               	/* stack size = 30 */
 3732               	.L__stack_usage = 30
 3733 151e FC01      		movw r30,r24
 3734               	.LVL255:
3412:switcherator.c ****     int x = 0;
3413:switcherator.c ****     unsigned int outputNum, duration, low, high, switchNumber;
3414:switcherator.c ****     volatile unsigned char *thisPin = 0;
3415:switcherator.c ****     long temp = 0;
3416:switcherator.c ****     char test = 0;
3417:switcherator.c ****     char pwmValue = 0;
3418:switcherator.c ****     char whichRGB = 0;
3419:switcherator.c ****     // set up how many seconds are at the beginning of today
3420:switcherator.c ****     long daySeconds = (dow * 86400);
 3735               		.loc 1 3420 0
 3736 1520 2090 0000 		lds r2,dow
 3737 1524 3090 0000 		lds r3,dow+1
 3738 1528 2101      		movw r4,r2
 3739 152a 612C      		mov r6,__zero_reg__
 3740 152c 712C      		mov r7,__zero_reg__
 3741 152e A301      		movw r20,r6
 3742 1530 9201      		movw r18,r4
 3743 1532 60E8      		ldi r22,lo8(-128)
 3744 1534 71E5      		ldi r23,lo8(81)
 3745 1536 81E0      		ldi r24,lo8(1)
 3746 1538 90E0      		ldi r25,0
 3747 153a 0E94 0000 		call __mulsi3
 3748 153e 4B01      		movw r8,r22
 3749 1540 5C01      		movw r10,r24
 3750               	.LVL256:
3421:switcherator.c ****     long startTime, stopTime;
3422:switcherator.c ****     startTime = stopTime = 0;
3423:switcherator.c ****     outputNum = duration = low = high = switchNumber = 0;
3424:switcherator.c ****     outputNum = inputs[inputNumber][0];
 3751               		.loc 1 3424 0
 3752 1542 43E0      		ldi r20,3
 3753               		1:
 3754 1544 EE0F      		lsl r30
 3755 1546 FF1F      		rol r31
 3756 1548 4A95      		dec r20
 3757 154a 01F4      		brne 1b
 3758 154c E050      		subi r30,lo8(-(inputs))
 3759 154e F040      		sbci r31,hi8(-(inputs))
 3760 1550 6081      		ld r22,Z
 3761               	.LVL257:
3425:switcherator.c ****     low = inputs[inputNumber][1];
 3762               		.loc 1 3425 0
 3763 1552 C180      		ldd r12,Z+1
 3764 1554 EC2C      		mov r14,r12
 3765 1556 F12C      		mov r15,__zero_reg__
 3766               	.LVL258:
3426:switcherator.c ****     high = inputs[inputNumber][2];
 3767               		.loc 1 3426 0
 3768 1558 0281      		ldd r16,Z+2
 3769 155a 0983      		std Y+1,r16
 3770               	.LVL259:
3427:switcherator.c ****     switchNumber = inputs[inputNumber][3];
 3771               		.loc 1 3427 0
 3772 155c 0381      		ldd r16,Z+3
 3773               	.LVL260:
 3774 155e 10E0      		ldi r17,0
 3775               	.LVL261:
3428:switcherator.c ****     temp = inputs[inputNumber][4];
3429:switcherator.c ****     duration = (temp << 8);
 3776               		.loc 1 3429 0
 3777 1560 3481      		ldd r19,Z+4
 3778 1562 20E0      		ldi r18,0
3430:switcherator.c ****     temp = inputs[inputNumber][5];
3431:switcherator.c ****     duration |= temp;
 3779               		.loc 1 3431 0
 3780 1564 8581      		ldd r24,Z+5
 3781               	.LVL262:
 3782 1566 A901      		movw r20,r18
 3783 1568 482B      		or r20,r24
 3784 156a 5C87      		std Y+12,r21
 3785 156c 4B87      		std Y+11,r20
 3786               	.LVL263:
3432:switcherator.c ****     whichRGB = inputs[inputNumber][7];
 3787               		.loc 1 3432 0
 3788 156e D780      		ldd r13,Z+7
 3789               	.LVL264:
3433:switcherator.c ****     // if this is an analog input than both the low% or the high% will not be 255
3434:switcherator.c ****     if (low != 255 && high != 255) {
 3790               		.loc 1 3434 0
 3791 1570 5FEF      		ldi r21,-1
 3792 1572 E516      		cp r14,r21
 3793 1574 F104      		cpc r15,__zero_reg__
 3794 1576 01F4      		brne .+2
 3795 1578 00C0      		rjmp .L257
3426:switcherator.c ****     high = inputs[inputNumber][2];
 3796               		.loc 1 3426 0 discriminator 1
 3797 157a F981      		ldd r31,Y+1
 3798 157c EF2F      		mov r30,r31
 3799               	.LVL265:
 3800 157e F0E0      		ldi r31,0
 3801 1580 FA87      		std Y+10,r31
 3802 1582 E987      		std Y+9,r30
 3803               		.loc 1 3434 0 discriminator 1
 3804 1584 EF3F      		cpi r30,-1
 3805 1586 F105      		cpc r31,__zero_reg__
 3806 1588 01F4      		brne .+2
 3807 158a 00C0      		rjmp .L257
3424:switcherator.c ****     outputNum = inputs[inputNumber][0];
 3808               		.loc 1 3424 0
 3809 158c 70E0      		ldi r23,0
3435:switcherator.c ****         // this is an analog input
3436:switcherator.c ****         // currently only port C is supported for analog inputs
3437:switcherator.c ****         temp = outputNum - 32;
 3810               		.loc 1 3437 0
 3811 158e 6052      		subi r22,32
 3812 1590 7109      		sbc r23,__zero_reg__
 3813               	.LVL266:
 3814 1592 CB01      		movw r24,r22
 3815 1594 A0E0      		ldi r26,0
 3816 1596 B0E0      		ldi r27,0
 3817               	.LVL267:
3438:switcherator.c ****         temp = temp / 2;
 3818               		.loc 1 3438 0
 3819 1598 B595      		asr r27
 3820 159a A795      		ror r26
 3821 159c 9795      		ror r25
 3822 159e 8795      		ror r24
 3823               	.LVL268:
3439:switcherator.c ****         if (temp > 7) // if things got goofed up somehow 
 3824               		.loc 1 3439 0
 3825 15a0 8830      		cpi r24,8
 3826 15a2 9105      		cpc r25,__zero_reg__
 3827 15a4 A105      		cpc r26,__zero_reg__
 3828 15a6 B105      		cpc r27,__zero_reg__
 3829 15a8 04F0      		brlt .+2
 3830 15aa 00C0      		rjmp .L256
3440:switcherator.c ****             return;
3441:switcherator.c ****         ADMUX = temp; // which pin to check
 3831               		.loc 1 3441 0
 3832 15ac 8093 7C00 		sts 124,r24
3442:switcherator.c ****         ADCSRA |= (1 << ADEN) | (1 << ADSC); // turn on ADC and start a conversion
 3833               		.loc 1 3442 0
 3834 15b0 8091 7A00 		lds r24,122
 3835               	.LVL269:
 3836 15b4 806C      		ori r24,lo8(-64)
 3837 15b6 8093 7A00 		sts 122,r24
 3838               	.L260:
3443:switcherator.c ****         loop_until_bit_is_set(ADCSRA, ADIF);
 3839               		.loc 1 3443 0 discriminator 1
 3840 15ba 8091 7A00 		lds r24,122
 3841 15be 84FF      		sbrs r24,4
 3842 15c0 00C0      		rjmp .L260
3444:switcherator.c ****         temp = ADC;
 3843               		.loc 1 3444 0
 3844 15c2 2091 7800 		lds r18,120
 3845 15c6 3091 7900 		lds r19,120+1
 3846               	.LVL270:
3445:switcherator.c ****         temp = temp * 255;
 3847               		.loc 1 3445 0
 3848 15ca AFEF      		ldi r26,lo8(-1)
 3849 15cc B0E0      		ldi r27,0
 3850 15ce 0E94 0000 		call __umulhisi3
 3851               	.LVL271:
3446:switcherator.c ****         temp = temp / 1024; // now its a number between 0 and 255;
 3852               		.loc 1 3446 0
 3853 15d2 2AE0      		ldi r18,10
 3854               		1:
 3855 15d4 9595      		asr r25
 3856 15d6 8795      		ror r24
 3857 15d8 7795      		ror r23
 3858 15da 6795      		ror r22
 3859 15dc 2A95      		dec r18
 3860 15de 01F4      		brne 1b
 3861               	.LVL272:
3447:switcherator.c ****         ADCSRA |= (1 << ADIF); // clear the ADC
 3862               		.loc 1 3447 0
 3863 15e0 2091 7A00 		lds r18,122
 3864 15e4 2061      		ori r18,lo8(16)
 3865 15e6 2093 7A00 		sts 122,r18
3448:switcherator.c ****         // see if we are turning on the switch
3449:switcherator.c ****         if (temp > low && temp < (high + 1)) {
 3866               		.loc 1 3449 0
 3867 15ea 4C2C      		mov r4,r12
 3868 15ec 512C      		mov r5,__zero_reg__
 3869 15ee 612C      		mov r6,__zero_reg__
 3870 15f0 712C      		mov r7,__zero_reg__
 3871 15f2 4616      		cp r4,r22
 3872 15f4 5706      		cpc r5,r23
 3873 15f6 6806      		cpc r6,r24
 3874 15f8 7906      		cpc r7,r25
 3875 15fa 04F0      		brlt .+2
 3876 15fc 00C0      		rjmp .L256
 3877               		.loc 1 3449 0 is_stmt 0 discriminator 1
 3878 15fe A985      		ldd r26,Y+9
 3879 1600 BA85      		ldd r27,Y+10
 3880 1602 1196      		adiw r26,1
 3881 1604 9D01      		movw r18,r26
 3882 1606 40E0      		ldi r20,0
 3883 1608 50E0      		ldi r21,0
 3884               	.LVL273:
 3885 160a 6217      		cp r22,r18
 3886 160c 7307      		cpc r23,r19
 3887 160e 8407      		cpc r24,r20
 3888 1610 9507      		cpc r25,r21
 3889 1612 04F0      		brlt .+2
 3890 1614 00C0      		rjmp .L256
3450:switcherator.c ****             // see if it is a PWM switch (not a program)
3451:switcherator.c ****             if (switchNumber < 128 && switchStuff[switchNumber] == 200) {
 3891               		.loc 1 3451 0 is_stmt 1
 3892 1616 0038      		cpi r16,-128
 3893 1618 1105      		cpc r17,__zero_reg__
 3894 161a 00F4      		brsh .L262
 3895               		.loc 1 3451 0 is_stmt 0 discriminator 1
 3896 161c F801      		movw r30,r16
 3897               	.LVL274:
 3898 161e E050      		subi r30,lo8(-(switchStuff))
 3899 1620 F040      		sbci r31,hi8(-(switchStuff))
 3900 1622 2081      		ld r18,Z
 3901 1624 283C      		cpi r18,lo8(-56)
 3902 1626 01F0      		breq .+2
 3903 1628 00C0      		rjmp .L293
3452:switcherator.c ****                 // this is a PWM so we're doing it based on the relative ADC value
3453:switcherator.c ****                 // see if we are using the whole range.
3454:switcherator.c ****                 if ((high - low) > 250) {
 3904               		.loc 1 3454 0 is_stmt 1
 3905 162a 4985      		ldd r20,Y+9
 3906 162c 5A85      		ldd r21,Y+10
 3907 162e 4E19      		sub r20,r14
 3908 1630 5F09      		sbc r21,r15
 3909 1632 4B3F      		cpi r20,-5
 3910 1634 5105      		cpc r21,__zero_reg__
 3911 1636 00F0      		brlo .+2
 3912 1638 00C0      		rjmp .L293
 3913               	.LVL275:
 3914               	.LBB19:
3455:switcherator.c ****                     pwmValue = temp;
3456:switcherator.c ****                 } else {
3457:switcherator.c ****                     // figure out what percentage between the values we are
3458:switcherator.c ****                     char range = high - low;
3459:switcherator.c ****                     temp = temp - low;
 3915               		.loc 1 3459 0
 3916 163a 9B01      		movw r18,r22
 3917 163c AC01      		movw r20,r24
 3918 163e 2419      		sub r18,r4
 3919 1640 3509      		sbc r19,r5
 3920 1642 4609      		sbc r20,r6
 3921 1644 5709      		sbc r21,r7
 3922               	.LVL276:
3460:switcherator.c ****                     temp = temp * 255;
 3923               		.loc 1 3460 0
 3924 1646 AFEF      		ldi r26,lo8(-1)
 3925 1648 B0E0      		ldi r27,0
 3926 164a 0E94 0000 		call __muluhisi3
 3927               	.LVL277:
3458:switcherator.c ****                     char range = high - low;
 3928               		.loc 1 3458 0
 3929 164e 2981      		ldd r18,Y+1
 3930 1650 2C19      		sub r18,r12
 3931               	.LVL278:
3461:switcherator.c ****                     temp = temp / range; // now we have a relative value between 0&255
 3932               		.loc 1 3461 0
 3933 1652 30E0      		ldi r19,0
 3934 1654 40E0      		ldi r20,0
 3935 1656 50E0      		ldi r21,0
 3936 1658 0E94 0000 		call __divmodsi4
 3937               	.LVL279:
3462:switcherator.c ****                     pwmValue = temp;
 3938               		.loc 1 3462 0
 3939 165c 822F      		mov r24,r18
 3940               	.LVL280:
3463:switcherator.c ****                     // see if we are changing RGB
3464:switcherator.c ****                     if (whichRGB & 4)
 3941               		.loc 1 3464 0
 3942 165e D2FC      		sbrc r13,2
3465:switcherator.c ****                         pwmValues[0] = pwmValue;
 3943               		.loc 1 3465 0
 3944 1660 2093 0000 		sts pwmValues,r18
 3945               	.L264:
3466:switcherator.c ****                     if (whichRGB & 2)
 3946               		.loc 1 3466 0
 3947 1664 D1FC      		sbrc r13,1
3467:switcherator.c ****                         pwmValues[1] = pwmValue;
 3948               		.loc 1 3467 0
 3949 1666 8093 0000 		sts pwmValues+1,r24
 3950               	.L265:
3468:switcherator.c ****                     if (whichRGB & 1)
 3951               		.loc 1 3468 0
 3952 166a D0FC      		sbrc r13,0
3469:switcherator.c ****                         pwmValues[2] = pwmValue;
 3953               		.loc 1 3469 0
 3954 166c 8093 0000 		sts pwmValues+2,r24
 3955               	.L266:
3470:switcherator.c ****                     if (whichRGB & 7) // if anything changed
 3956               		.loc 1 3470 0
 3957 1670 8D2D      		mov r24,r13
 3958 1672 8770      		andi r24,lo8(7)
 3959 1674 01F4      		brne .+2
 3960 1676 00C0      		rjmp .L293
3471:switcherator.c ****                         switchChanged = 1;
 3961               		.loc 1 3471 0
 3962 1678 81E0      		ldi r24,lo8(1)
 3963 167a 8093 0000 		sts switchChanged,r24
 3964 167e 00C0      		rjmp .L293
 3965               	.LVL281:
 3966               	.L262:
 3967 1680 E0E0      		ldi r30,lo8(timeLimits+8)
 3968 1682 F0E0      		ldi r31,hi8(timeLimits+8)
 3969               	.LVL282:
 3970               	.LBE19:
3411:switcherator.c **** void getInput(int inputNumber) {
 3971               		.loc 1 3411 0
 3972 1684 20E0      		ldi r18,0
 3973               	.LVL283:
 3974               	.L269:
3472:switcherator.c ****                 }
3473:switcherator.c ****             }
3474:switcherator.c ****             // k we set up PWM now make it so it switches on
3475:switcherator.c ****             if (switchNumber < 128) { // its a switch
3476:switcherator.c ****                 if (switchStatus[switchNumber] == 0) // the switch is off
3477:switcherator.c ****                     switchChanged = 1;
3478:switcherator.c ****                 if (switchStatus[switchNumber] < (weeklySeconds + duration))
3479:switcherator.c ****                     switchStatus[switchNumber] = (weeklySeconds + duration);
3480:switcherator.c ****             } else { // its a program;
3481:switcherator.c ****                 test = 0;
3482:switcherator.c ****                 // check and make sure we are within the time limits (eg dusk to dawn)
3483:switcherator.c ****                 // first if no time limits set up then ignore it
3484:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
3485:switcherator.c ****                     if (timeLimits[x][2] > 0)
 3975               		.loc 1 3485 0
 3976 1686 8081      		ld r24,Z
 3977 1688 9181      		ldd r25,Z+1
 3978 168a A281      		ldd r26,Z+2
 3979 168c B381      		ldd r27,Z+3
 3980 168e 892B      		or r24,r25
 3981 1690 8A2B      		or r24,r26
 3982 1692 8B2B      		or r24,r27
 3983 1694 01F0      		breq .L268
3486:switcherator.c ****                         test = 1;
 3984               		.loc 1 3486 0
 3985 1696 21E0      		ldi r18,lo8(1)
 3986               	.L268:
 3987               	.LVL284:
 3988 1698 3C96      		adiw r30,12
3484:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
 3989               		.loc 1 3484 0
 3990 169a 30E0      		ldi r19,hi8(timeLimits+56)
 3991 169c E030      		cpi r30,lo8(timeLimits+56)
 3992 169e F307      		cpc r31,r19
 3993 16a0 01F4      		brne .L269
3487:switcherator.c ****                 }
3488:switcherator.c ****                 // no limits set up
3489:switcherator.c ****                 if (test == 0)
 3994               		.loc 1 3489 0
 3995 16a2 2111      		cpse r18,__zero_reg__
 3996 16a4 00C0      		rjmp .L270
3490:switcherator.c ****                     startTheProgram((switchNumber - 128), duration, 0);
 3997               		.loc 1 3490 0
 3998 16a6 20E0      		ldi r18,0
 3999 16a8 30E0      		ldi r19,0
 4000 16aa A901      		movw r20,r18
 4001               	.LVL285:
 4002 16ac 6B85      		ldd r22,Y+11
 4003 16ae 7C85      		ldd r23,Y+12
 4004               	.LVL286:
 4005 16b0 C801      		movw r24,r16
 4006 16b2 8058      		subi r24,-128
 4007 16b4 9109      		sbc r25,__zero_reg__
 4008 16b6 0E94 0000 		call startTheProgram
 4009               	.LVL287:
 4010               	.L270:
 4011 16ba 80E0      		ldi r24,lo8(timeLimits)
 4012 16bc E82E      		mov r14,r24
 4013 16be 80E0      		ldi r24,hi8(timeLimits)
 4014 16c0 F82E      		mov r15,r24
 4015               	.LVL288:
3491:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
3492:switcherator.c ****                     startTime = timeLimits[x][0];
3493:switcherator.c ****                     stopTime = timeLimits[x][1];
3494:switcherator.c ****                     // deal with nights that cross midnight
3495:switcherator.c ****                     if (stopTime < startTime) {
3496:switcherator.c ****                         temp = dow;
3497:switcherator.c ****                         // weekly seconds resets at the end of the week. so do lots of 9
3498:switcherator.c ****                         if (weeklySeconds <= (stopTime + daySeconds)) {
3499:switcherator.c ****                             // k this is dow + 1
3500:switcherator.c ****                             if (temp == 0)
3501:switcherator.c ****                                 temp = 6;
3502:switcherator.c ****                             else
3503:switcherator.c ****                                 temp--;
3504:switcherator.c ****                             if (timeLimits[x][2] & (1 << temp))
3505:switcherator.c ****                                 startTheProgram((switchNumber - 128), duration, 0);
3506:switcherator.c ****                         } else if (weeklySeconds >= (startTime + daySeconds)) {
3507:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
3508:switcherator.c ****                                 startTheProgram((switchNumber - 128), duration, 0);
3509:switcherator.c ****                         }
3510:switcherator.c ****                     } else {
3511:switcherator.c ****                         if (weeklySeconds >= (startTime + daySeconds) &&
3512:switcherator.c ****                                 weeklySeconds <= (stopTime + daySeconds)) {
3513:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
 4016               		.loc 1 3513 0 discriminator 1
 4017 16c2 CC24      		clr r12
 4018 16c4 C394      		inc r12
 4019 16c6 D12C      		mov r13,__zero_reg__
3514:switcherator.c ****                                 startTheProgram((switchNumber - 128), duration, 0);
 4020               		.loc 1 3514 0 discriminator 1
 4021 16c8 0058      		subi r16,-128
 4022 16ca 1109      		sbc r17,__zero_reg__
 4023               	.LVL289:
 4024               	.L275:
3492:switcherator.c ****                     startTime = timeLimits[x][0];
 4025               		.loc 1 3492 0
 4026 16cc D701      		movw r26,r14
 4027 16ce 4D90      		ld r4,X+
 4028 16d0 5D90      		ld r5,X+
 4029 16d2 6D90      		ld r6,X+
 4030 16d4 7C90      		ld r7,X
 4031 16d6 1397      		sbiw r26,3
 4032               	.LVL290:
3493:switcherator.c ****                     stopTime = timeLimits[x][1];
 4033               		.loc 1 3493 0
 4034 16d8 1496      		adiw r26,4
 4035 16da 4D91      		ld r20,X+
 4036 16dc 5D91      		ld r21,X+
 4037 16de 6D91      		ld r22,X+
 4038 16e0 7C91      		ld r23,X
 4039 16e2 1797      		sbiw r26,4+3
 4040               	.LVL291:
 4041 16e4 8091 0000 		lds r24,weeklySeconds
 4042 16e8 9091 0000 		lds r25,weeklySeconds+1
 4043 16ec A091 0000 		lds r26,weeklySeconds+2
 4044 16f0 B091 0000 		lds r27,weeklySeconds+3
3495:switcherator.c ****                     if (stopTime < startTime) {
 4045               		.loc 1 3495 0
 4046 16f4 4415      		cp r20,r4
 4047 16f6 5505      		cpc r21,r5
 4048 16f8 6605      		cpc r22,r6
 4049 16fa 7705      		cpc r23,r7
 4050 16fc 04F0      		brlt .+2
 4051 16fe 00C0      		rjmp .L271
3496:switcherator.c ****                         temp = dow;
 4052               		.loc 1 3496 0
 4053 1700 2091 0000 		lds r18,dow
 4054 1704 3091 0000 		lds r19,dow+1
 4055               	.LVL292:
3498:switcherator.c ****                         if (weeklySeconds <= (stopTime + daySeconds)) {
 4056               		.loc 1 3498 0
 4057 1708 480D      		add r20,r8
 4058 170a 591D      		adc r21,r9
 4059 170c 6A1D      		adc r22,r10
 4060 170e 7B1D      		adc r23,r11
 4061               	.LVL293:
 4062 1710 4817      		cp r20,r24
 4063 1712 5907      		cpc r21,r25
 4064 1714 6A07      		cpc r22,r26
 4065 1716 7B07      		cpc r23,r27
 4066 1718 00F0      		brlo .L272
3496:switcherator.c ****                         temp = dow;
 4067               		.loc 1 3496 0
 4068 171a C901      		movw r24,r18
 4069 171c A0E0      		ldi r26,0
 4070 171e B0E0      		ldi r27,0
3500:switcherator.c ****                             if (temp == 0)
 4071               		.loc 1 3500 0
 4072 1720 0097      		sbiw r24,0
 4073 1722 A105      		cpc r26,__zero_reg__
 4074 1724 B105      		cpc r27,__zero_reg__
 4075 1726 01F0      		breq .L295
3503:switcherator.c ****                                 temp--;
 4076               		.loc 1 3503 0
 4077 1728 0197      		sbiw r24,1
 4078 172a A109      		sbc r26,__zero_reg__
 4079 172c B109      		sbc r27,__zero_reg__
 4080               	.LVL294:
 4081 172e 00C0      		rjmp .L273
 4082               	.LVL295:
 4083               	.L295:
3501:switcherator.c ****                                 temp = 6;
 4084               		.loc 1 3501 0
 4085 1730 86E0      		ldi r24,lo8(6)
 4086 1732 90E0      		ldi r25,0
 4087 1734 A0E0      		ldi r26,0
 4088 1736 B0E0      		ldi r27,0
 4089               	.LVL296:
 4090               	.L273:
3504:switcherator.c ****                             if (timeLimits[x][2] & (1 << temp))
 4091               		.loc 1 3504 0
 4092 1738 9601      		movw r18,r12
 4093 173a 00C0      		rjmp 2f
 4094               		1:
 4095 173c 220F      		lsl r18
 4096 173e 331F      		rol r19
 4097               		2:
 4098 1740 8A95      		dec r24
 4099 1742 02F4      		brpl 1b
 4100 1744 A901      		movw r20,r18
 4101 1746 6627      		clr r22
 4102 1748 57FD      		sbrc r21,7
 4103 174a 6095      		com r22
 4104 174c 762F      		mov r23,r22
 4105 174e F701      		movw r30,r14
 4106 1750 8085      		ldd r24,Z+8
 4107 1752 9185      		ldd r25,Z+9
 4108 1754 A285      		ldd r26,Z+10
 4109 1756 B385      		ldd r27,Z+11
 4110 1758 4823      		and r20,r24
 4111 175a 5923      		and r21,r25
 4112 175c 6A23      		and r22,r26
 4113 175e 7B23      		and r23,r27
 4114 1760 452B      		or r20,r21
 4115 1762 462B      		or r20,r22
 4116 1764 472B      		or r20,r23
 4117 1766 01F4      		brne .+2
 4118 1768 00C0      		rjmp .L274
 4119 176a 00C0      		rjmp .L347
 4120               	.LVL297:
 4121               	.L272:
3506:switcherator.c ****                         } else if (weeklySeconds >= (startTime + daySeconds)) {
 4122               		.loc 1 3506 0
 4123 176c 480C      		add r4,r8
 4124 176e 591C      		adc r5,r9
 4125 1770 6A1C      		adc r6,r10
 4126 1772 7B1C      		adc r7,r11
 4127               	.LVL298:
 4128 1774 8415      		cp r24,r4
 4129 1776 9505      		cpc r25,r5
 4130 1778 A605      		cpc r26,r6
 4131 177a B705      		cpc r27,r7
 4132 177c 00F0      		brlo .L274
3507:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
 4133               		.loc 1 3507 0
 4134 177e C601      		movw r24,r12
 4135 1780 00C0      		rjmp 2f
 4136               		1:
 4137 1782 880F      		lsl r24
 4138 1784 991F      		rol r25
 4139               		2:
 4140 1786 2A95      		dec r18
 4141 1788 02F4      		brpl 1b
 4142 178a 00C0      		rjmp .L351
 4143               	.LVL299:
 4144               	.L271:
3511:switcherator.c ****                         if (weeklySeconds >= (startTime + daySeconds) &&
 4145               		.loc 1 3511 0
 4146 178c 480C      		add r4,r8
 4147 178e 591C      		adc r5,r9
 4148 1790 6A1C      		adc r6,r10
 4149 1792 7B1C      		adc r7,r11
 4150               	.LVL300:
 4151 1794 8415      		cp r24,r4
 4152 1796 9505      		cpc r25,r5
 4153 1798 A605      		cpc r26,r6
 4154 179a B705      		cpc r27,r7
 4155 179c 00F0      		brlo .L274
3512:switcherator.c ****                                 weeklySeconds <= (stopTime + daySeconds)) {
 4156               		.loc 1 3512 0 discriminator 1
 4157 179e 480D      		add r20,r8
 4158 17a0 591D      		adc r21,r9
 4159 17a2 6A1D      		adc r22,r10
 4160 17a4 7B1D      		adc r23,r11
 4161               	.LVL301:
3511:switcherator.c ****                         if (weeklySeconds >= (startTime + daySeconds) &&
 4162               		.loc 1 3511 0 discriminator 1
 4163 17a6 4817      		cp r20,r24
 4164 17a8 5907      		cpc r21,r25
 4165 17aa 6A07      		cpc r22,r26
 4166 17ac 7B07      		cpc r23,r27
 4167 17ae 00F0      		brlo .L274
3513:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
 4168               		.loc 1 3513 0
 4169 17b0 C601      		movw r24,r12
 4170 17b2 0090 0000 		lds r0,dow
 4171 17b6 00C0      		rjmp 2f
 4172               		1:
 4173 17b8 880F      		lsl r24
 4174 17ba 991F      		rol r25
 4175               		2:
 4176 17bc 0A94      		dec r0
 4177 17be 02F4      		brpl 1b
 4178               	.L351:
 4179 17c0 AA27      		clr r26
 4180 17c2 97FD      		sbrc r25,7
 4181 17c4 A095      		com r26
 4182 17c6 BA2F      		mov r27,r26
 4183 17c8 F701      		movw r30,r14
 4184 17ca 4085      		ldd r20,Z+8
 4185 17cc 5185      		ldd r21,Z+9
 4186 17ce 6285      		ldd r22,Z+10
 4187 17d0 7385      		ldd r23,Z+11
 4188 17d2 8423      		and r24,r20
 4189 17d4 9523      		and r25,r21
 4190 17d6 A623      		and r26,r22
 4191 17d8 B723      		and r27,r23
 4192 17da 892B      		or r24,r25
 4193 17dc 8A2B      		or r24,r26
 4194 17de 8B2B      		or r24,r27
 4195 17e0 01F0      		breq .L274
 4196               	.L347:
 4197               		.loc 1 3514 0
 4198 17e2 20E0      		ldi r18,0
 4199 17e4 30E0      		ldi r19,0
 4200 17e6 A901      		movw r20,r18
 4201 17e8 6B85      		ldd r22,Y+11
 4202 17ea 7C85      		ldd r23,Y+12
 4203 17ec C801      		movw r24,r16
 4204 17ee 0E94 0000 		call startTheProgram
 4205               	.LVL302:
 4206               	.L274:
 4207 17f2 FCE0      		ldi r31,12
 4208 17f4 EF0E      		add r14,r31
 4209 17f6 F11C      		adc r15,__zero_reg__
3491:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
 4210               		.loc 1 3491 0
 4211 17f8 20E0      		ldi r18,lo8(timeLimits+48)
 4212 17fa E216      		cp r14,r18
 4213 17fc 20E0      		ldi r18,hi8(timeLimits+48)
 4214 17fe F206      		cpc r15,r18
 4215 1800 01F0      		breq .+2
 4216 1802 00C0      		rjmp .L275
 4217 1804 00C0      		rjmp .L256
 4218               	.LVL303:
 4219               	.L257:
 4220               	.LBB20:
3515:switcherator.c ****                         }
3516:switcherator.c ****                     }
3517:switcherator.c ****                 } // end of the for
3518:switcherator.c ****             }
3519:switcherator.c ****         }
3520:switcherator.c **** 
3521:switcherator.c ****     } else {
3522:switcherator.c ****         // this is a digital input
3523:switcherator.c ****         // value of 255 (default) means nothing programmed
3524:switcherator.c ****         // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
3525:switcherator.c ****         // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG        
3526:switcherator.c ****         // figure out what we are dealing with and check it.
3527:switcherator.c ****         temp = outputNum;
 4221               		.loc 1 3527 0
 4222 1806 862F      		mov r24,r22
 4223 1808 90E0      		ldi r25,0
 4224 180a A0E0      		ldi r26,0
 4225 180c B0E0      		ldi r27,0
 4226               	.LVL304:
3528:switcherator.c ****         if (temp > 15 && temp < 32) {
 4227               		.loc 1 3528 0
 4228 180e AC01      		movw r20,r24
 4229 1810 BD01      		movw r22,r26
 4230               	.LVL305:
 4231 1812 4051      		subi r20,16
 4232 1814 5109      		sbc r21,__zero_reg__
 4233 1816 6109      		sbc r22,__zero_reg__
 4234 1818 7109      		sbc r23,__zero_reg__
 4235 181a 4031      		cpi r20,16
 4236 181c 5105      		cpc r21,__zero_reg__
 4237 181e 6105      		cpc r22,__zero_reg__
 4238 1820 7105      		cpc r23,__zero_reg__
 4239 1822 00F4      		brsh .L276
 4240               	.LVL306:
3529:switcherator.c ****             thisPin = &PINB;
3530:switcherator.c ****             temp -= 16;
 4241               		.loc 1 3530 0
 4242 1824 CB01      		movw r24,r22
 4243 1826 BA01      		movw r22,r20
 4244               	.LVL307:
3529:switcherator.c ****             thisPin = &PINB;
 4245               		.loc 1 3529 0
 4246 1828 B3E2      		ldi r27,lo8(35)
 4247 182a CB2E      		mov r12,r27
 4248 182c D12C      		mov r13,__zero_reg__
 4249 182e 00C0      		rjmp .L277
 4250               	.LVL308:
 4251               	.L276:
3531:switcherator.c **** #ifdef PINA
3532:switcherator.c ****         } else if (temp < 16) {
3533:switcherator.c ****             thisPin = &PINA;
3534:switcherator.c ****             temp -= 0;
3535:switcherator.c **** #endif
3536:switcherator.c **** #ifdef PINC
3537:switcherator.c ****         } else if (temp < 48) {
 4252               		.loc 1 3537 0
 4253 1830 8033      		cpi r24,48
 4254 1832 9105      		cpc r25,__zero_reg__
 4255 1834 A105      		cpc r26,__zero_reg__
 4256 1836 B105      		cpc r27,__zero_reg__
 4257 1838 04F4      		brge .L278
 4258               	.LVL309:
3538:switcherator.c ****             thisPin = &PINC;
3539:switcherator.c ****             temp -= 32;
 4259               		.loc 1 3539 0
 4260 183a BC01      		movw r22,r24
 4261 183c CD01      		movw r24,r26
 4262               	.LVL310:
 4263 183e 6052      		subi r22,32
 4264 1840 7109      		sbc r23,__zero_reg__
 4265 1842 8109      		sbc r24,__zero_reg__
 4266 1844 9109      		sbc r25,__zero_reg__
 4267               	.LVL311:
3538:switcherator.c ****             thisPin = &PINC;
 4268               		.loc 1 3538 0
 4269 1846 A6E2      		ldi r26,lo8(38)
 4270 1848 CA2E      		mov r12,r26
 4271 184a D12C      		mov r13,__zero_reg__
 4272 184c 00C0      		rjmp .L277
 4273               	.LVL312:
 4274               	.L278:
3540:switcherator.c **** #endif
3541:switcherator.c **** #ifdef PIND
3542:switcherator.c ****         } else if (temp < 64) {
 4275               		.loc 1 3542 0
 4276 184e 8034      		cpi r24,64
 4277 1850 9105      		cpc r25,__zero_reg__
 4278 1852 A105      		cpc r26,__zero_reg__
 4279 1854 B105      		cpc r27,__zero_reg__
 4280 1856 04F0      		brlt .+2
 4281 1858 00C0      		rjmp .L256
 4282               	.LVL313:
3543:switcherator.c ****             thisPin = &PIND;
3544:switcherator.c ****             temp -= 48;
 4283               		.loc 1 3544 0
 4284 185a BC01      		movw r22,r24
 4285 185c CD01      		movw r24,r26
 4286               	.LVL314:
 4287 185e 6053      		subi r22,48
 4288 1860 7109      		sbc r23,__zero_reg__
 4289 1862 8109      		sbc r24,__zero_reg__
 4290 1864 9109      		sbc r25,__zero_reg__
 4291               	.LVL315:
3543:switcherator.c ****             thisPin = &PIND;
 4292               		.loc 1 3543 0
 4293 1866 F9E2      		ldi r31,lo8(41)
 4294 1868 CF2E      		mov r12,r31
 4295 186a D12C      		mov r13,__zero_reg__
 4296               	.LVL316:
 4297               	.L277:
3545:switcherator.c **** #endif
3546:switcherator.c **** #ifdef PINE
3547:switcherator.c ****         } else if (temp < 80) {
3548:switcherator.c ****             thisPin = &PINE;
3549:switcherator.c ****             temp -= 64;
3550:switcherator.c **** #endif
3551:switcherator.c **** #ifdef PINF
3552:switcherator.c ****         } else if (temp < 96) {
3553:switcherator.c ****             thisPin = &PINF;
3554:switcherator.c ****             temp -= 80;
3555:switcherator.c **** #endif
3556:switcherator.c **** #ifdef PING
3557:switcherator.c ****         } else if (temp < 112) {
3558:switcherator.c ****             thisPin = &PING;
3559:switcherator.c ****             temp -= 96;
3560:switcherator.c **** #endif
3561:switcherator.c **** #ifdef PINH
3562:switcherator.c ****         } else if (temp < 128) {
3563:switcherator.c ****             thisPin = &PINH;
3564:switcherator.c ****             temp -= 112;
3565:switcherator.c **** #endif
3566:switcherator.c **** #ifdef PINI
3567:switcherator.c ****         } else if (temp < 144) {
3568:switcherator.c ****             thisPin = &PINI;
3569:switcherator.c ****             temp -= 128;
3570:switcherator.c **** #endif
3571:switcherator.c ****         } else {
3572:switcherator.c ****             // something went wrong.  Who cares.
3573:switcherator.c ****             return;
3574:switcherator.c ****         }
3575:switcherator.c ****         // if we want the input to be high then low = 0.  If we want it to be 
3576:switcherator.c ****         // low to be on then low = 255;
3577:switcherator.c ****         temp = temp / 2;
 4298               		.loc 1 3577 0
 4299 186c 22E0      		ldi r18,lo8(2)
 4300 186e 30E0      		ldi r19,0
 4301 1870 40E0      		ldi r20,0
 4302 1872 50E0      		ldi r21,0
 4303 1874 0E94 0000 		call __divmodsi4
 4304               	.LVL317:
3578:switcherator.c ****         if (temp > 7) {
 4305               		.loc 1 3578 0
 4306 1878 2830      		cpi r18,8
 4307 187a 3105      		cpc r19,__zero_reg__
 4308 187c 4105      		cpc r20,__zero_reg__
 4309 187e 5105      		cpc r21,__zero_reg__
 4310 1880 04F0      		brlt .+2
 4311 1882 00C0      		rjmp .L256
3579:switcherator.c ****             return; // something wrong again
3580:switcherator.c ****         }
3581:switcherator.c ****         int pinsOn = *thisPin;
 4312               		.loc 1 3581 0
 4313 1884 D601      		movw r26,r12
 4314 1886 8C91      		ld r24,X
 4315               	.LVL318:
 4316 1888 90E0      		ldi r25,0
3582:switcherator.c ****         char yeaOurInputIsOn = 0;
3583:switcherator.c ****         if (pinsOn & (1 << temp)) {
 4317               		.loc 1 3583 0
 4318 188a 00C0      		rjmp 2f
 4319               		1:
 4320 188c 9595      		asr r25
 4321 188e 8795      		ror r24
 4322               		2:
 4323 1890 2A95      		dec r18
 4324 1892 02F4      		brpl 1b
 4325               	.LVL319:
 4326 1894 80FF      		sbrs r24,0
 4327 1896 00C0      		rjmp .L279
3584:switcherator.c ****             // pin is high
3585:switcherator.c ****             if (low == 0)
 4328               		.loc 1 3585 0
 4329 1898 EF28      		or r14,r15
 4330 189a 01F4      		brne .+2
 4331 189c 00C0      		rjmp .L280
 4332 189e 00C0      		rjmp .L256
 4333               	.L279:
3586:switcherator.c ****                 yeaOurInputIsOn = 1;
3587:switcherator.c ****         } else {
3588:switcherator.c ****             // pin is low
3589:switcherator.c ****             if (low == 255)
 4334               		.loc 1 3589 0
 4335 18a0 BFEF      		ldi r27,-1
 4336 18a2 EB16      		cp r14,r27
 4337 18a4 F104      		cpc r15,__zero_reg__
 4338 18a6 01F0      		breq .+2
 4339 18a8 00C0      		rjmp .L256
 4340 18aa 00C0      		rjmp .L280
 4341               	.LVL320:
 4342               	.L293:
3590:switcherator.c ****                 yeaOurInputIsOn = 1;
3591:switcherator.c ****         }
3592:switcherator.c ****         if (yeaOurInputIsOn == 1) {
3593:switcherator.c ****             if (switchNumber < 128) { // this is a switch
3594:switcherator.c ****                 if (switchStatus[switchNumber] == 0) // the switch is off
 4343               		.loc 1 3594 0
 4344 18ac 000F      		lsl r16
 4345 18ae 111F      		rol r17
 4346 18b0 000F      		lsl r16
 4347 18b2 111F      		rol r17
 4348               	.LVL321:
 4349 18b4 F801      		movw r30,r16
 4350 18b6 E050      		subi r30,lo8(-(switchStatus))
 4351 18b8 F040      		sbci r31,hi8(-(switchStatus))
 4352 18ba 4081      		ld r20,Z
 4353 18bc 5181      		ldd r21,Z+1
 4354 18be 6281      		ldd r22,Z+2
 4355 18c0 7381      		ldd r23,Z+3
 4356 18c2 4115      		cp r20,__zero_reg__
 4357 18c4 5105      		cpc r21,__zero_reg__
 4358 18c6 6105      		cpc r22,__zero_reg__
 4359 18c8 7105      		cpc r23,__zero_reg__
 4360 18ca 01F4      		brne .L281
3595:switcherator.c ****                     switchChanged = 1;
 4361               		.loc 1 3595 0
 4362 18cc 81E0      		ldi r24,lo8(1)
 4363 18ce 8093 0000 		sts switchChanged,r24
 4364               	.L281:
3596:switcherator.c ****                 if ((switchStatus[switchNumber]) < (weeklySeconds + duration))
 4365               		.loc 1 3596 0
 4366 18d2 8091 0000 		lds r24,weeklySeconds
 4367 18d6 9091 0000 		lds r25,weeklySeconds+1
 4368 18da A091 0000 		lds r26,weeklySeconds+2
 4369 18de B091 0000 		lds r27,weeklySeconds+3
 4370 18e2 EB85      		ldd r30,Y+11
 4371 18e4 FC85      		ldd r31,Y+12
 4372 18e6 8E0F      		add r24,r30
 4373 18e8 9F1F      		adc r25,r31
 4374 18ea A11D      		adc r26,__zero_reg__
 4375 18ec B11D      		adc r27,__zero_reg__
 4376 18ee 4817      		cp r20,r24
 4377 18f0 5907      		cpc r21,r25
 4378 18f2 6A07      		cpc r22,r26
 4379 18f4 7B07      		cpc r23,r27
 4380 18f6 00F0      		brlo .+2
 4381 18f8 00C0      		rjmp .L256
3597:switcherator.c ****                     switchStatus[switchNumber] = (weeklySeconds + duration);
 4382               		.loc 1 3597 0
 4383 18fa F801      		movw r30,r16
 4384 18fc E050      		subi r30,lo8(-(switchStatus))
 4385 18fe F040      		sbci r31,hi8(-(switchStatus))
 4386 1900 8083      		st Z,r24
 4387 1902 9183      		std Z+1,r25
 4388 1904 A283      		std Z+2,r26
 4389 1906 B383      		std Z+3,r27
 4390 1908 00C0      		rjmp .L256
 4391               	.LVL322:
 4392               	.L283:
3598:switcherator.c ****             } else { // its a program;
3599:switcherator.c ****                 test = 0;
3600:switcherator.c ****                 // check and make sure we are within the time limits (eg dusk to dawn)
3601:switcherator.c ****                 // first if no time limits set up then ignore it
3602:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
3603:switcherator.c ****                     if (timeLimits[x][2] > 0)
 4393               		.loc 1 3603 0
 4394 190a 8081      		ld r24,Z
 4395 190c 9181      		ldd r25,Z+1
 4396 190e A281      		ldd r26,Z+2
 4397 1910 B381      		ldd r27,Z+3
 4398 1912 892B      		or r24,r25
 4399 1914 8A2B      		or r24,r26
 4400 1916 8B2B      		or r24,r27
 4401 1918 01F0      		breq .L282
3604:switcherator.c ****                         test = 1;
 4402               		.loc 1 3604 0
 4403 191a 21E0      		ldi r18,lo8(1)
 4404               	.L282:
 4405               	.LVL323:
 4406 191c 3C96      		adiw r30,12
3602:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
 4407               		.loc 1 3602 0
 4408 191e 30E0      		ldi r19,hi8(timeLimits+56)
 4409 1920 E030      		cpi r30,lo8(timeLimits+56)
 4410 1922 F307      		cpc r31,r19
 4411 1924 01F4      		brne .L283
3605:switcherator.c ****                 }
3606:switcherator.c ****                 // no limits set up
3607:switcherator.c ****                 if (test == 0)
 4412               		.loc 1 3607 0
 4413 1926 2111      		cpse r18,__zero_reg__
 4414 1928 00C0      		rjmp .L284
3608:switcherator.c ****                     startTheProgram((switchNumber - 128), duration, 0);
 4415               		.loc 1 3608 0
 4416 192a 20E0      		ldi r18,0
 4417 192c 30E0      		ldi r19,0
 4418 192e A901      		movw r20,r18
 4419               	.LVL324:
 4420 1930 6B85      		ldd r22,Y+11
 4421 1932 7C85      		ldd r23,Y+12
 4422 1934 C801      		movw r24,r16
 4423 1936 8058      		subi r24,-128
 4424 1938 9109      		sbc r25,__zero_reg__
 4425 193a 0E94 0000 		call startTheProgram
 4426               	.LVL325:
 4427               	.L284:
3609:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
3610:switcherator.c ****                     startTime = timeLimits[x][0];
3611:switcherator.c ****                     stopTime = timeLimits[x][1];
3612:switcherator.c ****                     // deal with nights that cross midnight
3613:switcherator.c ****                     if (stopTime < startTime) {
3614:switcherator.c ****                         temp = dow;
3615:switcherator.c ****                         // weekly seconds resets at the end of the week. so do lots of 9
3616:switcherator.c ****                         if (weeklySeconds <= (stopTime + daySeconds)) {
3617:switcherator.c ****                             // k this is dow + 1
3618:switcherator.c ****                             if (temp == 0)
3619:switcherator.c ****                                 temp = 6;
3620:switcherator.c ****                             else
3621:switcherator.c ****                                 temp--;
 4428               		.loc 1 3621 0 discriminator 1
 4429 193e D301      		movw r26,r6
 4430 1940 C201      		movw r24,r4
 4431 1942 0197      		sbiw r24,1
 4432 1944 A109      		sbc r26,__zero_reg__
 4433 1946 B109      		sbc r27,__zero_reg__
3622:switcherator.c ****                             if (timeLimits[x][2] & (1 << temp))
 4434               		.loc 1 3622 0 discriminator 1
 4435 1948 4528      		or r4,r5
 4436 194a 4628      		or r4,r6
 4437 194c 4728      		or r4,r7
 4438 194e 01F4      		brne .L285
 4439 1950 76E0      		ldi r23,lo8(6)
 4440 1952 472E      		mov r4,r23
 4441 1954 512C      		mov r5,__zero_reg__
 4442 1956 612C      		mov r6,__zero_reg__
 4443 1958 712C      		mov r7,__zero_reg__
 4444 195a 00C0      		rjmp .L286
 4445               	.L285:
 4446 195c 2C01      		movw r4,r24
 4447 195e 3D01      		movw r6,r26
 4448               	.L286:
 4449 1960 81E0      		ldi r24,lo8(1)
 4450 1962 90E0      		ldi r25,0
 4451 1964 AC01      		movw r20,r24
 4452 1966 00C0      		rjmp 2f
 4453               		1:
 4454 1968 440F      		lsl r20
 4455 196a 551F      		rol r21
 4456               		2:
 4457 196c 4A94      		dec r4
 4458 196e 02F4      		brpl 1b
 4459 1970 9A01      		movw r18,r20
 4460 1972 4427      		clr r20
 4461 1974 37FD      		sbrc r19,7
 4462 1976 4095      		com r20
 4463 1978 542F      		mov r21,r20
 4464 197a 2983      		std Y+1,r18
 4465 197c 3A83      		std Y+2,r19
 4466 197e 4B83      		std Y+3,r20
 4467 1980 5C83      		std Y+4,r21
3623:switcherator.c ****                                 startTheProgram((switchNumber - 128), duration, 0);
3624:switcherator.c ****                         } else if (weeklySeconds >= (startTime + daySeconds)) {
3625:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
 4468               		.loc 1 3625 0 discriminator 1
 4469 1982 2C01      		movw r4,r24
 4470 1984 00C0      		rjmp 2f
 4471               		1:
 4472 1986 440C      		lsl r4
 4473 1988 551C      		rol r5
 4474               		2:
 4475 198a 2A94      		dec r2
 4476 198c 02F4      		brpl 1b
 4477 198e 6624      		clr r6
 4478 1990 57FC      		sbrc r5,7
 4479 1992 6094      		com r6
 4480 1994 762C      		mov r7,r6
 4481 1996 60E0      		ldi r22,lo8(timeLimits)
 4482 1998 E62E      		mov r14,r22
 4483 199a 60E0      		ldi r22,hi8(timeLimits)
 4484 199c F62E      		mov r15,r22
 4485               	.LVL326:
3626:switcherator.c ****                                 startTheProgram((switchNumber - 128), duration, 0);
3627:switcherator.c ****                         }
3628:switcherator.c ****                     } else {
3629:switcherator.c ****                         if (weeklySeconds >= (startTime + daySeconds) &&
3630:switcherator.c ****                                 weeklySeconds <= (stopTime + daySeconds)) {
3631:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
3632:switcherator.c ****                                 startTheProgram((switchNumber - 128), duration, 0);
 4486               		.loc 1 3632 0 discriminator 1
 4487 199e 6801      		movw r12,r16
 4488               	.LVL327:
 4489 19a0 30E8      		ldi r19,-128
 4490 19a2 C31A      		sub r12,r19
 4491 19a4 D108      		sbc r13,__zero_reg__
 4492               	.LVL328:
 4493               	.L290:
3610:switcherator.c ****                     startTime = timeLimits[x][0];
 4494               		.loc 1 3610 0
 4495 19a6 D701      		movw r26,r14
 4496 19a8 8D91      		ld r24,X+
 4497 19aa 9D91      		ld r25,X+
 4498 19ac 0D90      		ld __tmp_reg__,X+
 4499 19ae BC91      		ld r27,X
 4500 19b0 A02D      		mov r26,__tmp_reg__
 4501 19b2 8D83      		std Y+5,r24
 4502 19b4 9E83      		std Y+6,r25
 4503 19b6 AF83      		std Y+7,r26
 4504 19b8 B887      		std Y+8,r27
 4505               	.LVL329:
3611:switcherator.c ****                     stopTime = timeLimits[x][1];
 4506               		.loc 1 3611 0
 4507 19ba F701      		movw r30,r14
 4508 19bc 4481      		ldd r20,Z+4
 4509 19be 5581      		ldd r21,Z+5
 4510 19c0 6681      		ldd r22,Z+6
 4511 19c2 7781      		ldd r23,Z+7
 4512               	.LVL330:
 4513 19c4 8091 0000 		lds r24,weeklySeconds
 4514 19c8 9091 0000 		lds r25,weeklySeconds+1
 4515 19cc A091 0000 		lds r26,weeklySeconds+2
 4516 19d0 B091 0000 		lds r27,weeklySeconds+3
 4517               	.LVL331:
3613:switcherator.c ****                     if (stopTime < startTime) {
 4518               		.loc 1 3613 0
 4519 19d4 0D81      		ldd r16,Y+5
 4520 19d6 1E81      		ldd r17,Y+6
 4521 19d8 2F81      		ldd r18,Y+7
 4522 19da 3885      		ldd r19,Y+8
 4523 19dc 4017      		cp r20,r16
 4524 19de 5107      		cpc r21,r17
 4525 19e0 6207      		cpc r22,r18
 4526 19e2 7307      		cpc r23,r19
 4527 19e4 04F4      		brge .L287
3616:switcherator.c ****                         if (weeklySeconds <= (stopTime + daySeconds)) {
 4528               		.loc 1 3616 0
 4529 19e6 480D      		add r20,r8
 4530 19e8 591D      		adc r21,r9
 4531 19ea 6A1D      		adc r22,r10
 4532 19ec 7B1D      		adc r23,r11
 4533               	.LVL332:
 4534 19ee 4817      		cp r20,r24
 4535 19f0 5907      		cpc r21,r25
 4536 19f2 6A07      		cpc r22,r26
 4537 19f4 7B07      		cpc r23,r27
 4538 19f6 00F0      		brlo .L288
3622:switcherator.c ****                             if (timeLimits[x][2] & (1 << temp))
 4539               		.loc 1 3622 0
 4540 19f8 8085      		ldd r24,Z+8
 4541 19fa 9185      		ldd r25,Z+9
 4542 19fc A285      		ldd r26,Z+10
 4543 19fe B385      		ldd r27,Z+11
 4544 1a00 2981      		ldd r18,Y+1
 4545 1a02 3A81      		ldd r19,Y+2
 4546 1a04 4B81      		ldd r20,Y+3
 4547 1a06 5C81      		ldd r21,Y+4
 4548 1a08 8223      		and r24,r18
 4549 1a0a 9323      		and r25,r19
 4550 1a0c A423      		and r26,r20
 4551 1a0e B523      		and r27,r21
 4552 1a10 00C0      		rjmp .L354
 4553               	.L288:
3624:switcherator.c ****                         } else if (weeklySeconds >= (startTime + daySeconds)) {
 4554               		.loc 1 3624 0
 4555 1a12 4D81      		ldd r20,Y+5
 4556 1a14 5E81      		ldd r21,Y+6
 4557 1a16 6F81      		ldd r22,Y+7
 4558 1a18 7885      		ldd r23,Y+8
 4559 1a1a 480D      		add r20,r8
 4560 1a1c 591D      		adc r21,r9
 4561 1a1e 6A1D      		adc r22,r10
 4562 1a20 7B1D      		adc r23,r11
 4563 1a22 8417      		cp r24,r20
 4564 1a24 9507      		cpc r25,r21
 4565 1a26 A607      		cpc r26,r22
 4566 1a28 B707      		cpc r27,r23
 4567 1a2a 00F0      		brlo .L289
 4568 1a2c 00C0      		rjmp .L356
 4569               	.LVL333:
 4570               	.L287:
3629:switcherator.c ****                         if (weeklySeconds >= (startTime + daySeconds) &&
 4571               		.loc 1 3629 0
 4572 1a2e 0D81      		ldd r16,Y+5
 4573 1a30 1E81      		ldd r17,Y+6
 4574 1a32 2F81      		ldd r18,Y+7
 4575 1a34 3885      		ldd r19,Y+8
 4576 1a36 080D      		add r16,r8
 4577 1a38 191D      		adc r17,r9
 4578 1a3a 2A1D      		adc r18,r10
 4579 1a3c 3B1D      		adc r19,r11
 4580 1a3e 8017      		cp r24,r16
 4581 1a40 9107      		cpc r25,r17
 4582 1a42 A207      		cpc r26,r18
 4583 1a44 B307      		cpc r27,r19
 4584 1a46 00F0      		brlo .L289
3630:switcherator.c ****                                 weeklySeconds <= (stopTime + daySeconds)) {
 4585               		.loc 1 3630 0 discriminator 1
 4586 1a48 480D      		add r20,r8
 4587 1a4a 591D      		adc r21,r9
 4588 1a4c 6A1D      		adc r22,r10
 4589 1a4e 7B1D      		adc r23,r11
 4590               	.LVL334:
3629:switcherator.c ****                         if (weeklySeconds >= (startTime + daySeconds) &&
 4591               		.loc 1 3629 0 discriminator 1
 4592 1a50 4817      		cp r20,r24
 4593 1a52 5907      		cpc r21,r25
 4594 1a54 6A07      		cpc r22,r26
 4595 1a56 7B07      		cpc r23,r27
 4596 1a58 00F0      		brlo .L289
 4597               	.L356:
3631:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
 4598               		.loc 1 3631 0
 4599 1a5a F701      		movw r30,r14
 4600 1a5c 8085      		ldd r24,Z+8
 4601 1a5e 9185      		ldd r25,Z+9
 4602 1a60 A285      		ldd r26,Z+10
 4603 1a62 B385      		ldd r27,Z+11
 4604 1a64 8421      		and r24,r4
 4605 1a66 9521      		and r25,r5
 4606 1a68 A621      		and r26,r6
 4607 1a6a B721      		and r27,r7
 4608               	.L354:
 4609 1a6c 892B      		or r24,r25
 4610 1a6e 8A2B      		or r24,r26
 4611 1a70 8B2B      		or r24,r27
 4612 1a72 01F0      		breq .L289
 4613               		.loc 1 3632 0
 4614 1a74 20E0      		ldi r18,0
 4615 1a76 30E0      		ldi r19,0
 4616 1a78 A901      		movw r20,r18
 4617 1a7a 6B85      		ldd r22,Y+11
 4618 1a7c 7C85      		ldd r23,Y+12
 4619 1a7e C601      		movw r24,r12
 4620 1a80 0E94 0000 		call startTheProgram
 4621               	.LVL335:
 4622               	.L289:
 4623 1a84 FCE0      		ldi r31,12
 4624 1a86 EF0E      		add r14,r31
 4625 1a88 F11C      		adc r15,__zero_reg__
3609:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
 4626               		.loc 1 3609 0
 4627 1a8a 00E0      		ldi r16,lo8(timeLimits+48)
 4628 1a8c E016      		cp r14,r16
 4629 1a8e 00E0      		ldi r16,hi8(timeLimits+48)
 4630 1a90 F006      		cpc r15,r16
 4631 1a92 01F0      		breq .+2
 4632 1a94 00C0      		rjmp .L290
 4633 1a96 00C0      		rjmp .L256
 4634               	.LVL336:
 4635               	.L280:
3593:switcherator.c ****             if (switchNumber < 128) { // this is a switch
 4636               		.loc 1 3593 0
 4637 1a98 0038      		cpi r16,-128
 4638 1a9a 1105      		cpc r17,__zero_reg__
 4639 1a9c 00F4      		brsh .+2
 4640 1a9e 00C0      		rjmp .L293
 4641 1aa0 E0E0      		ldi r30,lo8(timeLimits+8)
 4642 1aa2 F0E0      		ldi r31,hi8(timeLimits+8)
3411:switcherator.c **** void getInput(int inputNumber) {
 4643               		.loc 1 3411 0
 4644 1aa4 20E0      		ldi r18,0
 4645               	.LVL337:
 4646 1aa6 00C0      		rjmp .L283
 4647               	.LVL338:
 4648               	.L256:
 4649               	/* epilogue start */
 4650               	.LBE20:
3633:switcherator.c ****                         }
3634:switcherator.c ****                     }
3635:switcherator.c ****                 } // end of the for
3636:switcherator.c ****             }
3637:switcherator.c ****         }
3638:switcherator.c ****     }
3639:switcherator.c **** }
 4651               		.loc 1 3639 0
 4652 1aa8 2C96      		adiw r28,12
 4653 1aaa 0FB6      		in __tmp_reg__,__SREG__
 4654 1aac F894      		cli
 4655 1aae DEBF      		out __SP_H__,r29
 4656 1ab0 0FBE      		out __SREG__,__tmp_reg__
 4657 1ab2 CDBF      		out __SP_L__,r28
 4658 1ab4 DF91      		pop r29
 4659 1ab6 CF91      		pop r28
 4660 1ab8 1F91      		pop r17
 4661 1aba 0F91      		pop r16
 4662 1abc FF90      		pop r15
 4663 1abe EF90      		pop r14
 4664 1ac0 DF90      		pop r13
 4665               	.LVL339:
 4666 1ac2 CF90      		pop r12
 4667 1ac4 BF90      		pop r11
 4668 1ac6 AF90      		pop r10
 4669 1ac8 9F90      		pop r9
 4670 1aca 8F90      		pop r8
 4671               	.LVL340:
 4672 1acc 7F90      		pop r7
 4673 1ace 6F90      		pop r6
 4674 1ad0 5F90      		pop r5
 4675 1ad2 4F90      		pop r4
 4676 1ad4 3F90      		pop r3
 4677 1ad6 2F90      		pop r2
 4678 1ad8 0895      		ret
 4679               	.LFE82:
 4681               	.global	inputTenthCheck
 4683               	inputTenthCheck:
 4684               	.LFB81:
3391:switcherator.c **** void inputTenthCheck(void) {
 4685               		.loc 1 3391 0
 4686 1ada 0F93      		push r16
 4687               	.LCFI106:
 4688 1adc 1F93      		push r17
 4689               	.LCFI107:
 4690 1ade CF93      		push r28
 4691               	.LCFI108:
 4692 1ae0 DF93      		push r29
 4693               	.LCFI109:
 4694               	/* prologue: function */
 4695               	/* frame size = 0 */
 4696               	/* stack size = 4 */
 4697               	.L__stack_usage = 4
 4698               	.LVL341:
 4699 1ae2 00E0      		ldi r16,lo8(inputs+6)
 4700 1ae4 10E0      		ldi r17,hi8(inputs+6)
3393:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 4701               		.loc 1 3393 0
 4702 1ae6 C0E0      		ldi r28,0
 4703 1ae8 D0E0      		ldi r29,0
 4704               	.LVL342:
 4705               	.L360:
3391:switcherator.c **** void inputTenthCheck(void) {
 4706               		.loc 1 3391 0
 4707 1aea F801      		movw r30,r16
 4708 1aec 3697      		sbiw r30,6
3395:switcherator.c ****         if (inputs[x][0] != 255 && inputs[x][6] == 0)
 4709               		.loc 1 3395 0
 4710 1aee 8081      		ld r24,Z
 4711 1af0 8F3F      		cpi r24,lo8(-1)
 4712 1af2 01F0      		breq .L359
3395:switcherator.c ****         if (inputs[x][0] != 255 && inputs[x][6] == 0)
 4713               		.loc 1 3395 0 is_stmt 0 discriminator 1
 4714 1af4 F801      		movw r30,r16
 4715 1af6 8081      		ld r24,Z
 4716 1af8 8111      		cpse r24,__zero_reg__
 4717 1afa 00C0      		rjmp .L359
3396:switcherator.c ****             getInput(x);
 4718               		.loc 1 3396 0 is_stmt 1
 4719 1afc CE01      		movw r24,r28
 4720 1afe 0E94 0000 		call getInput
 4721               	.LVL343:
 4722               	.L359:
3393:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 4723               		.loc 1 3393 0
 4724 1b02 2196      		adiw r28,1
 4725               	.LVL344:
 4726 1b04 085F      		subi r16,-8
 4727 1b06 1F4F      		sbci r17,-1
 4728 1b08 C430      		cpi r28,4
 4729 1b0a D105      		cpc r29,__zero_reg__
 4730 1b0c 01F4      		brne .L360
 4731               	/* epilogue start */
3398:switcherator.c **** }
 4732               		.loc 1 3398 0
 4733 1b0e DF91      		pop r29
 4734 1b10 CF91      		pop r28
 4735               	.LVL345:
 4736 1b12 1F91      		pop r17
 4737 1b14 0F91      		pop r16
 4738 1b16 0895      		ret
 4739               	.LFE81:
 4741               	.global	inputCheck
 4743               	inputCheck:
 4744               	.LFB80:
3370:switcherator.c **** void inputCheck(void) {
 4745               		.loc 1 3370 0
 4746 1b18 0F93      		push r16
 4747               	.LCFI110:
 4748 1b1a 1F93      		push r17
 4749               	.LCFI111:
 4750 1b1c CF93      		push r28
 4751               	.LCFI112:
 4752 1b1e DF93      		push r29
 4753               	.LCFI113:
 4754               	/* prologue: function */
 4755               	/* frame size = 0 */
 4756               	/* stack size = 4 */
 4757               	.L__stack_usage = 4
 4758               	.LVL346:
 4759 1b20 00E0      		ldi r16,lo8(inputs+6)
 4760 1b22 10E0      		ldi r17,hi8(inputs+6)
3374:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 4761               		.loc 1 3374 0
 4762 1b24 C0E0      		ldi r28,0
 4763 1b26 D0E0      		ldi r29,0
 4764               	.LVL347:
 4765               	.L368:
3370:switcherator.c **** void inputCheck(void) {
 4766               		.loc 1 3370 0
 4767 1b28 F801      		movw r30,r16
 4768 1b2a 3697      		sbiw r30,6
3376:switcherator.c ****         if (inputs[x][0] == 255)
 4769               		.loc 1 3376 0
 4770 1b2c 8081      		ld r24,Z
 4771 1b2e 8F3F      		cpi r24,lo8(-1)
 4772 1b30 01F0      		breq .L366
3378:switcherator.c ****         pollTime = inputs[x][6];
 4773               		.loc 1 3378 0
 4774 1b32 F801      		movw r30,r16
 4775 1b34 2081      		ld r18,Z
 4776               	.LVL348:
3380:switcherator.c ****         if (pollTime == 0 || pollTime == 1) {
 4777               		.loc 1 3380 0
 4778 1b36 2230      		cpi r18,lo8(2)
 4779 1b38 00F4      		brsh .L367
 4780 1b3a 00C0      		rjmp .L373
 4781               	.L367:
3383:switcherator.c ****         } else if (weeklySeconds % pollTime == 0) {
 4782               		.loc 1 3383 0
 4783 1b3c 30E0      		ldi r19,0
 4784 1b3e 40E0      		ldi r20,0
 4785 1b40 50E0      		ldi r21,0
 4786 1b42 6091 0000 		lds r22,weeklySeconds
 4787 1b46 7091 0000 		lds r23,weeklySeconds+1
 4788 1b4a 8091 0000 		lds r24,weeklySeconds+2
 4789 1b4e 9091 0000 		lds r25,weeklySeconds+3
 4790 1b52 0E94 0000 		call __udivmodsi4
 4791               	.LVL349:
 4792 1b56 672B      		or r22,r23
 4793 1b58 682B      		or r22,r24
 4794 1b5a 692B      		or r22,r25
 4795 1b5c 01F4      		brne .L366
 4796               	.L373:
3384:switcherator.c ****             getInput(x);
 4797               		.loc 1 3384 0
 4798 1b5e CE01      		movw r24,r28
 4799 1b60 0E94 0000 		call getInput
 4800               	.LVL350:
 4801               	.L366:
3374:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 4802               		.loc 1 3374 0
 4803 1b64 2196      		adiw r28,1
 4804               	.LVL351:
 4805 1b66 085F      		subi r16,-8
 4806 1b68 1F4F      		sbci r17,-1
 4807 1b6a C430      		cpi r28,4
 4808 1b6c D105      		cpc r29,__zero_reg__
 4809 1b6e 01F4      		brne .L368
 4810               	/* epilogue start */
3387:switcherator.c **** }
 4811               		.loc 1 3387 0
 4812 1b70 DF91      		pop r29
 4813 1b72 CF91      		pop r28
 4814               	.LVL352:
 4815 1b74 1F91      		pop r17
 4816 1b76 0F91      		pop r16
 4817 1b78 0895      		ret
 4818               	.LFE80:
 4820               	.global	flashFail
 4822               	flashFail:
 4823               	.LFB84:
3640:switcherator.c **** 
3641:switcherator.c **** // clears an input
3642:switcherator.c **** // CI nn = input number
3643:switcherator.c **** 
3644:switcherator.c **** void clearInput(char * commandReceived) {
3645:switcherator.c ****     int inputNumber = 0;
3646:switcherator.c ****     volatile unsigned char *thisPort = 0;
3647:switcherator.c ****     tempIntString[0] = commandReceived[3];
3648:switcherator.c ****     tempIntString[1] = commandReceived[4];
3649:switcherator.c ****     inputNumber = atoi(tempIntString);
3650:switcherator.c ****     int temp = inputs[inputNumber][0];
3651:switcherator.c ****     if (temp > 15 && temp < 32) {
3652:switcherator.c ****         thisPort = &PINB;
3653:switcherator.c ****         temp -= 16;
3654:switcherator.c **** #ifdef PINA
3655:switcherator.c ****     } else if (temp < 16) {
3656:switcherator.c ****         thisPort = &PINA;
3657:switcherator.c ****         temp -= 0;
3658:switcherator.c **** #endif
3659:switcherator.c **** #ifdef PINC
3660:switcherator.c ****     } else if (temp < 48) {
3661:switcherator.c ****         thisPort = &PINC;
3662:switcherator.c ****         temp -= 32;
3663:switcherator.c **** #endif
3664:switcherator.c **** #ifdef PIND
3665:switcherator.c ****     } else if (temp < 64) {
3666:switcherator.c ****         thisPort = &PIND;
3667:switcherator.c ****         temp -= 48;
3668:switcherator.c **** #endif
3669:switcherator.c **** #ifdef PINE
3670:switcherator.c ****     } else if (temp < 80) {
3671:switcherator.c ****         thisPort = &PINE;
3672:switcherator.c ****         temp -= 64;
3673:switcherator.c **** #endif
3674:switcherator.c **** #ifdef PINF
3675:switcherator.c ****     } else if (temp < 96) {
3676:switcherator.c ****         thisPort = &PINF;
3677:switcherator.c ****         temp -= 80;
3678:switcherator.c **** #endif
3679:switcherator.c **** #ifdef PING
3680:switcherator.c ****     } else if (temp < 112) {
3681:switcherator.c ****         thisPort = &PING;
3682:switcherator.c ****         temp -= 96;
3683:switcherator.c **** #endif
3684:switcherator.c **** #ifdef PINH
3685:switcherator.c ****     } else if (temp < 128) {
3686:switcherator.c ****         thisPort = &PINH;
3687:switcherator.c ****         temp -= 112;
3688:switcherator.c **** #endif
3689:switcherator.c **** #ifdef PINI
3690:switcherator.c ****     } else if (temp < 144) {
3691:switcherator.c ****         thisPort = &PINI;
3692:switcherator.c ****         temp -= 128;
3693:switcherator.c **** #endif
3694:switcherator.c ****     } else {
3695:switcherator.c ****         ok();
3696:switcherator.c ****         return;
3697:switcherator.c ****     }
3698:switcherator.c ****     // zero out the port
3699:switcherator.c ****     *thisPort &= ~(1 << temp);
3700:switcherator.c ****     inputs[inputNumber][0] = 255;
3701:switcherator.c ****     ok();
3702:switcherator.c **** }
3703:switcherator.c **** 
3704:switcherator.c **** /****************************************************************
3705:switcherator.c ****  *
3706:switcherator.c ****  *              All Things Interrupt and on offish Related
3707:switcherator.c ****  *
3708:switcherator.c ****  ****************************************************************/
3709:switcherator.c **** 
3710:switcherator.c **** 
3711:switcherator.c **** // Flashes the indicator pin to determine problems
3712:switcherator.c **** 
3713:switcherator.c **** void flashFail(void) {
 4824               		.loc 1 3713 0
 4825               	/* prologue: function */
 4826               	/* frame size = 0 */
 4827               	/* stack size = 0 */
 4828               	.L__stack_usage = 0
3714:switcherator.c ****     failTimer++;
 4829               		.loc 1 3714 0
 4830 1b7a 8091 0000 		lds r24,failTimer
 4831 1b7e 8F5F      		subi r24,lo8(-(1))
 4832 1b80 8093 0000 		sts failTimer,r24
3715:switcherator.c ****     INDICATOR_DDR |= INDICATOR_PIN;
 4833               		.loc 1 3715 0
 4834 1b84 529A      		sbi 0xa,2
3716:switcherator.c ****     // different timings for different fails
3717:switcherator.c ****     if (failCondition == 1) {
 4835               		.loc 1 3717 0
 4836 1b86 9091 0000 		lds r25,failCondition
 4837 1b8a 9130      		cpi r25,lo8(1)
 4838 1b8c 01F4      		brne .L375
3718:switcherator.c ****         if (failTimer == 2) {
 4839               		.loc 1 3718 0
 4840 1b8e 8230      		cpi r24,lo8(2)
 4841 1b90 01F4      		brne .L376
 4842 1b92 00C0      		rjmp .L393
 4843               	.L376:
3719:switcherator.c ****             INDICATOR_PORT |= INDICATOR_PIN;
3720:switcherator.c ****         } else if (failTimer == 4) {
 4844               		.loc 1 3720 0
 4845 1b94 8430      		cpi r24,lo8(4)
 4846 1b96 01F4      		brne .L378
 4847 1b98 00C0      		rjmp .L391
 4848               	.L378:
3721:switcherator.c ****             INDICATOR_PORT &= ~(INDICATOR_PIN);
3722:switcherator.c ****         } else if (failTimer == 24)
 4849               		.loc 1 3722 0
 4850 1b9a 8831      		cpi r24,lo8(24)
 4851 1b9c 01F4      		brne .L374
 4852 1b9e 00C0      		rjmp .L392
 4853               	.L375:
3723:switcherator.c ****             failTimer = 0;
3724:switcherator.c ****     } else if (failCondition == 2) {
 4854               		.loc 1 3724 0
 4855 1ba0 9230      		cpi r25,lo8(2)
 4856 1ba2 01F4      		brne .L379
3725:switcherator.c ****         if (failTimer == 2) {
 4857               		.loc 1 3725 0
 4858 1ba4 8230      		cpi r24,lo8(2)
 4859 1ba6 01F4      		brne .L380
 4860 1ba8 00C0      		rjmp .L393
 4861               	.L380:
3726:switcherator.c ****             INDICATOR_PORT |= INDICATOR_PIN;
3727:switcherator.c ****         } else if (failTimer == 4) {
 4862               		.loc 1 3727 0
 4863 1baa 8430      		cpi r24,lo8(4)
 4864 1bac 01F4      		brne .L381
 4865 1bae 00C0      		rjmp .L391
 4866               	.L381:
3728:switcherator.c ****             INDICATOR_PORT &= ~(INDICATOR_PIN);
3729:switcherator.c ****         } else if (failTimer == 8) {
 4867               		.loc 1 3729 0
 4868 1bb0 8830      		cpi r24,lo8(8)
 4869 1bb2 01F4      		brne .L382
 4870 1bb4 00C0      		rjmp .L393
 4871               	.L382:
3730:switcherator.c ****             INDICATOR_PORT |= INDICATOR_PIN;
3731:switcherator.c ****         } else if (failTimer == 10) {
 4872               		.loc 1 3731 0
 4873 1bb6 8A30      		cpi r24,lo8(10)
 4874 1bb8 01F4      		brne .L383
 4875 1bba 00C0      		rjmp .L391
 4876               	.L383:
3732:switcherator.c ****             INDICATOR_PORT &= ~(INDICATOR_PIN);
3733:switcherator.c ****         } else if (failTimer == 30)
 4877               		.loc 1 3733 0
 4878 1bbc 8E31      		cpi r24,lo8(30)
 4879 1bbe 01F4      		brne .L374
 4880 1bc0 00C0      		rjmp .L392
 4881               	.L379:
3734:switcherator.c ****             failTimer = 0;
3735:switcherator.c ****     } else if (failCondition == 3) {
 4882               		.loc 1 3735 0
 4883 1bc2 9330      		cpi r25,lo8(3)
 4884 1bc4 01F4      		brne .L374
3736:switcherator.c ****         if (failTimer == 2) {
 4885               		.loc 1 3736 0
 4886 1bc6 8230      		cpi r24,lo8(2)
 4887 1bc8 01F4      		brne .L384
 4888 1bca 00C0      		rjmp .L393
 4889               	.L384:
3737:switcherator.c ****             INDICATOR_PORT |= INDICATOR_PIN;
3738:switcherator.c ****         } else if (failTimer == 4) {
 4890               		.loc 1 3738 0
 4891 1bcc 8430      		cpi r24,lo8(4)
 4892 1bce 01F4      		brne .L385
 4893 1bd0 00C0      		rjmp .L391
 4894               	.L385:
3739:switcherator.c ****             INDICATOR_PORT &= ~(INDICATOR_PIN);
3740:switcherator.c ****         } else if (failTimer == 8) {
 4895               		.loc 1 3740 0
 4896 1bd2 8830      		cpi r24,lo8(8)
 4897 1bd4 01F4      		brne .L386
 4898 1bd6 00C0      		rjmp .L393
 4899               	.L386:
3741:switcherator.c ****             INDICATOR_PORT |= INDICATOR_PIN;
3742:switcherator.c ****         } else if (failTimer == 10) {
 4900               		.loc 1 3742 0
 4901 1bd8 8A30      		cpi r24,lo8(10)
 4902 1bda 01F4      		brne .L387
 4903 1bdc 00C0      		rjmp .L391
 4904               	.L387:
3743:switcherator.c ****             INDICATOR_PORT &= ~(INDICATOR_PIN);
3744:switcherator.c ****         } else if (failTimer == 14) {
 4905               		.loc 1 3744 0
 4906 1bde 8E30      		cpi r24,lo8(14)
 4907 1be0 01F4      		brne .L388
 4908               	.L393:
3745:switcherator.c ****             INDICATOR_PORT |= INDICATOR_PIN;
 4909               		.loc 1 3745 0
 4910 1be2 5A9A      		sbi 0xb,2
 4911 1be4 0895      		ret
 4912               	.L388:
3746:switcherator.c ****         } else if (failTimer == 16) {
 4913               		.loc 1 3746 0
 4914 1be6 8031      		cpi r24,lo8(16)
 4915 1be8 01F4      		brne .L389
 4916               	.L391:
3747:switcherator.c ****             INDICATOR_PORT &= ~(INDICATOR_PIN);
 4917               		.loc 1 3747 0
 4918 1bea 5A98      		cbi 0xb,2
 4919 1bec 0895      		ret
 4920               	.L389:
3748:switcherator.c ****         } else if (failTimer == 36)
 4921               		.loc 1 3748 0
 4922 1bee 8432      		cpi r24,lo8(36)
 4923 1bf0 01F4      		brne .L374
 4924               	.L392:
3749:switcherator.c ****             failTimer = 0;
 4925               		.loc 1 3749 0
 4926 1bf2 1092 0000 		sts failTimer,__zero_reg__
 4927               	.L374:
 4928 1bf6 0895      		ret
 4929               	.LFE84:
 4931               	.global	clearFail
 4933               	clearFail:
 4934               	.LFB85:
3750:switcherator.c ****     }
3751:switcherator.c **** }
3752:switcherator.c **** 
3753:switcherator.c **** // turns off the indicator pin
3754:switcherator.c **** void clearFail(void) {
 4935               		.loc 1 3754 0
 4936               	/* prologue: function */
 4937               	/* frame size = 0 */
 4938               	/* stack size = 0 */
 4939               	.L__stack_usage = 0
3755:switcherator.c ****     failTimer = 0;
 4940               		.loc 1 3755 0
 4941 1bf8 1092 0000 		sts failTimer,__zero_reg__
3756:switcherator.c ****     INDICATOR_PORT |= (INDICATOR_PIN);
 4942               		.loc 1 3756 0
 4943 1bfc 5A9A      		sbi 0xb,2
3757:switcherator.c ****     INDICATOR_DDR |= (INDICATOR_PIN);
 4944               		.loc 1 3757 0
 4945 1bfe 529A      		sbi 0xa,2
 4946 1c00 0895      		ret
 4947               	.LFE85:
 4949               	.global	sendMessage
 4951               	sendMessage:
 4952               	.LFB77:
3072:switcherator.c **** void sendMessage(char * myResponse) {
 4953               		.loc 1 3072 0
 4954               	.LVL353:
 4955 1c02 CF93      		push r28
 4956               	.LCFI114:
 4957 1c04 DF93      		push r29
 4958               	.LCFI115:
 4959 1c06 00D0      		rcall .
 4960               	.LCFI116:
 4961 1c08 CDB7      		in r28,__SP_L__
 4962 1c0a DEB7      		in r29,__SP_H__
 4963               	.LCFI117:
 4964               	/* prologue: function */
 4965               	/* frame size = 2 */
 4966               	/* stack size = 4 */
 4967               	.L__stack_usage = 4
3073:switcherator.c ****     stopRx();
 4968               		.loc 1 3073 0
 4969 1c0c 8983      		std Y+1,r24
 4970 1c0e 9A83      		std Y+2,r25
 4971 1c10 0E94 0000 		call stopRx
 4972               	.LVL354:
 4973               	.LBB21:
 4974               	.LBB22:
 4975               		.file 2 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h"
   1:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
   6:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
   9:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  12:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  17:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  21:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  33:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  35:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  38:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  41:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  42:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  46:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /** \file */
  47:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \code
  49:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \endcode
  53:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  54:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     used.
  58:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  59:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  68:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  77:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  81:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** */
  82:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  83:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  87:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  88:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  93:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  94:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  97:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  98:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
 103:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 104:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /**
 105:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 107:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 109:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 112:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 114:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 120:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 125:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 129:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 132:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 140:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****  */
 141:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** void
 142:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** {
 144:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 153:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 156:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 159:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#else
 160:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#endif
 163:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 164:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 165:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 166:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #else
 167:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	{
 172:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		{
 176:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		}
 180:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		return;
 181:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	}
 182:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	else
 183:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
 186:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** }
 187:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 188:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /**
 189:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 191:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 193:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 196:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 198:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 202:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   
 207:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 211:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****  
 214:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 222:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****  */
 223:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** void
 224:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** {
 226:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 235:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 238:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 241:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#else
 242:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		//round up by default
 243:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#endif
 245:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 246:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 4976               		.loc 2 246 0
 4977 1c14 AFE8      		ldi r26,lo8(399)
 4978 1c16 B1E0      		ldi r27,hi8(399)
 4979 1c18 1197      		1: sbiw r26,1
 4980 1c1a 01F4      		brne 1b
 4981 1c1c 00C0      		rjmp .
 4982 1c1e 0000      		nop
 4983               	.LBE22:
 4984               	.LBE21:
3075:switcherator.c ****     int transmitLength = strlen(myResponse);
 4985               		.loc 1 3075 0
 4986 1c20 8981      		ldd r24,Y+1
 4987 1c22 E82F      		mov r30,r24
 4988 1c24 9A81      		ldd r25,Y+2
 4989 1c26 F92F      		mov r31,r25
 4990 1c28 DF01      		movw r26,r30
 4991               		0:
 4992 1c2a 0D90      		ld __tmp_reg__,X+
 4993 1c2c 0020      		tst __tmp_reg__
 4994 1c2e 01F4      		brne 0b
 4995 1c30 BD01      		movw r22,r26
 4996 1c32 6150      		subi r22,1
 4997 1c34 7109      		sbc r23,__zero_reg__
 4998 1c36 6E1B      		sub r22,r30
 4999 1c38 7F0B      		sbc r23,r31
3076:switcherator.c ****     if(!transmit(myResponse, transmitLength)) {
 5000               		.loc 1 3076 0
 5001 1c3a 0E94 0000 		call transmit
 5002               	.LVL355:
 5003 1c3e 8111      		cpse r24,__zero_reg__
 5004 1c40 00C0      		rjmp .L396
3077:switcherator.c ****         failCondition = 2;
 5005               		.loc 1 3077 0
 5006 1c42 82E0      		ldi r24,lo8(2)
 5007 1c44 8093 0000 		sts failCondition,r24
 5008 1c48 00C0      		rjmp .L397
 5009               	.L396:
3079:switcherator.c ****         failCondition = 0;
 5010               		.loc 1 3079 0
 5011 1c4a 1092 0000 		sts failCondition,__zero_reg__
3080:switcherator.c ****         clearFail();
 5012               		.loc 1 3080 0
 5013 1c4e 0E94 0000 		call clearFail
 5014               	.LVL356:
 5015               	.L397:
 5016               	/* epilogue start */
3083:switcherator.c **** }
 5017               		.loc 1 3083 0
 5018 1c52 0F90      		pop __tmp_reg__
 5019 1c54 0F90      		pop __tmp_reg__
 5020 1c56 DF91      		pop r29
 5021 1c58 CF91      		pop r28
3082:switcherator.c ****     startRx();
 5022               		.loc 1 3082 0
 5023 1c5a 0C94 0000 		jmp startRx
 5024               	.LVL357:
 5025               	.LFE77:
 5027               		.section	.rodata.str1.1
 5028               	.LC8:
 5029 000b 7230 2030 		.string	"r0 0x"
 5029      7800 
 5030               	.LC9:
 5031 0011 7231 2030 		.string	"r1 0x"
 5031      7800 
 5032               	.LC10:
 5033 0017 7232 2030 		.string	"r2 0x"
 5033      7800 
 5034               	.LC11:
 5035 001d 7233 2030 		.string	"r3 0x"
 5035      7800 
 5036               	.LC12:
 5037 0023 7234 2030 		.string	"r4 0x"
 5037      7800 
 5038               	.LC13:
 5039 0029 7235 2030 		.string	"r5 0x"
 5039      7800 
 5040               	.LC14:
 5041 002f 7420 3078 		.string	"t 0x"
 5041      00
 5042               	.LC6:
 5043 0034 3078 3030 		.string	"0x00"
 5043      00
 5044               	.LC7:
 5045 0039 3030 3030 		.string	"00000"
 5045      3000 
 5046               		.text
 5047               	.global	radioChangeAddress
 5049               	radioChangeAddress:
 5050               	.LFB75:
2996:switcherator.c **** void radioChangeAddress(char * commandReceived) {
 5051               		.loc 1 2996 0
 5052               	.LVL358:
 5053 1c5e 2F92      		push r2
 5054               	.LCFI118:
 5055 1c60 3F92      		push r3
 5056               	.LCFI119:
 5057 1c62 4F92      		push r4
 5058               	.LCFI120:
 5059 1c64 5F92      		push r5
 5060               	.LCFI121:
 5061 1c66 6F92      		push r6
 5062               	.LCFI122:
 5063 1c68 7F92      		push r7
 5064               	.LCFI123:
 5065 1c6a 8F92      		push r8
 5066               	.LCFI124:
 5067 1c6c 9F92      		push r9
 5068               	.LCFI125:
 5069 1c6e AF92      		push r10
 5070               	.LCFI126:
 5071 1c70 BF92      		push r11
 5072               	.LCFI127:
 5073 1c72 CF92      		push r12
 5074               	.LCFI128:
 5075 1c74 DF92      		push r13
 5076               	.LCFI129:
 5077 1c76 EF92      		push r14
 5078               	.LCFI130:
 5079 1c78 FF92      		push r15
 5080               	.LCFI131:
 5081 1c7a 0F93      		push r16
 5082               	.LCFI132:
 5083 1c7c 1F93      		push r17
 5084               	.LCFI133:
 5085 1c7e CF93      		push r28
 5086               	.LCFI134:
 5087 1c80 DF93      		push r29
 5088               	.LCFI135:
 5089 1c82 CDB7      		in r28,__SP_L__
 5090 1c84 DEB7      		in r29,__SP_H__
 5091               	.LCFI136:
 5092 1c86 2B97      		sbiw r28,11
 5093               	.LCFI137:
 5094 1c88 0FB6      		in __tmp_reg__,__SREG__
 5095 1c8a F894      		cli
 5096 1c8c DEBF      		out __SP_H__,r29
 5097 1c8e 0FBE      		out __SREG__,__tmp_reg__
 5098 1c90 CDBF      		out __SP_L__,r28
 5099               	/* prologue: function */
 5100               	/* frame size = 11 */
 5101               	/* stack size = 29 */
 5102               	.L__stack_usage = 29
 5103 1c92 5C01      		movw r10,r24
 5104               	.LVL359:
2998:switcherator.c ****     statusMsg[0] = 0;
 5105               		.loc 1 2998 0
 5106 1c94 1092 0000 		sts statusMsg,__zero_reg__
 5107               	.LVL360:
3001:switcherator.c ****     char tempString[] = "0x00";
 5108               		.loc 1 3001 0
 5109 1c98 85E0      		ldi r24,lo8(5)
 5110               	.LVL361:
 5111 1c9a E0E0      		ldi r30,lo8(.LC6)
 5112 1c9c F0E0      		ldi r31,hi8(.LC6)
 5113 1c9e DE01      		movw r26,r28
 5114 1ca0 1796      		adiw r26,7
 5115               		0:
 5116 1ca2 0190      		ld r0,Z+
 5117 1ca4 0D92      		st X+,r0
 5118 1ca6 8A95      		dec r24
 5119 1ca8 01F4      		brne 0b
3002:switcherator.c ****     char tempRadioString[] = "00000";
 5120               		.loc 1 3002 0
 5121 1caa 86E0      		ldi r24,lo8(6)
 5122 1cac E0E0      		ldi r30,lo8(.LC7)
 5123 1cae F0E0      		ldi r31,hi8(.LC7)
 5124 1cb0 DE01      		movw r26,r28
 5125 1cb2 1196      		adiw r26,1
 5126               		0:
 5127 1cb4 0190      		ld r0,Z+
 5128 1cb6 0D92      		st X+,r0
 5129 1cb8 8A95      		dec r24
 5130 1cba 01F4      		brne 0b
2996:switcherator.c **** void radioChangeAddress(char * commandReceived) {
 5131               		.loc 1 2996 0
 5132 1cbc 6501      		movw r12,r10
 5133 1cbe 88E0      		ldi r24,8
 5134 1cc0 C80E      		add r12,r24
 5135 1cc2 D11C      		adc r13,__zero_reg__
3000:switcherator.c ****     uint64_t newAddress = 0;
 5136               		.loc 1 3000 0
 5137 1cc4 212C      		mov r2,__zero_reg__
 5138 1cc6 312C      		mov r3,__zero_reg__
 5139 1cc8 412C      		mov r4,__zero_reg__
 5140 1cca 512C      		mov r5,__zero_reg__
 5141 1ccc 612C      		mov r6,__zero_reg__
 5142 1cce 712C      		mov r7,__zero_reg__
 5143 1cd0 812C      		mov r8,__zero_reg__
 5144 1cd2 912C      		mov r9,__zero_reg__
3003:switcherator.c ****     for (x = 0; x < 5; x++) {
 5145               		.loc 1 3003 0
 5146 1cd4 E12C      		mov r14,__zero_reg__
 5147 1cd6 F12C      		mov r15,__zero_reg__
 5148               	.LVL362:
 5149               	.L400:
2996:switcherator.c **** void radioChangeAddress(char * commandReceived) {
 5150               		.loc 1 2996 0
 5151 1cd8 F601      		movw r30,r12
 5152 1cda 3197      		sbiw r30,1
3004:switcherator.c ****         tempString[2] = commandReceived[((x * 2) + 7)];
 5153               		.loc 1 3004 0
 5154 1cdc 8081      		ld r24,Z
 5155 1cde 8987      		std Y+9,r24
3005:switcherator.c ****         tempString[3] = commandReceived[((x * 2) + 8)];
 5156               		.loc 1 3005 0
 5157 1ce0 F601      		movw r30,r12
 5158 1ce2 8081      		ld r24,Z
 5159 1ce4 8A87      		std Y+10,r24
3006:switcherator.c ****         tempInt = strtol(tempString, 0, 0);
 5160               		.loc 1 3006 0
 5161 1ce6 40E0      		ldi r20,0
 5162 1ce8 50E0      		ldi r21,0
 5163 1cea 60E0      		ldi r22,0
 5164 1cec 70E0      		ldi r23,0
 5165 1cee CE01      		movw r24,r28
 5166 1cf0 0796      		adiw r24,7
 5167 1cf2 0E94 0000 		call strtol
 5168               	.LVL363:
3007:switcherator.c ****         newAddress |= tempInt;
 5169               		.loc 1 3007 0
 5170 1cf6 872F      		mov r24,r23
 5171 1cf8 880F      		lsl r24
 5172 1cfa 880B      		sbc r24,r24
 5173 1cfc 262A      		or r2,r22
 5174 1cfe 372A      		or r3,r23
 5175 1d00 482A      		or r4,r24
 5176 1d02 582A      		or r5,r24
 5177 1d04 682A      		or r6,r24
 5178 1d06 782A      		or r7,r24
 5179 1d08 882A      		or r8,r24
 5180 1d0a 982A      		or r9,r24
 5181               	.LVL364:
3008:switcherator.c ****         if (x < 4)
 5182               		.loc 1 3008 0
 5183 1d0c F4E0      		ldi r31,4
 5184 1d0e EF16      		cp r14,r31
 5185 1d10 F104      		cpc r15,__zero_reg__
 5186 1d12 01F0      		breq .L399
3009:switcherator.c ****             newAddress <<= 8;
 5187               		.loc 1 3009 0
 5188 1d14 9101      		movw r18,r2
 5189 1d16 A201      		movw r20,r4
 5190 1d18 B301      		movw r22,r6
 5191 1d1a C401      		movw r24,r8
 5192 1d1c 08E0      		ldi r16,lo8(8)
 5193 1d1e 0E94 0000 		call __ashldi3
 5194 1d22 1901      		movw r2,r18
 5195               	.LVL365:
 5196 1d24 2A01      		movw r4,r20
 5197 1d26 3B01      		movw r6,r22
 5198 1d28 4C01      		movw r8,r24
 5199               	.LVL366:
 5200               	.L399:
3003:switcherator.c ****     for (x = 0; x < 5; x++) {
 5201               		.loc 1 3003 0
 5202 1d2a 8FEF      		ldi r24,-1
 5203 1d2c E81A      		sub r14,r24
 5204 1d2e F80A      		sbc r15,r24
 5205               	.LVL367:
 5206 1d30 E2E0      		ldi r30,2
 5207 1d32 CE0E      		add r12,r30
 5208 1d34 D11C      		adc r13,__zero_reg__
 5209 1d36 F5E0      		ldi r31,5
 5210 1d38 EF16      		cp r14,r31
 5211 1d3a F104      		cpc r15,__zero_reg__
 5212 1d3c 01F4      		brne .L400
3011:switcherator.c ****     switch (commandReceived[3]) {
 5213               		.loc 1 3011 0
 5214 1d3e F501      		movw r30,r10
 5215 1d40 8381      		ldd r24,Z+3
 5216 1d42 8333      		cpi r24,lo8(51)
 5217 1d44 01F4      		brne .+2
 5218 1d46 00C0      		rjmp .L405
 5219 1d48 00F4      		brsh .L409
 5220 1d4a 8133      		cpi r24,lo8(49)
 5221 1d4c 01F0      		breq .L403
 5222 1d4e 00F0      		brlo .+2
 5223 1d50 00C0      		rjmp .L404
 5224 1d52 8033      		cpi r24,lo8(48)
 5225 1d54 01F0      		breq .+2
 5226 1d56 00C0      		rjmp .L401
 5227 1d58 00C0      		rjmp .L402
 5228               	.L409:
 5229 1d5a 8533      		cpi r24,lo8(53)
 5230 1d5c 01F4      		brne .+2
 5231 1d5e 00C0      		rjmp .L407
 5232 1d60 00F4      		brsh .+2
 5233 1d62 00C0      		rjmp .L406
 5234 1d64 8435      		cpi r24,lo8(84)
 5235 1d66 01F0      		breq .+2
 5236 1d68 00C0      		rjmp .L401
 5237 1d6a 00C0      		rjmp .L408
 5238               	.L402:
3013:switcherator.c ****             rx_addr_p0 = newAddress;
 5239               		.loc 1 3013 0
 5240 1d6c 2092 0000 		sts rx_addr_p0,r2
 5241 1d70 3092 0000 		sts rx_addr_p0+1,r3
 5242 1d74 4092 0000 		sts rx_addr_p0+2,r4
 5243 1d78 5092 0000 		sts rx_addr_p0+3,r5
 5244 1d7c 6092 0000 		sts rx_addr_p0+4,r6
 5245 1d80 7092 0000 		sts rx_addr_p0+5,r7
 5246 1d84 8092 0000 		sts rx_addr_p0+6,r8
 5247 1d88 9092 0000 		sts rx_addr_p0+7,r9
3014:switcherator.c ****             strcat(statusMsg, "r0 0x");
 5248               		.loc 1 3014 0
 5249 1d8c 60E0      		ldi r22,lo8(.LC8)
 5250 1d8e 70E0      		ldi r23,hi8(.LC8)
 5251 1d90 80E0      		ldi r24,lo8(statusMsg)
 5252 1d92 90E0      		ldi r25,hi8(statusMsg)
 5253 1d94 0E94 0000 		call strcat
 5254               	.LVL368:
3015:switcherator.c ****             writeAddr(RX_ADDR_P0, newAddress);
 5255               		.loc 1 3015 0
 5256 1d98 8101      		movw r16,r2
 5257 1d9a 9201      		movw r18,r4
 5258 1d9c A301      		movw r20,r6
 5259 1d9e B401      		movw r22,r8
 5260 1da0 8AE0      		ldi r24,lo8(10)
 5261 1da2 00C0      		rjmp .L416
 5262               	.L403:
3018:switcherator.c ****             rx_addr_p1 = newAddress;
 5263               		.loc 1 3018 0
 5264 1da4 2092 0000 		sts rx_addr_p1,r2
 5265 1da8 3092 0000 		sts rx_addr_p1+1,r3
 5266 1dac 4092 0000 		sts rx_addr_p1+2,r4
 5267 1db0 5092 0000 		sts rx_addr_p1+3,r5
 5268 1db4 6092 0000 		sts rx_addr_p1+4,r6
 5269 1db8 7092 0000 		sts rx_addr_p1+5,r7
 5270 1dbc 8092 0000 		sts rx_addr_p1+6,r8
 5271 1dc0 9092 0000 		sts rx_addr_p1+7,r9
3019:switcherator.c ****             strcat(statusMsg, "r1 0x");
 5272               		.loc 1 3019 0
 5273 1dc4 60E0      		ldi r22,lo8(.LC9)
 5274 1dc6 70E0      		ldi r23,hi8(.LC9)
 5275 1dc8 80E0      		ldi r24,lo8(statusMsg)
 5276 1dca 90E0      		ldi r25,hi8(statusMsg)
 5277 1dcc 0E94 0000 		call strcat
 5278               	.LVL369:
3020:switcherator.c ****             writeAddr(RX_ADDR_P1, newAddress);
 5279               		.loc 1 3020 0
 5280 1dd0 8101      		movw r16,r2
 5281 1dd2 9201      		movw r18,r4
 5282 1dd4 A301      		movw r20,r6
 5283 1dd6 B401      		movw r22,r8
 5284 1dd8 8BE0      		ldi r24,lo8(11)
 5285 1dda 00C0      		rjmp .L416
 5286               	.L404:
3023:switcherator.c ****             rx_addr_p2 = newAddress;
 5287               		.loc 1 3023 0
 5288 1ddc 2092 0000 		sts rx_addr_p2,r2
 5289 1de0 3092 0000 		sts rx_addr_p2+1,r3
 5290 1de4 4092 0000 		sts rx_addr_p2+2,r4
 5291 1de8 5092 0000 		sts rx_addr_p2+3,r5
 5292 1dec 6092 0000 		sts rx_addr_p2+4,r6
 5293 1df0 7092 0000 		sts rx_addr_p2+5,r7
 5294 1df4 8092 0000 		sts rx_addr_p2+6,r8
 5295 1df8 9092 0000 		sts rx_addr_p2+7,r9
3024:switcherator.c ****             strcat(statusMsg, "r2 0x");
 5296               		.loc 1 3024 0
 5297 1dfc 60E0      		ldi r22,lo8(.LC10)
 5298 1dfe 70E0      		ldi r23,hi8(.LC10)
 5299 1e00 80E0      		ldi r24,lo8(statusMsg)
 5300 1e02 90E0      		ldi r25,hi8(statusMsg)
 5301 1e04 0E94 0000 		call strcat
 5302               	.LVL370:
3025:switcherator.c ****             writeAddr(RX_ADDR_P2, newAddress);
 5303               		.loc 1 3025 0
 5304 1e08 8101      		movw r16,r2
 5305 1e0a 9201      		movw r18,r4
 5306 1e0c A301      		movw r20,r6
 5307 1e0e B401      		movw r22,r8
 5308 1e10 8CE0      		ldi r24,lo8(12)
 5309 1e12 00C0      		rjmp .L416
 5310               	.L405:
3028:switcherator.c ****             rx_addr_p3 = newAddress;
 5311               		.loc 1 3028 0
 5312 1e14 2092 0000 		sts rx_addr_p3,r2
 5313 1e18 3092 0000 		sts rx_addr_p3+1,r3
 5314 1e1c 4092 0000 		sts rx_addr_p3+2,r4
 5315 1e20 5092 0000 		sts rx_addr_p3+3,r5
 5316 1e24 6092 0000 		sts rx_addr_p3+4,r6
 5317 1e28 7092 0000 		sts rx_addr_p3+5,r7
 5318 1e2c 8092 0000 		sts rx_addr_p3+6,r8
 5319 1e30 9092 0000 		sts rx_addr_p3+7,r9
3029:switcherator.c ****             strcat(statusMsg, "r3 0x");
 5320               		.loc 1 3029 0
 5321 1e34 60E0      		ldi r22,lo8(.LC11)
 5322 1e36 70E0      		ldi r23,hi8(.LC11)
 5323 1e38 80E0      		ldi r24,lo8(statusMsg)
 5324 1e3a 90E0      		ldi r25,hi8(statusMsg)
 5325 1e3c 0E94 0000 		call strcat
 5326               	.LVL371:
3030:switcherator.c ****             writeAddr(RX_ADDR_P3, newAddress);
 5327               		.loc 1 3030 0
 5328 1e40 8101      		movw r16,r2
 5329 1e42 9201      		movw r18,r4
 5330 1e44 A301      		movw r20,r6
 5331 1e46 B401      		movw r22,r8
 5332 1e48 8DE0      		ldi r24,lo8(13)
 5333 1e4a 00C0      		rjmp .L416
 5334               	.L406:
3033:switcherator.c ****             rx_addr_p4 = newAddress;
 5335               		.loc 1 3033 0
 5336 1e4c 2092 0000 		sts rx_addr_p4,r2
 5337 1e50 3092 0000 		sts rx_addr_p4+1,r3
 5338 1e54 4092 0000 		sts rx_addr_p4+2,r4
 5339 1e58 5092 0000 		sts rx_addr_p4+3,r5
 5340 1e5c 6092 0000 		sts rx_addr_p4+4,r6
 5341 1e60 7092 0000 		sts rx_addr_p4+5,r7
 5342 1e64 8092 0000 		sts rx_addr_p4+6,r8
 5343 1e68 9092 0000 		sts rx_addr_p4+7,r9
3034:switcherator.c ****             strcat(statusMsg, "r4 0x");
 5344               		.loc 1 3034 0
 5345 1e6c 60E0      		ldi r22,lo8(.LC12)
 5346 1e6e 70E0      		ldi r23,hi8(.LC12)
 5347 1e70 80E0      		ldi r24,lo8(statusMsg)
 5348 1e72 90E0      		ldi r25,hi8(statusMsg)
 5349 1e74 0E94 0000 		call strcat
 5350               	.LVL372:
3035:switcherator.c ****             writeAddr(RX_ADDR_P4, newAddress);
 5351               		.loc 1 3035 0
 5352 1e78 8101      		movw r16,r2
 5353 1e7a 9201      		movw r18,r4
 5354 1e7c A301      		movw r20,r6
 5355 1e7e B401      		movw r22,r8
 5356 1e80 8EE0      		ldi r24,lo8(14)
 5357 1e82 00C0      		rjmp .L416
 5358               	.L407:
3038:switcherator.c ****             rx_addr_p5 = newAddress;
 5359               		.loc 1 3038 0
 5360 1e84 2092 0000 		sts rx_addr_p5,r2
 5361 1e88 3092 0000 		sts rx_addr_p5+1,r3
 5362 1e8c 4092 0000 		sts rx_addr_p5+2,r4
 5363 1e90 5092 0000 		sts rx_addr_p5+3,r5
 5364 1e94 6092 0000 		sts rx_addr_p5+4,r6
 5365 1e98 7092 0000 		sts rx_addr_p5+5,r7
 5366 1e9c 8092 0000 		sts rx_addr_p5+6,r8
 5367 1ea0 9092 0000 		sts rx_addr_p5+7,r9
3039:switcherator.c ****             strcat(statusMsg, "r5 0x");
 5368               		.loc 1 3039 0
 5369 1ea4 60E0      		ldi r22,lo8(.LC13)
 5370 1ea6 70E0      		ldi r23,hi8(.LC13)
 5371 1ea8 80E0      		ldi r24,lo8(statusMsg)
 5372 1eaa 90E0      		ldi r25,hi8(statusMsg)
 5373 1eac 0E94 0000 		call strcat
 5374               	.LVL373:
3040:switcherator.c ****             writeAddr(RX_ADDR_P5, newAddress);
 5375               		.loc 1 3040 0
 5376 1eb0 8101      		movw r16,r2
 5377 1eb2 9201      		movw r18,r4
 5378 1eb4 A301      		movw r20,r6
 5379 1eb6 B401      		movw r22,r8
 5380 1eb8 8FE0      		ldi r24,lo8(15)
 5381 1eba 00C0      		rjmp .L416
 5382               	.L408:
3043:switcherator.c ****             tx_addr = newAddress;
 5383               		.loc 1 3043 0
 5384 1ebc 2092 0000 		sts tx_addr,r2
 5385 1ec0 3092 0000 		sts tx_addr+1,r3
 5386 1ec4 4092 0000 		sts tx_addr+2,r4
 5387 1ec8 5092 0000 		sts tx_addr+3,r5
 5388 1ecc 6092 0000 		sts tx_addr+4,r6
 5389 1ed0 7092 0000 		sts tx_addr+5,r7
 5390 1ed4 8092 0000 		sts tx_addr+6,r8
 5391 1ed8 9092 0000 		sts tx_addr+7,r9
3044:switcherator.c ****             strcat(statusMsg, "t 0x");
 5392               		.loc 1 3044 0
 5393 1edc 60E0      		ldi r22,lo8(.LC14)
 5394 1ede 70E0      		ldi r23,hi8(.LC14)
 5395 1ee0 80E0      		ldi r24,lo8(statusMsg)
 5396 1ee2 90E0      		ldi r25,hi8(statusMsg)
 5397 1ee4 0E94 0000 		call strcat
 5398               	.LVL374:
3045:switcherator.c ****             writeAddr(TX_ADDR, newAddress);
 5399               		.loc 1 3045 0
 5400 1ee8 8101      		movw r16,r2
 5401 1eea 9201      		movw r18,r4
 5402 1eec A301      		movw r20,r6
 5403 1eee B401      		movw r22,r8
 5404 1ef0 80E1      		ldi r24,lo8(16)
 5405               	.L416:
 5406 1ef2 0E94 0000 		call writeAddr
 5407               	.LVL375:
 5408               	.L401:
3048:switcherator.c ****     unformatAddress(newAddress, tempRadioString);
 5409               		.loc 1 3048 0
 5410 1ef6 8E01      		movw r16,r28
 5411 1ef8 0F5F      		subi r16,-1
 5412 1efa 1F4F      		sbci r17,-1
 5413 1efc 9101      		movw r18,r2
 5414 1efe A201      		movw r20,r4
 5415 1f00 B301      		movw r22,r6
 5416 1f02 C401      		movw r24,r8
 5417 1f04 0E94 0000 		call unformatAddress
 5418               	.LVL376:
 5419 1f08 7801      		movw r14,r16
2996:switcherator.c **** void radioChangeAddress(char * commandReceived) {
 5420               		.loc 1 2996 0
 5421 1f0a 6E01      		movw r12,r28
 5422 1f0c F6E0      		ldi r31,6
 5423 1f0e CF0E      		add r12,r31
 5424 1f10 D11C      		adc r13,__zero_reg__
 5425               	.LVL377:
 5426               	.L410:
3050:switcherator.c ****         returnHexWithout(tempRadioString[x], tempLongString);
 5427               		.loc 1 3050 0 discriminator 2
 5428 1f12 60E0      		ldi r22,lo8(tempLongString)
 5429 1f14 70E0      		ldi r23,hi8(tempLongString)
 5430 1f16 F701      		movw r30,r14
 5431 1f18 8191      		ld r24,Z+
 5432 1f1a 7F01      		movw r14,r30
 5433 1f1c 90E0      		ldi r25,0
 5434 1f1e 0E94 0000 		call returnHexWithout
 5435               	.LVL378:
3051:switcherator.c ****         strcat(statusMsg, tempLongString);
 5436               		.loc 1 3051 0 discriminator 2
 5437 1f22 60E0      		ldi r22,lo8(tempLongString)
 5438 1f24 70E0      		ldi r23,hi8(tempLongString)
 5439 1f26 80E0      		ldi r24,lo8(statusMsg)
 5440 1f28 90E0      		ldi r25,hi8(statusMsg)
 5441 1f2a 0E94 0000 		call strcat
 5442               	.LVL379:
3049:switcherator.c ****     for (x = 0; x < 5; x++) {
 5443               		.loc 1 3049 0 discriminator 2
 5444 1f2e EC14      		cp r14,r12
 5445 1f30 FD04      		cpc r15,r13
 5446 1f32 01F4      		brne .L410
3053:switcherator.c ****     sendMessage(statusMsg);
 5447               		.loc 1 3053 0
 5448 1f34 80E0      		ldi r24,lo8(statusMsg)
 5449 1f36 90E0      		ldi r25,hi8(statusMsg)
 5450 1f38 0E94 0000 		call sendMessage
 5451               	.LVL380:
 5452               	/* epilogue start */
3054:switcherator.c **** }
 5453               		.loc 1 3054 0
 5454 1f3c 2B96      		adiw r28,11
 5455 1f3e 0FB6      		in __tmp_reg__,__SREG__
 5456 1f40 F894      		cli
 5457 1f42 DEBF      		out __SP_H__,r29
 5458 1f44 0FBE      		out __SREG__,__tmp_reg__
 5459 1f46 CDBF      		out __SP_L__,r28
 5460 1f48 DF91      		pop r29
 5461 1f4a CF91      		pop r28
 5462 1f4c 1F91      		pop r17
 5463 1f4e 0F91      		pop r16
 5464 1f50 FF90      		pop r15
 5465 1f52 EF90      		pop r14
 5466 1f54 DF90      		pop r13
 5467 1f56 CF90      		pop r12
 5468 1f58 BF90      		pop r11
 5469 1f5a AF90      		pop r10
 5470               	.LVL381:
 5471 1f5c 9F90      		pop r9
 5472               	.LVL382:
 5473 1f5e 8F90      		pop r8
 5474 1f60 7F90      		pop r7
 5475 1f62 6F90      		pop r6
 5476 1f64 5F90      		pop r5
 5477 1f66 4F90      		pop r4
 5478 1f68 3F90      		pop r3
 5479 1f6a 2F90      		pop r2
 5480 1f6c 0895      		ret
 5481               	.LFE75:
 5483               		.section	.rodata.str1.1
 5484               	.LC15:
 5485 003f 7231 2D30 		.string	"r1-0x"
 5485      7800 
 5486               	.LC16:
 5487 0045 7232 2D30 		.string	"r2-0x"
 5487      7800 
 5488               	.LC17:
 5489 004b 7233 2D30 		.string	"r3-0x"
 5489      7800 
 5490               	.LC18:
 5491 0051 7234 2D30 		.string	"r4-0x"
 5491      7800 
 5492               	.LC19:
 5493 0057 7235 2D30 		.string	"r5-0x"
 5493      7800 
 5494               	.LC20:
 5495 005d 742D 3078 		.string	"t-0x"
 5495      00
 5496               	.LC21:
 5497 0062 7230 2D30 		.string	"r0-0x"
 5497      7800 
 5498               		.text
 5499               	.global	radioDisplayAddress
 5501               	radioDisplayAddress:
 5502               	.LFB74:
2956:switcherator.c **** void radioDisplayAddress(char * commandReceived) {
 5503               		.loc 1 2956 0
 5504               	.LVL383:
 5505 1f6e EF92      		push r14
 5506               	.LCFI138:
 5507 1f70 FF92      		push r15
 5508               	.LCFI139:
 5509 1f72 0F93      		push r16
 5510               	.LCFI140:
 5511 1f74 1F93      		push r17
 5512               	.LCFI141:
 5513 1f76 CF93      		push r28
 5514               	.LCFI142:
 5515 1f78 DF93      		push r29
 5516               	.LCFI143:
 5517 1f7a 00D0      		rcall .
 5518 1f7c 00D0      		rcall .
 5519 1f7e 00D0      		rcall .
 5520               	.LCFI144:
 5521 1f80 CDB7      		in r28,__SP_L__
 5522 1f82 DEB7      		in r29,__SP_H__
 5523               	.LCFI145:
 5524               	/* prologue: function */
 5525               	/* frame size = 6 */
 5526               	/* stack size = 12 */
 5527               	.L__stack_usage = 12
 5528               	.LVL384:
2959:switcherator.c ****     statusMsg[0] = 0;
 5529               		.loc 1 2959 0
 5530 1f84 1092 0000 		sts statusMsg,__zero_reg__
2960:switcherator.c ****     if(commandReceived[3] == '1') {
 5531               		.loc 1 2960 0
 5532 1f88 FC01      		movw r30,r24
 5533 1f8a 8381      		ldd r24,Z+3
 5534               	.LVL385:
 5535 1f8c 8133      		cpi r24,lo8(49)
 5536 1f8e 01F4      		brne .L418
2961:switcherator.c ****         unformatAddress(rx_addr_p1, tempRadioString);
 5537               		.loc 1 2961 0
 5538 1f90 2091 0000 		lds r18,rx_addr_p1
 5539 1f94 3091 0000 		lds r19,rx_addr_p1+1
 5540 1f98 4091 0000 		lds r20,rx_addr_p1+2
 5541 1f9c 5091 0000 		lds r21,rx_addr_p1+3
 5542 1fa0 6091 0000 		lds r22,rx_addr_p1+4
 5543 1fa4 7091 0000 		lds r23,rx_addr_p1+5
 5544 1fa8 8E01      		movw r16,r28
 5545 1faa 0F5F      		subi r16,-1
 5546 1fac 1F4F      		sbci r17,-1
 5547 1fae 8091 0000 		lds r24,rx_addr_p1+6
 5548 1fb2 9091 0000 		lds r25,rx_addr_p1+7
 5549 1fb6 0E94 0000 		call unformatAddress
 5550               	.LVL386:
2962:switcherator.c ****         strcat(statusMsg, "r1-0x");
 5551               		.loc 1 2962 0
 5552 1fba 60E0      		ldi r22,lo8(.LC15)
 5553 1fbc 70E0      		ldi r23,hi8(.LC15)
 5554               	.L427:
 5555 1fbe 80E0      		ldi r24,lo8(statusMsg)
 5556 1fc0 90E0      		ldi r25,hi8(statusMsg)
 5557 1fc2 0E94 0000 		call strcat
 5558               	.LVL387:
 5559 1fc6 8E01      		movw r16,r28
 5560 1fc8 0F5F      		subi r16,-1
 5561 1fca 1F4F      		sbci r17,-1
2956:switcherator.c **** void radioDisplayAddress(char * commandReceived) {
 5562               		.loc 1 2956 0
 5563 1fcc 7E01      		movw r14,r28
 5564 1fce F6E0      		ldi r31,6
 5565 1fd0 EF0E      		add r14,r31
 5566 1fd2 F11C      		adc r15,__zero_reg__
 5567 1fd4 00C0      		rjmp .L419
 5568               	.LVL388:
 5569               	.L418:
2963:switcherator.c ****     } else if(commandReceived[3] == '2') {
 5570               		.loc 1 2963 0
 5571 1fd6 8233      		cpi r24,lo8(50)
 5572 1fd8 01F4      		brne .L420
2964:switcherator.c ****         unformatAddress(rx_addr_p2, tempRadioString);
 5573               		.loc 1 2964 0
 5574 1fda 2091 0000 		lds r18,rx_addr_p2
 5575 1fde 3091 0000 		lds r19,rx_addr_p2+1
 5576 1fe2 4091 0000 		lds r20,rx_addr_p2+2
 5577 1fe6 5091 0000 		lds r21,rx_addr_p2+3
 5578 1fea 6091 0000 		lds r22,rx_addr_p2+4
 5579 1fee 7091 0000 		lds r23,rx_addr_p2+5
 5580 1ff2 8E01      		movw r16,r28
 5581 1ff4 0F5F      		subi r16,-1
 5582 1ff6 1F4F      		sbci r17,-1
 5583 1ff8 8091 0000 		lds r24,rx_addr_p2+6
 5584 1ffc 9091 0000 		lds r25,rx_addr_p2+7
 5585 2000 0E94 0000 		call unformatAddress
 5586               	.LVL389:
2965:switcherator.c ****         strcat(statusMsg, "r2-0x");
 5587               		.loc 1 2965 0
 5588 2004 60E0      		ldi r22,lo8(.LC16)
 5589 2006 70E0      		ldi r23,hi8(.LC16)
 5590 2008 00C0      		rjmp .L427
 5591               	.LVL390:
 5592               	.L420:
2966:switcherator.c ****     } else if(commandReceived[3] == '3') {
 5593               		.loc 1 2966 0
 5594 200a 8333      		cpi r24,lo8(51)
 5595 200c 01F4      		brne .L422
2967:switcherator.c ****         unformatAddress(rx_addr_p3, tempRadioString);
 5596               		.loc 1 2967 0
 5597 200e 2091 0000 		lds r18,rx_addr_p3
 5598 2012 3091 0000 		lds r19,rx_addr_p3+1
 5599 2016 4091 0000 		lds r20,rx_addr_p3+2
 5600 201a 5091 0000 		lds r21,rx_addr_p3+3
 5601 201e 6091 0000 		lds r22,rx_addr_p3+4
 5602 2022 7091 0000 		lds r23,rx_addr_p3+5
 5603 2026 8E01      		movw r16,r28
 5604 2028 0F5F      		subi r16,-1
 5605 202a 1F4F      		sbci r17,-1
 5606 202c 8091 0000 		lds r24,rx_addr_p3+6
 5607 2030 9091 0000 		lds r25,rx_addr_p3+7
 5608 2034 0E94 0000 		call unformatAddress
 5609               	.LVL391:
2968:switcherator.c ****         strcat(statusMsg, "r3-0x");
 5610               		.loc 1 2968 0
 5611 2038 60E0      		ldi r22,lo8(.LC17)
 5612 203a 70E0      		ldi r23,hi8(.LC17)
 5613 203c 00C0      		rjmp .L427
 5614               	.LVL392:
 5615               	.L422:
2969:switcherator.c ****     } else if(commandReceived[3] == '4') {
 5616               		.loc 1 2969 0
 5617 203e 8433      		cpi r24,lo8(52)
 5618 2040 01F4      		brne .L423
2970:switcherator.c ****         unformatAddress(rx_addr_p4, tempRadioString);
 5619               		.loc 1 2970 0
 5620 2042 2091 0000 		lds r18,rx_addr_p4
 5621 2046 3091 0000 		lds r19,rx_addr_p4+1
 5622 204a 4091 0000 		lds r20,rx_addr_p4+2
 5623 204e 5091 0000 		lds r21,rx_addr_p4+3
 5624 2052 6091 0000 		lds r22,rx_addr_p4+4
 5625 2056 7091 0000 		lds r23,rx_addr_p4+5
 5626 205a 8E01      		movw r16,r28
 5627 205c 0F5F      		subi r16,-1
 5628 205e 1F4F      		sbci r17,-1
 5629 2060 8091 0000 		lds r24,rx_addr_p4+6
 5630 2064 9091 0000 		lds r25,rx_addr_p4+7
 5631 2068 0E94 0000 		call unformatAddress
 5632               	.LVL393:
2971:switcherator.c ****         strcat(statusMsg, "r4-0x");
 5633               		.loc 1 2971 0
 5634 206c 60E0      		ldi r22,lo8(.LC18)
 5635 206e 70E0      		ldi r23,hi8(.LC18)
 5636 2070 00C0      		rjmp .L427
 5637               	.LVL394:
 5638               	.L423:
2972:switcherator.c ****     } else if (commandReceived[3] == '5') {
 5639               		.loc 1 2972 0
 5640 2072 8533      		cpi r24,lo8(53)
 5641 2074 01F4      		brne .L424
2973:switcherator.c ****         unformatAddress(rx_addr_p5, tempRadioString);
 5642               		.loc 1 2973 0
 5643 2076 2091 0000 		lds r18,rx_addr_p5
 5644 207a 3091 0000 		lds r19,rx_addr_p5+1
 5645 207e 4091 0000 		lds r20,rx_addr_p5+2
 5646 2082 5091 0000 		lds r21,rx_addr_p5+3
 5647 2086 6091 0000 		lds r22,rx_addr_p5+4
 5648 208a 7091 0000 		lds r23,rx_addr_p5+5
 5649 208e 8E01      		movw r16,r28
 5650 2090 0F5F      		subi r16,-1
 5651 2092 1F4F      		sbci r17,-1
 5652 2094 8091 0000 		lds r24,rx_addr_p5+6
 5653 2098 9091 0000 		lds r25,rx_addr_p5+7
 5654 209c 0E94 0000 		call unformatAddress
 5655               	.LVL395:
2974:switcherator.c ****         strcat(statusMsg, "r5-0x");
 5656               		.loc 1 2974 0
 5657 20a0 60E0      		ldi r22,lo8(.LC19)
 5658 20a2 70E0      		ldi r23,hi8(.LC19)
 5659 20a4 00C0      		rjmp .L427
 5660               	.LVL396:
 5661               	.L424:
2975:switcherator.c ****     } else if (commandReceived[3] == 'T') {
 5662               		.loc 1 2975 0
 5663 20a6 8435      		cpi r24,lo8(84)
 5664 20a8 01F4      		brne .L425
2976:switcherator.c ****         unformatAddress(tx_addr, tempRadioString);
 5665               		.loc 1 2976 0
 5666 20aa 2091 0000 		lds r18,tx_addr
 5667 20ae 3091 0000 		lds r19,tx_addr+1
 5668 20b2 4091 0000 		lds r20,tx_addr+2
 5669 20b6 5091 0000 		lds r21,tx_addr+3
 5670 20ba 6091 0000 		lds r22,tx_addr+4
 5671 20be 7091 0000 		lds r23,tx_addr+5
 5672 20c2 8E01      		movw r16,r28
 5673 20c4 0F5F      		subi r16,-1
 5674 20c6 1F4F      		sbci r17,-1
 5675 20c8 8091 0000 		lds r24,tx_addr+6
 5676 20cc 9091 0000 		lds r25,tx_addr+7
 5677 20d0 0E94 0000 		call unformatAddress
 5678               	.LVL397:
2977:switcherator.c ****         strcat(statusMsg, "t-0x");
 5679               		.loc 1 2977 0
 5680 20d4 60E0      		ldi r22,lo8(.LC20)
 5681 20d6 70E0      		ldi r23,hi8(.LC20)
 5682 20d8 00C0      		rjmp .L427
 5683               	.LVL398:
 5684               	.L425:
2979:switcherator.c ****         unformatAddress(rx_addr_p0, tempRadioString);
 5685               		.loc 1 2979 0
 5686 20da 2091 0000 		lds r18,rx_addr_p0
 5687 20de 3091 0000 		lds r19,rx_addr_p0+1
 5688 20e2 4091 0000 		lds r20,rx_addr_p0+2
 5689 20e6 5091 0000 		lds r21,rx_addr_p0+3
 5690 20ea 6091 0000 		lds r22,rx_addr_p0+4
 5691 20ee 7091 0000 		lds r23,rx_addr_p0+5
 5692 20f2 8E01      		movw r16,r28
 5693 20f4 0F5F      		subi r16,-1
 5694 20f6 1F4F      		sbci r17,-1
 5695 20f8 8091 0000 		lds r24,rx_addr_p0+6
 5696 20fc 9091 0000 		lds r25,rx_addr_p0+7
 5697 2100 0E94 0000 		call unformatAddress
 5698               	.LVL399:
2980:switcherator.c ****         strcat(statusMsg, "r0-0x");
 5699               		.loc 1 2980 0
 5700 2104 60E0      		ldi r22,lo8(.LC21)
 5701 2106 70E0      		ldi r23,hi8(.LC21)
 5702 2108 00C0      		rjmp .L427
 5703               	.LVL400:
 5704               	.L419:
2983:switcherator.c ****         returnHexWithout(tempRadioString[x], tempLongString);
 5705               		.loc 1 2983 0 discriminator 2
 5706 210a 60E0      		ldi r22,lo8(tempLongString)
 5707 210c 70E0      		ldi r23,hi8(tempLongString)
 5708 210e F801      		movw r30,r16
 5709 2110 8191      		ld r24,Z+
 5710 2112 8F01      		movw r16,r30
 5711 2114 90E0      		ldi r25,0
 5712 2116 0E94 0000 		call returnHexWithout
 5713               	.LVL401:
2984:switcherator.c ****         strcat(statusMsg, tempLongString);
 5714               		.loc 1 2984 0 discriminator 2
 5715 211a 60E0      		ldi r22,lo8(tempLongString)
 5716 211c 70E0      		ldi r23,hi8(tempLongString)
 5717 211e 80E0      		ldi r24,lo8(statusMsg)
 5718 2120 90E0      		ldi r25,hi8(statusMsg)
 5719 2122 0E94 0000 		call strcat
 5720               	.LVL402:
2982:switcherator.c ****     for (x = 0; x < 5; x++) {
 5721               		.loc 1 2982 0 discriminator 2
 5722 2126 0E15      		cp r16,r14
 5723 2128 1F05      		cpc r17,r15
 5724 212a 01F4      		brne .L419
2986:switcherator.c ****     sendMessage(statusMsg);
 5725               		.loc 1 2986 0
 5726 212c 80E0      		ldi r24,lo8(statusMsg)
 5727 212e 90E0      		ldi r25,hi8(statusMsg)
 5728 2130 0E94 0000 		call sendMessage
 5729               	.LVL403:
 5730               	/* epilogue start */
2987:switcherator.c **** }
 5731               		.loc 1 2987 0
 5732 2134 2696      		adiw r28,6
 5733 2136 0FB6      		in __tmp_reg__,__SREG__
 5734 2138 F894      		cli
 5735 213a DEBF      		out __SP_H__,r29
 5736 213c 0FBE      		out __SREG__,__tmp_reg__
 5737 213e CDBF      		out __SP_L__,r28
 5738 2140 DF91      		pop r29
 5739 2142 CF91      		pop r28
 5740 2144 1F91      		pop r17
 5741 2146 0F91      		pop r16
 5742 2148 FF90      		pop r15
 5743 214a EF90      		pop r14
 5744 214c 0895      		ret
 5745               	.LFE74:
 5747               		.section	.rodata.str1.1
 5748               	.LC22:
 5749 0068 5377 4F6E 		.string	"SwOn:"
 5749      3A00 
 5750               	.LC23:
 5751 006e 7900      		.string	"y"
 5752               	.LC24:
 5753 0070 6E00      		.string	"n"
 5754               		.text
 5755               	.global	switchesOn
 5757               	switchesOn:
 5758               	.LFB67:
2834:switcherator.c **** void switchesOn(void) {
 5759               		.loc 1 2834 0
 5760 214e CF93      		push r28
 5761               	.LCFI146:
 5762 2150 DF93      		push r29
 5763               	.LCFI147:
 5764               	/* prologue: function */
 5765               	/* frame size = 0 */
 5766               	/* stack size = 2 */
 5767               	.L__stack_usage = 2
2835:switcherator.c ****     statusMsg[0] = 0;
 5768               		.loc 1 2835 0
 5769 2152 1092 0000 		sts statusMsg,__zero_reg__
2836:switcherator.c ****     strcat(statusMsg, "SwOn:");
 5770               		.loc 1 2836 0
 5771 2156 60E0      		ldi r22,lo8(.LC22)
 5772 2158 70E0      		ldi r23,hi8(.LC22)
 5773 215a 80E0      		ldi r24,lo8(statusMsg)
 5774 215c 90E0      		ldi r25,hi8(statusMsg)
 5775 215e 0E94 0000 		call strcat
 5776               	.LVL404:
 5777 2162 C0E0      		ldi r28,lo8(switchStatus)
 5778 2164 D0E0      		ldi r29,hi8(switchStatus)
 5779               	.LVL405:
 5780               	.L432:
2839:switcherator.c ****         if (switchStatus[x] > 0) {
 5781               		.loc 1 2839 0
 5782 2166 8991      		ld r24,Y+
 5783 2168 9991      		ld r25,Y+
 5784 216a A991      		ld r26,Y+
 5785 216c B991      		ld r27,Y+
 5786 216e 892B      		or r24,r25
 5787 2170 8A2B      		or r24,r26
 5788 2172 8B2B      		or r24,r27
 5789 2174 01F0      		breq .L429
2840:switcherator.c ****             strcat(statusMsg, "y");
 5790               		.loc 1 2840 0
 5791 2176 60E0      		ldi r22,lo8(.LC23)
 5792 2178 70E0      		ldi r23,hi8(.LC23)
 5793 217a 00C0      		rjmp .L434
 5794               	.L429:
2842:switcherator.c ****             strcat(statusMsg, "n");
 5795               		.loc 1 2842 0
 5796 217c 60E0      		ldi r22,lo8(.LC24)
 5797 217e 70E0      		ldi r23,hi8(.LC24)
 5798               	.L434:
 5799 2180 80E0      		ldi r24,lo8(statusMsg)
 5800 2182 90E0      		ldi r25,hi8(statusMsg)
 5801 2184 0E94 0000 		call strcat
 5802               	.LVL406:
2844:switcherator.c ****         if (strlen(statusMsg) > 30) {
 5803               		.loc 1 2844 0
 5804 2188 E0E0      		ldi r30,lo8(statusMsg)
 5805 218a F0E0      		ldi r31,hi8(statusMsg)
 5806               		0:
 5807 218c 0190      		ld __tmp_reg__,Z+
 5808 218e 0020      		tst __tmp_reg__
 5809 2190 01F4      		brne 0b
 5810 2192 3197      		sbiw r30,1
 5811 2194 E050      		subi r30,lo8(statusMsg)
 5812 2196 F040      		sbci r31,hi8(statusMsg)
 5813 2198 7F97      		sbiw r30,31
 5814 219a 00F0      		brlo .L431
2845:switcherator.c ****             sendMessage(statusMsg);
 5815               		.loc 1 2845 0
 5816 219c 80E0      		ldi r24,lo8(statusMsg)
 5817 219e 90E0      		ldi r25,hi8(statusMsg)
 5818 21a0 0E94 0000 		call sendMessage
 5819               	.LVL407:
2846:switcherator.c ****             statusMsg[5] = 0;
 5820               		.loc 1 2846 0
 5821 21a4 1092 0000 		sts statusMsg+5,__zero_reg__
 5822               	.L431:
2838:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 5823               		.loc 1 2838 0
 5824 21a8 80E0      		ldi r24,hi8(switchStatus+64)
 5825 21aa C030      		cpi r28,lo8(switchStatus+64)
 5826 21ac D807      		cpc r29,r24
 5827 21ae 01F4      		brne .L432
2849:switcherator.c ****     sendMessage(statusMsg);
 5828               		.loc 1 2849 0
 5829 21b0 80E0      		ldi r24,lo8(statusMsg)
 5830 21b2 90E0      		ldi r25,hi8(statusMsg)
 5831               	/* epilogue start */
2850:switcherator.c **** }
 5832               		.loc 1 2850 0
 5833 21b4 DF91      		pop r29
 5834 21b6 CF91      		pop r28
2849:switcherator.c ****     sendMessage(statusMsg);
 5835               		.loc 1 2849 0
 5836 21b8 0C94 0000 		jmp sendMessage
 5837               	.LVL408:
 5838               	.LFE67:
 5840               		.section	.rodata.str1.1
 5841               	.LC25:
 5842 0072 496E 703A 		.string	"Inp:"
 5842      00
 5843               		.text
 5844               	.global	inputsProgrammed
 5846               	inputsProgrammed:
 5847               	.LFB66:
2814:switcherator.c **** void inputsProgrammed(void) {
 5848               		.loc 1 2814 0
 5849 21bc CF93      		push r28
 5850               	.LCFI148:
 5851 21be DF93      		push r29
 5852               	.LCFI149:
 5853               	/* prologue: function */
 5854               	/* frame size = 0 */
 5855               	/* stack size = 2 */
 5856               	.L__stack_usage = 2
2815:switcherator.c ****     statusMsg[0] = 0;
 5857               		.loc 1 2815 0
 5858 21c0 1092 0000 		sts statusMsg,__zero_reg__
2816:switcherator.c ****     strcat(statusMsg, "Inp:");
 5859               		.loc 1 2816 0
 5860 21c4 60E0      		ldi r22,lo8(.LC25)
 5861 21c6 70E0      		ldi r23,hi8(.LC25)
 5862 21c8 80E0      		ldi r24,lo8(statusMsg)
 5863 21ca 90E0      		ldi r25,hi8(statusMsg)
 5864 21cc 0E94 0000 		call strcat
 5865               	.LVL409:
 5866 21d0 C0E0      		ldi r28,lo8(inputs)
 5867 21d2 D0E0      		ldi r29,hi8(inputs)
 5868               	.LVL410:
 5869               	.L439:
2819:switcherator.c ****         if (inputs[x][0] == 255) {
 5870               		.loc 1 2819 0
 5871 21d4 8881      		ld r24,Y
 5872 21d6 8F3F      		cpi r24,lo8(-1)
 5873 21d8 01F4      		brne .L436
2820:switcherator.c ****             strcat(statusMsg, "n");
 5874               		.loc 1 2820 0
 5875 21da 60E0      		ldi r22,lo8(.LC24)
 5876 21dc 70E0      		ldi r23,hi8(.LC24)
 5877 21de 00C0      		rjmp .L441
 5878               	.L436:
2822:switcherator.c ****             strcat(statusMsg, "y");
 5879               		.loc 1 2822 0
 5880 21e0 60E0      		ldi r22,lo8(.LC23)
 5881 21e2 70E0      		ldi r23,hi8(.LC23)
 5882               	.L441:
 5883 21e4 80E0      		ldi r24,lo8(statusMsg)
 5884 21e6 90E0      		ldi r25,hi8(statusMsg)
 5885 21e8 0E94 0000 		call strcat
 5886               	.LVL411:
2825:switcherator.c ****         if (strlen(statusMsg) > 30) {
 5887               		.loc 1 2825 0
 5888 21ec E0E0      		ldi r30,lo8(statusMsg)
 5889 21ee F0E0      		ldi r31,hi8(statusMsg)
 5890               		0:
 5891 21f0 0190      		ld __tmp_reg__,Z+
 5892 21f2 0020      		tst __tmp_reg__
 5893 21f4 01F4      		brne 0b
 5894 21f6 3197      		sbiw r30,1
 5895 21f8 E050      		subi r30,lo8(statusMsg)
 5896 21fa F040      		sbci r31,hi8(statusMsg)
 5897 21fc 7F97      		sbiw r30,31
 5898 21fe 00F0      		brlo .L438
2826:switcherator.c ****             sendMessage(statusMsg);
 5899               		.loc 1 2826 0
 5900 2200 80E0      		ldi r24,lo8(statusMsg)
 5901 2202 90E0      		ldi r25,hi8(statusMsg)
 5902 2204 0E94 0000 		call sendMessage
 5903               	.LVL412:
2827:switcherator.c ****             statusMsg[4] = 0;
 5904               		.loc 1 2827 0
 5905 2208 1092 0000 		sts statusMsg+4,__zero_reg__
 5906               	.L438:
 5907 220c 2896      		adiw r28,8
2818:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 5908               		.loc 1 2818 0
 5909 220e 80E0      		ldi r24,hi8(inputs+32)
 5910 2210 C030      		cpi r28,lo8(inputs+32)
 5911 2212 D807      		cpc r29,r24
 5912 2214 01F4      		brne .L439
2830:switcherator.c ****     sendMessage(statusMsg);
 5913               		.loc 1 2830 0
 5914 2216 80E0      		ldi r24,lo8(statusMsg)
 5915 2218 90E0      		ldi r25,hi8(statusMsg)
 5916               	/* epilogue start */
2831:switcherator.c **** }
 5917               		.loc 1 2831 0
 5918 221a DF91      		pop r29
 5919 221c CF91      		pop r28
2830:switcherator.c ****     sendMessage(statusMsg);
 5920               		.loc 1 2830 0
 5921 221e 0C94 0000 		jmp sendMessage
 5922               	.LVL413:
 5923               	.LFE66:
 5925               		.section	.rodata.str1.1
 5926               	.LC26:
 5927 0077 5377 693A 		.string	"Swi:"
 5927      00
 5928               		.text
 5929               	.global	switchesProgrammed
 5931               	switchesProgrammed:
 5932               	.LFB65:
2793:switcherator.c **** void switchesProgrammed(void) {
 5933               		.loc 1 2793 0
 5934 2222 CF93      		push r28
 5935               	.LCFI150:
 5936 2224 DF93      		push r29
 5937               	.LCFI151:
 5938               	/* prologue: function */
 5939               	/* frame size = 0 */
 5940               	/* stack size = 2 */
 5941               	.L__stack_usage = 2
2794:switcherator.c ****     statusMsg[0] = 0;
 5942               		.loc 1 2794 0
 5943 2226 1092 0000 		sts statusMsg,__zero_reg__
2795:switcherator.c ****     strcat(statusMsg, "Swi:");
 5944               		.loc 1 2795 0
 5945 222a 60E0      		ldi r22,lo8(.LC26)
 5946 222c 70E0      		ldi r23,hi8(.LC26)
 5947 222e 80E0      		ldi r24,lo8(statusMsg)
 5948 2230 90E0      		ldi r25,hi8(statusMsg)
 5949 2232 0E94 0000 		call strcat
 5950               	.LVL414:
 5951 2236 C0E0      		ldi r28,lo8(switchStuff)
 5952 2238 D0E0      		ldi r29,hi8(switchStuff)
 5953               	.LVL415:
 5954               	.L446:
2799:switcherator.c ****         if (switchStuff[x] == 255) {
 5955               		.loc 1 2799 0
 5956 223a 8991      		ld r24,Y+
 5957 223c 8F3F      		cpi r24,lo8(-1)
 5958 223e 01F4      		brne .L443
2800:switcherator.c ****             strcat(statusMsg, "n");
 5959               		.loc 1 2800 0
 5960 2240 60E0      		ldi r22,lo8(.LC24)
 5961 2242 70E0      		ldi r23,hi8(.LC24)
 5962 2244 00C0      		rjmp .L448
 5963               	.L443:
2802:switcherator.c ****             strcat(statusMsg, "y");
 5964               		.loc 1 2802 0
 5965 2246 60E0      		ldi r22,lo8(.LC23)
 5966 2248 70E0      		ldi r23,hi8(.LC23)
 5967               	.L448:
 5968 224a 80E0      		ldi r24,lo8(statusMsg)
 5969 224c 90E0      		ldi r25,hi8(statusMsg)
 5970 224e 0E94 0000 		call strcat
 5971               	.LVL416:
2805:switcherator.c ****         if (strlen(statusMsg) > 30) {
 5972               		.loc 1 2805 0
 5973 2252 E0E0      		ldi r30,lo8(statusMsg)
 5974 2254 F0E0      		ldi r31,hi8(statusMsg)
 5975               		0:
 5976 2256 0190      		ld __tmp_reg__,Z+
 5977 2258 0020      		tst __tmp_reg__
 5978 225a 01F4      		brne 0b
 5979 225c 3197      		sbiw r30,1
 5980 225e E050      		subi r30,lo8(statusMsg)
 5981 2260 F040      		sbci r31,hi8(statusMsg)
 5982 2262 7F97      		sbiw r30,31
 5983 2264 00F0      		brlo .L445
2806:switcherator.c ****             sendMessage(statusMsg);
 5984               		.loc 1 2806 0
 5985 2266 80E0      		ldi r24,lo8(statusMsg)
 5986 2268 90E0      		ldi r25,hi8(statusMsg)
 5987 226a 0E94 0000 		call sendMessage
 5988               	.LVL417:
2807:switcherator.c ****             statusMsg[4] = 0;
 5989               		.loc 1 2807 0
 5990 226e 1092 0000 		sts statusMsg+4,__zero_reg__
 5991               	.L445:
2797:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 5992               		.loc 1 2797 0
 5993 2272 80E0      		ldi r24,hi8(switchStuff+16)
 5994 2274 C030      		cpi r28,lo8(switchStuff+16)
 5995 2276 D807      		cpc r29,r24
 5996 2278 01F4      		brne .L446
2810:switcherator.c ****     sendMessage(statusMsg);
 5997               		.loc 1 2810 0
 5998 227a 80E0      		ldi r24,lo8(statusMsg)
 5999 227c 90E0      		ldi r25,hi8(statusMsg)
 6000               	/* epilogue start */
2811:switcherator.c **** }
 6001               		.loc 1 2811 0
 6002 227e DF91      		pop r29
 6003 2280 CF91      		pop r28
2810:switcherator.c ****     sendMessage(statusMsg);
 6004               		.loc 1 2810 0
 6005 2282 0C94 0000 		jmp sendMessage
 6006               	.LVL418:
 6007               	.LFE65:
 6009               		.section	.rodata.str1.1
 6010               	.LC27:
 6011 007c 5072 6F67 		.string	"Progs:"
 6011      733A 00
 6012               		.text
 6013               	.global	programsProgrammed
 6015               	programsProgrammed:
 6016               	.LFB64:
2774:switcherator.c **** void programsProgrammed(void) {
 6017               		.loc 1 2774 0
 6018 2286 CF93      		push r28
 6019               	.LCFI152:
 6020 2288 DF93      		push r29
 6021               	.LCFI153:
 6022               	/* prologue: function */
 6023               	/* frame size = 0 */
 6024               	/* stack size = 2 */
 6025               	.L__stack_usage = 2
2775:switcherator.c ****     statusMsg[0] = 0;
 6026               		.loc 1 2775 0
 6027 228a 1092 0000 		sts statusMsg,__zero_reg__
2776:switcherator.c ****     strcat(statusMsg, "Progs:");
 6028               		.loc 1 2776 0
 6029 228e 60E0      		ldi r22,lo8(.LC27)
 6030 2290 70E0      		ldi r23,hi8(.LC27)
 6031 2292 80E0      		ldi r24,lo8(statusMsg)
 6032 2294 90E0      		ldi r25,hi8(statusMsg)
 6033 2296 0E94 0000 		call strcat
 6034               	.LVL419:
 6035 229a C0E0      		ldi r28,lo8(weeklyProgram+1)
 6036 229c D0E0      		ldi r29,hi8(weeklyProgram+1)
 6037               	.LVL420:
 6038               	.L453:
2774:switcherator.c **** void programsProgrammed(void) {
 6039               		.loc 1 2774 0
 6040 229e FE01      		movw r30,r28
 6041 22a0 3197      		sbiw r30,1
2779:switcherator.c ****         if (weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) {
 6042               		.loc 1 2779 0
 6043 22a2 8081      		ld r24,Z
 6044 22a4 8F3F      		cpi r24,lo8(-1)
 6045 22a6 01F4      		brne .L450
2779:switcherator.c ****         if (weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) {
 6046               		.loc 1 2779 0 is_stmt 0 discriminator 1
 6047 22a8 8881      		ld r24,Y
 6048 22aa 8F3F      		cpi r24,lo8(-1)
 6049 22ac 01F4      		brne .L450
2780:switcherator.c ****             strcat(statusMsg, "n");
 6050               		.loc 1 2780 0 is_stmt 1
 6051 22ae 60E0      		ldi r22,lo8(.LC24)
 6052 22b0 70E0      		ldi r23,hi8(.LC24)
 6053 22b2 00C0      		rjmp .L455
 6054               	.L450:
2782:switcherator.c ****             strcat(statusMsg, "y");
 6055               		.loc 1 2782 0
 6056 22b4 60E0      		ldi r22,lo8(.LC23)
 6057 22b6 70E0      		ldi r23,hi8(.LC23)
 6058               	.L455:
 6059 22b8 80E0      		ldi r24,lo8(statusMsg)
 6060 22ba 90E0      		ldi r25,hi8(statusMsg)
 6061 22bc 0E94 0000 		call strcat
 6062               	.LVL421:
2785:switcherator.c ****         if (strlen(statusMsg) > 30) {
 6063               		.loc 1 2785 0
 6064 22c0 E0E0      		ldi r30,lo8(statusMsg)
 6065 22c2 F0E0      		ldi r31,hi8(statusMsg)
 6066               		0:
 6067 22c4 0190      		ld __tmp_reg__,Z+
 6068 22c6 0020      		tst __tmp_reg__
 6069 22c8 01F4      		brne 0b
 6070 22ca 3197      		sbiw r30,1
 6071 22cc E050      		subi r30,lo8(statusMsg)
 6072 22ce F040      		sbci r31,hi8(statusMsg)
 6073 22d0 7F97      		sbiw r30,31
 6074 22d2 00F0      		brlo .L452
2786:switcherator.c ****             sendMessage(statusMsg);
 6075               		.loc 1 2786 0
 6076 22d4 80E0      		ldi r24,lo8(statusMsg)
 6077 22d6 90E0      		ldi r25,hi8(statusMsg)
 6078 22d8 0E94 0000 		call sendMessage
 6079               	.LVL422:
2787:switcherator.c ****             statusMsg[6] = 0;
 6080               		.loc 1 2787 0
 6081 22dc 1092 0000 		sts statusMsg+6,__zero_reg__
 6082               	.L452:
 6083 22e0 2A96      		adiw r28,10
2778:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 6084               		.loc 1 2778 0
 6085 22e2 80E0      		ldi r24,hi8(weeklyProgram+201)
 6086 22e4 C030      		cpi r28,lo8(weeklyProgram+201)
 6087 22e6 D807      		cpc r29,r24
 6088 22e8 01F4      		brne .L453
2790:switcherator.c ****     sendMessage(statusMsg);    
 6089               		.loc 1 2790 0
 6090 22ea 80E0      		ldi r24,lo8(statusMsg)
 6091 22ec 90E0      		ldi r25,hi8(statusMsg)
 6092               	/* epilogue start */
2791:switcherator.c **** }
 6093               		.loc 1 2791 0
 6094 22ee DF91      		pop r29
 6095 22f0 CF91      		pop r28
2790:switcherator.c ****     sendMessage(statusMsg);    
 6096               		.loc 1 2790 0
 6097 22f2 0C94 0000 		jmp sendMessage
 6098               	.LVL423:
 6099               	.LFE64:
 6101               		.section	.rodata.str1.1
 6102               	.LC28:
 6103 0083 5072 2C00 		.string	"Pr,"
 6104               	.LC29:
 6105 0087 2C53 772C 		.string	",Sw,"
 6105      00
 6106               	.LC30:
 6107 008c 2C49 6E2C 		.string	",In,"
 6107      00
 6108               	.LC31:
 6109 0091 2C4C 692C 		.string	",Li,"
 6109      00
 6110               	.LC32:
 6111 0096 2C43 432C 		.string	",CC,"
 6111      00
 6112               		.text
 6113               	.global	generalInformation
 6115               	generalInformation:
 6116               	.LFB63:
2710:switcherator.c **** void generalInformation(void) {
 6117               		.loc 1 2710 0
 6118               	/* prologue: function */
 6119               	/* frame size = 0 */
 6120               	/* stack size = 0 */
 6121               	.L__stack_usage = 0
2711:switcherator.c ****     statusMsg[0] = 0;
 6122               		.loc 1 2711 0
 6123 22f6 1092 0000 		sts statusMsg,__zero_reg__
2712:switcherator.c ****     strcat(statusMsg,"Pr,");
 6124               		.loc 1 2712 0
 6125 22fa 60E0      		ldi r22,lo8(.LC28)
 6126 22fc 70E0      		ldi r23,hi8(.LC28)
 6127 22fe 80E0      		ldi r24,lo8(statusMsg)
 6128 2300 90E0      		ldi r25,hi8(statusMsg)
 6129 2302 0E94 0000 		call strcat
 6130               	.LVL424:
 6131 2306 E0E0      		ldi r30,lo8(weeklyProgram+1)
 6132 2308 F0E0      		ldi r31,hi8(weeklyProgram+1)
2713:switcherator.c ****     int count = 0;
 6133               		.loc 1 2713 0
 6134 230a 80E0      		ldi r24,0
 6135 230c 90E0      		ldi r25,0
 6136               	.LVL425:
 6137               	.L459:
2710:switcherator.c **** void generalInformation(void) {
 6138               		.loc 1 2710 0
 6139 230e DF01      		movw r26,r30
 6140 2310 1197      		sbiw r26,1
2716:switcherator.c ****         if(weeklyProgram[x][0] < 255 || weeklyProgram[x][1] < 255) 
 6141               		.loc 1 2716 0
 6142 2312 2C91      		ld r18,X
 6143 2314 2F3F      		cpi r18,lo8(-1)
 6144 2316 01F4      		brne .L457
2716:switcherator.c ****         if(weeklyProgram[x][0] < 255 || weeklyProgram[x][1] < 255) 
 6145               		.loc 1 2716 0 is_stmt 0 discriminator 1
 6146 2318 2081      		ld r18,Z
 6147 231a 2F3F      		cpi r18,lo8(-1)
 6148 231c 01F0      		breq .L458
 6149               	.L457:
2717:switcherator.c ****             count++;
 6150               		.loc 1 2717 0 is_stmt 1
 6151 231e 0196      		adiw r24,1
 6152               	.LVL426:
 6153               	.L458:
 6154 2320 3A96      		adiw r30,10
2715:switcherator.c ****     for(x=0;x<MAX_PROGRAM;x++) {
 6155               		.loc 1 2715 0
 6156 2322 20E0      		ldi r18,hi8(weeklyProgram+201)
 6157 2324 E030      		cpi r30,lo8(weeklyProgram+201)
 6158 2326 F207      		cpc r31,r18
 6159 2328 01F4      		brne .L459
2719:switcherator.c ****     returnInt(count,tempLongString);
 6160               		.loc 1 2719 0
 6161 232a 60E0      		ldi r22,lo8(tempLongString)
 6162 232c 70E0      		ldi r23,hi8(tempLongString)
 6163 232e 0E94 0000 		call returnInt
 6164               	.LVL427:
2720:switcherator.c ****     strcat(statusMsg,tempLongString);
 6165               		.loc 1 2720 0
 6166 2332 60E0      		ldi r22,lo8(tempLongString)
 6167 2334 70E0      		ldi r23,hi8(tempLongString)
 6168 2336 80E0      		ldi r24,lo8(statusMsg)
 6169 2338 90E0      		ldi r25,hi8(statusMsg)
 6170 233a 0E94 0000 		call strcat
 6171               	.LVL428:
2721:switcherator.c ****     strcat(statusMsg,"/");
 6172               		.loc 1 2721 0
 6173 233e 60E0      		ldi r22,lo8(.LC3)
 6174 2340 70E0      		ldi r23,hi8(.LC3)
 6175 2342 80E0      		ldi r24,lo8(statusMsg)
 6176 2344 90E0      		ldi r25,hi8(statusMsg)
 6177 2346 0E94 0000 		call strcat
 6178               	.LVL429:
2722:switcherator.c ****     returnInt(MAX_PROGRAM,tempLongString);
 6179               		.loc 1 2722 0
 6180 234a 60E0      		ldi r22,lo8(tempLongString)
 6181 234c 70E0      		ldi r23,hi8(tempLongString)
 6182 234e 84E1      		ldi r24,lo8(20)
 6183 2350 90E0      		ldi r25,0
 6184 2352 0E94 0000 		call returnInt
 6185               	.LVL430:
2723:switcherator.c ****     strcat(statusMsg,tempLongString);
 6186               		.loc 1 2723 0
 6187 2356 60E0      		ldi r22,lo8(tempLongString)
 6188 2358 70E0      		ldi r23,hi8(tempLongString)
 6189 235a 80E0      		ldi r24,lo8(statusMsg)
 6190 235c 90E0      		ldi r25,hi8(statusMsg)
 6191 235e 0E94 0000 		call strcat
 6192               	.LVL431:
2724:switcherator.c ****     strcat(statusMsg,",Sw,");
 6193               		.loc 1 2724 0
 6194 2362 60E0      		ldi r22,lo8(.LC29)
 6195 2364 70E0      		ldi r23,hi8(.LC29)
 6196 2366 80E0      		ldi r24,lo8(statusMsg)
 6197 2368 90E0      		ldi r25,hi8(statusMsg)
 6198 236a 0E94 0000 		call strcat
 6199               	.LVL432:
 6200 236e E0E0      		ldi r30,lo8(switchStuff)
 6201 2370 F0E0      		ldi r31,hi8(switchStuff)
2725:switcherator.c ****     count = 0;
 6202               		.loc 1 2725 0
 6203 2372 80E0      		ldi r24,0
 6204 2374 90E0      		ldi r25,0
 6205               	.LVL433:
 6206               	.L461:
2727:switcherator.c ****         if (switchStuff[x] < 255)
 6207               		.loc 1 2727 0
 6208 2376 2191      		ld r18,Z+
 6209 2378 2F3F      		cpi r18,lo8(-1)
 6210 237a 01F0      		breq .L460
2728:switcherator.c ****             count ++;
 6211               		.loc 1 2728 0
 6212 237c 0196      		adiw r24,1
 6213               	.LVL434:
 6214               	.L460:
2726:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 6215               		.loc 1 2726 0
 6216 237e 20E0      		ldi r18,hi8(switchStuff+16)
 6217 2380 E030      		cpi r30,lo8(switchStuff+16)
 6218 2382 F207      		cpc r31,r18
 6219 2384 01F4      		brne .L461
2730:switcherator.c ****     returnInt(count,tempLongString);
 6220               		.loc 1 2730 0
 6221 2386 60E0      		ldi r22,lo8(tempLongString)
 6222 2388 70E0      		ldi r23,hi8(tempLongString)
 6223 238a 0E94 0000 		call returnInt
 6224               	.LVL435:
2731:switcherator.c ****     strcat(statusMsg,tempLongString);
 6225               		.loc 1 2731 0
 6226 238e 60E0      		ldi r22,lo8(tempLongString)
 6227 2390 70E0      		ldi r23,hi8(tempLongString)
 6228 2392 80E0      		ldi r24,lo8(statusMsg)
 6229 2394 90E0      		ldi r25,hi8(statusMsg)
 6230 2396 0E94 0000 		call strcat
 6231               	.LVL436:
2732:switcherator.c ****     strcat(statusMsg,"/");
 6232               		.loc 1 2732 0
 6233 239a 60E0      		ldi r22,lo8(.LC3)
 6234 239c 70E0      		ldi r23,hi8(.LC3)
 6235 239e 80E0      		ldi r24,lo8(statusMsg)
 6236 23a0 90E0      		ldi r25,hi8(statusMsg)
 6237 23a2 0E94 0000 		call strcat
 6238               	.LVL437:
2733:switcherator.c ****     returnInt(NUM_SWITCHES,tempLongString);
 6239               		.loc 1 2733 0
 6240 23a6 60E0      		ldi r22,lo8(tempLongString)
 6241 23a8 70E0      		ldi r23,hi8(tempLongString)
 6242 23aa 80E1      		ldi r24,lo8(16)
 6243 23ac 90E0      		ldi r25,0
 6244 23ae 0E94 0000 		call returnInt
 6245               	.LVL438:
2734:switcherator.c ****     strcat(statusMsg,tempLongString);
 6246               		.loc 1 2734 0
 6247 23b2 60E0      		ldi r22,lo8(tempLongString)
 6248 23b4 70E0      		ldi r23,hi8(tempLongString)
 6249 23b6 80E0      		ldi r24,lo8(statusMsg)
 6250 23b8 90E0      		ldi r25,hi8(statusMsg)
 6251 23ba 0E94 0000 		call strcat
 6252               	.LVL439:
2735:switcherator.c ****     sendMessage(statusMsg);
 6253               		.loc 1 2735 0
 6254 23be 80E0      		ldi r24,lo8(statusMsg)
 6255 23c0 90E0      		ldi r25,hi8(statusMsg)
 6256 23c2 0E94 0000 		call sendMessage
 6257               	.LVL440:
2736:switcherator.c ****     statusMsg[0] = 0;
 6258               		.loc 1 2736 0
 6259 23c6 1092 0000 		sts statusMsg,__zero_reg__
2737:switcherator.c ****     strcat(statusMsg,",In,");
 6260               		.loc 1 2737 0
 6261 23ca 60E0      		ldi r22,lo8(.LC30)
 6262 23cc 70E0      		ldi r23,hi8(.LC30)
 6263 23ce 80E0      		ldi r24,lo8(statusMsg)
 6264 23d0 90E0      		ldi r25,hi8(statusMsg)
 6265 23d2 0E94 0000 		call strcat
 6266               	.LVL441:
 6267 23d6 E0E0      		ldi r30,lo8(inputs)
 6268 23d8 F0E0      		ldi r31,hi8(inputs)
2738:switcherator.c ****     count = 0;
 6269               		.loc 1 2738 0
 6270 23da 80E0      		ldi r24,0
 6271 23dc 90E0      		ldi r25,0
 6272               	.LVL442:
 6273               	.L463:
2740:switcherator.c ****         if (inputs[x][0] < 255)
 6274               		.loc 1 2740 0
 6275 23de 2081      		ld r18,Z
 6276 23e0 2F3F      		cpi r18,lo8(-1)
 6277 23e2 01F0      		breq .L462
2741:switcherator.c ****             count ++;
 6278               		.loc 1 2741 0
 6279 23e4 0196      		adiw r24,1
 6280               	.LVL443:
 6281               	.L462:
 6282 23e6 3896      		adiw r30,8
2739:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 6283               		.loc 1 2739 0
 6284 23e8 20E0      		ldi r18,hi8(inputs+32)
 6285 23ea E030      		cpi r30,lo8(inputs+32)
 6286 23ec F207      		cpc r31,r18
 6287 23ee 01F4      		brne .L463
2743:switcherator.c ****     returnInt(count,tempLongString);
 6288               		.loc 1 2743 0
 6289 23f0 60E0      		ldi r22,lo8(tempLongString)
 6290 23f2 70E0      		ldi r23,hi8(tempLongString)
 6291 23f4 0E94 0000 		call returnInt
 6292               	.LVL444:
2744:switcherator.c ****     strcat(statusMsg,tempLongString);
 6293               		.loc 1 2744 0
 6294 23f8 60E0      		ldi r22,lo8(tempLongString)
 6295 23fa 70E0      		ldi r23,hi8(tempLongString)
 6296 23fc 80E0      		ldi r24,lo8(statusMsg)
 6297 23fe 90E0      		ldi r25,hi8(statusMsg)
 6298 2400 0E94 0000 		call strcat
 6299               	.LVL445:
2745:switcherator.c ****     strcat(statusMsg,"/");
 6300               		.loc 1 2745 0
 6301 2404 60E0      		ldi r22,lo8(.LC3)
 6302 2406 70E0      		ldi r23,hi8(.LC3)
 6303 2408 80E0      		ldi r24,lo8(statusMsg)
 6304 240a 90E0      		ldi r25,hi8(statusMsg)
 6305 240c 0E94 0000 		call strcat
 6306               	.LVL446:
2746:switcherator.c ****     returnInt(NUM_INPUTS,tempLongString);
 6307               		.loc 1 2746 0
 6308 2410 60E0      		ldi r22,lo8(tempLongString)
 6309 2412 70E0      		ldi r23,hi8(tempLongString)
 6310 2414 84E0      		ldi r24,lo8(4)
 6311 2416 90E0      		ldi r25,0
 6312 2418 0E94 0000 		call returnInt
 6313               	.LVL447:
2747:switcherator.c ****     strcat(statusMsg,tempLongString);
 6314               		.loc 1 2747 0
 6315 241c 60E0      		ldi r22,lo8(tempLongString)
 6316 241e 70E0      		ldi r23,hi8(tempLongString)
 6317 2420 80E0      		ldi r24,lo8(statusMsg)
 6318 2422 90E0      		ldi r25,hi8(statusMsg)
 6319 2424 0E94 0000 		call strcat
 6320               	.LVL448:
2748:switcherator.c ****     strcat(statusMsg,",Li,");
 6321               		.loc 1 2748 0
 6322 2428 60E0      		ldi r22,lo8(.LC31)
 6323 242a 70E0      		ldi r23,hi8(.LC31)
 6324 242c 80E0      		ldi r24,lo8(statusMsg)
 6325 242e 90E0      		ldi r25,hi8(statusMsg)
 6326 2430 0E94 0000 		call strcat
 6327               	.LVL449:
 6328 2434 E0E0      		ldi r30,lo8(inputs+2)
 6329 2436 F0E0      		ldi r31,hi8(inputs+2)
2749:switcherator.c ****     count = 0;
 6330               		.loc 1 2749 0
 6331 2438 80E0      		ldi r24,0
 6332 243a 90E0      		ldi r25,0
 6333               	.LVL450:
 6334               	.L465:
2751:switcherator.c ****         if (inputs[x][2] > 0)
 6335               		.loc 1 2751 0
 6336 243c 2081      		ld r18,Z
 6337 243e 2111      		cpse r18,__zero_reg__
2752:switcherator.c ****             count ++;
 6338               		.loc 1 2752 0
 6339 2440 0196      		adiw r24,1
 6340               	.LVL451:
 6341               	.L464:
 6342 2442 3896      		adiw r30,8
2750:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++) {
 6343               		.loc 1 2750 0
 6344 2444 20E0      		ldi r18,hi8(inputs+34)
 6345 2446 E030      		cpi r30,lo8(inputs+34)
 6346 2448 F207      		cpc r31,r18
 6347 244a 01F4      		brne .L465
2754:switcherator.c ****     returnInt(count,tempLongString);
 6348               		.loc 1 2754 0
 6349 244c 60E0      		ldi r22,lo8(tempLongString)
 6350 244e 70E0      		ldi r23,hi8(tempLongString)
 6351 2450 0E94 0000 		call returnInt
 6352               	.LVL452:
2755:switcherator.c ****     strcat(statusMsg,tempLongString);
 6353               		.loc 1 2755 0
 6354 2454 60E0      		ldi r22,lo8(tempLongString)
 6355 2456 70E0      		ldi r23,hi8(tempLongString)
 6356 2458 80E0      		ldi r24,lo8(statusMsg)
 6357 245a 90E0      		ldi r25,hi8(statusMsg)
 6358 245c 0E94 0000 		call strcat
 6359               	.LVL453:
2756:switcherator.c ****     strcat(statusMsg,"/");
 6360               		.loc 1 2756 0
 6361 2460 60E0      		ldi r22,lo8(.LC3)
 6362 2462 70E0      		ldi r23,hi8(.LC3)
 6363 2464 80E0      		ldi r24,lo8(statusMsg)
 6364 2466 90E0      		ldi r25,hi8(statusMsg)
 6365 2468 0E94 0000 		call strcat
 6366               	.LVL454:
2757:switcherator.c ****     returnInt(NUM_LIMITS,tempLongString);
 6367               		.loc 1 2757 0
 6368 246c 60E0      		ldi r22,lo8(tempLongString)
 6369 246e 70E0      		ldi r23,hi8(tempLongString)
 6370 2470 84E0      		ldi r24,lo8(4)
 6371 2472 90E0      		ldi r25,0
 6372 2474 0E94 0000 		call returnInt
 6373               	.LVL455:
2758:switcherator.c ****     strcat(statusMsg,tempLongString);
 6374               		.loc 1 2758 0
 6375 2478 60E0      		ldi r22,lo8(tempLongString)
 6376 247a 70E0      		ldi r23,hi8(tempLongString)
 6377 247c 80E0      		ldi r24,lo8(statusMsg)
 6378 247e 90E0      		ldi r25,hi8(statusMsg)
 6379 2480 0E94 0000 		call strcat
 6380               	.LVL456:
2759:switcherator.c ****     strcat(statusMsg,",CC,");
 6381               		.loc 1 2759 0
 6382 2484 60E0      		ldi r22,lo8(.LC32)
 6383 2486 70E0      		ldi r23,hi8(.LC32)
 6384 2488 80E0      		ldi r24,lo8(statusMsg)
 6385 248a 90E0      		ldi r25,hi8(statusMsg)
 6386 248c 0E94 0000 		call strcat
 6387               	.LVL457:
 6388 2490 E0E0      		ldi r30,lo8(colorChanges+2)
 6389 2492 F0E0      		ldi r31,hi8(colorChanges+2)
2760:switcherator.c ****     count = 0;
 6390               		.loc 1 2760 0
 6391 2494 80E0      		ldi r24,0
 6392 2496 90E0      		ldi r25,0
 6393               	.LVL458:
 6394               	.L468:
2710:switcherator.c **** void generalInformation(void) {
 6395               		.loc 1 2710 0
 6396 2498 DF01      		movw r26,r30
 6397 249a 1297      		sbiw r26,2
2762:switcherator.c ****         if (colorChanges[x][0] != 0 || colorChanges[x][1] != 1 || colorChanges[x][2] != 0)
 6398               		.loc 1 2762 0
 6399 249c 2C91      		ld r18,X
 6400 249e 2111      		cpse r18,__zero_reg__
 6401 24a0 00C0      		rjmp .L466
2710:switcherator.c **** void generalInformation(void) {
 6402               		.loc 1 2710 0 discriminator 1
 6403 24a2 DF01      		movw r26,r30
 6404 24a4 1197      		sbiw r26,1
2762:switcherator.c ****         if (colorChanges[x][0] != 0 || colorChanges[x][1] != 1 || colorChanges[x][2] != 0)
 6405               		.loc 1 2762 0 discriminator 1
 6406 24a6 2C91      		ld r18,X
 6407 24a8 2130      		cpi r18,lo8(1)
 6408 24aa 01F4      		brne .L466
 6409 24ac 2081      		ld r18,Z
 6410 24ae 2111      		cpse r18,__zero_reg__
 6411               	.L466:
2763:switcherator.c ****             count ++;
 6412               		.loc 1 2763 0
 6413 24b0 0196      		adiw r24,1
 6414               	.LVL459:
 6415               	.L467:
 6416 24b2 3396      		adiw r30,3
2761:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 6417               		.loc 1 2761 0
 6418 24b4 20E0      		ldi r18,hi8(colorChanges+20)
 6419 24b6 E030      		cpi r30,lo8(colorChanges+20)
 6420 24b8 F207      		cpc r31,r18
 6421 24ba 01F4      		brne .L468
2765:switcherator.c ****     returnInt(count,tempLongString);
 6422               		.loc 1 2765 0
 6423 24bc 60E0      		ldi r22,lo8(tempLongString)
 6424 24be 70E0      		ldi r23,hi8(tempLongString)
 6425 24c0 0E94 0000 		call returnInt
 6426               	.LVL460:
2766:switcherator.c ****     strcat(statusMsg,tempLongString);
 6427               		.loc 1 2766 0
 6428 24c4 60E0      		ldi r22,lo8(tempLongString)
 6429 24c6 70E0      		ldi r23,hi8(tempLongString)
 6430 24c8 80E0      		ldi r24,lo8(statusMsg)
 6431 24ca 90E0      		ldi r25,hi8(statusMsg)
 6432 24cc 0E94 0000 		call strcat
 6433               	.LVL461:
2767:switcherator.c ****     strcat(statusMsg,"/");
 6434               		.loc 1 2767 0
 6435 24d0 60E0      		ldi r22,lo8(.LC3)
 6436 24d2 70E0      		ldi r23,hi8(.LC3)
 6437 24d4 80E0      		ldi r24,lo8(statusMsg)
 6438 24d6 90E0      		ldi r25,hi8(statusMsg)
 6439 24d8 0E94 0000 		call strcat
 6440               	.LVL462:
2768:switcherator.c ****     returnInt(NUM_COLOR_CHANGES,tempLongString);
 6441               		.loc 1 2768 0
 6442 24dc 60E0      		ldi r22,lo8(tempLongString)
 6443 24de 70E0      		ldi r23,hi8(tempLongString)
 6444 24e0 86E0      		ldi r24,lo8(6)
 6445 24e2 90E0      		ldi r25,0
 6446 24e4 0E94 0000 		call returnInt
 6447               	.LVL463:
2769:switcherator.c ****     strcat(statusMsg,tempLongString);
 6448               		.loc 1 2769 0
 6449 24e8 60E0      		ldi r22,lo8(tempLongString)
 6450 24ea 70E0      		ldi r23,hi8(tempLongString)
 6451 24ec 80E0      		ldi r24,lo8(statusMsg)
 6452 24ee 90E0      		ldi r25,hi8(statusMsg)
 6453 24f0 0E94 0000 		call strcat
 6454               	.LVL464:
2770:switcherator.c ****     sendMessage(statusMsg);
 6455               		.loc 1 2770 0
 6456 24f4 80E0      		ldi r24,lo8(statusMsg)
 6457 24f6 90E0      		ldi r25,hi8(statusMsg)
 6458 24f8 0C94 0000 		jmp sendMessage
 6459               	.LVL465:
 6460               	.LFE63:
 6462               		.section	.rodata.str1.1
 6463               	.LC33:
 6464 009b 2054 3A78 		.string	" T:xx/xx/xxxx xx:xx:xx"
 6464      782F 7878 
 6464      2F78 7878 
 6464      7820 7878 
 6464      3A78 783A 
 6465               	.LC34:
 6466 00b2 2054 3A00 		.string	" T:"
 6467               		.text
 6468               	.global	generalStatus
 6470               	generalStatus:
 6471               	.LFB62:
2670:switcherator.c **** void generalStatus(char * commandReceived) {
 6472               		.loc 1 2670 0
 6473               	.LVL466:
 6474 24fc CF93      		push r28
 6475               	.LCFI154:
 6476 24fe DF93      		push r29
 6477               	.LCFI155:
 6478               	/* prologue: function */
 6479               	/* frame size = 0 */
 6480               	/* stack size = 2 */
 6481               	.L__stack_usage = 2
 6482 2500 EC01      		movw r28,r24
2671:switcherator.c ****     statusMsg[0] = 0;
 6483               		.loc 1 2671 0
 6484 2502 1092 0000 		sts statusMsg,__zero_reg__
2672:switcherator.c ****     tempIntString[0] = commandReceived[2];
 6485               		.loc 1 2672 0
 6486 2506 8A81      		ldd r24,Y+2
 6487               	.LVL467:
 6488 2508 8093 0000 		sts tempIntString,r24
2673:switcherator.c ****     tempIntString[1] = commandReceived[3];
 6489               		.loc 1 2673 0
 6490 250c 8B81      		ldd r24,Y+3
 6491 250e 8093 0000 		sts tempIntString+1,r24
2676:switcherator.c ****     if (panicMyClockIsNotSet == 1) {
 6492               		.loc 1 2676 0
 6493 2512 8091 0000 		lds r24,panicMyClockIsNotSet
 6494 2516 8130      		cpi r24,lo8(1)
 6495 2518 01F4      		brne .L490
2677:switcherator.c ****         strcat(statusMsg, " T:xx/xx/xxxx xx:xx:xx");
 6496               		.loc 1 2677 0
 6497 251a 60E0      		ldi r22,lo8(.LC33)
 6498 251c 70E0      		ldi r23,hi8(.LC33)
 6499 251e 00C0      		rjmp .L493
 6500               	.L490:
2679:switcherator.c ****         strcat(statusMsg, " T:");
 6501               		.loc 1 2679 0
 6502 2520 60E0      		ldi r22,lo8(.LC34)
 6503 2522 70E0      		ldi r23,hi8(.LC34)
 6504 2524 80E0      		ldi r24,lo8(statusMsg)
 6505 2526 90E0      		ldi r25,hi8(statusMsg)
 6506 2528 0E94 0000 		call strcat
 6507               	.LVL468:
2680:switcherator.c ****         returnInt(globalMonth, tempLongString);
 6508               		.loc 1 2680 0
 6509 252c 60E0      		ldi r22,lo8(tempLongString)
 6510 252e 70E0      		ldi r23,hi8(tempLongString)
 6511 2530 8091 0000 		lds r24,globalMonth
 6512 2534 9091 0000 		lds r25,globalMonth+1
 6513 2538 0E94 0000 		call returnInt
 6514               	.LVL469:
2681:switcherator.c ****         strcat(statusMsg, tempLongString);
 6515               		.loc 1 2681 0
 6516 253c 60E0      		ldi r22,lo8(tempLongString)
 6517 253e 70E0      		ldi r23,hi8(tempLongString)
 6518 2540 80E0      		ldi r24,lo8(statusMsg)
 6519 2542 90E0      		ldi r25,hi8(statusMsg)
 6520 2544 0E94 0000 		call strcat
 6521               	.LVL470:
2682:switcherator.c ****         strcat(statusMsg, "/");
 6522               		.loc 1 2682 0
 6523 2548 60E0      		ldi r22,lo8(.LC3)
 6524 254a 70E0      		ldi r23,hi8(.LC3)
 6525 254c 80E0      		ldi r24,lo8(statusMsg)
 6526 254e 90E0      		ldi r25,hi8(statusMsg)
 6527 2550 0E94 0000 		call strcat
 6528               	.LVL471:
2683:switcherator.c ****         returnInt(globalDay, tempLongString);
 6529               		.loc 1 2683 0
 6530 2554 60E0      		ldi r22,lo8(tempLongString)
 6531 2556 70E0      		ldi r23,hi8(tempLongString)
 6532 2558 8091 0000 		lds r24,globalDay
 6533 255c 9091 0000 		lds r25,globalDay+1
 6534 2560 0E94 0000 		call returnInt
 6535               	.LVL472:
2684:switcherator.c ****         strcat(statusMsg, tempLongString);
 6536               		.loc 1 2684 0
 6537 2564 60E0      		ldi r22,lo8(tempLongString)
 6538 2566 70E0      		ldi r23,hi8(tempLongString)
 6539 2568 80E0      		ldi r24,lo8(statusMsg)
 6540 256a 90E0      		ldi r25,hi8(statusMsg)
 6541 256c 0E94 0000 		call strcat
 6542               	.LVL473:
2685:switcherator.c ****         strcat(statusMsg, "/");
 6543               		.loc 1 2685 0
 6544 2570 60E0      		ldi r22,lo8(.LC3)
 6545 2572 70E0      		ldi r23,hi8(.LC3)
 6546 2574 80E0      		ldi r24,lo8(statusMsg)
 6547 2576 90E0      		ldi r25,hi8(statusMsg)
 6548 2578 0E94 0000 		call strcat
 6549               	.LVL474:
2686:switcherator.c ****         returnInt(globalYear, tempLongString);
 6550               		.loc 1 2686 0
 6551 257c 60E0      		ldi r22,lo8(tempLongString)
 6552 257e 70E0      		ldi r23,hi8(tempLongString)
 6553 2580 8091 0000 		lds r24,globalYear
 6554 2584 9091 0000 		lds r25,globalYear+1
 6555 2588 0E94 0000 		call returnInt
 6556               	.LVL475:
2687:switcherator.c ****         strcat(statusMsg, tempLongString);
 6557               		.loc 1 2687 0
 6558 258c 60E0      		ldi r22,lo8(tempLongString)
 6559 258e 70E0      		ldi r23,hi8(tempLongString)
 6560 2590 80E0      		ldi r24,lo8(statusMsg)
 6561 2592 90E0      		ldi r25,hi8(statusMsg)
 6562 2594 0E94 0000 		call strcat
 6563               	.LVL476:
2688:switcherator.c ****         strcat(statusMsg, " ");
 6564               		.loc 1 2688 0
 6565 2598 60E0      		ldi r22,lo8(.LC2)
 6566 259a 70E0      		ldi r23,hi8(.LC2)
 6567 259c 80E0      		ldi r24,lo8(statusMsg)
 6568 259e 90E0      		ldi r25,hi8(statusMsg)
 6569 25a0 0E94 0000 		call strcat
 6570               	.LVL477:
2689:switcherator.c ****         returnInt(globalHour, tempLongString);
 6571               		.loc 1 2689 0
 6572 25a4 60E0      		ldi r22,lo8(tempLongString)
 6573 25a6 70E0      		ldi r23,hi8(tempLongString)
 6574 25a8 8091 0000 		lds r24,globalHour
 6575 25ac 9091 0000 		lds r25,globalHour+1
 6576 25b0 0E94 0000 		call returnInt
 6577               	.LVL478:
2690:switcherator.c ****         strcat(statusMsg, tempLongString);
 6578               		.loc 1 2690 0
 6579 25b4 60E0      		ldi r22,lo8(tempLongString)
 6580 25b6 70E0      		ldi r23,hi8(tempLongString)
 6581 25b8 80E0      		ldi r24,lo8(statusMsg)
 6582 25ba 90E0      		ldi r25,hi8(statusMsg)
 6583 25bc 0E94 0000 		call strcat
 6584               	.LVL479:
2691:switcherator.c ****         strcat(statusMsg, ":");
 6585               		.loc 1 2691 0
 6586 25c0 60E0      		ldi r22,lo8(.LC4)
 6587 25c2 70E0      		ldi r23,hi8(.LC4)
 6588 25c4 80E0      		ldi r24,lo8(statusMsg)
 6589 25c6 90E0      		ldi r25,hi8(statusMsg)
 6590 25c8 0E94 0000 		call strcat
 6591               	.LVL480:
2692:switcherator.c ****         returnInt(globalMinute, tempLongString);
 6592               		.loc 1 2692 0
 6593 25cc 60E0      		ldi r22,lo8(tempLongString)
 6594 25ce 70E0      		ldi r23,hi8(tempLongString)
 6595 25d0 8091 0000 		lds r24,globalMinute
 6596 25d4 9091 0000 		lds r25,globalMinute+1
 6597 25d8 0E94 0000 		call returnInt
 6598               	.LVL481:
2693:switcherator.c ****         strcat(statusMsg, tempLongString);
 6599               		.loc 1 2693 0
 6600 25dc 60E0      		ldi r22,lo8(tempLongString)
 6601 25de 70E0      		ldi r23,hi8(tempLongString)
 6602 25e0 80E0      		ldi r24,lo8(statusMsg)
 6603 25e2 90E0      		ldi r25,hi8(statusMsg)
 6604 25e4 0E94 0000 		call strcat
 6605               	.LVL482:
2694:switcherator.c ****         strcat(statusMsg, ":");
 6606               		.loc 1 2694 0
 6607 25e8 60E0      		ldi r22,lo8(.LC4)
 6608 25ea 70E0      		ldi r23,hi8(.LC4)
 6609 25ec 80E0      		ldi r24,lo8(statusMsg)
 6610 25ee 90E0      		ldi r25,hi8(statusMsg)
 6611 25f0 0E94 0000 		call strcat
 6612               	.LVL483:
2695:switcherator.c ****         returnInt(globalSecond, tempLongString);
 6613               		.loc 1 2695 0
 6614 25f4 60E0      		ldi r22,lo8(tempLongString)
 6615 25f6 70E0      		ldi r23,hi8(tempLongString)
 6616 25f8 8091 0000 		lds r24,globalSecond
 6617 25fc 9091 0000 		lds r25,globalSecond+1
 6618 2600 0E94 0000 		call returnInt
 6619               	.LVL484:
2696:switcherator.c ****         strcat(statusMsg, tempLongString);
 6620               		.loc 1 2696 0
 6621 2604 60E0      		ldi r22,lo8(tempLongString)
 6622 2606 70E0      		ldi r23,hi8(tempLongString)
 6623               	.L493:
 6624 2608 80E0      		ldi r24,lo8(statusMsg)
 6625 260a 90E0      		ldi r25,hi8(statusMsg)
 6626 260c 0E94 0000 		call strcat
 6627               	.LVL485:
2698:switcherator.c ****     sendMessage(statusMsg);
 6628               		.loc 1 2698 0
 6629 2610 80E0      		ldi r24,lo8(statusMsg)
 6630 2612 90E0      		ldi r25,hi8(statusMsg)
 6631 2614 0E94 0000 		call sendMessage
 6632               	.LVL486:
2699:switcherator.c ****     statusMsg[0] = 0;
 6633               		.loc 1 2699 0
 6634 2618 1092 0000 		sts statusMsg,__zero_reg__
2700:switcherator.c ****     if (commandReceived[2] == 'q')
 6635               		.loc 1 2700 0
 6636 261c 8A81      		ldd r24,Y+2
 6637 261e 8137      		cpi r24,lo8(113)
 6638 2620 01F0      		breq .L489
2703:switcherator.c ****     programsProgrammed();
 6639               		.loc 1 2703 0
 6640 2622 0E94 0000 		call programsProgrammed
 6641               	.LVL487:
2704:switcherator.c ****     switchesProgrammed();
 6642               		.loc 1 2704 0
 6643 2626 0E94 0000 		call switchesProgrammed
 6644               	.LVL488:
2705:switcherator.c ****     inputsProgrammed();
 6645               		.loc 1 2705 0
 6646 262a 0E94 0000 		call inputsProgrammed
 6647               	.LVL489:
 6648               	/* epilogue start */
2707:switcherator.c **** }
 6649               		.loc 1 2707 0
 6650 262e DF91      		pop r29
 6651 2630 CF91      		pop r28
 6652               	.LVL490:
2706:switcherator.c ****     switchesOn();
 6653               		.loc 1 2706 0
 6654 2632 0C94 0000 		jmp switchesOn
 6655               	.LVL491:
 6656               	.L489:
 6657               	/* epilogue start */
2707:switcherator.c **** }
 6658               		.loc 1 2707 0
 6659 2636 DF91      		pop r29
 6660 2638 CF91      		pop r28
 6661               	.LVL492:
 6662 263a 0895      		ret
 6663               	.LFE62:
 6665               		.section	.rodata.str1.1
 6666               	.LC35:
 6667 00b6 5072 6F67 		.string	"Prog#"
 6667      2300 
 6668               	.LC36:
 6669 00bc 626C 616E 		.string	"blank."
 6669      6B2E 00
 6670               	.LC37:
 6671 00c3 533A 2D00 		.string	"S:-"
 6672               	.LC38:
 6673 00c7 5300      		.string	"S"
 6674               	.LC39:
 6675 00c9 542D 00   		.string	"T-"
 6676               	.LC40:
 6677 00cc 2044 7572 		.string	" Dur:"
 6677      3A00 
 6678               	.LC41:
 6679 00d2 2044 3A00 		.string	" D:"
 6680               	.LC42:
 6681 00d6 2D2D 2D2D 		.string	"-------"
 6681      2D2D 2D00 
 6682               	.LC43:
 6683 00de 2D00      		.string	"-"
 6684               	.LC44:
 6685 00e0 4D00      		.string	"M"
 6686               	.LC45:
 6687 00e2 5400      		.string	"T"
 6688               	.LC46:
 6689 00e4 5700      		.string	"W"
 6690               	.LC47:
 6691 00e6 4600      		.string	"F"
 6692               		.text
 6693               	.global	programDisplay
 6695               	programDisplay:
 6696               	.LFB38:
1528:switcherator.c **** void programDisplay(char * commandReceived) {
 6697               		.loc 1 1528 0
 6698               	.LVL493:
 6699 263c 8F92      		push r8
 6700               	.LCFI156:
 6701 263e 9F92      		push r9
 6702               	.LCFI157:
 6703 2640 AF92      		push r10
 6704               	.LCFI158:
 6705 2642 BF92      		push r11
 6706               	.LCFI159:
 6707 2644 CF92      		push r12
 6708               	.LCFI160:
 6709 2646 DF92      		push r13
 6710               	.LCFI161:
 6711 2648 EF92      		push r14
 6712               	.LCFI162:
 6713 264a FF92      		push r15
 6714               	.LCFI163:
 6715 264c 0F93      		push r16
 6716               	.LCFI164:
 6717 264e 1F93      		push r17
 6718               	.LCFI165:
 6719 2650 CF93      		push r28
 6720               	.LCFI166:
 6721 2652 DF93      		push r29
 6722               	.LCFI167:
 6723 2654 CDB7      		in r28,__SP_L__
 6724 2656 DEB7      		in r29,__SP_H__
 6725               	.LCFI168:
 6726 2658 6097      		sbiw r28,16
 6727               	.LCFI169:
 6728 265a 0FB6      		in __tmp_reg__,__SREG__
 6729 265c F894      		cli
 6730 265e DEBF      		out __SP_H__,r29
 6731 2660 0FBE      		out __SREG__,__tmp_reg__
 6732 2662 CDBF      		out __SP_L__,r28
 6733               	/* prologue: function */
 6734               	/* frame size = 16 */
 6735               	/* stack size = 28 */
 6736               	.L__stack_usage = 28
 6737               	.LVL494:
1531:switcherator.c ****     tempIntString[0] = commandReceived[3];
 6738               		.loc 1 1531 0
 6739 2664 FC01      		movw r30,r24
 6740 2666 2381      		ldd r18,Z+3
 6741 2668 2093 0000 		sts tempIntString,r18
1532:switcherator.c ****     tempIntString[1] = commandReceived[4];
 6742               		.loc 1 1532 0
 6743 266c 8481      		ldd r24,Z+4
 6744               	.LVL495:
 6745 266e 8093 0000 		sts tempIntString+1,r24
1533:switcherator.c ****     programNumber = atoi(tempIntString);
 6746               		.loc 1 1533 0
 6747 2672 80E0      		ldi r24,lo8(tempIntString)
 6748 2674 90E0      		ldi r25,hi8(tempIntString)
 6749 2676 0E94 0000 		call atoi
 6750               	.LVL496:
 6751 267a 8C01      		movw r16,r24
 6752               	.LVL497:
1534:switcherator.c ****     statusMsg[0] = 0;
 6753               		.loc 1 1534 0
 6754 267c 1092 0000 		sts statusMsg,__zero_reg__
1535:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 6755               		.loc 1 1535 0
 6756 2680 8AE0      		ldi r24,lo8(10)
 6757 2682 809F      		mul r24,r16
 6758 2684 F001      		movw r30,r0
 6759 2686 819F      		mul r24,r17
 6760 2688 F00D      		add r31,r0
 6761 268a 1124      		clr __zero_reg__
 6762 268c E050      		subi r30,lo8(-(weeklyProgram))
 6763 268e F040      		sbci r31,hi8(-(weeklyProgram))
 6764 2690 8081      		ld r24,Z
 6765 2692 8F3F      		cpi r24,lo8(-1)
 6766 2694 01F4      		brne .L495
1535:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 6767               		.loc 1 1535 0 is_stmt 0 discriminator 1
 6768 2696 8181      		ldd r24,Z+1
 6769 2698 8F3F      		cpi r24,lo8(-1)
 6770 269a 01F4      		brne .L495
1536:switcherator.c ****         strcat(statusMsg, "Prog#");
 6771               		.loc 1 1536 0 is_stmt 1
 6772 269c 60E0      		ldi r22,lo8(.LC35)
 6773 269e 70E0      		ldi r23,hi8(.LC35)
 6774 26a0 80E0      		ldi r24,lo8(statusMsg)
 6775 26a2 90E0      		ldi r25,hi8(statusMsg)
 6776 26a4 0E94 0000 		call strcat
 6777               	.LVL498:
1537:switcherator.c ****         returnInt(programNumber, tempIntString);
 6778               		.loc 1 1537 0
 6779 26a8 60E0      		ldi r22,lo8(tempIntString)
 6780 26aa 70E0      		ldi r23,hi8(tempIntString)
 6781 26ac C801      		movw r24,r16
 6782 26ae 0E94 0000 		call returnInt
 6783               	.LVL499:
1538:switcherator.c ****         strcat(statusMsg, tempIntString);
 6784               		.loc 1 1538 0
 6785 26b2 60E0      		ldi r22,lo8(tempIntString)
 6786 26b4 70E0      		ldi r23,hi8(tempIntString)
 6787 26b6 80E0      		ldi r24,lo8(statusMsg)
 6788 26b8 90E0      		ldi r25,hi8(statusMsg)
 6789 26ba 0E94 0000 		call strcat
 6790               	.LVL500:
1539:switcherator.c ****         strcat(statusMsg, "blank.");
 6791               		.loc 1 1539 0
 6792 26be 60E0      		ldi r22,lo8(.LC36)
 6793 26c0 70E0      		ldi r23,hi8(.LC36)
 6794 26c2 00C0      		rjmp .L524
 6795               	.L495:
1544:switcherator.c ****     switches[0] = 0;
 6796               		.loc 1 1544 0
 6797 26c4 1982      		std Y+1,__zero_reg__
 6798               	.LVL501:
1546:switcherator.c ****     switchCount = programGetSwitches(programNumber, switches);
 6799               		.loc 1 1546 0
 6800 26c6 BE01      		movw r22,r28
 6801 26c8 6F5F      		subi r22,-1
 6802 26ca 7F4F      		sbci r23,-1
 6803 26cc C801      		movw r24,r16
 6804 26ce 0E94 0000 		call programGetSwitches
 6805               	.LVL502:
 6806 26d2 6C01      		movw r12,r24
 6807               	.LVL503:
1547:switcherator.c ****     statusMsg[0] = 0;
 6808               		.loc 1 1547 0
 6809 26d4 1092 0000 		sts statusMsg,__zero_reg__
1548:switcherator.c ****     strcat(statusMsg, "Prog#");
 6810               		.loc 1 1548 0
 6811 26d8 60E0      		ldi r22,lo8(.LC35)
 6812 26da 70E0      		ldi r23,hi8(.LC35)
 6813 26dc 80E0      		ldi r24,lo8(statusMsg)
 6814 26de 90E0      		ldi r25,hi8(statusMsg)
 6815 26e0 0E94 0000 		call strcat
 6816               	.LVL504:
1549:switcherator.c ****     itoa(programNumber, tempIntString, 10);
 6817               		.loc 1 1549 0
 6818 26e4 4AE0      		ldi r20,lo8(10)
 6819 26e6 50E0      		ldi r21,0
 6820 26e8 60E0      		ldi r22,lo8(tempIntString)
 6821 26ea 70E0      		ldi r23,hi8(tempIntString)
 6822 26ec C801      		movw r24,r16
 6823 26ee 0E94 0000 		call itoa
 6824               	.LVL505:
1550:switcherator.c ****     strcat(statusMsg, tempIntString);
 6825               		.loc 1 1550 0
 6826 26f2 60E0      		ldi r22,lo8(tempIntString)
 6827 26f4 70E0      		ldi r23,hi8(tempIntString)
 6828 26f6 80E0      		ldi r24,lo8(statusMsg)
 6829 26f8 90E0      		ldi r25,hi8(statusMsg)
 6830 26fa 0E94 0000 		call strcat
 6831               	.LVL506:
1551:switcherator.c ****     if (switchCount == 0) {
 6832               		.loc 1 1551 0
 6833 26fe C114      		cp r12,__zero_reg__
 6834 2700 D104      		cpc r13,__zero_reg__
 6835 2702 01F4      		brne .L497
1552:switcherator.c ****         strcat(switches, "S:-");
 6836               		.loc 1 1552 0
 6837 2704 60E0      		ldi r22,lo8(.LC37)
 6838 2706 70E0      		ldi r23,hi8(.LC37)
 6839 2708 CE01      		movw r24,r28
 6840 270a 0196      		adiw r24,1
 6841 270c 0E94 0000 		call strcat
 6842               	.LVL507:
 6843 2710 00C0      		rjmp .L498
 6844               	.L497:
 6845               	.LVL508:
 6846               	.LBB23:
1555:switcherator.c ****         strcat(statusMsg, "S");
 6847               		.loc 1 1555 0
 6848 2712 60E0      		ldi r22,lo8(.LC38)
 6849 2714 70E0      		ldi r23,hi8(.LC38)
 6850 2716 80E0      		ldi r24,lo8(statusMsg)
 6851 2718 90E0      		ldi r25,hi8(statusMsg)
 6852 271a 0E94 0000 		call strcat
 6853               	.LVL509:
 6854 271e EE24      		clr r14
 6855 2720 E394      		inc r14
 6856 2722 F12C      		mov r15,__zero_reg__
 6857 2724 EC0E      		add r14,r28
 6858 2726 FD1E      		adc r15,r29
1528:switcherator.c **** void programDisplay(char * commandReceived) {
 6859               		.loc 1 1528 0
 6860 2728 5701      		movw r10,r14
1557:switcherator.c ****             if(strlen(statusMsg)>30) {
 6861               		.loc 1 1557 0
 6862 272a 70E0      		ldi r23,lo8(statusMsg)
 6863 272c 872E      		mov r8,r23
 6864 272e 70E0      		ldi r23,hi8(statusMsg)
 6865 2730 972E      		mov r9,r23
1556:switcherator.c ****         for (x = 0; x < switchCount; x++) {
 6866               		.loc 1 1556 0
 6867 2732 00C0      		rjmp .L499
 6868               	.LVL510:
 6869               	.L501:
1557:switcherator.c ****             if(strlen(statusMsg)>30) {
 6870               		.loc 1 1557 0
 6871 2734 F401      		movw r30,r8
 6872               		0:
 6873 2736 0190      		ld __tmp_reg__,Z+
 6874 2738 0020      		tst __tmp_reg__
 6875 273a 01F4      		brne 0b
 6876 273c 3197      		sbiw r30,1
 6877 273e E050      		subi r30,lo8(statusMsg)
 6878 2740 F040      		sbci r31,hi8(statusMsg)
 6879 2742 7F97      		sbiw r30,31
 6880 2744 00F0      		brlo .L500
1558:switcherator.c ****                 sendMessage(statusMsg);
 6881               		.loc 1 1558 0
 6882 2746 80E0      		ldi r24,lo8(statusMsg)
 6883 2748 90E0      		ldi r25,hi8(statusMsg)
 6884 274a 0E94 0000 		call sendMessage
 6885               	.LVL511:
1559:switcherator.c ****                 statusMsg[6] = 0;
 6886               		.loc 1 1559 0
 6887 274e 1092 0000 		sts statusMsg+6,__zero_reg__
 6888               	.L500:
1561:switcherator.c ****             strcat(statusMsg, ":");
 6889               		.loc 1 1561 0
 6890 2752 60E0      		ldi r22,lo8(.LC4)
 6891 2754 70E0      		ldi r23,hi8(.LC4)
 6892 2756 80E0      		ldi r24,lo8(statusMsg)
 6893 2758 90E0      		ldi r25,hi8(statusMsg)
 6894 275a 0E94 0000 		call strcat
 6895               	.LVL512:
1563:switcherator.c ****             itoa(temp, tempIntString, 10);
 6896               		.loc 1 1563 0
 6897 275e 4AE0      		ldi r20,lo8(10)
 6898 2760 50E0      		ldi r21,0
 6899 2762 60E0      		ldi r22,lo8(tempIntString)
 6900 2764 70E0      		ldi r23,hi8(tempIntString)
 6901 2766 F701      		movw r30,r14
 6902 2768 8191      		ld r24,Z+
 6903 276a 7F01      		movw r14,r30
 6904               	.LVL513:
 6905 276c 90E0      		ldi r25,0
 6906 276e 0E94 0000 		call itoa
 6907               	.LVL514:
1564:switcherator.c ****             strcat(statusMsg, tempIntString);
 6908               		.loc 1 1564 0
 6909 2772 60E0      		ldi r22,lo8(tempIntString)
 6910 2774 70E0      		ldi r23,hi8(tempIntString)
 6911 2776 80E0      		ldi r24,lo8(statusMsg)
 6912 2778 90E0      		ldi r25,hi8(statusMsg)
 6913 277a 0E94 0000 		call strcat
 6914               	.LVL515:
 6915               	.L499:
1528:switcherator.c **** void programDisplay(char * commandReceived) {
 6916               		.loc 1 1528 0 discriminator 1
 6917 277e C701      		movw r24,r14
 6918 2780 8A19      		sub r24,r10
 6919 2782 9B09      		sbc r25,r11
1556:switcherator.c ****         for (x = 0; x < switchCount; x++) {
 6920               		.loc 1 1556 0 discriminator 1
 6921 2784 8C15      		cp r24,r12
 6922 2786 9D05      		cpc r25,r13
 6923 2788 04F0      		brlt .L501
 6924               	.L498:
 6925               	.LBE23:
1567:switcherator.c ****     sendMessage(statusMsg);
 6926               		.loc 1 1567 0
 6927 278a 80E0      		ldi r24,lo8(statusMsg)
 6928 278c 90E0      		ldi r25,hi8(statusMsg)
 6929 278e 0E94 0000 		call sendMessage
 6930               	.LVL516:
1568:switcherator.c ****     statusMsg[0] = 0;
 6931               		.loc 1 1568 0
 6932 2792 1092 0000 		sts statusMsg,__zero_reg__
 6933               	.LVL517:
1570:switcherator.c ****     time = weeklyProgram[programNumber][1];
 6934               		.loc 1 1570 0
 6935 2796 8AE0      		ldi r24,lo8(10)
 6936 2798 809F      		mul r24,r16
 6937 279a F001      		movw r30,r0
 6938 279c 819F      		mul r24,r17
 6939 279e F00D      		add r31,r0
 6940 27a0 1124      		clr __zero_reg__
 6941 27a2 E050      		subi r30,lo8(-(weeklyProgram))
 6942 27a4 F040      		sbci r31,hi8(-(weeklyProgram))
 6943               	.LVL518:
1571:switcherator.c ****     time <<= 8;
 6944               		.loc 1 1571 0
 6945 27a6 9181      		ldd r25,Z+1
 6946 27a8 80E0      		ldi r24,0
 6947               	.LVL519:
1572:switcherator.c ****     time |= weeklyProgram[programNumber][2];
 6948               		.loc 1 1572 0
 6949 27aa 2281      		ldd r18,Z+2
 6950 27ac AC01      		movw r20,r24
 6951 27ae 422B      		or r20,r18
 6952 27b0 9A01      		movw r18,r20
 6953               	.LVL520:
1573:switcherator.c ****     unsigned int hours = (time / 60);
 6954               		.loc 1 1573 0
 6955 27b2 5CE3      		ldi r21,lo8(60)
 6956 27b4 E52E      		mov r14,r21
 6957 27b6 F12C      		mov r15,__zero_reg__
 6958 27b8 C901      		movw r24,r18
 6959 27ba B701      		movw r22,r14
 6960 27bc 0E94 0000 		call __udivmodhi4
 6961 27c0 8B01      		movw r16,r22
 6962               	.LVL521:
1574:switcherator.c ****     unsigned int minutes = (time - (hours * 60));
 6963               		.loc 1 1574 0
 6964 27c2 4CE3      		ldi r20,lo8(60)
 6965 27c4 469F      		mul r20,r22
 6966 27c6 C001      		movw r24,r0
 6967 27c8 479F      		mul r20,r23
 6968 27ca 900D      		add r25,r0
 6969 27cc 1124      		clr __zero_reg__
 6970 27ce 6901      		movw r12,r18
 6971               	.LVL522:
 6972 27d0 C81A      		sub r12,r24
 6973 27d2 D90A      		sbc r13,r25
 6974               	.LVL523:
1576:switcherator.c ****     time <<= 8;
 6975               		.loc 1 1576 0
 6976 27d4 3381      		ldd r19,Z+3
 6977 27d6 20E0      		ldi r18,0
1577:switcherator.c ****     time |= weeklyProgram[programNumber][4];
 6978               		.loc 1 1577 0
 6979 27d8 8481      		ldd r24,Z+4
 6980 27da A901      		movw r20,r18
 6981 27dc 482B      		or r20,r24
 6982 27de CA01      		movw r24,r20
1578:switcherator.c ****     int duration = (time / 60);
 6983               		.loc 1 1578 0
 6984 27e0 B701      		movw r22,r14
 6985 27e2 0E94 0000 		call __udivmodhi4
 6986 27e6 B62E      		mov r11,r22
 6987 27e8 E72E      		mov r14,r23
 6988               	.LVL524:
1580:switcherator.c ****     weekdays = weeklyProgram[programNumber][0];
 6989               		.loc 1 1580 0
 6990 27ea F080      		ld r15,Z
 6991               	.LVL525:
1581:switcherator.c ****     strcat(statusMsg, "T-");
 6992               		.loc 1 1581 0
 6993 27ec 60E0      		ldi r22,lo8(.LC39)
 6994 27ee 70E0      		ldi r23,hi8(.LC39)
 6995 27f0 80E0      		ldi r24,lo8(statusMsg)
 6996 27f2 90E0      		ldi r25,hi8(statusMsg)
 6997 27f4 0E94 0000 		call strcat
 6998               	.LVL526:
1582:switcherator.c ****     itoa(hours, tempIntString, 10);
 6999               		.loc 1 1582 0
 7000 27f8 4AE0      		ldi r20,lo8(10)
 7001 27fa 50E0      		ldi r21,0
 7002 27fc 60E0      		ldi r22,lo8(tempIntString)
 7003 27fe 70E0      		ldi r23,hi8(tempIntString)
 7004 2800 C801      		movw r24,r16
 7005 2802 0E94 0000 		call itoa
 7006               	.LVL527:
1583:switcherator.c ****     strcat(statusMsg, tempIntString);
 7007               		.loc 1 1583 0
 7008 2806 60E0      		ldi r22,lo8(tempIntString)
 7009 2808 70E0      		ldi r23,hi8(tempIntString)
 7010 280a 80E0      		ldi r24,lo8(statusMsg)
 7011 280c 90E0      		ldi r25,hi8(statusMsg)
 7012 280e 0E94 0000 		call strcat
 7013               	.LVL528:
1584:switcherator.c ****     strcat(statusMsg, ":");
 7014               		.loc 1 1584 0
 7015 2812 60E0      		ldi r22,lo8(.LC4)
 7016 2814 70E0      		ldi r23,hi8(.LC4)
 7017 2816 80E0      		ldi r24,lo8(statusMsg)
 7018 2818 90E0      		ldi r25,hi8(statusMsg)
 7019 281a 0E94 0000 		call strcat
 7020               	.LVL529:
1585:switcherator.c ****     itoa(minutes, tempIntString, 10);
 7021               		.loc 1 1585 0
 7022 281e 4AE0      		ldi r20,lo8(10)
 7023 2820 50E0      		ldi r21,0
 7024 2822 60E0      		ldi r22,lo8(tempIntString)
 7025 2824 70E0      		ldi r23,hi8(tempIntString)
 7026 2826 C601      		movw r24,r12
 7027 2828 0E94 0000 		call itoa
 7028               	.LVL530:
1586:switcherator.c ****     strcat(statusMsg, tempIntString);
 7029               		.loc 1 1586 0
 7030 282c 60E0      		ldi r22,lo8(tempIntString)
 7031 282e 70E0      		ldi r23,hi8(tempIntString)
 7032 2830 80E0      		ldi r24,lo8(statusMsg)
 7033 2832 90E0      		ldi r25,hi8(statusMsg)
 7034 2834 0E94 0000 		call strcat
 7035               	.LVL531:
1587:switcherator.c ****     strcat(statusMsg, " Dur:");
 7036               		.loc 1 1587 0
 7037 2838 60E0      		ldi r22,lo8(.LC40)
 7038 283a 70E0      		ldi r23,hi8(.LC40)
 7039 283c 80E0      		ldi r24,lo8(statusMsg)
 7040 283e 90E0      		ldi r25,hi8(statusMsg)
 7041 2840 0E94 0000 		call strcat
 7042               	.LVL532:
1588:switcherator.c ****     itoa(duration, tempLongString, 10);
 7043               		.loc 1 1588 0
 7044 2844 4AE0      		ldi r20,lo8(10)
 7045 2846 50E0      		ldi r21,0
 7046 2848 60E0      		ldi r22,lo8(tempLongString)
 7047 284a 70E0      		ldi r23,hi8(tempLongString)
 7048 284c 8B2D      		mov r24,r11
 7049 284e 9E2D      		mov r25,r14
 7050 2850 0E94 0000 		call itoa
 7051               	.LVL533:
1589:switcherator.c ****     strcat(statusMsg, tempLongString);
 7052               		.loc 1 1589 0
 7053 2854 60E0      		ldi r22,lo8(tempLongString)
 7054 2856 70E0      		ldi r23,hi8(tempLongString)
 7055 2858 80E0      		ldi r24,lo8(statusMsg)
 7056 285a 90E0      		ldi r25,hi8(statusMsg)
 7057 285c 0E94 0000 		call strcat
 7058               	.LVL534:
1590:switcherator.c ****     strcat(statusMsg, " D:");
 7059               		.loc 1 1590 0
 7060 2860 60E0      		ldi r22,lo8(.LC41)
 7061 2862 70E0      		ldi r23,hi8(.LC41)
 7062 2864 80E0      		ldi r24,lo8(statusMsg)
 7063 2866 90E0      		ldi r25,hi8(statusMsg)
 7064 2868 0E94 0000 		call strcat
 7065               	.LVL535:
1591:switcherator.c ****     if (weekdays == 255) {
 7066               		.loc 1 1591 0
 7067 286c 5FEF      		ldi r21,lo8(-1)
 7068 286e F512      		cpse r15,r21
 7069 2870 00C0      		rjmp .L502
1592:switcherator.c ****         strcat(statusMsg, "-------");
 7070               		.loc 1 1592 0
 7071 2872 60E0      		ldi r22,lo8(.LC42)
 7072 2874 70E0      		ldi r23,hi8(.LC42)
 7073 2876 00C0      		rjmp .L524
 7074               	.L502:
1596:switcherator.c ****     if (weekdays & 0x40) {
 7075               		.loc 1 1596 0
 7076 2878 F6FE      		sbrs r15,6
 7077 287a 00C0      		rjmp .L503
1597:switcherator.c ****         strcat(statusMsg, "S");
 7078               		.loc 1 1597 0
 7079 287c 60E0      		ldi r22,lo8(.LC38)
 7080 287e 70E0      		ldi r23,hi8(.LC38)
 7081 2880 00C0      		rjmp .L518
 7082               	.L503:
1599:switcherator.c ****         strcat(statusMsg, "-");
 7083               		.loc 1 1599 0
 7084 2882 60E0      		ldi r22,lo8(.LC43)
 7085 2884 70E0      		ldi r23,hi8(.LC43)
 7086               	.L518:
 7087 2886 80E0      		ldi r24,lo8(statusMsg)
 7088 2888 90E0      		ldi r25,hi8(statusMsg)
 7089 288a 0E94 0000 		call strcat
 7090               	.LVL536:
1601:switcherator.c ****     if (weekdays & 0x20) {
 7091               		.loc 1 1601 0
 7092 288e F5FE      		sbrs r15,5
 7093 2890 00C0      		rjmp .L505
1602:switcherator.c ****         strcat(statusMsg, "M");
 7094               		.loc 1 1602 0
 7095 2892 60E0      		ldi r22,lo8(.LC44)
 7096 2894 70E0      		ldi r23,hi8(.LC44)
 7097 2896 00C0      		rjmp .L519
 7098               	.L505:
1604:switcherator.c ****         strcat(statusMsg, "-");
 7099               		.loc 1 1604 0
 7100 2898 60E0      		ldi r22,lo8(.LC43)
 7101 289a 70E0      		ldi r23,hi8(.LC43)
 7102               	.L519:
 7103 289c 80E0      		ldi r24,lo8(statusMsg)
 7104 289e 90E0      		ldi r25,hi8(statusMsg)
 7105 28a0 0E94 0000 		call strcat
 7106               	.LVL537:
1606:switcherator.c ****     if (weekdays & 0x10) {
 7107               		.loc 1 1606 0
 7108 28a4 F4FE      		sbrs r15,4
 7109 28a6 00C0      		rjmp .L507
1607:switcherator.c ****         strcat(statusMsg, "T");
 7110               		.loc 1 1607 0
 7111 28a8 60E0      		ldi r22,lo8(.LC45)
 7112 28aa 70E0      		ldi r23,hi8(.LC45)
 7113 28ac 00C0      		rjmp .L520
 7114               	.L507:
1609:switcherator.c ****         strcat(statusMsg, "-");
 7115               		.loc 1 1609 0
 7116 28ae 60E0      		ldi r22,lo8(.LC43)
 7117 28b0 70E0      		ldi r23,hi8(.LC43)
 7118               	.L520:
 7119 28b2 80E0      		ldi r24,lo8(statusMsg)
 7120 28b4 90E0      		ldi r25,hi8(statusMsg)
 7121 28b6 0E94 0000 		call strcat
 7122               	.LVL538:
1611:switcherator.c ****     if (weekdays & 0x08) {
 7123               		.loc 1 1611 0
 7124 28ba F3FE      		sbrs r15,3
 7125 28bc 00C0      		rjmp .L509
1612:switcherator.c ****         strcat(statusMsg, "W");
 7126               		.loc 1 1612 0
 7127 28be 60E0      		ldi r22,lo8(.LC46)
 7128 28c0 70E0      		ldi r23,hi8(.LC46)
 7129 28c2 00C0      		rjmp .L521
 7130               	.L509:
1614:switcherator.c ****         strcat(statusMsg, "-");
 7131               		.loc 1 1614 0
 7132 28c4 60E0      		ldi r22,lo8(.LC43)
 7133 28c6 70E0      		ldi r23,hi8(.LC43)
 7134               	.L521:
 7135 28c8 80E0      		ldi r24,lo8(statusMsg)
 7136 28ca 90E0      		ldi r25,hi8(statusMsg)
 7137 28cc 0E94 0000 		call strcat
 7138               	.LVL539:
1616:switcherator.c ****     if (weekdays & 0x04) {
 7139               		.loc 1 1616 0
 7140 28d0 F2FE      		sbrs r15,2
 7141 28d2 00C0      		rjmp .L511
1617:switcherator.c ****         strcat(statusMsg, "T");
 7142               		.loc 1 1617 0
 7143 28d4 60E0      		ldi r22,lo8(.LC45)
 7144 28d6 70E0      		ldi r23,hi8(.LC45)
 7145 28d8 00C0      		rjmp .L522
 7146               	.L511:
1619:switcherator.c ****         strcat(statusMsg, "-");
 7147               		.loc 1 1619 0
 7148 28da 60E0      		ldi r22,lo8(.LC43)
 7149 28dc 70E0      		ldi r23,hi8(.LC43)
 7150               	.L522:
 7151 28de 80E0      		ldi r24,lo8(statusMsg)
 7152 28e0 90E0      		ldi r25,hi8(statusMsg)
 7153 28e2 0E94 0000 		call strcat
 7154               	.LVL540:
1621:switcherator.c ****     if (weekdays & 0x02) {
 7155               		.loc 1 1621 0
 7156 28e6 F1FE      		sbrs r15,1
 7157 28e8 00C0      		rjmp .L513
1622:switcherator.c ****         strcat(statusMsg, "F");
 7158               		.loc 1 1622 0
 7159 28ea 60E0      		ldi r22,lo8(.LC47)
 7160 28ec 70E0      		ldi r23,hi8(.LC47)
 7161 28ee 00C0      		rjmp .L523
 7162               	.L513:
1624:switcherator.c ****         strcat(statusMsg, "-");
 7163               		.loc 1 1624 0
 7164 28f0 60E0      		ldi r22,lo8(.LC43)
 7165 28f2 70E0      		ldi r23,hi8(.LC43)
 7166               	.L523:
 7167 28f4 80E0      		ldi r24,lo8(statusMsg)
 7168 28f6 90E0      		ldi r25,hi8(statusMsg)
 7169 28f8 0E94 0000 		call strcat
 7170               	.LVL541:
1626:switcherator.c ****     if (weekdays & 0x01) {
 7171               		.loc 1 1626 0
 7172 28fc F0FE      		sbrs r15,0
 7173 28fe 00C0      		rjmp .L515
1627:switcherator.c ****         strcat(statusMsg, "S");
 7174               		.loc 1 1627 0
 7175 2900 60E0      		ldi r22,lo8(.LC38)
 7176 2902 70E0      		ldi r23,hi8(.LC38)
 7177 2904 00C0      		rjmp .L524
 7178               	.L515:
1629:switcherator.c ****         strcat(statusMsg, "-");
 7179               		.loc 1 1629 0
 7180 2906 60E0      		ldi r22,lo8(.LC43)
 7181 2908 70E0      		ldi r23,hi8(.LC43)
 7182               	.LVL542:
 7183               	.L524:
 7184 290a 80E0      		ldi r24,lo8(statusMsg)
 7185 290c 90E0      		ldi r25,hi8(statusMsg)
 7186 290e 0E94 0000 		call strcat
 7187               	.LVL543:
1632:switcherator.c ****     sendMessage(statusMsg);
 7188               		.loc 1 1632 0
 7189 2912 80E0      		ldi r24,lo8(statusMsg)
 7190 2914 90E0      		ldi r25,hi8(statusMsg)
 7191 2916 0E94 0000 		call sendMessage
 7192               	.LVL544:
 7193               	/* epilogue start */
1633:switcherator.c **** }
 7194               		.loc 1 1633 0
 7195 291a 6096      		adiw r28,16
 7196 291c 0FB6      		in __tmp_reg__,__SREG__
 7197 291e F894      		cli
 7198 2920 DEBF      		out __SP_H__,r29
 7199 2922 0FBE      		out __SREG__,__tmp_reg__
 7200 2924 CDBF      		out __SP_L__,r28
 7201 2926 DF91      		pop r29
 7202 2928 CF91      		pop r28
 7203 292a 1F91      		pop r17
 7204 292c 0F91      		pop r16
 7205 292e FF90      		pop r15
 7206 2930 EF90      		pop r14
 7207 2932 DF90      		pop r13
 7208 2934 CF90      		pop r12
 7209 2936 BF90      		pop r11
 7210 2938 AF90      		pop r10
 7211 293a 9F90      		pop r9
 7212 293c 8F90      		pop r8
 7213 293e 0895      		ret
 7214               	.LFE38:
 7216               		.section	.rodata.str1.1
 7217               	.LC48:
 7218 00e8 5661 6C20 		.string	"Val 0x"
 7218      3078 00
 7219               	.LC49:
 7220 00ef 2C00      		.string	","
 7221               	.LC50:
 7222 00f1 2064 6972 		.string	" dir "
 7222      2000 
 7223               	.LC51:
 7224 00f7 436F 6C43 		.string	"ColCh:"
 7224      683A 00
 7225               	.LC52:
 7226 00fe 2D2D 00   		.string	"--"
 7227               	.LC53:
 7228 0101 5057 4D20 		.string	"PWM "
 7228      00
 7229               	.LC54:
 7230 0106 7374 6174 		.string	"static"
 7230      6963 00
 7231               	.LC55:
 7232 010d 436F 6C43 		.string	"ColCh"
 7232      6800 
 7233               	.LC56:
 7234 0113 6875 6500 		.string	"hue"
 7235               	.LC57:
 7236 0117 6F6E 2073 		.string	"on sw# "
 7236      7723 2000 
 7237               		.text
 7238               	.global	pwmSummary
 7240               	pwmSummary:
 7241               	.LFB25:
 967:switcherator.c **** void pwmSummary(void) {
 7242               		.loc 1 967 0
 7243 2940 AF92      		push r10
 7244               	.LCFI170:
 7245 2942 BF92      		push r11
 7246               	.LCFI171:
 7247 2944 CF92      		push r12
 7248               	.LCFI172:
 7249 2946 DF92      		push r13
 7250               	.LCFI173:
 7251 2948 EF92      		push r14
 7252               	.LCFI174:
 7253 294a FF92      		push r15
 7254               	.LCFI175:
 7255 294c 0F93      		push r16
 7256               	.LCFI176:
 7257 294e 1F93      		push r17
 7258               	.LCFI177:
 7259 2950 CF93      		push r28
 7260               	.LCFI178:
 7261 2952 DF93      		push r29
 7262               	.LCFI179:
 7263 2954 1F92      		push __zero_reg__
 7264               	.LCFI180:
 7265 2956 CDB7      		in r28,__SP_L__
 7266 2958 DEB7      		in r29,__SP_H__
 7267               	.LCFI181:
 7268               	/* prologue: function */
 7269               	/* frame size = 1 */
 7270               	/* stack size = 11 */
 7271               	.L__stack_usage = 11
 968:switcherator.c ****     statusMsg[0] = 0;
 7272               		.loc 1 968 0
 7273 295a 1092 0000 		sts statusMsg,__zero_reg__
 969:switcherator.c ****     strcat(statusMsg, "Val 0x");
 7274               		.loc 1 969 0
 7275 295e 60E0      		ldi r22,lo8(.LC48)
 7276 2960 70E0      		ldi r23,hi8(.LC48)
 7277 2962 80E0      		ldi r24,lo8(statusMsg)
 7278 2964 90E0      		ldi r25,hi8(statusMsg)
 7279 2966 0E94 0000 		call strcat
 7280               	.LVL545:
 7281 296a 00E0      		ldi r16,lo8(pwmValues)
 7282 296c 10E0      		ldi r17,hi8(pwmValues)
 971:switcherator.c ****     for (x = 0; x < 3; x++) {
 7283               		.loc 1 971 0
 7284 296e E12C      		mov r14,__zero_reg__
 7285 2970 F12C      		mov r15,__zero_reg__
 7286 2972 00C0      		rjmp .L526
 7287               	.LVL546:
 7288               	.L527:
 973:switcherator.c ****             strcat(statusMsg, ",");
 7289               		.loc 1 973 0
 7290 2974 60E0      		ldi r22,lo8(.LC49)
 7291 2976 70E0      		ldi r23,hi8(.LC49)
 7292 2978 80E0      		ldi r24,lo8(statusMsg)
 7293 297a 90E0      		ldi r25,hi8(statusMsg)
 7294 297c 0E94 0000 		call strcat
 7295               	.LVL547:
 7296               	.L526:
 974:switcherator.c ****         returnHexWithout(pwmValues[x], tempLongString);
 7297               		.loc 1 974 0
 7298 2980 60E0      		ldi r22,lo8(tempLongString)
 7299 2982 70E0      		ldi r23,hi8(tempLongString)
 7300 2984 F801      		movw r30,r16
 7301 2986 8191      		ld r24,Z+
 7302 2988 8F01      		movw r16,r30
 7303 298a 90E0      		ldi r25,0
 7304 298c 0E94 0000 		call returnHexWithout
 7305               	.LVL548:
 975:switcherator.c ****         strcat(statusMsg, tempLongString);
 7306               		.loc 1 975 0
 7307 2990 60E0      		ldi r22,lo8(tempLongString)
 7308 2992 70E0      		ldi r23,hi8(tempLongString)
 7309 2994 80E0      		ldi r24,lo8(statusMsg)
 7310 2996 90E0      		ldi r25,hi8(statusMsg)
 7311 2998 0E94 0000 		call strcat
 7312               	.LVL549:
 971:switcherator.c ****     for (x = 0; x < 3; x++) {
 7313               		.loc 1 971 0
 7314 299c FFEF      		ldi r31,-1
 7315 299e EF1A      		sub r14,r31
 7316 29a0 FF0A      		sbc r15,r31
 7317               	.LVL550:
 7318 29a2 83E0      		ldi r24,3
 7319 29a4 E816      		cp r14,r24
 7320 29a6 F104      		cpc r15,__zero_reg__
 7321 29a8 01F4      		brne .L527
 977:switcherator.c ****     strcat(statusMsg, " dir ");
 7322               		.loc 1 977 0
 7323 29aa 60E0      		ldi r22,lo8(.LC50)
 7324 29ac 70E0      		ldi r23,hi8(.LC50)
 7325 29ae 80E0      		ldi r24,lo8(statusMsg)
 7326 29b0 90E0      		ldi r25,hi8(statusMsg)
 7327 29b2 0E94 0000 		call strcat
 7328               	.LVL551:
 978:switcherator.c ****     returnInt(pwmdir, tempLongString);
 7329               		.loc 1 978 0
 7330 29b6 60E0      		ldi r22,lo8(tempLongString)
 7331 29b8 70E0      		ldi r23,hi8(tempLongString)
 7332 29ba 8091 0000 		lds r24,pwmdir
 7333 29be 90E0      		ldi r25,0
 7334 29c0 0E94 0000 		call returnInt
 7335               	.LVL552:
 979:switcherator.c ****     strcat(statusMsg, tempLongString);
 7336               		.loc 1 979 0
 7337 29c4 60E0      		ldi r22,lo8(tempLongString)
 7338 29c6 70E0      		ldi r23,hi8(tempLongString)
 7339 29c8 80E0      		ldi r24,lo8(statusMsg)
 7340 29ca 90E0      		ldi r25,hi8(statusMsg)
 7341 29cc 0E94 0000 		call strcat
 7342               	.LVL553:
 980:switcherator.c ****     sendMessage(statusMsg);
 7343               		.loc 1 980 0
 7344 29d0 80E0      		ldi r24,lo8(statusMsg)
 7345 29d2 90E0      		ldi r25,hi8(statusMsg)
 7346 29d4 0E94 0000 		call sendMessage
 7347               	.LVL554:
 981:switcherator.c ****     statusMsg[0] = 0;
 7348               		.loc 1 981 0
 7349 29d8 1092 0000 		sts statusMsg,__zero_reg__
 982:switcherator.c ****     strcat(statusMsg, "ColCh:");
 7350               		.loc 1 982 0
 7351 29dc 60E0      		ldi r22,lo8(.LC51)
 7352 29de 70E0      		ldi r23,hi8(.LC51)
 7353 29e0 80E0      		ldi r24,lo8(statusMsg)
 7354 29e2 90E0      		ldi r25,hi8(statusMsg)
 7355 29e4 0E94 0000 		call strcat
 7356               	.LVL555:
 7357 29e8 00E0      		ldi r16,lo8(colorChanges)
 7358 29ea 10E0      		ldi r17,hi8(colorChanges)
 7359 29ec E0E0      		ldi r30,lo8(colorChanges+2)
 7360 29ee EE2E      		mov r14,r30
 7361 29f0 E0E0      		ldi r30,hi8(colorChanges+2)
 7362 29f2 FE2E      		mov r15,r30
 984:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 7363               		.loc 1 984 0
 7364 29f4 C12C      		mov r12,__zero_reg__
 7365 29f6 D12C      		mov r13,__zero_reg__
 7366 29f8 00C0      		rjmp .L528
 7367               	.LVL556:
 7368               	.L533:
 986:switcherator.c ****             strcat(statusMsg, ",");
 7369               		.loc 1 986 0
 7370 29fa 60E0      		ldi r22,lo8(.LC49)
 7371 29fc 70E0      		ldi r23,hi8(.LC49)
 7372 29fe 80E0      		ldi r24,lo8(statusMsg)
 7373 2a00 90E0      		ldi r25,hi8(statusMsg)
 7374 2a02 0E94 0000 		call strcat
 7375               	.LVL557:
 7376 2a06 0D5F      		subi r16,-3
 7377 2a08 1F4F      		sbci r17,-1
 7378 2a0a E3E0      		ldi r30,3
 7379 2a0c EE0E      		add r14,r30
 7380 2a0e F11C      		adc r15,__zero_reg__
 7381               	.LVL558:
 7382               	.L528:
 987:switcherator.c ****         strcat(statusMsg, "0x");
 7383               		.loc 1 987 0
 7384 2a10 60E0      		ldi r22,lo8(.LC5)
 7385 2a12 70E0      		ldi r23,hi8(.LC5)
 7386 2a14 80E0      		ldi r24,lo8(statusMsg)
 7387 2a16 90E0      		ldi r25,hi8(statusMsg)
 7388 2a18 0E94 0000 		call strcat
 7389               	.LVL559:
 988:switcherator.c ****         if(colorChanges[x][0] == 0 && colorChanges[x][1] == 1 &&
 7390               		.loc 1 988 0
 7391 2a1c F801      		movw r30,r16
 7392 2a1e 8081      		ld r24,Z
 7393 2a20 8111      		cpse r24,__zero_reg__
 7394 2a22 00C0      		rjmp .L542
 967:switcherator.c **** void pwmSummary(void) {
 7395               		.loc 1 967 0 discriminator 1
 7396 2a24 F701      		movw r30,r14
 7397 2a26 3197      		sbiw r30,1
 988:switcherator.c ****         if(colorChanges[x][0] == 0 && colorChanges[x][1] == 1 &&
 7398               		.loc 1 988 0 discriminator 1
 7399 2a28 8081      		ld r24,Z
 7400 2a2a 8130      		cpi r24,lo8(1)
 7401 2a2c 01F4      		brne .L542
 7402 2a2e F701      		movw r30,r14
 7403 2a30 8081      		ld r24,Z
 7404 2a32 8111      		cpse r24,__zero_reg__
 7405 2a34 00C0      		rjmp .L542
 990:switcherator.c ****             strcat(statusMsg,"--");
 7406               		.loc 1 990 0
 7407 2a36 60E0      		ldi r22,lo8(.LC52)
 7408 2a38 70E0      		ldi r23,hi8(.LC52)
 7409 2a3a 80E0      		ldi r24,lo8(statusMsg)
 7410 2a3c 90E0      		ldi r25,hi8(statusMsg)
 7411 2a3e 0E94 0000 		call strcat
 7412               	.LVL560:
 7413 2a42 00C0      		rjmp .L530
 7414               	.LVL561:
 7415               	.L531:
 994:switcherator.c ****                     strcat(statusMsg,",");
 7416               		.loc 1 994 0
 7417 2a44 60E0      		ldi r22,lo8(.LC49)
 7418 2a46 70E0      		ldi r23,hi8(.LC49)
 7419 2a48 80E0      		ldi r24,lo8(statusMsg)
 7420 2a4a 90E0      		ldi r25,hi8(statusMsg)
 7421 2a4c 0E94 0000 		call strcat
 7422               	.LVL562:
 7423 2a50 00C0      		rjmp .L544
 7424               	.LVL563:
 7425               	.L542:
 988:switcherator.c ****         if(colorChanges[x][0] == 0 && colorChanges[x][1] == 1 &&
 7426               		.loc 1 988 0
 7427 2a52 A12C      		mov r10,__zero_reg__
 7428 2a54 B12C      		mov r11,__zero_reg__
 7429               	.L544:
 967:switcherator.c **** void pwmSummary(void) {
 7430               		.loc 1 967 0
 7431 2a56 F801      		movw r30,r16
 7432 2a58 EA0D      		add r30,r10
 7433 2a5a FB1D      		adc r31,r11
 995:switcherator.c ****                 returnHexWithout(colorChanges[x][y], tempLongString);
 7434               		.loc 1 995 0
 7435 2a5c 60E0      		ldi r22,lo8(tempLongString)
 7436 2a5e 70E0      		ldi r23,hi8(tempLongString)
 7437 2a60 8081      		ld r24,Z
 7438 2a62 90E0      		ldi r25,0
 7439 2a64 0E94 0000 		call returnHexWithout
 7440               	.LVL564:
 996:switcherator.c ****                 strcat(statusMsg, tempLongString);
 7441               		.loc 1 996 0
 7442 2a68 60E0      		ldi r22,lo8(tempLongString)
 7443 2a6a 70E0      		ldi r23,hi8(tempLongString)
 7444 2a6c 80E0      		ldi r24,lo8(statusMsg)
 7445 2a6e 90E0      		ldi r25,hi8(statusMsg)
 7446 2a70 0E94 0000 		call strcat
 7447               	.LVL565:
 992:switcherator.c ****             for (y = 0; y < 3; y++) {
 7448               		.loc 1 992 0
 7449 2a74 FFEF      		ldi r31,-1
 7450 2a76 AF1A      		sub r10,r31
 7451 2a78 BF0A      		sbc r11,r31
 7452               	.LVL566:
 7453 2a7a 83E0      		ldi r24,3
 7454 2a7c A816      		cp r10,r24
 7455 2a7e B104      		cpc r11,__zero_reg__
 7456 2a80 01F4      		brne .L531
 7457               	.LVL567:
 7458               	.L530:
 999:switcherator.c ****         if (strlen(statusMsg) > 20) {
 7459               		.loc 1 999 0
 7460 2a82 E0E0      		ldi r30,lo8(statusMsg)
 7461 2a84 F0E0      		ldi r31,hi8(statusMsg)
 7462               		0:
 7463 2a86 0190      		ld __tmp_reg__,Z+
 7464 2a88 0020      		tst __tmp_reg__
 7465 2a8a 01F4      		brne 0b
 7466 2a8c 3197      		sbiw r30,1
 7467 2a8e E050      		subi r30,lo8(statusMsg)
 7468 2a90 F040      		sbci r31,hi8(statusMsg)
 7469 2a92 7597      		sbiw r30,21
 7470 2a94 00F0      		brlo .L532
1000:switcherator.c ****             sendMessage(statusMsg);
 7471               		.loc 1 1000 0
 7472 2a96 80E0      		ldi r24,lo8(statusMsg)
 7473 2a98 90E0      		ldi r25,hi8(statusMsg)
 7474 2a9a 0E94 0000 		call sendMessage
 7475               	.LVL568:
1001:switcherator.c ****             statusMsg[6] = 0;
 7476               		.loc 1 1001 0
 7477 2a9e 1092 0000 		sts statusMsg+6,__zero_reg__
 7478               	.L532:
 984:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 7479               		.loc 1 984 0
 7480 2aa2 EFEF      		ldi r30,-1
 7481 2aa4 CE1A      		sub r12,r30
 7482 2aa6 DE0A      		sbc r13,r30
 7483               	.LVL569:
 7484 2aa8 F6E0      		ldi r31,6
 7485 2aaa CF16      		cp r12,r31
 7486 2aac D104      		cpc r13,__zero_reg__
 7487 2aae 01F0      		breq .+2
 7488 2ab0 00C0      		rjmp .L533
1004:switcherator.c ****     if(strlen(statusMsg)> 6)
 7489               		.loc 1 1004 0
 7490 2ab2 E0E0      		ldi r30,lo8(statusMsg)
 7491 2ab4 F0E0      		ldi r31,hi8(statusMsg)
 7492               		0:
 7493 2ab6 0190      		ld __tmp_reg__,Z+
 7494 2ab8 0020      		tst __tmp_reg__
 7495 2aba 01F4      		brne 0b
 7496 2abc 3197      		sbiw r30,1
 7497 2abe E050      		subi r30,lo8(statusMsg)
 7498 2ac0 F040      		sbci r31,hi8(statusMsg)
 7499 2ac2 3797      		sbiw r30,7
 7500 2ac4 00F0      		brlo .L534
1005:switcherator.c ****         sendMessage(statusMsg);
 7501               		.loc 1 1005 0
 7502 2ac6 80E0      		ldi r24,lo8(statusMsg)
 7503 2ac8 90E0      		ldi r25,hi8(statusMsg)
 7504 2aca 0E94 0000 		call sendMessage
 7505               	.LVL570:
 7506               	.L534:
1006:switcherator.c ****     statusMsg[0] = 0;
 7507               		.loc 1 1006 0
 7508 2ace 1092 0000 		sts statusMsg,__zero_reg__
 7509               	.LVL571:
 7510 2ad2 00E0      		ldi r16,lo8(switchStuff)
 7511 2ad4 10E0      		ldi r17,hi8(switchStuff)
1007:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 7512               		.loc 1 1007 0
 7513 2ad6 E12C      		mov r14,__zero_reg__
 7514 2ad8 F12C      		mov r15,__zero_reg__
 7515               	.LVL572:
 7516               	.L539:
1008:switcherator.c ****         if ((switchStuff[x] >= 200) && (switchStuff[x] <= 220)) {
 7517               		.loc 1 1008 0
 7518 2ada F801      		movw r30,r16
 7519 2adc 2191      		ld r18,Z+
 7520 2ade 8F01      		movw r16,r30
 7521 2ae0 822F      		mov r24,r18
 7522 2ae2 885C      		subi r24,lo8(-(56))
 7523 2ae4 8531      		cpi r24,lo8(21)
 7524 2ae6 00F4      		brsh .L535
1009:switcherator.c ****             strcat(statusMsg, "PWM ");
 7525               		.loc 1 1009 0
 7526 2ae8 60E0      		ldi r22,lo8(.LC53)
 7527 2aea 70E0      		ldi r23,hi8(.LC53)
 7528 2aec 80E0      		ldi r24,lo8(statusMsg)
 7529 2aee 90E0      		ldi r25,hi8(statusMsg)
 7530 2af0 2983      		std Y+1,r18
 7531 2af2 0E94 0000 		call strcat
 7532               	.LVL573:
1010:switcherator.c ****             if (switchStuff[x] == 200) {
 7533               		.loc 1 1010 0
 7534 2af6 2981      		ldd r18,Y+1
 7535 2af8 283C      		cpi r18,lo8(-56)
 7536 2afa 01F4      		brne .L536
1011:switcherator.c ****                 strcat(statusMsg, "static");
 7537               		.loc 1 1011 0
 7538 2afc 60E0      		ldi r22,lo8(.LC54)
 7539 2afe 70E0      		ldi r23,hi8(.LC54)
 7540 2b00 00C0      		rjmp .L545
 7541               	.L536:
1012:switcherator.c ****             } else if (switchStuff[x] == 202) {
 7542               		.loc 1 1012 0
 7543 2b02 2A3C      		cpi r18,lo8(-54)
 7544 2b04 01F4      		brne .L538
1013:switcherator.c ****                 strcat(statusMsg, "ColCh");
 7545               		.loc 1 1013 0
 7546 2b06 60E0      		ldi r22,lo8(.LC55)
 7547 2b08 70E0      		ldi r23,hi8(.LC55)
 7548 2b0a 00C0      		rjmp .L545
 7549               	.L538:
1015:switcherator.c ****                 strcat(statusMsg, "hue");
 7550               		.loc 1 1015 0
 7551 2b0c 60E0      		ldi r22,lo8(.LC56)
 7552 2b0e 70E0      		ldi r23,hi8(.LC56)
 7553               	.L545:
 7554 2b10 80E0      		ldi r24,lo8(statusMsg)
 7555 2b12 90E0      		ldi r25,hi8(statusMsg)
 7556 2b14 0E94 0000 		call strcat
 7557               	.LVL574:
1017:switcherator.c ****             strcat(statusMsg, "on sw# ");
 7558               		.loc 1 1017 0
 7559 2b18 60E0      		ldi r22,lo8(.LC57)
 7560 2b1a 70E0      		ldi r23,hi8(.LC57)
 7561 2b1c 80E0      		ldi r24,lo8(statusMsg)
 7562 2b1e 90E0      		ldi r25,hi8(statusMsg)
 7563 2b20 0E94 0000 		call strcat
 7564               	.LVL575:
1018:switcherator.c ****             returnInt(x, tempLongString);
 7565               		.loc 1 1018 0
 7566 2b24 60E0      		ldi r22,lo8(tempLongString)
 7567 2b26 70E0      		ldi r23,hi8(tempLongString)
 7568 2b28 C701      		movw r24,r14
 7569 2b2a 0E94 0000 		call returnInt
 7570               	.LVL576:
1019:switcherator.c ****             strcat(statusMsg, tempLongString);
 7571               		.loc 1 1019 0
 7572 2b2e 60E0      		ldi r22,lo8(tempLongString)
 7573 2b30 70E0      		ldi r23,hi8(tempLongString)
 7574 2b32 80E0      		ldi r24,lo8(statusMsg)
 7575 2b34 90E0      		ldi r25,hi8(statusMsg)
 7576 2b36 0E94 0000 		call strcat
 7577               	.LVL577:
1020:switcherator.c ****             sendMessage(statusMsg);
 7578               		.loc 1 1020 0
 7579 2b3a 80E0      		ldi r24,lo8(statusMsg)
 7580 2b3c 90E0      		ldi r25,hi8(statusMsg)
 7581 2b3e 0E94 0000 		call sendMessage
 7582               	.LVL578:
1021:switcherator.c ****             statusMsg[0] = 0;
 7583               		.loc 1 1021 0
 7584 2b42 1092 0000 		sts statusMsg,__zero_reg__
 7585               	.L535:
1007:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 7586               		.loc 1 1007 0
 7587 2b46 FFEF      		ldi r31,-1
 7588 2b48 EF1A      		sub r14,r31
 7589 2b4a FF0A      		sbc r15,r31
 7590               	.LVL579:
 7591 2b4c 80E1      		ldi r24,16
 7592 2b4e E816      		cp r14,r24
 7593 2b50 F104      		cpc r15,__zero_reg__
 7594 2b52 01F4      		brne .L539
 7595               	/* epilogue start */
1024:switcherator.c **** }
 7596               		.loc 1 1024 0
 7597 2b54 0F90      		pop __tmp_reg__
 7598 2b56 DF91      		pop r29
 7599 2b58 CF91      		pop r28
 7600 2b5a 1F91      		pop r17
 7601 2b5c 0F91      		pop r16
 7602 2b5e FF90      		pop r15
 7603 2b60 EF90      		pop r14
 7604               	.LVL580:
 7605 2b62 DF90      		pop r13
 7606 2b64 CF90      		pop r12
 7607 2b66 BF90      		pop r11
 7608 2b68 AF90      		pop r10
 7609 2b6a 0895      		ret
 7610               	.LFE25:
 7612               		.section	.rodata.str1.1
 7613               	.LC58:
 7614 011f 436F 4300 		.string	"CoC"
 7615               	.LC59:
 7616 0123 4272 7400 		.string	"Brt"
 7617               	.LC60:
 7618 0127 4669 7800 		.string	"Fix"
 7619               	.LC61:
 7620 012b 4875 6500 		.string	"Hue"
 7621               	.LC62:
 7622 012f 4C00      		.string	"L"
 7623               	.LC63:
 7624 0131 4800      		.string	"H"
 7625               		.text
 7626               	.global	switchDisplay
 7628               	switchDisplay:
 7629               	.LFB15:
 585:switcherator.c **** void switchDisplay(char * commandReceived) {
 7630               		.loc 1 585 0
 7631               	.LVL581:
 7632 2b6c CF93      		push r28
 7633               	.LCFI182:
 7634 2b6e DF93      		push r29
 7635               	.LCFI183:
 7636 2b70 CDB7      		in r28,__SP_L__
 7637 2b72 DEB7      		in r29,__SP_H__
 7638               	.LCFI184:
 7639 2b74 A397      		sbiw r28,35
 7640               	.LCFI185:
 7641 2b76 0FB6      		in __tmp_reg__,__SREG__
 7642 2b78 F894      		cli
 7643 2b7a DEBF      		out __SP_H__,r29
 7644 2b7c 0FBE      		out __SREG__,__tmp_reg__
 7645 2b7e CDBF      		out __SP_L__,r28
 7646               	/* prologue: function */
 7647               	/* frame size = 35 */
 7648               	/* stack size = 37 */
 7649               	.L__stack_usage = 37
 586:switcherator.c ****     char port[] = {0};
 7650               		.loc 1 586 0
 7651 2b80 1BA2      		std Y+35,__zero_reg__
 587:switcherator.c ****     char pin[] = {0};
 7652               		.loc 1 587 0
 7653 2b82 1AA2      		std Y+34,__zero_reg__
 588:switcherator.c ****     char direction[] = {0};
 7654               		.loc 1 588 0
 7655 2b84 19A2      		std Y+33,__zero_reg__
 7656               	.LVL582:
 592:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 7657               		.loc 1 592 0
 7658 2b86 0E94 0000 		call getSwitchNumber
 7659               	.LVL583:
 593:switcherator.c ****     statusMsg[0] = 0;
 7660               		.loc 1 593 0
 7661 2b8a 1982      		std Y+1,__zero_reg__
 595:switcherator.c ****     if (switchStuff[switchNumber] >= 200 && switchStuff[switchNumber] <= 220) {
 7662               		.loc 1 595 0
 7663 2b8c FC01      		movw r30,r24
 7664 2b8e E050      		subi r30,lo8(-(switchStuff))
 7665 2b90 F040      		sbci r31,hi8(-(switchStuff))
 7666 2b92 2081      		ld r18,Z
 7667 2b94 322F      		mov r19,r18
 7668 2b96 385C      		subi r19,lo8(-(56))
 7669 2b98 3531      		cpi r19,lo8(21)
 7670 2b9a 00F4      		brsh .L547
 597:switcherator.c ****         if (switchStuff[switchNumber] % 2 == 0) {
 7671               		.loc 1 597 0
 7672 2b9c 20FD      		sbrc r18,0
 7673 2b9e 00C0      		rjmp .L548
 598:switcherator.c ****             if (switchStuff[switchNumber] == 202) {
 7674               		.loc 1 598 0
 7675 2ba0 2A3C      		cpi r18,lo8(-54)
 7676 2ba2 01F4      		brne .L549
 599:switcherator.c ****                 strcat(statusMsg, "CoC");
 7677               		.loc 1 599 0
 7678 2ba4 60E0      		ldi r22,lo8(.LC58)
 7679 2ba6 70E0      		ldi r23,hi8(.LC58)
 7680 2ba8 00C0      		rjmp .L553
 7681               	.L549:
 600:switcherator.c ****             } else if (switchStuff[switchNumber] == 212) {
 7682               		.loc 1 600 0
 7683 2baa 243D      		cpi r18,lo8(-44)
 7684 2bac 01F4      		brne .L551
 601:switcherator.c ****                 strcat(statusMsg, "Brt");
 7685               		.loc 1 601 0
 7686 2bae 60E0      		ldi r22,lo8(.LC59)
 7687 2bb0 70E0      		ldi r23,hi8(.LC59)
 7688 2bb2 00C0      		rjmp .L553
 7689               	.L551:
 603:switcherator.c ****                 strcat(statusMsg, "Fix");
 7690               		.loc 1 603 0
 7691 2bb4 60E0      		ldi r22,lo8(.LC60)
 7692 2bb6 70E0      		ldi r23,hi8(.LC60)
 7693 2bb8 00C0      		rjmp .L553
 7694               	.L548:
 606:switcherator.c ****             strcat(statusMsg, "Hue");
 7695               		.loc 1 606 0
 7696 2bba 60E0      		ldi r22,lo8(.LC61)
 7697 2bbc 70E0      		ldi r23,hi8(.LC61)
 7698 2bbe 00C0      		rjmp .L553
 7699               	.L547:
 609:switcherator.c ****         getPort(switchNumber, port, pin, direction);
 7700               		.loc 1 609 0
 7701 2bc0 9E01      		movw r18,r28
 7702 2bc2 2F5D      		subi r18,-33
 7703 2bc4 3F4F      		sbci r19,-1
 7704 2bc6 AE01      		movw r20,r28
 7705 2bc8 4E5D      		subi r20,-34
 7706 2bca 5F4F      		sbci r21,-1
 7707 2bcc BE01      		movw r22,r28
 7708 2bce 6D5D      		subi r22,-35
 7709 2bd0 7F4F      		sbci r23,-1
 7710 2bd2 0E94 0000 		call getPort
 7711               	.LVL584:
 610:switcherator.c ****         tempIntString[0] = port[0];
 7712               		.loc 1 610 0
 7713 2bd6 8BA1      		ldd r24,Y+35
 7714 2bd8 8093 0000 		sts tempIntString,r24
 611:switcherator.c ****         tempIntString[1] = 0;
 7715               		.loc 1 611 0
 7716 2bdc 1092 0000 		sts tempIntString+1,__zero_reg__
 612:switcherator.c ****         strcat(statusMsg, tempIntString);
 7717               		.loc 1 612 0
 7718 2be0 60E0      		ldi r22,lo8(tempIntString)
 7719 2be2 70E0      		ldi r23,hi8(tempIntString)
 7720 2be4 CE01      		movw r24,r28
 7721 2be6 0196      		adiw r24,1
 7722 2be8 0E94 0000 		call strcat
 7723               	.LVL585:
 614:switcherator.c ****         itoa(realPin, tempIntString, 10);
 7724               		.loc 1 614 0
 7725 2bec 4AE0      		ldi r20,lo8(10)
 7726 2bee 50E0      		ldi r21,0
 7727 2bf0 60E0      		ldi r22,lo8(tempIntString)
 7728 2bf2 70E0      		ldi r23,hi8(tempIntString)
 7729 2bf4 8AA1      		ldd r24,Y+34
 7730 2bf6 90E0      		ldi r25,0
 7731 2bf8 0E94 0000 		call itoa
 7732               	.LVL586:
 615:switcherator.c ****         strcat(statusMsg, tempIntString);
 7733               		.loc 1 615 0
 7734 2bfc 60E0      		ldi r22,lo8(tempIntString)
 7735 2bfe 70E0      		ldi r23,hi8(tempIntString)
 7736 2c00 CE01      		movw r24,r28
 7737 2c02 0196      		adiw r24,1
 7738 2c04 0E94 0000 		call strcat
 7739               	.LVL587:
 616:switcherator.c ****         if (direction[0] == 0) {
 7740               		.loc 1 616 0
 7741 2c08 89A1      		ldd r24,Y+33
 7742 2c0a 8111      		cpse r24,__zero_reg__
 7743 2c0c 00C0      		rjmp .L552
 617:switcherator.c ****             strcat(statusMsg, "L");
 7744               		.loc 1 617 0
 7745 2c0e 60E0      		ldi r22,lo8(.LC62)
 7746 2c10 70E0      		ldi r23,hi8(.LC62)
 7747 2c12 00C0      		rjmp .L553
 7748               	.L552:
 619:switcherator.c ****             strcat(statusMsg, "H");
 7749               		.loc 1 619 0
 7750 2c14 60E0      		ldi r22,lo8(.LC63)
 7751 2c16 70E0      		ldi r23,hi8(.LC63)
 7752               	.L553:
 7753 2c18 CE01      		movw r24,r28
 7754 2c1a 0196      		adiw r24,1
 7755 2c1c 0E94 0000 		call strcat
 7756               	.LVL588:
 622:switcherator.c ****     sendMessage(statusMsg);
 7757               		.loc 1 622 0
 7758 2c20 CE01      		movw r24,r28
 7759 2c22 0196      		adiw r24,1
 7760 2c24 0E94 0000 		call sendMessage
 7761               	.LVL589:
 7762               	/* epilogue start */
 624:switcherator.c **** }
 7763               		.loc 1 624 0
 7764 2c28 A396      		adiw r28,35
 7765 2c2a 0FB6      		in __tmp_reg__,__SREG__
 7766 2c2c F894      		cli
 7767 2c2e DEBF      		out __SP_H__,r29
 7768 2c30 0FBE      		out __SREG__,__tmp_reg__
 7769 2c32 CDBF      		out __SP_L__,r28
 7770 2c34 DF91      		pop r29
 7771 2c36 CF91      		pop r28
 7772 2c38 0895      		ret
 7773               	.LFE15:
 7775               		.section	.rodata.str1.1
 7776               	.LC64:
 7777 0133 6F6B 00   		.string	"ok"
 7778               		.text
 7779               	.global	ok
 7781               	ok:
 7782               	.LFB10:
 374:switcherator.c **** void ok(void) {
 7783               		.loc 1 374 0
 7784               	/* prologue: function */
 7785               	/* frame size = 0 */
 7786               	/* stack size = 0 */
 7787               	.L__stack_usage = 0
 375:switcherator.c ****     sendMessage("ok");
 7788               		.loc 1 375 0
 7789 2c3a 80E0      		ldi r24,lo8(.LC64)
 7790 2c3c 90E0      		ldi r25,hi8(.LC64)
 7791 2c3e 0C94 0000 		jmp sendMessage
 7792               	.LVL590:
 7793               	.LFE10:
 7795               	.global	clearInput
 7797               	clearInput:
 7798               	.LFB83:
3644:switcherator.c **** void clearInput(char * commandReceived) {
 7799               		.loc 1 3644 0
 7800               	.LVL591:
 7801               	/* prologue: function */
 7802               	/* frame size = 0 */
 7803               	/* stack size = 0 */
 7804               	.L__stack_usage = 0
3647:switcherator.c ****     tempIntString[0] = commandReceived[3];
 7805               		.loc 1 3647 0
 7806 2c42 FC01      		movw r30,r24
 7807 2c44 2381      		ldd r18,Z+3
 7808 2c46 2093 0000 		sts tempIntString,r18
3648:switcherator.c ****     tempIntString[1] = commandReceived[4];
 7809               		.loc 1 3648 0
 7810 2c4a 8481      		ldd r24,Z+4
 7811               	.LVL592:
 7812 2c4c 8093 0000 		sts tempIntString+1,r24
3649:switcherator.c ****     inputNumber = atoi(tempIntString);
 7813               		.loc 1 3649 0
 7814 2c50 80E0      		ldi r24,lo8(tempIntString)
 7815 2c52 90E0      		ldi r25,hi8(tempIntString)
 7816 2c54 0E94 0000 		call atoi
 7817               	.LVL593:
3650:switcherator.c ****     int temp = inputs[inputNumber][0];
 7818               		.loc 1 3650 0
 7819 2c58 F3E0      		ldi r31,3
 7820               		1:
 7821 2c5a 880F      		lsl r24
 7822 2c5c 991F      		rol r25
 7823 2c5e FA95      		dec r31
 7824 2c60 01F4      		brne 1b
 7825               	.LVL594:
 7826 2c62 FC01      		movw r30,r24
 7827 2c64 E050      		subi r30,lo8(-(inputs))
 7828 2c66 F040      		sbci r31,hi8(-(inputs))
 7829 2c68 2081      		ld r18,Z
 7830 2c6a 30E0      		ldi r19,0
 7831               	.LVL595:
3651:switcherator.c ****     if (temp > 15 && temp < 32) {
 7832               		.loc 1 3651 0
 7833 2c6c A901      		movw r20,r18
 7834 2c6e 4051      		subi r20,16
 7835 2c70 5109      		sbc r21,__zero_reg__
 7836 2c72 4031      		cpi r20,16
 7837 2c74 5105      		cpc r21,__zero_reg__
 7838 2c76 00F4      		brsh .L556
 7839               	.LVL596:
3653:switcherator.c ****         temp -= 16;
 7840               		.loc 1 3653 0
 7841 2c78 9A01      		movw r18,r20
 7842               	.LVL597:
3652:switcherator.c ****         thisPort = &PINB;
 7843               		.loc 1 3652 0
 7844 2c7a E3E2      		ldi r30,lo8(35)
 7845 2c7c F0E0      		ldi r31,0
 7846 2c7e 00C0      		rjmp .L557
 7847               	.LVL598:
 7848               	.L556:
3660:switcherator.c ****     } else if (temp < 48) {
 7849               		.loc 1 3660 0
 7850 2c80 2033      		cpi r18,48
 7851 2c82 3105      		cpc r19,__zero_reg__
 7852 2c84 04F4      		brge .L558
 7853               	.LVL599:
3662:switcherator.c ****         temp -= 32;
 7854               		.loc 1 3662 0
 7855 2c86 2052      		subi r18,32
 7856 2c88 3109      		sbc r19,__zero_reg__
 7857               	.LVL600:
3661:switcherator.c ****         thisPort = &PINC;
 7858               		.loc 1 3661 0
 7859 2c8a E6E2      		ldi r30,lo8(38)
 7860 2c8c F0E0      		ldi r31,0
 7861 2c8e 00C0      		rjmp .L557
 7862               	.LVL601:
 7863               	.L558:
3665:switcherator.c ****     } else if (temp < 64) {
 7864               		.loc 1 3665 0
 7865 2c90 2034      		cpi r18,64
 7866 2c92 3105      		cpc r19,__zero_reg__
 7867 2c94 04F4      		brge .L560
 7868               	.LVL602:
3667:switcherator.c ****         temp -= 48;
 7869               		.loc 1 3667 0
 7870 2c96 2053      		subi r18,48
 7871 2c98 3109      		sbc r19,__zero_reg__
 7872               	.LVL603:
3666:switcherator.c ****         thisPort = &PIND;
 7873               		.loc 1 3666 0
 7874 2c9a E9E2      		ldi r30,lo8(41)
 7875 2c9c F0E0      		ldi r31,0
 7876               	.LVL604:
 7877               	.L557:
3699:switcherator.c ****     *thisPort &= ~(1 << temp);
 7878               		.loc 1 3699 0
 7879 2c9e 3081      		ld r19,Z
 7880 2ca0 41E0      		ldi r20,lo8(1)
 7881 2ca2 50E0      		ldi r21,0
 7882 2ca4 00C0      		rjmp 2f
 7883               		1:
 7884 2ca6 440F      		lsl r20
 7885               		2:
 7886 2ca8 2A95      		dec r18
 7887 2caa 02F4      		brpl 1b
 7888 2cac 4095      		com r20
 7889 2cae 4323      		and r20,r19
 7890 2cb0 4083      		st Z,r20
3700:switcherator.c ****     inputs[inputNumber][0] = 255;
 7891               		.loc 1 3700 0
 7892 2cb2 FC01      		movw r30,r24
 7893               	.LVL605:
 7894 2cb4 E050      		subi r30,lo8(-(inputs))
 7895 2cb6 F040      		sbci r31,hi8(-(inputs))
 7896 2cb8 2FEF      		ldi r18,lo8(-1)
 7897 2cba 2083      		st Z,r18
 7898               	.L560:
3701:switcherator.c ****     ok();
 7899               		.loc 1 3701 0
 7900 2cbc 0C94 0000 		jmp ok
 7901               	.LVL606:
 7902               	.LFE83:
 7904               	.global	setDaylightSavings
 7906               	setDaylightSavings:
 7907               	.LFB55:
2264:switcherator.c **** void setDaylightSavings(char * commandReceived) {
 7908               		.loc 1 2264 0
 7909               	.LVL607:
 7910 2cc0 EF92      		push r14
 7911               	.LCFI186:
 7912 2cc2 FF92      		push r15
 7913               	.LCFI187:
 7914 2cc4 0F93      		push r16
 7915               	.LCFI188:
 7916 2cc6 1F93      		push r17
 7917               	.LCFI189:
 7918 2cc8 CF93      		push r28
 7919               	.LCFI190:
 7920 2cca DF93      		push r29
 7921               	.LCFI191:
 7922               	/* prologue: function */
 7923               	/* frame size = 0 */
 7924               	/* stack size = 6 */
 7925               	.L__stack_usage = 6
 7926 2ccc EC01      		movw r28,r24
2266:switcherator.c ****     tempIntString[0] = commandReceived[3];
 7927               		.loc 1 2266 0
 7928 2cce A0E0      		ldi r26,lo8(tempIntString)
 7929 2cd0 EA2E      		mov r14,r26
 7930 2cd2 A0E0      		ldi r26,hi8(tempIntString)
 7931 2cd4 FA2E      		mov r15,r26
 7932 2cd6 8B81      		ldd r24,Y+3
 7933               	.LVL608:
 7934 2cd8 F701      		movw r30,r14
 7935 2cda 8083      		st Z,r24
2267:switcherator.c ****     tempIntString[1] = commandReceived[4];
 7936               		.loc 1 2267 0
 7937 2cdc 00E0      		ldi r16,lo8(tempIntString+1)
 7938 2cde 10E0      		ldi r17,hi8(tempIntString+1)
 7939 2ce0 8C81      		ldd r24,Y+4
 7940 2ce2 F801      		movw r30,r16
 7941 2ce4 8083      		st Z,r24
2268:switcherator.c ****     dlInt = atoi(tempIntString);
 7942               		.loc 1 2268 0
 7943 2ce6 C701      		movw r24,r14
 7944 2ce8 0E94 0000 		call atoi
 7945               	.LVL609:
2269:switcherator.c ****     daylightSavings[0][0] = dlInt;
 7946               		.loc 1 2269 0
 7947 2cec 9093 0000 		sts daylightSavings+1,r25
 7948 2cf0 8093 0000 		sts daylightSavings,r24
2270:switcherator.c ****     tempIntString[0] = commandReceived[5];
 7949               		.loc 1 2270 0
 7950 2cf4 8D81      		ldd r24,Y+5
 7951               	.LVL610:
 7952 2cf6 F701      		movw r30,r14
 7953 2cf8 8083      		st Z,r24
2271:switcherator.c ****     tempIntString[1] = commandReceived[6];
 7954               		.loc 1 2271 0
 7955 2cfa 8E81      		ldd r24,Y+6
 7956 2cfc F801      		movw r30,r16
 7957 2cfe 8083      		st Z,r24
2272:switcherator.c ****     dlInt = atoi(tempIntString);
 7958               		.loc 1 2272 0
 7959 2d00 C701      		movw r24,r14
 7960 2d02 0E94 0000 		call atoi
 7961               	.LVL611:
2273:switcherator.c ****     daylightSavings[0][1] = dlInt;
 7962               		.loc 1 2273 0
 7963 2d06 9093 0000 		sts daylightSavings+2+1,r25
 7964 2d0a 8093 0000 		sts daylightSavings+2,r24
2274:switcherator.c ****     tempIntString[0] = commandReceived[8];
 7965               		.loc 1 2274 0
 7966 2d0e 8885      		ldd r24,Y+8
 7967               	.LVL612:
 7968 2d10 F701      		movw r30,r14
 7969 2d12 8083      		st Z,r24
2275:switcherator.c ****     tempIntString[1] = commandReceived[9];
 7970               		.loc 1 2275 0
 7971 2d14 8985      		ldd r24,Y+9
 7972 2d16 F801      		movw r30,r16
 7973 2d18 8083      		st Z,r24
2276:switcherator.c ****     dlInt = atoi(tempIntString);
 7974               		.loc 1 2276 0
 7975 2d1a C701      		movw r24,r14
 7976 2d1c 0E94 0000 		call atoi
 7977               	.LVL613:
2277:switcherator.c ****     daylightSavings[1][0] = dlInt;
 7978               		.loc 1 2277 0
 7979 2d20 9093 0000 		sts daylightSavings+4+1,r25
 7980 2d24 8093 0000 		sts daylightSavings+4,r24
2278:switcherator.c ****     tempIntString[0] = commandReceived[10];
 7981               		.loc 1 2278 0
 7982 2d28 8A85      		ldd r24,Y+10
 7983               	.LVL614:
 7984 2d2a F701      		movw r30,r14
 7985 2d2c 8083      		st Z,r24
2279:switcherator.c ****     tempIntString[1] = commandReceived[11];
 7986               		.loc 1 2279 0
 7987 2d2e 8B85      		ldd r24,Y+11
 7988 2d30 F801      		movw r30,r16
 7989 2d32 8083      		st Z,r24
2280:switcherator.c ****     dlInt = atoi(tempIntString);
 7990               		.loc 1 2280 0
 7991 2d34 C701      		movw r24,r14
 7992 2d36 0E94 0000 		call atoi
 7993               	.LVL615:
2281:switcherator.c ****     daylightSavings[1][1] = dlInt;
 7994               		.loc 1 2281 0
 7995 2d3a 9093 0000 		sts daylightSavings+6+1,r25
 7996 2d3e 8093 0000 		sts daylightSavings+6,r24
 7997               	/* epilogue start */
2283:switcherator.c **** }
 7998               		.loc 1 2283 0
 7999 2d42 DF91      		pop r29
 8000 2d44 CF91      		pop r28
 8001               	.LVL616:
 8002 2d46 1F91      		pop r17
 8003 2d48 0F91      		pop r16
 8004 2d4a FF90      		pop r15
 8005 2d4c EF90      		pop r14
2282:switcherator.c ****     ok();
 8006               		.loc 1 2282 0
 8007 2d4e 0C94 0000 		jmp ok
 8008               	.LVL617:
 8009               	.LFE55:
 8011               	.global	clearToEEPROM
 8013               	clearToEEPROM:
 8014               	.LFB47:
2095:switcherator.c **** void clearToEEPROM(void) {
 8015               		.loc 1 2095 0
 8016 2d52 CF93      		push r28
 8017               	.LCFI192:
 8018 2d54 DF93      		push r29
 8019               	.LCFI193:
 8020               	/* prologue: function */
 8021               	/* frame size = 0 */
 8022               	/* stack size = 2 */
 8023               	.L__stack_usage = 2
 8024               	.LVL618:
2097:switcherator.c ****     clearEEPROM(DAYLIGHT_SAVE);
 8025               		.loc 1 2097 0
 8026 2d56 86E0      		ldi r24,lo8(6)
 8027 2d58 90E0      		ldi r25,0
 8028 2d5a 0E94 0000 		call clearEEPROM
 8029               	.LVL619:
2098:switcherator.c ****     clearEEPROM(RADIO_ADDR_TX);
 8030               		.loc 1 2098 0
 8031 2d5e 8EE0      		ldi r24,lo8(14)
 8032 2d60 90E0      		ldi r25,0
 8033 2d62 0E94 0000 		call clearEEPROM
 8034               	.LVL620:
2099:switcherator.c ****     clearEEPROM(RADIO_ADDR_R0);
 8035               		.loc 1 2099 0
 8036 2d66 85E1      		ldi r24,lo8(21)
 8037 2d68 90E0      		ldi r25,0
 8038 2d6a 0E94 0000 		call clearEEPROM
 8039               	.LVL621:
2100:switcherator.c ****     clearEEPROM(RADIO_ADDR_R1);
 8040               		.loc 1 2100 0
 8041 2d6e 8CE1      		ldi r24,lo8(28)
 8042 2d70 90E0      		ldi r25,0
 8043 2d72 0E94 0000 		call clearEEPROM
 8044               	.LVL622:
2101:switcherator.c ****     clearEEPROM(RADIO_ADDR_R2);
 8045               		.loc 1 2101 0
 8046 2d76 83E2      		ldi r24,lo8(35)
 8047 2d78 90E0      		ldi r25,0
 8048 2d7a 0E94 0000 		call clearEEPROM
 8049               	.LVL623:
2102:switcherator.c ****     clearEEPROM(RADIO_ADDR_R3);
 8050               		.loc 1 2102 0
 8051 2d7e 86E2      		ldi r24,lo8(38)
 8052 2d80 90E0      		ldi r25,0
 8053 2d82 0E94 0000 		call clearEEPROM
 8054               	.LVL624:
2103:switcherator.c ****     clearEEPROM(RADIO_ADDR_R4);
 8055               		.loc 1 2103 0
 8056 2d86 89E2      		ldi r24,lo8(41)
 8057 2d88 90E0      		ldi r25,0
 8058 2d8a 0E94 0000 		call clearEEPROM
 8059               	.LVL625:
2104:switcherator.c ****     clearEEPROM(RADIO_ADDR_R5);
 8060               		.loc 1 2104 0
 8061 2d8e 8CE2      		ldi r24,lo8(44)
 8062 2d90 90E0      		ldi r25,0
 8063 2d92 0E94 0000 		call clearEEPROM
 8064               	.LVL626:
2105:switcherator.c ****     clearEEPROM(SWITCH_STUFF);
 8065               		.loc 1 2105 0
 8066 2d96 80E3      		ldi r24,lo8(48)
 8067 2d98 90E0      		ldi r25,0
 8068 2d9a 0E94 0000 		call clearEEPROM
 8069               	.LVL627:
2106:switcherator.c ****     clearEEPROM(PWM_DIR);
 8070               		.loc 1 2106 0
 8071 2d9e 85E9      		ldi r24,lo8(-107)
 8072 2da0 91E0      		ldi r25,lo8(1)
 8073 2da2 0E94 0000 		call clearEEPROM
 8074               	.LVL628:
2107:switcherator.c ****     clearEEPROM(BRIGHTNESS);
 8075               		.loc 1 2107 0
 8076 2da6 88E9      		ldi r24,lo8(-104)
 8077 2da8 91E0      		ldi r25,lo8(1)
 8078 2daa 0E94 0000 		call clearEEPROM
 8079               	.LVL629:
2109:switcherator.c ****         clearEEPROM((INPUT + (x * INPUT_BYTES)));
 8080               		.loc 1 2109 0
 8081 2dae 82E4      		ldi r24,lo8(66)
 8082 2db0 90E0      		ldi r25,0
 8083 2db2 0E94 0000 		call clearEEPROM
 8084               	.LVL630:
 8085 2db6 8CE4      		ldi r24,lo8(76)
 8086 2db8 90E0      		ldi r25,0
 8087 2dba 0E94 0000 		call clearEEPROM
 8088               	.LVL631:
 8089 2dbe 86E5      		ldi r24,lo8(86)
 8090 2dc0 90E0      		ldi r25,0
 8091 2dc2 0E94 0000 		call clearEEPROM
 8092               	.LVL632:
 8093 2dc6 80E6      		ldi r24,lo8(96)
 8094 2dc8 90E0      		ldi r25,0
 8095 2dca 0E94 0000 		call clearEEPROM
 8096               	.LVL633:
2111:switcherator.c ****         clearEEPROM((LIMIT + (x * LIMIT_BYTES)));
 8097               		.loc 1 2111 0
 8098 2dce 8AE6      		ldi r24,lo8(106)
 8099 2dd0 90E0      		ldi r25,0
 8100 2dd2 0E94 0000 		call clearEEPROM
 8101               	.LVL634:
 8102 2dd6 8FE6      		ldi r24,lo8(111)
 8103 2dd8 90E0      		ldi r25,0
 8104 2dda 0E94 0000 		call clearEEPROM
 8105               	.LVL635:
 8106 2dde 84E7      		ldi r24,lo8(116)
 8107 2de0 90E0      		ldi r25,0
 8108 2de2 0E94 0000 		call clearEEPROM
 8109               	.LVL636:
 8110 2de6 89E7      		ldi r24,lo8(121)
 8111 2de8 90E0      		ldi r25,0
 8112 2dea 0E94 0000 		call clearEEPROM
 8113               	.LVL637:
2112:switcherator.c ****     clearEEPROM(PWM_VALUE);
 8114               		.loc 1 2112 0
 8115 2dee 8EE7      		ldi r24,lo8(126)
 8116 2df0 90E0      		ldi r25,0
 8117 2df2 0E94 0000 		call clearEEPROM
 8118               	.LVL638:
2114:switcherator.c ****         clearEEPROM((COLOR_CHANGE + (x * COLOR_CHANGE_BYTES)));
 8119               		.loc 1 2114 0
 8120 2df6 83E8      		ldi r24,lo8(-125)
 8121 2df8 90E0      		ldi r25,0
 8122 2dfa 0E94 0000 		call clearEEPROM
 8123               	.LVL639:
 8124 2dfe 88E8      		ldi r24,lo8(-120)
 8125 2e00 90E0      		ldi r25,0
 8126 2e02 0E94 0000 		call clearEEPROM
 8127               	.LVL640:
 8128 2e06 8DE8      		ldi r24,lo8(-115)
 8129 2e08 90E0      		ldi r25,0
 8130 2e0a 0E94 0000 		call clearEEPROM
 8131               	.LVL641:
 8132 2e0e 82E9      		ldi r24,lo8(-110)
 8133 2e10 90E0      		ldi r25,0
 8134 2e12 0E94 0000 		call clearEEPROM
 8135               	.LVL642:
 8136 2e16 87E9      		ldi r24,lo8(-105)
 8137 2e18 90E0      		ldi r25,0
 8138 2e1a 0E94 0000 		call clearEEPROM
 8139               	.LVL643:
 8140 2e1e 8CE9      		ldi r24,lo8(-100)
 8141 2e20 90E0      		ldi r25,0
 8142 2e22 0E94 0000 		call clearEEPROM
 8143               	.LVL644:
 8144 2e26 C1EA      		ldi r28,lo8(-95)
 8145 2e28 D0E0      		ldi r29,0
 8146               	.LVL645:
 8147               	.L563:
2116:switcherator.c ****         clearEEPROM((WEEKLY_PROGRAM + (x * WEEKLY_PROGRAM_BYTES)));
 8148               		.loc 1 2116 0 discriminator 2
 8149 2e2a CE01      		movw r24,r28
 8150 2e2c 0E94 0000 		call clearEEPROM
 8151               	.LVL646:
 8152 2e30 2C96      		adiw r28,12
2115:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++)
 8153               		.loc 1 2115 0 discriminator 2
 8154 2e32 C139      		cpi r28,-111
 8155 2e34 81E0      		ldi r24,1
 8156 2e36 D807      		cpc r29,r24
 8157 2e38 01F4      		brne .L563
2117:switcherator.c ****     clearEEPROM(TWEAK_TIMER);
 8158               		.loc 1 2117 0
 8159 2e3a 81E9      		ldi r24,lo8(-111)
 8160 2e3c 91E0      		ldi r25,lo8(1)
 8161 2e3e 0E94 0000 		call clearEEPROM
 8162               	.LVL647:
 8163               	/* epilogue start */
2119:switcherator.c **** }
 8164               		.loc 1 2119 0
 8165 2e42 DF91      		pop r29
 8166 2e44 CF91      		pop r28
2118:switcherator.c ****     ok();
 8167               		.loc 1 2118 0
 8168 2e46 0C94 0000 		jmp ok
 8169               	.LVL648:
 8170               	.LFE47:
 8172               	.global	saveToEEPROM
 8174               	saveToEEPROM:
 8175               	.LFB46:
1965:switcherator.c **** void saveToEEPROM(void) {
 8176               		.loc 1 1965 0
 8177 2e4a BF92      		push r11
 8178               	.LCFI194:
 8179 2e4c CF92      		push r12
 8180               	.LCFI195:
 8181 2e4e DF92      		push r13
 8182               	.LCFI196:
 8183 2e50 EF92      		push r14
 8184               	.LCFI197:
 8185 2e52 FF92      		push r15
 8186               	.LCFI198:
 8187 2e54 0F93      		push r16
 8188               	.LCFI199:
 8189 2e56 1F93      		push r17
 8190               	.LCFI200:
 8191 2e58 CF93      		push r28
 8192               	.LCFI201:
 8193 2e5a DF93      		push r29
 8194               	.LCFI202:
 8195 2e5c CDB7      		in r28,__SP_L__
 8196 2e5e DEB7      		in r29,__SP_H__
 8197               	.LCFI203:
 8198 2e60 2E97      		sbiw r28,14
 8199               	.LCFI204:
 8200 2e62 0FB6      		in __tmp_reg__,__SREG__
 8201 2e64 F894      		cli
 8202 2e66 DEBF      		out __SP_H__,r29
 8203 2e68 0FBE      		out __SREG__,__tmp_reg__
 8204 2e6a CDBF      		out __SP_L__,r28
 8205               	/* prologue: function */
 8206               	/* frame size = 14 */
 8207               	/* stack size = 23 */
 8208               	.L__stack_usage = 23
 8209               	.LVL649:
1969:switcherator.c ****     if (tx_addr > 0) {
 8210               		.loc 1 1969 0
 8211 2e6c B090 0000 		lds r11,tx_addr
 8212 2e70 C090 0000 		lds r12,tx_addr+1
 8213 2e74 D090 0000 		lds r13,tx_addr+2
 8214 2e78 E090 0000 		lds r14,tx_addr+3
 8215 2e7c F090 0000 		lds r15,tx_addr+4
 8216 2e80 B091 0000 		lds r27,tx_addr+5
 8217 2e84 F091 0000 		lds r31,tx_addr+6
 8218 2e88 E091 0000 		lds r30,tx_addr+7
 8219 2e8c 2B2D      		mov r18,r11
 8220 2e8e 3C2D      		mov r19,r12
 8221 2e90 4D2D      		mov r20,r13
 8222 2e92 5E2D      		mov r21,r14
 8223 2e94 6F2D      		mov r22,r15
 8224 2e96 7B2F      		mov r23,r27
 8225 2e98 8F2F      		mov r24,r31
 8226 2e9a 9E2F      		mov r25,r30
 8227 2e9c A0E0      		ldi r26,0
 8228 2e9e 0E94 0000 		call __cmpdi2_s8
 8229 2ea2 01F0      		breq .L566
1970:switcherator.c ****         unformatAddress(tx_addr, tempStuff);
 8230               		.loc 1 1970 0
 8231 2ea4 8E01      		movw r16,r28
 8232 2ea6 0F5F      		subi r16,-1
 8233 2ea8 1F4F      		sbci r17,-1
 8234 2eaa 0E94 0000 		call unformatAddress
 8235               	.LVL650:
1971:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_TX, RADIO_ADDR_TX_BYTES);
 8236               		.loc 1 1971 0
 8237 2eae 47E0      		ldi r20,lo8(7)
 8238 2eb0 50E0      		ldi r21,0
 8239 2eb2 6EE0      		ldi r22,lo8(14)
 8240 2eb4 70E0      		ldi r23,0
 8241 2eb6 C801      		movw r24,r16
 8242 2eb8 0E94 0000 		call writeEEPROM
 8243               	.LVL651:
 8244               	.L566:
1973:switcherator.c ****     if (rx_addr_p0 > 0) {
 8245               		.loc 1 1973 0
 8246 2ebc B090 0000 		lds r11,rx_addr_p0
 8247 2ec0 C090 0000 		lds r12,rx_addr_p0+1
 8248 2ec4 D090 0000 		lds r13,rx_addr_p0+2
 8249 2ec8 E090 0000 		lds r14,rx_addr_p0+3
 8250 2ecc F090 0000 		lds r15,rx_addr_p0+4
 8251 2ed0 B091 0000 		lds r27,rx_addr_p0+5
 8252 2ed4 F091 0000 		lds r31,rx_addr_p0+6
 8253 2ed8 E091 0000 		lds r30,rx_addr_p0+7
 8254 2edc 2B2D      		mov r18,r11
 8255 2ede 3C2D      		mov r19,r12
 8256 2ee0 4D2D      		mov r20,r13
 8257 2ee2 5E2D      		mov r21,r14
 8258 2ee4 6F2D      		mov r22,r15
 8259 2ee6 7B2F      		mov r23,r27
 8260 2ee8 8F2F      		mov r24,r31
 8261 2eea 9E2F      		mov r25,r30
 8262 2eec A0E0      		ldi r26,0
 8263 2eee 0E94 0000 		call __cmpdi2_s8
 8264 2ef2 01F0      		breq .L567
1974:switcherator.c ****         unformatAddress(rx_addr_p0, tempStuff);
 8265               		.loc 1 1974 0
 8266 2ef4 8E01      		movw r16,r28
 8267 2ef6 0F5F      		subi r16,-1
 8268 2ef8 1F4F      		sbci r17,-1
 8269 2efa 0E94 0000 		call unformatAddress
 8270               	.LVL652:
1975:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R0, RADIO_ADDR_R0_BYTES);
 8271               		.loc 1 1975 0
 8272 2efe 47E0      		ldi r20,lo8(7)
 8273 2f00 50E0      		ldi r21,0
 8274 2f02 65E1      		ldi r22,lo8(21)
 8275 2f04 70E0      		ldi r23,0
 8276 2f06 C801      		movw r24,r16
 8277 2f08 0E94 0000 		call writeEEPROM
 8278               	.LVL653:
 8279               	.L567:
1977:switcherator.c ****     if (rx_addr_p1 > 0) {
 8280               		.loc 1 1977 0
 8281 2f0c B090 0000 		lds r11,rx_addr_p1
 8282 2f10 C090 0000 		lds r12,rx_addr_p1+1
 8283 2f14 D090 0000 		lds r13,rx_addr_p1+2
 8284 2f18 E090 0000 		lds r14,rx_addr_p1+3
 8285 2f1c F090 0000 		lds r15,rx_addr_p1+4
 8286 2f20 B091 0000 		lds r27,rx_addr_p1+5
 8287 2f24 F091 0000 		lds r31,rx_addr_p1+6
 8288 2f28 E091 0000 		lds r30,rx_addr_p1+7
 8289 2f2c 2B2D      		mov r18,r11
 8290 2f2e 3C2D      		mov r19,r12
 8291 2f30 4D2D      		mov r20,r13
 8292 2f32 5E2D      		mov r21,r14
 8293 2f34 6F2D      		mov r22,r15
 8294 2f36 7B2F      		mov r23,r27
 8295 2f38 8F2F      		mov r24,r31
 8296 2f3a 9E2F      		mov r25,r30
 8297 2f3c A0E0      		ldi r26,0
 8298 2f3e 0E94 0000 		call __cmpdi2_s8
 8299 2f42 01F0      		breq .L568
1978:switcherator.c ****         unformatAddress(rx_addr_p1, tempStuff);
 8300               		.loc 1 1978 0
 8301 2f44 8E01      		movw r16,r28
 8302 2f46 0F5F      		subi r16,-1
 8303 2f48 1F4F      		sbci r17,-1
 8304 2f4a 0E94 0000 		call unformatAddress
 8305               	.LVL654:
1979:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R1, RADIO_ADDR_R1_BYTES);
 8306               		.loc 1 1979 0
 8307 2f4e 47E0      		ldi r20,lo8(7)
 8308 2f50 50E0      		ldi r21,0
 8309 2f52 6CE1      		ldi r22,lo8(28)
 8310 2f54 70E0      		ldi r23,0
 8311 2f56 C801      		movw r24,r16
 8312 2f58 0E94 0000 		call writeEEPROM
 8313               	.LVL655:
 8314               	.L568:
1981:switcherator.c ****     if (rx_addr_p2 > 0) {
 8315               		.loc 1 1981 0
 8316 2f5c E091 0000 		lds r30,rx_addr_p2
 8317 2f60 3091 0000 		lds r19,rx_addr_p2+1
 8318 2f64 4091 0000 		lds r20,rx_addr_p2+2
 8319 2f68 5091 0000 		lds r21,rx_addr_p2+3
 8320 2f6c 6091 0000 		lds r22,rx_addr_p2+4
 8321 2f70 7091 0000 		lds r23,rx_addr_p2+5
 8322 2f74 2E2F      		mov r18,r30
 8323 2f76 8091 0000 		lds r24,rx_addr_p2+6
 8324 2f7a 9091 0000 		lds r25,rx_addr_p2+7
 8325 2f7e A0E0      		ldi r26,0
 8326 2f80 0E94 0000 		call __cmpdi2_s8
 8327 2f84 01F0      		breq .L569
1982:switcherator.c ****         tempStuff[0] = rx_addr_p2;
 8328               		.loc 1 1982 0
 8329 2f86 E983      		std Y+1,r30
1983:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R2, RADIO_ADDR_R2_BYTES);
 8330               		.loc 1 1983 0
 8331 2f88 43E0      		ldi r20,lo8(3)
 8332 2f8a 50E0      		ldi r21,0
 8333 2f8c 63E2      		ldi r22,lo8(35)
 8334 2f8e 70E0      		ldi r23,0
 8335 2f90 CE01      		movw r24,r28
 8336 2f92 0196      		adiw r24,1
 8337 2f94 0E94 0000 		call writeEEPROM
 8338               	.LVL656:
 8339               	.L569:
1985:switcherator.c ****     if (rx_addr_p3 > 0) {
 8340               		.loc 1 1985 0
 8341 2f98 E091 0000 		lds r30,rx_addr_p3
 8342 2f9c 3091 0000 		lds r19,rx_addr_p3+1
 8343 2fa0 4091 0000 		lds r20,rx_addr_p3+2
 8344 2fa4 5091 0000 		lds r21,rx_addr_p3+3
 8345 2fa8 6091 0000 		lds r22,rx_addr_p3+4
 8346 2fac 7091 0000 		lds r23,rx_addr_p3+5
 8347 2fb0 2E2F      		mov r18,r30
 8348 2fb2 8091 0000 		lds r24,rx_addr_p3+6
 8349 2fb6 9091 0000 		lds r25,rx_addr_p3+7
 8350 2fba A0E0      		ldi r26,0
 8351 2fbc 0E94 0000 		call __cmpdi2_s8
 8352 2fc0 01F0      		breq .L570
1986:switcherator.c ****         tempStuff[0] = rx_addr_p3;
 8353               		.loc 1 1986 0
 8354 2fc2 E983      		std Y+1,r30
1987:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R3, RADIO_ADDR_R3_BYTES);
 8355               		.loc 1 1987 0
 8356 2fc4 43E0      		ldi r20,lo8(3)
 8357 2fc6 50E0      		ldi r21,0
 8358 2fc8 66E2      		ldi r22,lo8(38)
 8359 2fca 70E0      		ldi r23,0
 8360 2fcc CE01      		movw r24,r28
 8361 2fce 0196      		adiw r24,1
 8362 2fd0 0E94 0000 		call writeEEPROM
 8363               	.LVL657:
 8364               	.L570:
1989:switcherator.c ****     if (rx_addr_p4 > 0) {
 8365               		.loc 1 1989 0
 8366 2fd4 E091 0000 		lds r30,rx_addr_p4
 8367 2fd8 3091 0000 		lds r19,rx_addr_p4+1
 8368 2fdc 4091 0000 		lds r20,rx_addr_p4+2
 8369 2fe0 5091 0000 		lds r21,rx_addr_p4+3
 8370 2fe4 6091 0000 		lds r22,rx_addr_p4+4
 8371 2fe8 7091 0000 		lds r23,rx_addr_p4+5
 8372 2fec 2E2F      		mov r18,r30
 8373 2fee 8091 0000 		lds r24,rx_addr_p4+6
 8374 2ff2 9091 0000 		lds r25,rx_addr_p4+7
 8375 2ff6 A0E0      		ldi r26,0
 8376 2ff8 0E94 0000 		call __cmpdi2_s8
 8377 2ffc 01F0      		breq .L571
1990:switcherator.c ****         tempStuff[0] = rx_addr_p4;
 8378               		.loc 1 1990 0
 8379 2ffe E983      		std Y+1,r30
1991:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R4, RADIO_ADDR_R4_BYTES);
 8380               		.loc 1 1991 0
 8381 3000 43E0      		ldi r20,lo8(3)
 8382 3002 50E0      		ldi r21,0
 8383 3004 69E2      		ldi r22,lo8(41)
 8384 3006 70E0      		ldi r23,0
 8385 3008 CE01      		movw r24,r28
 8386 300a 0196      		adiw r24,1
 8387 300c 0E94 0000 		call writeEEPROM
 8388               	.LVL658:
 8389               	.L571:
1993:switcherator.c ****     if (rx_addr_p5 > 0) {
 8390               		.loc 1 1993 0
 8391 3010 E091 0000 		lds r30,rx_addr_p5
 8392 3014 3091 0000 		lds r19,rx_addr_p5+1
 8393 3018 4091 0000 		lds r20,rx_addr_p5+2
 8394 301c 5091 0000 		lds r21,rx_addr_p5+3
 8395 3020 6091 0000 		lds r22,rx_addr_p5+4
 8396 3024 7091 0000 		lds r23,rx_addr_p5+5
 8397 3028 2E2F      		mov r18,r30
 8398 302a 8091 0000 		lds r24,rx_addr_p5+6
 8399 302e 9091 0000 		lds r25,rx_addr_p5+7
 8400 3032 A0E0      		ldi r26,0
 8401 3034 0E94 0000 		call __cmpdi2_s8
 8402 3038 01F0      		breq .L572
1994:switcherator.c ****         tempStuff[0] = rx_addr_p5;
 8403               		.loc 1 1994 0
 8404 303a E983      		std Y+1,r30
1995:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R5, RADIO_ADDR_R5_BYTES);
 8405               		.loc 1 1995 0
 8406 303c 43E0      		ldi r20,lo8(3)
 8407 303e 50E0      		ldi r21,0
 8408 3040 6CE2      		ldi r22,lo8(44)
 8409 3042 70E0      		ldi r23,0
 8410 3044 CE01      		movw r24,r28
 8411 3046 0196      		adiw r24,1
 8412 3048 0E94 0000 		call writeEEPROM
 8413               	.LVL659:
 8414               	.L572:
1998:switcherator.c ****     if (tweakTimer != 0) {
 8415               		.loc 1 1998 0
 8416 304c 8091 0000 		lds r24,tweakTimer
 8417 3050 9091 0000 		lds r25,tweakTimer+1
 8418 3054 A091 0000 		lds r26,tweakTimer+2
 8419 3058 B091 0000 		lds r27,tweakTimer+3
 8420 305c 0097      		sbiw r24,0
 8421 305e A105      		cpc r26,__zero_reg__
 8422 3060 B105      		cpc r27,__zero_reg__
 8423 3062 01F0      		breq .L573
1999:switcherator.c ****         tempStuff[0] = tweakTimer >> 8;
 8424               		.loc 1 1999 0
 8425 3064 9983      		std Y+1,r25
2000:switcherator.c ****         tempStuff[1] = (tweakTimer & 0xff);
 8426               		.loc 1 2000 0
 8427 3066 8A83      		std Y+2,r24
2001:switcherator.c ****         writeEEPROM(tempStuff, TWEAK_TIMER, TWEAK_TIMER_BYTES);
 8428               		.loc 1 2001 0
 8429 3068 44E0      		ldi r20,lo8(4)
 8430 306a 50E0      		ldi r21,0
 8431 306c 61E9      		ldi r22,lo8(-111)
 8432 306e 71E0      		ldi r23,lo8(1)
 8433 3070 CE01      		movw r24,r28
 8434 3072 0196      		adiw r24,1
 8435 3074 0E94 0000 		call writeEEPROM
 8436               	.LVL660:
 8437               	.L573:
2006:switcherator.c ****     if (daylightSavings[0][0] > 0) {
 8438               		.loc 1 2006 0
 8439 3078 8091 0000 		lds r24,daylightSavings
 8440 307c 9091 0000 		lds r25,daylightSavings+1
 8441 3080 0097      		sbiw r24,0
 8442 3082 01F0      		breq .L574
2007:switcherator.c ****         tempStuff[0] = (daylightSavings[0][0] >> 8);
 8443               		.loc 1 2007 0
 8444 3084 9983      		std Y+1,r25
2008:switcherator.c ****         tempStuff[1] = (daylightSavings[0][0] & 0xff);
 8445               		.loc 1 2008 0
 8446 3086 8A83      		std Y+2,r24
2009:switcherator.c ****         tempStuff[2] = (daylightSavings[0][1] >> 8);
 8447               		.loc 1 2009 0
 8448 3088 8091 0000 		lds r24,daylightSavings+2
 8449 308c 9091 0000 		lds r25,daylightSavings+3
 8450 3090 9B83      		std Y+3,r25
2010:switcherator.c ****         tempStuff[3] = (daylightSavings[0][1] & 0xff);
 8451               		.loc 1 2010 0
 8452 3092 8C83      		std Y+4,r24
2011:switcherator.c ****         tempStuff[4] = (daylightSavings[1][0] >> 8);
 8453               		.loc 1 2011 0
 8454 3094 8091 0000 		lds r24,daylightSavings+4
 8455 3098 9091 0000 		lds r25,daylightSavings+5
 8456 309c 9D83      		std Y+5,r25
2012:switcherator.c ****         tempStuff[5] = (daylightSavings[1][0] & 0xff);
 8457               		.loc 1 2012 0
 8458 309e 8E83      		std Y+6,r24
2013:switcherator.c ****         tempStuff[6] = (daylightSavings[1][1] >> 8);
 8459               		.loc 1 2013 0
 8460 30a0 8091 0000 		lds r24,daylightSavings+6
 8461 30a4 9091 0000 		lds r25,daylightSavings+7
 8462 30a8 9F83      		std Y+7,r25
2014:switcherator.c ****         tempStuff[7] = (daylightSavings[1][1] & 0xff);
 8463               		.loc 1 2014 0
 8464 30aa 8887      		std Y+8,r24
2015:switcherator.c ****         writeEEPROM(tempStuff, DAYLIGHT_SAVE, DAYLIGHT_SAVE_BYTES);
 8465               		.loc 1 2015 0
 8466 30ac 4AE0      		ldi r20,lo8(10)
 8467 30ae 50E0      		ldi r21,0
 8468 30b0 66E0      		ldi r22,lo8(6)
 8469 30b2 70E0      		ldi r23,0
 8470 30b4 CE01      		movw r24,r28
 8471 30b6 0196      		adiw r24,1
 8472 30b8 0E94 0000 		call writeEEPROM
 8473               	.LVL661:
 8474               	.L574:
 8475 30bc E0E0      		ldi r30,lo8(switchStuff)
 8476 30be F0E0      		ldi r31,hi8(switchStuff)
2018:switcherator.c ****     char setupPWM = 0;
 8477               		.loc 1 2018 0
 8478 30c0 10E0      		ldi r17,0
2017:switcherator.c ****     char setupaSwitch = 0;
 8479               		.loc 1 2017 0
 8480 30c2 80E0      		ldi r24,0
 8481               	.LVL662:
 8482               	.L577:
2021:switcherator.c ****         if (switchStuff[x] < 255)
 8483               		.loc 1 2021 0
 8484 30c4 9191      		ld r25,Z+
 8485 30c6 9F3F      		cpi r25,lo8(-1)
 8486 30c8 01F0      		breq .L575
2022:switcherator.c ****             setupaSwitch = 1;
 8487               		.loc 1 2022 0
 8488 30ca 81E0      		ldi r24,lo8(1)
 8489               	.L575:
 8490               	.LVL663:
2023:switcherator.c ****         if (switchStuff[x] >= 200 && switchStuff[x] <= 230)
 8491               		.loc 1 2023 0
 8492 30cc 985C      		subi r25,lo8(-(56))
 8493 30ce 9F31      		cpi r25,lo8(31)
 8494 30d0 00F4      		brsh .L576
2024:switcherator.c ****             setupPWM = 1;
 8495               		.loc 1 2024 0
 8496 30d2 11E0      		ldi r17,lo8(1)
 8497               	.L576:
 8498               	.LVL664:
2020:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 8499               		.loc 1 2020 0
 8500 30d4 90E0      		ldi r25,hi8(switchStuff+16)
 8501 30d6 E030      		cpi r30,lo8(switchStuff+16)
 8502 30d8 F907      		cpc r31,r25
 8503 30da 01F4      		brne .L577
2026:switcherator.c ****     if (setupaSwitch == 1) {
 8504               		.loc 1 2026 0
 8505 30dc 8130      		cpi r24,lo8(1)
 8506 30de 01F4      		brne .L578
2027:switcherator.c ****         writeEEPROM(switchStuff, SWITCH_STUFF, SWITCH_STUFF_BYTES);
 8507               		.loc 1 2027 0
 8508 30e0 42E1      		ldi r20,lo8(18)
 8509 30e2 50E0      		ldi r21,0
 8510 30e4 60E3      		ldi r22,lo8(48)
 8511 30e6 70E0      		ldi r23,0
 8512 30e8 80E0      		ldi r24,lo8(switchStuff)
 8513 30ea 90E0      		ldi r25,hi8(switchStuff)
 8514               	.LVL665:
 8515 30ec 0E94 0000 		call writeEEPROM
 8516               	.LVL666:
2028:switcherator.c ****         writeEEPROM(switchBright, BRIGHTNESS, BRIGHTNESS_BYTES);
 8517               		.loc 1 2028 0
 8518 30f0 42E1      		ldi r20,lo8(18)
 8519 30f2 50E0      		ldi r21,0
 8520 30f4 68E9      		ldi r22,lo8(-104)
 8521 30f6 71E0      		ldi r23,lo8(1)
 8522 30f8 80E0      		ldi r24,lo8(switchBright)
 8523 30fa 90E0      		ldi r25,hi8(switchBright)
 8524 30fc 0E94 0000 		call writeEEPROM
 8525               	.LVL667:
 8526               	.L578:
2030:switcherator.c ****     tempStuff[0] = pwmdir;
 8527               		.loc 1 2030 0
 8528 3100 8091 0000 		lds r24,pwmdir
 8529 3104 8983      		std Y+1,r24
2031:switcherator.c ****     if (setupPWM == 1)
 8530               		.loc 1 2031 0
 8531 3106 1130      		cpi r17,lo8(1)
 8532 3108 01F4      		brne .L579
2032:switcherator.c ****         writeEEPROM(tempStuff, PWM_DIR, PWM_DIR_BYTES);
 8533               		.loc 1 2032 0
 8534 310a 43E0      		ldi r20,lo8(3)
 8535 310c 50E0      		ldi r21,0
 8536 310e 65E9      		ldi r22,lo8(-107)
 8537 3110 71E0      		ldi r23,lo8(1)
 8538 3112 CE01      		movw r24,r28
 8539 3114 0196      		adiw r24,1
 8540 3116 0E94 0000 		call writeEEPROM
 8541               	.LVL668:
 8542               	.L579:
 8543 311a 20E0      		ldi r18,lo8(weeklyProgram)
 8544 311c E22E      		mov r14,r18
 8545 311e 20E0      		ldi r18,hi8(weeklyProgram)
 8546 3120 F22E      		mov r15,r18
 8547 3122 30E0      		ldi r19,lo8(weeklyProgram+1)
 8548 3124 C32E      		mov r12,r19
 8549 3126 30E0      		ldi r19,hi8(weeklyProgram+1)
 8550 3128 D32E      		mov r13,r19
2024:switcherator.c ****             setupPWM = 1;
 8551               		.loc 1 2024 0 discriminator 1
 8552 312a 01EA      		ldi r16,lo8(-95)
 8553 312c 10E0      		ldi r17,0
 8554               	.LVL669:
 8555               	.L583:
2042:switcherator.c ****         memoryMarker = (WEEKLY_PROGRAM + (x * WEEKLY_PROGRAM_BYTES));
 8556               		.loc 1 2042 0
 8557 312e B801      		movw r22,r16
 8558               	.LVL670:
2043:switcherator.c ****         if (weeklyProgram[x][0] != 255 || weeklyProgram[x][1] != 255) {
 8559               		.loc 1 2043 0
 8560 3130 F701      		movw r30,r14
 8561 3132 8081      		ld r24,Z
 8562 3134 8F3F      		cpi r24,lo8(-1)
 8563 3136 01F4      		brne .L580
2043:switcherator.c ****         if (weeklyProgram[x][0] != 255 || weeklyProgram[x][1] != 255) {
 8564               		.loc 1 2043 0 is_stmt 0 discriminator 1
 8565 3138 F601      		movw r30,r12
 8566 313a 8081      		ld r24,Z
 8567 313c 8F3F      		cpi r24,lo8(-1)
 8568 313e 01F0      		breq .L581
 8569               	.L580:
 8570 3140 FE01      		movw r30,r28
 8571 3142 3196      		adiw r30,1
2024:switcherator.c ****             setupPWM = 1;
 8572               		.loc 1 2024 0 is_stmt 1 discriminator 2
 8573 3144 80E0      		ldi r24,0
 8574 3146 90E0      		ldi r25,0
 8575               	.L582:
1965:switcherator.c **** void saveToEEPROM(void) {
 8576               		.loc 1 1965 0 discriminator 2
 8577 3148 D701      		movw r26,r14
 8578 314a A80F      		add r26,r24
 8579 314c B91F      		adc r27,r25
2045:switcherator.c ****                 tempStuff[y] = weeklyProgram[x][y];
 8580               		.loc 1 2045 0 discriminator 2
 8581 314e 2C91      		ld r18,X
 8582 3150 2193      		st Z+,r18
2044:switcherator.c ****             for (y = 0; y < 10; y++)
 8583               		.loc 1 2044 0 discriminator 2
 8584 3152 0196      		adiw r24,1
 8585               	.LVL671:
 8586 3154 8A30      		cpi r24,10
 8587 3156 9105      		cpc r25,__zero_reg__
 8588 3158 01F4      		brne .L582
2046:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, WEEKLY_PROGRAM_BYTES);
 8589               		.loc 1 2046 0
 8590 315a 4CE0      		ldi r20,lo8(12)
 8591 315c 50E0      		ldi r21,0
 8592 315e CE01      		movw r24,r28
 8593               	.LVL672:
 8594 3160 0196      		adiw r24,1
 8595 3162 0E94 0000 		call writeEEPROM
 8596               	.LVL673:
 8597               	.L581:
 8598 3166 FAE0      		ldi r31,10
 8599 3168 EF0E      		add r14,r31
 8600 316a F11C      		adc r15,__zero_reg__
 8601 316c 8AE0      		ldi r24,10
 8602 316e C80E      		add r12,r24
 8603 3170 D11C      		adc r13,__zero_reg__
 8604 3172 045F      		subi r16,-12
 8605 3174 1F4F      		sbci r17,-1
2041:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 8606               		.loc 1 2041 0
 8607 3176 0139      		cpi r16,-111
 8608 3178 91E0      		ldi r25,1
 8609 317a 1907      		cpc r17,r25
 8610 317c 01F4      		brne .L583
 8611 317e 90E0      		ldi r25,lo8(inputs)
 8612 3180 E92E      		mov r14,r25
 8613 3182 90E0      		ldi r25,hi8(inputs)
 8614 3184 F92E      		mov r15,r25
 8615 3186 02E4      		ldi r16,lo8(66)
 8616 3188 10E0      		ldi r17,0
 8617               	.L586:
2053:switcherator.c ****         if (inputs[x][0] != 255) {
 8618               		.loc 1 2053 0
 8619 318a F701      		movw r30,r14
 8620 318c 8081      		ld r24,Z
 8621 318e 8F3F      		cpi r24,lo8(-1)
 8622 3190 01F0      		breq .L584
 8623 3192 FE01      		movw r30,r28
 8624 3194 3196      		adiw r30,1
 8625 3196 80E0      		ldi r24,0
 8626 3198 90E0      		ldi r25,0
 8627               	.L585:
1965:switcherator.c **** void saveToEEPROM(void) {
 8628               		.loc 1 1965 0 discriminator 2
 8629 319a D701      		movw r26,r14
 8630 319c A80F      		add r26,r24
 8631 319e B91F      		adc r27,r25
2055:switcherator.c ****                 tempStuff[y] = inputs[x][y];
 8632               		.loc 1 2055 0 discriminator 2
 8633 31a0 2C91      		ld r18,X
 8634 31a2 2193      		st Z+,r18
2054:switcherator.c ****             for (y = 0; y < 8; y++) {
 8635               		.loc 1 2054 0 discriminator 2
 8636 31a4 0196      		adiw r24,1
 8637               	.LVL674:
 8638 31a6 8830      		cpi r24,8
 8639 31a8 9105      		cpc r25,__zero_reg__
 8640 31aa 01F4      		brne .L585
2057:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, INPUT_BYTES);
 8641               		.loc 1 2057 0
 8642 31ac 4AE0      		ldi r20,lo8(10)
 8643 31ae 50E0      		ldi r21,0
 8644 31b0 B801      		movw r22,r16
 8645 31b2 CE01      		movw r24,r28
 8646               	.LVL675:
 8647 31b4 0196      		adiw r24,1
 8648 31b6 0E94 0000 		call writeEEPROM
 8649               	.LVL676:
 8650               	.L584:
 8651 31ba F8E0      		ldi r31,8
 8652 31bc EF0E      		add r14,r31
 8653 31be F11C      		adc r15,__zero_reg__
 8654 31c0 065F      		subi r16,-10
 8655 31c2 1F4F      		sbci r17,-1
2051:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 8656               		.loc 1 2051 0
 8657 31c4 0A36      		cpi r16,106
 8658 31c6 1105      		cpc r17,__zero_reg__
 8659 31c8 01F4      		brne .L586
 8660 31ca 00E0      		ldi r16,lo8(timeLimits)
 8661 31cc 10E0      		ldi r17,hi8(timeLimits)
 8662 31ce 8AE6      		ldi r24,lo8(106)
 8663 31d0 E82E      		mov r14,r24
 8664 31d2 F12C      		mov r15,__zero_reg__
 8665               	.L588:
2064:switcherator.c ****         if (timeLimits[x][2] > 0) {
 8666               		.loc 1 2064 0
 8667 31d4 F801      		movw r30,r16
 8668 31d6 8085      		ldd r24,Z+8
 8669 31d8 9185      		ldd r25,Z+9
 8670 31da A285      		ldd r26,Z+10
 8671 31dc B385      		ldd r27,Z+11
 8672 31de 0097      		sbiw r24,0
 8673 31e0 A105      		cpc r26,__zero_reg__
 8674 31e2 B105      		cpc r27,__zero_reg__
 8675 31e4 01F0      		breq .L587
 8676               	.LVL677:
2066:switcherator.c ****                 tempStuff[y] = timeLimits[x][y];
 8677               		.loc 1 2066 0 discriminator 1
 8678 31e6 2081      		ld r18,Z
 8679 31e8 2983      		std Y+1,r18
 8680               	.LVL678:
 8681 31ea 2481      		ldd r18,Z+4
 8682 31ec 2A83      		std Y+2,r18
 8683               	.LVL679:
 8684 31ee 8B83      		std Y+3,r24
 8685               	.LVL680:
2068:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, INPUT_BYTES);
 8686               		.loc 1 2068 0 discriminator 1
 8687 31f0 4AE0      		ldi r20,lo8(10)
 8688 31f2 50E0      		ldi r21,0
 8689 31f4 B701      		movw r22,r14
 8690 31f6 CE01      		movw r24,r28
 8691 31f8 0196      		adiw r24,1
 8692 31fa 0E94 0000 		call writeEEPROM
 8693               	.LVL681:
 8694               	.L587:
 8695 31fe 045F      		subi r16,-12
 8696 3200 1F4F      		sbci r17,-1
 8697 3202 F5E0      		ldi r31,5
 8698 3204 EF0E      		add r14,r31
 8699 3206 F11C      		adc r15,__zero_reg__
2062:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++) {
 8700               		.loc 1 2062 0
 8701 3208 8EE7      		ldi r24,126
 8702 320a E816      		cp r14,r24
 8703 320c F104      		cpc r15,__zero_reg__
 8704 320e 01F4      		brne .L588
 8705               	.LVL682:
2075:switcherator.c ****     if (pwmValues[0] != 0 || pwmValues[1] != 0 || pwmValues[2] != 0) {
 8706               		.loc 1 2075 0
 8707 3210 8091 0000 		lds r24,pwmValues
 8708 3214 8111      		cpse r24,__zero_reg__
 8709 3216 00C0      		rjmp .L589
2075:switcherator.c ****     if (pwmValues[0] != 0 || pwmValues[1] != 0 || pwmValues[2] != 0) {
 8710               		.loc 1 2075 0 is_stmt 0 discriminator 1
 8711 3218 9091 0000 		lds r25,pwmValues+1
 8712 321c 9923      		tst r25
 8713 321e 01F0      		breq .L590
 8714               	.L589:
 8715               	.LVL683:
2077:switcherator.c ****             tempStuff[y] = pwmValues[y];
 8716               		.loc 1 2077 0 is_stmt 1 discriminator 1
 8717 3220 8983      		std Y+1,r24
 8718               	.LVL684:
 8719 3222 8091 0000 		lds r24,pwmValues+1
 8720 3226 8A83      		std Y+2,r24
 8721               	.LVL685:
 8722 3228 8091 0000 		lds r24,pwmValues+2
 8723 322c 8B83      		std Y+3,r24
 8724               	.LVL686:
2079:switcherator.c ****         writeEEPROM(tempStuff, memoryMarker, PWM_VALUE_BYTES);
 8725               		.loc 1 2079 0 discriminator 1
 8726 322e 45E0      		ldi r20,lo8(5)
 8727 3230 50E0      		ldi r21,0
 8728 3232 6EE7      		ldi r22,lo8(126)
 8729 3234 70E0      		ldi r23,0
 8730 3236 CE01      		movw r24,r28
 8731 3238 0196      		adiw r24,1
 8732 323a 0E94 0000 		call writeEEPROM
 8733               	.LVL687:
 8734               	.L592:
 8735 323e B0E0      		ldi r27,lo8(inputs+2)
 8736 3240 EB2E      		mov r14,r27
 8737 3242 B0E0      		ldi r27,hi8(inputs+2)
 8738 3244 FB2E      		mov r15,r27
2051:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 8739               		.loc 1 2051 0 discriminator 1
 8740 3246 03E8      		ldi r16,lo8(-125)
 8741 3248 10E0      		ldi r17,0
 8742 324a 00C0      		rjmp .L591
 8743               	.LVL688:
 8744               	.L590:
2075:switcherator.c ****     if (pwmValues[0] != 0 || pwmValues[1] != 0 || pwmValues[2] != 0) {
 8745               		.loc 1 2075 0 discriminator 1
 8746 324c 9091 0000 		lds r25,pwmValues+2
 8747 3250 9111      		cpse r25,__zero_reg__
 8748 3252 00C0      		rjmp .L589
 8749 3254 00C0      		rjmp .L592
 8750               	.LVL689:
 8751               	.L591:
2084:switcherator.c ****         memoryMarker = (COLOR_CHANGE + (x * COLOR_CHANGE_BYTES));
 8752               		.loc 1 2084 0
 8753 3256 B801      		movw r22,r16
 8754               	.LVL690:
2085:switcherator.c ****         if (colorChanges[0][0] != 0 || colorChanges[0][1] != 1 || colorChanges[0][2] != 0) {
 8755               		.loc 1 2085 0
 8756 3258 8091 0000 		lds r24,colorChanges
 8757 325c 8111      		cpse r24,__zero_reg__
 8758 325e 00C0      		rjmp .L593
2085:switcherator.c ****         if (colorChanges[0][0] != 0 || colorChanges[0][1] != 1 || colorChanges[0][2] != 0) {
 8759               		.loc 1 2085 0 is_stmt 0 discriminator 1
 8760 3260 8091 0000 		lds r24,colorChanges+1
 8761 3264 8130      		cpi r24,lo8(1)
 8762 3266 01F0      		breq .L594
 8763               	.L593:
 8764               	.LVL691:
1965:switcherator.c **** void saveToEEPROM(void) {
 8765               		.loc 1 1965 0 is_stmt 1 discriminator 1
 8766 3268 F701      		movw r30,r14
 8767 326a 3297      		sbiw r30,2
2087:switcherator.c ****                 tempStuff[y] = inputs[x][y];
 8768               		.loc 1 2087 0 discriminator 1
 8769 326c 8081      		ld r24,Z
 8770 326e 8983      		std Y+1,r24
 8771               	.LVL692:
1965:switcherator.c **** void saveToEEPROM(void) {
 8772               		.loc 1 1965 0 discriminator 1
 8773 3270 F701      		movw r30,r14
 8774 3272 3197      		sbiw r30,1
2087:switcherator.c ****                 tempStuff[y] = inputs[x][y];
 8775               		.loc 1 2087 0 discriminator 1
 8776 3274 8081      		ld r24,Z
 8777 3276 8A83      		std Y+2,r24
 8778               	.LVL693:
 8779 3278 F701      		movw r30,r14
 8780 327a 8081      		ld r24,Z
 8781 327c 8B83      		std Y+3,r24
 8782               	.LVL694:
2089:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, COLOR_CHANGE_BYTES);
 8783               		.loc 1 2089 0 discriminator 1
 8784 327e 45E0      		ldi r20,lo8(5)
 8785 3280 50E0      		ldi r21,0
 8786 3282 CE01      		movw r24,r28
 8787 3284 0196      		adiw r24,1
 8788 3286 0E94 0000 		call writeEEPROM
 8789               	.LVL695:
 8790 328a 00C0      		rjmp .L595
 8791               	.LVL696:
 8792               	.L594:
2085:switcherator.c ****         if (colorChanges[0][0] != 0 || colorChanges[0][1] != 1 || colorChanges[0][2] != 0) {
 8793               		.loc 1 2085 0 discriminator 1
 8794 328c 8091 0000 		lds r24,colorChanges+2
 8795 3290 8111      		cpse r24,__zero_reg__
 8796 3292 00C0      		rjmp .L593
 8797               	.LVL697:
 8798               	.L595:
 8799 3294 F8E0      		ldi r31,8
 8800 3296 EF0E      		add r14,r31
 8801 3298 F11C      		adc r15,__zero_reg__
 8802 329a 0B5F      		subi r16,-5
 8803 329c 1F4F      		sbci r17,-1
2083:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 8804               		.loc 1 2083 0
 8805 329e 013A      		cpi r16,-95
 8806 32a0 1105      		cpc r17,__zero_reg__
 8807 32a2 01F4      		brne .L591
2092:switcherator.c ****     ok();
 8808               		.loc 1 2092 0
 8809 32a4 0E94 0000 		call ok
 8810               	.LVL698:
 8811               	/* epilogue start */
2093:switcherator.c **** }
 8812               		.loc 1 2093 0
 8813 32a8 2E96      		adiw r28,14
 8814 32aa 0FB6      		in __tmp_reg__,__SREG__
 8815 32ac F894      		cli
 8816 32ae DEBF      		out __SP_H__,r29
 8817 32b0 0FBE      		out __SREG__,__tmp_reg__
 8818 32b2 CDBF      		out __SP_L__,r28
 8819 32b4 DF91      		pop r29
 8820 32b6 CF91      		pop r28
 8821 32b8 1F91      		pop r17
 8822               	.LVL699:
 8823 32ba 0F91      		pop r16
 8824 32bc FF90      		pop r15
 8825 32be EF90      		pop r14
 8826 32c0 DF90      		pop r13
 8827 32c2 CF90      		pop r12
 8828 32c4 BF90      		pop r11
 8829 32c6 0895      		ret
 8830               	.LFE46:
 8832               	.global	pwmValueSet
 8834               	pwmValueSet:
 8835               	.LFB23:
 921:switcherator.c **** void pwmValueSet(char * commandReceived) {
 8836               		.loc 1 921 0
 8837               	.LVL700:
 8838 32c8 CF92      		push r12
 8839               	.LCFI205:
 8840 32ca DF92      		push r13
 8841               	.LCFI206:
 8842 32cc EF92      		push r14
 8843               	.LCFI207:
 8844 32ce FF92      		push r15
 8845               	.LCFI208:
 8846 32d0 0F93      		push r16
 8847               	.LCFI209:
 8848 32d2 1F93      		push r17
 8849               	.LCFI210:
 8850 32d4 CF93      		push r28
 8851               	.LCFI211:
 8852 32d6 DF93      		push r29
 8853               	.LCFI212:
 8854               	/* prologue: function */
 8855               	/* frame size = 0 */
 8856               	/* stack size = 8 */
 8857               	.L__stack_usage = 8
 8858 32d8 EC01      		movw r28,r24
 922:switcherator.c ****     tempLongString[3] = 0;
 8859               		.loc 1 922 0
 8860 32da 1092 0000 		sts tempLongString+3,__zero_reg__
 923:switcherator.c ****     tempLongString[0] = commandReceived[6];
 8861               		.loc 1 923 0
 8862 32de 40E0      		ldi r20,lo8(tempLongString)
 8863 32e0 C42E      		mov r12,r20
 8864 32e2 40E0      		ldi r20,hi8(tempLongString)
 8865 32e4 D42E      		mov r13,r20
 8866 32e6 8E81      		ldd r24,Y+6
 8867               	.LVL701:
 8868 32e8 F601      		movw r30,r12
 8869 32ea 8083      		st Z,r24
 924:switcherator.c ****     tempLongString[1] = commandReceived[7];
 8870               		.loc 1 924 0
 8871 32ec 50E0      		ldi r21,lo8(tempLongString+1)
 8872 32ee E52E      		mov r14,r21
 8873 32f0 50E0      		ldi r21,hi8(tempLongString+1)
 8874 32f2 F52E      		mov r15,r21
 8875 32f4 8F81      		ldd r24,Y+7
 8876 32f6 F701      		movw r30,r14
 8877 32f8 8083      		st Z,r24
 925:switcherator.c ****     tempLongString[2] = commandReceived[8];
 8878               		.loc 1 925 0
 8879 32fa 00E0      		ldi r16,lo8(tempLongString+2)
 8880 32fc 10E0      		ldi r17,hi8(tempLongString+2)
 8881 32fe 8885      		ldd r24,Y+8
 8882 3300 F801      		movw r30,r16
 8883 3302 8083      		st Z,r24
 926:switcherator.c ****     pwmValues[0] = atoi(tempLongString);
 8884               		.loc 1 926 0
 8885 3304 C601      		movw r24,r12
 8886 3306 0E94 0000 		call atoi
 8887               	.LVL702:
 8888 330a 8093 0000 		sts pwmValues,r24
 927:switcherator.c ****     tempLongString[0] = commandReceived[10];
 8889               		.loc 1 927 0
 8890 330e 8A85      		ldd r24,Y+10
 8891 3310 F601      		movw r30,r12
 8892 3312 8083      		st Z,r24
 928:switcherator.c ****     tempLongString[1] = commandReceived[11];
 8893               		.loc 1 928 0
 8894 3314 8B85      		ldd r24,Y+11
 8895 3316 F701      		movw r30,r14
 8896 3318 8083      		st Z,r24
 929:switcherator.c ****     tempLongString[2] = commandReceived[12];
 8897               		.loc 1 929 0
 8898 331a 8C85      		ldd r24,Y+12
 8899 331c F801      		movw r30,r16
 8900 331e 8083      		st Z,r24
 930:switcherator.c ****     pwmValues[1] = atoi(tempLongString);
 8901               		.loc 1 930 0
 8902 3320 C601      		movw r24,r12
 8903 3322 0E94 0000 		call atoi
 8904               	.LVL703:
 8905 3326 8093 0000 		sts pwmValues+1,r24
 931:switcherator.c ****     tempLongString[0] = commandReceived[14];
 8906               		.loc 1 931 0
 8907 332a 8E85      		ldd r24,Y+14
 8908 332c F601      		movw r30,r12
 8909 332e 8083      		st Z,r24
 932:switcherator.c ****     tempLongString[1] = commandReceived[15];
 8910               		.loc 1 932 0
 8911 3330 8F85      		ldd r24,Y+15
 8912 3332 F701      		movw r30,r14
 8913 3334 8083      		st Z,r24
 933:switcherator.c ****     tempLongString[2] = commandReceived[16];
 8914               		.loc 1 933 0
 8915 3336 8889      		ldd r24,Y+16
 8916 3338 F801      		movw r30,r16
 8917 333a 8083      		st Z,r24
 934:switcherator.c ****     pwmValues[2] = atoi(tempLongString);
 8918               		.loc 1 934 0
 8919 333c C601      		movw r24,r12
 8920 333e 0E94 0000 		call atoi
 8921               	.LVL704:
 8922 3342 8093 0000 		sts pwmValues+2,r24
 935:switcherator.c ****     statusMsg[0] = 0;
 8923               		.loc 1 935 0
 8924 3346 1092 0000 		sts statusMsg,__zero_reg__
 8925               	/* epilogue start */
 937:switcherator.c **** }
 8926               		.loc 1 937 0
 8927 334a DF91      		pop r29
 8928 334c CF91      		pop r28
 8929               	.LVL705:
 8930 334e 1F91      		pop r17
 8931 3350 0F91      		pop r16
 8932 3352 FF90      		pop r15
 8933 3354 EF90      		pop r14
 8934 3356 DF90      		pop r13
 8935 3358 CF90      		pop r12
 936:switcherator.c ****     ok();
 8936               		.loc 1 936 0
 8937 335a 0C94 0000 		jmp ok
 8938               	.LVL706:
 8939               	.LFE23:
 8941               	.global	setHueSpeed
 8943               	setHueSpeed:
 8944               	.LFB22:
 906:switcherator.c **** void setHueSpeed(char * commandReceived) {
 8945               		.loc 1 906 0
 8946               	.LVL707:
 8947               	/* prologue: function */
 8948               	/* frame size = 0 */
 8949               	/* stack size = 0 */
 8950               	.L__stack_usage = 0
 907:switcherator.c ****     tempIntString[0] = commandReceived[3];
 8951               		.loc 1 907 0
 8952 335e FC01      		movw r30,r24
 8953 3360 2381      		ldd r18,Z+3
 8954 3362 2093 0000 		sts tempIntString,r18
 908:switcherator.c ****     tempIntString[1] = commandReceived[4];
 8955               		.loc 1 908 0
 8956 3366 8481      		ldd r24,Z+4
 8957               	.LVL708:
 8958 3368 8093 0000 		sts tempIntString+1,r24
 8959               	.LVL709:
 910:switcherator.c ****     programNumber = atoi(tempIntString);
 8960               		.loc 1 910 0
 8961 336c 80E0      		ldi r24,lo8(tempIntString)
 8962 336e 90E0      		ldi r25,hi8(tempIntString)
 8963 3370 0E94 0000 		call atoi
 8964               	.LVL710:
 911:switcherator.c ****     if (programNumber > 0)
 8965               		.loc 1 911 0
 8966 3374 1816      		cp __zero_reg__,r24
 8967 3376 1906      		cpc __zero_reg__,r25
 8968 3378 04F4      		brge .L622
 912:switcherator.c ****         hueSpeed = programNumber;
 8969               		.loc 1 912 0
 8970 337a 9093 0000 		sts hueSpeed+1,r25
 8971 337e 8093 0000 		sts hueSpeed,r24
 8972               	.L622:
 913:switcherator.c ****     ok();
 8973               		.loc 1 913 0
 8974 3382 0C94 0000 		jmp ok
 8975               	.LVL711:
 8976               	.LFE22:
 8978               	.global	cycleHue
 8980               	cycleHue:
 8981               	.LFB21:
 890:switcherator.c **** void cycleHue(char * commandReceived) {
 8982               		.loc 1 890 0
 8983               	.LVL712:
 8984               	/* prologue: function */
 8985               	/* frame size = 0 */
 8986               	/* stack size = 0 */
 8987               	.L__stack_usage = 0
 8988 3386 FC01      		movw r30,r24
 892:switcherator.c ****     tempLongString[0] = commandReceived[5];
 8989               		.loc 1 892 0
 8990 3388 8581      		ldd r24,Z+5
 8991               	.LVL713:
 8992 338a 8093 0000 		sts tempLongString,r24
 893:switcherator.c ****     tempLongString[1] = commandReceived[6];
 8993               		.loc 1 893 0
 8994 338e 8681      		ldd r24,Z+6
 8995 3390 8093 0000 		sts tempLongString+1,r24
 894:switcherator.c ****     tempLongString[2] = commandReceived[7];
 8996               		.loc 1 894 0
 8997 3394 8781      		ldd r24,Z+7
 8998 3396 8093 0000 		sts tempLongString+2,r24
 895:switcherator.c ****     tempLongString[3] = commandReceived[8];
 8999               		.loc 1 895 0
 9000 339a 8085      		ldd r24,Z+8
 9001 339c 8093 0000 		sts tempLongString+3,r24
 9002               	.LVL714:
 897:switcherator.c ****     programNumber = atoi(tempLongString);
 9003               		.loc 1 897 0
 9004 33a0 80E0      		ldi r24,lo8(tempLongString)
 9005 33a2 90E0      		ldi r25,hi8(tempLongString)
 9006 33a4 0E94 0000 		call atoi
 9007               	.LVL715:
 898:switcherator.c ****     if (programNumber > 0)
 9008               		.loc 1 898 0
 9009 33a8 1816      		cp __zero_reg__,r24
 9010 33aa 1906      		cpc __zero_reg__,r25
 9011 33ac 04F4      		brge .L624
 899:switcherator.c ****         colorChangeSpeed = programNumber;
 9012               		.loc 1 899 0
 9013 33ae 9093 0000 		sts colorChangeSpeed+1,r25
 9014 33b2 8093 0000 		sts colorChangeSpeed,r24
 9015               	.L624:
 900:switcherator.c ****     ok();
 9016               		.loc 1 900 0
 9017 33b6 0C94 0000 		jmp ok
 9018               	.LVL716:
 9019               	.LFE21:
 9021               	.global	switchClear
 9023               	switchClear:
 9024               	.LFB13:
 508:switcherator.c **** void switchClear(char * commandReceived) {
 9025               		.loc 1 508 0
 9026               	.LVL717:
 9027               	/* prologue: function */
 9028               	/* frame size = 0 */
 9029               	/* stack size = 0 */
 9030               	.L__stack_usage = 0
 511:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 9031               		.loc 1 511 0
 9032 33ba 0E94 0000 		call getSwitchNumber
 9033               	.LVL718:
 512:switcherator.c ****     clearTheSwitch(switchNumber);
 9034               		.loc 1 512 0
 9035 33be 0E94 0000 		call clearTheSwitch
 9036               	.LVL719:
 513:switcherator.c ****     ok();
 9037               		.loc 1 513 0
 9038 33c2 0C94 0000 		jmp ok
 9039               	.LVL720:
 9040               	.LFE13:
 9042               		.section	.rodata.str1.1
 9043               	.LC65:
 9044 0136 4375 7272 		.string	"Curr Tweak:"
 9044      2054 7765 
 9044      616B 3A00 
 9045               		.text
 9046               	.global	clockTweak
 9048               	clockTweak:
 9049               	.LFB61:
2638:switcherator.c **** void clockTweak(char * commandReceived) {
 9050               		.loc 1 2638 0
 9051               	.LVL721:
 9052               	/* prologue: function */
 9053               	/* frame size = 0 */
 9054               	/* stack size = 0 */
 9055               	.L__stack_usage = 0
 9056 33c6 FC01      		movw r30,r24
 9057               	.LVL722:
2641:switcherator.c ****         tempLongString[x] = commandReceived[(x + 3)];
 9058               		.loc 1 2641 0
 9059 33c8 8381      		ldd r24,Z+3
 9060               	.LVL723:
 9061 33ca 8093 0000 		sts tempLongString,r24
 9062               	.LVL724:
 9063 33ce 8481      		ldd r24,Z+4
 9064 33d0 8093 0000 		sts tempLongString+1,r24
 9065               	.LVL725:
 9066 33d4 8581      		ldd r24,Z+5
 9067 33d6 8093 0000 		sts tempLongString+2,r24
 9068               	.LVL726:
 9069 33da 8681      		ldd r24,Z+6
 9070 33dc 8093 0000 		sts tempLongString+3,r24
 9071               	.LVL727:
2643:switcherator.c ****     int adjustment = atoi(tempLongString);
 9072               		.loc 1 2643 0
 9073 33e0 80E0      		ldi r24,lo8(tempLongString)
 9074 33e2 90E0      		ldi r25,hi8(tempLongString)
 9075 33e4 0E94 0000 		call atoi
 9076               	.LVL728:
2644:switcherator.c ****     if (adjustment == 0) {
 9077               		.loc 1 2644 0
 9078 33e8 0097      		sbiw r24,0
 9079 33ea 01F4      		brne .L627
2645:switcherator.c ****         itoa(tweakTimer, tempLongString, 10);
 9080               		.loc 1 2645 0
 9081 33ec 4AE0      		ldi r20,lo8(10)
 9082 33ee 50E0      		ldi r21,0
 9083 33f0 60E0      		ldi r22,lo8(tempLongString)
 9084 33f2 70E0      		ldi r23,hi8(tempLongString)
 9085 33f4 8091 0000 		lds r24,tweakTimer
 9086 33f8 9091 0000 		lds r25,tweakTimer+1
 9087               	.LVL729:
 9088 33fc 0E94 0000 		call itoa
 9089               	.LVL730:
2646:switcherator.c ****         statusMsg[0] = 0;
 9090               		.loc 1 2646 0
 9091 3400 1092 0000 		sts statusMsg,__zero_reg__
2647:switcherator.c ****         strcat(statusMsg, "Curr Tweak:");
 9092               		.loc 1 2647 0
 9093 3404 60E0      		ldi r22,lo8(.LC65)
 9094 3406 70E0      		ldi r23,hi8(.LC65)
 9095 3408 80E0      		ldi r24,lo8(statusMsg)
 9096 340a 90E0      		ldi r25,hi8(statusMsg)
 9097 340c 0E94 0000 		call strcat
 9098               	.LVL731:
2648:switcherator.c ****         strcat(statusMsg, tempLongString);
 9099               		.loc 1 2648 0
 9100 3410 60E0      		ldi r22,lo8(tempLongString)
 9101 3412 70E0      		ldi r23,hi8(tempLongString)
 9102 3414 80E0      		ldi r24,lo8(statusMsg)
 9103 3416 90E0      		ldi r25,hi8(statusMsg)
 9104 3418 0E94 0000 		call strcat
 9105               	.LVL732:
2649:switcherator.c ****         sendMessage(statusMsg);
 9106               		.loc 1 2649 0
 9107 341c 80E0      		ldi r24,lo8(statusMsg)
 9108 341e 90E0      		ldi r25,hi8(statusMsg)
 9109 3420 0C94 0000 		jmp sendMessage
 9110               	.LVL733:
 9111               	.L627:
2652:switcherator.c ****     tweakTimer += adjustment;
 9112               		.loc 1 2652 0
 9113 3424 AA27      		clr r26
 9114 3426 97FD      		sbrc r25,7
 9115 3428 A095      		com r26
 9116 342a BA2F      		mov r27,r26
 9117 342c 4091 0000 		lds r20,tweakTimer
 9118 3430 5091 0000 		lds r21,tweakTimer+1
 9119 3434 6091 0000 		lds r22,tweakTimer+2
 9120 3438 7091 0000 		lds r23,tweakTimer+3
 9121 343c 480F      		add r20,r24
 9122 343e 591F      		adc r21,r25
 9123 3440 6A1F      		adc r22,r26
 9124 3442 7B1F      		adc r23,r27
 9125 3444 4093 0000 		sts tweakTimer,r20
 9126 3448 5093 0000 		sts tweakTimer+1,r21
 9127 344c 6093 0000 		sts tweakTimer+2,r22
 9128 3450 7093 0000 		sts tweakTimer+3,r23
2653:switcherator.c ****     ok();
 9129               		.loc 1 2653 0
 9130 3454 0C94 0000 		jmp ok
 9131               	.LVL734:
 9132               	.LFE61:
 9134               		.section	.rodata.str1.1
 9135               	.LC66:
 9136 0142 5365 7420 		.string	"Set @"
 9136      4000 
 9137               	.LC67:
 9138 0148 4240 00   		.string	"B@"
 9139               		.text
 9140               	.global	brightnessSet
 9142               	brightnessSet:
 9143               	.LFB28:
1127:switcherator.c **** void brightnessSet(char * commandReceived) {
 9144               		.loc 1 1127 0
 9145               	.LVL735:
 9146               	/* prologue: function */
 9147               	/* frame size = 0 */
 9148               	/* stack size = 0 */
 9149               	.L__stack_usage = 0
1128:switcherator.c ****     int brightValue = getSwitchNumber(commandReceived);
 9150               		.loc 1 1128 0
 9151 3458 0E94 0000 		call getSwitchNumber
 9152               	.LVL736:
 9153 345c 9C01      		movw r18,r24
 9154               	.LVL737:
 9155 345e 8091 0000 		lds r24,oldBright
1129:switcherator.c ****     if (brightValue == 0) {
 9156               		.loc 1 1129 0
 9157 3462 2115      		cp r18,__zero_reg__
 9158 3464 3105      		cpc r19,__zero_reg__
 9159 3466 01F4      		brne .L629
1131:switcherator.c ****         itoa(oldBright, tempIntString, 10);
 9160               		.loc 1 1131 0
 9161 3468 4AE0      		ldi r20,lo8(10)
 9162 346a 50E0      		ldi r21,0
 9163 346c 60E0      		ldi r22,lo8(tempIntString)
 9164 346e 70E0      		ldi r23,hi8(tempIntString)
 9165 3470 90E0      		ldi r25,0
 9166 3472 0E94 0000 		call itoa
 9167               	.LVL738:
1132:switcherator.c ****         statusMsg[0] = 0;
 9168               		.loc 1 1132 0
 9169 3476 1092 0000 		sts statusMsg,__zero_reg__
1133:switcherator.c ****         strcat(statusMsg, "Set @");
 9170               		.loc 1 1133 0
 9171 347a 60E0      		ldi r22,lo8(.LC66)
 9172 347c 70E0      		ldi r23,hi8(.LC66)
 9173 347e 80E0      		ldi r24,lo8(statusMsg)
 9174 3480 90E0      		ldi r25,hi8(statusMsg)
 9175 3482 0E94 0000 		call strcat
 9176               	.LVL739:
1134:switcherator.c ****         strcat(statusMsg, tempIntString);
 9177               		.loc 1 1134 0
 9178 3486 60E0      		ldi r22,lo8(tempIntString)
 9179 3488 70E0      		ldi r23,hi8(tempIntString)
 9180 348a 80E0      		ldi r24,lo8(statusMsg)
 9181 348c 90E0      		ldi r25,hi8(statusMsg)
 9182 348e 0E94 0000 		call strcat
 9183               	.LVL740:
1135:switcherator.c ****         strcat(statusMsg, "B@");
 9184               		.loc 1 1135 0
 9185 3492 60E0      		ldi r22,lo8(.LC67)
 9186 3494 70E0      		ldi r23,hi8(.LC67)
 9187 3496 80E0      		ldi r24,lo8(statusMsg)
 9188 3498 90E0      		ldi r25,hi8(statusMsg)
 9189 349a 0E94 0000 		call strcat
 9190               	.LVL741:
1136:switcherator.c ****         itoa(bright, tempIntString, 10);
 9191               		.loc 1 1136 0
 9192 349e 4AE0      		ldi r20,lo8(10)
 9193 34a0 50E0      		ldi r21,0
 9194 34a2 60E0      		ldi r22,lo8(tempIntString)
 9195 34a4 70E0      		ldi r23,hi8(tempIntString)
 9196 34a6 8091 0000 		lds r24,bright
 9197 34aa 9091 0000 		lds r25,bright+1
 9198 34ae 0E94 0000 		call itoa
 9199               	.LVL742:
1137:switcherator.c ****         strcat(statusMsg, tempIntString);
 9200               		.loc 1 1137 0
 9201 34b2 60E0      		ldi r22,lo8(tempIntString)
 9202 34b4 70E0      		ldi r23,hi8(tempIntString)
 9203 34b6 80E0      		ldi r24,lo8(statusMsg)
 9204 34b8 90E0      		ldi r25,hi8(statusMsg)
 9205 34ba 0E94 0000 		call strcat
 9206               	.LVL743:
1138:switcherator.c ****         sendMessage(statusMsg);
 9207               		.loc 1 1138 0
 9208 34be 80E0      		ldi r24,lo8(statusMsg)
 9209 34c0 90E0      		ldi r25,hi8(statusMsg)
 9210 34c2 0C94 0000 		jmp sendMessage
 9211               	.LVL744:
 9212               	.L629:
 9213 34c6 2131      		cpi r18,17
 9214 34c8 3105      		cpc r19,__zero_reg__
 9215 34ca 04F0      		brlt .L630
 9216 34cc 20E1      		ldi r18,lo8(16)
 9217 34ce 30E0      		ldi r19,0
 9218               	.LVL745:
 9219               	.L630:
1142:switcherator.c ****         if (oldBright == bright) {
 9220               		.loc 1 1142 0
 9221 34d0 90E0      		ldi r25,0
 9222 34d2 4091 0000 		lds r20,bright
 9223 34d6 5091 0000 		lds r21,bright+1
 9224 34da 8417      		cp r24,r20
 9225 34dc 9507      		cpc r25,r21
 9226 34de 01F4      		brne .L631
1144:switcherator.c ****             bright = brightValue;
 9227               		.loc 1 1144 0
 9228 34e0 3093 0000 		sts bright+1,r19
 9229 34e4 2093 0000 		sts bright,r18
 9230               	.L631:
1146:switcherator.c ****         oldBright = brightValue;
 9231               		.loc 1 1146 0
 9232 34e8 2093 0000 		sts oldBright,r18
1147:switcherator.c ****         switchChanged = 1;
 9233               		.loc 1 1147 0
 9234 34ec 81E0      		ldi r24,lo8(1)
 9235 34ee 8093 0000 		sts switchChanged,r24
1148:switcherator.c ****         ok();
 9236               		.loc 1 1148 0
 9237 34f2 0C94 0000 		jmp ok
 9238               	.LVL746:
 9239               	.LFE28:
 9241               		.section	.rodata.str1.1
 9242               	.LC68:
 9243 014b 6661 696C 		.string	"fail:"
 9243      3A00 
 9244               		.text
 9245               	.global	fail
 9247               	fail:
 9248               	.LFB9:
 366:switcherator.c **** void fail(int failCode) {
 9249               		.loc 1 366 0
 9250               	.LVL747:
 9251 34f6 CF93      		push r28
 9252               	.LCFI213:
 9253 34f8 DF93      		push r29
 9254               	.LCFI214:
 9255               	/* prologue: function */
 9256               	/* frame size = 0 */
 9257               	/* stack size = 2 */
 9258               	.L__stack_usage = 2
 9259 34fa EC01      		movw r28,r24
 367:switcherator.c ****     statusMsg[0] = 0;
 9260               		.loc 1 367 0
 9261 34fc 1092 0000 		sts statusMsg,__zero_reg__
 368:switcherator.c ****     strcat(statusMsg, "fail:");
 9262               		.loc 1 368 0
 9263 3500 60E0      		ldi r22,lo8(.LC68)
 9264 3502 70E0      		ldi r23,hi8(.LC68)
 9265 3504 80E0      		ldi r24,lo8(statusMsg)
 9266 3506 90E0      		ldi r25,hi8(statusMsg)
 9267               	.LVL748:
 9268 3508 0E94 0000 		call strcat
 9269               	.LVL749:
 369:switcherator.c ****     returnHex(failCode, tempLongString);
 9270               		.loc 1 369 0
 9271 350c 60E0      		ldi r22,lo8(tempLongString)
 9272 350e 70E0      		ldi r23,hi8(tempLongString)
 9273 3510 CE01      		movw r24,r28
 9274 3512 0E94 0000 		call returnHex
 9275               	.LVL750:
 370:switcherator.c ****     strcat(statusMsg, tempLongString);
 9276               		.loc 1 370 0
 9277 3516 60E0      		ldi r22,lo8(tempLongString)
 9278 3518 70E0      		ldi r23,hi8(tempLongString)
 9279 351a 80E0      		ldi r24,lo8(statusMsg)
 9280 351c 90E0      		ldi r25,hi8(statusMsg)
 9281 351e 0E94 0000 		call strcat
 9282               	.LVL751:
 371:switcherator.c ****     sendMessage(statusMsg);
 9283               		.loc 1 371 0
 9284 3522 80E0      		ldi r24,lo8(statusMsg)
 9285 3524 90E0      		ldi r25,hi8(statusMsg)
 9286               	/* epilogue start */
 372:switcherator.c **** }
 9287               		.loc 1 372 0
 9288 3526 DF91      		pop r29
 9289 3528 CF91      		pop r28
 9290               	.LVL752:
 371:switcherator.c ****     sendMessage(statusMsg);
 9291               		.loc 1 371 0
 9292 352a 0C94 0000 		jmp sendMessage
 9293               	.LVL753:
 9294               	.LFE9:
 9296               	.global	setDigitalInput
 9298               	setDigitalInput:
 9299               	.LFB79:
3224:switcherator.c **** void setDigitalInput(char * commandReceived) {
 9300               		.loc 1 3224 0
 9301               	.LVL754:
 9302 352e 5F92      		push r5
 9303               	.LCFI215:
 9304 3530 6F92      		push r6
 9305               	.LCFI216:
 9306 3532 7F92      		push r7
 9307               	.LCFI217:
 9308 3534 8F92      		push r8
 9309               	.LCFI218:
 9310 3536 9F92      		push r9
 9311               	.LCFI219:
 9312 3538 AF92      		push r10
 9313               	.LCFI220:
 9314 353a BF92      		push r11
 9315               	.LCFI221:
 9316 353c CF92      		push r12
 9317               	.LCFI222:
 9318 353e DF92      		push r13
 9319               	.LCFI223:
 9320 3540 EF92      		push r14
 9321               	.LCFI224:
 9322 3542 FF92      		push r15
 9323               	.LCFI225:
 9324 3544 0F93      		push r16
 9325               	.LCFI226:
 9326 3546 1F93      		push r17
 9327               	.LCFI227:
 9328 3548 CF93      		push r28
 9329               	.LCFI228:
 9330 354a DF93      		push r29
 9331               	.LCFI229:
 9332               	/* prologue: function */
 9333               	/* frame size = 0 */
 9334               	/* stack size = 15 */
 9335               	.L__stack_usage = 15
 9336 354c EC01      		movw r28,r24
 9337               	.LVL755:
3233:switcherator.c ****     tempIntString[0] = commandReceived[3];
 9338               		.loc 1 3233 0
 9339 354e 8B81      		ldd r24,Y+3
 9340               	.LVL756:
 9341 3550 8093 0000 		sts tempIntString,r24
3234:switcherator.c ****     tempIntString[1] = commandReceived[4];
 9342               		.loc 1 3234 0
 9343 3554 8C81      		ldd r24,Y+4
 9344 3556 8093 0000 		sts tempIntString+1,r24
3235:switcherator.c ****     inputNumber = atoi(tempIntString);
 9345               		.loc 1 3235 0
 9346 355a 80E0      		ldi r24,lo8(tempIntString)
 9347 355c 90E0      		ldi r25,hi8(tempIntString)
 9348 355e 0E94 0000 		call atoi
 9349               	.LVL757:
 9350 3562 7C01      		movw r14,r24
 9351               	.LVL758:
3236:switcherator.c ****     if (inputNumber >= NUM_INPUTS) {
 9352               		.loc 1 3236 0
 9353 3564 84E0      		ldi r24,4
 9354 3566 E816      		cp r14,r24
 9355 3568 F104      		cpc r15,__zero_reg__
 9356 356a 04F0      		brlt .L634
3237:switcherator.c ****         fail(0x11);
 9357               		.loc 1 3237 0
 9358 356c 81E1      		ldi r24,lo8(17)
 9359 356e 90E0      		ldi r25,0
 9360 3570 00C0      		rjmp .L671
 9361               	.L634:
3240:switcherator.c ****     tempIntString[0] = '0';
 9362               		.loc 1 3240 0
 9363 3572 80E3      		ldi r24,lo8(48)
 9364 3574 8093 0000 		sts tempIntString,r24
3241:switcherator.c ****     tempIntString[1] = commandReceived[6];
 9365               		.loc 1 3241 0
 9366 3578 8E81      		ldd r24,Y+6
 9367 357a 8093 0000 		sts tempIntString+1,r24
3242:switcherator.c ****     pin = atoi(tempIntString);
 9368               		.loc 1 3242 0
 9369 357e 80E0      		ldi r24,lo8(tempIntString)
 9370 3580 90E0      		ldi r25,hi8(tempIntString)
 9371 3582 0E94 0000 		call atoi
 9372               	.LVL759:
 9373 3586 6C01      		movw r12,r24
 9374               	.LVL760:
3243:switcherator.c ****     if (pin > 7) {
 9375               		.loc 1 3243 0
 9376 3588 E7E0      		ldi r30,lo8(7)
 9377 358a E817      		cp r30,r24
 9378 358c 00F4      		brsh .L635
3244:switcherator.c ****         fail(0x04);
 9379               		.loc 1 3244 0
 9380 358e 84E0      		ldi r24,lo8(4)
 9381 3590 90E0      		ldi r25,0
 9382               	.LVL761:
 9383               	.L671:
 9384               	/* epilogue start */
3358:switcherator.c **** }
 9385               		.loc 1 3358 0
 9386 3592 DF91      		pop r29
 9387 3594 CF91      		pop r28
 9388               	.LVL762:
 9389 3596 1F91      		pop r17
 9390 3598 0F91      		pop r16
 9391 359a FF90      		pop r15
 9392 359c EF90      		pop r14
 9393               	.LVL763:
 9394 359e DF90      		pop r13
 9395 35a0 CF90      		pop r12
 9396 35a2 BF90      		pop r11
 9397 35a4 AF90      		pop r10
 9398 35a6 9F90      		pop r9
 9399 35a8 8F90      		pop r8
 9400 35aa 7F90      		pop r7
 9401 35ac 6F90      		pop r6
 9402 35ae 5F90      		pop r5
3244:switcherator.c ****         fail(0x04);
 9403               		.loc 1 3244 0
 9404 35b0 0C94 0000 		jmp fail
 9405               	.LVL764:
 9406               	.L635:
3248:switcherator.c ****     tempIntString[0] = commandReceived[9];
 9407               		.loc 1 3248 0
 9408 35b4 8985      		ldd r24,Y+9
 9409 35b6 8093 0000 		sts tempIntString,r24
3249:switcherator.c ****     tempIntString[1] = commandReceived[10];
 9410               		.loc 1 3249 0
 9411 35ba 8A85      		ldd r24,Y+10
 9412 35bc 8093 0000 		sts tempIntString+1,r24
3250:switcherator.c ****     switchNumber = atoi(tempIntString);
 9413               		.loc 1 3250 0
 9414 35c0 80E0      		ldi r24,lo8(tempIntString)
 9415 35c2 90E0      		ldi r25,hi8(tempIntString)
 9416 35c4 0E94 0000 		call atoi
 9417               	.LVL765:
 9418 35c8 8C01      		movw r16,r24
 9419               	.LVL766:
3252:switcherator.c ****     tempIntString[0] = commandReceived[15];
 9420               		.loc 1 3252 0
 9421 35ca 8F85      		ldd r24,Y+15
 9422 35cc 8093 0000 		sts tempIntString,r24
3253:switcherator.c ****     tempIntString[1] = commandReceived[16];
 9423               		.loc 1 3253 0
 9424 35d0 8889      		ldd r24,Y+16
 9425 35d2 8093 0000 		sts tempIntString+1,r24
3254:switcherator.c ****     pollTime = atoi(tempIntString);
 9426               		.loc 1 3254 0
 9427 35d6 80E0      		ldi r24,lo8(tempIntString)
 9428 35d8 90E0      		ldi r25,hi8(tempIntString)
 9429 35da 0E94 0000 		call atoi
 9430               	.LVL767:
 9431 35de 4C01      		movw r8,r24
 9432               	.LVL768:
3256:switcherator.c ****     tempLongString[0] = commandReceived[11];
 9433               		.loc 1 3256 0
 9434 35e0 8B85      		ldd r24,Y+11
 9435 35e2 8093 0000 		sts tempLongString,r24
3257:switcherator.c ****     tempLongString[1] = commandReceived[12];
 9436               		.loc 1 3257 0
 9437 35e6 8C85      		ldd r24,Y+12
 9438 35e8 8093 0000 		sts tempLongString+1,r24
3258:switcherator.c ****     tempLongString[2] = commandReceived[13];
 9439               		.loc 1 3258 0
 9440 35ec 8D85      		ldd r24,Y+13
 9441 35ee 8093 0000 		sts tempLongString+2,r24
3259:switcherator.c ****     tempLongString[3] = commandReceived[14];
 9442               		.loc 1 3259 0
 9443 35f2 8E85      		ldd r24,Y+14
 9444 35f4 8093 0000 		sts tempLongString+3,r24
3260:switcherator.c ****     duration = atoi(tempLongString);
 9445               		.loc 1 3260 0
 9446 35f8 80E0      		ldi r24,lo8(tempLongString)
 9447 35fa 90E0      		ldi r25,hi8(tempLongString)
 9448 35fc 0E94 0000 		call atoi
 9449               	.LVL769:
 9450 3600 582E      		mov r5,r24
 9451               	.LVL770:
3262:switcherator.c ****     if (commandReceived[8] == 'P' || commandReceived[8] == 'p') {
 9452               		.loc 1 3262 0
 9453 3602 2885      		ldd r18,Y+8
 9454 3604 2035      		cpi r18,lo8(80)
 9455 3606 01F0      		breq .L636
3262:switcherator.c ****     if (commandReceived[8] == 'P' || commandReceived[8] == 'p') {
 9456               		.loc 1 3262 0 is_stmt 0 discriminator 1
 9457 3608 2037      		cpi r18,lo8(112)
 9458 360a 01F4      		brne .L637
 9459               	.L636:
3263:switcherator.c ****         switchNumber += 128;
 9460               		.loc 1 3263 0 is_stmt 1
 9461 360c 0058      		subi r16,-128
 9462 360e 1F4F      		sbci r17,-1
 9463               	.LVL771:
 9464               	.L637:
3265:switcherator.c ****     temp = pin * 2;
 9465               		.loc 1 3265 0
 9466 3610 B601      		movw r22,r12
 9467 3612 7727      		clr r23
 9468 3614 9B01      		movw r18,r22
 9469 3616 220F      		lsl r18
 9470 3618 331F      		rol r19
 9471               	.LVL772:
3266:switcherator.c ****     if (commandReceived[5] == 'B' || commandReceived[5] == 'b') {
 9472               		.loc 1 3266 0
 9473 361a 4D81      		ldd r20,Y+5
 9474 361c 4234      		cpi r20,lo8(66)
 9475 361e 01F0      		breq .L638
3266:switcherator.c ****     if (commandReceived[5] == 'B' || commandReceived[5] == 'b') {
 9476               		.loc 1 3266 0 is_stmt 0 discriminator 1
 9477 3620 4236      		cpi r20,lo8(98)
 9478 3622 01F4      		brne .L639
 9479               	.L638:
 9480               	.LVL773:
3269:switcherator.c ****         temp += 16;
 9481               		.loc 1 3269 0 is_stmt 1
 9482 3624 205F      		subi r18,-16
 9483 3626 3F4F      		sbci r19,-1
 9484               	.LVL774:
3268:switcherator.c ****         realPort = &PORTB;
 9485               		.loc 1 3268 0
 9486 3628 B5E2      		ldi r27,lo8(37)
 9487 362a 6B2E      		mov r6,r27
 9488 362c 712C      		mov r7,__zero_reg__
3267:switcherator.c ****         realDDR = &DDRB;
 9489               		.loc 1 3267 0
 9490 362e A4E2      		ldi r26,lo8(36)
 9491 3630 B0E0      		ldi r27,0
3269:switcherator.c ****         temp += 16;
 9492               		.loc 1 3269 0
 9493 3632 00C0      		rjmp .L640
 9494               	.LVL775:
 9495               	.L639:
3277:switcherator.c ****     } else if (commandReceived[5] == 'C' || commandReceived[5] == 'c') {
 9496               		.loc 1 3277 0
 9497 3634 4334      		cpi r20,lo8(67)
 9498 3636 01F0      		breq .L641
3277:switcherator.c ****     } else if (commandReceived[5] == 'C' || commandReceived[5] == 'c') {
 9499               		.loc 1 3277 0 is_stmt 0 discriminator 1
 9500 3638 4336      		cpi r20,lo8(99)
 9501 363a 01F4      		brne .L642
 9502               	.L641:
 9503               	.LVL776:
3280:switcherator.c ****         temp += 32;
 9504               		.loc 1 3280 0 is_stmt 1
 9505 363c 205E      		subi r18,-32
 9506 363e 3F4F      		sbci r19,-1
 9507               	.LVL777:
3279:switcherator.c ****         realPort = &PORTC;
 9508               		.loc 1 3279 0
 9509 3640 A8E2      		ldi r26,lo8(40)
 9510 3642 6A2E      		mov r6,r26
 9511 3644 712C      		mov r7,__zero_reg__
3278:switcherator.c ****         realDDR = &DDRC;
 9512               		.loc 1 3278 0
 9513 3646 A7E2      		ldi r26,lo8(39)
 9514 3648 B0E0      		ldi r27,0
3280:switcherator.c ****         temp += 32;
 9515               		.loc 1 3280 0
 9516 364a 00C0      		rjmp .L640
 9517               	.LVL778:
 9518               	.L642:
3283:switcherator.c ****     } else if (commandReceived[5] == 'D' || commandReceived[5] == 'd') {
 9519               		.loc 1 3283 0
 9520 364c 4434      		cpi r20,lo8(68)
 9521 364e 01F0      		breq .L643
3283:switcherator.c ****     } else if (commandReceived[5] == 'D' || commandReceived[5] == 'd') {
 9522               		.loc 1 3283 0 is_stmt 0 discriminator 1
 9523 3650 4436      		cpi r20,lo8(100)
 9524 3652 01F4      		brne .L651
 9525               	.L643:
 9526               	.LVL779:
3286:switcherator.c ****         temp += 48;
 9527               		.loc 1 3286 0 is_stmt 1
 9528 3654 205D      		subi r18,-48
 9529 3656 3F4F      		sbci r19,-1
 9530               	.LVL780:
3285:switcherator.c ****         realPort = &PORTD;
 9531               		.loc 1 3285 0
 9532 3658 FBE2      		ldi r31,lo8(43)
 9533 365a 6F2E      		mov r6,r31
 9534 365c 712C      		mov r7,__zero_reg__
3284:switcherator.c ****         realDDR = &DDRD;
 9535               		.loc 1 3284 0
 9536 365e AAE2      		ldi r26,lo8(42)
 9537 3660 B0E0      		ldi r27,0
 9538 3662 00C0      		rjmp .L640
 9539               	.LVL781:
 9540               	.L651:
3228:switcherator.c ****     volatile unsigned char *realPort = 0;
 9541               		.loc 1 3228 0
 9542 3664 612C      		mov r6,__zero_reg__
 9543 3666 712C      		mov r7,__zero_reg__
3227:switcherator.c ****     volatile unsigned char *realDDR = 0;
 9544               		.loc 1 3227 0
 9545 3668 A0E0      		ldi r26,0
 9546 366a B0E0      		ldi r27,0
 9547               	.LVL782:
 9548               	.L640:
 9549 366c 40E0      		ldi r20,lo8(switchStuff)
 9550 366e 50E0      		ldi r21,hi8(switchStuff)
3326:switcherator.c ****         if (switchStuff[x] == temp || switchStuff[x] == (temp + 1)) {
 9551               		.loc 1 3326 0
 9552 3670 5901      		movw r10,r18
 9553 3672 FFEF      		ldi r31,-1
 9554 3674 AF1A      		sub r10,r31
 9555 3676 BF0A      		sbc r11,r31
 9556               	.LVL783:
 9557               	.L646:
 9558 3678 FA01      		movw r30,r20
 9559 367a C190      		ld r12,Z+
 9560 367c AF01      		movw r20,r30
 9561 367e D12C      		mov r13,__zero_reg__
 9562 3680 C216      		cp r12,r18
 9563 3682 D306      		cpc r13,r19
 9564 3684 01F0      		breq .L644
3326:switcherator.c ****         if (switchStuff[x] == temp || switchStuff[x] == (temp + 1)) {
 9565               		.loc 1 3326 0 is_stmt 0 discriminator 1
 9566 3686 CA14      		cp r12,r10
 9567 3688 DB04      		cpc r13,r11
 9568 368a 01F4      		brne .L645
 9569               	.L644:
3327:switcherator.c ****             fail(0x12);
 9570               		.loc 1 3327 0 is_stmt 1
 9571 368c 82E1      		ldi r24,lo8(18)
 9572 368e 90E0      		ldi r25,0
 9573 3690 00C0      		rjmp .L671
 9574               	.L645:
3325:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 9575               		.loc 1 3325 0
 9576 3692 F0E0      		ldi r31,hi8(switchStuff+16)
 9577 3694 4030      		cpi r20,lo8(switchStuff+16)
 9578 3696 5F07      		cpc r21,r31
 9579 3698 01F4      		brne .L646
3332:switcherator.c ****     inputs[inputNumber][0] = temp;
 9580               		.loc 1 3332 0
 9581 369a A701      		movw r20,r14
 9582 369c 73E0      		ldi r23,3
 9583               		1:
 9584 369e 440F      		lsl r20
 9585 36a0 551F      		rol r21
 9586 36a2 7A95      		dec r23
 9587 36a4 01F4      		brne 1b
 9588 36a6 E0E0      		ldi r30,lo8(inputs)
 9589 36a8 EE2E      		mov r14,r30
 9590 36aa E0E0      		ldi r30,hi8(inputs)
 9591 36ac FE2E      		mov r15,r30
 9592               	.LVL784:
 9593 36ae E40E      		add r14,r20
 9594 36b0 F51E      		adc r15,r21
 9595 36b2 F701      		movw r30,r14
 9596 36b4 2083      		st Z,r18
3334:switcherator.c ****     if (commandReceived[7] == 'H' || commandReceived[7] == 'h' ||
 9597               		.loc 1 3334 0
 9598 36b6 2F81      		ldd r18,Y+7
 9599               	.LVL785:
 9600 36b8 2834      		cpi r18,lo8(72)
 9601 36ba 01F0      		breq .L647
3334:switcherator.c ****     if (commandReceived[7] == 'H' || commandReceived[7] == 'h' ||
 9602               		.loc 1 3334 0 is_stmt 0 discriminator 1
 9603 36bc 2836      		cpi r18,lo8(104)
 9604 36be 01F0      		breq .L647
 9605 36c0 2133      		cpi r18,lo8(49)
 9606 36c2 01F4      		brne .L648
 9607               	.L647:
3336:switcherator.c ****         inputs[inputNumber][1] = 0;
 9608               		.loc 1 3336 0 is_stmt 1
 9609 36c4 EA01      		movw r28,r20
 9610               	.LVL786:
 9611 36c6 C050      		subi r28,lo8(-(inputs))
 9612 36c8 D040      		sbci r29,hi8(-(inputs))
 9613 36ca 1982      		std Y+1,__zero_reg__
3337:switcherator.c ****         inputs[inputNumber][2] = 255;
 9614               		.loc 1 3337 0
 9615 36cc 2FEF      		ldi r18,lo8(-1)
 9616 36ce 2A83      		std Y+2,r18
 9617 36d0 00C0      		rjmp .L649
 9618               	.LVL787:
 9619               	.L648:
3339:switcherator.c ****         inputs[inputNumber][1] = 255;
 9620               		.loc 1 3339 0
 9621 36d2 2FEF      		ldi r18,lo8(-1)
 9622 36d4 F701      		movw r30,r14
 9623 36d6 2183      		std Z+1,r18
3340:switcherator.c ****         inputs[inputNumber][2] = 0;
 9624               		.loc 1 3340 0
 9625 36d8 1282      		std Z+2,__zero_reg__
 9626               	.LVL788:
 9627               	.L649:
3342:switcherator.c ****     inputs[inputNumber][3] = switchNumber;
 9628               		.loc 1 3342 0
 9629 36da EA01      		movw r28,r20
 9630 36dc C050      		subi r28,lo8(-(inputs))
 9631 36de D040      		sbci r29,hi8(-(inputs))
 9632 36e0 0B83      		std Y+3,r16
 9633               	.LVL789:
3344:switcherator.c ****     inputs[inputNumber][4] = temp;
 9634               		.loc 1 3344 0
 9635 36e2 9C83      		std Y+4,r25
 9636               	.LVL790:
3346:switcherator.c ****     inputs[inputNumber][5] = temp;
 9637               		.loc 1 3346 0
 9638 36e4 5D82      		std Y+5,r5
 9639               	.LVL791:
3350:switcherator.c ****     inputs[inputNumber][6] = pollTime;
 9640               		.loc 1 3350 0
 9641 36e6 9401      		movw r18,r8
 9642 36e8 2F3F      		cpi r18,-1
 9643 36ea 3105      		cpc r19,__zero_reg__
 9644 36ec 01F0      		breq .L650
 9645 36ee 04F0      		brlt .L650
 9646 36f0 2FEF      		ldi r18,lo8(-1)
 9647 36f2 30E0      		ldi r19,0
 9648               	.L650:
 9649 36f4 2E83      		std Y+6,r18
3352:switcherator.c ****     *realDDR &= ~(1 << pin);
 9650               		.loc 1 3352 0
 9651 36f6 8C91      		ld r24,X
 9652 36f8 21E0      		ldi r18,lo8(1)
 9653 36fa 30E0      		ldi r19,0
 9654 36fc 00C0      		rjmp 2f
 9655               		1:
 9656 36fe 220F      		lsl r18
 9657               		2:
 9658 3700 6A95      		dec r22
 9659 3702 02F4      		brpl 1b
 9660 3704 922F      		mov r25,r18
 9661               	.LVL792:
 9662 3706 9095      		com r25
 9663 3708 8923      		and r24,r25
 9664 370a 8C93      		st X,r24
3353:switcherator.c ****     *realPort |= (1 << pin);
 9665               		.loc 1 3353 0
 9666 370c F301      		movw r30,r6
 9667 370e 8081      		ld r24,Z
 9668 3710 822B      		or r24,r18
 9669 3712 8083      		st Z,r24
 9670               	/* epilogue start */
3358:switcherator.c **** }
 9671               		.loc 1 3358 0
 9672 3714 DF91      		pop r29
 9673 3716 CF91      		pop r28
 9674               	.LVL793:
 9675 3718 1F91      		pop r17
 9676 371a 0F91      		pop r16
 9677 371c FF90      		pop r15
 9678 371e EF90      		pop r14
 9679 3720 DF90      		pop r13
 9680 3722 CF90      		pop r12
 9681 3724 BF90      		pop r11
 9682 3726 AF90      		pop r10
 9683 3728 9F90      		pop r9
 9684               	.LVL794:
 9685 372a 8F90      		pop r8
 9686 372c 7F90      		pop r7
 9687 372e 6F90      		pop r6
 9688               	.LVL795:
 9689 3730 5F90      		pop r5
 9690               	.LVL796:
3355:switcherator.c ****     ok();
 9691               		.loc 1 3355 0
 9692 3732 0C94 0000 		jmp ok
 9693               	.LVL797:
 9694               	.LFE79:
 9696               	.global	setAnalogInput
 9698               	setAnalogInput:
 9699               	.LFB78:
3099:switcherator.c **** void setAnalogInput(char * commandReceived) {
 9700               		.loc 1 3099 0
 9701               	.LVL798:
 9702 3736 2F92      		push r2
 9703               	.LCFI230:
 9704 3738 3F92      		push r3
 9705               	.LCFI231:
 9706 373a 4F92      		push r4
 9707               	.LCFI232:
 9708 373c 5F92      		push r5
 9709               	.LCFI233:
 9710 373e 6F92      		push r6
 9711               	.LCFI234:
 9712 3740 7F92      		push r7
 9713               	.LCFI235:
 9714 3742 8F92      		push r8
 9715               	.LCFI236:
 9716 3744 9F92      		push r9
 9717               	.LCFI237:
 9718 3746 AF92      		push r10
 9719               	.LCFI238:
 9720 3748 BF92      		push r11
 9721               	.LCFI239:
 9722 374a CF92      		push r12
 9723               	.LCFI240:
 9724 374c DF92      		push r13
 9725               	.LCFI241:
 9726 374e EF92      		push r14
 9727               	.LCFI242:
 9728 3750 FF92      		push r15
 9729               	.LCFI243:
 9730 3752 0F93      		push r16
 9731               	.LCFI244:
 9732 3754 1F93      		push r17
 9733               	.LCFI245:
 9734 3756 CF93      		push r28
 9735               	.LCFI246:
 9736 3758 DF93      		push r29
 9737               	.LCFI247:
 9738 375a 00D0      		rcall .
 9739 375c 1F92      		push __zero_reg__
 9740               	.LCFI248:
 9741 375e CDB7      		in r28,__SP_L__
 9742 3760 DEB7      		in r29,__SP_H__
 9743               	.LCFI249:
 9744               	/* prologue: function */
 9745               	/* frame size = 3 */
 9746               	/* stack size = 21 */
 9747               	.L__stack_usage = 21
 9748 3762 9B83      		std Y+3,r25
 9749 3764 8A83      		std Y+2,r24
 9750               	.LVL799:
3107:switcherator.c ****     tempIntString[0] = commandReceived[3];
 9751               		.loc 1 3107 0
 9752 3766 DC01      		movw r26,r24
 9753 3768 1396      		adiw r26,3
 9754 376a 8C91      		ld r24,X
 9755 376c 1397      		sbiw r26,3
 9756               	.LVL800:
 9757 376e 8093 0000 		sts tempIntString,r24
3108:switcherator.c ****     tempIntString[1] = commandReceived[4];
 9758               		.loc 1 3108 0
 9759 3772 1496      		adiw r26,4
 9760 3774 8C91      		ld r24,X
 9761 3776 8093 0000 		sts tempIntString+1,r24
3109:switcherator.c ****     inputNumber = atoi(tempIntString);
 9762               		.loc 1 3109 0
 9763 377a 80E0      		ldi r24,lo8(tempIntString)
 9764 377c 90E0      		ldi r25,hi8(tempIntString)
 9765 377e 0E94 0000 		call atoi
 9766               	.LVL801:
 9767 3782 8C01      		movw r16,r24
 9768               	.LVL802:
3110:switcherator.c ****     if (inputNumber >= NUM_INPUTS) {
 9769               		.loc 1 3110 0
 9770 3784 8430      		cpi r24,4
 9771 3786 9105      		cpc r25,__zero_reg__
 9772 3788 04F0      		brlt .L673
3111:switcherator.c ****         fail(0x11);
 9773               		.loc 1 3111 0
 9774 378a 81E1      		ldi r24,lo8(17)
 9775 378c 90E0      		ldi r25,0
 9776 378e 00C0      		rjmp .L694
 9777               	.L673:
3114:switcherator.c ****     tempIntString[0] = '0';
 9778               		.loc 1 3114 0
 9779 3790 50E3      		ldi r21,lo8(48)
 9780 3792 B52E      		mov r11,r21
 9781 3794 B092 0000 		sts tempIntString,r11
3115:switcherator.c ****     tempIntString[1] = commandReceived[6];
 9782               		.loc 1 3115 0
 9783 3798 EA81      		ldd r30,Y+2
 9784 379a FB81      		ldd r31,Y+3
 9785 379c 8681      		ldd r24,Z+6
 9786 379e 8093 0000 		sts tempIntString+1,r24
3116:switcherator.c ****     pin = atoi(tempIntString);
 9787               		.loc 1 3116 0
 9788 37a2 80E0      		ldi r24,lo8(tempIntString)
 9789 37a4 90E0      		ldi r25,hi8(tempIntString)
 9790 37a6 0E94 0000 		call atoi
 9791               	.LVL803:
 9792 37aa 6C01      		movw r12,r24
 9793               	.LVL804:
3117:switcherator.c ****     if (pin > 7) {
 9794               		.loc 1 3117 0
 9795 37ac F7E0      		ldi r31,lo8(7)
 9796 37ae F817      		cp r31,r24
 9797 37b0 00F4      		brsh .L674
3118:switcherator.c ****         fail(0x04);
 9798               		.loc 1 3118 0
 9799 37b2 84E0      		ldi r24,lo8(4)
 9800 37b4 90E0      		ldi r25,0
 9801               	.LVL805:
 9802               	.L694:
 9803               	/* epilogue start */
3216:switcherator.c **** }
 9804               		.loc 1 3216 0
 9805 37b6 0F90      		pop __tmp_reg__
 9806 37b8 0F90      		pop __tmp_reg__
 9807 37ba 0F90      		pop __tmp_reg__
 9808 37bc DF91      		pop r29
 9809 37be CF91      		pop r28
 9810 37c0 1F91      		pop r17
 9811 37c2 0F91      		pop r16
 9812               	.LVL806:
 9813 37c4 FF90      		pop r15
 9814 37c6 EF90      		pop r14
 9815 37c8 DF90      		pop r13
 9816 37ca CF90      		pop r12
 9817 37cc BF90      		pop r11
 9818 37ce AF90      		pop r10
 9819 37d0 9F90      		pop r9
 9820 37d2 8F90      		pop r8
 9821 37d4 7F90      		pop r7
 9822 37d6 6F90      		pop r6
 9823 37d8 5F90      		pop r5
 9824 37da 4F90      		pop r4
 9825 37dc 3F90      		pop r3
 9826 37de 2F90      		pop r2
3118:switcherator.c ****         fail(0x04);
 9827               		.loc 1 3118 0
 9828 37e0 0C94 0000 		jmp fail
 9829               	.LVL807:
 9830               	.L674:
3122:switcherator.c ****     tempIntString[0] = commandReceived[14];
 9831               		.loc 1 3122 0
 9832 37e4 AA81      		ldd r26,Y+2
 9833 37e6 BB81      		ldd r27,Y+3
 9834 37e8 1E96      		adiw r26,14
 9835 37ea 8C91      		ld r24,X
 9836 37ec 1E97      		sbiw r26,14
 9837 37ee 8093 0000 		sts tempIntString,r24
3123:switcherator.c ****     tempIntString[1] = commandReceived[15];
 9838               		.loc 1 3123 0
 9839 37f2 1F96      		adiw r26,15
 9840 37f4 8C91      		ld r24,X
 9841 37f6 8093 0000 		sts tempIntString+1,r24
3124:switcherator.c ****     switchNumber = atoi(tempIntString);
 9842               		.loc 1 3124 0
 9843 37fa 80E0      		ldi r24,lo8(tempIntString)
 9844 37fc 90E0      		ldi r25,hi8(tempIntString)
 9845 37fe 0E94 0000 		call atoi
 9846               	.LVL808:
 9847 3802 7C01      		movw r14,r24
 9848               	.LVL809:
3126:switcherator.c ****     tempIntString[0] = commandReceived[20];
 9849               		.loc 1 3126 0
 9850 3804 EA81      		ldd r30,Y+2
 9851 3806 FB81      		ldd r31,Y+3
 9852 3808 8489      		ldd r24,Z+20
 9853 380a 8093 0000 		sts tempIntString,r24
3127:switcherator.c ****     tempIntString[1] = commandReceived[21];
 9854               		.loc 1 3127 0
 9855 380e 8589      		ldd r24,Z+21
 9856 3810 8093 0000 		sts tempIntString+1,r24
3128:switcherator.c ****     pollTime = atoi(tempIntString);
 9857               		.loc 1 3128 0
 9858 3814 80E0      		ldi r24,lo8(tempIntString)
 9859 3816 90E0      		ldi r25,hi8(tempIntString)
 9860 3818 0E94 0000 		call atoi
 9861               	.LVL810:
 9862 381c 782E      		mov r7,r24
 9863 381e 892E      		mov r8,r25
 9864               	.LVL811:
3130:switcherator.c ****     tempIntString[0] = '0';
 9865               		.loc 1 3130 0
 9866 3820 B092 0000 		sts tempIntString,r11
3131:switcherator.c ****     tempIntString[1] = commandReceived[22];
 9867               		.loc 1 3131 0
 9868 3824 AA81      		ldd r26,Y+2
 9869 3826 BB81      		ldd r27,Y+3
 9870 3828 5696      		adiw r26,22
 9871 382a 8C91      		ld r24,X
 9872 382c 8093 0000 		sts tempIntString+1,r24
3132:switcherator.c ****     whichRGB = atoi(tempIntString);
 9873               		.loc 1 3132 0
 9874 3830 80E0      		ldi r24,lo8(tempIntString)
 9875 3832 90E0      		ldi r25,hi8(tempIntString)
 9876 3834 0E94 0000 		call atoi
 9877               	.LVL812:
 9878 3838 982E      		mov r9,r24
 9879               	.LVL813:
3134:switcherator.c ****     tempLongString[0] = '0';
 9880               		.loc 1 3134 0
 9881 383a B092 0000 		sts tempLongString,r11
3135:switcherator.c ****     tempLongString[1] = commandReceived[7];
 9882               		.loc 1 3135 0
 9883 383e EA81      		ldd r30,Y+2
 9884 3840 FB81      		ldd r31,Y+3
 9885 3842 8781      		ldd r24,Z+7
 9886 3844 8093 0000 		sts tempLongString+1,r24
3136:switcherator.c ****     tempLongString[2] = commandReceived[8];
 9887               		.loc 1 3136 0
 9888 3848 8085      		ldd r24,Z+8
 9889 384a 8093 0000 		sts tempLongString+2,r24
3137:switcherator.c ****     tempLongString[3] = commandReceived[9];
 9890               		.loc 1 3137 0
 9891 384e 8185      		ldd r24,Z+9
 9892 3850 8093 0000 		sts tempLongString+3,r24
3138:switcherator.c ****     lowPercent = atoi(tempLongString);
 9893               		.loc 1 3138 0
 9894 3854 80E0      		ldi r24,lo8(tempLongString)
 9895 3856 90E0      		ldi r25,hi8(tempLongString)
 9896 3858 0E94 0000 		call atoi
 9897               	.LVL814:
 9898 385c 5C01      		movw r10,r24
 9899               	.LVL815:
3139:switcherator.c ****     tempLongString[1] = commandReceived[10];
 9900               		.loc 1 3139 0
 9901 385e AA81      		ldd r26,Y+2
 9902 3860 BB81      		ldd r27,Y+3
 9903 3862 1A96      		adiw r26,10
 9904 3864 8C91      		ld r24,X
 9905 3866 1A97      		sbiw r26,10
 9906 3868 8093 0000 		sts tempLongString+1,r24
3140:switcherator.c ****     tempLongString[2] = commandReceived[11];
 9907               		.loc 1 3140 0
 9908 386c 1B96      		adiw r26,11
 9909 386e 8C91      		ld r24,X
 9910 3870 1B97      		sbiw r26,11
 9911 3872 8093 0000 		sts tempLongString+2,r24
3141:switcherator.c ****     tempLongString[3] = commandReceived[12];
 9912               		.loc 1 3141 0
 9913 3876 1C96      		adiw r26,12
 9914 3878 8C91      		ld r24,X
 9915 387a 8093 0000 		sts tempLongString+3,r24
3142:switcherator.c ****     highPercent = atoi(tempLongString);
 9916               		.loc 1 3142 0
 9917 387e 80E0      		ldi r24,lo8(tempLongString)
 9918 3880 90E0      		ldi r25,hi8(tempLongString)
 9919 3882 0E94 0000 		call atoi
 9920               	.LVL816:
 9921 3886 2C01      		movw r4,r24
 9922               	.LVL817:
3144:switcherator.c ****     tempLongString[0] = commandReceived[16];
 9923               		.loc 1 3144 0
 9924 3888 EA81      		ldd r30,Y+2
 9925 388a FB81      		ldd r31,Y+3
 9926 388c 8089      		ldd r24,Z+16
 9927 388e 8093 0000 		sts tempLongString,r24
3145:switcherator.c ****     tempLongString[1] = commandReceived[17];
 9928               		.loc 1 3145 0
 9929 3892 8189      		ldd r24,Z+17
 9930 3894 8093 0000 		sts tempLongString+1,r24
3146:switcherator.c ****     tempLongString[2] = commandReceived[18];
 9931               		.loc 1 3146 0
 9932 3898 8289      		ldd r24,Z+18
 9933 389a 8093 0000 		sts tempLongString+2,r24
3147:switcherator.c ****     tempLongString[3] = commandReceived[19];
 9934               		.loc 1 3147 0
 9935 389e 8389      		ldd r24,Z+19
 9936 38a0 8093 0000 		sts tempLongString+3,r24
3148:switcherator.c ****     duration = atoi(tempLongString);
 9937               		.loc 1 3148 0
 9938 38a4 80E0      		ldi r24,lo8(tempLongString)
 9939 38a6 90E0      		ldi r25,hi8(tempLongString)
 9940 38a8 0E94 0000 		call atoi
 9941               	.LVL818:
 9942 38ac 682E      		mov r6,r24
 9943 38ae 9983      		std Y+1,r25
 9944               	.LVL819:
3155:switcherator.c ****     if (commandReceived[5] != 'C' && commandReceived[5] != 'c') {
 9945               		.loc 1 3155 0
 9946 38b0 AA81      		ldd r26,Y+2
 9947 38b2 BB81      		ldd r27,Y+3
 9948 38b4 1596      		adiw r26,5
 9949 38b6 8C91      		ld r24,X
 9950 38b8 8334      		cpi r24,lo8(67)
 9951 38ba 01F0      		breq .L675
3155:switcherator.c ****     if (commandReceived[5] != 'C' && commandReceived[5] != 'c') {
 9952               		.loc 1 3155 0 is_stmt 0 discriminator 1
 9953 38bc 8336      		cpi r24,lo8(99)
 9954 38be 01F0      		breq .L675
3156:switcherator.c ****         fail(0x03);
 9955               		.loc 1 3156 0 is_stmt 1
 9956 38c0 83E0      		ldi r24,lo8(3)
 9957 38c2 90E0      		ldi r25,0
 9958 38c4 00C0      		rjmp .L694
 9959               	.L675:
3166:switcherator.c ****     temp = pin * 2;
 9960               		.loc 1 3166 0
 9961 38c6 DD24      		clr r13
 9962               	.LVL820:
 9963 38c8 C601      		movw r24,r12
 9964 38ca 880F      		lsl r24
 9965 38cc 991F      		rol r25
 9966 38ce AA27      		clr r26
 9967 38d0 97FD      		sbrc r25,7
 9968 38d2 A095      		com r26
 9969 38d4 BA2F      		mov r27,r26
 9970               	.LVL821:
3168:switcherator.c ****     temp += 32;
 9971               		.loc 1 3168 0
 9972 38d6 8096      		adiw r24,32
 9973 38d8 A11D      		adc r26,__zero_reg__
 9974 38da B11D      		adc r27,__zero_reg__
 9975               	.LVL822:
 9976 38dc E0E0      		ldi r30,lo8(switchStuff)
 9977 38de F0E0      		ldi r31,hi8(switchStuff)
 9978               	.LVL823:
 9979               	.L677:
3170:switcherator.c ****         if (switchStuff[x] == temp) {
 9980               		.loc 1 3170 0
 9981 38e0 4191      		ld r20,Z+
 9982 38e2 50E0      		ldi r21,0
 9983 38e4 60E0      		ldi r22,0
 9984 38e6 70E0      		ldi r23,0
 9985 38e8 4817      		cp r20,r24
 9986 38ea 5907      		cpc r21,r25
 9987 38ec 6A07      		cpc r22,r26
 9988 38ee 7B07      		cpc r23,r27
 9989 38f0 01F4      		brne .L676
3172:switcherator.c ****             fail(0x12);
 9990               		.loc 1 3172 0
 9991 38f2 82E1      		ldi r24,lo8(18)
 9992 38f4 90E0      		ldi r25,0
 9993               	.LVL824:
 9994 38f6 00C0      		rjmp .L694
 9995               	.LVL825:
 9996               	.L676:
3169:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 9997               		.loc 1 3169 0
 9998 38f8 20E0      		ldi r18,hi8(switchStuff+16)
 9999 38fa E030      		cpi r30,lo8(switchStuff+16)
 10000 38fc F207      		cpc r31,r18
 10001 38fe 01F4      		brne .L677
3176:switcherator.c ****     inputs[inputNumber][0] = temp;
 10002               		.loc 1 3176 0
 10003 3900 93E0      		ldi r25,3
 10004               		1:
 10005 3902 000F      		lsl r16
 10006 3904 111F      		rol r17
 10007 3906 9A95      		dec r25
 10008 3908 01F4      		brne 1b
 10009               	.LVL826:
 10010 390a 20E0      		ldi r18,lo8(inputs)
 10011 390c 222E      		mov r2,r18
 10012 390e 20E0      		ldi r18,hi8(inputs)
 10013 3910 322E      		mov r3,r18
 10014 3912 200E      		add r2,r16
 10015 3914 311E      		adc r3,r17
 10016 3916 F101      		movw r30,r2
 10017 3918 8083      		st Z,r24
3177:switcherator.c ****     DDRC &= ~(1 << pin);
 10018               		.loc 1 3177 0
 10019 391a 27B1      		in r18,0x7
 10020 391c 81E0      		ldi r24,lo8(1)
 10021 391e 90E0      		ldi r25,0
 10022               	.LVL827:
 10023 3920 00C0      		rjmp 2f
 10024               		1:
 10025 3922 880F      		lsl r24
 10026               		2:
 10027 3924 CA94      		dec r12
 10028 3926 02F4      		brpl 1b
 10029 3928 8095      		com r24
 10030 392a 8223      		and r24,r18
 10031 392c 87B9      		out 0x7,r24
 10032               	.LVL828:
3179:switcherator.c ****     temp = temp * 255;
 10033               		.loc 1 3179 0
 10034 392e 2FEF      		ldi r18,lo8(-1)
 10035 3930 30E0      		ldi r19,0
 10036 3932 D501      		movw r26,r10
 10037 3934 0E94 0000 		call __usmulhisi3
 10038               	.LVL829:
3180:switcherator.c ****     temp = temp / 100;
 10039               		.loc 1 3180 0
 10040 3938 34E6      		ldi r19,lo8(100)
 10041 393a A32E      		mov r10,r19
 10042 393c B12C      		mov r11,__zero_reg__
 10043 393e C12C      		mov r12,__zero_reg__
 10044 3940 D12C      		mov r13,__zero_reg__
 10045               	.LVL830:
 10046 3942 A601      		movw r20,r12
 10047 3944 9501      		movw r18,r10
 10048 3946 0E94 0000 		call __divmodsi4
 10049               	.LVL831:
3181:switcherator.c ****     inputs[inputNumber][1] = temp;
 10050               		.loc 1 3181 0
 10051 394a D101      		movw r26,r2
 10052 394c 1196      		adiw r26,1
 10053 394e 2C93      		st X,r18
 10054               	.LVL832:
3183:switcherator.c ****     temp = temp * 255;
 10055               		.loc 1 3183 0
 10056 3950 2FEF      		ldi r18,lo8(-1)
 10057 3952 30E0      		ldi r19,0
 10058 3954 D201      		movw r26,r4
 10059 3956 0E94 0000 		call __usmulhisi3
 10060               	.LVL833:
3184:switcherator.c ****     temp = temp / 100;
 10061               		.loc 1 3184 0
 10062 395a A601      		movw r20,r12
 10063 395c 9501      		movw r18,r10
 10064 395e 0E94 0000 		call __divmodsi4
 10065               	.LVL834:
3185:switcherator.c ****     if (temp == 255) // if the top is 255 we need it to be 254 so its not digital
 10066               		.loc 1 3185 0
 10067 3962 2F3F      		cpi r18,-1
 10068 3964 3105      		cpc r19,__zero_reg__
 10069 3966 4105      		cpc r20,__zero_reg__
 10070 3968 5105      		cpc r21,__zero_reg__
 10071 396a 01F4      		brne .L678
3186:switcherator.c ****         temp = 254;
 10072               		.loc 1 3186 0
 10073 396c 2EEF      		ldi r18,lo8(-2)
 10074 396e 30E0      		ldi r19,0
 10075 3970 40E0      		ldi r20,0
 10076 3972 50E0      		ldi r21,0
 10077               	.LVL835:
 10078               	.L678:
3188:switcherator.c ****     inputs[inputNumber][2] = temp;
 10079               		.loc 1 3188 0
 10080 3974 F801      		movw r30,r16
 10081 3976 E050      		subi r30,lo8(-(inputs))
 10082 3978 F040      		sbci r31,hi8(-(inputs))
 10083 397a 2283      		std Z+2,r18
3190:switcherator.c ****     if (commandReceived[13] == 'P' || commandReceived[13] == 'p') {
 10084               		.loc 1 3190 0
 10085 397c EA81      		ldd r30,Y+2
 10086 397e FB81      		ldd r31,Y+3
 10087 3980 8585      		ldd r24,Z+13
 10088 3982 8035      		cpi r24,lo8(80)
 10089 3984 01F0      		breq .L679
3190:switcherator.c ****     if (commandReceived[13] == 'P' || commandReceived[13] == 'p') {
 10090               		.loc 1 3190 0 is_stmt 0 discriminator 1
 10091 3986 8037      		cpi r24,lo8(112)
 10092 3988 01F4      		brne .L680
 10093               	.L679:
3191:switcherator.c ****         switchNumber += 128;
 10094               		.loc 1 3191 0 is_stmt 1
 10095 398a F0E8      		ldi r31,-128
 10096 398c EF0E      		add r14,r31
 10097 398e F11C      		adc r15,__zero_reg__
 10098               	.LVL836:
 10099               	.L680:
3193:switcherator.c ****     inputs[inputNumber][3] = switchNumber;
 10100               		.loc 1 3193 0
 10101 3990 F801      		movw r30,r16
 10102 3992 E050      		subi r30,lo8(-(inputs))
 10103 3994 F040      		sbci r31,hi8(-(inputs))
 10104 3996 E382      		std Z+3,r14
 10105               	.LVL837:
3195:switcherator.c ****     inputs[inputNumber][4] = temp;
 10106               		.loc 1 3195 0
 10107 3998 2981      		ldd r18,Y+1
 10108 399a 2483      		std Z+4,r18
 10109               	.LVL838:
3197:switcherator.c ****     inputs[inputNumber][5] = temp;
 10110               		.loc 1 3197 0
 10111 399c 6582      		std Z+5,r6
 10112               	.LVL839:
3202:switcherator.c ****     inputs[inputNumber][6] = pollTime;
 10113               		.loc 1 3202 0
 10114 399e 872D      		mov r24,r7
 10115 39a0 982D      		mov r25,r8
 10116 39a2 8F3F      		cpi r24,-1
 10117 39a4 9105      		cpc r25,__zero_reg__
 10118 39a6 01F0      		breq .L681
 10119 39a8 04F0      		brlt .L681
 10120 39aa 8FEF      		ldi r24,lo8(-1)
 10121 39ac 90E0      		ldi r25,0
 10122               	.L681:
 10123 39ae 8683      		std Z+6,r24
 10124               	.LVL840:
3207:switcherator.c ****     inputs[inputNumber][7] = whichRGB;
 10125               		.loc 1 3207 0
 10126 39b0 F801      		movw r30,r16
 10127 39b2 E050      		subi r30,lo8(-(inputs))
 10128 39b4 F040      		sbci r31,hi8(-(inputs))
 10129 39b6 892D      		mov r24,r9
 10130 39b8 8830      		cpi r24,lo8(8)
 10131 39ba 00F0      		brlo .L682
 10132 39bc 87E0      		ldi r24,lo8(7)
 10133               	.L682:
 10134 39be 8783      		std Z+7,r24
3212:switcherator.c ****     ADCSRA |= (1 << ADPS2) || (1 << ADPS0);
 10135               		.loc 1 3212 0
 10136 39c0 8091 7A00 		lds r24,122
 10137 39c4 8160      		ori r24,lo8(1)
 10138 39c6 8093 7A00 		sts 122,r24
 10139               	/* epilogue start */
3216:switcherator.c **** }
 10140               		.loc 1 3216 0
 10141 39ca 0F90      		pop __tmp_reg__
 10142 39cc 0F90      		pop __tmp_reg__
 10143 39ce 0F90      		pop __tmp_reg__
 10144 39d0 DF91      		pop r29
 10145 39d2 CF91      		pop r28
 10146 39d4 1F91      		pop r17
 10147 39d6 0F91      		pop r16
 10148 39d8 FF90      		pop r15
 10149 39da EF90      		pop r14
 10150 39dc DF90      		pop r13
 10151 39de CF90      		pop r12
 10152 39e0 BF90      		pop r11
 10153 39e2 AF90      		pop r10
 10154 39e4 9F90      		pop r9
 10155               	.LVL841:
 10156 39e6 8F90      		pop r8
 10157               	.LVL842:
 10158 39e8 7F90      		pop r7
 10159               	.LVL843:
 10160 39ea 6F90      		pop r6
 10161               	.LVL844:
 10162 39ec 5F90      		pop r5
 10163 39ee 4F90      		pop r4
 10164               	.LVL845:
 10165 39f0 3F90      		pop r3
 10166 39f2 2F90      		pop r2
3215:switcherator.c ****     ok();
 10167               		.loc 1 3215 0
 10168 39f4 0C94 0000 		jmp ok
 10169               	.LVL846:
 10170               	.LFE78:
 10172               	.global	startProgram
 10174               	startProgram:
 10175               	.LFB40:
1668:switcherator.c **** void startProgram(char * commandReceived) {
 10176               		.loc 1 1668 0
 10177               	.LVL847:
 10178 39f8 0F93      		push r16
 10179               	.LCFI250:
 10180 39fa 1F93      		push r17
 10181               	.LCFI251:
 10182 39fc CF93      		push r28
 10183               	.LCFI252:
 10184 39fe DF93      		push r29
 10185               	.LCFI253:
 10186               	/* prologue: function */
 10187               	/* frame size = 0 */
 10188               	/* stack size = 4 */
 10189               	.L__stack_usage = 4
 10190 3a00 EC01      		movw r28,r24
 10191               	.LVL848:
1672:switcherator.c ****     tempIntString[0] = commandReceived[3];
 10192               		.loc 1 1672 0
 10193 3a02 8B81      		ldd r24,Y+3
 10194               	.LVL849:
 10195 3a04 8093 0000 		sts tempIntString,r24
1673:switcherator.c ****     tempIntString[1] = commandReceived[4];
 10196               		.loc 1 1673 0
 10197 3a08 8C81      		ldd r24,Y+4
 10198 3a0a 8093 0000 		sts tempIntString+1,r24
1674:switcherator.c ****     programNumber = atoi(tempIntString);
 10199               		.loc 1 1674 0
 10200 3a0e 80E0      		ldi r24,lo8(tempIntString)
 10201 3a10 90E0      		ldi r25,hi8(tempIntString)
 10202 3a12 0E94 0000 		call atoi
 10203               	.LVL850:
 10204 3a16 8C01      		movw r16,r24
 10205               	.LVL851:
1675:switcherator.c ****     if (programNumber >= MAX_PROGRAM) {
 10206               		.loc 1 1675 0
 10207 3a18 8431      		cpi r24,20
 10208 3a1a 9105      		cpc r25,__zero_reg__
 10209 3a1c 04F0      		brlt .L696
1676:switcherator.c ****         fail(2);
 10210               		.loc 1 1676 0
 10211 3a1e 82E0      		ldi r24,lo8(2)
 10212 3a20 90E0      		ldi r25,0
 10213               	/* epilogue start */
1689:switcherator.c **** }
 10214               		.loc 1 1689 0
 10215 3a22 DF91      		pop r29
 10216 3a24 CF91      		pop r28
 10217               	.LVL852:
 10218 3a26 1F91      		pop r17
 10219 3a28 0F91      		pop r16
 10220               	.LVL853:
1676:switcherator.c ****         fail(2);
 10221               		.loc 1 1676 0
 10222 3a2a 0C94 0000 		jmp fail
 10223               	.LVL854:
 10224               	.L696:
1680:switcherator.c ****     tempHugeString[0] = commandReceived[5];
 10225               		.loc 1 1680 0
 10226 3a2e 8D81      		ldd r24,Y+5
 10227 3a30 8093 0000 		sts tempHugeString,r24
1681:switcherator.c ****     tempHugeString[1] = commandReceived[6];
 10228               		.loc 1 1681 0
 10229 3a34 8E81      		ldd r24,Y+6
 10230 3a36 8093 0000 		sts tempHugeString+1,r24
1682:switcherator.c ****     tempHugeString[2] = commandReceived[7];
 10231               		.loc 1 1682 0
 10232 3a3a 8F81      		ldd r24,Y+7
 10233 3a3c 8093 0000 		sts tempHugeString+2,r24
1683:switcherator.c ****     tempHugeString[3] = commandReceived[8];
 10234               		.loc 1 1683 0
 10235 3a40 8885      		ldd r24,Y+8
 10236 3a42 8093 0000 		sts tempHugeString+3,r24
1684:switcherator.c ****     tempHugeString[4] = commandReceived[9];
 10237               		.loc 1 1684 0
 10238 3a46 8985      		ldd r24,Y+9
 10239 3a48 8093 0000 		sts tempHugeString+4,r24
1685:switcherator.c ****     tempHugeString[5] = commandReceived[10];
 10240               		.loc 1 1685 0
 10241 3a4c 8A85      		ldd r24,Y+10
 10242 3a4e 8093 0000 		sts tempHugeString+5,r24
1686:switcherator.c ****     duration = atol(tempHugeString);
 10243               		.loc 1 1686 0
 10244 3a52 80E0      		ldi r24,lo8(tempHugeString)
 10245 3a54 90E0      		ldi r25,hi8(tempHugeString)
 10246 3a56 0E94 0000 		call atol
 10247               	.LVL855:
1687:switcherator.c ****     startTheProgram(programNumber, duration, 0);
 10248               		.loc 1 1687 0
 10249 3a5a 20E0      		ldi r18,0
 10250 3a5c 30E0      		ldi r19,0
 10251 3a5e A901      		movw r20,r18
 10252 3a60 C801      		movw r24,r16
 10253 3a62 0E94 0000 		call startTheProgram
 10254               	.LVL856:
 10255               	/* epilogue start */
1689:switcherator.c **** }
 10256               		.loc 1 1689 0
 10257 3a66 DF91      		pop r29
 10258 3a68 CF91      		pop r28
 10259               	.LVL857:
 10260 3a6a 1F91      		pop r17
 10261 3a6c 0F91      		pop r16
 10262               	.LVL858:
1688:switcherator.c ****     ok();
 10263               		.loc 1 1688 0
 10264 3a6e 0C94 0000 		jmp ok
 10265               	.LVL859:
 10266               	.LFE40:
 10268               	.global	programSetTime
 10270               	programSetTime:
 10271               	.LFB37:
1469:switcherator.c **** void programSetTime(char * commandReceived) {
 10272               		.loc 1 1469 0
 10273               	.LVL860:
 10274 3a72 AF92      		push r10
 10275               	.LCFI254:
 10276 3a74 BF92      		push r11
 10277               	.LCFI255:
 10278 3a76 CF92      		push r12
 10279               	.LCFI256:
 10280 3a78 DF92      		push r13
 10281               	.LCFI257:
 10282 3a7a EF92      		push r14
 10283               	.LCFI258:
 10284 3a7c FF92      		push r15
 10285               	.LCFI259:
 10286 3a7e 0F93      		push r16
 10287               	.LCFI260:
 10288 3a80 1F93      		push r17
 10289               	.LCFI261:
 10290 3a82 CF93      		push r28
 10291               	.LCFI262:
 10292 3a84 DF93      		push r29
 10293               	.LCFI263:
 10294               	/* prologue: function */
 10295               	/* frame size = 0 */
 10296               	/* stack size = 10 */
 10297               	.L__stack_usage = 10
 10298 3a86 EC01      		movw r28,r24
 10299               	.LVL861:
1475:switcherator.c ****     tempIntString[0] = commandReceived[3];
 10300               		.loc 1 1475 0
 10301 3a88 8B81      		ldd r24,Y+3
 10302               	.LVL862:
 10303 3a8a 8093 0000 		sts tempIntString,r24
1476:switcherator.c ****     tempIntString[1] = commandReceived[4];
 10304               		.loc 1 1476 0
 10305 3a8e FC80      		ldd r15,Y+4
 10306 3a90 F092 0000 		sts tempIntString+1,r15
1477:switcherator.c ****     programNumber = atoi(tempIntString);
 10307               		.loc 1 1477 0
 10308 3a94 80E0      		ldi r24,lo8(tempIntString)
 10309 3a96 90E0      		ldi r25,hi8(tempIntString)
 10310 3a98 0E94 0000 		call atoi
 10311               	.LVL863:
 10312 3a9c 8C01      		movw r16,r24
 10313               	.LVL864:
1478:switcherator.c ****     if (programNumber >= MAX_PROGRAM || (programNumber == 0 && commandReceived[4] != '0')) {
 10314               		.loc 1 1478 0
 10315 3a9e 8431      		cpi r24,20
 10316 3aa0 9105      		cpc r25,__zero_reg__
 10317 3aa2 04F4      		brge .L698
1478:switcherator.c ****     if (programNumber >= MAX_PROGRAM || (programNumber == 0 && commandReceived[4] != '0')) {
 10318               		.loc 1 1478 0 is_stmt 0 discriminator 1
 10319 3aa4 0097      		sbiw r24,0
 10320 3aa6 01F4      		brne .L699
 10321 3aa8 20E3      		ldi r18,lo8(48)
 10322 3aaa F216      		cp r15,r18
 10323 3aac 01F0      		breq .L699
 10324               	.L698:
1479:switcherator.c ****         fail(2);
 10325               		.loc 1 1479 0 is_stmt 1
 10326 3aae 82E0      		ldi r24,lo8(2)
 10327 3ab0 90E0      		ldi r25,0
 10328 3ab2 00C0      		rjmp .L715
 10329               	.L699:
1486:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 10330               		.loc 1 1486 0
 10331 3ab4 8AE0      		ldi r24,lo8(10)
 10332 3ab6 809F      		mul r24,r16
 10333 3ab8 F001      		movw r30,r0
 10334 3aba 819F      		mul r24,r17
 10335 3abc F00D      		add r31,r0
 10336 3abe 1124      		clr __zero_reg__
 10337 3ac0 E050      		subi r30,lo8(-(weeklyProgram))
 10338 3ac2 F040      		sbci r31,hi8(-(weeklyProgram))
 10339 3ac4 8081      		ld r24,Z
 10340 3ac6 8F3F      		cpi r24,lo8(-1)
 10341 3ac8 01F4      		brne .L700
1486:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 10342               		.loc 1 1486 0 is_stmt 0 discriminator 1
 10343 3aca 8181      		ldd r24,Z+1
 10344 3acc 8F3F      		cpi r24,lo8(-1)
 10345 3ace 01F4      		brne .L700
1487:switcherator.c ****         fail(0x0d);
 10346               		.loc 1 1487 0 is_stmt 1
 10347 3ad0 8DE0      		ldi r24,lo8(13)
 10348 3ad2 90E0      		ldi r25,0
 10349               	.LVL865:
 10350               	.L715:
 10351               	/* epilogue start */
1526:switcherator.c **** }
 10352               		.loc 1 1526 0
 10353 3ad4 DF91      		pop r29
 10354 3ad6 CF91      		pop r28
 10355               	.LVL866:
 10356 3ad8 1F91      		pop r17
 10357 3ada 0F91      		pop r16
 10358               	.LVL867:
 10359 3adc FF90      		pop r15
 10360 3ade EF90      		pop r14
 10361 3ae0 DF90      		pop r13
 10362 3ae2 CF90      		pop r12
 10363 3ae4 BF90      		pop r11
 10364 3ae6 AF90      		pop r10
1487:switcherator.c ****         fail(0x0d);
 10365               		.loc 1 1487 0
 10366 3ae8 0C94 0000 		jmp fail
 10367               	.LVL868:
 10368               	.L700:
1490:switcherator.c ****     tempIntString[0] = commandReceived[5];
 10369               		.loc 1 1490 0
 10370 3aec 8D81      		ldd r24,Y+5
 10371 3aee 8093 0000 		sts tempIntString,r24
1491:switcherator.c ****     tempIntString[1] = commandReceived[6];
 10372               		.loc 1 1491 0
 10373 3af2 AE80      		ldd r10,Y+6
 10374 3af4 A092 0000 		sts tempIntString+1,r10
1492:switcherator.c ****     hours = atoi(tempIntString);
 10375               		.loc 1 1492 0
 10376 3af8 80E0      		ldi r24,lo8(tempIntString)
 10377 3afa 90E0      		ldi r25,hi8(tempIntString)
 10378 3afc 0E94 0000 		call atoi
 10379               	.LVL869:
 10380 3b00 6C01      		movw r12,r24
 10381               	.LVL870:
1493:switcherator.c ****     tempIntString[0] = commandReceived[7];
 10382               		.loc 1 1493 0
 10383 3b02 8F81      		ldd r24,Y+7
 10384 3b04 8093 0000 		sts tempIntString,r24
1494:switcherator.c ****     tempIntString[1] = commandReceived[8];
 10385               		.loc 1 1494 0
 10386 3b08 B884      		ldd r11,Y+8
 10387 3b0a B092 0000 		sts tempIntString+1,r11
1495:switcherator.c ****     minutes = atoi(tempIntString);
 10388               		.loc 1 1495 0
 10389 3b0e 80E0      		ldi r24,lo8(tempIntString)
 10390 3b10 90E0      		ldi r25,hi8(tempIntString)
 10391 3b12 0E94 0000 		call atoi
 10392               	.LVL871:
 10393 3b16 7C01      		movw r14,r24
 10394               	.LVL872:
1496:switcherator.c ****     tempLongString[0] = commandReceived[9];
 10395               		.loc 1 1496 0
 10396 3b18 8985      		ldd r24,Y+9
 10397 3b1a 8093 0000 		sts tempLongString,r24
1497:switcherator.c ****     tempLongString[1] = commandReceived[10];
 10398               		.loc 1 1497 0
 10399 3b1e 8A85      		ldd r24,Y+10
 10400 3b20 8093 0000 		sts tempLongString+1,r24
1498:switcherator.c ****     tempLongString[2] = commandReceived[11];
 10401               		.loc 1 1498 0
 10402 3b24 8B85      		ldd r24,Y+11
 10403 3b26 8093 0000 		sts tempLongString+2,r24
1499:switcherator.c ****     tempLongString[3] = commandReceived[12];
 10404               		.loc 1 1499 0
 10405 3b2a 8C85      		ldd r24,Y+12
 10406 3b2c 8093 0000 		sts tempLongString+3,r24
1500:switcherator.c ****     duration = atoi(tempLongString);
 10407               		.loc 1 1500 0
 10408 3b30 80E0      		ldi r24,lo8(tempLongString)
 10409 3b32 90E0      		ldi r25,hi8(tempLongString)
 10410 3b34 0E94 0000 		call atoi
 10411               	.LVL873:
1501:switcherator.c ****     if (hours >= 24 || (hours == 0 && commandReceived[6] != '0')) {
 10412               		.loc 1 1501 0
 10413 3b38 28E1      		ldi r18,24
 10414 3b3a C216      		cp r12,r18
 10415 3b3c D104      		cpc r13,__zero_reg__
 10416 3b3e 04F4      		brge .L701
1501:switcherator.c ****     if (hours >= 24 || (hours == 0 && commandReceived[6] != '0')) {
 10417               		.loc 1 1501 0 is_stmt 0 discriminator 1
 10418 3b40 C114      		cp r12,__zero_reg__
 10419 3b42 D104      		cpc r13,__zero_reg__
 10420 3b44 01F4      		brne .L702
 10421 3b46 20E3      		ldi r18,lo8(48)
 10422 3b48 A216      		cp r10,r18
 10423 3b4a 01F0      		breq .L702
 10424               	.L701:
1502:switcherator.c ****         fail(9);
 10425               		.loc 1 1502 0 is_stmt 1
 10426 3b4c 89E0      		ldi r24,lo8(9)
 10427 3b4e 90E0      		ldi r25,0
 10428               	.LVL874:
 10429 3b50 00C0      		rjmp .L715
 10430               	.LVL875:
 10431               	.L702:
1505:switcherator.c ****     if (minutes >= 60 || (minutes == 0 && commandReceived[8] != '0')) {
 10432               		.loc 1 1505 0
 10433 3b52 2CE3      		ldi r18,60
 10434 3b54 E216      		cp r14,r18
 10435 3b56 F104      		cpc r15,__zero_reg__
 10436 3b58 04F4      		brge .L703
1505:switcherator.c ****     if (minutes >= 60 || (minutes == 0 && commandReceived[8] != '0')) {
 10437               		.loc 1 1505 0 is_stmt 0 discriminator 1
 10438 3b5a E114      		cp r14,__zero_reg__
 10439 3b5c F104      		cpc r15,__zero_reg__
 10440 3b5e 01F4      		brne .L704
 10441 3b60 20E3      		ldi r18,lo8(48)
 10442 3b62 B216      		cp r11,r18
 10443 3b64 01F0      		breq .L704
 10444               	.L703:
1506:switcherator.c ****         fail(0x0a);
 10445               		.loc 1 1506 0 is_stmt 1
 10446 3b66 8AE0      		ldi r24,lo8(10)
 10447 3b68 90E0      		ldi r25,0
 10448               	.LVL876:
 10449 3b6a 00C0      		rjmp .L715
 10450               	.LVL877:
 10451               	.L704:
1509:switcherator.c ****     if (duration == 0) {
 10452               		.loc 1 1509 0
 10453 3b6c 0097      		sbiw r24,0
 10454 3b6e 01F4      		brne .L705
1510:switcherator.c ****         fail(0x0b);
 10455               		.loc 1 1510 0
 10456 3b70 8BE0      		ldi r24,lo8(11)
 10457 3b72 90E0      		ldi r25,0
 10458               	.LVL878:
 10459 3b74 00C0      		rjmp .L715
 10460               	.LVL879:
 10461               	.L705:
1513:switcherator.c ****     duration *= 60; // convert to seconds
 10462               		.loc 1 1513 0
 10463 3b76 6CE3      		ldi r22,lo8(60)
 10464 3b78 689F      		mul r22,r24
 10465 3b7a A001      		movw r20,r0
 10466 3b7c 699F      		mul r22,r25
 10467 3b7e 500D      		add r21,r0
 10468 3b80 1124      		clr __zero_reg__
 10469               	.LVL880:
1514:switcherator.c ****     startTime = (hours * 60);
 10470               		.loc 1 1514 0
 10471 3b82 6C9D      		mul r22,r12
 10472 3b84 9001      		movw r18,r0
 10473 3b86 6D9D      		mul r22,r13
 10474 3b88 300D      		add r19,r0
 10475 3b8a 1124      		clr __zero_reg__
 10476               	.LVL881:
1515:switcherator.c ****     startTime += minutes; // stored in minutes
 10477               		.loc 1 1515 0
 10478 3b8c 2E0D      		add r18,r14
 10479 3b8e 3F1D      		adc r19,r15
 10480               	.LVL882:
1518:switcherator.c ****     weeklyProgram[programNumber][1] = temp;
 10481               		.loc 1 1518 0
 10482 3b90 8AE0      		ldi r24,lo8(10)
 10483 3b92 809F      		mul r24,r16
 10484 3b94 F001      		movw r30,r0
 10485 3b96 819F      		mul r24,r17
 10486 3b98 F00D      		add r31,r0
 10487 3b9a 1124      		clr __zero_reg__
 10488 3b9c E050      		subi r30,lo8(-(weeklyProgram))
 10489 3b9e F040      		sbci r31,hi8(-(weeklyProgram))
 10490 3ba0 3183      		std Z+1,r19
 10491               	.LVL883:
1520:switcherator.c ****     weeklyProgram[programNumber][2] = temp;
 10492               		.loc 1 1520 0
 10493 3ba2 2283      		std Z+2,r18
 10494               	.LVL884:
1522:switcherator.c ****     weeklyProgram[programNumber][3] = temp;
 10495               		.loc 1 1522 0
 10496 3ba4 5383      		std Z+3,r21
 10497               	.LVL885:
1523:switcherator.c ****     temp = (duration & 0xff);
 10498               		.loc 1 1523 0
 10499 3ba6 5527      		clr r21
 10500               	.LVL886:
1524:switcherator.c ****     weeklyProgram[programNumber][4] = temp;
 10501               		.loc 1 1524 0
 10502 3ba8 4483      		std Z+4,r20
 10503               	/* epilogue start */
1526:switcherator.c **** }
 10504               		.loc 1 1526 0
 10505 3baa DF91      		pop r29
 10506 3bac CF91      		pop r28
 10507               	.LVL887:
 10508 3bae 1F91      		pop r17
 10509 3bb0 0F91      		pop r16
 10510               	.LVL888:
 10511 3bb2 FF90      		pop r15
 10512 3bb4 EF90      		pop r14
 10513               	.LVL889:
 10514 3bb6 DF90      		pop r13
 10515 3bb8 CF90      		pop r12
 10516               	.LVL890:
 10517 3bba BF90      		pop r11
 10518 3bbc AF90      		pop r10
1525:switcherator.c ****     ok();
 10519               		.loc 1 1525 0
 10520 3bbe 0C94 0000 		jmp ok
 10521               	.LVL891:
 10522               	.LFE37:
 10524               		.section	.rodata.str1.1
 10525               	.LC69:
 10526 0151 3030 3030 		.string	"0000000"
 10526      3030 3000 
 10527               		.text
 10528               	.global	programSetDays
 10530               	programSetDays:
 10531               	.LFB36:
1428:switcherator.c **** void programSetDays(char * commandReceived) {
 10532               		.loc 1 1428 0
 10533               	.LVL892:
 10534 3bc2 EF92      		push r14
 10535               	.LCFI264:
 10536 3bc4 FF92      		push r15
 10537               	.LCFI265:
 10538 3bc6 0F93      		push r16
 10539               	.LCFI266:
 10540 3bc8 1F93      		push r17
 10541               	.LCFI267:
 10542 3bca CF93      		push r28
 10543               	.LCFI268:
 10544 3bcc DF93      		push r29
 10545               	.LCFI269:
 10546 3bce CDB7      		in r28,__SP_L__
 10547 3bd0 DEB7      		in r29,__SP_H__
 10548               	.LCFI270:
 10549 3bd2 2897      		sbiw r28,8
 10550               	.LCFI271:
 10551 3bd4 0FB6      		in __tmp_reg__,__SREG__
 10552 3bd6 F894      		cli
 10553 3bd8 DEBF      		out __SP_H__,r29
 10554 3bda 0FBE      		out __SREG__,__tmp_reg__
 10555 3bdc CDBF      		out __SP_L__,r28
 10556               	/* prologue: function */
 10557               	/* frame size = 8 */
 10558               	/* stack size = 14 */
 10559               	.L__stack_usage = 14
 10560 3bde 7C01      		movw r14,r24
1429:switcherator.c ****     char tempReallyLongString[] = "0000000";
 10561               		.loc 1 1429 0
 10562 3be0 88E0      		ldi r24,lo8(8)
 10563               	.LVL893:
 10564 3be2 E0E0      		ldi r30,lo8(.LC69)
 10565 3be4 F0E0      		ldi r31,hi8(.LC69)
 10566 3be6 DE01      		movw r26,r28
 10567 3be8 1196      		adiw r26,1
 10568               		0:
 10569 3bea 0190      		ld r0,Z+
 10570 3bec 0D92      		st X+,r0
 10571 3bee 8A95      		dec r24
 10572 3bf0 01F4      		brne 0b
 10573               	.LVL894:
1432:switcherator.c ****     tempIntString[0] = commandReceived[3];
 10574               		.loc 1 1432 0
 10575 3bf2 F701      		movw r30,r14
 10576 3bf4 8381      		ldd r24,Z+3
 10577 3bf6 8093 0000 		sts tempIntString,r24
1433:switcherator.c ****     tempIntString[1] = commandReceived[4];
 10578               		.loc 1 1433 0
 10579 3bfa 8481      		ldd r24,Z+4
 10580 3bfc 8093 0000 		sts tempIntString+1,r24
1434:switcherator.c ****     programNumber = atoi(tempIntString);
 10581               		.loc 1 1434 0
 10582 3c00 80E0      		ldi r24,lo8(tempIntString)
 10583 3c02 90E0      		ldi r25,hi8(tempIntString)
 10584 3c04 0E94 0000 		call atoi
 10585               	.LVL895:
 10586 3c08 8C01      		movw r16,r24
 10587               	.LVL896:
1435:switcherator.c ****     tempReallyLongString[0] = commandReceived[5];
 10588               		.loc 1 1435 0
 10589 3c0a F701      		movw r30,r14
 10590 3c0c 8581      		ldd r24,Z+5
 10591 3c0e 8983      		std Y+1,r24
1436:switcherator.c ****     tempReallyLongString[1] = commandReceived[6];
 10592               		.loc 1 1436 0
 10593 3c10 8681      		ldd r24,Z+6
 10594 3c12 8A83      		std Y+2,r24
1437:switcherator.c ****     tempReallyLongString[2] = commandReceived[7];
 10595               		.loc 1 1437 0
 10596 3c14 8781      		ldd r24,Z+7
 10597 3c16 8B83      		std Y+3,r24
1438:switcherator.c ****     tempReallyLongString[3] = commandReceived[8];
 10598               		.loc 1 1438 0
 10599 3c18 8085      		ldd r24,Z+8
 10600 3c1a 8C83      		std Y+4,r24
1439:switcherator.c ****     tempReallyLongString[4] = commandReceived[9];
 10601               		.loc 1 1439 0
 10602 3c1c 8185      		ldd r24,Z+9
 10603 3c1e 8D83      		std Y+5,r24
1440:switcherator.c ****     tempReallyLongString[5] = commandReceived[10];
 10604               		.loc 1 1440 0
 10605 3c20 8285      		ldd r24,Z+10
 10606 3c22 8E83      		std Y+6,r24
1441:switcherator.c ****     tempReallyLongString[6] = commandReceived[11];
 10607               		.loc 1 1441 0
 10608 3c24 8385      		ldd r24,Z+11
 10609 3c26 8F83      		std Y+7,r24
1442:switcherator.c ****     weekLong = strtol(tempReallyLongString, 0, 2);
 10610               		.loc 1 1442 0
 10611 3c28 42E0      		ldi r20,lo8(2)
 10612 3c2a 50E0      		ldi r21,0
 10613 3c2c 60E0      		ldi r22,0
 10614 3c2e 70E0      		ldi r23,0
 10615 3c30 CE01      		movw r24,r28
 10616 3c32 0196      		adiw r24,1
 10617 3c34 0E94 0000 		call strtol
 10618               	.LVL897:
1443:switcherator.c ****     if ((programNumber >= MAX_PROGRAM) || (programNumber == 0 && commandReceived[4] != '0')) {
 10619               		.loc 1 1443 0
 10620 3c38 0431      		cpi r16,20
 10621 3c3a 1105      		cpc r17,__zero_reg__
 10622 3c3c 04F4      		brge .L717
1443:switcherator.c ****     if ((programNumber >= MAX_PROGRAM) || (programNumber == 0 && commandReceived[4] != '0')) {
 10623               		.loc 1 1443 0 is_stmt 0 discriminator 1
 10624 3c3e 0115      		cp r16,__zero_reg__
 10625 3c40 1105      		cpc r17,__zero_reg__
 10626 3c42 01F4      		brne .L718
 10627 3c44 F701      		movw r30,r14
 10628 3c46 2481      		ldd r18,Z+4
 10629 3c48 2033      		cpi r18,lo8(48)
 10630 3c4a 01F0      		breq .L718
 10631               	.L717:
1444:switcherator.c ****         fail(2);
 10632               		.loc 1 1444 0 is_stmt 1
 10633 3c4c 82E0      		ldi r24,lo8(2)
 10634 3c4e 90E0      		ldi r25,0
 10635 3c50 00C0      		rjmp .L726
 10636               	.L718:
1451:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 10637               		.loc 1 1451 0
 10638 3c52 2AE0      		ldi r18,lo8(10)
 10639 3c54 209F      		mul r18,r16
 10640 3c56 F001      		movw r30,r0
 10641 3c58 219F      		mul r18,r17
 10642 3c5a F00D      		add r31,r0
 10643 3c5c 1124      		clr __zero_reg__
 10644 3c5e E050      		subi r30,lo8(-(weeklyProgram))
 10645 3c60 F040      		sbci r31,hi8(-(weeklyProgram))
 10646 3c62 2081      		ld r18,Z
 10647 3c64 2F3F      		cpi r18,lo8(-1)
 10648 3c66 01F4      		brne .L720
1451:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 10649               		.loc 1 1451 0 is_stmt 0 discriminator 1
 10650 3c68 2181      		ldd r18,Z+1
 10651 3c6a 2F3F      		cpi r18,lo8(-1)
 10652 3c6c 01F4      		brne .L720
1452:switcherator.c ****         fail(0x0d);
 10653               		.loc 1 1452 0 is_stmt 1
 10654 3c6e 8DE0      		ldi r24,lo8(13)
 10655 3c70 90E0      		ldi r25,0
 10656 3c72 00C0      		rjmp .L726
 10657               	.L720:
1455:switcherator.c ****     if ((weekLong & 0x7f) == 0) {
 10658               		.loc 1 1455 0
 10659 3c74 AB01      		movw r20,r22
 10660 3c76 BC01      		movw r22,r24
 10661 3c78 4F77      		andi r20,127
 10662 3c7a 5527      		clr r21
 10663 3c7c 6627      		clr r22
 10664 3c7e 7727      		clr r23
 10665 3c80 4115      		cp r20,__zero_reg__
 10666 3c82 5105      		cpc r21,__zero_reg__
 10667 3c84 6105      		cpc r22,__zero_reg__
 10668 3c86 7105      		cpc r23,__zero_reg__
 10669 3c88 01F4      		brne .L721
1456:switcherator.c ****         fail(0x0f);
 10670               		.loc 1 1456 0
 10671 3c8a 8FE0      		ldi r24,lo8(15)
 10672 3c8c 90E0      		ldi r25,0
 10673               	.L726:
 10674 3c8e 0E94 0000 		call fail
 10675               	.LVL898:
 10676 3c92 00C0      		rjmp .L716
 10677               	.LVL899:
 10678               	.L721:
1460:switcherator.c ****     weeklyProgram[programNumber][0] = weekdays;
 10679               		.loc 1 1460 0
 10680 3c94 8AE0      		ldi r24,lo8(10)
 10681 3c96 809F      		mul r24,r16
 10682 3c98 F001      		movw r30,r0
 10683 3c9a 819F      		mul r24,r17
 10684 3c9c F00D      		add r31,r0
 10685 3c9e 1124      		clr __zero_reg__
 10686 3ca0 E050      		subi r30,lo8(-(weeklyProgram))
 10687 3ca2 F040      		sbci r31,hi8(-(weeklyProgram))
1459:switcherator.c ****     char weekdays = (weekLong & 0x7f);
 10688               		.loc 1 1459 0
 10689 3ca4 4083      		st Z,r20
1461:switcherator.c ****     ok();
 10690               		.loc 1 1461 0
 10691 3ca6 0E94 0000 		call ok
 10692               	.LVL900:
 10693               	.L716:
 10694               	/* epilogue start */
1462:switcherator.c **** }
 10695               		.loc 1 1462 0
 10696 3caa 2896      		adiw r28,8
 10697 3cac 0FB6      		in __tmp_reg__,__SREG__
 10698 3cae F894      		cli
 10699 3cb0 DEBF      		out __SP_H__,r29
 10700 3cb2 0FBE      		out __SREG__,__tmp_reg__
 10701 3cb4 CDBF      		out __SP_L__,r28
 10702 3cb6 DF91      		pop r29
 10703 3cb8 CF91      		pop r28
 10704 3cba 1F91      		pop r17
 10705 3cbc 0F91      		pop r16
 10706               	.LVL901:
 10707 3cbe FF90      		pop r15
 10708 3cc0 EF90      		pop r14
 10709               	.LVL902:
 10710 3cc2 0895      		ret
 10711               	.LFE36:
 10713               	.global	programAddSwitch
 10715               	programAddSwitch:
 10716               	.LFB34:
1323:switcherator.c **** void programAddSwitch(char * commandReceived) {
 10717               		.loc 1 1323 0
 10718               	.LVL903:
 10719 3cc4 CF92      		push r12
 10720               	.LCFI272:
 10721 3cc6 DF92      		push r13
 10722               	.LCFI273:
 10723 3cc8 EF92      		push r14
 10724               	.LCFI274:
 10725 3cca FF92      		push r15
 10726               	.LCFI275:
 10727 3ccc 0F93      		push r16
 10728               	.LCFI276:
 10729 3cce 1F93      		push r17
 10730               	.LCFI277:
 10731 3cd0 CF93      		push r28
 10732               	.LCFI278:
 10733 3cd2 DF93      		push r29
 10734               	.LCFI279:
 10735 3cd4 CDB7      		in r28,__SP_L__
 10736 3cd6 DEB7      		in r29,__SP_H__
 10737               	.LCFI280:
 10738 3cd8 6097      		sbiw r28,16
 10739               	.LCFI281:
 10740 3cda 0FB6      		in __tmp_reg__,__SREG__
 10741 3cdc F894      		cli
 10742 3cde DEBF      		out __SP_H__,r29
 10743 3ce0 0FBE      		out __SREG__,__tmp_reg__
 10744 3ce2 CDBF      		out __SP_L__,r28
 10745               	/* prologue: function */
 10746               	/* frame size = 16 */
 10747               	/* stack size = 24 */
 10748               	.L__stack_usage = 24
 10749 3ce4 7C01      		movw r14,r24
 10750               	.LVL904:
1326:switcherator.c ****     tempIntString[0] = commandReceived[3];
 10751               		.loc 1 1326 0
 10752 3ce6 FC01      		movw r30,r24
 10753 3ce8 8381      		ldd r24,Z+3
 10754               	.LVL905:
 10755 3cea 8093 0000 		sts tempIntString,r24
1327:switcherator.c ****     tempIntString[1] = commandReceived[4];
 10756               		.loc 1 1327 0
 10757 3cee 8481      		ldd r24,Z+4
 10758 3cf0 8093 0000 		sts tempIntString+1,r24
1328:switcherator.c ****     programNumber = atoi(tempIntString);
 10759               		.loc 1 1328 0
 10760 3cf4 80E0      		ldi r24,lo8(tempIntString)
 10761 3cf6 90E0      		ldi r25,hi8(tempIntString)
 10762 3cf8 0E94 0000 		call atoi
 10763               	.LVL906:
 10764 3cfc 8C01      		movw r16,r24
 10765               	.LVL907:
1329:switcherator.c ****     tempIntString[0] = commandReceived[5];
 10766               		.loc 1 1329 0
 10767 3cfe F701      		movw r30,r14
 10768 3d00 8581      		ldd r24,Z+5
 10769 3d02 8093 0000 		sts tempIntString,r24
1330:switcherator.c ****     tempIntString[1] = commandReceived[6];
 10770               		.loc 1 1330 0
 10771 3d06 8681      		ldd r24,Z+6
 10772 3d08 8093 0000 		sts tempIntString+1,r24
1331:switcherator.c ****     switchNumber = atoi(tempIntString);
 10773               		.loc 1 1331 0
 10774 3d0c 80E0      		ldi r24,lo8(tempIntString)
 10775 3d0e 90E0      		ldi r25,hi8(tempIntString)
 10776 3d10 0E94 0000 		call atoi
 10777               	.LVL908:
 10778 3d14 6C01      		movw r12,r24
 10779               	.LVL909:
1333:switcherator.c ****     switches[0] = 0;
 10780               		.loc 1 1333 0
 10781 3d16 1982      		std Y+1,__zero_reg__
1334:switcherator.c ****     int switchCount = programGetSwitches(programNumber, switches);
 10782               		.loc 1 1334 0
 10783 3d18 BE01      		movw r22,r28
 10784 3d1a 6F5F      		subi r22,-1
 10785 3d1c 7F4F      		sbci r23,-1
 10786 3d1e C801      		movw r24,r16
 10787 3d20 0E94 0000 		call programGetSwitches
 10788               	.LVL910:
 10789 3d24 FE01      		movw r30,r28
 10790 3d26 3196      		adiw r30,1
1323:switcherator.c **** void programAddSwitch(char * commandReceived) {
 10791               		.loc 1 1323 0
 10792 3d28 AF01      		movw r20,r30
1337:switcherator.c ****     for (x = 0; x < switchCount; x++) {
 10793               		.loc 1 1337 0
 10794 3d2a 00C0      		rjmp .L728
 10795               	.LVL911:
 10796               	.L730:
1338:switcherator.c ****         if (switches[x] == switchNumber) {
 10797               		.loc 1 1338 0
 10798 3d2c 2191      		ld r18,Z+
 10799 3d2e 30E0      		ldi r19,0
 10800 3d30 2C15      		cp r18,r12
 10801 3d32 3D05      		cpc r19,r13
 10802 3d34 01F4      		brne .L728
1339:switcherator.c ****             fail(0x0c);
 10803               		.loc 1 1339 0
 10804 3d36 8CE0      		ldi r24,lo8(12)
 10805 3d38 90E0      		ldi r25,0
 10806               	.LVL912:
 10807 3d3a 00C0      		rjmp .L754
 10808               	.LVL913:
 10809               	.L728:
1323:switcherator.c **** void programAddSwitch(char * commandReceived) {
 10810               		.loc 1 1323 0 discriminator 1
 10811 3d3c 9F01      		movw r18,r30
 10812 3d3e 241B      		sub r18,r20
 10813 3d40 350B      		sbc r19,r21
1337:switcherator.c ****     for (x = 0; x < switchCount; x++) {
 10814               		.loc 1 1337 0 discriminator 1
 10815 3d42 2817      		cp r18,r24
 10816 3d44 3907      		cpc r19,r25
 10817 3d46 04F0      		brlt .L730
1345:switcherator.c ****     if ((programNumber >= MAX_PROGRAM) || (programNumber == 0 && commandReceived[4] != '0')) {
 10818               		.loc 1 1345 0
 10819 3d48 0431      		cpi r16,20
 10820 3d4a 1105      		cpc r17,__zero_reg__
 10821 3d4c 04F4      		brge .L731
1345:switcherator.c ****     if ((programNumber >= MAX_PROGRAM) || (programNumber == 0 && commandReceived[4] != '0')) {
 10822               		.loc 1 1345 0 is_stmt 0 discriminator 1
 10823 3d4e 0115      		cp r16,__zero_reg__
 10824 3d50 1105      		cpc r17,__zero_reg__
 10825 3d52 01F4      		brne .L732
 10826 3d54 F701      		movw r30,r14
 10827 3d56 8481      		ldd r24,Z+4
 10828               	.LVL914:
 10829 3d58 8033      		cpi r24,lo8(48)
 10830 3d5a 01F0      		breq .L732
 10831               	.L731:
1346:switcherator.c ****         fail(2);
 10832               		.loc 1 1346 0 is_stmt 1
 10833 3d5c 82E0      		ldi r24,lo8(2)
 10834 3d5e 90E0      		ldi r25,0
 10835 3d60 00C0      		rjmp .L754
 10836               	.L732:
1349:switcherator.c ****     if ((switchNumber >= NUM_SWITCHES) || (switchNumber == 0 && commandReceived[6] != '0')) {
 10837               		.loc 1 1349 0
 10838 3d62 F0E1      		ldi r31,16
 10839 3d64 CF16      		cp r12,r31
 10840 3d66 D104      		cpc r13,__zero_reg__
 10841 3d68 04F4      		brge .L733
1349:switcherator.c ****     if ((switchNumber >= NUM_SWITCHES) || (switchNumber == 0 && commandReceived[6] != '0')) {
 10842               		.loc 1 1349 0 is_stmt 0 discriminator 1
 10843 3d6a C114      		cp r12,__zero_reg__
 10844 3d6c D104      		cpc r13,__zero_reg__
 10845 3d6e 01F4      		brne .L734
 10846 3d70 F701      		movw r30,r14
 10847 3d72 8681      		ldd r24,Z+6
 10848 3d74 8033      		cpi r24,lo8(48)
 10849 3d76 01F0      		breq .L734
 10850               	.L733:
1350:switcherator.c ****         fail(1);
 10851               		.loc 1 1350 0 is_stmt 1
 10852 3d78 81E0      		ldi r24,lo8(1)
 10853 3d7a 90E0      		ldi r25,0
 10854 3d7c 00C0      		rjmp .L754
 10855               	.L734:
1357:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 10856               		.loc 1 1357 0
 10857 3d7e 8AE0      		ldi r24,lo8(10)
 10858 3d80 809F      		mul r24,r16
 10859 3d82 F001      		movw r30,r0
 10860 3d84 819F      		mul r24,r17
 10861 3d86 F00D      		add r31,r0
 10862 3d88 1124      		clr __zero_reg__
 10863 3d8a E050      		subi r30,lo8(-(weeklyProgram))
 10864 3d8c F040      		sbci r31,hi8(-(weeklyProgram))
 10865 3d8e 8081      		ld r24,Z
 10866 3d90 8F3F      		cpi r24,lo8(-1)
 10867 3d92 01F4      		brne .L735
1357:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 10868               		.loc 1 1357 0 is_stmt 0 discriminator 1
 10869 3d94 8181      		ldd r24,Z+1
 10870 3d96 8F3F      		cpi r24,lo8(-1)
 10871 3d98 01F4      		brne .L735
1358:switcherator.c ****         fail(0x0d);
 10872               		.loc 1 1358 0 is_stmt 1
 10873 3d9a 8DE0      		ldi r24,lo8(13)
 10874 3d9c 90E0      		ldi r25,0
 10875 3d9e 00C0      		rjmp .L754
 10876               	.L735:
 10877               	.LVL915:
1365:switcherator.c ****     itoa(programNumber, tempIntString, 10);
 10878               		.loc 1 1365 0
 10879 3da0 4AE0      		ldi r20,lo8(10)
 10880 3da2 50E0      		ldi r21,0
 10881 3da4 60E0      		ldi r22,lo8(tempIntString)
 10882 3da6 70E0      		ldi r23,hi8(tempIntString)
 10883 3da8 C801      		movw r24,r16
 10884 3daa 0E94 0000 		call itoa
 10885               	.LVL916:
1367:switcherator.c ****     blankSwitch = findOpenSwitch(programNumber);
 10886               		.loc 1 1367 0
 10887 3dae C801      		movw r24,r16
 10888 3db0 0E94 0000 		call findOpenSwitch
 10889               	.LVL917:
1369:switcherator.c ****         if (blankSwitch == 0) {
 10890               		.loc 1 1369 0
 10891 3db4 0097      		sbiw r24,0
 10892 3db6 01F4      		brne .L736
1372:switcherator.c ****             overflowProgram = weeklyProgram[programNumber][9];
 10893               		.loc 1 1372 0
 10894 3db8 4AE0      		ldi r20,lo8(10)
 10895               	.LVL918:
 10896               	.L753:
 10897 3dba 409F      		mul r20,r16
 10898 3dbc F001      		movw r30,r0
 10899 3dbe 419F      		mul r20,r17
 10900 3dc0 F00D      		add r31,r0
 10901 3dc2 1124      		clr __zero_reg__
 10902 3dc4 E050      		subi r30,lo8(-(weeklyProgram))
 10903 3dc6 F040      		sbci r31,hi8(-(weeklyProgram))
 10904 3dc8 8185      		ldd r24,Z+9
 10905 3dca 90E0      		ldi r25,0
 10906               	.LVL919:
1373:switcherator.c ****             if (overflowProgram == 255) {
 10907               		.loc 1 1373 0
 10908 3dcc 8F3F      		cpi r24,-1
 10909 3dce 9105      		cpc r25,__zero_reg__
 10910 3dd0 01F4      		brne .L743
 10911 3dd2 2FEF      		ldi r18,lo8(-1)
 10912 3dd4 30E0      		ldi r19,0
 10913 3dd6 83E1      		ldi r24,lo8(19)
 10914 3dd8 90E0      		ldi r25,0
 10915               	.LVL920:
 10916               	.L739:
 10917               	.LBB24:
1380:switcherator.c ****                     if (weeklyProgram[x][0] == 255 && weeklyProgram[x][5] == 255) {
 10918               		.loc 1 1380 0
 10919 3dda 489F      		mul r20,r24
 10920 3ddc F001      		movw r30,r0
 10921 3dde 499F      		mul r20,r25
 10922 3de0 F00D      		add r31,r0
 10923 3de2 1124      		clr __zero_reg__
 10924 3de4 E050      		subi r30,lo8(-(weeklyProgram))
 10925 3de6 F040      		sbci r31,hi8(-(weeklyProgram))
 10926 3de8 5081      		ld r21,Z
 10927 3dea 5F3F      		cpi r21,lo8(-1)
 10928 3dec 01F4      		brne .L738
1380:switcherator.c ****                     if (weeklyProgram[x][0] == 255 && weeklyProgram[x][5] == 255) {
 10929               		.loc 1 1380 0 is_stmt 0 discriminator 1
 10930 3dee 5581      		ldd r21,Z+5
 10931 3df0 5F3F      		cpi r21,lo8(-1)
 10932 3df2 01F4      		brne .L738
1380:switcherator.c ****                     if (weeklyProgram[x][0] == 255 && weeklyProgram[x][5] == 255) {
 10933               		.loc 1 1380 0
 10934 3df4 9C01      		movw r18,r24
1384:switcherator.c ****                         x = 0;
 10935               		.loc 1 1384 0 is_stmt 1
 10936 3df6 80E0      		ldi r24,0
 10937 3df8 90E0      		ldi r25,0
 10938               	.L738:
 10939               	.LVL921:
1378:switcherator.c ****                 for (x = (MAX_PROGRAM - 1); x > 0; x--) {
 10940               		.loc 1 1378 0
 10941 3dfa 0197      		sbiw r24,1
 10942               	.LVL922:
 10943 3dfc 1816      		cp __zero_reg__,r24
 10944 3dfe 1906      		cpc __zero_reg__,r25
 10945 3e00 04F0      		brlt .L739
1387:switcherator.c ****                 if (possibleBlank == 255) {
 10946               		.loc 1 1387 0
 10947 3e02 2F3F      		cpi r18,-1
 10948 3e04 3105      		cpc r19,__zero_reg__
 10949 3e06 01F4      		brne .L740
1389:switcherator.c ****                     fail(0x0e);
 10950               		.loc 1 1389 0
 10951 3e08 8EE0      		ldi r24,lo8(14)
 10952 3e0a 90E0      		ldi r25,0
 10953               	.LVL923:
 10954               	.L754:
 10955 3e0c 0E94 0000 		call fail
 10956               	.LVL924:
 10957 3e10 00C0      		rjmp .L727
 10958               	.LVL925:
 10959               	.L740:
1393:switcherator.c ****                 weeklyProgram[programNumber][9] = possibleBlank;
 10960               		.loc 1 1393 0
 10961 3e12 409F      		mul r20,r16
 10962 3e14 F001      		movw r30,r0
 10963 3e16 419F      		mul r20,r17
 10964 3e18 F00D      		add r31,r0
 10965 3e1a 1124      		clr __zero_reg__
 10966 3e1c E050      		subi r30,lo8(-(weeklyProgram))
 10967 3e1e F040      		sbci r31,hi8(-(weeklyProgram))
 10968 3e20 2187      		std Z+9,r18
 10969               	.LVL926:
 10970 3e22 8901      		movw r16,r18
 10971 3e24 00C0      		rjmp .L753
 10972               	.LVL927:
 10973               	.L743:
 10974               	.LBE24:
1373:switcherator.c ****             if (overflowProgram == 255) {
 10975               		.loc 1 1373 0
 10976 3e26 8C01      		movw r16,r24
 10977               	.LVL928:
 10978 3e28 00C0      		rjmp .L753
 10979               	.LVL929:
 10980               	.L736:
1405:switcherator.c ****     weeklyProgram[programNumber][blankSwitch] = switchNumber;
 10981               		.loc 1 1405 0 discriminator 1
 10982 3e2a 2AE0      		ldi r18,lo8(10)
 10983 3e2c 209F      		mul r18,r16
 10984 3e2e F001      		movw r30,r0
 10985 3e30 219F      		mul r18,r17
 10986 3e32 F00D      		add r31,r0
 10987 3e34 1124      		clr __zero_reg__
 10988 3e36 E80F      		add r30,r24
 10989 3e38 F91F      		adc r31,r25
 10990 3e3a E050      		subi r30,lo8(-(weeklyProgram))
 10991 3e3c F040      		sbci r31,hi8(-(weeklyProgram))
 10992 3e3e C082      		st Z,r12
1406:switcherator.c ****     ok();
 10993               		.loc 1 1406 0 discriminator 1
 10994 3e40 0E94 0000 		call ok
 10995               	.LVL930:
 10996               	.L727:
 10997               	/* epilogue start */
1407:switcherator.c **** }
 10998               		.loc 1 1407 0
 10999 3e44 6096      		adiw r28,16
 11000 3e46 0FB6      		in __tmp_reg__,__SREG__
 11001 3e48 F894      		cli
 11002 3e4a DEBF      		out __SP_H__,r29
 11003 3e4c 0FBE      		out __SREG__,__tmp_reg__
 11004 3e4e CDBF      		out __SP_L__,r28
 11005 3e50 DF91      		pop r29
 11006 3e52 CF91      		pop r28
 11007 3e54 1F91      		pop r17
 11008 3e56 0F91      		pop r16
 11009               	.LVL931:
 11010 3e58 FF90      		pop r15
 11011 3e5a EF90      		pop r14
 11012               	.LVL932:
 11013 3e5c DF90      		pop r13
 11014 3e5e CF90      		pop r12
 11015               	.LVL933:
 11016 3e60 0895      		ret
 11017               	.LFE34:
 11019               	.global	clearProgram
 11021               	clearProgram:
 11022               	.LFB32:
1293:switcherator.c **** void clearProgram(char * commandReceived) {
 11023               		.loc 1 1293 0
 11024               	.LVL934:
 11025 3e62 0F93      		push r16
 11026               	.LCFI282:
 11027 3e64 1F93      		push r17
 11028               	.LCFI283:
 11029 3e66 CF93      		push r28
 11030               	.LCFI284:
 11031 3e68 DF93      		push r29
 11032               	.LCFI285:
 11033               	/* prologue: function */
 11034               	/* frame size = 0 */
 11035               	/* stack size = 4 */
 11036               	.L__stack_usage = 4
 11037 3e6a 8C01      		movw r16,r24
1294:switcherator.c ****     int programNumber = getSwitchNumber(commandReceived);
 11038               		.loc 1 1294 0
 11039 3e6c 0E94 0000 		call getSwitchNumber
 11040               	.LVL935:
 11041 3e70 EC01      		movw r28,r24
 11042               	.LVL936:
1295:switcherator.c ****     if (programNumber >= MAX_PROGRAM || (programNumber == 0 && commandReceived[4] != '0')) {
 11043               		.loc 1 1295 0
 11044 3e72 8431      		cpi r24,20
 11045 3e74 9105      		cpc r25,__zero_reg__
 11046 3e76 04F4      		brge .L756
1295:switcherator.c ****     if (programNumber >= MAX_PROGRAM || (programNumber == 0 && commandReceived[4] != '0')) {
 11047               		.loc 1 1295 0 is_stmt 0 discriminator 1
 11048 3e78 0097      		sbiw r24,0
 11049 3e7a 01F4      		brne .L757
 11050 3e7c F801      		movw r30,r16
 11051 3e7e 8481      		ldd r24,Z+4
 11052               	.LVL937:
 11053 3e80 8033      		cpi r24,lo8(48)
 11054 3e82 01F0      		breq .L757
 11055               	.L756:
1296:switcherator.c ****         fail(2);
 11056               		.loc 1 1296 0 is_stmt 1
 11057 3e84 82E0      		ldi r24,lo8(2)
 11058 3e86 90E0      		ldi r25,0
 11059               	/* epilogue start */
1302:switcherator.c **** }
 11060               		.loc 1 1302 0
 11061 3e88 DF91      		pop r29
 11062 3e8a CF91      		pop r28
 11063               	.LVL938:
 11064 3e8c 1F91      		pop r17
 11065 3e8e 0F91      		pop r16
 11066               	.LVL939:
1296:switcherator.c ****         fail(2);
 11067               		.loc 1 1296 0
 11068 3e90 0C94 0000 		jmp fail
 11069               	.LVL940:
 11070               	.L757:
1298:switcherator.c ****         itoa(programNumber, tempIntString, 10);
 11071               		.loc 1 1298 0
 11072 3e94 4AE0      		ldi r20,lo8(10)
 11073 3e96 50E0      		ldi r21,0
 11074 3e98 60E0      		ldi r22,lo8(tempIntString)
 11075 3e9a 70E0      		ldi r23,hi8(tempIntString)
 11076 3e9c CE01      		movw r24,r28
 11077 3e9e 0E94 0000 		call itoa
 11078               	.LVL941:
1299:switcherator.c ****         ok();
 11079               		.loc 1 1299 0
 11080 3ea2 0E94 0000 		call ok
 11081               	.LVL942:
1300:switcherator.c ****         clearTheProgram(programNumber);
 11082               		.loc 1 1300 0
 11083 3ea6 CE01      		movw r24,r28
 11084               	/* epilogue start */
1302:switcherator.c **** }
 11085               		.loc 1 1302 0
 11086 3ea8 DF91      		pop r29
 11087 3eaa CF91      		pop r28
 11088               	.LVL943:
 11089 3eac 1F91      		pop r17
 11090 3eae 0F91      		pop r16
 11091               	.LVL944:
1300:switcherator.c ****         clearTheProgram(programNumber);
 11092               		.loc 1 1300 0
 11093 3eb0 0C94 0000 		jmp clearTheProgram
 11094               	.LVL945:
 11095               	.LFE32:
 11097               	.global	setImmediateChange
 11099               	setImmediateChange:
 11100               	.LFB29:
1156:switcherator.c **** void setImmediateChange(char * commandReceived) {
 11101               		.loc 1 1156 0
 11102               	.LVL946:
 11103 3eb4 FF92      		push r15
 11104               	.LCFI286:
 11105 3eb6 0F93      		push r16
 11106               	.LCFI287:
 11107 3eb8 1F93      		push r17
 11108               	.LCFI288:
 11109 3eba CF93      		push r28
 11110               	.LCFI289:
 11111 3ebc DF93      		push r29
 11112               	.LCFI290:
 11113               	/* prologue: function */
 11114               	/* frame size = 0 */
 11115               	/* stack size = 5 */
 11116               	.L__stack_usage = 5
 11117 3ebe EC01      		movw r28,r24
1157:switcherator.c ****     tempLongString[3] = 0;
 11118               		.loc 1 1157 0
 11119 3ec0 1092 0000 		sts tempLongString+3,__zero_reg__
1158:switcherator.c ****     tempLongString[0] = commandReceived[3];
 11120               		.loc 1 1158 0
 11121 3ec4 8B81      		ldd r24,Y+3
 11122               	.LVL947:
 11123 3ec6 8093 0000 		sts tempLongString,r24
1159:switcherator.c ****     tempLongString[1] = commandReceived[4];
 11124               		.loc 1 1159 0
 11125 3eca 8C81      		ldd r24,Y+4
 11126 3ecc 8093 0000 		sts tempLongString+1,r24
1160:switcherator.c ****     tempLongString[2] = commandReceived[5];
 11127               		.loc 1 1160 0
 11128 3ed0 8D81      		ldd r24,Y+5
 11129 3ed2 8093 0000 		sts tempLongString+2,r24
1161:switcherator.c ****     pwmChangeValues[0] = atoi(tempLongString);
 11130               		.loc 1 1161 0
 11131 3ed6 80E0      		ldi r24,lo8(tempLongString)
 11132 3ed8 90E0      		ldi r25,hi8(tempLongString)
 11133 3eda 0E94 0000 		call atoi
 11134               	.LVL948:
 11135 3ede F82E      		mov r15,r24
 11136 3ee0 8093 0000 		sts pwmChangeValues,r24
1162:switcherator.c ****     tempLongString[0] = commandReceived[7];
 11137               		.loc 1 1162 0
 11138 3ee4 8F81      		ldd r24,Y+7
 11139 3ee6 8093 0000 		sts tempLongString,r24
1163:switcherator.c ****     tempLongString[1] = commandReceived[8];
 11140               		.loc 1 1163 0
 11141 3eea 8885      		ldd r24,Y+8
 11142 3eec 8093 0000 		sts tempLongString+1,r24
1164:switcherator.c ****     tempLongString[2] = commandReceived[9];
 11143               		.loc 1 1164 0
 11144 3ef0 8985      		ldd r24,Y+9
 11145 3ef2 8093 0000 		sts tempLongString+2,r24
1165:switcherator.c ****     pwmChangeValues[1] = atoi(tempLongString);
 11146               		.loc 1 1165 0
 11147 3ef6 80E0      		ldi r24,lo8(tempLongString)
 11148 3ef8 90E0      		ldi r25,hi8(tempLongString)
 11149 3efa 0E94 0000 		call atoi
 11150               	.LVL949:
 11151 3efe 182F      		mov r17,r24
 11152 3f00 8093 0000 		sts pwmChangeValues+1,r24
1166:switcherator.c ****     tempLongString[0] = commandReceived[11];
 11153               		.loc 1 1166 0
 11154 3f04 8B85      		ldd r24,Y+11
 11155 3f06 8093 0000 		sts tempLongString,r24
1167:switcherator.c ****     tempLongString[1] = commandReceived[12];
 11156               		.loc 1 1167 0
 11157 3f0a 8C85      		ldd r24,Y+12
 11158 3f0c 8093 0000 		sts tempLongString+1,r24
1168:switcherator.c ****     tempLongString[2] = commandReceived[13];
 11159               		.loc 1 1168 0
 11160 3f10 8D85      		ldd r24,Y+13
 11161 3f12 8093 0000 		sts tempLongString+2,r24
1169:switcherator.c ****     pwmChangeValues[2] = atoi(tempLongString);
 11162               		.loc 1 1169 0
 11163 3f16 80E0      		ldi r24,lo8(tempLongString)
 11164 3f18 90E0      		ldi r25,hi8(tempLongString)
 11165 3f1a 0E94 0000 		call atoi
 11166               	.LVL950:
 11167 3f1e 8093 0000 		sts pwmChangeValues+2,r24
1170:switcherator.c ****     if(pwmChangeValues[0] == 0 && pwmChangeValues[1] == 0 &&
 11168               		.loc 1 1170 0
 11169 3f22 F110      		cpse r15,__zero_reg__
 11170 3f24 00C0      		rjmp .L762
1170:switcherator.c ****     if(pwmChangeValues[0] == 0 && pwmChangeValues[1] == 0 &&
 11171               		.loc 1 1170 0 is_stmt 0 discriminator 1
 11172 3f26 1111      		cpse r17,__zero_reg__
 11173 3f28 00C0      		rjmp .L762
 11174 3f2a 8111      		cpse r24,__zero_reg__
 11175 3f2c 00C0      		rjmp .L762
1172:switcherator.c ****         fail(0x13);
 11176               		.loc 1 1172 0 is_stmt 1
 11177 3f2e 83E1      		ldi r24,lo8(19)
 11178 3f30 90E0      		ldi r25,0
 11179 3f32 00C0      		rjmp .L765
 11180               	.L762:
1175:switcherator.c ****      if(pwmIsSet == 1) {
 11181               		.loc 1 1175 0
 11182 3f34 8091 0000 		lds r24,pwmIsSet
 11183 3f38 8130      		cpi r24,lo8(1)
 11184 3f3a 01F0      		breq .+2
 11185 3f3c 00C0      		rjmp .L763
1176:switcherator.c ****         immediateChange = (weeklySeconds + 5);
 11186               		.loc 1 1176 0
 11187 3f3e 4091 0000 		lds r20,weeklySeconds
 11188 3f42 5091 0000 		lds r21,weeklySeconds+1
 11189 3f46 6091 0000 		lds r22,weeklySeconds+2
 11190 3f4a 7091 0000 		lds r23,weeklySeconds+3
 11191 3f4e 4B5F      		subi r20,-5
 11192 3f50 5F4F      		sbci r21,-1
 11193 3f52 6F4F      		sbci r22,-1
 11194 3f54 7F4F      		sbci r23,-1
 11195 3f56 4093 0000 		sts immediateChange,r20
 11196 3f5a 5093 0000 		sts immediateChange+1,r21
 11197 3f5e 6093 0000 		sts immediateChange+2,r22
 11198 3f62 7093 0000 		sts immediateChange+3,r23
1177:switcherator.c ****         if(switchStatus[pwmSwitchNumber] < immediateChange)
 11199               		.loc 1 1177 0
 11200 3f66 E091 0000 		lds r30,pwmSwitchNumber
 11201 3f6a F091 0000 		lds r31,pwmSwitchNumber+1
 11202 3f6e EE0F      		lsl r30
 11203 3f70 FF1F      		rol r31
 11204 3f72 EE0F      		lsl r30
 11205 3f74 FF1F      		rol r31
 11206 3f76 E050      		subi r30,lo8(-(switchStatus))
 11207 3f78 F040      		sbci r31,hi8(-(switchStatus))
 11208 3f7a 0081      		ld r16,Z
 11209 3f7c 1181      		ldd r17,Z+1
 11210 3f7e 2281      		ldd r18,Z+2
 11211 3f80 3381      		ldd r19,Z+3
 11212 3f82 0417      		cp r16,r20
 11213 3f84 1507      		cpc r17,r21
 11214 3f86 2607      		cpc r18,r22
 11215 3f88 3707      		cpc r19,r23
 11216 3f8a 00F4      		brsh .L764
1178:switcherator.c ****             switchStatus[pwmSwitchNumber] = immediateChange;
 11217               		.loc 1 1178 0
 11218 3f8c 4083      		st Z,r20
 11219 3f8e 5183      		std Z+1,r21
 11220 3f90 6283      		std Z+2,r22
 11221 3f92 7383      		std Z+3,r23
 11222               	.L764:
1179:switcherator.c ****         pwmOldValues[0] = Red;
 11223               		.loc 1 1179 0
 11224 3f94 8091 B400 		lds r24,180
 11225 3f98 8093 0000 		sts pwmOldValues,r24
1180:switcherator.c ****         pwmOldValues[1] = Green;
 11226               		.loc 1 1180 0
 11227 3f9c 88B5      		in r24,0x28
 11228 3f9e 8093 0000 		sts pwmOldValues+1,r24
1181:switcherator.c ****         pwmOldValues[2] = Blue;
 11229               		.loc 1 1181 0
 11230 3fa2 87B5      		in r24,0x27
 11231 3fa4 8093 0000 		sts pwmOldValues+2,r24
1182:switcherator.c ****         Red = pwmChangeValues[0];
 11232               		.loc 1 1182 0
 11233 3fa8 F092 B400 		sts 180,r15
1183:switcherator.c ****         Green = pwmChangeValues[1];
 11234               		.loc 1 1183 0
 11235 3fac 8091 0000 		lds r24,pwmChangeValues+1
 11236 3fb0 88BD      		out 0x28,r24
1184:switcherator.c ****         Blue = pwmChangeValues[2];
 11237               		.loc 1 1184 0
 11238 3fb2 8091 0000 		lds r24,pwmChangeValues+2
 11239 3fb6 87BD      		out 0x27,r24
 11240               	/* epilogue start */
1190:switcherator.c **** }
 11241               		.loc 1 1190 0
 11242 3fb8 DF91      		pop r29
 11243 3fba CF91      		pop r28
 11244               	.LVL951:
 11245 3fbc 1F91      		pop r17
 11246 3fbe 0F91      		pop r16
 11247 3fc0 FF90      		pop r15
1185:switcherator.c ****         ok();
 11248               		.loc 1 1185 0
 11249 3fc2 0C94 0000 		jmp ok
 11250               	.LVL952:
 11251               	.L763:
1187:switcherator.c ****         fail(0x14);
 11252               		.loc 1 1187 0
 11253 3fc6 84E1      		ldi r24,lo8(20)
 11254 3fc8 90E0      		ldi r25,0
 11255               	.L765:
 11256               	/* epilogue start */
1190:switcherator.c **** }
 11257               		.loc 1 1190 0
 11258 3fca DF91      		pop r29
 11259 3fcc CF91      		pop r28
 11260               	.LVL953:
 11261 3fce 1F91      		pop r17
 11262 3fd0 0F91      		pop r16
 11263 3fd2 FF90      		pop r15
1187:switcherator.c ****         fail(0x14);
 11264               		.loc 1 1187 0
 11265 3fd4 0C94 0000 		jmp fail
 11266               	.LVL954:
 11267               	.LFE29:
 11269               	.global	colorChangeSet
 11271               	colorChangeSet:
 11272               	.LFB24:
 943:switcherator.c **** void colorChangeSet(char * commandReceived) {
 11273               		.loc 1 943 0
 11274               	.LVL955:
 11275 3fd8 EF92      		push r14
 11276               	.LCFI291:
 11277 3fda FF92      		push r15
 11278               	.LCFI292:
 11279 3fdc 0F93      		push r16
 11280               	.LCFI293:
 11281 3fde 1F93      		push r17
 11282               	.LCFI294:
 11283 3fe0 CF93      		push r28
 11284               	.LCFI295:
 11285 3fe2 DF93      		push r29
 11286               	.LCFI296:
 11287               	/* prologue: function */
 11288               	/* frame size = 0 */
 11289               	/* stack size = 6 */
 11290               	.L__stack_usage = 6
 11291 3fe4 EC01      		movw r28,r24
 944:switcherator.c ****     int programNumber = getSwitchNumber(commandReceived);
 11292               		.loc 1 944 0
 11293 3fe6 0E94 0000 		call getSwitchNumber
 11294               	.LVL956:
 11295 3fea 7C01      		movw r14,r24
 11296               	.LVL957:
 945:switcherator.c ****     if (programNumber >= NUM_COLOR_CHANGES) {
 11297               		.loc 1 945 0
 11298 3fec 86E0      		ldi r24,6
 11299 3fee E816      		cp r14,r24
 11300 3ff0 F104      		cpc r15,__zero_reg__
 11301 3ff2 04F0      		brlt .L767
 946:switcherator.c ****         fail(7);
 11302               		.loc 1 946 0
 11303 3ff4 87E0      		ldi r24,lo8(7)
 11304 3ff6 90E0      		ldi r25,0
 11305               	/* epilogue start */
 963:switcherator.c **** }
 11306               		.loc 1 963 0
 11307 3ff8 DF91      		pop r29
 11308 3ffa CF91      		pop r28
 11309               	.LVL958:
 11310 3ffc 1F91      		pop r17
 11311 3ffe 0F91      		pop r16
 11312 4000 FF90      		pop r15
 11313 4002 EF90      		pop r14
 11314               	.LVL959:
 946:switcherator.c ****         fail(7);
 11315               		.loc 1 946 0
 11316 4004 0C94 0000 		jmp fail
 11317               	.LVL960:
 11318               	.L767:
 949:switcherator.c ****     tempLongString[3] = 0;
 11319               		.loc 1 949 0
 11320 4008 1092 0000 		sts tempLongString+3,__zero_reg__
 950:switcherator.c ****     tempLongString[0] = commandReceived[6];
 11321               		.loc 1 950 0
 11322 400c 8E81      		ldd r24,Y+6
 11323 400e 8093 0000 		sts tempLongString,r24
 951:switcherator.c ****     tempLongString[1] = commandReceived[7];
 11324               		.loc 1 951 0
 11325 4012 8F81      		ldd r24,Y+7
 11326 4014 8093 0000 		sts tempLongString+1,r24
 952:switcherator.c ****     tempLongString[2] = commandReceived[8];
 11327               		.loc 1 952 0
 11328 4018 8885      		ldd r24,Y+8
 11329 401a 8093 0000 		sts tempLongString+2,r24
 953:switcherator.c ****     colorChanges[programNumber][0] = atoi(tempLongString);
 11330               		.loc 1 953 0
 11331 401e 80E0      		ldi r24,lo8(tempLongString)
 11332 4020 90E0      		ldi r25,hi8(tempLongString)
 11333 4022 0E94 0000 		call atoi
 11334               	.LVL961:
 11335 4026 8701      		movw r16,r14
 11336 4028 000F      		lsl r16
 11337 402a 111F      		rol r17
 11338 402c 0E0D      		add r16,r14
 11339 402e 1F1D      		adc r17,r15
 11340 4030 0050      		subi r16,lo8(-(colorChanges))
 11341 4032 1040      		sbci r17,hi8(-(colorChanges))
 11342 4034 F801      		movw r30,r16
 11343 4036 8083      		st Z,r24
 954:switcherator.c ****     tempLongString[0] = commandReceived[10];
 11344               		.loc 1 954 0
 11345 4038 8A85      		ldd r24,Y+10
 11346 403a 8093 0000 		sts tempLongString,r24
 955:switcherator.c ****     tempLongString[1] = commandReceived[11];
 11347               		.loc 1 955 0
 11348 403e 8B85      		ldd r24,Y+11
 11349 4040 8093 0000 		sts tempLongString+1,r24
 956:switcherator.c ****     tempLongString[2] = commandReceived[12];
 11350               		.loc 1 956 0
 11351 4044 8C85      		ldd r24,Y+12
 11352 4046 8093 0000 		sts tempLongString+2,r24
 957:switcherator.c ****     colorChanges[programNumber][1] = atoi(tempLongString);
 11353               		.loc 1 957 0
 11354 404a 80E0      		ldi r24,lo8(tempLongString)
 11355 404c 90E0      		ldi r25,hi8(tempLongString)
 11356 404e 0E94 0000 		call atoi
 11357               	.LVL962:
 11358 4052 F801      		movw r30,r16
 11359 4054 8183      		std Z+1,r24
 958:switcherator.c ****     tempLongString[0] = commandReceived[14];
 11360               		.loc 1 958 0
 11361 4056 8E85      		ldd r24,Y+14
 11362 4058 8093 0000 		sts tempLongString,r24
 959:switcherator.c ****     tempLongString[1] = commandReceived[15];
 11363               		.loc 1 959 0
 11364 405c 8F85      		ldd r24,Y+15
 11365 405e 8093 0000 		sts tempLongString+1,r24
 960:switcherator.c ****     tempLongString[2] = commandReceived[16];
 11366               		.loc 1 960 0
 11367 4062 8889      		ldd r24,Y+16
 11368 4064 8093 0000 		sts tempLongString+2,r24
 961:switcherator.c ****     colorChanges[programNumber][2] = atoi(tempLongString);
 11369               		.loc 1 961 0
 11370 4068 80E0      		ldi r24,lo8(tempLongString)
 11371 406a 90E0      		ldi r25,hi8(tempLongString)
 11372 406c 0E94 0000 		call atoi
 11373               	.LVL963:
 11374 4070 F801      		movw r30,r16
 11375 4072 8283      		std Z+2,r24
 11376               	/* epilogue start */
 963:switcherator.c **** }
 11377               		.loc 1 963 0
 11378 4074 DF91      		pop r29
 11379 4076 CF91      		pop r28
 11380               	.LVL964:
 11381 4078 1F91      		pop r17
 11382 407a 0F91      		pop r16
 11383 407c FF90      		pop r15
 11384 407e EF90      		pop r14
 11385               	.LVL965:
 962:switcherator.c ****     ok();
 11386               		.loc 1 962 0
 11387 4080 0C94 0000 		jmp ok
 11388               	.LVL966:
 11389               	.LFE24:
 11391               	.global	pwmSetup
 11393               	pwmSetup:
 11394               	.LFB19:
 816:switcherator.c **** void pwmSetup(char * commandReceived) {
 11395               		.loc 1 816 0
 11396               	.LVL967:
 11397 4084 0F93      		push r16
 11398               	.LCFI297:
 11399 4086 1F93      		push r17
 11400               	.LCFI298:
 11401 4088 CF93      		push r28
 11402               	.LCFI299:
 11403 408a DF93      		push r29
 11404               	.LCFI300:
 11405               	/* prologue: function */
 11406               	/* frame size = 0 */
 11407               	/* stack size = 4 */
 11408               	.L__stack_usage = 4
 11409 408c EC01      		movw r28,r24
 11410               	.LVL968:
 11411 408e E0E0      		ldi r30,lo8(switchStuff)
 11412 4090 F0E0      		ldi r31,hi8(switchStuff)
 11413               	.LVL969:
 11414               	.L771:
 819:switcherator.c ****         if (switchStuff[x] == 70 || switchStuff[x] == 71 || switchStuff[x] == 74 ||
 11415               		.loc 1 819 0
 11416 4092 8191      		ld r24,Z+
 11417 4094 982F      		mov r25,r24
 11418 4096 9654      		subi r25,lo8(-(-70))
 11419 4098 9230      		cpi r25,lo8(2)
 11420 409a 00F0      		brlo .L769
 819:switcherator.c ****         if (switchStuff[x] == 70 || switchStuff[x] == 71 || switchStuff[x] == 74 ||
 11421               		.loc 1 819 0 is_stmt 0 discriminator 1
 11422 409c 8A34      		cpi r24,lo8(74)
 11423 409e 01F0      		breq .L769
 11424 40a0 8B34      		cpi r24,lo8(75)
 11425 40a2 01F0      		breq .L769
 820:switcherator.c ****                 switchStuff[x] == 75 || switchStuff[x] == 76 || switchStuff[x] == 77) {
 11426               		.loc 1 820 0 is_stmt 1
 11427 40a4 8C34      		cpi r24,lo8(76)
 11428 40a6 01F0      		breq .L769
 820:switcherator.c ****                 switchStuff[x] == 75 || switchStuff[x] == 76 || switchStuff[x] == 77) {
 11429               		.loc 1 820 0 is_stmt 0 discriminator 1
 11430 40a8 8D34      		cpi r24,lo8(77)
 11431 40aa 01F4      		brne .L770
 11432               	.L769:
 821:switcherator.c ****             fail(6);
 11433               		.loc 1 821 0 is_stmt 1
 11434 40ac 86E0      		ldi r24,lo8(6)
 11435 40ae 90E0      		ldi r25,0
 11436               	/* epilogue start */
 863:switcherator.c **** }
 11437               		.loc 1 863 0
 11438 40b0 DF91      		pop r29
 11439 40b2 CF91      		pop r28
 11440               	.LVL970:
 11441 40b4 1F91      		pop r17
 11442 40b6 0F91      		pop r16
 821:switcherator.c ****             fail(6);
 11443               		.loc 1 821 0
 11444 40b8 0C94 0000 		jmp fail
 11445               	.LVL971:
 11446               	.L770:
 818:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 11447               		.loc 1 818 0
 11448 40bc 80E0      		ldi r24,hi8(switchStuff+16)
 11449 40be E030      		cpi r30,lo8(switchStuff+16)
 11450 40c0 F807      		cpc r31,r24
 11451 40c2 01F4      		brne .L771
 11452               	.LVL972:
 827:switcherator.c ****     tempIntString[0] = commandReceived[5];
 11453               		.loc 1 827 0
 11454 40c4 8D81      		ldd r24,Y+5
 11455 40c6 8093 0000 		sts tempIntString,r24
 828:switcherator.c ****     tempIntString[1] = commandReceived[6];
 11456               		.loc 1 828 0
 11457 40ca 8E81      		ldd r24,Y+6
 11458 40cc 8093 0000 		sts tempIntString+1,r24
 829:switcherator.c ****     switchNumber = atoi(tempIntString);
 11459               		.loc 1 829 0
 11460 40d0 80E0      		ldi r24,lo8(tempIntString)
 11461 40d2 90E0      		ldi r25,hi8(tempIntString)
 11462 40d4 0E94 0000 		call atoi
 11463               	.LVL973:
 11464 40d8 8C01      		movw r16,r24
 11465               	.LVL974:
 830:switcherator.c ****     clearTheSwitch(switchNumber);
 11466               		.loc 1 830 0
 11467 40da 0E94 0000 		call clearTheSwitch
 11468               	.LVL975:
 832:switcherator.c ****     if (commandReceived[8] == 'H' || commandReceived[8] == 'h' || commandReceived[8] == '1') {
 11469               		.loc 1 832 0
 11470 40de 8885      		ldd r24,Y+8
 11471 40e0 8834      		cpi r24,lo8(72)
 11472 40e2 01F0      		breq .L772
 832:switcherator.c ****     if (commandReceived[8] == 'H' || commandReceived[8] == 'h' || commandReceived[8] == '1') {
 11473               		.loc 1 832 0 is_stmt 0 discriminator 1
 11474 40e4 8836      		cpi r24,lo8(104)
 11475 40e6 01F0      		breq .L772
 11476 40e8 8133      		cpi r24,lo8(49)
 11477 40ea 01F4      		brne .L773
 11478               	.L772:
 833:switcherator.c ****         switchStuff[switchNumber] = 201;
 11479               		.loc 1 833 0 is_stmt 1
 11480 40ec F801      		movw r30,r16
 11481 40ee E050      		subi r30,lo8(-(switchStuff))
 11482 40f0 F040      		sbci r31,hi8(-(switchStuff))
 11483 40f2 89EC      		ldi r24,lo8(-55)
 11484 40f4 00C0      		rjmp .L798
 11485               	.L773:
 11486 40f6 F801      		movw r30,r16
 11487 40f8 E050      		subi r30,lo8(-(switchStuff))
 11488 40fa F040      		sbci r31,hi8(-(switchStuff))
 834:switcherator.c ****     } else if (commandReceived[8] == 'C' || commandReceived[8] == 'c') {
 11489               		.loc 1 834 0
 11490 40fc 8334      		cpi r24,lo8(67)
 11491 40fe 01F0      		breq .L775
 834:switcherator.c ****     } else if (commandReceived[8] == 'C' || commandReceived[8] == 'c') {
 11492               		.loc 1 834 0 is_stmt 0 discriminator 1
 11493 4100 8336      		cpi r24,lo8(99)
 11494 4102 01F4      		brne .L776
 11495               	.L775:
 835:switcherator.c ****         switchStuff[switchNumber] = 202;
 11496               		.loc 1 835 0 is_stmt 1
 11497 4104 8AEC      		ldi r24,lo8(-54)
 11498 4106 00C0      		rjmp .L798
 11499               	.L776:
 837:switcherator.c ****         switchStuff[switchNumber] = 200;
 11500               		.loc 1 837 0
 11501 4108 88EC      		ldi r24,lo8(-56)
 11502               	.L798:
 11503 410a 8083      		st Z,r24
 839:switcherator.c ****     DDRD |= (1 << PIND3) | (1 << PIND5) | (1 << PIND6);
 11504               		.loc 1 839 0
 11505 410c 8AB1      		in r24,0xa
 11506 410e 8866      		ori r24,lo8(104)
 11507 4110 8AB9      		out 0xa,r24
 841:switcherator.c ****     Red = 0;
 11508               		.loc 1 841 0
 11509 4112 1092 B400 		sts 180,__zero_reg__
 842:switcherator.c ****     Green = 0;
 11510               		.loc 1 842 0
 11511 4116 18BC      		out 0x28,__zero_reg__
 843:switcherator.c ****     Blue = 0;
 11512               		.loc 1 843 0
 11513 4118 17BC      		out 0x27,__zero_reg__
 846:switcherator.c ****     if (commandReceived[7] == '0') {
 11514               		.loc 1 846 0
 11515 411a 8F81      		ldd r24,Y+7
 11516 411c 8033      		cpi r24,lo8(48)
 11517 411e 01F4      		brne .L777
 847:switcherator.c ****         pwmdir = 0;
 11518               		.loc 1 847 0
 11519 4120 1092 0000 		sts pwmdir,__zero_reg__
 848:switcherator.c ****         TCCR0A = (1 << COM0A0) | (1 << COM0A1) | (1 << COM0B0) | (1 << COM0B1) | (1 << WGM00);
 11520               		.loc 1 848 0
 11521 4124 81EF      		ldi r24,lo8(-15)
 11522 4126 84BD      		out 0x24,r24
 849:switcherator.c ****         TCCR2A = (1 << COM2B0) | (1 << COM2B1) | (1 << WGM20);
 11523               		.loc 1 849 0
 11524 4128 81E3      		ldi r24,lo8(49)
 11525 412a 00C0      		rjmp .L799
 11526               	.L777:
 851:switcherator.c ****         pwmdir = 1;
 11527               		.loc 1 851 0
 11528 412c 81E0      		ldi r24,lo8(1)
 11529 412e 8093 0000 		sts pwmdir,r24
 852:switcherator.c ****         TCCR0A = (1 << COM0A1) | (1 << COM0B1) | (1 << WGM00);
 11530               		.loc 1 852 0
 11531 4132 81EA      		ldi r24,lo8(-95)
 11532 4134 84BD      		out 0x24,r24
 853:switcherator.c ****         TCCR2A = (1 << COM2B1) | (1 << WGM20);
 11533               		.loc 1 853 0
 11534 4136 81E2      		ldi r24,lo8(33)
 11535               	.L799:
 11536 4138 8093 B000 		sts 176,r24
 856:switcherator.c ****     TCCR0B = (1 << CS01) | (1 << CS00);
 11537               		.loc 1 856 0
 11538 413c 83E0      		ldi r24,lo8(3)
 11539 413e 85BD      		out 0x25,r24
 858:switcherator.c ****     TCCR2B = (1 << CS22); // F_CPU/64
 11540               		.loc 1 858 0
 11541 4140 84E0      		ldi r24,lo8(4)
 11542 4142 8093 B100 		sts 177,r24
 859:switcherator.c ****     pwmIsSet = 1;
 11543               		.loc 1 859 0
 11544 4146 81E0      		ldi r24,lo8(1)
 11545 4148 8093 0000 		sts pwmIsSet,r24
 860:switcherator.c ****     pwmSwitchNumber = switchNumber;
 11546               		.loc 1 860 0
 11547 414c 1093 0000 		sts pwmSwitchNumber+1,r17
 11548 4150 0093 0000 		sts pwmSwitchNumber,r16
 11549               	/* epilogue start */
 863:switcherator.c **** }
 11550               		.loc 1 863 0
 11551 4154 DF91      		pop r29
 11552 4156 CF91      		pop r28
 11553               	.LVL976:
 11554 4158 1F91      		pop r17
 11555 415a 0F91      		pop r16
 11556               	.LVL977:
 862:switcherator.c ****     ok();
 11557               		.loc 1 862 0
 11558 415c 0C94 0000 		jmp ok
 11559               	.LVL978:
 11560               	.LFE19:
 11562               	.global	startSwitch
 11564               	startSwitch:
 11565               	.LFB16:
 630:switcherator.c **** void startSwitch(char * commandReceived) {
 11566               		.loc 1 630 0
 11567               	.LVL979:
 11568 4160 EF92      		push r14
 11569               	.LCFI301:
 11570 4162 FF92      		push r15
 11571               	.LCFI302:
 11572 4164 0F93      		push r16
 11573               	.LCFI303:
 11574 4166 1F93      		push r17
 11575               	.LCFI304:
 11576 4168 CF93      		push r28
 11577               	.LCFI305:
 11578 416a DF93      		push r29
 11579               	.LCFI306:
 11580 416c 00D0      		rcall .
 11581 416e 00D0      		rcall .
 11582               	.LCFI307:
 11583 4170 CDB7      		in r28,__SP_L__
 11584 4172 DEB7      		in r29,__SP_H__
 11585               	.LCFI308:
 11586               	/* prologue: function */
 11587               	/* frame size = 4 */
 11588               	/* stack size = 10 */
 11589               	.L__stack_usage = 10
 11590 4174 7C01      		movw r14,r24
 11591               	.LVL980:
 634:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 11592               		.loc 1 634 0
 11593 4176 0E94 0000 		call getSwitchNumber
 11594               	.LVL981:
 11595 417a 8C01      		movw r16,r24
 11596               	.LVL982:
 635:switcherator.c ****     if ((switchNumber >= NUM_SWITCHES) || (switchStuff[switchNumber] == 255)) {
 11597               		.loc 1 635 0
 11598 417c 8031      		cpi r24,16
 11599 417e 9105      		cpc r25,__zero_reg__
 11600 4180 04F4      		brge .L801
 635:switcherator.c ****     if ((switchNumber >= NUM_SWITCHES) || (switchStuff[switchNumber] == 255)) {
 11601               		.loc 1 635 0 is_stmt 0 discriminator 1
 11602 4182 FC01      		movw r30,r24
 11603 4184 E050      		subi r30,lo8(-(switchStuff))
 11604 4186 F040      		sbci r31,hi8(-(switchStuff))
 11605 4188 2081      		ld r18,Z
 11606 418a 2F3F      		cpi r18,lo8(-1)
 11607 418c 01F4      		brne .L802
 11608               	.L801:
 636:switcherator.c ****         fail(1);
 11609               		.loc 1 636 0 is_stmt 1
 11610 418e 81E0      		ldi r24,lo8(1)
 11611 4190 90E0      		ldi r25,0
 11612 4192 00C0      		rjmp .L818
 11613               	.L802:
 640:switcherator.c ****     tempHugeString[0] = commandReceived[5];
 11614               		.loc 1 640 0
 11615 4194 F701      		movw r30,r14
 11616 4196 8581      		ldd r24,Z+5
 11617 4198 8093 0000 		sts tempHugeString,r24
 641:switcherator.c ****     tempHugeString[1] = commandReceived[6];
 11618               		.loc 1 641 0
 11619 419c 8681      		ldd r24,Z+6
 11620 419e 8093 0000 		sts tempHugeString+1,r24
 642:switcherator.c ****     tempHugeString[2] = commandReceived[7];
 11621               		.loc 1 642 0
 11622 41a2 8781      		ldd r24,Z+7
 11623 41a4 8093 0000 		sts tempHugeString+2,r24
 643:switcherator.c ****     tempHugeString[3] = commandReceived[8];
 11624               		.loc 1 643 0
 11625 41a8 8085      		ldd r24,Z+8
 11626 41aa 8093 0000 		sts tempHugeString+3,r24
 644:switcherator.c ****     tempHugeString[4] = commandReceived[9];
 11627               		.loc 1 644 0
 11628 41ae 8185      		ldd r24,Z+9
 11629 41b0 8093 0000 		sts tempHugeString+4,r24
 645:switcherator.c ****     tempHugeString[5] = commandReceived[10];
 11630               		.loc 1 645 0
 11631 41b4 8285      		ldd r24,Z+10
 11632 41b6 8093 0000 		sts tempHugeString+5,r24
 646:switcherator.c ****     duration = atol(tempHugeString);
 11633               		.loc 1 646 0
 11634 41ba 80E0      		ldi r24,lo8(tempHugeString)
 11635 41bc 90E0      		ldi r25,hi8(tempHugeString)
 11636 41be 2C83      		std Y+4,r18
 11637 41c0 0E94 0000 		call atol
 11638               	.LVL983:
 11639 41c4 462F      		mov r20,r22
 11640 41c6 572F      		mov r21,r23
 11641 41c8 BC01      		movw r22,r24
 11642               	.LVL984:
 647:switcherator.c ****     if (duration == 0) {
 11643               		.loc 1 647 0
 11644 41ca 2C81      		ldd r18,Y+4
 11645 41cc 4115      		cp r20,__zero_reg__
 11646 41ce 5105      		cpc r21,__zero_reg__
 11647 41d0 6105      		cpc r22,__zero_reg__
 11648 41d2 7105      		cpc r23,__zero_reg__
 11649 41d4 01F4      		brne .L804
 648:switcherator.c ****         fail(5);
 11650               		.loc 1 648 0
 11651 41d6 85E0      		ldi r24,lo8(5)
 11652 41d8 90E0      		ldi r25,0
 11653               	.LVL985:
 11654               	.L818:
 11655 41da 0E94 0000 		call fail
 11656               	.LVL986:
 649:switcherator.c ****         return;
 11657               		.loc 1 649 0
 11658 41de 00C0      		rjmp .L800
 11659               	.LVL987:
 11660               	.L804:
 652:switcherator.c ****     if ((weeklySeconds + duration) > switchStatus[switchNumber])
 11661               		.loc 1 652 0
 11662 41e0 8091 0000 		lds r24,weeklySeconds
 11663 41e4 9091 0000 		lds r25,weeklySeconds+1
 11664 41e8 A091 0000 		lds r26,weeklySeconds+2
 11665 41ec B091 0000 		lds r27,weeklySeconds+3
 11666 41f0 840F      		add r24,r20
 11667 41f2 951F      		adc r25,r21
 11668 41f4 A61F      		adc r26,r22
 11669 41f6 B71F      		adc r27,r23
 11670 41f8 F801      		movw r30,r16
 11671 41fa EE0F      		lsl r30
 11672 41fc FF1F      		rol r31
 11673 41fe EE0F      		lsl r30
 11674 4200 FF1F      		rol r31
 11675               	.LVL988:
 11676 4202 E050      		subi r30,lo8(-(switchStatus))
 11677 4204 F040      		sbci r31,hi8(-(switchStatus))
 11678 4206 4081      		ld r20,Z
 11679 4208 5181      		ldd r21,Z+1
 11680 420a 6281      		ldd r22,Z+2
 11681 420c 7381      		ldd r23,Z+3
 11682 420e 4817      		cp r20,r24
 11683 4210 5907      		cpc r21,r25
 11684 4212 6A07      		cpc r22,r26
 11685 4214 7B07      		cpc r23,r27
 11686 4216 00F4      		brsh .L805
 653:switcherator.c ****         switchStatus[switchNumber] = (weeklySeconds + duration);
 11687               		.loc 1 653 0
 11688 4218 8083      		st Z,r24
 11689 421a 9183      		std Z+1,r25
 11690 421c A283      		std Z+2,r26
 11691 421e B383      		std Z+3,r27
 11692               	.L805:
 656:switcherator.c ****     if (switchStuff[switchNumber] >= 200 && switchStuff[switchNumber] <= 220
 11693               		.loc 1 656 0
 11694 4220 822F      		mov r24,r18
 11695 4222 885C      		subi r24,lo8(-(56))
 11696 4224 8531      		cpi r24,lo8(21)
 11697 4226 00F0      		brlo .+2
 11698 4228 00C0      		rjmp .L806
 657:switcherator.c ****             && immediateChange == 0) {
 11699               		.loc 1 657 0
 11700 422a 8091 0000 		lds r24,immediateChange
 11701 422e 9091 0000 		lds r25,immediateChange+1
 11702 4232 A091 0000 		lds r26,immediateChange+2
 11703 4236 B091 0000 		lds r27,immediateChange+3
 11704 423a 892B      		or r24,r25
 11705 423c 8A2B      		or r24,r26
 11706 423e 8B2B      		or r24,r27
 11707 4240 01F0      		breq .+2
 11708 4242 00C0      		rjmp .L806
 659:switcherator.c ****         if (switchStuff[switchNumber] == 200) {
 11709               		.loc 1 659 0
 11710 4244 283C      		cpi r18,lo8(-56)
 11711 4246 01F4      		brne .L807
 662:switcherator.c ****             green = pwmValues[1];
 11712               		.loc 1 662 0
 11713 4248 8091 0000 		lds r24,pwmValues+1
 663:switcherator.c ****             blue = pwmValues[2];
 11714               		.loc 1 663 0
 11715 424c E091 0000 		lds r30,pwmValues+2
 664:switcherator.c ****             red = red * bright / 16;
 11716               		.loc 1 664 0
 11717 4250 6091 0000 		lds r22,bright
 11718 4254 7091 0000 		lds r23,bright+1
 661:switcherator.c ****             red = pwmValues[0];
 11719               		.loc 1 661 0
 11720 4258 9091 0000 		lds r25,pwmValues
 664:switcherator.c ****             red = red * bright / 16;
 11721               		.loc 1 664 0
 11722 425c 969F      		mul r25,r22
 11723 425e A001      		movw r20,r0
 11724 4260 979F      		mul r25,r23
 11725 4262 500D      		add r21,r0
 11726 4264 1124      		clr __zero_reg__
 11727 4266 14E0      		ldi r17,4
 11728               		1:
 11729 4268 5695      		lsr r21
 11730 426a 4795      		ror r20
 11731 426c 1A95      		dec r17
 11732 426e 01F4      		brne 1b
 11733 4270 5093 0000 		sts red+1,r21
 11734 4274 4093 0000 		sts red,r20
 665:switcherator.c ****             green = green * bright / 16;
 11735               		.loc 1 665 0
 11736 4278 869F      		mul r24,r22
 11737 427a 9001      		movw r18,r0
 11738 427c 879F      		mul r24,r23
 11739 427e 300D      		add r19,r0
 11740 4280 1124      		clr __zero_reg__
 11741 4282 04E0      		ldi r16,4
 11742               		1:
 11743 4284 3695      		lsr r19
 11744 4286 2795      		ror r18
 11745 4288 0A95      		dec r16
 11746 428a 01F4      		brne 1b
 11747               	.LVL989:
 11748 428c 3093 0000 		sts green+1,r19
 11749 4290 2093 0000 		sts green,r18
 666:switcherator.c ****             blue = blue * bright / 16;
 11750               		.loc 1 666 0
 11751 4294 E69F      		mul r30,r22
 11752 4296 C001      		movw r24,r0
 11753 4298 E79F      		mul r30,r23
 11754 429a 900D      		add r25,r0
 11755 429c 1124      		clr __zero_reg__
 11756 429e 34E0      		ldi r19,4
 11757               		1:
 11758 42a0 9695      		lsr r25
 11759 42a2 8795      		ror r24
 11760 42a4 3A95      		dec r19
 11761 42a6 01F4      		brne 1b
 11762 42a8 9093 0000 		sts blue+1,r25
 11763 42ac 8093 0000 		sts blue,r24
 667:switcherator.c ****             Red = red;
 11764               		.loc 1 667 0
 11765 42b0 4093 B400 		sts 180,r20
 668:switcherator.c ****             Green = green;
 11766               		.loc 1 668 0
 11767 42b4 28BD      		out 0x28,r18
 669:switcherator.c ****             Blue = blue;
 11768               		.loc 1 669 0
 11769 42b6 87BD      		out 0x27,r24
 11770 42b8 00C0      		rjmp .L808
 11771               	.LVL990:
 11772               	.L807:
 670:switcherator.c ****         } else if (switchStuff[switchNumber] == 202) {
 11773               		.loc 1 670 0
 11774 42ba 2A3C      		cpi r18,lo8(-54)
 11775 42bc 01F4      		brne .L809
 671:switcherator.c ****             runColorChanges = 1;
 11776               		.loc 1 671 0
 11777 42be 81E0      		ldi r24,lo8(1)
 11778 42c0 8093 0000 		sts runColorChanges,r24
 11779 42c4 00C0      		rjmp .L808
 11780               	.L809:
 672:switcherator.c ****         } else if (switchStuff[switchNumber] == 212) {
 11781               		.loc 1 672 0
 11782 42c6 243D      		cpi r18,lo8(-44)
 11783 42c8 01F4      		brne .L810
 673:switcherator.c ****             bright = switchBright[switchNumber];
 11784               		.loc 1 673 0
 11785 42ca F801      		movw r30,r16
 11786 42cc E050      		subi r30,lo8(-(switchBright))
 11787 42ce F040      		sbci r31,hi8(-(switchBright))
 11788 42d0 8081      		ld r24,Z
 11789 42d2 8093 0000 		sts bright,r24
 11790 42d6 1092 0000 		sts bright+1,__zero_reg__
 11791 42da 00C0      		rjmp .L808
 11792               	.L810:
 675:switcherator.c ****             runHue = 1;
 11793               		.loc 1 675 0
 11794 42dc 81E0      		ldi r24,lo8(1)
 11795 42de 8093 0000 		sts runHue,r24
 11796 42e2 00C0      		rjmp .L808
 11797               	.L806:
 11798               	.LVL991:
 11799               	.LBB25:
 686:switcherator.c ****         getPort(switchNumber, port, pin, direction);
 11800               		.loc 1 686 0
 11801 42e4 9E01      		movw r18,r28
 11802 42e6 2F5F      		subi r18,-1
 11803 42e8 3F4F      		sbci r19,-1
 11804 42ea AE01      		movw r20,r28
 11805 42ec 4E5F      		subi r20,-2
 11806 42ee 5F4F      		sbci r21,-1
 11807 42f0 BE01      		movw r22,r28
 11808 42f2 6D5F      		subi r22,-3
 11809 42f4 7F4F      		sbci r23,-1
 11810 42f6 C801      		movw r24,r16
 11811 42f8 0E94 0000 		call getPort
 11812               	.LVL992:
 688:switcherator.c ****         realPin = pin[0];
 11813               		.loc 1 688 0
 11814 42fc 3A81      		ldd r19,Y+2
 11815               	.LVL993:
 689:switcherator.c ****         if (port[0] == 'B')
 11816               		.loc 1 689 0
 11817 42fe 8B81      		ldd r24,Y+3
 11818 4300 8234      		cpi r24,lo8(66)
 11819 4302 01F0      		breq .L814
 696:switcherator.c ****         else if (port[0] == 'C')
 11820               		.loc 1 696 0
 11821 4304 8334      		cpi r24,lo8(67)
 11822 4306 01F0      		breq .L815
 700:switcherator.c ****         else if (port[0] == 'D')
 11823               		.loc 1 700 0
 11824 4308 8434      		cpi r24,lo8(68)
 11825 430a 01F0      		breq .L816
 685:switcherator.c ****         volatile unsigned char *thisPort = 0;
 11826               		.loc 1 685 0
 11827 430c E0E0      		ldi r30,0
 11828 430e F0E0      		ldi r31,0
 11829 4310 00C0      		rjmp .L811
 11830               	.L814:
 690:switcherator.c ****             thisPort = &PORTB;
 11831               		.loc 1 690 0
 11832 4312 E5E2      		ldi r30,lo8(37)
 11833 4314 F0E0      		ldi r31,0
 11834 4316 00C0      		rjmp .L811
 11835               	.L815:
 697:switcherator.c ****             thisPort = &PORTC;
 11836               		.loc 1 697 0
 11837 4318 E8E2      		ldi r30,lo8(40)
 11838 431a F0E0      		ldi r31,0
 11839 431c 00C0      		rjmp .L811
 11840               	.L816:
 701:switcherator.c ****             thisPort = &PORTD;
 11841               		.loc 1 701 0
 11842 431e EBE2      		ldi r30,lo8(43)
 11843 4320 F0E0      		ldi r31,0
 11844               	.L811:
 11845               	.LVL994:
 725:switcherator.c ****         if (direction[0] == 0) {
 11846               		.loc 1 725 0
 11847 4322 8981      		ldd r24,Y+1
 726:switcherator.c ****             *thisPort &= ~(1 << realPin);
 11848               		.loc 1 726 0
 11849 4324 2081      		ld r18,Z
 725:switcherator.c ****         if (direction[0] == 0) {
 11850               		.loc 1 725 0
 11851 4326 8111      		cpse r24,__zero_reg__
 11852 4328 00C0      		rjmp .L812
 726:switcherator.c ****             *thisPort &= ~(1 << realPin);
 11853               		.loc 1 726 0
 11854 432a 81E0      		ldi r24,lo8(1)
 11855 432c 90E0      		ldi r25,0
 11856 432e 032E      		mov r0,r19
 11857 4330 00C0      		rjmp 2f
 11858               		1:
 11859 4332 880F      		lsl r24
 11860               		2:
 11861 4334 0A94      		dec r0
 11862 4336 02F4      		brpl 1b
 11863 4338 8095      		com r24
 11864 433a 2823      		and r18,r24
 11865 433c 00C0      		rjmp .L817
 11866               	.L812:
 728:switcherator.c ****             *thisPort |= (1 << realPin);
 11867               		.loc 1 728 0
 11868 433e 81E0      		ldi r24,lo8(1)
 11869 4340 90E0      		ldi r25,0
 11870 4342 00C0      		rjmp 2f
 11871               		1:
 11872 4344 880F      		lsl r24
 11873               		2:
 11874 4346 3A95      		dec r19
 11875 4348 02F4      		brpl 1b
 11876 434a 282B      		or r18,r24
 11877               	.L817:
 11878 434c 2083      		st Z,r18
 11879               	.LVL995:
 11880               	.L808:
 11881               	.LBE25:
 731:switcherator.c ****     ok();
 11882               		.loc 1 731 0
 11883 434e 0E94 0000 		call ok
 11884               	.LVL996:
 11885               	.L800:
 11886               	/* epilogue start */
 732:switcherator.c **** }
 11887               		.loc 1 732 0
 11888 4352 0F90      		pop __tmp_reg__
 11889 4354 0F90      		pop __tmp_reg__
 11890 4356 0F90      		pop __tmp_reg__
 11891 4358 0F90      		pop __tmp_reg__
 11892 435a DF91      		pop r29
 11893 435c CF91      		pop r28
 11894 435e 1F91      		pop r17
 11895 4360 0F91      		pop r16
 11896 4362 FF90      		pop r15
 11897 4364 EF90      		pop r14
 11898               	.LVL997:
 11899 4366 0895      		ret
 11900               	.LFE16:
 11902               	.global	setNewSwitch
 11904               	setNewSwitch:
 11905               	.LFB12:
 400:switcherator.c **** void setNewSwitch(char * commandReceived) {
 11906               		.loc 1 400 0
 11907               	.LVL998:
 11908 4368 AF92      		push r10
 11909               	.LCFI309:
 11910 436a BF92      		push r11
 11911               	.LCFI310:
 11912 436c CF92      		push r12
 11913               	.LCFI311:
 11914 436e DF92      		push r13
 11915               	.LCFI312:
 11916 4370 EF92      		push r14
 11917               	.LCFI313:
 11918 4372 FF92      		push r15
 11919               	.LCFI314:
 11920 4374 0F93      		push r16
 11921               	.LCFI315:
 11922 4376 1F93      		push r17
 11923               	.LCFI316:
 11924 4378 CF93      		push r28
 11925               	.LCFI317:
 11926 437a DF93      		push r29
 11927               	.LCFI318:
 11928 437c 1F92      		push __zero_reg__
 11929               	.LCFI319:
 11930 437e CDB7      		in r28,__SP_L__
 11931 4380 DEB7      		in r29,__SP_H__
 11932               	.LCFI320:
 11933               	/* prologue: function */
 11934               	/* frame size = 1 */
 11935               	/* stack size = 11 */
 11936               	.L__stack_usage = 11
 11937 4382 6C01      		movw r12,r24
 11938               	.LVL999:
 410:switcherator.c ****     tempIntString[0] = '0';
 11939               		.loc 1 410 0
 11940 4384 80E3      		ldi r24,lo8(48)
 11941               	.LVL1000:
 11942 4386 8093 0000 		sts tempIntString,r24
 411:switcherator.c ****     tempIntString[1] = commandReceived[6];
 11943               		.loc 1 411 0
 11944 438a D601      		movw r26,r12
 11945 438c 1696      		adiw r26,6
 11946 438e 8C91      		ld r24,X
 11947 4390 8093 0000 		sts tempIntString+1,r24
 412:switcherator.c ****     pin = atoi(tempIntString);
 11948               		.loc 1 412 0
 11949 4394 80E0      		ldi r24,lo8(tempIntString)
 11950 4396 90E0      		ldi r25,hi8(tempIntString)
 11951 4398 0E94 0000 		call atoi
 11952               	.LVL1001:
 11953 439c F82E      		mov r15,r24
 11954               	.LVL1002:
 414:switcherator.c ****     tempIntString[1] = commandReceived[7];
 11955               		.loc 1 414 0
 11956 439e F601      		movw r30,r12
 11957 43a0 8781      		ldd r24,Z+7
 11958 43a2 8093 0000 		sts tempIntString+1,r24
 415:switcherator.c ****     direction = atoi(tempIntString);
 11959               		.loc 1 415 0
 11960 43a6 80E0      		ldi r24,lo8(tempIntString)
 11961 43a8 90E0      		ldi r25,hi8(tempIntString)
 11962 43aa 0E94 0000 		call atoi
 11963               	.LVL1003:
 11964 43ae E82E      		mov r14,r24
 11965               	.LVL1004:
 416:switcherator.c ****     port = commandReceived[5];
 11966               		.loc 1 416 0
 11967 43b0 D601      		movw r26,r12
 11968 43b2 1596      		adiw r26,5
 11969 43b4 2C91      		ld r18,X
 11970               	.LVL1005:
 417:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 11971               		.loc 1 417 0
 11972 43b6 C601      		movw r24,r12
 11973 43b8 2983      		std Y+1,r18
 11974 43ba 0E94 0000 		call getSwitchNumber
 11975               	.LVL1006:
 11976 43be 8C01      		movw r16,r24
 11977               	.LVL1007:
 419:switcherator.c ****     clearTheSwitch(switchNumber);
 11978               		.loc 1 419 0
 11979 43c0 0E94 0000 		call clearTheSwitch
 11980               	.LVL1008:
 421:switcherator.c ****     if (port == 'B' || port == 'b') {
 11981               		.loc 1 421 0
 11982 43c4 2981      		ldd r18,Y+1
 11983 43c6 2234      		cpi r18,lo8(66)
 11984 43c8 01F4      		brne .+2
 11985 43ca 00C0      		rjmp .L830
 421:switcherator.c ****     if (port == 'B' || port == 'b') {
 11986               		.loc 1 421 0 is_stmt 0 discriminator 1
 11987 43cc 2236      		cpi r18,lo8(98)
 11988 43ce 01F4      		brne .+2
 11989 43d0 00C0      		rjmp .L830
 432:switcherator.c ****     } else if (port == 'C' || port == 'c') {
 11990               		.loc 1 432 0 is_stmt 1
 11991 43d2 2334      		cpi r18,lo8(67)
 11992 43d4 01F4      		brne .+2
 11993 43d6 00C0      		rjmp .L832
 432:switcherator.c ****     } else if (port == 'C' || port == 'c') {
 11994               		.loc 1 432 0 is_stmt 0 discriminator 1
 11995 43d8 2336      		cpi r18,lo8(99)
 11996 43da 01F4      		brne .+2
 11997 43dc 00C0      		rjmp .L832
 438:switcherator.c ****     } else if (port == 'D' || port == 'd') {
 11998               		.loc 1 438 0 is_stmt 1
 11999 43de 2434      		cpi r18,lo8(68)
 12000 43e0 01F4      		brne .+2
 12001 43e2 00C0      		rjmp .L834
 438:switcherator.c ****     } else if (port == 'D' || port == 'd') {
 12002               		.loc 1 438 0 is_stmt 0 discriminator 1
 12003 43e4 2436      		cpi r18,lo8(100)
 12004 43e6 01F0      		breq .+2
 12005 43e8 00C0      		rjmp .L844
 12006 43ea 00C0      		rjmp .L834
 12007               	.LVL1009:
 12008               	.L845:
 479:switcherator.c ****     } else if ((switchNumber >= NUM_SWITCHES) ||
 12009               		.loc 1 479 0 is_stmt 1 discriminator 1
 12010 43ec 0115      		cp r16,__zero_reg__
 12011 43ee 1105      		cpc r17,__zero_reg__
 12012 43f0 01F4      		brne .L822
 480:switcherator.c ****             ((switchNumber == 0) && (commandReceived[3] != '0') && (commandReceived[4] != 0))) {
 12013               		.loc 1 480 0
 12014 43f2 D601      		movw r26,r12
 12015 43f4 1396      		adiw r26,3
 12016 43f6 8C91      		ld r24,X
 12017 43f8 1397      		sbiw r26,3
 12018 43fa 8033      		cpi r24,lo8(48)
 12019 43fc 01F0      		breq .L822
 480:switcherator.c ****             ((switchNumber == 0) && (commandReceived[3] != '0') && (commandReceived[4] != 0))) {
 12020               		.loc 1 480 0 is_stmt 0 discriminator 1
 12021 43fe 1496      		adiw r26,4
 12022 4400 8C91      		ld r24,X
 12023 4402 8823      		tst r24
 12024 4404 01F0      		breq .L822
 12025               	.L827:
 481:switcherator.c ****         fail(1);
 12026               		.loc 1 481 0 is_stmt 1
 12027 4406 81E0      		ldi r24,lo8(1)
 12028 4408 90E0      		ldi r25,0
 12029 440a 00C0      		rjmp .L846
 12030               	.L822:
 412:switcherator.c ****     pin = atoi(tempIntString);
 12031               		.loc 1 412 0
 12032 440c 4F2D      		mov r20,r15
 482:switcherator.c ****     } else if ((pin > 7) || ((pin == 0) && (commandReceived[6] != '0'))) {
 12033               		.loc 1 482 0
 12034 440e 4830      		cpi r20,lo8(8)
 12035 4410 00F4      		brsh .L823
 482:switcherator.c ****     } else if ((pin > 7) || ((pin == 0) && (commandReceived[6] != '0'))) {
 12036               		.loc 1 482 0 is_stmt 0 discriminator 1
 12037 4412 F110      		cpse r15,__zero_reg__
 12038 4414 00C0      		rjmp .L824
 12039 4416 D601      		movw r26,r12
 12040 4418 1696      		adiw r26,6
 12041 441a 8C91      		ld r24,X
 12042 441c 8033      		cpi r24,lo8(48)
 12043 441e 01F0      		breq .L824
 12044               	.L823:
 483:switcherator.c ****         fail(4);
 12045               		.loc 1 483 0 is_stmt 1
 12046 4420 84E0      		ldi r24,lo8(4)
 12047 4422 90E0      		ldi r25,0
 12048 4424 00C0      		rjmp .L846
 12049               	.L824:
 486:switcherator.c ****         *realDDR |= (1 << originalPin);
 12050               		.loc 1 486 0
 12051 4426 D501      		movw r26,r10
 12052 4428 5C91      		ld r21,X
 12053 442a 21E0      		ldi r18,lo8(1)
 12054 442c 30E0      		ldi r19,0
 12055 442e 0F2C      		mov r0,r15
 12056 4430 00C0      		rjmp 2f
 12057               		1:
 12058 4432 220F      		lsl r18
 12059               		2:
 12060 4434 0A94      		dec r0
 12061 4436 02F4      		brpl 1b
 12062 4438 522B      		or r21,r18
 12063 443a 5C93      		st X,r21
 488:switcherator.c ****         pinMultiplied = pin * 2;
 12064               		.loc 1 488 0
 12065 443c 440F      		lsl r20
 12066               	.LVL1010:
 491:switcherator.c ****         switchStuff[switchNumber] = pin;
 12067               		.loc 1 491 0
 12068 443e D801      		movw r26,r16
 12069 4440 A050      		subi r26,lo8(-(switchStuff))
 12070 4442 B040      		sbci r27,hi8(-(switchStuff))
 490:switcherator.c ****         pin = pinMultiplied + pinSubtractee;
 12071               		.loc 1 490 0
 12072 4444 490F      		add r20,r25
 12073               	.LVL1011:
 491:switcherator.c ****         switchStuff[switchNumber] = pin;
 12074               		.loc 1 491 0
 12075 4446 4C93      		st X,r20
 495:switcherator.c ****             *realPort |= (1 << originalPin);
 12076               		.loc 1 495 0
 12077 4448 8081      		ld r24,Z
 493:switcherator.c ****         if (direction == 0) {
 12078               		.loc 1 493 0
 12079 444a E110      		cpse r14,__zero_reg__
 12080 444c 00C0      		rjmp .L825
 495:switcherator.c ****             *realPort |= (1 << originalPin);
 12081               		.loc 1 495 0
 12082 444e 822B      		or r24,r18
 12083 4450 8083      		st Z,r24
 12084 4452 00C0      		rjmp .L826
 12085               	.L825:
 497:switcherator.c ****             *realPort &= ~(1 << originalPin);
 12086               		.loc 1 497 0
 12087 4454 2095      		com r18
 12088 4456 8223      		and r24,r18
 12089 4458 8083      		st Z,r24
 498:switcherator.c ****             switchStuff[switchNumber]++;
 12090               		.loc 1 498 0
 12091 445a 8C91      		ld r24,X
 12092 445c 8F5F      		subi r24,lo8(-(1))
 12093 445e 8C93      		st X,r24
 12094               	.L826:
 12095               	/* epilogue start */
 502:switcherator.c **** }
 12096               		.loc 1 502 0
 12097 4460 0F90      		pop __tmp_reg__
 12098 4462 DF91      		pop r29
 12099 4464 CF91      		pop r28
 12100 4466 1F91      		pop r17
 12101 4468 0F91      		pop r16
 12102               	.LVL1012:
 12103 446a FF90      		pop r15
 12104               	.LVL1013:
 12105 446c EF90      		pop r14
 12106               	.LVL1014:
 12107 446e DF90      		pop r13
 12108 4470 CF90      		pop r12
 12109               	.LVL1015:
 12110 4472 BF90      		pop r11
 12111 4474 AF90      		pop r10
 12112               	.LVL1016:
 500:switcherator.c ****         ok();
 12113               		.loc 1 500 0
 12114 4476 0C94 0000 		jmp ok
 12115               	.LVL1017:
 12116               	.L844:
 478:switcherator.c ****         fail(2);
 12117               		.loc 1 478 0
 12118 447a 82E0      		ldi r24,lo8(2)
 12119 447c 90E0      		ldi r25,0
 12120               	.LVL1018:
 12121               	.L846:
 12122               	/* epilogue start */
 502:switcherator.c **** }
 12123               		.loc 1 502 0
 12124 447e 0F90      		pop __tmp_reg__
 12125 4480 DF91      		pop r29
 12126 4482 CF91      		pop r28
 12127 4484 1F91      		pop r17
 12128 4486 0F91      		pop r16
 12129               	.LVL1019:
 12130 4488 FF90      		pop r15
 12131               	.LVL1020:
 12132 448a EF90      		pop r14
 12133               	.LVL1021:
 12134 448c DF90      		pop r13
 12135 448e CF90      		pop r12
 12136               	.LVL1022:
 12137 4490 BF90      		pop r11
 12138 4492 AF90      		pop r10
 478:switcherator.c ****         fail(2);
 12139               		.loc 1 478 0
 12140 4494 0C94 0000 		jmp fail
 12141               	.LVL1023:
 12142               	.L830:
 423:switcherator.c ****         realDDR = &DDRB;
 12143               		.loc 1 423 0
 12144 4498 74E2      		ldi r23,lo8(36)
 12145 449a A72E      		mov r10,r23
 12146 449c B12C      		mov r11,__zero_reg__
 422:switcherator.c ****         realPort = &PORTB;
 12147               		.loc 1 422 0
 12148 449e E5E2      		ldi r30,lo8(37)
 12149 44a0 F0E0      		ldi r31,0
 424:switcherator.c ****         pinSubtractee = 16;
 12150               		.loc 1 424 0
 12151 44a2 90E1      		ldi r25,lo8(16)
 12152 44a4 00C0      		rjmp .L820
 12153               	.L832:
 434:switcherator.c ****         realDDR = &DDRC;
 12154               		.loc 1 434 0
 12155 44a6 67E2      		ldi r22,lo8(39)
 12156 44a8 A62E      		mov r10,r22
 12157 44aa B12C      		mov r11,__zero_reg__
 433:switcherator.c ****         realPort = &PORTC;
 12158               		.loc 1 433 0
 12159 44ac E8E2      		ldi r30,lo8(40)
 12160 44ae F0E0      		ldi r31,0
 435:switcherator.c ****         pinSubtractee = 32;
 12161               		.loc 1 435 0
 12162 44b0 90E2      		ldi r25,lo8(32)
 12163 44b2 00C0      		rjmp .L820
 12164               	.L834:
 440:switcherator.c ****         realDDR = &DDRD;
 12165               		.loc 1 440 0
 12166 44b4 5AE2      		ldi r21,lo8(42)
 12167 44b6 A52E      		mov r10,r21
 12168 44b8 B12C      		mov r11,__zero_reg__
 439:switcherator.c ****         realPort = &PORTD;
 12169               		.loc 1 439 0
 12170 44ba EBE2      		ldi r30,lo8(43)
 12171 44bc F0E0      		ldi r31,0
 441:switcherator.c ****         pinSubtractee = 48;
 12172               		.loc 1 441 0
 12173 44be 90E3      		ldi r25,lo8(48)
 12174               	.L820:
 12175               	.LVL1024:
 479:switcherator.c ****     } else if ((switchNumber >= NUM_SWITCHES) ||
 12176               		.loc 1 479 0
 12177 44c0 0031      		cpi r16,16
 12178 44c2 1105      		cpc r17,__zero_reg__
 12179 44c4 04F4      		brge .+2
 12180 44c6 00C0      		rjmp .L845
 12181 44c8 00C0      		rjmp .L827
 12182               	.LFE12:
 12184               		.section	.rodata.str1.1
 12185               	.LC70:
 12186 0159 5374 6172 		.string	"Start:"
 12186      743A 00
 12187               	.LC71:
 12188 0160 5374 6F70 		.string	"Stop:"
 12188      3A00 
 12189               		.text
 12190               	.global	setTimeLimits
 12192               	setTimeLimits:
 12193               	.LFB60:
2554:switcherator.c **** void setTimeLimits(char * commandReceived) {
 12194               		.loc 1 2554 0
 12195               	.LVL1025:
 12196 44ca 2F92      		push r2
 12197               	.LCFI321:
 12198 44cc 3F92      		push r3
 12199               	.LCFI322:
 12200 44ce 4F92      		push r4
 12201               	.LCFI323:
 12202 44d0 5F92      		push r5
 12203               	.LCFI324:
 12204 44d2 6F92      		push r6
 12205               	.LCFI325:
 12206 44d4 7F92      		push r7
 12207               	.LCFI326:
 12208 44d6 8F92      		push r8
 12209               	.LCFI327:
 12210 44d8 9F92      		push r9
 12211               	.LCFI328:
 12212 44da AF92      		push r10
 12213               	.LCFI329:
 12214 44dc BF92      		push r11
 12215               	.LCFI330:
 12216 44de CF92      		push r12
 12217               	.LCFI331:
 12218 44e0 DF92      		push r13
 12219               	.LCFI332:
 12220 44e2 EF92      		push r14
 12221               	.LCFI333:
 12222 44e4 FF92      		push r15
 12223               	.LCFI334:
 12224 44e6 0F93      		push r16
 12225               	.LCFI335:
 12226 44e8 1F93      		push r17
 12227               	.LCFI336:
 12228 44ea CF93      		push r28
 12229               	.LCFI337:
 12230 44ec DF93      		push r29
 12231               	.LCFI338:
 12232 44ee CDB7      		in r28,__SP_L__
 12233 44f0 DEB7      		in r29,__SP_H__
 12234               	.LCFI339:
 12235 44f2 2C97      		sbiw r28,12
 12236               	.LCFI340:
 12237 44f4 0FB6      		in __tmp_reg__,__SREG__
 12238 44f6 F894      		cli
 12239 44f8 DEBF      		out __SP_H__,r29
 12240 44fa 0FBE      		out __SREG__,__tmp_reg__
 12241 44fc CDBF      		out __SP_L__,r28
 12242               	/* prologue: function */
 12243               	/* frame size = 12 */
 12244               	/* stack size = 30 */
 12245               	.L__stack_usage = 30
 12246 44fe 6C01      		movw r12,r24
2555:switcherator.c ****     char tempReallyLongString[] = "0000000";
 12247               		.loc 1 2555 0
 12248 4500 88E0      		ldi r24,lo8(8)
 12249               	.LVL1026:
 12250 4502 E0E0      		ldi r30,lo8(.LC69)
 12251 4504 F0E0      		ldi r31,hi8(.LC69)
 12252 4506 DE01      		movw r26,r28
 12253 4508 1196      		adiw r26,1
 12254               		0:
 12255 450a 0190      		ld r0,Z+
 12256 450c 0D92      		st X+,r0
 12257 450e 8A95      		dec r24
 12258 4510 01F4      		brne 0b
 12259               	.LVL1027:
2561:switcherator.c ****     statusMsg[0] = 0;
 12260               		.loc 1 2561 0
 12261 4512 1092 0000 		sts statusMsg,__zero_reg__
2563:switcherator.c ****     tempIntString[0] = commandReceived[3];
 12262               		.loc 1 2563 0
 12263 4516 F601      		movw r30,r12
 12264 4518 8381      		ldd r24,Z+3
 12265 451a 8093 0000 		sts tempIntString,r24
2564:switcherator.c ****     tempIntString[1] = commandReceived[4];
 12266               		.loc 1 2564 0
 12267 451e 8481      		ldd r24,Z+4
 12268 4520 8093 0000 		sts tempIntString+1,r24
2565:switcherator.c ****     programNumber = atoi(tempIntString);
 12269               		.loc 1 2565 0
 12270 4524 80E0      		ldi r24,lo8(tempIntString)
 12271 4526 90E0      		ldi r25,hi8(tempIntString)
 12272 4528 0E94 0000 		call atoi
 12273               	.LVL1028:
 12274 452c 8C01      		movw r16,r24
 12275               	.LVL1029:
2566:switcherator.c ****     if (programNumber > NUM_LIMITS) {
 12276               		.loc 1 2566 0
 12277 452e 8530      		cpi r24,5
 12278 4530 9105      		cpc r25,__zero_reg__
 12279 4532 04F0      		brlt .L848
2567:switcherator.c ****         fail(0x10);
 12280               		.loc 1 2567 0
 12281 4534 80E1      		ldi r24,lo8(16)
 12282 4536 90E0      		ldi r25,0
 12283 4538 00C0      		rjmp .L859
 12284               	.L848:
2570:switcherator.c ****     if (commandReceived[5] == 'x' || commandReceived[5] == 'x') {
 12285               		.loc 1 2570 0
 12286 453a F601      		movw r30,r12
 12287 453c 8581      		ldd r24,Z+5
 12288 453e 8837      		cpi r24,lo8(120)
 12289 4540 01F4      		brne .L850
2571:switcherator.c ****         timeLimits[programNumber][2] = 0;
 12290               		.loc 1 2571 0
 12291 4542 8CE0      		ldi r24,lo8(12)
 12292 4544 809F      		mul r24,r16
 12293 4546 F001      		movw r30,r0
 12294 4548 819F      		mul r24,r17
 12295 454a F00D      		add r31,r0
 12296 454c 1124      		clr __zero_reg__
 12297 454e E050      		subi r30,lo8(-(timeLimits))
 12298 4550 F040      		sbci r31,hi8(-(timeLimits))
 12299 4552 1086      		std Z+8,__zero_reg__
 12300 4554 1186      		std Z+9,__zero_reg__
 12301 4556 1286      		std Z+10,__zero_reg__
 12302 4558 1386      		std Z+11,__zero_reg__
 12303 455a 00C0      		rjmp .L860
 12304               	.L850:
2575:switcherator.c ****     if (commandReceived[5] == '?') {
 12305               		.loc 1 2575 0
 12306 455c 8F33      		cpi r24,lo8(63)
 12307 455e 01F0      		breq .+2
 12308 4560 00C0      		rjmp .L851
2577:switcherator.c ****         startTime = timeLimits[programNumber][0];
 12309               		.loc 1 2577 0
 12310 4562 8CE0      		ldi r24,lo8(12)
 12311 4564 809F      		mul r24,r16
 12312 4566 F001      		movw r30,r0
 12313 4568 819F      		mul r24,r17
 12314 456a F00D      		add r31,r0
 12315 456c 1124      		clr __zero_reg__
 12316 456e E050      		subi r30,lo8(-(timeLimits))
 12317 4570 F040      		sbci r31,hi8(-(timeLimits))
 12318 4572 8080      		ld r8,Z
 12319 4574 9180      		ldd r9,Z+1
 12320 4576 A280      		ldd r10,Z+2
 12321 4578 B380      		ldd r11,Z+3
 12322               	.LVL1030:
2579:switcherator.c ****         strcat(statusMsg, "Start:");
 12323               		.loc 1 2579 0
 12324 457a 60E0      		ldi r22,lo8(.LC70)
 12325 457c 70E0      		ldi r23,hi8(.LC70)
 12326 457e 80E0      		ldi r24,lo8(statusMsg)
 12327 4580 90E0      		ldi r25,hi8(statusMsg)
 12328 4582 0E94 0000 		call strcat
 12329               	.LVL1031:
2580:switcherator.c ****         startHour = (startTime / 60 / 60);
 12330               		.loc 1 2580 0
 12331 4586 C501      		movw r24,r10
 12332 4588 B401      		movw r22,r8
 12333 458a 20E1      		ldi r18,lo8(16)
 12334 458c 3EE0      		ldi r19,lo8(14)
 12335 458e 40E0      		ldi r20,0
 12336 4590 50E0      		ldi r21,0
 12337 4592 0E94 0000 		call __divmodsi4
 12338 4596 6901      		movw r12,r18
 12339 4598 7A01      		movw r14,r20
 12340               	.LVL1032:
2581:switcherator.c ****         returnInt(startHour, tempLongString);
 12341               		.loc 1 2581 0
 12342 459a 60E0      		ldi r22,lo8(tempLongString)
 12343 459c 70E0      		ldi r23,hi8(tempLongString)
 12344 459e C901      		movw r24,r18
 12345 45a0 0E94 0000 		call returnInt
 12346               	.LVL1033:
2582:switcherator.c ****         strcat(statusMsg, tempLongString);
 12347               		.loc 1 2582 0
 12348 45a4 60E0      		ldi r22,lo8(tempLongString)
 12349 45a6 70E0      		ldi r23,hi8(tempLongString)
 12350 45a8 80E0      		ldi r24,lo8(statusMsg)
 12351 45aa 90E0      		ldi r25,hi8(statusMsg)
 12352 45ac 0E94 0000 		call strcat
 12353               	.LVL1034:
2584:switcherator.c ****         strcat(statusMsg, ":");
 12354               		.loc 1 2584 0
 12355 45b0 60E0      		ldi r22,lo8(.LC4)
 12356 45b2 70E0      		ldi r23,hi8(.LC4)
 12357 45b4 80E0      		ldi r24,lo8(statusMsg)
 12358 45b6 90E0      		ldi r25,hi8(statusMsg)
 12359 45b8 0E94 0000 		call strcat
 12360               	.LVL1035:
2583:switcherator.c ****         startMinute = ((startTime - (startHour * 60 * 60)) / 60);
 12361               		.loc 1 2583 0
 12362 45bc 20E1      		ldi r18,lo8(16)
 12363 45be 3EE0      		ldi r19,lo8(14)
 12364 45c0 C29E      		mul r12,r18
 12365 45c2 C001      		movw r24,r0
 12366 45c4 C39E      		mul r12,r19
 12367 45c6 900D      		add r25,r0
 12368 45c8 D29E      		mul r13,r18
 12369 45ca 900D      		add r25,r0
 12370 45cc 1124      		clr r1
 12371 45ce A501      		movw r20,r10
 12372 45d0 9401      		movw r18,r8
 12373 45d2 281B      		sub r18,r24
 12374 45d4 390B      		sbc r19,r25
 12375 45d6 4109      		sbc r20,__zero_reg__
 12376 45d8 5109      		sbc r21,__zero_reg__
 12377 45da CA01      		movw r24,r20
 12378 45dc B901      		movw r22,r18
 12379 45de 2CE3      		ldi r18,lo8(60)
 12380 45e0 30E0      		ldi r19,0
 12381 45e2 40E0      		ldi r20,0
 12382 45e4 50E0      		ldi r21,0
 12383 45e6 0E94 0000 		call __divmodsi4
2585:switcherator.c ****         returnInt(startMinute, tempLongString);
 12384               		.loc 1 2585 0
 12385 45ea 60E0      		ldi r22,lo8(tempLongString)
 12386 45ec 70E0      		ldi r23,hi8(tempLongString)
 12387 45ee C901      		movw r24,r18
 12388 45f0 2987      		std Y+9,r18
 12389 45f2 3A87      		std Y+10,r19
 12390 45f4 4B87      		std Y+11,r20
 12391 45f6 5C87      		std Y+12,r21
 12392 45f8 0E94 0000 		call returnInt
 12393               	.LVL1036:
2586:switcherator.c ****         strcat(statusMsg, tempLongString);
 12394               		.loc 1 2586 0
 12395 45fc 60E0      		ldi r22,lo8(tempLongString)
 12396 45fe 70E0      		ldi r23,hi8(tempLongString)
 12397 4600 80E0      		ldi r24,lo8(statusMsg)
 12398 4602 90E0      		ldi r25,hi8(statusMsg)
 12399 4604 0E94 0000 		call strcat
 12400               	.LVL1037:
2587:switcherator.c ****         strcat(statusMsg, "Stop:");
 12401               		.loc 1 2587 0
 12402 4608 60E0      		ldi r22,lo8(.LC71)
 12403 460a 70E0      		ldi r23,hi8(.LC71)
 12404 460c 80E0      		ldi r24,lo8(statusMsg)
 12405 460e 90E0      		ldi r25,hi8(statusMsg)
 12406 4610 0E94 0000 		call strcat
 12407               	.LVL1038:
2589:switcherator.c ****         returnInt(stopHour, tempLongString);
 12408               		.loc 1 2589 0
 12409 4614 60E0      		ldi r22,lo8(tempLongString)
 12410 4616 70E0      		ldi r23,hi8(tempLongString)
 12411 4618 C601      		movw r24,r12
 12412 461a 0E94 0000 		call returnInt
 12413               	.LVL1039:
2590:switcherator.c ****         strcat(statusMsg, tempLongString);
 12414               		.loc 1 2590 0
 12415 461e 60E0      		ldi r22,lo8(tempLongString)
 12416 4620 70E0      		ldi r23,hi8(tempLongString)
 12417 4622 80E0      		ldi r24,lo8(statusMsg)
 12418 4624 90E0      		ldi r25,hi8(statusMsg)
 12419 4626 0E94 0000 		call strcat
 12420               	.LVL1040:
2592:switcherator.c ****         strcat(statusMsg, ":");
 12421               		.loc 1 2592 0
 12422 462a 60E0      		ldi r22,lo8(.LC4)
 12423 462c 70E0      		ldi r23,hi8(.LC4)
 12424 462e 80E0      		ldi r24,lo8(statusMsg)
 12425 4630 90E0      		ldi r25,hi8(statusMsg)
 12426 4632 0E94 0000 		call strcat
 12427               	.LVL1041:
2593:switcherator.c ****         returnInt(stopMinute, tempLongString);
 12428               		.loc 1 2593 0
 12429 4636 60E0      		ldi r22,lo8(tempLongString)
 12430 4638 70E0      		ldi r23,hi8(tempLongString)
 12431 463a 2985      		ldd r18,Y+9
 12432 463c 3A85      		ldd r19,Y+10
 12433 463e C901      		movw r24,r18
 12434 4640 0E94 0000 		call returnInt
 12435               	.LVL1042:
2594:switcherator.c ****         strcat(statusMsg, tempLongString);
 12436               		.loc 1 2594 0
 12437 4644 60E0      		ldi r22,lo8(tempLongString)
 12438 4646 70E0      		ldi r23,hi8(tempLongString)
 12439 4648 80E0      		ldi r24,lo8(statusMsg)
 12440 464a 90E0      		ldi r25,hi8(statusMsg)
 12441 464c 0E94 0000 		call strcat
 12442               	.LVL1043:
2595:switcherator.c ****         sendMessage(statusMsg);
 12443               		.loc 1 2595 0
 12444 4650 80E0      		ldi r24,lo8(statusMsg)
 12445 4652 90E0      		ldi r25,hi8(statusMsg)
 12446 4654 0E94 0000 		call sendMessage
 12447               	.LVL1044:
 12448 4658 00C0      		rjmp .L847
 12449               	.LVL1045:
 12450               	.L851:
2554:switcherator.c **** void setTimeLimits(char * commandReceived) {
 12451               		.loc 1 2554 0
 12452 465a D601      		movw r26,r12
 12453 465c 1D96      		adiw r26,13
 12454 465e FE01      		movw r30,r28
 12455 4660 3196      		adiw r30,1
 12456 4662 CE01      		movw r24,r28
 12457 4664 0896      		adiw r24,8
 12458               	.LVL1046:
 12459               	.L852:
2599:switcherator.c ****         tempReallyLongString[x] = commandReceived[x + 13];
 12460               		.loc 1 2599 0 discriminator 2
 12461 4666 2D91      		ld r18,X+
 12462 4668 2193      		st Z+,r18
2598:switcherator.c ****     for (x = 0; x < 7; x++) {
 12463               		.loc 1 2598 0 discriminator 2
 12464 466a E817      		cp r30,r24
 12465 466c F907      		cpc r31,r25
 12466 466e 01F4      		brne .L852
2601:switcherator.c ****     weekLong = strtol(tempReallyLongString, 0, 2);
 12467               		.loc 1 2601 0
 12468 4670 42E0      		ldi r20,lo8(2)
 12469 4672 50E0      		ldi r21,0
 12470 4674 60E0      		ldi r22,0
 12471 4676 70E0      		ldi r23,0
 12472 4678 CE01      		movw r24,r28
 12473 467a 0196      		adiw r24,1
 12474 467c 0E94 0000 		call strtol
 12475               	.LVL1047:
 12476 4680 2B01      		movw r4,r22
 12477 4682 3C01      		movw r6,r24
 12478               	.LVL1048:
2602:switcherator.c ****     tempIntString[0] = commandReceived[5];
 12479               		.loc 1 2602 0
 12480 4684 F601      		movw r30,r12
 12481 4686 8581      		ldd r24,Z+5
 12482 4688 8093 0000 		sts tempIntString,r24
2603:switcherator.c ****     tempIntString[1] = commandReceived[6];
 12483               		.loc 1 2603 0
 12484 468c 8681      		ldd r24,Z+6
 12485 468e 8093 0000 		sts tempIntString+1,r24
2604:switcherator.c ****     startHour = atoi(tempIntString);
 12486               		.loc 1 2604 0
 12487 4692 80E0      		ldi r24,lo8(tempIntString)
 12488 4694 90E0      		ldi r25,hi8(tempIntString)
 12489 4696 0E94 0000 		call atoi
 12490               	.LVL1049:
 12491 469a 7C01      		movw r14,r24
 12492               	.LVL1050:
2605:switcherator.c ****     tempIntString[0] = commandReceived[7];
 12493               		.loc 1 2605 0
 12494 469c F601      		movw r30,r12
 12495 469e 8781      		ldd r24,Z+7
 12496 46a0 8093 0000 		sts tempIntString,r24
2606:switcherator.c ****     tempIntString[1] = commandReceived[8];
 12497               		.loc 1 2606 0
 12498 46a4 8085      		ldd r24,Z+8
 12499 46a6 8093 0000 		sts tempIntString+1,r24
2607:switcherator.c ****     startMinute = atoi(tempIntString);
 12500               		.loc 1 2607 0
 12501 46aa 80E0      		ldi r24,lo8(tempIntString)
 12502 46ac 90E0      		ldi r25,hi8(tempIntString)
 12503 46ae 0E94 0000 		call atoi
 12504               	.LVL1051:
 12505 46b2 4C01      		movw r8,r24
 12506               	.LVL1052:
2608:switcherator.c ****     tempIntString[0] = commandReceived[9];
 12507               		.loc 1 2608 0
 12508 46b4 F601      		movw r30,r12
 12509 46b6 8185      		ldd r24,Z+9
 12510 46b8 8093 0000 		sts tempIntString,r24
2609:switcherator.c ****     tempIntString[1] = commandReceived[10];
 12511               		.loc 1 2609 0
 12512 46bc 8285      		ldd r24,Z+10
 12513 46be 8093 0000 		sts tempIntString+1,r24
2610:switcherator.c ****     stopHour = atoi(tempIntString);
 12514               		.loc 1 2610 0
 12515 46c2 80E0      		ldi r24,lo8(tempIntString)
 12516 46c4 90E0      		ldi r25,hi8(tempIntString)
 12517 46c6 0E94 0000 		call atoi
 12518               	.LVL1053:
 12519 46ca 1C01      		movw r2,r24
 12520               	.LVL1054:
2611:switcherator.c ****     tempIntString[0] = commandReceived[11];
 12521               		.loc 1 2611 0
 12522 46cc F601      		movw r30,r12
 12523 46ce 8385      		ldd r24,Z+11
 12524 46d0 8093 0000 		sts tempIntString,r24
2612:switcherator.c ****     tempIntString[1] = commandReceived[12];
 12525               		.loc 1 2612 0
 12526 46d4 8485      		ldd r24,Z+12
 12527 46d6 8093 0000 		sts tempIntString+1,r24
2613:switcherator.c ****     stopMinute = atoi(tempIntString);
 12528               		.loc 1 2613 0
 12529 46da 80E0      		ldi r24,lo8(tempIntString)
 12530 46dc 90E0      		ldi r25,hi8(tempIntString)
 12531 46de 0E94 0000 		call atoi
 12532               	.LVL1055:
2614:switcherator.c ****     if (startHour > 23 || stopHour > 23) {
 12533               		.loc 1 2614 0
 12534 46e2 F8E1      		ldi r31,24
 12535 46e4 EF16      		cp r14,r31
 12536 46e6 F104      		cpc r15,__zero_reg__
 12537 46e8 00F4      		brsh .L853
2614:switcherator.c ****     if (startHour > 23 || stopHour > 23) {
 12538               		.loc 1 2614 0 is_stmt 0 discriminator 1
 12539 46ea 28E1      		ldi r18,24
 12540 46ec 2216      		cp r2,r18
 12541 46ee 3104      		cpc r3,__zero_reg__
 12542 46f0 00F0      		brlo .L854
 12543               	.L853:
2615:switcherator.c ****         fail(0x09);
 12544               		.loc 1 2615 0 is_stmt 1
 12545 46f2 89E0      		ldi r24,lo8(9)
 12546 46f4 90E0      		ldi r25,0
 12547               	.LVL1056:
 12548 46f6 00C0      		rjmp .L859
 12549               	.LVL1057:
 12550               	.L854:
2607:switcherator.c ****     startMinute = atoi(tempIntString);
 12551               		.loc 1 2607 0
 12552 46f8 F401      		movw r30,r8
2618:switcherator.c ****     if (startMinute > 59 || stopMinute > 59) {
 12553               		.loc 1 2618 0
 12554 46fa EC33      		cpi r30,60
 12555 46fc F105      		cpc r31,__zero_reg__
 12556 46fe 00F4      		brsh .L855
2613:switcherator.c ****     stopMinute = atoi(tempIntString);
 12557               		.loc 1 2613 0 discriminator 1
 12558 4700 AC01      		movw r20,r24
2618:switcherator.c ****     if (startMinute > 59 || stopMinute > 59) {
 12559               		.loc 1 2618 0 discriminator 1
 12560 4702 8C33      		cpi r24,60
 12561 4704 9105      		cpc r25,__zero_reg__
 12562 4706 00F0      		brlo .L856
 12563               	.L855:
2619:switcherator.c ****         fail(0x0A);
 12564               		.loc 1 2619 0
 12565 4708 8AE0      		ldi r24,lo8(10)
 12566 470a 90E0      		ldi r25,0
 12567               	.LVL1058:
 12568               	.L859:
 12569 470c 0E94 0000 		call fail
 12570               	.LVL1059:
 12571 4710 00C0      		rjmp .L847
 12572               	.LVL1060:
 12573               	.L856:
2623:switcherator.c ****     startTime = startTime * 60 * 60;
 12574               		.loc 1 2623 0
 12575 4712 9701      		movw r18,r14
 12576 4714 A0E1      		ldi r26,lo8(16)
 12577 4716 BEE0      		ldi r27,lo8(14)
 12578 4718 0E94 0000 		call __umulhisi3
 12579 471c 6B01      		movw r12,r22
 12580 471e 7C01      		movw r14,r24
 12581               	.LVL1061:
2626:switcherator.c ****     stopTime = stopTime * 60 * 60;
 12582               		.loc 1 2626 0
 12583 4720 9101      		movw r18,r2
 12584 4722 0E94 0000 		call __umulhisi3
 12585               	.LVL1062:
2628:switcherator.c ****     timeLimits[programNumber][0] = startTime;
 12586               		.loc 1 2628 0
 12587 4726 2CE0      		ldi r18,lo8(12)
 12588 4728 209F      		mul r18,r16
 12589 472a D001      		movw r26,r0
 12590 472c 219F      		mul r18,r17
 12591 472e B00D      		add r27,r0
 12592 4730 1124      		clr __zero_reg__
 12593 4732 A050      		subi r26,lo8(-(timeLimits))
 12594 4734 B040      		sbci r27,hi8(-(timeLimits))
2624:switcherator.c ****     startTime += (startMinute * 60);
 12595               		.loc 1 2624 0
 12596 4736 2CE3      		ldi r18,lo8(60)
 12597 4738 289D      		mul r18,r8
 12598 473a 8001      		movw r16,r0
 12599 473c 299D      		mul r18,r9
 12600 473e 100D      		add r17,r0
 12601 4740 1124      		clr __zero_reg__
 12602               	.LVL1063:
 12603 4742 C00E      		add r12,r16
 12604 4744 D11E      		adc r13,r17
 12605 4746 E11C      		adc r14,__zero_reg__
 12606 4748 F11C      		adc r15,__zero_reg__
 12607               	.LVL1064:
2628:switcherator.c ****     timeLimits[programNumber][0] = startTime;
 12608               		.loc 1 2628 0
 12609 474a CD92      		st X+,r12
 12610 474c DD92      		st X+,r13
 12611 474e ED92      		st X+,r14
 12612 4750 FC92      		st X,r15
 12613 4752 1397      		sbiw r26,3
2627:switcherator.c ****     stopTime += (stopMinute * 60);
 12614               		.loc 1 2627 0
 12615 4754 249F      		mul r18,r20
 12616 4756 F001      		movw r30,r0
 12617 4758 259F      		mul r18,r21
 12618 475a F00D      		add r31,r0
 12619 475c 1124      		clr __zero_reg__
 12620 475e 6E0F      		add r22,r30
 12621 4760 7F1F      		adc r23,r31
 12622 4762 811D      		adc r24,__zero_reg__
 12623 4764 911D      		adc r25,__zero_reg__
 12624               	.LVL1065:
2629:switcherator.c ****     timeLimits[programNumber][1] = stopTime;
 12625               		.loc 1 2629 0
 12626 4766 1496      		adiw r26,4
 12627 4768 6D93      		st X+,r22
 12628 476a 7D93      		st X+,r23
 12629 476c 8D93      		st X+,r24
 12630 476e 9C93      		st X,r25
 12631 4770 1797      		sbiw r26,4+3
2630:switcherator.c ****     timeLimits[programNumber][2] = weekLong;
 12632               		.loc 1 2630 0
 12633 4772 1896      		adiw r26,8
 12634 4774 4D92      		st X+,r4
 12635 4776 5D92      		st X+,r5
 12636 4778 6D92      		st X+,r6
 12637 477a 7C92      		st X,r7
 12638 477c 1B97      		sbiw r26,8+3
 12639               	.LVL1066:
 12640               	.L860:
2631:switcherator.c ****     ok();
 12641               		.loc 1 2631 0
 12642 477e 0E94 0000 		call ok
 12643               	.LVL1067:
 12644               	.L847:
 12645               	/* epilogue start */
2633:switcherator.c **** }
 12646               		.loc 1 2633 0
 12647 4782 2C96      		adiw r28,12
 12648 4784 0FB6      		in __tmp_reg__,__SREG__
 12649 4786 F894      		cli
 12650 4788 DEBF      		out __SP_H__,r29
 12651 478a 0FBE      		out __SREG__,__tmp_reg__
 12652 478c CDBF      		out __SP_L__,r28
 12653 478e DF91      		pop r29
 12654 4790 CF91      		pop r28
 12655 4792 1F91      		pop r17
 12656 4794 0F91      		pop r16
 12657 4796 FF90      		pop r15
 12658 4798 EF90      		pop r14
 12659 479a DF90      		pop r13
 12660 479c CF90      		pop r12
 12661 479e BF90      		pop r11
 12662 47a0 AF90      		pop r10
 12663 47a2 9F90      		pop r9
 12664 47a4 8F90      		pop r8
 12665 47a6 7F90      		pop r7
 12666 47a8 6F90      		pop r6
 12667 47aa 5F90      		pop r5
 12668 47ac 4F90      		pop r4
 12669 47ae 3F90      		pop r3
 12670 47b0 2F90      		pop r2
 12671 47b2 0895      		ret
 12672               	.LFE60:
 12674               		.section	.rodata.str1.1
 12675               	.LC72:
 12676 0166 4E65 7720 		.string	"New prog#"
 12676      7072 6F67 
 12676      2300 
 12677               		.text
 12678               	.global	newProgram
 12680               	newProgram:
 12681               	.LFB31:
1224:switcherator.c **** void newProgram(char * commandReceived) {
 12682               		.loc 1 1224 0
 12683               	.LVL1068:
 12684 47b4 AF92      		push r10
 12685               	.LCFI341:
 12686 47b6 BF92      		push r11
 12687               	.LCFI342:
 12688 47b8 CF92      		push r12
 12689               	.LCFI343:
 12690 47ba DF92      		push r13
 12691               	.LCFI344:
 12692 47bc EF92      		push r14
 12693               	.LCFI345:
 12694 47be FF92      		push r15
 12695               	.LCFI346:
 12696 47c0 0F93      		push r16
 12697               	.LCFI347:
 12698 47c2 1F93      		push r17
 12699               	.LCFI348:
 12700 47c4 CF93      		push r28
 12701               	.LCFI349:
 12702 47c6 DF93      		push r29
 12703               	.LCFI350:
 12704               	/* prologue: function */
 12705               	/* frame size = 0 */
 12706               	/* stack size = 10 */
 12707               	.L__stack_usage = 10
 12708 47c8 EC01      		movw r28,r24
 12709               	.LVL1069:
 12710 47ca E0E0      		ldi r30,lo8(weeklyProgram+1)
 12711 47cc F0E0      		ldi r31,hi8(weeklyProgram+1)
1232:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 12712               		.loc 1 1232 0
 12713 47ce 00E0      		ldi r16,0
 12714 47d0 10E0      		ldi r17,0
 12715               	.LVL1070:
 12716               	.L864:
1224:switcherator.c **** void newProgram(char * commandReceived) {
 12717               		.loc 1 1224 0
 12718 47d2 DF01      		movw r26,r30
 12719 47d4 1197      		sbiw r26,1
1234:switcherator.c ****         if (weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) {
 12720               		.loc 1 1234 0
 12721 47d6 8C91      		ld r24,X
 12722 47d8 8F3F      		cpi r24,lo8(-1)
 12723 47da 01F4      		brne .L862
1234:switcherator.c ****         if (weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) {
 12724               		.loc 1 1234 0 is_stmt 0 discriminator 1
 12725 47dc 8081      		ld r24,Z
 12726 47de 8F3F      		cpi r24,lo8(-1)
 12727 47e0 01F4      		brne .+2
 12728 47e2 00C0      		rjmp .L863
 12729               	.L862:
1232:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 12730               		.loc 1 1232 0 is_stmt 1
 12731 47e4 0F5F      		subi r16,-1
 12732 47e6 1F4F      		sbci r17,-1
 12733               	.LVL1071:
 12734 47e8 3A96      		adiw r30,10
 12735 47ea 0431      		cpi r16,20
 12736 47ec 1105      		cpc r17,__zero_reg__
 12737 47ee 01F4      		brne .L864
 12738 47f0 00C0      		rjmp .L879
 12739               	.LVL1072:
 12740               	.L880:
1257:switcherator.c ****     if (hours >= 24 || (hours == 0 && commandReceived[4] != '0')) {
 12741               		.loc 1 1257 0 discriminator 1
 12742 47f2 E114      		cp r14,__zero_reg__
 12743 47f4 F104      		cpc r15,__zero_reg__
 12744 47f6 01F4      		brne .L866
 12745 47f8 20E3      		ldi r18,lo8(48)
 12746 47fa A216      		cp r10,r18
 12747 47fc 01F0      		breq .L866
 12748               	.L870:
1258:switcherator.c ****         fail(9);
 12749               		.loc 1 1258 0
 12750 47fe 89E0      		ldi r24,lo8(9)
 12751 4800 90E0      		ldi r25,0
 12752               	.LVL1073:
 12753 4802 00C0      		rjmp .L881
 12754               	.LVL1074:
 12755               	.L866:
1261:switcherator.c ****     if (minutes >= 60 || (minutes == 0 && commandReceived[6] != '0')) {
 12756               		.loc 1 1261 0
 12757 4804 2CE3      		ldi r18,60
 12758 4806 C216      		cp r12,r18
 12759 4808 D104      		cpc r13,__zero_reg__
 12760 480a 04F4      		brge .L867
1261:switcherator.c ****     if (minutes >= 60 || (minutes == 0 && commandReceived[6] != '0')) {
 12761               		.loc 1 1261 0 is_stmt 0 discriminator 1
 12762 480c C114      		cp r12,__zero_reg__
 12763 480e D104      		cpc r13,__zero_reg__
 12764 4810 01F4      		brne .L868
 12765 4812 20E3      		ldi r18,lo8(48)
 12766 4814 B216      		cp r11,r18
 12767 4816 01F0      		breq .L868
 12768               	.L867:
1262:switcherator.c ****         fail(0x0a);
 12769               		.loc 1 1262 0 is_stmt 1
 12770 4818 8AE0      		ldi r24,lo8(10)
 12771 481a 90E0      		ldi r25,0
 12772               	.LVL1075:
 12773 481c 00C0      		rjmp .L881
 12774               	.LVL1076:
 12775               	.L868:
1265:switcherator.c ****     if (duration == 0) {
 12776               		.loc 1 1265 0
 12777 481e 0097      		sbiw r24,0
 12778 4820 01F4      		brne .L869
1266:switcherator.c ****         fail(0x0b);
 12779               		.loc 1 1266 0
 12780 4822 8BE0      		ldi r24,lo8(11)
 12781 4824 90E0      		ldi r25,0
 12782               	.LVL1077:
 12783 4826 00C0      		rjmp .L881
 12784               	.LVL1078:
 12785               	.L869:
1269:switcherator.c ****     duration *= 60; // convert to seconds
 12786               		.loc 1 1269 0
 12787 4828 6CE3      		ldi r22,lo8(60)
 12788 482a 689F      		mul r22,r24
 12789 482c A001      		movw r20,r0
 12790 482e 699F      		mul r22,r25
 12791 4830 500D      		add r21,r0
 12792 4832 1124      		clr __zero_reg__
 12793               	.LVL1079:
1270:switcherator.c ****     startTime = (hours * 60);
 12794               		.loc 1 1270 0
 12795 4834 6E9D      		mul r22,r14
 12796 4836 9001      		movw r18,r0
 12797 4838 6F9D      		mul r22,r15
 12798 483a 300D      		add r19,r0
 12799 483c 1124      		clr __zero_reg__
 12800               	.LVL1080:
1271:switcherator.c ****     startTime += minutes; // stored in minutes
 12801               		.loc 1 1271 0
 12802 483e 2C0D      		add r18,r12
 12803 4840 3D1D      		adc r19,r13
 12804               	.LVL1081:
1274:switcherator.c ****     weeklyProgram[programNumber][1] = temp;
 12805               		.loc 1 1274 0
 12806 4842 8AE0      		ldi r24,lo8(10)
 12807 4844 809F      		mul r24,r16
 12808 4846 F001      		movw r30,r0
 12809 4848 819F      		mul r24,r17
 12810 484a F00D      		add r31,r0
 12811 484c 1124      		clr __zero_reg__
 12812 484e E050      		subi r30,lo8(-(weeklyProgram))
 12813 4850 F040      		sbci r31,hi8(-(weeklyProgram))
 12814 4852 3183      		std Z+1,r19
 12815               	.LVL1082:
1276:switcherator.c ****     weeklyProgram[programNumber][2] = temp;
 12816               		.loc 1 1276 0
 12817 4854 2283      		std Z+2,r18
 12818               	.LVL1083:
1278:switcherator.c ****     weeklyProgram[programNumber][3] = temp;
 12819               		.loc 1 1278 0
 12820 4856 5383      		std Z+3,r21
 12821               	.LVL1084:
1279:switcherator.c ****     temp = (duration & 0xff);
 12822               		.loc 1 1279 0
 12823 4858 5527      		clr r21
 12824               	.LVL1085:
1280:switcherator.c ****     weeklyProgram[programNumber][4] = temp;
 12825               		.loc 1 1280 0
 12826 485a 4483      		std Z+4,r20
1281:switcherator.c ****     statusMsg[0] = 0;
 12827               		.loc 1 1281 0
 12828 485c 1092 0000 		sts statusMsg,__zero_reg__
1282:switcherator.c ****     strcat(statusMsg, "New prog#");
 12829               		.loc 1 1282 0
 12830 4860 60E0      		ldi r22,lo8(.LC72)
 12831 4862 70E0      		ldi r23,hi8(.LC72)
 12832 4864 80E0      		ldi r24,lo8(statusMsg)
 12833 4866 90E0      		ldi r25,hi8(statusMsg)
 12834 4868 0E94 0000 		call strcat
 12835               	.LVL1086:
1283:switcherator.c ****     returnInt(programNumber, tempIntString);
 12836               		.loc 1 1283 0
 12837 486c 60E0      		ldi r22,lo8(tempIntString)
 12838 486e 70E0      		ldi r23,hi8(tempIntString)
 12839 4870 C801      		movw r24,r16
 12840 4872 0E94 0000 		call returnInt
 12841               	.LVL1087:
1284:switcherator.c ****     strcat(statusMsg, tempIntString);
 12842               		.loc 1 1284 0
 12843 4876 60E0      		ldi r22,lo8(tempIntString)
 12844 4878 70E0      		ldi r23,hi8(tempIntString)
 12845 487a 80E0      		ldi r24,lo8(statusMsg)
 12846 487c 90E0      		ldi r25,hi8(statusMsg)
 12847 487e 0E94 0000 		call strcat
 12848               	.LVL1088:
1285:switcherator.c ****     sendMessage(statusMsg);
 12849               		.loc 1 1285 0
 12850 4882 80E0      		ldi r24,lo8(statusMsg)
 12851 4884 90E0      		ldi r25,hi8(statusMsg)
 12852               	/* epilogue start */
1286:switcherator.c **** }
 12853               		.loc 1 1286 0
 12854 4886 DF91      		pop r29
 12855 4888 CF91      		pop r28
 12856               	.LVL1089:
 12857 488a 1F91      		pop r17
 12858 488c 0F91      		pop r16
 12859               	.LVL1090:
 12860 488e FF90      		pop r15
 12861 4890 EF90      		pop r14
 12862               	.LVL1091:
 12863 4892 DF90      		pop r13
 12864 4894 CF90      		pop r12
 12865               	.LVL1092:
 12866 4896 BF90      		pop r11
 12867 4898 AF90      		pop r10
1285:switcherator.c ****     sendMessage(statusMsg);
 12868               		.loc 1 1285 0
 12869 489a 0C94 0000 		jmp sendMessage
 12870               	.LVL1093:
 12871               	.L879:
1242:switcherator.c ****         fail(8);
 12872               		.loc 1 1242 0
 12873 489e 88E0      		ldi r24,lo8(8)
 12874 48a0 90E0      		ldi r25,0
 12875               	.LVL1094:
 12876               	.L881:
 12877               	/* epilogue start */
1286:switcherator.c **** }
 12878               		.loc 1 1286 0
 12879 48a2 DF91      		pop r29
 12880 48a4 CF91      		pop r28
 12881               	.LVL1095:
 12882 48a6 1F91      		pop r17
 12883 48a8 0F91      		pop r16
 12884 48aa FF90      		pop r15
 12885 48ac EF90      		pop r14
 12886 48ae DF90      		pop r13
 12887 48b0 CF90      		pop r12
 12888 48b2 BF90      		pop r11
 12889 48b4 AF90      		pop r10
1242:switcherator.c ****         fail(8);
 12890               		.loc 1 1242 0
 12891 48b6 0C94 0000 		jmp fail
 12892               	.LVL1096:
 12893               	.L863:
1245:switcherator.c ****     clearTheProgram(programNumber);
 12894               		.loc 1 1245 0
 12895 48ba C801      		movw r24,r16
 12896 48bc 0E94 0000 		call clearTheProgram
 12897               	.LVL1097:
1246:switcherator.c ****     tempIntString[0] = commandReceived[3];
 12898               		.loc 1 1246 0
 12899 48c0 8B81      		ldd r24,Y+3
 12900 48c2 8093 0000 		sts tempIntString,r24
1247:switcherator.c ****     tempIntString[1] = commandReceived[4];
 12901               		.loc 1 1247 0
 12902 48c6 AC80      		ldd r10,Y+4
 12903 48c8 A092 0000 		sts tempIntString+1,r10
1248:switcherator.c ****     hours = atoi(tempIntString);
 12904               		.loc 1 1248 0
 12905 48cc 80E0      		ldi r24,lo8(tempIntString)
 12906 48ce 90E0      		ldi r25,hi8(tempIntString)
 12907 48d0 0E94 0000 		call atoi
 12908               	.LVL1098:
 12909 48d4 7C01      		movw r14,r24
 12910               	.LVL1099:
1249:switcherator.c ****     tempIntString[0] = commandReceived[5];
 12911               		.loc 1 1249 0
 12912 48d6 8D81      		ldd r24,Y+5
 12913 48d8 8093 0000 		sts tempIntString,r24
1250:switcherator.c ****     tempIntString[1] = commandReceived[6];
 12914               		.loc 1 1250 0
 12915 48dc BE80      		ldd r11,Y+6
 12916 48de B092 0000 		sts tempIntString+1,r11
1251:switcherator.c ****     minutes = atoi(tempIntString);
 12917               		.loc 1 1251 0
 12918 48e2 80E0      		ldi r24,lo8(tempIntString)
 12919 48e4 90E0      		ldi r25,hi8(tempIntString)
 12920 48e6 0E94 0000 		call atoi
 12921               	.LVL1100:
 12922 48ea 6C01      		movw r12,r24
 12923               	.LVL1101:
1252:switcherator.c ****     tempLongString[0] = commandReceived[7];
 12924               		.loc 1 1252 0
 12925 48ec 8F81      		ldd r24,Y+7
 12926 48ee 8093 0000 		sts tempLongString,r24
1253:switcherator.c ****     tempLongString[1] = commandReceived[8];
 12927               		.loc 1 1253 0
 12928 48f2 8885      		ldd r24,Y+8
 12929 48f4 8093 0000 		sts tempLongString+1,r24
1254:switcherator.c ****     tempLongString[2] = commandReceived[9];
 12930               		.loc 1 1254 0
 12931 48f8 8985      		ldd r24,Y+9
 12932 48fa 8093 0000 		sts tempLongString+2,r24
1255:switcherator.c ****     tempLongString[3] = commandReceived[10];
 12933               		.loc 1 1255 0
 12934 48fe 8A85      		ldd r24,Y+10
 12935 4900 8093 0000 		sts tempLongString+3,r24
1256:switcherator.c ****     duration = atoi(tempLongString);
 12936               		.loc 1 1256 0
 12937 4904 80E0      		ldi r24,lo8(tempLongString)
 12938 4906 90E0      		ldi r25,hi8(tempLongString)
 12939 4908 0E94 0000 		call atoi
 12940               	.LVL1102:
1257:switcherator.c ****     if (hours >= 24 || (hours == 0 && commandReceived[4] != '0')) {
 12941               		.loc 1 1257 0
 12942 490c 28E1      		ldi r18,24
 12943 490e E216      		cp r14,r18
 12944 4910 F104      		cpc r15,__zero_reg__
 12945 4912 04F4      		brge .+2
 12946 4914 00C0      		rjmp .L880
 12947 4916 00C0      		rjmp .L870
 12948               	.LFE31:
 12950               	.global	switchBrightness
 12952               	switchBrightness:
 12953               	.LFB18:
 777:switcherator.c **** void switchBrightness(char * commandReceived) {
 12954               		.loc 1 777 0
 12955               	.LVL1103:
 12956 4918 FF92      		push r15
 12957               	.LCFI351:
 12958 491a 0F93      		push r16
 12959               	.LCFI352:
 12960 491c 1F93      		push r17
 12961               	.LCFI353:
 12962 491e CF93      		push r28
 12963               	.LCFI354:
 12964 4920 DF93      		push r29
 12965               	.LCFI355:
 12966               	/* prologue: function */
 12967               	/* frame size = 0 */
 12968               	/* stack size = 5 */
 12969               	.L__stack_usage = 5
 12970 4922 8C01      		movw r16,r24
 778:switcherator.c ****     int switchNumber = getSwitchNumber(commandReceived);
 12971               		.loc 1 778 0
 12972 4924 0E94 0000 		call getSwitchNumber
 12973               	.LVL1104:
 12974 4928 EC01      		movw r28,r24
 12975               	.LVL1105:
 780:switcherator.c ****     if (switchNumber >= NUM_SWITCHES) {
 12976               		.loc 1 780 0
 12977 492a 8031      		cpi r24,16
 12978 492c 9105      		cpc r25,__zero_reg__
 12979 492e 04F0      		brlt .L883
 781:switcherator.c ****         fail(1);
 12980               		.loc 1 781 0
 12981 4930 81E0      		ldi r24,lo8(1)
 12982 4932 90E0      		ldi r25,0
 12983               	.LVL1106:
 12984               	/* epilogue start */
 803:switcherator.c **** }
 12985               		.loc 1 803 0
 12986 4934 DF91      		pop r29
 12987 4936 CF91      		pop r28
 12988               	.LVL1107:
 12989 4938 1F91      		pop r17
 12990 493a 0F91      		pop r16
 12991               	.LVL1108:
 12992 493c FF90      		pop r15
 781:switcherator.c ****         fail(1);
 12993               		.loc 1 781 0
 12994 493e 0C94 0000 		jmp fail
 12995               	.LVL1109:
 12996               	.L883:
 784:switcherator.c ****     tempIntString[0] = commandReceived[5];
 12997               		.loc 1 784 0
 12998 4942 F801      		movw r30,r16
 12999 4944 8581      		ldd r24,Z+5
 13000               	.LVL1110:
 13001 4946 8093 0000 		sts tempIntString,r24
 785:switcherator.c ****     tempIntString[1] = commandReceived[6];
 13002               		.loc 1 785 0
 13003 494a 8681      		ldd r24,Z+6
 13004 494c 8093 0000 		sts tempIntString+1,r24
 786:switcherator.c ****     char brightValue = atoi(tempIntString);
 13005               		.loc 1 786 0
 13006 4950 80E0      		ldi r24,lo8(tempIntString)
 13007 4952 90E0      		ldi r25,hi8(tempIntString)
 13008 4954 0E94 0000 		call atoi
 13009               	.LVL1111:
 13010 4958 F82E      		mov r15,r24
 13011               	.LVL1112:
 13012 495a 8E01      		movw r16,r28
 13013               	.LVL1113:
 13014 495c 0050      		subi r16,lo8(-(switchBright))
 13015 495e 1040      		sbci r17,hi8(-(switchBright))
 787:switcherator.c ****     if (brightValue == 0) {
 13016               		.loc 1 787 0
 13017 4960 8111      		cpse r24,__zero_reg__
 13018 4962 00C0      		rjmp .L884
 13019               	.LVL1114:
 789:switcherator.c ****         itoa(tempBright, tempIntString, 10);
 13020               		.loc 1 789 0
 13021 4964 4AE0      		ldi r20,lo8(10)
 13022 4966 50E0      		ldi r21,0
 13023 4968 60E0      		ldi r22,lo8(tempIntString)
 13024 496a 70E0      		ldi r23,hi8(tempIntString)
 13025 496c F801      		movw r30,r16
 13026 496e 8081      		ld r24,Z
 13027 4970 90E0      		ldi r25,0
 13028 4972 0E94 0000 		call itoa
 13029               	.LVL1115:
 790:switcherator.c ****         statusMsg[0] = 0;
 13030               		.loc 1 790 0
 13031 4976 1092 0000 		sts statusMsg,__zero_reg__
 791:switcherator.c ****         strcat(statusMsg, "Set @");
 13032               		.loc 1 791 0
 13033 497a 60E0      		ldi r22,lo8(.LC66)
 13034 497c 70E0      		ldi r23,hi8(.LC66)
 13035 497e 80E0      		ldi r24,lo8(statusMsg)
 13036 4980 90E0      		ldi r25,hi8(statusMsg)
 13037 4982 0E94 0000 		call strcat
 13038               	.LVL1116:
 792:switcherator.c ****         strcat(statusMsg, tempIntString);
 13039               		.loc 1 792 0
 13040 4986 60E0      		ldi r22,lo8(tempIntString)
 13041 4988 70E0      		ldi r23,hi8(tempIntString)
 13042 498a 80E0      		ldi r24,lo8(statusMsg)
 13043 498c 90E0      		ldi r25,hi8(statusMsg)
 13044 498e 0E94 0000 		call strcat
 13045               	.LVL1117:
 793:switcherator.c ****         sendMessage(statusMsg);
 13046               		.loc 1 793 0
 13047 4992 80E0      		ldi r24,lo8(statusMsg)
 13048 4994 90E0      		ldi r25,hi8(statusMsg)
 13049               	/* epilogue start */
 803:switcherator.c **** }
 13050               		.loc 1 803 0
 13051 4996 DF91      		pop r29
 13052 4998 CF91      		pop r28
 13053               	.LVL1118:
 13054 499a 1F91      		pop r17
 13055 499c 0F91      		pop r16
 13056               	.LVL1119:
 13057 499e FF90      		pop r15
 13058               	.LVL1120:
 793:switcherator.c ****         sendMessage(statusMsg);
 13059               		.loc 1 793 0
 13060 49a0 0C94 0000 		jmp sendMessage
 13061               	.LVL1121:
 13062               	.L884:
 797:switcherator.c ****         clearTheSwitch(switchNumber);
 13063               		.loc 1 797 0
 13064 49a4 CE01      		movw r24,r28
 13065 49a6 0E94 0000 		call clearTheSwitch
 13066               	.LVL1122:
 799:switcherator.c ****         switchStuff[switchNumber] = 212;
 13067               		.loc 1 799 0
 13068 49aa C050      		subi r28,lo8(-(switchStuff))
 13069 49ac D040      		sbci r29,hi8(-(switchStuff))
 13070               	.LVL1123:
 13071 49ae 84ED      		ldi r24,lo8(-44)
 13072 49b0 8883      		st Y,r24
 800:switcherator.c ****         switchBright[switchNumber] = brightValue;
 13073               		.loc 1 800 0
 13074 49b2 8F2D      		mov r24,r15
 13075 49b4 8131      		cpi r24,lo8(17)
 13076 49b6 00F0      		brlo .L885
 13077 49b8 80E1      		ldi r24,lo8(16)
 13078               	.L885:
 13079 49ba F801      		movw r30,r16
 13080 49bc 8083      		st Z,r24
 13081               	/* epilogue start */
 803:switcherator.c **** }
 13082               		.loc 1 803 0
 13083 49be DF91      		pop r29
 13084 49c0 CF91      		pop r28
 13085 49c2 1F91      		pop r17
 13086 49c4 0F91      		pop r16
 13087               	.LVL1124:
 13088 49c6 FF90      		pop r15
 13089               	.LVL1125:
 801:switcherator.c ****         ok();
 13090               		.loc 1 801 0
 13091 49c8 0C94 0000 		jmp ok
 13092               	.LVL1126:
 13093               	.LFE18:
 13095               	.global	radioTest
 13097               	radioTest:
 13098               	.LFB72:
2919:switcherator.c **** int radioTest(void) {
 13099               		.loc 1 2919 0
 13100 49cc AF92      		push r10
 13101               	.LCFI356:
 13102 49ce BF92      		push r11
 13103               	.LCFI357:
 13104 49d0 CF92      		push r12
 13105               	.LCFI358:
 13106 49d2 DF92      		push r13
 13107               	.LCFI359:
 13108 49d4 EF92      		push r14
 13109               	.LCFI360:
 13110 49d6 FF92      		push r15
 13111               	.LCFI361:
 13112 49d8 0F93      		push r16
 13113               	.LCFI362:
 13114 49da 1F93      		push r17
 13115               	.LCFI363:
 13116               	/* prologue: function */
 13117               	/* frame size = 0 */
 13118               	/* stack size = 8 */
 13119               	.L__stack_usage = 8
2921:switcherator.c ****     test_addr = readAddr(RX_ADDR_P0);    
 13120               		.loc 1 2921 0
 13121 49dc 8AE0      		ldi r24,lo8(10)
 13122 49de 0E94 0000 		call readAddr
 13123               	.LVL1127:
2922:switcherator.c ****     if (test_addr != rx_addr_p0) {
 13124               		.loc 1 2922 0
 13125 49e2 A090 0000 		lds r10,rx_addr_p0
 13126 49e6 B090 0000 		lds r11,rx_addr_p0+1
 13127 49ea C090 0000 		lds r12,rx_addr_p0+2
 13128 49ee D090 0000 		lds r13,rx_addr_p0+3
 13129 49f2 E090 0000 		lds r14,rx_addr_p0+4
 13130 49f6 F090 0000 		lds r15,rx_addr_p0+5
 13131 49fa 0091 0000 		lds r16,rx_addr_p0+6
 13132 49fe 1091 0000 		lds r17,rx_addr_p0+7
 13133 4a02 0E94 0000 		call __cmpdi2
 13134 4a06 01F0      		breq .L887
2924:switcherator.c ****         failCondition = 1;
 13135               		.loc 1 2924 0
 13136 4a08 81E0      		ldi r24,lo8(1)
 13137               	.LVL1128:
 13138 4a0a 8093 0000 		sts failCondition,r24
2925:switcherator.c ****         return -1;
 13139               		.loc 1 2925 0
 13140 4a0e 2FEF      		ldi r18,lo8(-1)
 13141 4a10 3FEF      		ldi r19,lo8(-1)
 13142 4a12 00C0      		rjmp .L888
 13143               	.LVL1129:
 13144               	.L887:
2927:switcherator.c ****     if(failCondition == 1 || failCondition == 2)
 13145               		.loc 1 2927 0
 13146 4a14 8091 0000 		lds r24,failCondition
 13147               	.LVL1130:
 13148 4a18 8150      		subi r24,lo8(-(-1))
 13149 4a1a 8230      		cpi r24,lo8(2)
 13150 4a1c 00F4      		brsh .L889
2928:switcherator.c ****         clearFail();
 13151               		.loc 1 2928 0
 13152 4a1e 0E94 0000 		call clearFail
 13153               	.LVL1131:
 13154               	.L889:
2929:switcherator.c ****     return 1;
 13155               		.loc 1 2929 0
 13156 4a22 21E0      		ldi r18,lo8(1)
 13157 4a24 30E0      		ldi r19,0
 13158               	.L888:
2930:switcherator.c **** }
 13159               		.loc 1 2930 0
 13160 4a26 C901      		movw r24,r18
 13161               	/* epilogue start */
 13162 4a28 1F91      		pop r17
 13163 4a2a 0F91      		pop r16
 13164 4a2c FF90      		pop r15
 13165 4a2e EF90      		pop r14
 13166 4a30 DF90      		pop r13
 13167 4a32 CF90      		pop r12
 13168 4a34 BF90      		pop r11
 13169 4a36 AF90      		pop r10
 13170 4a38 0895      		ret
 13171               	.LFE72:
 13173               	.global	radioInit
 13175               	radioInit:
 13176               	.LFB71:
2891:switcherator.c **** void radioInit(void) {
 13177               		.loc 1 2891 0
 13178 4a3a 0F93      		push r16
 13179               	.LCFI364:
 13180 4a3c 1F93      		push r17
 13181               	.LCFI365:
 13182               	/* prologue: function */
 13183               	/* frame size = 0 */
 13184               	/* stack size = 2 */
 13185               	.L__stack_usage = 2
2892:switcherator.c ****     nrfInit();
 13186               		.loc 1 2892 0
 13187 4a3e 0E94 0000 		call nrfInit
 13188               	.LVL1132:
2893:switcherator.c ****     rx_addr_p0 = SET_RX_ADDR_P0;
 13189               		.loc 1 2893 0
 13190 4a42 91E0      		ldi r25,lo8(1)
 13191 4a44 9093 0000 		sts rx_addr_p0,r25
 13192 4a48 80EF      		ldi r24,lo8(-16)
 13193 4a4a 8093 0000 		sts rx_addr_p0+1,r24
 13194 4a4e 8093 0000 		sts rx_addr_p0+2,r24
 13195 4a52 8093 0000 		sts rx_addr_p0+3,r24
 13196 4a56 8093 0000 		sts rx_addr_p0+4,r24
 13197 4a5a 1092 0000 		sts rx_addr_p0+5,__zero_reg__
 13198 4a5e 1092 0000 		sts rx_addr_p0+6,__zero_reg__
 13199 4a62 1092 0000 		sts rx_addr_p0+7,__zero_reg__
2894:switcherator.c ****     tx_addr = SET_TX_ADDR;
 13200               		.loc 1 2894 0
 13201 4a66 9093 0000 		sts tx_addr,r25
 13202 4a6a 8093 0000 		sts tx_addr+1,r24
 13203 4a6e 8093 0000 		sts tx_addr+2,r24
 13204 4a72 8093 0000 		sts tx_addr+3,r24
 13205 4a76 8093 0000 		sts tx_addr+4,r24
 13206 4a7a 1092 0000 		sts tx_addr+5,__zero_reg__
 13207 4a7e 1092 0000 		sts tx_addr+6,__zero_reg__
 13208 4a82 1092 0000 		sts tx_addr+7,__zero_reg__
2896:switcherator.c ****     rx_addr_p1 = readAddr(RX_ADDR_P1);
 13209               		.loc 1 2896 0
 13210 4a86 8BE0      		ldi r24,lo8(11)
 13211 4a88 0E94 0000 		call readAddr
 13212               	.LVL1133:
 13213 4a8c 2093 0000 		sts rx_addr_p1,r18
 13214 4a90 3093 0000 		sts rx_addr_p1+1,r19
 13215 4a94 4093 0000 		sts rx_addr_p1+2,r20
 13216 4a98 5093 0000 		sts rx_addr_p1+3,r21
 13217 4a9c 6093 0000 		sts rx_addr_p1+4,r22
 13218 4aa0 7093 0000 		sts rx_addr_p1+5,r23
 13219 4aa4 8093 0000 		sts rx_addr_p1+6,r24
 13220 4aa8 9093 0000 		sts rx_addr_p1+7,r25
2897:switcherator.c ****     rx_addr_p2 = readAddr(RX_ADDR_P2);
 13221               		.loc 1 2897 0
 13222 4aac 8CE0      		ldi r24,lo8(12)
 13223 4aae 0E94 0000 		call readAddr
 13224               	.LVL1134:
 13225 4ab2 2093 0000 		sts rx_addr_p2,r18
 13226 4ab6 3093 0000 		sts rx_addr_p2+1,r19
 13227 4aba 4093 0000 		sts rx_addr_p2+2,r20
 13228 4abe 5093 0000 		sts rx_addr_p2+3,r21
 13229 4ac2 6093 0000 		sts rx_addr_p2+4,r22
 13230 4ac6 7093 0000 		sts rx_addr_p2+5,r23
 13231 4aca 8093 0000 		sts rx_addr_p2+6,r24
 13232 4ace 9093 0000 		sts rx_addr_p2+7,r25
2898:switcherator.c ****     rx_addr_p3 = readAddr(RX_ADDR_P3);
 13233               		.loc 1 2898 0
 13234 4ad2 8DE0      		ldi r24,lo8(13)
 13235 4ad4 0E94 0000 		call readAddr
 13236               	.LVL1135:
 13237 4ad8 2093 0000 		sts rx_addr_p3,r18
 13238 4adc 3093 0000 		sts rx_addr_p3+1,r19
 13239 4ae0 4093 0000 		sts rx_addr_p3+2,r20
 13240 4ae4 5093 0000 		sts rx_addr_p3+3,r21
 13241 4ae8 6093 0000 		sts rx_addr_p3+4,r22
 13242 4aec 7093 0000 		sts rx_addr_p3+5,r23
 13243 4af0 8093 0000 		sts rx_addr_p3+6,r24
 13244 4af4 9093 0000 		sts rx_addr_p3+7,r25
2899:switcherator.c ****     rx_addr_p4 = readAddr(RX_ADDR_P4);
 13245               		.loc 1 2899 0
 13246 4af8 8EE0      		ldi r24,lo8(14)
 13247 4afa 0E94 0000 		call readAddr
 13248               	.LVL1136:
 13249 4afe 2093 0000 		sts rx_addr_p4,r18
 13250 4b02 3093 0000 		sts rx_addr_p4+1,r19
 13251 4b06 4093 0000 		sts rx_addr_p4+2,r20
 13252 4b0a 5093 0000 		sts rx_addr_p4+3,r21
 13253 4b0e 6093 0000 		sts rx_addr_p4+4,r22
 13254 4b12 7093 0000 		sts rx_addr_p4+5,r23
 13255 4b16 8093 0000 		sts rx_addr_p4+6,r24
 13256 4b1a 9093 0000 		sts rx_addr_p4+7,r25
2900:switcherator.c ****     rx_addr_p5 = readAddr(RX_ADDR_P5);
 13257               		.loc 1 2900 0
 13258 4b1e 8FE0      		ldi r24,lo8(15)
 13259 4b20 0E94 0000 		call readAddr
 13260               	.LVL1137:
 13261 4b24 2093 0000 		sts rx_addr_p5,r18
 13262 4b28 3093 0000 		sts rx_addr_p5+1,r19
 13263 4b2c 4093 0000 		sts rx_addr_p5+2,r20
 13264 4b30 5093 0000 		sts rx_addr_p5+3,r21
 13265 4b34 6093 0000 		sts rx_addr_p5+4,r22
 13266 4b38 7093 0000 		sts rx_addr_p5+5,r23
 13267 4b3c 8093 0000 		sts rx_addr_p5+6,r24
 13268 4b40 9093 0000 		sts rx_addr_p5+7,r25
2902:switcherator.c ****     writeReg(RF_SETUP, SET_RF_SETUP);
 13269               		.loc 1 2902 0
 13270 4b44 66E0      		ldi r22,lo8(6)
 13271 4b46 86E0      		ldi r24,lo8(6)
 13272 4b48 0E94 0000 		call writeReg
 13273               	.LVL1138:
2903:switcherator.c ****     writeAddr(RX_ADDR_P0, rx_addr_p0);
 13274               		.loc 1 2903 0
 13275 4b4c 0091 0000 		lds r16,rx_addr_p0
 13276 4b50 1091 0000 		lds r17,rx_addr_p0+1
 13277 4b54 2091 0000 		lds r18,rx_addr_p0+2
 13278 4b58 3091 0000 		lds r19,rx_addr_p0+3
 13279 4b5c 4091 0000 		lds r20,rx_addr_p0+4
 13280 4b60 5091 0000 		lds r21,rx_addr_p0+5
 13281 4b64 6091 0000 		lds r22,rx_addr_p0+6
 13282 4b68 7091 0000 		lds r23,rx_addr_p0+7
 13283 4b6c 8AE0      		ldi r24,lo8(10)
 13284 4b6e 0E94 0000 		call writeAddr
 13285               	.LVL1139:
2904:switcherator.c ****     writeAddr(TX_ADDR, tx_addr);
 13286               		.loc 1 2904 0
 13287 4b72 0091 0000 		lds r16,tx_addr
 13288 4b76 1091 0000 		lds r17,tx_addr+1
 13289 4b7a 2091 0000 		lds r18,tx_addr+2
 13290 4b7e 3091 0000 		lds r19,tx_addr+3
 13291 4b82 4091 0000 		lds r20,tx_addr+4
 13292 4b86 5091 0000 		lds r21,tx_addr+5
 13293 4b8a 6091 0000 		lds r22,tx_addr+6
 13294 4b8e 7091 0000 		lds r23,tx_addr+7
 13295 4b92 80E1      		ldi r24,lo8(16)
 13296 4b94 0E94 0000 		call writeAddr
 13297               	.LVL1140:
2905:switcherator.c ****     writeReg(DYNPD, SET_DYNPD);
 13298               		.loc 1 2905 0
 13299 4b98 6FE3      		ldi r22,lo8(63)
 13300 4b9a 8CE1      		ldi r24,lo8(28)
 13301 4b9c 0E94 0000 		call writeReg
 13302               	.LVL1141:
2906:switcherator.c ****     writeReg(FEATURE, SET_FEATURE);
 13303               		.loc 1 2906 0
 13304 4ba0 64E0      		ldi r22,lo8(4)
 13305 4ba2 8DE1      		ldi r24,lo8(29)
 13306 4ba4 0E94 0000 		call writeReg
 13307               	.LVL1142:
2907:switcherator.c ****     writeReg(RF_CH, SET_RF_CH);
 13308               		.loc 1 2907 0
 13309 4ba8 6AE2      		ldi r22,lo8(42)
 13310 4baa 85E0      		ldi r24,lo8(5)
 13311 4bac 0E94 0000 		call writeReg
 13312               	.LVL1143:
2908:switcherator.c ****     writeReg(CONFIG, SET_CONFIG);
 13313               		.loc 1 2908 0
 13314 4bb0 68E0      		ldi r22,lo8(8)
 13315 4bb2 80E0      		ldi r24,0
 13316 4bb4 0E94 0000 		call writeReg
 13317               	.LVL1144:
2909:switcherator.c ****     writeReg(SETUP_RETR, SET_SETUP_RETR);
 13318               		.loc 1 2909 0
 13319 4bb8 6FE0      		ldi r22,lo8(15)
 13320 4bba 84E0      		ldi r24,lo8(4)
 13321 4bbc 0E94 0000 		call writeReg
 13322               	.LVL1145:
2912:switcherator.c ****     radioTest();
 13323               		.loc 1 2912 0
 13324 4bc0 0E94 0000 		call radioTest
 13325               	.LVL1146:
 13326               	/* epilogue start */
2916:switcherator.c **** }
 13327               		.loc 1 2916 0
 13328 4bc4 1F91      		pop r17
 13329 4bc6 0F91      		pop r16
2914:switcherator.c ****     startRadio();
 13330               		.loc 1 2914 0
 13331 4bc8 0C94 0000 		jmp startRadio
 13332               	.LVL1147:
 13333               	.LFE71:
 13335               	.global	setClock
 13337               	setClock:
 13338               	.LFB49:
2143:switcherator.c **** void setClock(char * commandReceived) {
 13339               		.loc 1 2143 0
 13340               	.LVL1148:
 13341 4bcc 6F92      		push r6
 13342               	.LCFI366:
 13343 4bce 7F92      		push r7
 13344               	.LCFI367:
 13345 4bd0 8F92      		push r8
 13346               	.LCFI368:
 13347 4bd2 9F92      		push r9
 13348               	.LCFI369:
 13349 4bd4 AF92      		push r10
 13350               	.LCFI370:
 13351 4bd6 BF92      		push r11
 13352               	.LCFI371:
 13353 4bd8 CF92      		push r12
 13354               	.LCFI372:
 13355 4bda DF92      		push r13
 13356               	.LCFI373:
 13357 4bdc EF92      		push r14
 13358               	.LCFI374:
 13359 4bde FF92      		push r15
 13360               	.LCFI375:
 13361 4be0 0F93      		push r16
 13362               	.LCFI376:
 13363 4be2 1F93      		push r17
 13364               	.LCFI377:
 13365 4be4 CF93      		push r28
 13366               	.LCFI378:
 13367 4be6 DF93      		push r29
 13368               	.LCFI379:
 13369               	/* prologue: function */
 13370               	/* frame size = 0 */
 13371               	/* stack size = 14 */
 13372               	.L__stack_usage = 14
 13373 4be8 EC01      		movw r28,r24
2146:switcherator.c ****     tempLongString[0] = '0';
 13374               		.loc 1 2146 0
 13375 4bea 80E3      		ldi r24,lo8(48)
 13376               	.LVL1149:
 13377 4bec 8093 0000 		sts tempLongString,r24
2147:switcherator.c ****     tempLongString[1] = '0';
 13378               		.loc 1 2147 0
 13379 4bf0 8093 0000 		sts tempLongString+1,r24
2150:switcherator.c ****     tempLongString[2] = commandReceived[3];
 13380               		.loc 1 2150 0
 13381 4bf4 8B81      		ldd r24,Y+3
 13382 4bf6 8093 0000 		sts tempLongString+2,r24
2151:switcherator.c ****     tempLongString[3] = commandReceived[4];
 13383               		.loc 1 2151 0
 13384 4bfa 8C81      		ldd r24,Y+4
 13385 4bfc 8093 0000 		sts tempLongString+3,r24
2152:switcherator.c ****     globalMonth = atoi(tempLongString);
 13386               		.loc 1 2152 0
 13387 4c00 80E0      		ldi r24,lo8(tempLongString)
 13388 4c02 90E0      		ldi r25,hi8(tempLongString)
 13389 4c04 0E94 0000 		call atoi
 13390               	.LVL1150:
 13391 4c08 6C01      		movw r12,r24
 13392 4c0a 9093 0000 		sts globalMonth+1,r25
 13393 4c0e 8093 0000 		sts globalMonth,r24
2154:switcherator.c ****     tempLongString[2] = commandReceived[5];
 13394               		.loc 1 2154 0
 13395 4c12 8D81      		ldd r24,Y+5
 13396 4c14 8093 0000 		sts tempLongString+2,r24
2155:switcherator.c ****     tempLongString[3] = commandReceived[6];
 13397               		.loc 1 2155 0
 13398 4c18 8E81      		ldd r24,Y+6
 13399 4c1a 8093 0000 		sts tempLongString+3,r24
2156:switcherator.c ****     globalDay = atoi(tempLongString);
 13400               		.loc 1 2156 0
 13401 4c1e 80E0      		ldi r24,lo8(tempLongString)
 13402 4c20 90E0      		ldi r25,hi8(tempLongString)
 13403 4c22 0E94 0000 		call atoi
 13404               	.LVL1151:
 13405 4c26 8C01      		movw r16,r24
 13406 4c28 9093 0000 		sts globalDay+1,r25
 13407 4c2c 8093 0000 		sts globalDay,r24
2158:switcherator.c ****     tempLongString[2] = commandReceived[11];
 13408               		.loc 1 2158 0
 13409 4c30 8B85      		ldd r24,Y+11
 13410 4c32 8093 0000 		sts tempLongString+2,r24
2159:switcherator.c ****     tempLongString[3] = commandReceived[12];
 13411               		.loc 1 2159 0
 13412 4c36 8C85      		ldd r24,Y+12
 13413 4c38 8093 0000 		sts tempLongString+3,r24
2160:switcherator.c ****     globalHour = atoi(tempLongString);
 13414               		.loc 1 2160 0
 13415 4c3c 80E0      		ldi r24,lo8(tempLongString)
 13416 4c3e 90E0      		ldi r25,hi8(tempLongString)
 13417 4c40 0E94 0000 		call atoi
 13418               	.LVL1152:
 13419 4c44 4C01      		movw r8,r24
 13420 4c46 8093 0000 		sts globalHour,r24
 13421 4c4a 9092 0000 		sts globalHour+1,r9
2162:switcherator.c ****     tempLongString[2] = commandReceived[13];
 13422               		.loc 1 2162 0
 13423 4c4e 8D85      		ldd r24,Y+13
 13424 4c50 8093 0000 		sts tempLongString+2,r24
2163:switcherator.c ****     tempLongString[3] = commandReceived[14];
 13425               		.loc 1 2163 0
 13426 4c54 8E85      		ldd r24,Y+14
 13427 4c56 8093 0000 		sts tempLongString+3,r24
2164:switcherator.c ****     globalMinute = atoi(tempLongString);
 13428               		.loc 1 2164 0
 13429 4c5a 80E0      		ldi r24,lo8(tempLongString)
 13430 4c5c 90E0      		ldi r25,hi8(tempLongString)
 13431 4c5e 0E94 0000 		call atoi
 13432               	.LVL1153:
 13433 4c62 5C01      		movw r10,r24
 13434 4c64 8093 0000 		sts globalMinute,r24
 13435 4c68 B092 0000 		sts globalMinute+1,r11
2166:switcherator.c ****     tempLongString[2] = commandReceived[15];
 13436               		.loc 1 2166 0
 13437 4c6c 8F85      		ldd r24,Y+15
 13438 4c6e 8093 0000 		sts tempLongString+2,r24
2167:switcherator.c ****     tempLongString[3] = commandReceived[16];
 13439               		.loc 1 2167 0
 13440 4c72 8889      		ldd r24,Y+16
 13441 4c74 8093 0000 		sts tempLongString+3,r24
2168:switcherator.c ****     globalSecond = atoi(tempLongString);
 13442               		.loc 1 2168 0
 13443 4c78 80E0      		ldi r24,lo8(tempLongString)
 13444 4c7a 90E0      		ldi r25,hi8(tempLongString)
 13445 4c7c 0E94 0000 		call atoi
 13446               	.LVL1154:
 13447 4c80 3C01      		movw r6,r24
 13448 4c82 9093 0000 		sts globalSecond+1,r25
 13449 4c86 8093 0000 		sts globalSecond,r24
2170:switcherator.c ****     tempLongString[0] = commandReceived[7];
 13450               		.loc 1 2170 0
 13451 4c8a 8F81      		ldd r24,Y+7
 13452 4c8c 8093 0000 		sts tempLongString,r24
2171:switcherator.c ****     tempLongString[1] = commandReceived[8];
 13453               		.loc 1 2171 0
 13454 4c90 8885      		ldd r24,Y+8
 13455 4c92 8093 0000 		sts tempLongString+1,r24
2172:switcherator.c ****     tempLongString[2] = commandReceived[9];
 13456               		.loc 1 2172 0
 13457 4c96 8985      		ldd r24,Y+9
 13458 4c98 8093 0000 		sts tempLongString+2,r24
2173:switcherator.c ****     tempLongString[3] = commandReceived[10];
 13459               		.loc 1 2173 0
 13460 4c9c 8A85      		ldd r24,Y+10
 13461 4c9e 8093 0000 		sts tempLongString+3,r24
2174:switcherator.c ****     globalYear = atoi(tempLongString);
 13462               		.loc 1 2174 0
 13463 4ca2 80E0      		ldi r24,lo8(tempLongString)
 13464 4ca4 90E0      		ldi r25,hi8(tempLongString)
 13465 4ca6 0E94 0000 		call atoi
 13466               	.LVL1155:
 13467 4caa 9093 0000 		sts globalYear+1,r25
 13468 4cae 8093 0000 		sts globalYear,r24
2175:switcherator.c ****     dow = getWeekday(globalYear, globalMonth, globalDay); // get day of week
 13469               		.loc 1 2175 0
 13470 4cb2 A801      		movw r20,r16
 13471 4cb4 B601      		movw r22,r12
 13472 4cb6 0E94 0000 		call getWeekday
 13473               	.LVL1156:
 13474 4cba DC01      		movw r26,r24
 13475 4cbc 8093 0000 		sts dow,r24
 13476 4cc0 B093 0000 		sts dow+1,r27
 13477               	.LVL1157:
2177:switcherator.c ****     tempInt = tempInt * 24 * 60 * 60;
 13478               		.loc 1 2177 0
 13479 4cc4 20E8      		ldi r18,lo8(-128)
 13480 4cc6 31E5      		ldi r19,lo8(81)
 13481 4cc8 41E0      		ldi r20,lo8(1)
 13482 4cca 50E0      		ldi r21,0
 13483 4ccc 0E94 0000 		call __muluhisi3
 13484 4cd0 6B01      		movw r12,r22
 13485 4cd2 7C01      		movw r14,r24
2180:switcherator.c ****     tempInt = tempInt * 60 * 60;
 13486               		.loc 1 2180 0
 13487 4cd4 9401      		movw r18,r8
 13488 4cd6 A0E1      		ldi r26,lo8(16)
 13489 4cd8 BEE0      		ldi r27,lo8(14)
 13490 4cda 0E94 0000 		call __umulhisi3
2181:switcherator.c ****     weeklySeconds += tempInt;
 13491               		.loc 1 2181 0
 13492 4cde C60E      		add r12,r22
 13493 4ce0 D71E      		adc r13,r23
 13494 4ce2 E81E      		adc r14,r24
 13495 4ce4 F91E      		adc r15,r25
2184:switcherator.c ****     weeklySeconds += tempInt;
 13496               		.loc 1 2184 0
 13497 4ce6 C60C      		add r12,r6
 13498 4ce8 D71C      		adc r13,r7
 13499 4cea E11C      		adc r14,__zero_reg__
 13500 4cec F11C      		adc r15,__zero_reg__
2183:switcherator.c ****     tempInt = tempInt * 60;
 13501               		.loc 1 2183 0
 13502 4cee 9501      		movw r18,r10
 13503 4cf0 ACE3      		ldi r26,lo8(60)
 13504 4cf2 B0E0      		ldi r27,0
 13505 4cf4 0E94 0000 		call __umulhisi3
2185:switcherator.c ****     weeklySeconds += globalSecond;
 13506               		.loc 1 2185 0
 13507 4cf8 C60E      		add r12,r22
 13508 4cfa D71E      		adc r13,r23
 13509 4cfc E81E      		adc r14,r24
 13510 4cfe F91E      		adc r15,r25
 13511 4d00 C092 0000 		sts weeklySeconds,r12
 13512 4d04 D092 0000 		sts weeklySeconds+1,r13
 13513 4d08 E092 0000 		sts weeklySeconds+2,r14
 13514 4d0c F092 0000 		sts weeklySeconds+3,r15
2186:switcherator.c ****     clockString();
 13515               		.loc 1 2186 0
 13516 4d10 0E94 0000 		call clockString
 13517               	.LVL1158:
2187:switcherator.c ****     sendMessage(statusMsg);
 13518               		.loc 1 2187 0
 13519 4d14 80E0      		ldi r24,lo8(statusMsg)
 13520 4d16 90E0      		ldi r25,hi8(statusMsg)
 13521 4d18 0E94 0000 		call sendMessage
 13522               	.LVL1159:
2188:switcherator.c ****     stopClock();
 13523               		.loc 1 2188 0
 13524 4d1c 0E94 0000 		call stopClock
 13525               	.LVL1160:
2189:switcherator.c ****     startClock();
 13526               		.loc 1 2189 0
 13527 4d20 0E94 0000 		call startClock
 13528               	.LVL1161:
2190:switcherator.c ****     panicMyClockIsNotSet = 0;
 13529               		.loc 1 2190 0
 13530 4d24 1092 0000 		sts panicMyClockIsNotSet,__zero_reg__
2191:switcherator.c ****     if(failCondition == 3) {
 13531               		.loc 1 2191 0
 13532 4d28 8091 0000 		lds r24,failCondition
 13533 4d2c 8330      		cpi r24,lo8(3)
 13534 4d2e 01F4      		brne .L891
 13535               	/* epilogue start */
2194:switcherator.c **** }
 13536               		.loc 1 2194 0
 13537 4d30 DF91      		pop r29
 13538 4d32 CF91      		pop r28
 13539               	.LVL1162:
 13540 4d34 1F91      		pop r17
 13541 4d36 0F91      		pop r16
 13542 4d38 FF90      		pop r15
 13543 4d3a EF90      		pop r14
 13544 4d3c DF90      		pop r13
 13545 4d3e CF90      		pop r12
 13546 4d40 BF90      		pop r11
 13547               	.LVL1163:
 13548 4d42 AF90      		pop r10
 13549 4d44 9F90      		pop r9
 13550 4d46 8F90      		pop r8
 13551 4d48 7F90      		pop r7
 13552 4d4a 6F90      		pop r6
2192:switcherator.c ****         clearFail();      
 13553               		.loc 1 2192 0
 13554 4d4c 0C94 0000 		jmp clearFail
 13555               	.LVL1164:
 13556               	.L891:
 13557               	/* epilogue start */
2194:switcherator.c **** }
 13558               		.loc 1 2194 0
 13559 4d50 DF91      		pop r29
 13560 4d52 CF91      		pop r28
 13561               	.LVL1165:
 13562 4d54 1F91      		pop r17
 13563 4d56 0F91      		pop r16
 13564 4d58 FF90      		pop r15
 13565 4d5a EF90      		pop r14
 13566 4d5c DF90      		pop r13
 13567 4d5e CF90      		pop r12
 13568 4d60 BF90      		pop r11
 13569               	.LVL1166:
 13570 4d62 AF90      		pop r10
 13571 4d64 9F90      		pop r9
 13572 4d66 8F90      		pop r8
 13573 4d68 7F90      		pop r7
 13574 4d6a 6F90      		pop r6
 13575 4d6c 0895      		ret
 13576               	.LFE49:
 13578               	.global	checkCommand
 13580               	checkCommand:
 13581               	.LFB8:
 240:switcherator.c **** void checkCommand(char * commandReceived) {
 13582               		.loc 1 240 0
 13583               	.LVL1167:
 13584               	/* prologue: function */
 13585               	/* frame size = 0 */
 13586               	/* stack size = 0 */
 13587               	.L__stack_usage = 0
 241:switcherator.c ****     if (commandReceived[0] > 0x60)
 13588               		.loc 1 241 0
 13589 4d6e FC01      		movw r30,r24
 13590 4d70 2081      		ld r18,Z
 13591 4d72 2136      		cpi r18,lo8(97)
 13592 4d74 00F0      		brlo .L894
 242:switcherator.c ****         commandReceived[0] -= 0x20;
 13593               		.loc 1 242 0
 13594 4d76 2052      		subi r18,lo8(-(-32))
 13595 4d78 2083      		st Z,r18
 13596               	.L894:
 243:switcherator.c ****     if (commandReceived[1] > 0x60)
 13597               		.loc 1 243 0
 13598 4d7a FC01      		movw r30,r24
 13599 4d7c 2181      		ldd r18,Z+1
 13600 4d7e 2136      		cpi r18,lo8(97)
 13601 4d80 00F0      		brlo .L895
 244:switcherator.c ****         commandReceived[1] -= 0x20;
 13602               		.loc 1 244 0
 13603 4d82 2052      		subi r18,lo8(-(-32))
 13604 4d84 2183      		std Z+1,r18
 13605               	.L895:
 246:switcherator.c ****     switchme <<= 8;
 13606               		.loc 1 246 0
 13607 4d86 FC01      		movw r30,r24
 13608 4d88 3081      		ld r19,Z
 13609 4d8a 20E0      		ldi r18,0
 13610               	.LVL1168:
 247:switcherator.c ****     switchme |= commandReceived[1];
 13611               		.loc 1 247 0
 13612 4d8c 4181      		ldd r20,Z+1
 13613 4d8e 242B      		or r18,r20
 13614               	.LVL1169:
 248:switcherator.c ****     switch (switchme) {
 13615               		.loc 1 248 0
 13616 4d90 2434      		cpi r18,68
 13617 4d92 F0E5      		ldi r31,80
 13618 4d94 3F07      		cpc r19,r31
 13619 4d96 01F4      		brne .+2
 13620 4d98 00C0      		rjmp .L915
 13621 4d9a 04F0      		brlt .+2
 13622 4d9c 00C0      		rjmp .L934
 13623 4d9e 2934      		cpi r18,73
 13624 4da0 E4E4      		ldi r30,68
 13625 4da2 3E07      		cpc r19,r30
 13626 4da4 01F4      		brne .+2
 13627 4da6 00C0      		rjmp .L905
 13628 4da8 04F4      		brge .L935
 13629 4daa 2834      		cpi r18,72
 13630 4dac 43E4      		ldi r20,67
 13631 4dae 3407      		cpc r19,r20
 13632 4db0 01F4      		brne .+2
 13633 4db2 00C0      		rjmp .L900
 13634 4db4 04F4      		brge .L936
 13635 4db6 2335      		cpi r18,83
 13636 4db8 F2E4      		ldi r31,66
 13637 4dba 3F07      		cpc r19,r31
 13638 4dbc 01F4      		brne .+2
 13639 4dbe 00C0      		rjmp .L898
 13640 4dc0 2334      		cpi r18,67
 13641 4dc2 43E4      		ldi r20,67
 13642 4dc4 3407      		cpc r19,r20
 13643 4dc6 01F4      		brne .+2
 13644 4dc8 00C0      		rjmp .L899
 13645 4dca 2934      		cpi r18,73
 13646 4dcc 3144      		sbci r19,65
 13647 4dce 01F0      		breq .+2
 13648 4dd0 00C0      		rjmp .L893
 13649 4dd2 00C0      		rjmp .L897
 13650               	.L936:
 13651 4dd4 2C34      		cpi r18,76
 13652 4dd6 F3E4      		ldi r31,67
 13653 4dd8 3F07      		cpc r19,r31
 13654 4dda 01F4      		brne .+2
 13655 4ddc 00C0      		rjmp .L902
 13656 4dde 04F4      		brge .L937
 13657 4de0 2934      		cpi r18,73
 13658 4de2 3344      		sbci r19,67
 13659 4de4 01F0      		breq .+2
 13660 4de6 00C0      		rjmp .L893
 13661 4de8 00C0      		rjmp .L901
 13662               	.L937:
 13663 4dea 2035      		cpi r18,80
 13664 4dec F3E4      		ldi r31,67
 13665 4dee 3F07      		cpc r19,r31
 13666 4df0 01F4      		brne .+2
 13667 4df2 00C0      		rjmp .L903
 13668 4df4 2435      		cpi r18,84
 13669 4df6 3344      		sbci r19,67
 13670 4df8 01F0      		breq .+2
 13671 4dfa 00C0      		rjmp .L893
 13672 4dfc 00C0      		rjmp .L904
 13673               	.L935:
 13674 4dfe 2334      		cpi r18,67
 13675 4e00 E9E4      		ldi r30,73
 13676 4e02 3E07      		cpc r19,r30
 13677 4e04 01F4      		brne .+2
 13678 4e06 00C0      		rjmp .L910
 13679 4e08 04F4      		brge .L938
 13680 4e0a 2934      		cpi r18,73
 13681 4e0c 47E4      		ldi r20,71
 13682 4e0e 3407      		cpc r19,r20
 13683 4e10 01F4      		brne .+2
 13684 4e12 00C0      		rjmp .L907
 13685 4e14 04F4      		brge .L939
 13686 4e16 2335      		cpi r18,83
 13687 4e18 3444      		sbci r19,68
 13688 4e1a 01F0      		breq .+2
 13689 4e1c 00C0      		rjmp .L893
 13690 4e1e 00C0      		rjmp .L906
 13691               	.L939:
 13692 4e20 2335      		cpi r18,83
 13693 4e22 47E4      		ldi r20,71
 13694 4e24 3407      		cpc r19,r20
 13695 4e26 01F4      		brne .+2
 13696 4e28 00C0      		rjmp .L908
 13697 4e2a 2436      		cpi r18,100
 13698 4e2c 3844      		sbci r19,72
 13699 4e2e 01F0      		breq .+2
 13700 4e30 00C0      		rjmp .L893
 13701 4e32 00C0      		rjmp .L909
 13702               	.L938:
 13703 4e34 2035      		cpi r18,80
 13704 4e36 FEE4      		ldi r31,78
 13705 4e38 3F07      		cpc r19,r31
 13706 4e3a 01F4      		brne .+2
 13707 4e3c 00C0      		rjmp .L912
 13708 4e3e 04F4      		brge .L940
 13709 4e40 2035      		cpi r18,80
 13710 4e42 3944      		sbci r19,73
 13711               	.LVL1170:
 13712 4e44 01F0      		breq .+2
 13713 4e46 00C0      		rjmp .L893
 13714 4e48 00C0      		rjmp .L911
 13715               	.LVL1171:
 13716               	.L940:
 13717 4e4a 2335      		cpi r18,83
 13718 4e4c EEE4      		ldi r30,78
 13719 4e4e 3E07      		cpc r19,r30
 13720 4e50 01F4      		brne .+2
 13721 4e52 00C0      		rjmp .L913
 13722 4e54 2134      		cpi r18,65
 13723 4e56 3045      		sbci r19,80
 13724 4e58 01F0      		breq .+2
 13725 4e5a 00C0      		rjmp .L893
 13726 4e5c 00C0      		rjmp .L914
 13727               	.L934:
 13728 4e5e 2134      		cpi r18,65
 13729 4e60 43E5      		ldi r20,83
 13730 4e62 3407      		cpc r19,r20
 13731 4e64 01F4      		brne .+2
 13732 4e66 00C0      		rjmp .L924
 13733 4e68 04F4      		brge .L941
 13734 4e6a 2435      		cpi r18,84
 13735 4e6c F0E5      		ldi r31,80
 13736 4e6e 3F07      		cpc r19,r31
 13737 4e70 01F4      		brne .+2
 13738 4e72 00C0      		rjmp .L919
 13739 4e74 04F4      		brge .L942
 13740 4e76 2035      		cpi r18,80
 13741 4e78 E0E5      		ldi r30,80
 13742 4e7a 3E07      		cpc r19,r30
 13743 4e7c 01F4      		brne .+2
 13744 4e7e 00C0      		rjmp .L917
 13745 4e80 2335      		cpi r18,83
 13746 4e82 F0E5      		ldi r31,80
 13747 4e84 3F07      		cpc r19,r31
 13748 4e86 01F4      		brne .+2
 13749 4e88 00C0      		rjmp .L918
 13750 4e8a 2934      		cpi r18,73
 13751 4e8c 3045      		sbci r19,80
 13752 4e8e 01F0      		breq .+2
 13753 4e90 00C0      		rjmp .L893
 13754 4e92 00C0      		rjmp .L916
 13755               	.L942:
 13756 4e94 2735      		cpi r18,87
 13757 4e96 E0E5      		ldi r30,80
 13758 4e98 3E07      		cpc r19,r30
 13759 4e9a 01F4      		brne .+2
 13760 4e9c 00C0      		rjmp .L921
 13761 4e9e 04F4      		brge .L943
 13762 4ea0 2635      		cpi r18,86
 13763 4ea2 3045      		sbci r19,80
 13764 4ea4 01F0      		breq .+2
 13765 4ea6 00C0      		rjmp .L893
 13766 4ea8 00C0      		rjmp .L920
 13767               	.L943:
 13768 4eaa 2334      		cpi r18,67
 13769 4eac E2E5      		ldi r30,82
 13770 4eae 3E07      		cpc r19,r30
 13771 4eb0 01F4      		brne .+2
 13772 4eb2 00C0      		rjmp .L922
 13773 4eb4 2434      		cpi r18,68
 13774 4eb6 3245      		sbci r19,82
 13775 4eb8 01F0      		breq .+2
 13776 4eba 00C0      		rjmp .L893
 13777 4ebc 00C0      		rjmp .L923
 13778               	.L941:
 13779 4ebe 2035      		cpi r18,80
 13780 4ec0 43E5      		ldi r20,83
 13781 4ec2 3407      		cpc r19,r20
 13782 4ec4 01F4      		brne .+2
 13783 4ec6 00C0      		rjmp .L929
 13784 4ec8 04F4      		brge .L944
 13785 4eca 2334      		cpi r18,67
 13786 4ecc F3E5      		ldi r31,83
 13787 4ece 3F07      		cpc r19,r31
 13788 4ed0 01F0      		breq .L926
 13789 4ed2 04F4      		brge .+2
 13790 4ed4 00C0      		rjmp .L925
 13791 4ed6 2434      		cpi r18,68
 13792 4ed8 E3E5      		ldi r30,83
 13793 4eda 3E07      		cpc r19,r30
 13794 4edc 01F0      		breq .L927
 13795 4ede 2F34      		cpi r18,79
 13796 4ee0 3345      		sbci r19,83
 13797 4ee2 01F0      		breq .+2
 13798 4ee4 00C0      		rjmp .L893
 13799 4ee6 00C0      		rjmp .L928
 13800               	.L944:
 13801 4ee8 2735      		cpi r18,87
 13802 4eea 43E5      		ldi r20,83
 13803 4eec 3407      		cpc r19,r20
 13804 4eee 01F4      		brne .+2
 13805 4ef0 00C0      		rjmp .L931
 13806 4ef2 04F4      		brge .L945
 13807 4ef4 2335      		cpi r18,83
 13808 4ef6 3345      		sbci r19,83
 13809 4ef8 01F0      		breq .+2
 13810 4efa 00C0      		rjmp .L893
 13811 4efc 00C0      		rjmp .L930
 13812               	.L945:
 13813 4efe 2934      		cpi r18,73
 13814 4f00 44E5      		ldi r20,84
 13815 4f02 3407      		cpc r19,r20
 13816 4f04 01F0      		breq .L932
 13817 4f06 2C34      		cpi r18,76
 13818 4f08 3445      		sbci r19,84
 13819 4f0a 01F0      		breq .+2
 13820 4f0c 00C0      		rjmp .L893
 13821 4f0e 00C0      		rjmp .L933
 13822               	.L932:
 250:switcherator.c ****             setClock(commandReceived);
 13823               		.loc 1 250 0
 13824 4f10 0C94 0000 		jmp setClock
 13825               	.LVL1172:
 13826               	.L906:
 253:switcherator.c ****             setDaylightSavings(commandReceived);
 13827               		.loc 1 253 0
 13828 4f14 0C94 0000 		jmp setDaylightSavings
 13829               	.LVL1173:
 13830               	.L933:
 256:switcherator.c ****             setTimeLimits(commandReceived);
 13831               		.loc 1 256 0
 13832 4f18 0C94 0000 		jmp setTimeLimits
 13833               	.LVL1174:
 13834               	.L913:
 259:switcherator.c ****             setNewSwitch(commandReceived);
 13835               		.loc 1 259 0
 13836 4f1c 0C94 0000 		jmp setNewSwitch
 13837               	.LVL1175:
 13838               	.L926:
 262:switcherator.c ****             switchClear(commandReceived);
 13839               		.loc 1 262 0
 13840 4f20 0C94 0000 		jmp switchClear
 13841               	.LVL1176:
 13842               	.L927:
 265:switcherator.c ****             switchDisplay(commandReceived);
 13843               		.loc 1 265 0
 13844 4f24 0C94 0000 		jmp switchDisplay
 13845               	.LVL1177:
 13846               	.L918:
 268:switcherator.c ****             pwmSetup(commandReceived);
 13847               		.loc 1 268 0
 13848 4f28 0C94 0000 		jmp pwmSetup
 13849               	.LVL1178:
 13850               	.L900:
 271:switcherator.c ****             cycleHue(commandReceived);
 13851               		.loc 1 271 0
 13852 4f2c 0C94 0000 		jmp cycleHue
 13853               	.LVL1179:
 13854               	.L909:
 274:switcherator.c ****             setHueSpeed(commandReceived);
 13855               		.loc 1 274 0
 13856 4f30 0C94 0000 		jmp setHueSpeed
 13857               	.LVL1180:
 13858               	.L920:
 277:switcherator.c ****             pwmValueSet(commandReceived);
 13859               		.loc 1 277 0
 13860 4f34 0C94 0000 		jmp pwmValueSet
 13861               	.LVL1181:
 13862               	.L912:
 280:switcherator.c ****             newProgram(commandReceived);
 13863               		.loc 1 280 0
 13864 4f38 0C94 0000 		jmp newProgram
 13865               	.LVL1182:
 13866               	.L903:
 283:switcherator.c ****             clearProgram(commandReceived);
 13867               		.loc 1 283 0
 13868 4f3c 0C94 0000 		jmp clearProgram
 13869               	.LVL1183:
 13870               	.L914:
 286:switcherator.c ****             programAddSwitch(commandReceived);
 13871               		.loc 1 286 0
 13872 4f40 0C94 0000 		jmp programAddSwitch
 13873               	.LVL1184:
 13874               	.L915:
 289:switcherator.c ****             programSetDays(commandReceived);
 13875               		.loc 1 289 0
 13876 4f44 0C94 0000 		jmp programSetDays
 13877               	.LVL1185:
 13878               	.L919:
 292:switcherator.c ****             programSetTime(commandReceived);
 13879               		.loc 1 292 0
 13880 4f48 0C94 0000 		jmp programSetTime
 13881               	.LVL1186:
 13882               	.L916:
 295:switcherator.c ****             programDisplay(commandReceived);
 13883               		.loc 1 295 0
 13884 4f4c 0C94 0000 		jmp programDisplay
 13885               	.LVL1187:
 13886               	.L930:
 298:switcherator.c ****             startSwitch(commandReceived);
 13887               		.loc 1 298 0
 13888 4f50 0C94 0000 		jmp startSwitch
 13889               	.LVL1188:
 13890               	.L929:
 301:switcherator.c ****             startProgram(commandReceived);
 13891               		.loc 1 301 0
 13892 4f54 0C94 0000 		jmp startProgram
 13893               	.LVL1189:
 13894               	.L924:
 304:switcherator.c ****             saveToEEPROM();
 13895               		.loc 1 304 0
 13896 4f58 0C94 0000 		jmp saveToEEPROM
 13897               	.LVL1190:
 13898               	.L902:
 307:switcherator.c ****             clearToEEPROM();
 13899               		.loc 1 307 0
 13900 4f5c 0C94 0000 		jmp clearToEEPROM
 13901               	.LVL1191:
 13902               	.L923:
 310:switcherator.c ****             radioDisplayAddress(commandReceived);
 13903               		.loc 1 310 0
 13904 4f60 0C94 0000 		jmp radioDisplayAddress
 13905               	.LVL1192:
 13906               	.L922:
 313:switcherator.c ****             radioChangeAddress(commandReceived);
 13907               		.loc 1 313 0
 13908 4f64 0C94 0000 		jmp radioChangeAddress
 13909               	.LVL1193:
 13910               	.L897:
 316:switcherator.c ****             setAnalogInput(commandReceived);
 13911               		.loc 1 316 0
 13912 4f68 0C94 0000 		jmp setAnalogInput
 13913               	.LVL1194:
 13914               	.L905:
 319:switcherator.c ****             setDigitalInput(commandReceived);
 13915               		.loc 1 319 0
 13916 4f6c 0C94 0000 		jmp setDigitalInput
 13917               	.LVL1195:
 13918               	.L901:
 322:switcherator.c ****             clearInput(commandReceived);
 13919               		.loc 1 322 0
 13920 4f70 0C94 0000 		jmp clearInput
 13921               	.LVL1196:
 13922               	.L904:
 325:switcherator.c ****             clockTweak(commandReceived);
 13923               		.loc 1 325 0
 13924 4f74 0C94 0000 		jmp clockTweak
 13925               	.LVL1197:
 13926               	.L921:
 328:switcherator.c ****             pwmSummary();
 13927               		.loc 1 328 0
 13928 4f78 0C94 0000 		jmp pwmSummary
 13929               	.LVL1198:
 13930               	.L908:
 331:switcherator.c ****             generalStatus(commandReceived);
 13931               		.loc 1 331 0
 13932 4f7c 0C94 0000 		jmp generalStatus
 13933               	.LVL1199:
 13934               	.L899:
 334:switcherator.c ****             colorChangeSet(commandReceived);
 13935               		.loc 1 334 0
 13936 4f80 0C94 0000 		jmp colorChangeSet
 13937               	.LVL1200:
 13938               	.L925:
 337:switcherator.c ****             switchBrightness(commandReceived);
 13939               		.loc 1 337 0
 13940 4f84 0C94 0000 		jmp switchBrightness
 13941               	.LVL1201:
 13942               	.L898:
 340:switcherator.c ****             brightnessSet(commandReceived);
 13943               		.loc 1 340 0
 13944 4f88 0C94 0000 		jmp brightnessSet
 13945               	.LVL1202:
 13946               	.L907:
 343:switcherator.c ****             generalInformation();
 13947               		.loc 1 343 0
 13948 4f8c 0C94 0000 		jmp generalInformation
 13949               	.LVL1203:
 13950               	.L917:
 346:switcherator.c ****             programsProgrammed();
 13951               		.loc 1 346 0
 13952 4f90 0C94 0000 		jmp programsProgrammed
 13953               	.LVL1204:
 13954               	.L931:
 349:switcherator.c ****             switchesProgrammed();
 13955               		.loc 1 349 0
 13956 4f94 0C94 0000 		jmp switchesProgrammed
 13957               	.LVL1205:
 13958               	.L911:
 352:switcherator.c ****             inputsProgrammed();
 13959               		.loc 1 352 0
 13960 4f98 0C94 0000 		jmp inputsProgrammed
 13961               	.LVL1206:
 13962               	.L928:
 355:switcherator.c ****             switchesOn();
 13963               		.loc 1 355 0
 13964 4f9c 0C94 0000 		jmp switchesOn
 13965               	.LVL1207:
 13966               	.L910:
 358:switcherator.c ****             setImmediateChange(commandReceived);
 13967               		.loc 1 358 0
 13968 4fa0 0C94 0000 		jmp setImmediateChange
 13969               	.LVL1208:
 13970               	.L893:
 13971 4fa4 0895      		ret
 13972               	.LFE8:
 13974               		.section	.rodata.str1.1
 13975               	.LC73:
 13976 0170 6773 7100 		.string	"gsq"
 13977               		.section	.text.startup,"ax",@progbits
 13978               	.global	main
 13980               	main:
 13981               	.LFB7:
 122:switcherator.c **** int main(void) {
 13982               		.loc 1 122 0
 13983               	/* prologue: function */
 13984               	/* frame size = 0 */
 13985               	/* stack size = 0 */
 13986               	.L__stack_usage = 0
 123:switcherator.c ****     receiveBuffer[0] = 0;
 13987               		.loc 1 123 0
 13988 0000 1092 0000 		sts receiveBuffer,__zero_reg__
 124:switcherator.c ****     radioReceiveBuffer[0] = 0;
 13989               		.loc 1 124 0
 13990 0004 1092 0000 		sts radioReceiveBuffer,__zero_reg__
 13991               	.LVL1209:
 127:switcherator.c ****     INDICATOR_DDR |= INDICATOR_PIN;
 13992               		.loc 1 127 0
 13993 0008 529A      		sbi 0xa,2
 13994 000a 84E0      		ldi r24,lo8(4)
 13995 000c 90E0      		ldi r25,0
 13996               	.LVL1210:
 13997               	.L947:
 129:switcherator.c ****         INDICATOR_PORT |= INDICATOR_PIN;
 13998               		.loc 1 129 0 discriminator 2
 13999 000e 5A9A      		sbi 0xb,2
 14000               	.LVL1211:
 14001               	.LBB26:
 14002               	.LBB27:
 164:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 14003               		.loc 2 164 0 discriminator 2
 14004 0010 2FEF      		ldi r18,lo8(159999)
 14005 0012 30E7      		ldi r19,hi8(159999)
 14006 0014 42E0      		ldi r20,hlo8(159999)
 14007 0016 2150      		1: subi r18,1
 14008 0018 3040      		sbci r19,0
 14009 001a 4040      		sbci r20,0
 14010 001c 01F4      		brne 1b
 14011 001e 00C0      		rjmp .
 14012 0020 0000      		nop
 14013               	.LBE27:
 14014               	.LBE26:
 131:switcherator.c ****         INDICATOR_PORT &= ~(INDICATOR_PIN);
 14015               		.loc 1 131 0 discriminator 2
 14016 0022 5A98      		cbi 0xb,2
 14017               	.LVL1212:
 14018               	.LBB28:
 14019               	.LBB29:
 164:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 14020               		.loc 2 164 0 discriminator 2
 14021 0024 2FEF      		ldi r18,lo8(319999)
 14022 0026 31EE      		ldi r19,hi8(319999)
 14023 0028 44E0      		ldi r20,hlo8(319999)
 14024 002a 2150      		1: subi r18,1
 14025 002c 3040      		sbci r19,0
 14026 002e 4040      		sbci r20,0
 14027 0030 01F4      		brne 1b
 14028 0032 00C0      		rjmp .
 14029 0034 0000      		nop
 14030 0036 0197      		sbiw r24,1
 14031               	.LBE29:
 14032               	.LBE28:
 128:switcherator.c ****     for (x = 0; x < 4; x++) {
 14033               		.loc 1 128 0 discriminator 2
 14034 0038 01F4      		brne .L947
 134:switcherator.c ****     INDICATOR_PORT |= INDICATOR_PIN;
 14035               		.loc 1 134 0
 14036 003a 5A9A      		sbi 0xb,2
 14037               	.LVL1213:
 14038 003c E0E0      		ldi r30,lo8(colorChanges+2)
 14039 003e F0E0      		ldi r31,hi8(colorChanges+2)
 140:switcherator.c ****         colorChanges[x][1] = 1;
 14040               		.loc 1 140 0
 14041 0040 81E0      		ldi r24,lo8(1)
 14042               	.LVL1214:
 14043               	.L948:
 122:switcherator.c **** int main(void) {
 14044               		.loc 1 122 0 discriminator 2
 14045 0042 DF01      		movw r26,r30
 14046 0044 1297      		sbiw r26,2
 139:switcherator.c ****         colorChanges[x][0] = 0;
 14047               		.loc 1 139 0 discriminator 2
 14048 0046 1C92      		st X,__zero_reg__
 122:switcherator.c **** int main(void) {
 14049               		.loc 1 122 0 discriminator 2
 14050 0048 DF01      		movw r26,r30
 14051 004a 1197      		sbiw r26,1
 140:switcherator.c ****         colorChanges[x][1] = 1;
 14052               		.loc 1 140 0 discriminator 2
 14053 004c 8C93      		st X,r24
 141:switcherator.c ****         colorChanges[x][2] = 0;
 14054               		.loc 1 141 0 discriminator 2
 14055 004e 1082      		st Z,__zero_reg__
 14056 0050 3396      		adiw r30,3
 138:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 14057               		.loc 1 138 0 discriminator 2
 14058 0052 90E0      		ldi r25,hi8(colorChanges+20)
 14059 0054 E030      		cpi r30,lo8(colorChanges+20)
 14060 0056 F907      		cpc r31,r25
 14061 0058 01F4      		brne .L948
 145:switcherator.c ****     globalYear = globalMonth = globalDay = globalHour = globalMinute = globalSecond = dow = 0;
 14062               		.loc 1 145 0
 14063 005a 1092 0000 		sts dow+1,__zero_reg__
 14064 005e 1092 0000 		sts dow,__zero_reg__
 14065 0062 1092 0000 		sts globalSecond+1,__zero_reg__
 14066 0066 1092 0000 		sts globalSecond,__zero_reg__
 14067 006a 1092 0000 		sts globalMinute+1,__zero_reg__
 14068 006e 1092 0000 		sts globalMinute,__zero_reg__
 14069 0072 1092 0000 		sts globalHour+1,__zero_reg__
 14070 0076 1092 0000 		sts globalHour,__zero_reg__
 14071 007a 1092 0000 		sts globalDay+1,__zero_reg__
 14072 007e 1092 0000 		sts globalDay,__zero_reg__
 14073 0082 1092 0000 		sts globalMonth+1,__zero_reg__
 14074 0086 1092 0000 		sts globalMonth,__zero_reg__
 14075 008a 1092 0000 		sts globalYear+1,__zero_reg__
 14076 008e 1092 0000 		sts globalYear,__zero_reg__
 14077               	.LVL1215:
 14078 0092 E0E0      		ldi r30,lo8(switchStatus)
 14079 0094 F0E0      		ldi r31,hi8(switchStatus)
 14080 0096 C0E0      		ldi r28,lo8(switchStuff)
 14081 0098 D0E0      		ldi r29,hi8(switchStuff)
 14082 009a A0E0      		ldi r26,lo8(switchBright)
 14083 009c B0E0      		ldi r27,hi8(switchBright)
 148:switcherator.c ****         switchStuff[x] = 255;
 14084               		.loc 1 148 0
 14085 009e 2FEF      		ldi r18,lo8(-1)
 149:switcherator.c ****         switchBright[x] = 16;
 14086               		.loc 1 149 0
 14087 00a0 90E1      		ldi r25,lo8(16)
 14088               	.LVL1216:
 14089               	.L949:
 147:switcherator.c ****         switchStatus[x] = 0;
 14090               		.loc 1 147 0 discriminator 2
 14091 00a2 1192      		st Z+,__zero_reg__
 14092 00a4 1192      		st Z+,__zero_reg__
 14093 00a6 1192      		st Z+,__zero_reg__
 14094 00a8 1192      		st Z+,__zero_reg__
 148:switcherator.c ****         switchStuff[x] = 255;
 14095               		.loc 1 148 0 discriminator 2
 14096 00aa 8FEF      		ldi r24,lo8(-1)
 14097 00ac 2993      		st Y+,r18
 149:switcherator.c ****         switchBright[x] = 16;
 14098               		.loc 1 149 0 discriminator 2
 14099 00ae 9D93      		st X+,r25
 146:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 14100               		.loc 1 146 0 discriminator 2
 14101 00b0 30E0      		ldi r19,hi8(switchStatus+64)
 14102 00b2 E030      		cpi r30,lo8(switchStatus+64)
 14103 00b4 F307      		cpc r31,r19
 14104 00b6 01F4      		brne .L949
 14105               	.LVL1217:
 152:switcherator.c ****         inputs[x][0] = 255;
 14106               		.loc 1 152 0 discriminator 1
 14107 00b8 8093 0000 		sts inputs,r24
 14108               	.LVL1218:
 14109 00bc 8093 0000 		sts inputs+8,r24
 14110               	.LVL1219:
 14111 00c0 8093 0000 		sts inputs+16,r24
 14112               	.LVL1220:
 14113 00c4 8093 0000 		sts inputs+24,r24
 14114               	.LVL1221:
 154:switcherator.c ****     sei();
 14115               		.loc 1 154 0 discriminator 1
 14116               	/* #APP */
 14117               	 ;  154 "switcherator.c" 1
 14118 00c8 7894      		sei
 14119               	 ;  0 "" 2
 14120               	.LVL1222:
 157:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 14121               		.loc 1 157 0 discriminator 1
 14122               	/* #NOAPP */
 14123 00ca C0E0      		ldi r28,0
 14124 00cc D0E0      		ldi r29,0
 14125               	.LVL1223:
 14126               	.L950:
 158:switcherator.c ****         clearTheProgram(x);
 14127               		.loc 1 158 0 discriminator 2
 14128 00ce CE01      		movw r24,r28
 14129 00d0 0E94 0000 		call clearTheProgram
 14130               	.LVL1224:
 157:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 14131               		.loc 1 157 0 discriminator 2
 14132 00d4 2196      		adiw r28,1
 14133               	.LVL1225:
 14134 00d6 C431      		cpi r28,20
 14135 00d8 D105      		cpc r29,__zero_reg__
 14136 00da 01F4      		brne .L950
 163:switcherator.c ****     clockInit();
 14137               		.loc 1 163 0
 14138 00dc 0E94 0000 		call clockInit
 14139               	.LVL1226:
 164:switcherator.c ****     radioInit();
 14140               		.loc 1 164 0
 14141 00e0 0E94 0000 		call radioInit
 14142               	.LVL1227:
 165:switcherator.c ****     startRx();
 14143               		.loc 1 165 0
 14144 00e4 0E94 0000 		call startRx
 14145               	.LVL1228:
 167:switcherator.c ****     generalInit();
 14146               		.loc 1 167 0
 14147 00e8 0E94 0000 		call generalInit
 14148               	.LVL1229:
 168:switcherator.c ****     startClock();
 14149               		.loc 1 168 0
 14150 00ec 0E94 0000 		call startClock
 14151               	.LVL1230:
 14152               	.L978:
 179:switcherator.c ****         if (newSecond == 1) {
 14153               		.loc 1 179 0
 14154 00f0 8091 0000 		lds r24,newSecond
 14155 00f4 8130      		cpi r24,lo8(1)
 14156 00f6 01F4      		brne .L951
 180:switcherator.c ****             newSecond = 0;
 14157               		.loc 1 180 0
 14158 00f8 1092 0000 		sts newSecond,__zero_reg__
 181:switcherator.c ****             timerCheck();
 14159               		.loc 1 181 0
 14160 00fc 0E94 0000 		call timerCheck
 14161               	.LVL1231:
 182:switcherator.c ****             inputCheck();
 14162               		.loc 1 182 0
 14163 0100 0E94 0000 		call inputCheck
 14164               	.LVL1232:
 14165               	.L951:
 185:switcherator.c ****         if (switchChanged == 1) {
 14166               		.loc 1 185 0
 14167 0104 8091 0000 		lds r24,switchChanged
 14168 0108 8130      		cpi r24,lo8(1)
 14169 010a 01F4      		brne .L952
 186:switcherator.c ****             switchChanged = 0;
 14170               		.loc 1 186 0
 14171 010c 1092 0000 		sts switchChanged,__zero_reg__
 187:switcherator.c ****             switchOnOff();
 14172               		.loc 1 187 0
 14173 0110 0E94 0000 		call switchOnOff
 14174               	.LVL1233:
 14175               	.L952:
 189:switcherator.c ****         if (runHue == 1 && immediateChange == 0) {
 14176               		.loc 1 189 0
 14177 0114 8091 0000 		lds r24,runHue
 14178 0118 8130      		cpi r24,lo8(1)
 14179 011a 01F4      		brne .L953
 189:switcherator.c ****         if (runHue == 1 && immediateChange == 0) {
 14180               		.loc 1 189 0 is_stmt 0 discriminator 1
 14181 011c 8091 0000 		lds r24,immediateChange
 14182 0120 9091 0000 		lds r25,immediateChange+1
 14183 0124 A091 0000 		lds r26,immediateChange+2
 14184 0128 B091 0000 		lds r27,immediateChange+3
 14185 012c 892B      		or r24,r25
 14186 012e 8A2B      		or r24,r26
 14187 0130 8B2B      		or r24,r27
 14188 0132 01F4      		brne .L953
 190:switcherator.c ****             runHueFunction();
 14189               		.loc 1 190 0 is_stmt 1
 14190 0134 0E94 0000 		call runHueFunction
 14191               	.LVL1234:
 14192               	.L953:
 192:switcherator.c ****         if (runColorChanges == 1 && immediateChange == 0) {
 14193               		.loc 1 192 0
 14194 0138 C091 0000 		lds r28,runColorChanges
 14195 013c C130      		cpi r28,lo8(1)
 14196 013e 01F4      		brne .L954
 192:switcherator.c ****         if (runColorChanges == 1 && immediateChange == 0) {
 14197               		.loc 1 192 0 is_stmt 0 discriminator 1
 14198 0140 8091 0000 		lds r24,immediateChange
 14199 0144 9091 0000 		lds r25,immediateChange+1
 14200 0148 A091 0000 		lds r26,immediateChange+2
 14201 014c B091 0000 		lds r27,immediateChange+3
 14202 0150 892B      		or r24,r25
 14203 0152 8A2B      		or r24,r26
 14204 0154 8B2B      		or r24,r27
 14205 0156 01F4      		brne .L954
 193:switcherator.c ****             runColorFunction();
 14206               		.loc 1 193 0 is_stmt 1
 14207 0158 0E94 0000 		call runColorFunction
 14208               	.LVL1235:
 14209               	.L954:
 197:switcherator.c ****         if (immediateChange > 0 && weeklySeconds > immediateChange) {
 14210               		.loc 1 197 0
 14211 015c 8091 0000 		lds r24,immediateChange
 14212 0160 9091 0000 		lds r25,immediateChange+1
 14213 0164 A091 0000 		lds r26,immediateChange+2
 14214 0168 B091 0000 		lds r27,immediateChange+3
 14215 016c 0097      		sbiw r24,0
 14216 016e A105      		cpc r26,__zero_reg__
 14217 0170 B105      		cpc r27,__zero_reg__
 14218 0172 01F0      		breq .L955
 197:switcherator.c ****         if (immediateChange > 0 && weeklySeconds > immediateChange) {
 14219               		.loc 1 197 0 is_stmt 0 discriminator 1
 14220 0174 4091 0000 		lds r20,weeklySeconds
 14221 0178 5091 0000 		lds r21,weeklySeconds+1
 14222 017c 6091 0000 		lds r22,weeklySeconds+2
 14223 0180 7091 0000 		lds r23,weeklySeconds+3
 14224 0184 8417      		cp r24,r20
 14225 0186 9507      		cpc r25,r21
 14226 0188 A607      		cpc r26,r22
 14227 018a B707      		cpc r27,r23
 14228 018c 00F4      		brsh .L955
 198:switcherator.c ****             clearImmediateChange();
 14229               		.loc 1 198 0 is_stmt 1
 14230 018e 0E94 0000 		call clearImmediateChange
 14231               	.LVL1236:
 14232               	.L955:
 201:switcherator.c ****         if (tenthFlag == 1) {
 14233               		.loc 1 201 0
 14234 0192 8091 0000 		lds r24,tenthFlag
 14235 0196 8130      		cpi r24,lo8(1)
 14236 0198 01F4      		brne .L957
 202:switcherator.c ****             tenthFlag = 0;
 14237               		.loc 1 202 0
 14238 019a 1092 0000 		sts tenthFlag,__zero_reg__
 203:switcherator.c ****             inputTenthCheck();
 14239               		.loc 1 203 0
 14240 019e 0E94 0000 		call inputTenthCheck
 14241               	.LVL1237:
 204:switcherator.c ****             if (failCondition > 0) {
 14242               		.loc 1 204 0
 14243 01a2 8091 0000 		lds r24,failCondition
 14244 01a6 8111      		cpse r24,__zero_reg__
 205:switcherator.c ****                 flashFail();
 14245               		.loc 1 205 0
 14246 01a8 0E94 0000 		call flashFail
 14247               	.LVL1238:
 14248               	.L958:
 207:switcherator.c ****             if (runColorChanges == 1) {
 14249               		.loc 1 207 0
 14250 01ac C130      		cpi r28,lo8(1)
 14251 01ae 01F4      		brne .L957
 208:switcherator.c ****                 runColorFunction();
 14252               		.loc 1 208 0
 14253 01b0 0E94 0000 		call runColorFunction
 14254               	.LVL1239:
 14255               	.L957:
 211:switcherator.c ****         if (newMinute == 1) {
 14256               		.loc 1 211 0
 14257 01b4 8091 0000 		lds r24,newMinute
 14258 01b8 8130      		cpi r24,lo8(1)
 14259 01ba 01F4      		brne .L960
 212:switcherator.c ****             newMinute = 0;
 14260               		.loc 1 212 0
 14261 01bc 1092 0000 		sts newMinute,__zero_reg__
 213:switcherator.c ****             if (panicMyClockIsNotSet == 1) {
 14262               		.loc 1 213 0
 14263 01c0 8091 0000 		lds r24,panicMyClockIsNotSet
 14264 01c4 8130      		cpi r24,lo8(1)
 14265 01c6 01F4      		brne .L961
 214:switcherator.c ****                 generalStatus("gsq");
 14266               		.loc 1 214 0
 14267 01c8 80E0      		ldi r24,lo8(.LC73)
 14268 01ca 90E0      		ldi r25,hi8(.LC73)
 14269 01cc 0E94 0000 		call generalStatus
 14270               	.LVL1240:
 14271               	.L961:
 216:switcherator.c ****             radioTest();
 14272               		.loc 1 216 0
 14273 01d0 0E94 0000 		call radioTest
 14274               	.LVL1241:
 14275               	.L960:
 219:switcherator.c ****         payloadLength = dynReceive(radioReceiveBuffer);
 14276               		.loc 1 219 0
 14277 01d4 80E0      		ldi r24,lo8(radioReceiveBuffer)
 14278 01d6 90E0      		ldi r25,hi8(radioReceiveBuffer)
 14279 01d8 0E94 0000 		call dynReceive
 14280               	.LVL1242:
 14281 01dc 90E0      		ldi r25,0
 220:switcherator.c ****         if (payloadLength > 1) {
 14282               		.loc 1 220 0
 14283 01de 0297      		sbiw r24,2
 14284 01e0 04F4      		brge .+2
 14285 01e2 00C0      		rjmp .L978
 14286               	.LVL1243:
 14287               	.LBB30:
 14288               	.LBB31:
 164:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 14289               		.loc 2 164 0
 14290 01e4 4FEF      		ldi r20,lo8(287999)
 14291 01e6 84E6      		ldi r24,hi8(287999)
 14292 01e8 94E0      		ldi r25,hlo8(287999)
 14293 01ea 4150      		1: subi r20,1
 14294 01ec 8040      		sbci r24,0
 14295 01ee 9040      		sbci r25,0
 14296 01f0 01F4      		brne 1b
 14297               	.LVL1244:
 14298 01f2 00C0      		rjmp .
 14299 01f4 0000      		nop
 14300               	.LBE31:
 14301               	.LBE30:
 223:switcherator.c ****             checkCommand(radioReceiveBuffer);
 14302               		.loc 1 223 0
 14303 01f6 80E0      		ldi r24,lo8(radioReceiveBuffer)
 14304 01f8 90E0      		ldi r25,hi8(radioReceiveBuffer)
 14305 01fa 0E94 0000 		call checkCommand
 14306               	.LVL1245:
 14307 01fe E0E0      		ldi r30,lo8(radioReceiveBuffer)
 14308 0200 F0E0      		ldi r31,hi8(radioReceiveBuffer)
 14309 0202 A0E0      		ldi r26,lo8(receiveBuffer)
 14310 0204 B0E0      		ldi r27,hi8(receiveBuffer)
 14311               	.LVL1246:
 14312               	.L963:
 227:switcherator.c ****                 radioReceiveBuffer[x] = 0;
 14313               		.loc 1 227 0 discriminator 2
 14314 0206 1192      		st Z+,__zero_reg__
 228:switcherator.c ****                 receiveBuffer[x] = 0;
 14315               		.loc 1 228 0 discriminator 2
 14316 0208 1D92      		st X+,__zero_reg__
 226:switcherator.c ****             for (x = 0; x < 30; x++) {
 14317               		.loc 1 226 0 discriminator 2
 14318 020a 20E0      		ldi r18,hi8(radioReceiveBuffer+30)
 14319 020c E030      		cpi r30,lo8(radioReceiveBuffer+30)
 14320 020e F207      		cpc r31,r18
 14321 0210 01F4      		brne .L963
 14322 0212 00C0      		rjmp .L978
 14323               	.LFE7:
 14325               		.text
 14326               	.global	__vector_11
 14328               	__vector_11:
 14329               	.LFB86:
3758:switcherator.c **** }
3759:switcherator.c **** 
3760:switcherator.c **** ISR(TIMER1_COMPA_vect) {
 14330               		.loc 1 3760 0
 14331 4fa6 1F92      		push r1
 14332               	.LCFI380:
 14333 4fa8 0F92      		push r0
 14334               	.LCFI381:
 14335 4faa 0FB6      		in r0,__SREG__
 14336 4fac 0F92      		push r0
 14337 4fae 1124      		clr __zero_reg__
 14338 4fb0 2F93      		push r18
 14339               	.LCFI382:
 14340 4fb2 3F93      		push r19
 14341               	.LCFI383:
 14342 4fb4 4F93      		push r20
 14343               	.LCFI384:
 14344 4fb6 5F93      		push r21
 14345               	.LCFI385:
 14346 4fb8 6F93      		push r22
 14347               	.LCFI386:
 14348 4fba 7F93      		push r23
 14349               	.LCFI387:
 14350 4fbc 8F93      		push r24
 14351               	.LCFI388:
 14352 4fbe 9F93      		push r25
 14353               	.LCFI389:
 14354 4fc0 AF93      		push r26
 14355               	.LCFI390:
 14356 4fc2 BF93      		push r27
 14357               	.LCFI391:
 14358 4fc4 EF93      		push r30
 14359               	.LCFI392:
 14360 4fc6 FF93      		push r31
 14361               	.LCFI393:
 14362               	/* prologue: Signal */
 14363               	/* frame size = 0 */
 14364               	/* stack size = 15 */
 14365               	.L__stack_usage = 15
3761:switcherator.c ****     int tenthTicks;
3762:switcherator.c ****     ticks++;
 14366               		.loc 1 3762 0
 14367 4fc8 4091 0000 		lds r20,ticks
 14368 4fcc 5091 0000 		lds r21,ticks+1
 14369 4fd0 4F5F      		subi r20,-1
 14370 4fd2 5F4F      		sbci r21,-1
 14371 4fd4 5093 0000 		sts ticks+1,r21
 14372 4fd8 4093 0000 		sts ticks,r20
3763:switcherator.c ****     // if its been a second
3764:switcherator.c ****     if (ticks >= tweakTimer) {
 14373               		.loc 1 3764 0
 14374 4fdc 60E0      		ldi r22,0
 14375 4fde 70E0      		ldi r23,0
 14376 4fe0 8091 0000 		lds r24,tweakTimer
 14377 4fe4 9091 0000 		lds r25,tweakTimer+1
 14378 4fe8 A091 0000 		lds r26,tweakTimer+2
 14379 4fec B091 0000 		lds r27,tweakTimer+3
 14380 4ff0 4817      		cp r20,r24
 14381 4ff2 5907      		cpc r21,r25
 14382 4ff4 6A07      		cpc r22,r26
 14383 4ff6 7B07      		cpc r23,r27
 14384 4ff8 04F4      		brge .+2
 14385 4ffa 00C0      		rjmp .L981
3765:switcherator.c ****         ticks = 0;
 14386               		.loc 1 3765 0
 14387 4ffc 1092 0000 		sts ticks+1,__zero_reg__
 14388 5000 1092 0000 		sts ticks,__zero_reg__
3766:switcherator.c ****         globalSecond++;
 14389               		.loc 1 3766 0
 14390 5004 2091 0000 		lds r18,globalSecond
 14391 5008 3091 0000 		lds r19,globalSecond+1
 14392 500c 2F5F      		subi r18,-1
 14393 500e 3F4F      		sbci r19,-1
 14394 5010 3093 0000 		sts globalSecond+1,r19
 14395 5014 2093 0000 		sts globalSecond,r18
3767:switcherator.c ****         weeklySeconds++;
 14396               		.loc 1 3767 0
 14397 5018 8091 0000 		lds r24,weeklySeconds
 14398 501c 9091 0000 		lds r25,weeklySeconds+1
 14399 5020 A091 0000 		lds r26,weeklySeconds+2
 14400 5024 B091 0000 		lds r27,weeklySeconds+3
 14401 5028 0196      		adiw r24,1
 14402 502a A11D      		adc r26,__zero_reg__
 14403 502c B11D      		adc r27,__zero_reg__
 14404 502e 8093 0000 		sts weeklySeconds,r24
 14405 5032 9093 0000 		sts weeklySeconds+1,r25
 14406 5036 A093 0000 		sts weeklySeconds+2,r26
 14407 503a B093 0000 		sts weeklySeconds+3,r27
3768:switcherator.c ****         newSecond = 1;
 14408               		.loc 1 3768 0
 14409 503e 41E0      		ldi r20,lo8(1)
 14410 5040 4093 0000 		sts newSecond,r20
3769:switcherator.c ****         if (globalSecond == 60) {
 14411               		.loc 1 3769 0
 14412 5044 2C33      		cpi r18,60
 14413 5046 3105      		cpc r19,__zero_reg__
 14414 5048 01F4      		brne .L981
3770:switcherator.c ****             globalMinute++;
 14415               		.loc 1 3770 0
 14416 504a 8091 0000 		lds r24,globalMinute
 14417 504e 9091 0000 		lds r25,globalMinute+1
 14418 5052 0196      		adiw r24,1
 14419 5054 9093 0000 		sts globalMinute+1,r25
 14420 5058 8093 0000 		sts globalMinute,r24
3771:switcherator.c ****             globalSecond = 0;
 14421               		.loc 1 3771 0
 14422 505c 1092 0000 		sts globalSecond+1,__zero_reg__
 14423 5060 1092 0000 		sts globalSecond,__zero_reg__
3772:switcherator.c ****             newMinute = 1;
 14424               		.loc 1 3772 0
 14425 5064 4093 0000 		sts newMinute,r20
3773:switcherator.c ****             if (globalMinute == 60) {
 14426               		.loc 1 3773 0
 14427 5068 CC97      		sbiw r24,60
 14428 506a 01F4      		brne .L981
3774:switcherator.c ****                 globalHour++;
 14429               		.loc 1 3774 0
 14430 506c 8091 0000 		lds r24,globalHour
 14431 5070 9091 0000 		lds r25,globalHour+1
 14432 5074 0196      		adiw r24,1
 14433 5076 9093 0000 		sts globalHour+1,r25
 14434 507a 8093 0000 		sts globalHour,r24
3775:switcherator.c ****                 globalMinute = 0;
 14435               		.loc 1 3775 0
 14436 507e 1092 0000 		sts globalMinute+1,__zero_reg__
 14437 5082 1092 0000 		sts globalMinute,__zero_reg__
3776:switcherator.c ****                 // daylight savings is always at 3am
3777:switcherator.c ****                 if (globalHour == 3)
 14438               		.loc 1 3777 0
 14439 5086 0397      		sbiw r24,3
 14440 5088 01F4      		brne .L983
3778:switcherator.c ****                     checkDaylightSavings();
 14441               		.loc 1 3778 0
 14442 508a 0E94 0000 		call checkDaylightSavings
 14443               	.LVL1247:
 14444               	.L983:
3779:switcherator.c ****                 if (globalHour == 24) {
 14445               		.loc 1 3779 0
 14446 508e 8091 0000 		lds r24,globalHour
 14447 5092 9091 0000 		lds r25,globalHour+1
 14448 5096 4897      		sbiw r24,24
 14449 5098 01F4      		brne .L981
3780:switcherator.c ****                     globalHour = 0;
 14450               		.loc 1 3780 0
 14451 509a 1092 0000 		sts globalHour+1,__zero_reg__
 14452 509e 1092 0000 		sts globalHour,__zero_reg__
3781:switcherator.c ****                     advanceDay();
 14453               		.loc 1 3781 0
 14454 50a2 0E94 0000 		call advanceDay
 14455               	.LVL1248:
 14456               	.L981:
3782:switcherator.c ****                 }
3783:switcherator.c ****             }
3784:switcherator.c ****         }
3785:switcherator.c ****     }
3786:switcherator.c ****     tenthTicks = ticks % TIMER_TENTH;
 14457               		.loc 1 3786 0
 14458 50a6 8091 0000 		lds r24,ticks
 14459 50aa 9091 0000 		lds r25,ticks+1
 14460 50ae 68E1      		ldi r22,lo8(24)
 14461 50b0 76E0      		ldi r23,lo8(6)
 14462 50b2 0E94 0000 		call __udivmodhi4
 14463               	.LVL1249:
3787:switcherator.c ****     if (tenthTicks == 0) {
 14464               		.loc 1 3787 0
 14465 50b6 892B      		or r24,r25
 14466 50b8 01F4      		brne .L979
3788:switcherator.c ****         tenthFlag = 1;
 14467               		.loc 1 3788 0
 14468 50ba 81E0      		ldi r24,lo8(1)
 14469               	.LVL1250:
 14470 50bc 8093 0000 		sts tenthFlag,r24
 14471               	.L979:
 14472               	/* epilogue start */
3789:switcherator.c ****         // set flags for whatever functions we want to do every 10th of a second here
3790:switcherator.c ****     }
3791:switcherator.c **** }
 14473               		.loc 1 3791 0
 14474 50c0 FF91      		pop r31
 14475 50c2 EF91      		pop r30
 14476 50c4 BF91      		pop r27
 14477 50c6 AF91      		pop r26
 14478 50c8 9F91      		pop r25
 14479 50ca 8F91      		pop r24
 14480 50cc 7F91      		pop r23
 14481 50ce 6F91      		pop r22
 14482 50d0 5F91      		pop r21
 14483 50d2 4F91      		pop r20
 14484 50d4 3F91      		pop r19
 14485 50d6 2F91      		pop r18
 14486 50d8 0F90      		pop r0
 14487 50da 0FBE      		out __SREG__,r0
 14488 50dc 0F90      		pop r0
 14489 50de 1F90      		pop r1
 14490 50e0 1895      		reti
 14491               	.LFE86:
 14493               		.local	receiveBuffer
 14494               		.comm	receiveBuffer,30,1
 14495               		.local	radioReceiveBuffer
 14496               		.comm	radioReceiveBuffer,30,1
 14497               		.local	colorChanges
 14498               		.comm	colorChanges,18,1
 14499               		.local	dow
 14500               		.comm	dow,2,1
 14501               		.local	globalSecond
 14502               		.comm	globalSecond,2,1
 14503               		.local	globalMinute
 14504               		.comm	globalMinute,2,1
 14505               		.local	globalHour
 14506               		.comm	globalHour,2,1
 14507               		.local	globalDay
 14508               		.comm	globalDay,2,1
 14509               		.local	globalMonth
 14510               		.comm	globalMonth,2,1
 14511               		.local	globalYear
 14512               		.comm	globalYear,2,1
 14513               		.local	switchStatus
 14514               		.comm	switchStatus,64,1
 14515               		.local	switchStuff
 14516               		.comm	switchStuff,16,1
 14517               		.local	switchBright
 14518               		.comm	switchBright,16,1
 14519               		.local	inputs
 14520               		.comm	inputs,32,1
 14521               		.local	newSecond
 14522               		.comm	newSecond,1,1
 14523               		.local	switchChanged
 14524               		.comm	switchChanged,1,1
 14525               		.local	runHue
 14526               		.comm	runHue,1,1
 14527               		.local	immediateChange
 14528               		.comm	immediateChange,4,1
 14529               		.local	runColorChanges
 14530               		.comm	runColorChanges,1,1
 14531               		.local	weeklySeconds
 14532               		.comm	weeklySeconds,4,1
 14533               		.local	tenthFlag
 14534               		.comm	tenthFlag,1,1
 14535               		.data
 14538               	failCondition:
 14539 0000 03        		.byte	3
 14540               		.local	newMinute
 14541               		.comm	newMinute,1,1
 14544               	panicMyClockIsNotSet:
 14545 0001 01        		.byte	1
 14546               		.local	statusMsg
 14547               		.comm	statusMsg,32,1
 14550               	tempLongString:
 14551 0002 3030 3030 		.string	"0000"
 14551      00
 14554               	tempIntString:
 14555 0007 3030 00   		.string	"00"
 14558               	tempHugeString:
 14559 000a 3030 3030 		.string	"000000"
 14559      3030 00
 14560               		.local	pwmValues
 14561               		.comm	pwmValues,3,1
 14562               		.local	red
 14563               		.comm	red,2,1
 14564               		.local	green
 14565               		.comm	green,2,1
 14566               		.local	blue
 14567               		.comm	blue,2,1
 14570               	bright:
 14571 0011 1000      		.word	16
 14572               		.local	pwmdir
 14573               		.comm	pwmdir,1,1
 14574               		.local	pwmIsSet
 14575               		.comm	pwmIsSet,1,1
 14576               		.local	pwmSwitchNumber
 14577               		.comm	pwmSwitchNumber,2,1
 14580               	oldBright:
 14581 0013 10        		.byte	16
 14584               	colorChangeSpeed:
 14585 0014 0A00      		.word	10
 14588               	hueSpeed:
 14589 0016 1000      		.word	16
 14590               		.local	colorChangeCount
 14591               		.comm	colorChangeCount,2,1
 14592               		.local	currentColor
 14593               		.comm	currentColor,1,1
 14594               		.local	littleCount
 14595               		.comm	littleCount,1,1
 14596               		.local	hueCount
 14597               		.comm	hueCount,2,1
 14598               		.local	currentHue
 14599               		.comm	currentHue,2,1
 14600               		.local	pwmChangeValues
 14601               		.comm	pwmChangeValues,3,1
 14602               		.local	pwmOldValues
 14603               		.comm	pwmOldValues,3,1
 14604               		.local	weeklyProgram
 14605               		.comm	weeklyProgram,200,1
 14606               		.local	tx_addr
 14607               		.comm	tx_addr,8,1
 14608               		.local	rx_addr_p0
 14609               		.comm	rx_addr_p0,8,1
 14610               		.local	rx_addr_p1
 14611               		.comm	rx_addr_p1,8,1
 14612               		.local	rx_addr_p2
 14613               		.comm	rx_addr_p2,8,1
 14614               		.local	rx_addr_p3
 14615               		.comm	rx_addr_p3,8,1
 14616               		.local	rx_addr_p4
 14617               		.comm	rx_addr_p4,8,1
 14618               		.local	rx_addr_p5
 14619               		.comm	rx_addr_p5,8,1
 14622               	tweakTimer:
 14623 0018 09        		.byte	9
 14624 0019 3D        		.byte	61
 14625 001a 00        		.byte	0
 14626 001b 00        		.byte	0
 14627               		.local	daylightSavings
 14628               		.comm	daylightSavings,8,1
 14629               		.local	timeLimits
 14630               		.comm	timeLimits,48,1
 14631               		.local	wasDaylightSavings
 14632               		.comm	wasDaylightSavings,1,1
 14633               		.local	failTimer
 14634               		.comm	failTimer,1,1
 14635               		.local	ticks
 14636               		.comm	ticks,2,1
 17583               	.Letext0:
 17584               		.file 3 "/usr/lib/gcc/avr/4.7.2/include/stddef.h"
 17585               		.file 4 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/stdint.h"
 17586               		.file 5 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/stdlib.h"
 17587               		.file 6 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/eeprom.h"
 17588               		.file 7 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/string.h"
 17589               		.file 8 "../myavrnrflib/nrf.h"
DEFINED SYMBOLS
                            *ABS*:00000000 switcherator.c
     /tmp/ccGIPBtg.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccGIPBtg.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccGIPBtg.s:4      *ABS*:0000003f __SREG__
     /tmp/ccGIPBtg.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccGIPBtg.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccGIPBtg.s:11     .text:00000000 getSwitchNumber
     /tmp/ccGIPBtg.s:14554  .data:00000007 tempIntString
     /tmp/ccGIPBtg.s:37     .text:00000016 getPort
     /tmp/ccGIPBtg.s:14514  .bss:0000009c switchStuff
     /tmp/ccGIPBtg.s:196    .text:000000ba pwmClear
     /tmp/ccGIPBtg.s:14580  .data:00000013 oldBright
     /tmp/ccGIPBtg.s:14570  .data:00000011 bright
     /tmp/ccGIPBtg.s:14524  .bss:000000de runHue
     /tmp/ccGIPBtg.s:14528  .bss:000000e3 runColorChanges
     /tmp/ccGIPBtg.s:14573  .bss:00000114 pwmIsSet
     /tmp/ccGIPBtg.s:247    .text:000000fa clearTheSwitch
     /tmp/ccGIPBtg.s:403    .text:000001c0 runColorFunction
     /tmp/ccGIPBtg.s:14577  .bss:00000117 colorChangeCount
     /tmp/ccGIPBtg.s:14584  .data:00000014 colorChangeSpeed
     /tmp/ccGIPBtg.s:14591  .bss:00000119 currentColor
     /tmp/ccGIPBtg.s:14496  .bss:0000003c colorChanges
     /tmp/ccGIPBtg.s:14561  .bss:0000010d red
     /tmp/ccGIPBtg.s:14563  .bss:0000010f green
     /tmp/ccGIPBtg.s:14565  .bss:00000111 blue
     /tmp/ccGIPBtg.s:545    .text:000002b0 runHueFunction
     /tmp/ccGIPBtg.s:14593  .bss:0000011a littleCount
     /tmp/ccGIPBtg.s:14595  .bss:0000011b hueCount
     /tmp/ccGIPBtg.s:14588  .data:00000016 hueSpeed
     /tmp/ccGIPBtg.s:14597  .bss:0000011d currentHue
     /tmp/ccGIPBtg.s:782    .text:00000494 clearImmediateChange
     /tmp/ccGIPBtg.s:14526  .bss:000000df immediateChange
     /tmp/ccGIPBtg.s:14601  .bss:00000122 pwmOldValues
     /tmp/ccGIPBtg.s:14522  .bss:000000dd switchChanged
     /tmp/ccGIPBtg.s:811    .text:000004c0 clearTheProgram
     /tmp/ccGIPBtg.s:14603  .bss:00000125 weeklyProgram
     /tmp/ccGIPBtg.s:857    .text:000004ec findOpenSwitch
     /tmp/ccGIPBtg.s:908    .text:00000520 programGetSwitches
     /tmp/ccGIPBtg.s:992    .text:00000580 startTheProgram
     /tmp/ccGIPBtg.s:14530  .bss:000000e4 weeklySeconds
     /tmp/ccGIPBtg.s:14512  .bss:0000005c switchStatus
     /tmp/ccGIPBtg.s:1167   .text:0000067c readEEPROM
     /tmp/ccGIPBtg.s:1257   .text:000006d8 writeEEPROM
     /tmp/ccGIPBtg.s:1296   .text:000006f8 clearEEPROM
     /tmp/ccGIPBtg.s:1313   .text:00000700 clockInit
     /tmp/ccGIPBtg.s:1336   .text:0000071a startClock
     /tmp/ccGIPBtg.s:1359   .text:00000732 stopClock
     /tmp/ccGIPBtg.s:1377   .text:0000073e getWeekday
     /tmp/ccGIPBtg.s:14510  .bss:0000005a globalYear
     /tmp/ccGIPBtg.s:1488   .text:000007d2 getDayofYear
     /tmp/ccGIPBtg.s:1576   .text:00000838 checkDaylightSavings
     /tmp/ccGIPBtg.s:14630  .bss:0000025d wasDaylightSavings
     /tmp/ccGIPBtg.s:14508  .bss:00000058 globalMonth
     /tmp/ccGIPBtg.s:14619  .bss:00000225 daylightSavings
     /tmp/ccGIPBtg.s:14506  .bss:00000056 globalDay
     /tmp/ccGIPBtg.s:14504  .bss:00000054 globalHour
     /tmp/ccGIPBtg.s:1642   .text:000008bc advanceDay
     /tmp/ccGIPBtg.s:14498  .bss:0000004e dow
     /tmp/ccGIPBtg.s:1829   .text:00000a08 timerCheck
     /tmp/ccGIPBtg.s:2069   .text:00000b70 switchOnOff
     /tmp/ccGIPBtg.s:14547  .bss:0000010a pwmValues
     /tmp/ccGIPBtg.s:14516  .bss:000000ac switchBright
     /tmp/ccGIPBtg.s:2433   .text:00000d88 returnInt
     /tmp/ccGIPBtg.s:14558  .data:0000000a tempHugeString
     /tmp/ccGIPBtg.s:2497   .text:00000dc4 clockString
     /tmp/ccGIPBtg.s:14541  .bss:000000ea statusMsg
     /tmp/ccGIPBtg.s:14502  .bss:00000052 globalMinute
     /tmp/ccGIPBtg.s:14500  .bss:00000050 globalSecond
     /tmp/ccGIPBtg.s:2642   .text:00000ebc returnHex
     /tmp/ccGIPBtg.s:2721   .text:00000f18 returnHexWithout
     /tmp/ccGIPBtg.s:2784   .text:00000f5e formatAddress
     /tmp/ccGIPBtg.s:2844   .text:00000f98 generalInit
     /tmp/ccGIPBtg.s:14605  .bss:000001ed tx_addr
     /tmp/ccGIPBtg.s:14607  .bss:000001f5 rx_addr_p0
     /tmp/ccGIPBtg.s:14609  .bss:000001fd rx_addr_p1
     /tmp/ccGIPBtg.s:14611  .bss:00000205 rx_addr_p2
     /tmp/ccGIPBtg.s:14613  .bss:0000020d rx_addr_p3
     /tmp/ccGIPBtg.s:14615  .bss:00000215 rx_addr_p4
     /tmp/ccGIPBtg.s:14617  .bss:0000021d rx_addr_p5
     /tmp/ccGIPBtg.s:14622  .data:00000018 tweakTimer
     /tmp/ccGIPBtg.s:14518  .bss:000000bc inputs
     /tmp/ccGIPBtg.s:14628  .bss:0000022d timeLimits
     /tmp/ccGIPBtg.s:14567  .bss:00000113 pwmdir
     /tmp/ccGIPBtg.s:3631   .text:000014c2 unformatAddress
     /tmp/ccGIPBtg.s:3679   .text:000014ea getInput
     /tmp/ccGIPBtg.s:4683   .text:00001ada inputTenthCheck
     /tmp/ccGIPBtg.s:4743   .text:00001b18 inputCheck
     /tmp/ccGIPBtg.s:4822   .text:00001b7a flashFail
     /tmp/ccGIPBtg.s:14632  .bss:0000025e failTimer
     /tmp/ccGIPBtg.s:14538  .data:00000000 failCondition
     /tmp/ccGIPBtg.s:4933   .text:00001bf8 clearFail
     /tmp/ccGIPBtg.s:4951   .text:00001c02 sendMessage
     /tmp/ccGIPBtg.s:5049   .text:00001c5e radioChangeAddress
     /tmp/ccGIPBtg.s:14550  .data:00000002 tempLongString
     /tmp/ccGIPBtg.s:5501   .text:00001f6e radioDisplayAddress
     /tmp/ccGIPBtg.s:5757   .text:0000214e switchesOn
     /tmp/ccGIPBtg.s:5846   .text:000021bc inputsProgrammed
     /tmp/ccGIPBtg.s:5931   .text:00002222 switchesProgrammed
     /tmp/ccGIPBtg.s:6015   .text:00002286 programsProgrammed
     /tmp/ccGIPBtg.s:6115   .text:000022f6 generalInformation
     /tmp/ccGIPBtg.s:6470   .text:000024fc generalStatus
     /tmp/ccGIPBtg.s:14544  .data:00000001 panicMyClockIsNotSet
     /tmp/ccGIPBtg.s:6695   .text:0000263c programDisplay
     /tmp/ccGIPBtg.s:7240   .text:00002940 pwmSummary
     /tmp/ccGIPBtg.s:7628   .text:00002b6c switchDisplay
     /tmp/ccGIPBtg.s:7781   .text:00002c3a ok
     /tmp/ccGIPBtg.s:7797   .text:00002c42 clearInput
     /tmp/ccGIPBtg.s:7906   .text:00002cc0 setDaylightSavings
     /tmp/ccGIPBtg.s:8013   .text:00002d52 clearToEEPROM
     /tmp/ccGIPBtg.s:8174   .text:00002e4a saveToEEPROM
     /tmp/ccGIPBtg.s:8834   .text:000032c8 pwmValueSet
     /tmp/ccGIPBtg.s:8943   .text:0000335e setHueSpeed
     /tmp/ccGIPBtg.s:8980   .text:00003386 cycleHue
     /tmp/ccGIPBtg.s:9023   .text:000033ba switchClear
     /tmp/ccGIPBtg.s:9048   .text:000033c6 clockTweak
     /tmp/ccGIPBtg.s:9142   .text:00003458 brightnessSet
     /tmp/ccGIPBtg.s:9247   .text:000034f6 fail
     /tmp/ccGIPBtg.s:9298   .text:0000352e setDigitalInput
     /tmp/ccGIPBtg.s:9698   .text:00003736 setAnalogInput
     /tmp/ccGIPBtg.s:10174  .text:000039f8 startProgram
     /tmp/ccGIPBtg.s:10270  .text:00003a72 programSetTime
     /tmp/ccGIPBtg.s:10530  .text:00003bc2 programSetDays
     /tmp/ccGIPBtg.s:10715  .text:00003cc4 programAddSwitch
     /tmp/ccGIPBtg.s:11021  .text:00003e62 clearProgram
     /tmp/ccGIPBtg.s:11099  .text:00003eb4 setImmediateChange
     /tmp/ccGIPBtg.s:14599  .bss:0000011f pwmChangeValues
     /tmp/ccGIPBtg.s:14575  .bss:00000115 pwmSwitchNumber
     /tmp/ccGIPBtg.s:11271  .text:00003fd8 colorChangeSet
     /tmp/ccGIPBtg.s:11393  .text:00004084 pwmSetup
     /tmp/ccGIPBtg.s:11564  .text:00004160 startSwitch
     /tmp/ccGIPBtg.s:11904  .text:00004368 setNewSwitch
     /tmp/ccGIPBtg.s:12192  .text:000044ca setTimeLimits
     /tmp/ccGIPBtg.s:12680  .text:000047b4 newProgram
     /tmp/ccGIPBtg.s:12952  .text:00004918 switchBrightness
     /tmp/ccGIPBtg.s:13097  .text:000049cc radioTest
     /tmp/ccGIPBtg.s:13175  .text:00004a3a radioInit
     /tmp/ccGIPBtg.s:13337  .text:00004bcc setClock
     /tmp/ccGIPBtg.s:13580  .text:00004d6e checkCommand
     /tmp/ccGIPBtg.s:13980  .text.startup:00000000 main
                             .bss:00000000 receiveBuffer
     /tmp/ccGIPBtg.s:14494  .bss:0000001e radioReceiveBuffer
     /tmp/ccGIPBtg.s:14520  .bss:000000dc newSecond
     /tmp/ccGIPBtg.s:14532  .bss:000000e8 tenthFlag
     /tmp/ccGIPBtg.s:14534  .bss:000000e9 newMinute
     /tmp/ccGIPBtg.s:14328  .text:00004fa6 __vector_11
     /tmp/ccGIPBtg.s:14634  .bss:0000025f ticks

UNDEFINED SYMBOLS
atoi
__eerd_word_m328
__eerd_block_m328
__eeupd_block_m328
__eeupd_word_m328
__divmodhi4
__muluhisi3
itoa
strcat
__ashldi3
writeAddr
__lshrdi3
__mulsi3
__umulhisi3
__divmodsi4
__udivmodsi4
stopRx
transmit
startRx
strtol
__udivmodhi4
__cmpdi2_s8
__usmulhisi3
atol
readAddr
__cmpdi2
nrfInit
writeReg
startRadio
dynReceive
__do_copy_data
__do_clear_bss
