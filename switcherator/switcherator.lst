   1               		.file	"switcherator.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               	.global	drawInterface
  11               	drawInterface:
  12               	.LFB9:
  13               		.file 1 "switcherator.c"
   1:switcherator.c **** #ifndef __AVR_ATmega328__
   2:switcherator.c **** #define __AVR_ATmega328__
   3:switcherator.c **** #endif
   4:switcherator.c **** #ifndef F_CPU
   5:switcherator.c **** #define F_CPU 16000000
   6:switcherator.c **** #endif
   7:switcherator.c **** 
   8:switcherator.c **** 
   9:switcherator.c **** #include "switcherator.h"
  10:switcherator.c **** 
  11:switcherator.c **** // Uncomment if you want the print variables command available (costs 1K in program memory)
  12:switcherator.c **** // warning - probably way to big.
  13:switcherator.c **** //#define debug
  14:switcherator.c **** //#define help
  15:switcherator.c **** 
  16:switcherator.c **** // globals and such
  17:switcherator.c **** 
  18:switcherator.c **** // First time we are turned on and we have the wrong time
  19:switcherator.c **** static char panicMyClockIsNotSet = 1;
  20:switcherator.c **** 
  21:switcherator.c **** 
  22:switcherator.c **** // clock related
  23:switcherator.c **** static unsigned int ticks = 0; // ticks for the clock
  24:switcherator.c **** static unsigned int globalYear, globalMonth, globalDay, globalHour, globalMinute, globalSecond, dow
  25:switcherator.c **** // dow - Sunday = 0
  26:switcherator.c **** static unsigned long weeklySeconds = 0;
  27:switcherator.c **** // This is 1 on daylight savings day so I don't do it twice
  28:switcherator.c **** static char wasDaylightSavings = 0;
  29:switcherator.c **** static unsigned int daylightSavings[2][2]; // [0][0] = spring month, [0][1] = spring day, etc...
  30:switcherator.c **** 
  31:switcherator.c **** // flags
  32:switcherator.c **** static char newSecond = 0;
  33:switcherator.c **** static char newMinute = 0;
  34:switcherator.c **** static char switchChanged = 0;
  35:switcherator.c **** static char tenthFlag = 0; // 10th of a second(ish) has passed
  36:switcherator.c **** static char failCondition = 3;
  37:switcherator.c **** static char failTimer = 0;
  38:switcherator.c **** #define INDICATOR_PORT PORTD
  39:switcherator.c **** #define INDICATOR_PIN (1 << PIND2)
  40:switcherator.c **** #define INDICATOR_DDR DDRD
  41:switcherator.c **** 
  42:switcherator.c **** // When the switch will turn off (weekly seconds))
  43:switcherator.c **** static unsigned long switchStatus[NUM_SWITCHES];
  44:switcherator.c **** // Coded information for the switches
  45:switcherator.c **** // value of 255 (default) means nothing programmed
  46:switcherator.c **** // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
  47:switcherator.c **** // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
  48:switcherator.c **** // pin is abs(value/2)-the base - PINB3 = (22-16)/2  PINB3 (22-16)%2 = 0 - low (23-16)%2 = 1 - high
  49:switcherator.c **** // 200 = PWM, 201 = PWM rotating hue. PWM always uses PORTD3,PORTD5,PORTD6 for RGB
  50:switcherator.c **** // 202 = Color changing PWM
  51:switcherator.c **** // future - 202 - PWM with other ports. Can't on 328p since radio overlaps pwm pins
  52:switcherator.c **** static char switchStuff[NUM_SWITCHES];
  53:switcherator.c **** 
  54:switcherator.c **** // serial number
  55:switcherator.c **** static char stringSerial[] = "000000";
  56:switcherator.c **** static long serial = 0;
  57:switcherator.c **** 
  58:switcherator.c **** // strings
  59:switcherator.c **** static char receiveBuffer[30];
  60:switcherator.c **** static char radioReceiveBuffer[30];
  61:switcherator.c **** static char tempIntString[] = "00";
  62:switcherator.c **** static char tempLongString[] = "0000";
  63:switcherator.c **** static char tempHugeString[] = "000000";
  64:switcherator.c **** static char statusMsg[32];
  65:switcherator.c **** 
  66:switcherator.c **** // HardwarePWM
  67:switcherator.c **** static char runHue = 0;
  68:switcherator.c **** static char runColorChanges = 0;
  69:switcherator.c **** // PD3, PD5, PD6 or red,green,blue
  70:switcherator.c **** static char pwmValues[] = {0, 0, 0};
  71:switcherator.c **** static char colorChanges[NUM_COLOR_CHANGES][3];
  72:switcherator.c **** 
  73:switcherator.c **** 
  74:switcherator.c **** // rotating hue
  75:switcherator.c **** static unsigned int currentHue = 0;
  76:switcherator.c **** static unsigned int hueSpeed = 16;
  77:switcherator.c **** static unsigned int hueCount = 0;
  78:switcherator.c **** static unsigned char littleCount = 0;
  79:switcherator.c **** static unsigned int colorChangeSpeed = 10; // how many 1/10 seconds in each color change
  80:switcherator.c **** static unsigned int colorChangeCount = 0;
  81:switcherator.c **** static unsigned char currentColor = 0;
  82:switcherator.c **** #define Red OCR2B
  83:switcherator.c **** #define Green OCR0B
  84:switcherator.c **** #define Blue OCR0A
  85:switcherator.c **** static unsigned int red = 0;
  86:switcherator.c **** static unsigned int green = 0;
  87:switcherator.c **** static unsigned int blue = 0;
  88:switcherator.c **** static unsigned int bright = 16;
  89:switcherator.c **** static unsigned char oldBright = 16;
  90:switcherator.c **** static char switchBright[NUM_SWITCHES];
  91:switcherator.c **** static unsigned char pwmdir = 0;
  92:switcherator.c **** 
  93:switcherator.c **** 
  94:switcherator.c **** // programs and such kept in EEPROM
  95:switcherator.c **** // 1 byte day of week mask or 0 for everyday
  96:switcherator.c **** // 2 byte start time (seconds in day), 2 bytes duration (seconds), 1 byte additional program
  97:switcherator.c **** // If more than 4 switches are desired it will roll over to an additional program
  98:switcherator.c **** // DssddSSSSP
  99:switcherator.c **** // 0123456789   
 100:switcherator.c **** static unsigned char weeklyProgram[MAX_PROGRAM][10];
 101:switcherator.c **** 
 102:switcherator.c **** // input information
 103:switcherator.c **** // Pp - value of 255 (default) means nothing programmed
 104:switcherator.c **** // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
 105:switcherator.c **** // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
 106:switcherator.c **** // pin is abs(value/2)-the base - PINB3 = (22-16)/2  PINB3 (22-16)%2 = 0 - low (23-16)%2 = 1 - high
 107:switcherator.c **** // pLHsDDPw Pp int pin/port like sw, L%,H% (0,255 - digital), s - 0-127=switch, 128-255 = prog
 108:switcherator.c **** // dur in seconds, poll time in secs or  0 for continuous. w = which rgb (mask);)
 109:switcherator.c **** static unsigned char inputs[NUM_INPUTS][8];
 110:switcherator.c **** 
 111:switcherator.c **** // Times that the PROGRAMS will react to a switch (eg dusk to dawn)
 112:switcherator.c **** // [0]=start,[1]=stop,[2]=days
 113:switcherator.c **** static unsigned long timeLimits[NUM_LIMITS][3];
 114:switcherator.c **** 
 115:switcherator.c **** 
 116:switcherator.c **** // adjust the timer so it can be accurate
 117:switcherator.c **** static long tweakTimer = TIMER_TOTAL;
 118:switcherator.c **** 
 119:switcherator.c **** 
 120:switcherator.c **** 
 121:switcherator.c **** // send receive addresses
 122:switcherator.c **** static uint64_t rx_addr_p0, rx_addr_p1, rx_addr_p2, rx_addr_p3, rx_addr_p4, rx_addr_p5, tx_addr;
 123:switcherator.c **** 
 124:switcherator.c **** int main(void) {
 125:switcherator.c ****     receiveBuffer[0] = 0;
 126:switcherator.c ****     radioReceiveBuffer[0] = 0;
 127:switcherator.c ****     int x = 0;
 128:switcherator.c **** 
 129:switcherator.c ****     INDICATOR_DDR |= INDICATOR_PIN;
 130:switcherator.c ****     for (x = 0; x < 4; x++) {
 131:switcherator.c ****         INDICATOR_PORT |= INDICATOR_PIN;
 132:switcherator.c ****         _delay_ms(50);
 133:switcherator.c ****         INDICATOR_PORT &= ~(INDICATOR_PIN);
 134:switcherator.c ****         _delay_ms(100);
 135:switcherator.c ****     }
 136:switcherator.c ****     INDICATOR_PORT |= INDICATOR_PIN;
 137:switcherator.c **** 
 138:switcherator.c **** 
 139:switcherator.c ****     // set color changes to blank
 140:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 141:switcherator.c ****         colorChanges[x][0] = 0;
 142:switcherator.c ****         colorChanges[x][1] = 1;
 143:switcherator.c ****         colorChanges[x][2] = 0;
 144:switcherator.c ****     }
 145:switcherator.c **** 
 146:switcherator.c ****     // just initializing memory
 147:switcherator.c ****     globalYear = globalMonth = globalDay = globalHour = globalMinute = globalSecond = dow = 0;
 148:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 149:switcherator.c ****         switchStatus[x] = 0;
 150:switcherator.c ****         switchStuff[x] = 255;
 151:switcherator.c ****         switchBright[x] = 16;
 152:switcherator.c ****     }
 153:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 154:switcherator.c ****         inputs[x][0] = 255;
 155:switcherator.c ****     }
 156:switcherator.c ****     sei();
 157:switcherator.c **** 
 158:switcherator.c ****     // initialize programs
 159:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 160:switcherator.c ****         clearTheProgram(x);
 161:switcherator.c ****     }
 162:switcherator.c **** 
 163:switcherator.c **** 
 164:switcherator.c **** 
 165:switcherator.c ****     clockInit();
 166:switcherator.c ****     radioInit();
 167:switcherator.c ****     startRx();
 168:switcherator.c ****     // make sure general init is after radioinit
 169:switcherator.c ****     generalInit();
 170:switcherator.c ****     startClock();
 171:switcherator.c **** 
 172:switcherator.c **** 
 173:switcherator.c **** 
 174:switcherator.c ****     // radio related
 175:switcherator.c ****     char radioCommand[32];
 176:switcherator.c ****     radioCommand[0] = 0;
 177:switcherator.c ****     char tempRadioSerialIn[] = "000000";
 178:switcherator.c ****     int payloadLength = 0;
 179:switcherator.c **** 
 180:switcherator.c ****     
 181:switcherator.c **** 
 182:switcherator.c ****     while (1) {
 183:switcherator.c ****         // what to run every second
 184:switcherator.c ****         if (newSecond == 1) {
 185:switcherator.c ****             newSecond = 0;
 186:switcherator.c ****             timerCheck();
 187:switcherator.c ****             inputCheck();
 188:switcherator.c ****         }
 189:switcherator.c ****         // runs only if a switch changed
 190:switcherator.c ****         if (switchChanged == 1) {
 191:switcherator.c ****             switchChanged = 0;
 192:switcherator.c ****             switchOnOff();
 193:switcherator.c ****         }
 194:switcherator.c ****         if (runHue == 1) {
 195:switcherator.c ****             runHueFunction();
 196:switcherator.c ****         }
 197:switcherator.c ****         if (runColorChanges == 1) {
 198:switcherator.c ****             runColorFunction();
 199:switcherator.c ****         }
 200:switcherator.c ****         if (tenthFlag == 1) {
 201:switcherator.c ****             tenthFlag = 0;
 202:switcherator.c ****             inputTenthCheck();
 203:switcherator.c ****             if (failCondition > 0) {
 204:switcherator.c ****                 flashFail();
 205:switcherator.c ****             }
 206:switcherator.c ****             if (runColorChanges == 1) {
 207:switcherator.c ****                 runColorFunction();
 208:switcherator.c ****             }
 209:switcherator.c ****         }
 210:switcherator.c ****         if (newMinute == 1) {
 211:switcherator.c ****             newMinute = 0;
 212:switcherator.c ****             if (panicMyClockIsNotSet == 1) {
 213:switcherator.c ****                 generalStatus("gsq");
 214:switcherator.c ****             }
 215:switcherator.c ****             radioTest();
 216:switcherator.c ****         }
 217:switcherator.c ****         // check for radio instructions
 218:switcherator.c ****         payloadLength = dynReceive(radioReceiveBuffer);
 219:switcherator.c ****         if (payloadLength > 2) {
 220:switcherator.c ****             // wait so the receiver won't miss our response
 221:switcherator.c ****             _delay_ms(90);
 222:switcherator.c ****             // just a command to preceed the serial number
 223:switcherator.c ****             if (radioReceiveBuffer[0] == 'z') {
 224:switcherator.c ****                 // radio is sending a serial number to compare to
 225:switcherator.c ****                 for (x = 0; x < 6; x++) {
 226:switcherator.c ****                     tempRadioSerialIn[x] = radioReceiveBuffer[(x + 1)];
 227:switcherator.c ****                 }
 228:switcherator.c ****                 // compare the strings
 229:switcherator.c ****                 if (strcmp(tempRadioSerialIn, stringSerial) == 0) {
 230:switcherator.c ****                     for (x = 7; x < payloadLength; x++) {
 231:switcherator.c ****                         radioCommand[(x - 7)] = radioReceiveBuffer[x];
 232:switcherator.c ****                     }
 233:switcherator.c ****                     // command is from the radio
 234:switcherator.c ****                     checkCommand(radioCommand);
 235:switcherator.c ****                 } // endif - serial doesn't match so ignore it
 236:switcherator.c ****             } else if (radioReceiveBuffer[0] == 'b') { // radio isn't sending a serial number b=bro
 237:switcherator.c ****                 for (x = 1; x < payloadLength; x++) {
 238:switcherator.c ****                     radioCommand[(x - 1)] = radioReceiveBuffer[x];
 239:switcherator.c ****                 }
 240:switcherator.c ****                 // we are only going to set the serial number in a broadcast if we don't have one
 241:switcherator.c ****                 if (strncmp(radioCommand, "SE", 2) == 0 || strncmp(radioCommand, "se", 2) == 0) {
 242:switcherator.c ****                     if (serial == 0) {
 243:switcherator.c ****                         checkCommand(radioCommand);
 244:switcherator.c ****                     }
 245:switcherator.c ****                 } else {
 246:switcherator.c ****                     checkCommand(radioCommand);
 247:switcherator.c ****                 }
 248:switcherator.c ****             }
 249:switcherator.c ****             // nothing we care about so do nothing
 250:switcherator.c ****             for (x = 0; x < 30; x++) {
 251:switcherator.c ****                 radioReceiveBuffer[x] = 0;
 252:switcherator.c ****                 receiveBuffer[x] = 0;
 253:switcherator.c ****                 radioCommand[x] = 0;
 254:switcherator.c ****             }
 255:switcherator.c ****         }
 256:switcherator.c ****     }
 257:switcherator.c **** }
 258:switcherator.c **** 
 259:switcherator.c **** /****************************************************************
 260:switcherator.c ****  *
 261:switcherator.c ****  *              All Things Command and Interface Related
 262:switcherator.c ****  *
 263:switcherator.c ****  ****************************************************************/
 264:switcherator.c **** 
 265:switcherator.c **** void checkCommand(char * commandReceived) {
 266:switcherator.c ****     if (commandReceived[0] > 0x60)
 267:switcherator.c ****         commandReceived[0] -= 0x20;
 268:switcherator.c ****     if (commandReceived[1] > 0x60)
 269:switcherator.c ****         commandReceived[1] -= 0x20;
 270:switcherator.c ****     int switchme = commandReceived[0];
 271:switcherator.c ****     switchme <<= 8;
 272:switcherator.c ****     switchme |= commandReceived[1];
 273:switcherator.c ****     switch (switchme) {
 274:switcherator.c ****         case 0x5449: //TI
 275:switcherator.c ****             setClock(commandReceived);
 276:switcherator.c ****             break;
 277:switcherator.c ****         case 0x4453: //DS
 278:switcherator.c ****             setDaylightSavings(commandReceived);
 279:switcherator.c ****             break;
 280:switcherator.c ****         case 0x544C: //TL
 281:switcherator.c ****             setTimeLimits(commandReceived);
 282:switcherator.c ****             break;
 283:switcherator.c ****         case 0x4E53: //NS
 284:switcherator.c ****             setNewSwitch(commandReceived);
 285:switcherator.c ****             break;
 286:switcherator.c ****         case 0x5343: //SC
 287:switcherator.c ****             switchClear(commandReceived);
 288:switcherator.c ****             break;
 289:switcherator.c ****         case 0x5344: //SD
 290:switcherator.c ****             switchDisplay(commandReceived);
 291:switcherator.c ****             break;
 292:switcherator.c ****         case 0x5053: //PS
 293:switcherator.c ****             pwmSetup(commandReceived);
 294:switcherator.c ****             break;
 295:switcherator.c ****         case 0x4348: //CH
 296:switcherator.c ****             cycleHue(commandReceived);
 297:switcherator.c ****             break;
 298:switcherator.c ****         case 0x4864: //HS
 299:switcherator.c ****             setHueSpeed(commandReceived);
 300:switcherator.c ****             break;
 301:switcherator.c ****         case 0x5056: //PV
 302:switcherator.c ****             pwmValueSet(commandReceived);
 303:switcherator.c ****             break;
 304:switcherator.c ****         case 0x4E50: //NP
 305:switcherator.c ****             newProgram(commandReceived);
 306:switcherator.c ****             break;
 307:switcherator.c ****         case 0x4350: //CP
 308:switcherator.c ****             clearProgram(commandReceived);
 309:switcherator.c ****             break;
 310:switcherator.c ****         case 0x5041: //PA
 311:switcherator.c ****             programAddSwitch(commandReceived);
 312:switcherator.c ****             break;
 313:switcherator.c ****         case 0x5044: //PD
 314:switcherator.c ****             programSetDays(commandReceived);
 315:switcherator.c ****             break;
 316:switcherator.c ****         case 0x5054: //PT
 317:switcherator.c ****             programSetTime(commandReceived);
 318:switcherator.c ****             break;
 319:switcherator.c ****         case 0x5049: //PI
 320:switcherator.c ****             programDisplay(commandReceived);
 321:switcherator.c ****             break;
 322:switcherator.c ****         case 0x5353: //SS
 323:switcherator.c ****             startSwitch(commandReceived);
 324:switcherator.c ****             break;
 325:switcherator.c ****         case 0x5350: //SP
 326:switcherator.c ****             startProgram(commandReceived);
 327:switcherator.c ****             break;
 328:switcherator.c ****         case 0x5345: //SE
 329:switcherator.c ****             serialNumber(commandReceived);
 330:switcherator.c ****             break;
 331:switcherator.c ****         case 0x5341: //SA
 332:switcherator.c ****             saveToEEPROM();
 333:switcherator.c ****             break;
 334:switcherator.c ****         case 0x434C: //CL
 335:switcherator.c ****             clearToEEPROM();
 336:switcherator.c ****             break;
 337:switcherator.c ****         case 0x5244: //RD
 338:switcherator.c ****             radioDisplayAddress(commandReceived);
 339:switcherator.c ****             break;
 340:switcherator.c ****         case 0x5243: //RC
 341:switcherator.c ****             radioChangeAddress(commandReceived);
 342:switcherator.c ****             break;
 343:switcherator.c ****         case 0x4149: //AI
 344:switcherator.c ****             setAnalogInput(commandReceived);
 345:switcherator.c ****             break;
 346:switcherator.c ****         case 0x4449: //DI
 347:switcherator.c ****             setDigitalInput(commandReceived);
 348:switcherator.c ****             break;
 349:switcherator.c ****         case 0x4349: //CI
 350:switcherator.c ****             clearInput(commandReceived);
 351:switcherator.c ****             break;
 352:switcherator.c ****         case 0x4354: //CT
 353:switcherator.c ****             clockTweak(commandReceived);
 354:switcherator.c ****             break;
 355:switcherator.c ****         case 0x5057: //PW
 356:switcherator.c ****             pwmSummary();
 357:switcherator.c ****             break;
 358:switcherator.c ****         case 0x4845: //HE
 359:switcherator.c ****             drawInterface();
 360:switcherator.c ****             break;
 361:switcherator.c ****         case 0x4753: //GS
 362:switcherator.c ****             generalStatus(commandReceived);
 363:switcherator.c ****             break;
 364:switcherator.c ****         case 0x5248: //RH
 365:switcherator.c ****             drawInterface();
 366:switcherator.c ****             break;
 367:switcherator.c ****         case 0x4343: //CC
 368:switcherator.c ****             colorChangeSet(commandReceived);
 369:switcherator.c ****             break;
 370:switcherator.c ****         case 0x5342: //sb
 371:switcherator.c ****             switchBrightness(commandReceived);
 372:switcherator.c ****             break;
 373:switcherator.c ****         case 0x4253: //bs
 374:switcherator.c ****             brightnessSet(commandReceived);
 375:switcherator.c ****             break;
 376:switcherator.c ****         default:
 377:switcherator.c ****             break;
 378:switcherator.c ****     }
 379:switcherator.c **** }
 380:switcherator.c **** 
 381:switcherator.c **** void drawInterface(void) {
  14               		.loc 1 381 0
  15               	/* prologue: function */
  16               	/* frame size = 0 */
  17               	/* stack size = 0 */
  18               	.L__stack_usage = 0
  19 0000 0895      		ret
  20               	.LFE9:
  22               	.global	getSwitchNumber
  24               	getSwitchNumber:
  25               	.LFB12:
 382:switcherator.c **** #ifdef help
 383:switcherator.c ****     sendMessage("TI:MMDDYYYYHHMMSS");
 384:switcherator.c ****     sendMessage("DS:MMDD MMDD");
 385:switcherator.c ****     sendMessage("TL:##HHMMHHMMdddddd");
 386:switcherator.c ****     sendMessage("NS:S#PpD,SC:S# SD NP:HHMMDur.");
 387:switcherator.c ****     sendMessage("CP:P# PA:P#S# PD:P#SMTWTFS");
 388:switcherator.c ****     sendMessage("PT:P#HHMMDur. PI:P#");
 389:switcherator.c ****     sendMessage("PS:P#S#DH CH:P#vvvv ");
 390:switcherator.c ****     sendMessage("PV:P#,vvv,vvv,vvv PW");
 391:switcherator.c ****     sendMessage("CC:##,vvv,vvv,vvv PW (sum)");
 392:switcherator.c ****     sendMessage("BS:16 SB S#16 HS:16");
 393:switcherator.c ****     sendMessage("SS S#Durat. SP P#Durat.");
 394:switcherator.c ****     sendMessage("SE nnnnnn SA CL CTvvv");
 395:switcherator.c ****     sendMessage("RD:N RC:N 0xnnnnnnnnnn");
 396:switcherator.c ****     sendMessage("AI:##PpLLLHHH?##DuraPO");
 397:switcherator.c ****     sendMessage("DI:##Ppx?##DuraPO  CI xx");
 398:switcherator.c ****     sendMessage("HE RH GS");
 399:switcherator.c **** #endif
 400:switcherator.c **** }
 401:switcherator.c **** 
 402:switcherator.c **** void fail(int failCode) {
 403:switcherator.c ****     statusMsg[0] = 0;
 404:switcherator.c ****     strcat(statusMsg, "fail 0x");
 405:switcherator.c ****     returnHex(failCode, tempIntString);
 406:switcherator.c ****     strcat(statusMsg, tempIntString);
 407:switcherator.c ****     sendMessage(statusMsg);
 408:switcherator.c **** }
 409:switcherator.c **** 
 410:switcherator.c **** void ok(void) {
 411:switcherator.c ****     sendMessage("ok");
 412:switcherator.c **** }
 413:switcherator.c **** 
 414:switcherator.c **** 
 415:switcherator.c **** // Helper function to get the switch number from char 3 and 4 of an array
 416:switcherator.c **** 
 417:switcherator.c **** int getSwitchNumber(char * commandReceived) {
  26               		.loc 1 417 0
  27               	.LVL0:
  28               	/* prologue: function */
  29               	/* frame size = 0 */
  30               	/* stack size = 0 */
  31               	.L__stack_usage = 0
 418:switcherator.c ****     int switchNumber = 0;
 419:switcherator.c ****     // get switch number
 420:switcherator.c ****     tempIntString[0] = commandReceived[3];
  32               		.loc 1 420 0
  33 0002 FC01      		movw r30,r24
  34 0004 2381      		ldd r18,Z+3
  35 0006 2093 0000 		sts tempIntString,r18
 421:switcherator.c ****     tempIntString[1] = commandReceived[4];
  36               		.loc 1 421 0
  37 000a 8481      		ldd r24,Z+4
  38               	.LVL1:
  39 000c 8093 0000 		sts tempIntString+1,r24
 422:switcherator.c ****     switchNumber = atoi(tempIntString);
  40               		.loc 1 422 0
  41 0010 80E0      		ldi r24,lo8(tempIntString)
  42 0012 90E0      		ldi r25,hi8(tempIntString)
  43 0014 0C94 0000 		jmp atoi
  44               	.LVL2:
  45               	.LFE12:
  47               	.global	getPort
  49               	getPort:
  50               	.LFB18:
 423:switcherator.c ****     return switchNumber;
 424:switcherator.c **** }
 425:switcherator.c **** 
 426:switcherator.c **** 
 427:switcherator.c **** /****************************************************************
 428:switcherator.c ****  *
 429:switcherator.c ****  *              All Things Switch Related
 430:switcherator.c ****  *
 431:switcherator.c ****  ****************************************************************/
 432:switcherator.c **** // Setup a new switch
 433:switcherator.c **** // NS:S#PpD
 434:switcherator.c **** // 01234567
 435:switcherator.c **** 
 436:switcherator.c **** void setNewSwitch(char * commandReceived) {
 437:switcherator.c ****     int switchNumber = 0;
 438:switcherator.c ****     char port = 0;
 439:switcherator.c ****     unsigned char pinMultiplied = 0;
 440:switcherator.c ****     unsigned char pinSubtractee = 0;
 441:switcherator.c ****     volatile unsigned char *realPort = 0;
 442:switcherator.c ****     volatile unsigned char *realDDR = 0;
 443:switcherator.c ****     char pin = 0;
 444:switcherator.c ****     char originalPin = 0;
 445:switcherator.c ****     char direction = 0;
 446:switcherator.c ****     tempIntString[0] = '0';
 447:switcherator.c ****     tempIntString[1] = commandReceived[6];
 448:switcherator.c ****     pin = atoi(tempIntString);
 449:switcherator.c ****     originalPin = pin;
 450:switcherator.c ****     tempIntString[1] = commandReceived[7];
 451:switcherator.c ****     direction = atoi(tempIntString);
 452:switcherator.c ****     port = commandReceived[5];
 453:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 454:switcherator.c ****     // make sure it is off before doing a new one.
 455:switcherator.c ****     clearTheSwitch(switchNumber);
 456:switcherator.c ****     // get the pin string ready for below
 457:switcherator.c ****     if (port == 'B' || port == 'b') {
 458:switcherator.c ****         realPort = &PORTB;
 459:switcherator.c ****         realDDR = &DDRB;
 460:switcherator.c ****         pinSubtractee = 16;
 461:switcherator.c **** #ifdef PORTA
 462:switcherator.c ****     } else if (port == 'A' || port == 'a') {
 463:switcherator.c ****         realPort = &PORTA;
 464:switcherator.c ****         realDDR = &DDRA;
 465:switcherator.c ****         pinSubtractee = 0;
 466:switcherator.c **** #endif
 467:switcherator.c **** #ifdef PORTC
 468:switcherator.c ****     } else if (port == 'C' || port == 'c') {
 469:switcherator.c ****         realPort = &PORTC;
 470:switcherator.c ****         realDDR = &DDRC;
 471:switcherator.c ****         pinSubtractee = 32;
 472:switcherator.c **** #endif
 473:switcherator.c **** #ifdef PORTD
 474:switcherator.c ****     } else if (port == 'D' || port == 'd') {
 475:switcherator.c ****         realPort = &PORTD;
 476:switcherator.c ****         realDDR = &DDRD;
 477:switcherator.c ****         pinSubtractee = 48;
 478:switcherator.c **** #endif
 479:switcherator.c **** #ifdef PORTE
 480:switcherator.c ****     } else if (port == 'E' || port == 'e') {
 481:switcherator.c ****         realPort = &PORTE;
 482:switcherator.c ****         realDDR = &DDRE;
 483:switcherator.c ****         pinSubtractee = 64;
 484:switcherator.c **** #endif
 485:switcherator.c **** #ifdef PORTF
 486:switcherator.c ****     } else if (port == 'F' || port == 'f') {
 487:switcherator.c ****         realPort = &PORTF;
 488:switcherator.c ****         realDDR = &DDRF;
 489:switcherator.c ****         pinSubtractee = 80;
 490:switcherator.c **** #endif
 491:switcherator.c **** #ifdef PORTG
 492:switcherator.c ****     } else if (port == 'G' || port == 'g') {
 493:switcherator.c ****         realPort = &PORTG;
 494:switcherator.c ****         realDDR = &DDRG;
 495:switcherator.c ****         pinSubtractee = 96;
 496:switcherator.c **** #endif
 497:switcherator.c **** #ifdef PORTH
 498:switcherator.c ****     } else if (port == 'H' || port == 'h') {
 499:switcherator.c ****         realPort = &PORTH;
 500:switcherator.c ****         realDDR = &DDRH;
 501:switcherator.c ****         pinSubtractee = 112;
 502:switcherator.c **** #endif
 503:switcherator.c **** #ifdef PORTI
 504:switcherator.c ****     } else if (port == 'I' || port == 'i') {
 505:switcherator.c ****         realPort = &PORTI;
 506:switcherator.c ****         realDDR = &DDRI;
 507:switcherator.c ****         pinSubtractee = 128;
 508:switcherator.c **** #endif
 509:switcherator.c **** 
 510:switcherator.c ****     }
 511:switcherator.c **** 
 512:switcherator.c **** 
 513:switcherator.c ****     if (realPort == 0) {
 514:switcherator.c ****         fail(2);
 515:switcherator.c ****     } else if ((switchNumber >= NUM_SWITCHES) ||
 516:switcherator.c ****             ((switchNumber == 0) && (commandReceived[3] != '0') && (commandReceived[4] != 0))) {
 517:switcherator.c ****         fail(1);
 518:switcherator.c ****     } else if ((pin > 7) || ((pin == 0) && (commandReceived[6] != '0'))) {
 519:switcherator.c ****         fail(4);
 520:switcherator.c ****     } else {
 521:switcherator.c ****         // set DDR out
 522:switcherator.c ****         *realDDR |= (1 << originalPin);
 523:switcherator.c ****         // double the pin and add 1 if it is high
 524:switcherator.c ****         pinMultiplied = pin * 2;
 525:switcherator.c ****         // turn switch off
 526:switcherator.c ****         pin = pinMultiplied + pinSubtractee;
 527:switcherator.c ****         switchStuff[switchNumber] = pin;
 528:switcherator.c **** 
 529:switcherator.c ****         if (direction == 0) {
 530:switcherator.c ****             // 0 = low is on  1 = high is on
 531:switcherator.c ****             *realPort |= (1 << originalPin);
 532:switcherator.c ****         } else {
 533:switcherator.c ****             *realPort &= ~(1 << originalPin);
 534:switcherator.c ****             switchStuff[switchNumber]++;
 535:switcherator.c ****         }
 536:switcherator.c ****         ok();
 537:switcherator.c ****     }
 538:switcherator.c **** }
 539:switcherator.c **** 
 540:switcherator.c **** // get rid of a switch and turn it off
 541:switcherator.c **** // SC:S#
 542:switcherator.c **** // 01234
 543:switcherator.c **** 
 544:switcherator.c **** void switchClear(char * commandReceived) {
 545:switcherator.c ****     int switchNumber = 0;
 546:switcherator.c ****     // get switch number
 547:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 548:switcherator.c ****     clearTheSwitch(switchNumber);
 549:switcherator.c ****     ok();
 550:switcherator.c **** }
 551:switcherator.c **** 
 552:switcherator.c **** // actual turning switch off (called with new switch as well)
 553:switcherator.c **** 
 554:switcherator.c **** void clearTheSwitch(int switchNumber) {
 555:switcherator.c ****     char port[] = {0};
 556:switcherator.c ****     char pin[] = {0};
 557:switcherator.c ****     char direction[] = {0};
 558:switcherator.c ****     volatile unsigned char *thisPort = 0;
 559:switcherator.c ****     volatile unsigned char *thisDDR = 0;
 560:switcherator.c ****     int realPin = 0;
 561:switcherator.c ****     // Figure out if it is pwm
 562:switcherator.c ****     if (switchStuff[switchNumber] >= 200 && switchStuff[switchNumber] <= 220) {
 563:switcherator.c ****         // if it is something else
 564:switcherator.c ****         pwmClear(switchNumber);
 565:switcherator.c ****         switchStuff[switchNumber] = 255;
 566:switcherator.c ****         return;
 567:switcherator.c ****     }
 568:switcherator.c ****     getPort(switchNumber, port, pin, direction);
 569:switcherator.c ****     if (port[0] == 'B') {
 570:switcherator.c ****         thisPort = &PORTB;
 571:switcherator.c ****         thisDDR = &DDRB;
 572:switcherator.c **** #ifdef PORTA
 573:switcherator.c ****     } else if (port[0] == 'A') {
 574:switcherator.c ****         thisPort = &PORTA;
 575:switcherator.c ****         thisDDR = &DDRA;
 576:switcherator.c **** #endif        
 577:switcherator.c **** #ifdef PORTC
 578:switcherator.c ****     } else if (port[0] == 'C') {
 579:switcherator.c ****         thisPort = &PORTC;
 580:switcherator.c ****         thisDDR = &DDRC;
 581:switcherator.c **** #endif        
 582:switcherator.c **** #ifdef PORTD
 583:switcherator.c ****     } else if (port[0] == 'D') {
 584:switcherator.c ****         thisPort = &PORTD;
 585:switcherator.c ****         thisDDR = &DDRD;
 586:switcherator.c **** #endif        
 587:switcherator.c **** #ifdef PORTE
 588:switcherator.c ****     } else if (port[0] == 'E') {
 589:switcherator.c ****         thisPort = &PORTE;
 590:switcherator.c ****         thisDDR = &DDRE;
 591:switcherator.c **** #endif        
 592:switcherator.c **** #ifdef PORTF
 593:switcherator.c ****     } else if (port[0] == 'F') {
 594:switcherator.c ****         thisPort = &PORTF;
 595:switcherator.c ****         thisDDR = &DDRF;
 596:switcherator.c **** #endif        
 597:switcherator.c **** #ifdef PORTG
 598:switcherator.c ****     } else if (port[0] == 'G') {
 599:switcherator.c ****         thisPort = &PORTG;
 600:switcherator.c ****         thisDDR = &DDRG;
 601:switcherator.c **** #endif        
 602:switcherator.c **** #ifdef PORTH
 603:switcherator.c ****     } else if (port[0] == 'H') {
 604:switcherator.c ****         thisPort = &PORTH;
 605:switcherator.c ****         thisDDR = &DDRH;
 606:switcherator.c **** #endif        
 607:switcherator.c **** #ifdef PORTI
 608:switcherator.c ****     } else if (port[0] == 'I') {
 609:switcherator.c ****         thisPort = &PORTI;
 610:switcherator.c ****         thisDDR = &DDRI;
 611:switcherator.c **** #endif        
 612:switcherator.c ****     }
 613:switcherator.c ****     realPin = pin[0];
 614:switcherator.c ****     *thisDDR &= ~(1 << realPin);
 615:switcherator.c ****     *thisPort &= ~(1 << realPin);
 616:switcherator.c ****     switchStuff[switchNumber] = 255;
 617:switcherator.c **** }
 618:switcherator.c **** 
 619:switcherator.c **** // show a summary of the switches
 620:switcherator.c **** 
 621:switcherator.c **** void switchDisplay(char * commandReceived) {
 622:switcherator.c ****     char port[] = {0};
 623:switcherator.c ****     char pin[] = {0};
 624:switcherator.c ****     char direction[] = {0};
 625:switcherator.c ****     int switchNumber = 0;
 626:switcherator.c ****     int realPin = 0;
 627:switcherator.c ****     char statusMsg[32];
 628:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 629:switcherator.c ****     statusMsg[0] = 0;
 630:switcherator.c ****     // see if this is a pwm switch
 631:switcherator.c ****     if (switchStuff[switchNumber] >= 200 && switchStuff[switchNumber] <= 220) {
 632:switcherator.c ****         // yes pwm
 633:switcherator.c ****         if (switchStuff[switchNumber] % 2 == 0) {
 634:switcherator.c ****             if (switchStuff[switchNumber] == 202) {
 635:switcherator.c ****                 strcat(statusMsg, "CoC");
 636:switcherator.c ****             } else if (switchStuff[switchNumber] == 212) {
 637:switcherator.c ****                 strcat(statusMsg, "Brt");
 638:switcherator.c ****             } else {
 639:switcherator.c ****                 strcat(statusMsg, "Fix");
 640:switcherator.c ****             }
 641:switcherator.c ****         } else {
 642:switcherator.c ****             strcat(statusMsg, "Hue");
 643:switcherator.c ****         }
 644:switcherator.c ****     } else {
 645:switcherator.c ****         getPort(switchNumber, port, pin, direction);
 646:switcherator.c ****         tempIntString[0] = port[0];
 647:switcherator.c ****         tempIntString[1] = 0;
 648:switcherator.c ****         strcat(statusMsg, tempIntString);
 649:switcherator.c ****         realPin = pin[0];
 650:switcherator.c ****         itoa(realPin, tempIntString, 10);
 651:switcherator.c ****         strcat(statusMsg, tempIntString);
 652:switcherator.c ****         if (direction[0] == 0) {
 653:switcherator.c ****             strcat(statusMsg, "L");
 654:switcherator.c ****         } else {
 655:switcherator.c ****             strcat(statusMsg, "H");
 656:switcherator.c ****         }
 657:switcherator.c ****     }
 658:switcherator.c ****     sendMessage(statusMsg);
 659:switcherator.c **** 
 660:switcherator.c **** }
 661:switcherator.c **** 
 662:switcherator.c **** // takes in a switch number and time and turns on the switch
 663:switcherator.c **** // SS S#Durat.
 664:switcherator.c **** // 01234567890
 665:switcherator.c **** 
 666:switcherator.c **** void startSwitch(char * commandReceived) {
 667:switcherator.c ****     unsigned long duration;
 668:switcherator.c ****     int switchNumber = 0;
 669:switcherator.c ****     // get switch number
 670:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 671:switcherator.c ****     if ((switchNumber >= NUM_SWITCHES) || (switchStuff[switchNumber] == 255)) {
 672:switcherator.c ****         fail(1);
 673:switcherator.c ****         return;
 674:switcherator.c ****     }
 675:switcherator.c ****     // get duration
 676:switcherator.c ****     tempHugeString[0] = commandReceived[5];
 677:switcherator.c ****     tempHugeString[1] = commandReceived[6];
 678:switcherator.c ****     tempHugeString[2] = commandReceived[7];
 679:switcherator.c ****     tempHugeString[3] = commandReceived[8];
 680:switcherator.c ****     tempHugeString[4] = commandReceived[9];
 681:switcherator.c ****     tempHugeString[5] = commandReceived[10];
 682:switcherator.c ****     duration = atol(tempHugeString);
 683:switcherator.c ****     if (duration == 0) {
 684:switcherator.c ****         fail(5);
 685:switcherator.c ****         return;
 686:switcherator.c ****     }
 687:switcherator.c ****     // only update the time if it is longer than what the switch is already turned on to
 688:switcherator.c ****     if ((weeklySeconds + duration) > switchStatus[switchNumber])
 689:switcherator.c ****         switchStatus[switchNumber] = (weeklySeconds + duration);
 690:switcherator.c **** 
 691:switcherator.c ****     // see if it is PWM
 692:switcherator.c ****     if (switchStuff[switchNumber] >= 200 && switchStuff[switchNumber] <= 220) {
 693:switcherator.c ****         // k it is PWM.  See if it is hue
 694:switcherator.c ****         if (switchStuff[switchNumber] == 200) {
 695:switcherator.c ****             // even number so values, not hue
 696:switcherator.c ****             red = pwmValues[0];
 697:switcherator.c ****             green = pwmValues[1];
 698:switcherator.c ****             blue = pwmValues[2];
 699:switcherator.c ****             red = red * bright / 16;
 700:switcherator.c ****             green = green * bright / 16;
 701:switcherator.c ****             blue = blue * bright / 16;
 702:switcherator.c ****             Red = red;
 703:switcherator.c ****             Green = green;
 704:switcherator.c ****             Blue = blue;
 705:switcherator.c ****         } else if (switchStuff[switchNumber] == 202) {
 706:switcherator.c ****             runColorChanges = 1;
 707:switcherator.c ****         } else if (switchStuff[switchNumber] == 212) {
 708:switcherator.c ****             bright = switchBright[switchNumber];
 709:switcherator.c ****         } else {
 710:switcherator.c ****             runHue = 1;
 711:switcherator.c ****         }
 712:switcherator.c **** 
 713:switcherator.c ****     } else {
 714:switcherator.c **** 
 715:switcherator.c ****         // get the port and turn it on
 716:switcherator.c ****         char port[1];
 717:switcherator.c ****         char pin[1];
 718:switcherator.c ****         int realPin = 0;
 719:switcherator.c ****         char direction[1];
 720:switcherator.c ****         volatile unsigned char *thisPort = 0;
 721:switcherator.c ****         getPort(switchNumber, port, pin, direction);
 722:switcherator.c ****         // yeah pointers and casts and whatevers. this fixes it
 723:switcherator.c ****         realPin = pin[0];
 724:switcherator.c ****         if (port[0] == 'B')
 725:switcherator.c ****             thisPort = &PORTB;
 726:switcherator.c **** #ifdef PORTA
 727:switcherator.c ****         else if (port[0] == 'A')
 728:switcherator.c ****             thisPort = &PORTA;
 729:switcherator.c **** #endif
 730:switcherator.c **** #ifdef PORTC
 731:switcherator.c ****         else if (port[0] == 'C')
 732:switcherator.c ****             thisPort = &PORTC;
 733:switcherator.c **** #endif
 734:switcherator.c **** #ifdef PORTD
 735:switcherator.c ****         else if (port[0] == 'D')
 736:switcherator.c ****             thisPort = &PORTD;
 737:switcherator.c **** #endif
 738:switcherator.c **** #ifdef PORTE
 739:switcherator.c ****         else if (port[0] == 'E')
 740:switcherator.c ****             thisPort = &PORTE;
 741:switcherator.c **** #endif
 742:switcherator.c **** #ifdef PORTF
 743:switcherator.c ****         else if (port[0] == 'F')
 744:switcherator.c ****             thisPort = &PORTF;
 745:switcherator.c **** #endif
 746:switcherator.c **** #ifdef PORTG
 747:switcherator.c ****         else if (port[0] == 'G')
 748:switcherator.c ****             thisPort = &PORTG;
 749:switcherator.c **** #endif
 750:switcherator.c **** #ifdef PORTH
 751:switcherator.c ****         else if (port[0] == 'H')
 752:switcherator.c ****             thisPort = &PORTH;
 753:switcherator.c **** #endif
 754:switcherator.c **** #ifdef PORTI
 755:switcherator.c ****         else if (port[0] == 'I')
 756:switcherator.c ****             thisPort = &PORTI;
 757:switcherator.c **** #endif
 758:switcherator.c **** 
 759:switcherator.c ****         // turn it on based on what direction
 760:switcherator.c ****         if (direction[0] == 0) {
 761:switcherator.c ****             *thisPort &= ~(1 << realPin);
 762:switcherator.c ****         } else {
 763:switcherator.c ****             *thisPort |= (1 << realPin);
 764:switcherator.c ****         }
 765:switcherator.c ****     }
 766:switcherator.c ****     ok();
 767:switcherator.c **** }
 768:switcherator.c **** // Takes in a switch number and returns the port (as a letter), pin, direction 0,1, and actual PORT
 769:switcherator.c **** 
 770:switcherator.c **** void getPort(int switchNumber, char * port, char * pin, char * direction) {
  51               		.loc 1 770 0
  52               	.LVL3:
  53               	/* prologue: function */
  54               	/* frame size = 0 */
  55               	/* stack size = 0 */
  56               	.L__stack_usage = 0
  57 0018 FB01      		movw r30,r22
 771:switcherator.c ****     char switchInfo = switchStuff[switchNumber];
  58               		.loc 1 771 0
  59 001a 8050      		subi r24,lo8(-(switchStuff))
  60 001c 9040      		sbci r25,hi8(-(switchStuff))
  61               	.LVL4:
  62 001e DC01      		movw r26,r24
  63 0020 8C91      		ld r24,X
  64               	.LVL5:
 772:switcherator.c ****     if ((switchInfo >= 16 && switchInfo < 32)) {
  65               		.loc 1 772 0
  66 0022 982F      		mov r25,r24
  67 0024 9051      		subi r25,lo8(-(-16))
  68 0026 9031      		cpi r25,lo8(16)
  69 0028 00F4      		brsh .L4
 773:switcherator.c ****         port[0] = 'B';
  70               		.loc 1 773 0
  71 002a 82E4      		ldi r24,lo8(66)
  72               	.LVL6:
  73 002c 8083      		st Z,r24
  74               	.LVL7:
  75 002e 00C0      		rjmp .L5
  76               	.LVL8:
  77               	.L4:
 774:switcherator.c ****         switchInfo -= 16;
 775:switcherator.c ****     } else if (switchInfo < 16) {
  78               		.loc 1 775 0
  79 0030 8031      		cpi r24,lo8(16)
  80 0032 00F4      		brsh .L6
 776:switcherator.c ****         port[0] = 'A';
  81               		.loc 1 776 0
  82 0034 91E4      		ldi r25,lo8(65)
  83 0036 9083      		st Z,r25
  84 0038 982F      		mov r25,r24
  85 003a 00C0      		rjmp .L5
  86               	.L6:
 777:switcherator.c ****         switchInfo -= 0;
 778:switcherator.c ****     } else if (switchInfo < 48) {
  87               		.loc 1 778 0
  88 003c 8033      		cpi r24,lo8(48)
  89 003e 00F4      		brsh .L7
 779:switcherator.c ****         port[0] = 'C';
  90               		.loc 1 779 0
  91 0040 93E4      		ldi r25,lo8(67)
  92 0042 9083      		st Z,r25
 780:switcherator.c ****         switchInfo -= 32;
  93               		.loc 1 780 0
  94 0044 982F      		mov r25,r24
  95 0046 9052      		subi r25,lo8(-(-32))
  96               	.LVL9:
  97 0048 00C0      		rjmp .L5
  98               	.LVL10:
  99               	.L7:
 781:switcherator.c ****     } else if (switchInfo < 64) {
 100               		.loc 1 781 0
 101 004a 8034      		cpi r24,lo8(64)
 102 004c 00F4      		brsh .L8
 782:switcherator.c ****         port[0] = 'D';
 103               		.loc 1 782 0
 104 004e 94E4      		ldi r25,lo8(68)
 105 0050 9083      		st Z,r25
 783:switcherator.c ****         switchInfo -= 48;
 106               		.loc 1 783 0
 107 0052 982F      		mov r25,r24
 108 0054 9053      		subi r25,lo8(-(-48))
 109               	.LVL11:
 110 0056 00C0      		rjmp .L5
 111               	.LVL12:
 112               	.L8:
 784:switcherator.c ****     } else if (switchInfo < 80) {
 113               		.loc 1 784 0
 114 0058 8035      		cpi r24,lo8(80)
 115 005a 00F4      		brsh .L9
 785:switcherator.c ****         port[0] = 'E';
 116               		.loc 1 785 0
 117 005c 95E4      		ldi r25,lo8(69)
 118 005e 9083      		st Z,r25
 786:switcherator.c ****         switchInfo -= 64;
 119               		.loc 1 786 0
 120 0060 982F      		mov r25,r24
 121 0062 9054      		subi r25,lo8(-(-64))
 122               	.LVL13:
 123 0064 00C0      		rjmp .L5
 124               	.LVL14:
 125               	.L9:
 787:switcherator.c ****     } else if (switchInfo < 96) {
 126               		.loc 1 787 0
 127 0066 8036      		cpi r24,lo8(96)
 128 0068 00F4      		brsh .L10
 788:switcherator.c ****         port[0] = 'F';
 129               		.loc 1 788 0
 130 006a 96E4      		ldi r25,lo8(70)
 131 006c 9083      		st Z,r25
 789:switcherator.c ****         switchInfo -= 80;
 132               		.loc 1 789 0
 133 006e 982F      		mov r25,r24
 134 0070 9055      		subi r25,lo8(-(-80))
 135               	.LVL15:
 136 0072 00C0      		rjmp .L5
 137               	.LVL16:
 138               	.L10:
 790:switcherator.c ****     } else if (switchInfo < 112) {
 139               		.loc 1 790 0
 140 0074 8037      		cpi r24,lo8(112)
 141 0076 00F4      		brsh .L11
 791:switcherator.c ****         port[0] = 'G';
 142               		.loc 1 791 0
 143 0078 97E4      		ldi r25,lo8(71)
 144 007a 9083      		st Z,r25
 792:switcherator.c ****         switchInfo -= 96;
 145               		.loc 1 792 0
 146 007c 982F      		mov r25,r24
 147 007e 9056      		subi r25,lo8(-(-96))
 148               	.LVL17:
 149 0080 00C0      		rjmp .L5
 150               	.LVL18:
 151               	.L11:
 793:switcherator.c ****     } else if (switchInfo < 128) {
 152               		.loc 1 793 0
 153 0082 87FD      		sbrc r24,7
 154 0084 00C0      		rjmp .L12
 794:switcherator.c ****         port[0] = 'H';
 155               		.loc 1 794 0
 156 0086 98E4      		ldi r25,lo8(72)
 157 0088 9083      		st Z,r25
 795:switcherator.c ****         switchInfo -= 112;
 158               		.loc 1 795 0
 159 008a 982F      		mov r25,r24
 160 008c 9057      		subi r25,lo8(-(-112))
 161               	.LVL19:
 162 008e 00C0      		rjmp .L5
 163               	.LVL20:
 164               	.L12:
 796:switcherator.c ****     } else if (switchInfo < 144) {
 165               		.loc 1 796 0
 166 0090 8039      		cpi r24,lo8(-112)
 167 0092 00F4      		brsh .L13
 797:switcherator.c ****         port[0] = 'I';
 168               		.loc 1 797 0
 169 0094 99E4      		ldi r25,lo8(73)
 170 0096 9083      		st Z,r25
 798:switcherator.c ****         switchInfo -= 128;
 171               		.loc 1 798 0
 172 0098 982F      		mov r25,r24
 173 009a 9058      		subi r25,lo8(-(-128))
 174               	.LVL21:
 175 009c 00C0      		rjmp .L5
 176               	.LVL22:
 177               	.L13:
 799:switcherator.c ****     } else {
 800:switcherator.c ****         port[0] = '?';
 178               		.loc 1 800 0
 179 009e 8FE3      		ldi r24,lo8(63)
 180               	.LVL23:
 181 00a0 8083      		st Z,r24
 801:switcherator.c ****         pin[0] = 0;
 182               		.loc 1 801 0
 183 00a2 FA01      		movw r30,r20
 184 00a4 1082      		st Z,__zero_reg__
 802:switcherator.c ****         direction[0] = 0;
 185               		.loc 1 802 0
 186 00a6 D901      		movw r26,r18
 187               	.LVL24:
 188 00a8 1C92      		st X,__zero_reg__
 803:switcherator.c ****         return;
 189               		.loc 1 803 0
 190 00aa 0895      		ret
 191               	.LVL25:
 192               	.L5:
 804:switcherator.c ****     }
 805:switcherator.c ****     pin[0] = switchInfo / 2;
 193               		.loc 1 805 0
 194 00ac 892F      		mov r24,r25
 195 00ae 8695      		lsr r24
 196 00b0 FA01      		movw r30,r20
 197 00b2 8083      		st Z,r24
 806:switcherator.c ****     direction[0] = switchInfo % 2;
 198               		.loc 1 806 0
 199 00b4 9170      		andi r25,lo8(1)
 200               	.LVL26:
 201 00b6 D901      		movw r26,r18
 202 00b8 9C93      		st X,r25
 203 00ba 0895      		ret
 204               	.LFE18:
 206               	.global	pwmClear
 208               	pwmClear:
 209               	.LFB21:
 807:switcherator.c **** }
 808:switcherator.c **** 
 809:switcherator.c **** // assign a secondary brightness to a switch
 810:switcherator.c **** // sb s#16
 811:switcherator.c **** 
 812:switcherator.c **** void switchBrightness(char * commandReceived) {
 813:switcherator.c ****     int switchNumber = getSwitchNumber(commandReceived);
 814:switcherator.c ****     char tempBright = 0;
 815:switcherator.c ****     if (switchNumber >= NUM_SWITCHES) {
 816:switcherator.c ****         fail(1);
 817:switcherator.c ****         return;
 818:switcherator.c ****     }
 819:switcherator.c ****     tempIntString[0] = commandReceived[5];
 820:switcherator.c ****     tempIntString[1] = commandReceived[6];
 821:switcherator.c ****     char brightValue = atoi(tempIntString);
 822:switcherator.c ****     if (brightValue == 0) {
 823:switcherator.c ****         tempBright = switchBright[switchNumber];
 824:switcherator.c ****         itoa(tempBright, tempIntString, 10);
 825:switcherator.c ****         statusMsg[0] = 0;
 826:switcherator.c ****         strcat(statusMsg, "Set @");
 827:switcherator.c ****         strcat(statusMsg, tempIntString);
 828:switcherator.c ****         sendMessage(statusMsg);
 829:switcherator.c ****     } else {
 830:switcherator.c ****         if (brightValue > 16)
 831:switcherator.c ****             brightValue = 16;
 832:switcherator.c ****         clearTheSwitch(switchNumber);
 833:switcherator.c ****         // value to indicate this is brightness
 834:switcherator.c ****         switchStuff[switchNumber] = 212;
 835:switcherator.c ****         switchBright[switchNumber] = brightValue;
 836:switcherator.c ****         ok();
 837:switcherator.c ****     }
 838:switcherator.c **** }
 839:switcherator.c **** 
 840:switcherator.c **** /****************************************************************
 841:switcherator.c ****  *
 842:switcherator.c ****  *              All Things PWM Related
 843:switcherator.c ****  *
 844:switcherator.c ****  ****************************************************************/
 845:switcherator.c **** 
 846:switcherator.c **** // PWM setup.  This is initially  geared for the 328p but the framework
 847:switcherator.c **** // exists for other chips
 848:switcherator.c **** // PS:P#S#DH
 849:switcherator.c **** // 012345678
 850:switcherator.c **** 
 851:switcherator.c **** void pwmSetup(char * commandReceived) {
 852:switcherator.c ****     int x = 0;
 853:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 854:switcherator.c ****         if (switchStuff[x] == 70 || switchStuff[x] == 71 || switchStuff[x] == 74 ||
 855:switcherator.c ****                 switchStuff[x] == 75 || switchStuff[x] == 76 || switchStuff[x] == 77) {
 856:switcherator.c ****             fail(6);
 857:switcherator.c ****             return;
 858:switcherator.c ****         }
 859:switcherator.c ****     }
 860:switcherator.c ****     int switchNumber = 0;
 861:switcherator.c ****     // get switch number
 862:switcherator.c ****     tempIntString[0] = commandReceived[5];
 863:switcherator.c ****     tempIntString[1] = commandReceived[6];
 864:switcherator.c ****     switchNumber = atoi(tempIntString);
 865:switcherator.c ****     clearTheSwitch(switchNumber);
 866:switcherator.c ****     // set up a hue pwm
 867:switcherator.c ****     if (commandReceived[8] == 'H' || commandReceived[8] == 'h' || commandReceived[8] == '1') {
 868:switcherator.c ****         switchStuff[switchNumber] = 201;
 869:switcherator.c ****     } else if (commandReceived[8] == 'C' || commandReceived[8] == 'c') {
 870:switcherator.c ****         switchStuff[switchNumber] = 202;
 871:switcherator.c ****     } else {
 872:switcherator.c ****         switchStuff[switchNumber] = 200;
 873:switcherator.c ****     }
 874:switcherator.c ****     DDRD |= (1 << PIND3) | (1 << PIND5) | (1 << PIND6);
 875:switcherator.c ****     // make sure initial values are 0
 876:switcherator.c ****     Red = 0;
 877:switcherator.c ****     Green = 0;
 878:switcherator.c ****     Blue = 0;
 879:switcherator.c ****     // Set output phase correct whatevers
 880:switcherator.c ****     // set it to inverted if the direction is 0
 881:switcherator.c ****     if (commandReceived[7] == '0') {
 882:switcherator.c ****         pwmdir = 0;
 883:switcherator.c ****         TCCR0A = (1 << COM0A0) | (1 << COM0A1) | (1 << COM0B0) | (1 << COM0B1) | (1 << WGM00);
 884:switcherator.c ****         TCCR2A = (1 << COM2B0) | (1 << COM2B1) | (1 << WGM20);
 885:switcherator.c ****     } else {
 886:switcherator.c ****         pwmdir = 1;
 887:switcherator.c ****         TCCR0A = (1 << COM0A1) | (1 << COM0B1) | (1 << WGM00);
 888:switcherator.c ****         TCCR2A = (1 << COM2B1) | (1 << WGM20);
 889:switcherator.c ****     }
 890:switcherator.c ****     // F_CPU/64 timers
 891:switcherator.c ****     TCCR0B = (1 << CS01) | (1 << CS00);
 892:switcherator.c **** 
 893:switcherator.c ****     TCCR2B = (1 << CS22); // F_CPU/64
 894:switcherator.c ****     // pwm to output
 895:switcherator.c ****     ok();
 896:switcherator.c **** }
 897:switcherator.c **** 
 898:switcherator.c **** // Turn off the PWM - called by clearing the switch
 899:switcherator.c **** 
 900:switcherator.c **** void pwmClear(int switchNumber) {
 210               		.loc 1 900 0
 211               	.LVL27:
 212               	/* prologue: function */
 213               	/* frame size = 0 */
 214               	/* stack size = 0 */
 215               	.L__stack_usage = 0
 901:switcherator.c ****     if (switchStuff[switchNumber] == 212) {
 216               		.loc 1 901 0
 217 00bc 8050      		subi r24,lo8(-(switchStuff))
 218 00be 9040      		sbci r25,hi8(-(switchStuff))
 219               	.LVL28:
 220 00c0 FC01      		movw r30,r24
 221 00c2 8081      		ld r24,Z
 222               	.LVL29:
 223 00c4 843D      		cpi r24,lo8(-44)
 224 00c6 01F4      		brne .L16
 902:switcherator.c ****         bright = oldBright;
 225               		.loc 1 902 0
 226 00c8 8091 0000 		lds r24,oldBright
 227 00cc 8093 0000 		sts bright,r24
 228 00d0 1092 0000 		sts bright+1,__zero_reg__
 229 00d4 0895      		ret
 230               	.L16:
 903:switcherator.c ****     } else {
 904:switcherator.c ****         TCCR0A = 0;
 231               		.loc 1 904 0
 232 00d6 14BC      		out 0x24,__zero_reg__
 905:switcherator.c ****         TCCR0B = 0;
 233               		.loc 1 905 0
 234 00d8 15BC      		out 0x25,__zero_reg__
 906:switcherator.c ****         TCCR2A = 0;
 235               		.loc 1 906 0
 236 00da 1092 B000 		sts 176,__zero_reg__
 907:switcherator.c ****         TCCR2B = 0;
 237               		.loc 1 907 0
 238 00de 1092 B100 		sts 177,__zero_reg__
 908:switcherator.c ****         Red = 0;
 239               		.loc 1 908 0
 240 00e2 1092 B400 		sts 180,__zero_reg__
 909:switcherator.c ****         Green = 0;
 241               		.loc 1 909 0
 242 00e6 18BC      		out 0x28,__zero_reg__
 910:switcherator.c ****         Blue = 0;
 243               		.loc 1 910 0
 244 00e8 17BC      		out 0x27,__zero_reg__
 911:switcherator.c ****         DDRD &= ~((1 << PIND3)&(1 << PIND5)&(1 << PIND6));
 245               		.loc 1 911 0
 246 00ea 8AB1      		in r24,0xa
 247 00ec 8AB9      		out 0xa,r24
 912:switcherator.c ****         runHue = 0;
 248               		.loc 1 912 0
 249 00ee 1092 0000 		sts runHue,__zero_reg__
 913:switcherator.c ****         runColorChanges = 0;
 250               		.loc 1 913 0
 251 00f2 1092 0000 		sts runColorChanges,__zero_reg__
 252 00f6 0895      		ret
 253               	.LFE21:
 255               	.global	clearTheSwitch
 257               	clearTheSwitch:
 258               	.LFB15:
 554:switcherator.c **** void clearTheSwitch(int switchNumber) {
 259               		.loc 1 554 0
 260               	.LVL30:
 261 00f8 EF92      		push r14
 262               	.LCFI0:
 263 00fa FF92      		push r15
 264               	.LCFI1:
 265 00fc 0F93      		push r16
 266               	.LCFI2:
 267 00fe 1F93      		push r17
 268               	.LCFI3:
 269 0100 CF93      		push r28
 270               	.LCFI4:
 271 0102 DF93      		push r29
 272               	.LCFI5:
 273 0104 00D0      		rcall .
 274 0106 1F92      		push __zero_reg__
 275               	.LCFI6:
 276 0108 CDB7      		in r28,__SP_L__
 277 010a DEB7      		in r29,__SP_H__
 278               	.LCFI7:
 279               	/* prologue: function */
 280               	/* frame size = 3 */
 281               	/* stack size = 9 */
 282               	.L__stack_usage = 9
 283 010c 8C01      		movw r16,r24
 555:switcherator.c ****     char port[] = {0};
 284               		.loc 1 555 0
 285 010e 1B82      		std Y+3,__zero_reg__
 556:switcherator.c ****     char pin[] = {0};
 286               		.loc 1 556 0
 287 0110 1A82      		std Y+2,__zero_reg__
 557:switcherator.c ****     char direction[] = {0};
 288               		.loc 1 557 0
 289 0112 1982      		std Y+1,__zero_reg__
 290               	.LVL31:
 562:switcherator.c ****     if (switchStuff[switchNumber] >= 200 && switchStuff[switchNumber] <= 220) {
 291               		.loc 1 562 0
 292 0114 80E0      		ldi r24,lo8(switchStuff)
 293 0116 E82E      		mov r14,r24
 294 0118 80E0      		ldi r24,hi8(switchStuff)
 295 011a F82E      		mov r15,r24
 296               	.LVL32:
 297 011c E00E      		add r14,r16
 298 011e F11E      		adc r15,r17
 299 0120 F701      		movw r30,r14
 300 0122 8081      		ld r24,Z
 301 0124 885C      		subi r24,lo8(-(56))
 302 0126 8531      		cpi r24,lo8(21)
 303 0128 00F4      		brsh .L19
 564:switcherator.c ****         pwmClear(switchNumber);
 304               		.loc 1 564 0
 305 012a C801      		movw r24,r16
 306 012c 0E94 0000 		call pwmClear
 307               	.LVL33:
 565:switcherator.c ****         switchStuff[switchNumber] = 255;
 308               		.loc 1 565 0
 309 0130 8FEF      		ldi r24,lo8(-1)
 310 0132 F701      		movw r30,r14
 311 0134 00C0      		rjmp .L25
 312               	.L19:
 568:switcherator.c ****     getPort(switchNumber, port, pin, direction);
 313               		.loc 1 568 0
 314 0136 9E01      		movw r18,r28
 315 0138 2F5F      		subi r18,-1
 316 013a 3F4F      		sbci r19,-1
 317 013c AE01      		movw r20,r28
 318 013e 4E5F      		subi r20,-2
 319 0140 5F4F      		sbci r21,-1
 320 0142 BE01      		movw r22,r28
 321 0144 6D5F      		subi r22,-3
 322 0146 7F4F      		sbci r23,-1
 323 0148 C801      		movw r24,r16
 324 014a 0E94 0000 		call getPort
 325               	.LVL34:
 569:switcherator.c ****     if (port[0] == 'B') {
 326               		.loc 1 569 0
 327 014e 8B81      		ldd r24,Y+3
 328 0150 8234      		cpi r24,lo8(66)
 329 0152 01F0      		breq .L22
 578:switcherator.c ****     } else if (port[0] == 'C') {
 330               		.loc 1 578 0
 331 0154 8334      		cpi r24,lo8(67)
 332 0156 01F0      		breq .L23
 583:switcherator.c ****     } else if (port[0] == 'D') {
 333               		.loc 1 583 0
 334 0158 8434      		cpi r24,lo8(68)
 335 015a 01F0      		breq .L24
 559:switcherator.c ****     volatile unsigned char *thisDDR = 0;
 336               		.loc 1 559 0
 337 015c A0E0      		ldi r26,0
 338 015e B0E0      		ldi r27,0
 558:switcherator.c ****     volatile unsigned char *thisPort = 0;
 339               		.loc 1 558 0
 340 0160 E0E0      		ldi r30,0
 341 0162 F0E0      		ldi r31,0
 342 0164 00C0      		rjmp .L21
 343               	.L22:
 571:switcherator.c ****         thisDDR = &DDRB;
 344               		.loc 1 571 0
 345 0166 A4E2      		ldi r26,lo8(36)
 346 0168 B0E0      		ldi r27,0
 570:switcherator.c ****         thisPort = &PORTB;
 347               		.loc 1 570 0
 348 016a E5E2      		ldi r30,lo8(37)
 349 016c F0E0      		ldi r31,0
 350 016e 00C0      		rjmp .L21
 351               	.L23:
 580:switcherator.c ****         thisDDR = &DDRC;
 352               		.loc 1 580 0
 353 0170 A7E2      		ldi r26,lo8(39)
 354 0172 B0E0      		ldi r27,0
 579:switcherator.c ****         thisPort = &PORTC;
 355               		.loc 1 579 0
 356 0174 E8E2      		ldi r30,lo8(40)
 357 0176 F0E0      		ldi r31,0
 358 0178 00C0      		rjmp .L21
 359               	.L24:
 585:switcherator.c ****         thisDDR = &DDRD;
 360               		.loc 1 585 0
 361 017a AAE2      		ldi r26,lo8(42)
 362 017c B0E0      		ldi r27,0
 584:switcherator.c ****         thisPort = &PORTD;
 363               		.loc 1 584 0
 364 017e EBE2      		ldi r30,lo8(43)
 365 0180 F0E0      		ldi r31,0
 366               	.L21:
 367               	.LVL35:
 614:switcherator.c ****     *thisDDR &= ~(1 << realPin);
 368               		.loc 1 614 0
 369 0182 2C91      		ld r18,X
 370 0184 81E0      		ldi r24,lo8(1)
 371 0186 90E0      		ldi r25,0
 372 0188 0A80      		ldd r0,Y+2
 373 018a 00C0      		rjmp 2f
 374               		1:
 375 018c 880F      		lsl r24
 376 018e 991F      		rol r25
 377               		2:
 378 0190 0A94      		dec r0
 379 0192 02F4      		brpl 1b
 380 0194 8095      		com r24
 381 0196 2823      		and r18,r24
 382 0198 2C93      		st X,r18
 615:switcherator.c ****     *thisPort &= ~(1 << realPin);
 383               		.loc 1 615 0
 384 019a 9081      		ld r25,Z
 385 019c 9823      		and r25,r24
 386 019e 9083      		st Z,r25
 616:switcherator.c ****     switchStuff[switchNumber] = 255;
 387               		.loc 1 616 0
 388 01a0 F801      		movw r30,r16
 389               	.LVL36:
 390 01a2 E050      		subi r30,lo8(-(switchStuff))
 391 01a4 F040      		sbci r31,hi8(-(switchStuff))
 392 01a6 8FEF      		ldi r24,lo8(-1)
 393               	.LVL37:
 394               	.L25:
 395 01a8 8083      		st Z,r24
 396               	/* epilogue start */
 617:switcherator.c **** }
 397               		.loc 1 617 0
 398 01aa 0F90      		pop __tmp_reg__
 399 01ac 0F90      		pop __tmp_reg__
 400 01ae 0F90      		pop __tmp_reg__
 401 01b0 DF91      		pop r29
 402 01b2 CF91      		pop r28
 403 01b4 1F91      		pop r17
 404 01b6 0F91      		pop r16
 405               	.LVL38:
 406 01b8 FF90      		pop r15
 407 01ba EF90      		pop r14
 408 01bc 0895      		ret
 409               	.LFE15:
 411               	.global	runColorFunction
 413               	runColorFunction:
 414               	.LFB27:
 914:switcherator.c ****     }
 915:switcherator.c **** }
 916:switcherator.c **** 
 917:switcherator.c **** // This just sets up the times for the PWM hues
 918:switcherator.c **** // CH:P#TTTTT 
 919:switcherator.c **** // 0123456789
 920:switcherator.c **** 
 921:switcherator.c **** void cycleHue(char * commandReceived) {
 922:switcherator.c ****     // right now we just have 1 pwm but I could add more
 923:switcherator.c ****     tempLongString[0] = commandReceived[5];
 924:switcherator.c ****     tempLongString[1] = commandReceived[6];
 925:switcherator.c ****     tempLongString[2] = commandReceived[7];
 926:switcherator.c ****     tempLongString[3] = commandReceived[8];
 927:switcherator.c ****     int programNumber = 0;
 928:switcherator.c ****     programNumber = atoi(tempLongString);
 929:switcherator.c ****     if (programNumber > 0)
 930:switcherator.c ****         colorChangeSpeed = programNumber;
 931:switcherator.c ****     ok();
 932:switcherator.c **** }
 933:switcherator.c **** 
 934:switcherator.c **** // Changes the hue speed
 935:switcherator.c **** // HS:xx
 936:switcherator.c **** 
 937:switcherator.c **** void setHueSpeed(char * commandReceived) {
 938:switcherator.c ****     tempIntString[0] = commandReceived[3];
 939:switcherator.c ****     tempIntString[1] = commandReceived[4];
 940:switcherator.c ****     int programNumber = 0;
 941:switcherator.c ****     programNumber = atoi(tempIntString);
 942:switcherator.c ****     if (programNumber > 0)
 943:switcherator.c ****         hueSpeed = programNumber;
 944:switcherator.c ****     ok();
 945:switcherator.c **** }
 946:switcherator.c **** 
 947:switcherator.c **** 
 948:switcherator.c **** // set up the values for a solid pwm
 949:switcherator.c **** // PV:P#,vvv,vvv,vvv
 950:switcherator.c **** // 01234567890123456
 951:switcherator.c **** 
 952:switcherator.c **** void pwmValueSet(char * commandReceived) {
 953:switcherator.c ****     tempLongString[3] = 0;
 954:switcherator.c ****     tempLongString[0] = commandReceived[6];
 955:switcherator.c ****     tempLongString[1] = commandReceived[7];
 956:switcherator.c ****     tempLongString[2] = commandReceived[8];
 957:switcherator.c ****     pwmValues[0] = atoi(tempLongString);
 958:switcherator.c ****     tempLongString[0] = commandReceived[10];
 959:switcherator.c ****     tempLongString[1] = commandReceived[11];
 960:switcherator.c ****     tempLongString[2] = commandReceived[12];
 961:switcherator.c ****     pwmValues[1] = atoi(tempLongString);
 962:switcherator.c ****     tempLongString[0] = commandReceived[14];
 963:switcherator.c ****     tempLongString[1] = commandReceived[15];
 964:switcherator.c ****     tempLongString[2] = commandReceived[16];
 965:switcherator.c ****     pwmValues[2] = atoi(tempLongString);
 966:switcherator.c ****     statusMsg[0] = 0;
 967:switcherator.c ****     ok();
 968:switcherator.c **** }
 969:switcherator.c **** 
 970:switcherator.c **** // add a color to the color change
 971:switcherator.c **** // CC:##,vvv,vvv,vvv
 972:switcherator.c **** // 01234567890123456
 973:switcherator.c **** 
 974:switcherator.c **** void colorChangeSet(char * commandReceived) {
 975:switcherator.c ****     int programNumber = getSwitchNumber(commandReceived);
 976:switcherator.c ****     if (programNumber >= NUM_COLOR_CHANGES) {
 977:switcherator.c ****         fail(7);
 978:switcherator.c ****         return;
 979:switcherator.c ****     }
 980:switcherator.c ****     tempLongString[3] = 0;
 981:switcherator.c ****     tempLongString[0] = commandReceived[6];
 982:switcherator.c ****     tempLongString[1] = commandReceived[7];
 983:switcherator.c ****     tempLongString[2] = commandReceived[8];
 984:switcherator.c ****     colorChanges[programNumber][0] = atoi(tempLongString);
 985:switcherator.c ****     tempLongString[0] = commandReceived[10];
 986:switcherator.c ****     tempLongString[1] = commandReceived[11];
 987:switcherator.c ****     tempLongString[2] = commandReceived[12];
 988:switcherator.c ****     colorChanges[programNumber][1] = atoi(tempLongString);
 989:switcherator.c ****     tempLongString[0] = commandReceived[14];
 990:switcherator.c ****     tempLongString[1] = commandReceived[15];
 991:switcherator.c ****     tempLongString[2] = commandReceived[16];
 992:switcherator.c ****     colorChanges[programNumber][2] = atoi(tempLongString);
 993:switcherator.c ****     ok();
 994:switcherator.c **** }
 995:switcherator.c **** 
 996:switcherator.c **** // show the pwm values & color change values
 997:switcherator.c **** 
 998:switcherator.c **** void pwmSummary(void) {
 999:switcherator.c ****     statusMsg[0] = 0;
1000:switcherator.c ****     strcat(statusMsg, "Val 0x");
1001:switcherator.c ****     int x = 0;
1002:switcherator.c ****     for (x = 0; x < 3; x++) {
1003:switcherator.c ****         if (x > 0)
1004:switcherator.c ****             strcat(statusMsg, ",");
1005:switcherator.c ****         returnHexWithout(pwmValues[x], tempLongString);
1006:switcherator.c ****         strcat(statusMsg, tempLongString);
1007:switcherator.c ****     }
1008:switcherator.c ****     strcat(statusMsg, " dir ");
1009:switcherator.c ****     returnInt(pwmdir, tempLongString);
1010:switcherator.c ****     strcat(statusMsg, tempLongString);
1011:switcherator.c ****     sendMessage(statusMsg);
1012:switcherator.c ****     statusMsg[0] = 0;
1013:switcherator.c ****     strcat(statusMsg, "Col Ch");
1014:switcherator.c ****     int y = 0;
1015:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
1016:switcherator.c ****         if (x > 0)
1017:switcherator.c ****             strcat(statusMsg, ",");
1018:switcherator.c ****         strcat(statusMsg, "0x");
1019:switcherator.c ****         for (y = 0; y < 3; y++) {
1020:switcherator.c ****             returnHexWithout(colorChanges[x][y], tempLongString);
1021:switcherator.c ****             strcat(statusMsg, tempLongString);
1022:switcherator.c ****         }
1023:switcherator.c ****         if (strlen(statusMsg) > 25 && (x + 1) < NUM_COLOR_CHANGES) {
1024:switcherator.c ****             sendMessage(statusMsg);
1025:switcherator.c ****             statusMsg[6] = 0;
1026:switcherator.c ****         }
1027:switcherator.c ****     }
1028:switcherator.c ****     sendMessage(statusMsg);
1029:switcherator.c ****     statusMsg[0] = 0;
1030:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
1031:switcherator.c ****         if ((switchStuff[x] >= 200) && (switchStuff[x] <= 220)) {
1032:switcherator.c ****             strcat(statusMsg, "PWM ");
1033:switcherator.c ****             if (switchStuff[x] == 200) {
1034:switcherator.c ****                 strcat(statusMsg, "static");
1035:switcherator.c ****             } else if (switchStuff[x] == 202) {
1036:switcherator.c ****                 strcat(statusMsg, "ColCh");
1037:switcherator.c ****             } else {
1038:switcherator.c ****                 strcat(statusMsg, "hue");
1039:switcherator.c ****             }
1040:switcherator.c ****             strcat(statusMsg, "on sw# ");
1041:switcherator.c ****             returnInt(x, tempLongString);
1042:switcherator.c ****             strcat(statusMsg, tempLongString);
1043:switcherator.c ****             sendMessage(statusMsg);
1044:switcherator.c ****             statusMsg[0] = 0;
1045:switcherator.c ****         }
1046:switcherator.c ****     }
1047:switcherator.c **** }
1048:switcherator.c **** // HardwarePWM
1049:switcherator.c **** //static char runHue = 0;
1050:switcherator.c **** // PD3, PD5, PD6 or red,green,blue
1051:switcherator.c **** //static char pwmValues[] = {0 , 0 , 0};
1052:switcherator.c **** 
1053:switcherator.c **** // Run color function
1054:switcherator.c **** // goes through the colors and switches them.
1055:switcherator.c **** 
1056:switcherator.c **** void runColorFunction(void) {
 415               		.loc 1 1056 0
 416               	/* prologue: function */
 417               	/* frame size = 0 */
 418               	/* stack size = 0 */
 419               	.L__stack_usage = 0
1057:switcherator.c ****     // delay
1058:switcherator.c ****     colorChangeCount++;
 420               		.loc 1 1058 0
 421 01be 8091 0000 		lds r24,colorChangeCount
 422 01c2 9091 0000 		lds r25,colorChangeCount+1
 423 01c6 0196      		adiw r24,1
 424 01c8 9093 0000 		sts colorChangeCount+1,r25
 425 01cc 8093 0000 		sts colorChangeCount,r24
1059:switcherator.c ****     if (colorChangeCount < colorChangeSpeed)
 426               		.loc 1 1059 0
 427 01d0 2091 0000 		lds r18,colorChangeSpeed
 428 01d4 3091 0000 		lds r19,colorChangeSpeed+1
 429 01d8 8217      		cp r24,r18
 430 01da 9307      		cpc r25,r19
 431 01dc 00F4      		brsh .+2
 432 01de 00C0      		rjmp .L26
1060:switcherator.c ****         return;
1061:switcherator.c ****     colorChangeCount = 0;
 433               		.loc 1 1061 0
 434 01e0 1092 0000 		sts colorChangeCount+1,__zero_reg__
 435 01e4 1092 0000 		sts colorChangeCount,__zero_reg__
1062:switcherator.c ****     currentColor++;
 436               		.loc 1 1062 0
 437 01e8 8091 0000 		lds r24,currentColor
 438 01ec 8F5F      		subi r24,lo8(-(1))
1063:switcherator.c ****     if (currentColor == NUM_COLOR_CHANGES)
 439               		.loc 1 1063 0
 440 01ee 8630      		cpi r24,lo8(6)
 441 01f0 01F0      		breq .L29
1062:switcherator.c ****     currentColor++;
 442               		.loc 1 1062 0
 443 01f2 8093 0000 		sts currentColor,r24
 444 01f6 00C0      		rjmp .L30
 445               	.L29:
1064:switcherator.c ****         currentColor = 0;
 446               		.loc 1 1064 0
 447 01f8 1092 0000 		sts currentColor,__zero_reg__
 448               	.L30:
1065:switcherator.c ****     if (colorChanges[currentColor][0] == 0 &&
 449               		.loc 1 1065 0
 450 01fc 2091 0000 		lds r18,currentColor
 451 0200 822F      		mov r24,r18
 452 0202 90E0      		ldi r25,0
 453 0204 FC01      		movw r30,r24
 454 0206 EE0F      		lsl r30
 455 0208 FF1F      		rol r31
 456 020a E80F      		add r30,r24
 457 020c F91F      		adc r31,r25
 458 020e E050      		subi r30,lo8(-(colorChanges))
 459 0210 F040      		sbci r31,hi8(-(colorChanges))
 460 0212 8081      		ld r24,Z
 461 0214 8111      		cpse r24,__zero_reg__
 462 0216 00C0      		rjmp .L31
 463               		.loc 1 1065 0 is_stmt 0 discriminator 1
 464 0218 8181      		ldd r24,Z+1
 465 021a 8130      		cpi r24,lo8(1)
 466 021c 01F4      		brne .L31
1066:switcherator.c ****             colorChanges[currentColor][1] == 1 &&
 467               		.loc 1 1066 0 is_stmt 1
 468 021e 8281      		ldd r24,Z+2
 469 0220 8111      		cpse r24,__zero_reg__
 470 0222 00C0      		rjmp .L31
1067:switcherator.c ****             colorChanges[currentColor][2] == 0) {
1068:switcherator.c ****         // this one is blank.
1069:switcherator.c ****         if (currentColor == 0)
 471               		.loc 1 1069 0
 472 0224 2223      		tst r18
 473 0226 01F4      		brne .+2
 474 0228 00C0      		rjmp .L26
1070:switcherator.c ****             return;
1071:switcherator.c ****         currentColor = 0;
 475               		.loc 1 1071 0
 476 022a 1092 0000 		sts currentColor,__zero_reg__
 477               	.L31:
 478               	.LBB16:
 479               	.LBB17:
1072:switcherator.c ****     }
1073:switcherator.c ****     red = colorChanges[currentColor][0];
 480               		.loc 1 1073 0
 481 022e 8091 0000 		lds r24,currentColor
 482 0232 90E0      		ldi r25,0
1074:switcherator.c ****     green = colorChanges[currentColor][1];
 483               		.loc 1 1074 0
 484 0234 FC01      		movw r30,r24
 485 0236 EE0F      		lsl r30
 486 0238 FF1F      		rol r31
 487 023a E80F      		add r30,r24
 488 023c F91F      		adc r31,r25
 489 023e E050      		subi r30,lo8(-(colorChanges))
 490 0240 F040      		sbci r31,hi8(-(colorChanges))
 491 0242 8181      		ldd r24,Z+1
1075:switcherator.c ****     blue = colorChanges[currentColor][2];
 492               		.loc 1 1075 0
 493 0244 A281      		ldd r26,Z+2
1076:switcherator.c ****     red = red * bright / 16;
 494               		.loc 1 1076 0
 495 0246 6091 0000 		lds r22,bright
 496 024a 7091 0000 		lds r23,bright+1
1073:switcherator.c ****     red = colorChanges[currentColor][0];
 497               		.loc 1 1073 0
 498 024e 9081      		ld r25,Z
 499               		.loc 1 1076 0
 500 0250 969F      		mul r25,r22
 501 0252 A001      		movw r20,r0
 502 0254 979F      		mul r25,r23
 503 0256 500D      		add r21,r0
 504 0258 1124      		clr __zero_reg__
 505 025a 34E0      		ldi r19,4
 506               		1:
 507 025c 5695      		lsr r21
 508 025e 4795      		ror r20
 509 0260 3A95      		dec r19
 510 0262 01F4      		brne 1b
 511 0264 5093 0000 		sts red+1,r21
 512 0268 4093 0000 		sts red,r20
1077:switcherator.c ****     green = green * bright / 16;
 513               		.loc 1 1077 0
 514 026c 869F      		mul r24,r22
 515 026e 9001      		movw r18,r0
 516 0270 879F      		mul r24,r23
 517 0272 300D      		add r19,r0
 518 0274 1124      		clr __zero_reg__
 519 0276 54E0      		ldi r21,4
 520               		1:
 521 0278 3695      		lsr r19
 522 027a 2795      		ror r18
 523 027c 5A95      		dec r21
 524 027e 01F4      		brne 1b
 525 0280 3093 0000 		sts green+1,r19
 526 0284 2093 0000 		sts green,r18
1078:switcherator.c ****     blue = blue * bright / 16;
 527               		.loc 1 1078 0
 528 0288 A69F      		mul r26,r22
 529 028a C001      		movw r24,r0
 530 028c A79F      		mul r26,r23
 531 028e 900D      		add r25,r0
 532 0290 1124      		clr __zero_reg__
 533 0292 64E0      		ldi r22,4
 534               		1:
 535 0294 9695      		lsr r25
 536 0296 8795      		ror r24
 537 0298 6A95      		dec r22
 538 029a 01F4      		brne 1b
 539 029c 9093 0000 		sts blue+1,r25
 540 02a0 8093 0000 		sts blue,r24
1079:switcherator.c ****     Red = red;
 541               		.loc 1 1079 0
 542 02a4 4093 B400 		sts 180,r20
1080:switcherator.c ****     Green = green;
 543               		.loc 1 1080 0
 544 02a8 28BD      		out 0x28,r18
1081:switcherator.c ****     Blue = blue;
 545               		.loc 1 1081 0
 546 02aa 87BD      		out 0x27,r24
 547               	.L26:
 548 02ac 0895      		ret
 549               	.LBE17:
 550               	.LBE16:
 551               	.LFE27:
 553               	.global	runHueFunction
 555               	runHueFunction:
 556               	.LFB28:
1082:switcherator.c **** }
1083:switcherator.c **** // rotating hue
1084:switcherator.c **** //static int currentHue = 0;
1085:switcherator.c **** //static int hueSpeed = 0;
1086:switcherator.c **** //static char hueCount = 0;
1087:switcherator.c **** //#define Red OCR2B
1088:switcherator.c **** //#define Green OCR0B
1089:switcherator.c **** //#define Blue OCR0A
1090:switcherator.c **** 
1091:switcherator.c **** // go through and rotate the hue based color rotation
1092:switcherator.c **** // static int currentHue = 0;
1093:switcherator.c **** // static char hueSpeed = 0;
1094:switcherator.c **** // static char hueCount = 0;
1095:switcherator.c **** 
1096:switcherator.c **** void runHueFunction(void) {
 557               		.loc 1 1096 0
 558               	/* prologue: function */
 559               	/* frame size = 0 */
 560               	/* stack size = 0 */
 561               	.L__stack_usage = 0
1097:switcherator.c ****     // extra fixed delay
1098:switcherator.c ****     littleCount++;
 562               		.loc 1 1098 0
 563 02ae 8091 0000 		lds r24,littleCount
 564 02b2 8F5F      		subi r24,lo8(-(1))
 565 02b4 8093 0000 		sts littleCount,r24
1099:switcherator.c ****     if (littleCount != 2)
 566               		.loc 1 1099 0
 567 02b8 8230      		cpi r24,lo8(2)
 568 02ba 01F0      		breq .+2
 569 02bc 00C0      		rjmp .L36
1100:switcherator.c ****         return;
1101:switcherator.c ****     littleCount = 0;
 570               		.loc 1 1101 0
 571 02be 1092 0000 		sts littleCount,__zero_reg__
1102:switcherator.c ****     hueCount++;
 572               		.loc 1 1102 0
 573 02c2 8091 0000 		lds r24,hueCount
 574 02c6 9091 0000 		lds r25,hueCount+1
 575 02ca 0196      		adiw r24,1
 576 02cc 9093 0000 		sts hueCount+1,r25
 577 02d0 8093 0000 		sts hueCount,r24
1103:switcherator.c ****     // only run if the count is higher than the "speed"
1104:switcherator.c ****     if (hueCount < hueSpeed) {
 578               		.loc 1 1104 0
 579 02d4 2091 0000 		lds r18,hueSpeed
 580 02d8 3091 0000 		lds r19,hueSpeed+1
 581 02dc 8217      		cp r24,r18
 582 02de 9307      		cpc r25,r19
 583 02e0 00F4      		brsh .+2
 584 02e2 00C0      		rjmp .L36
1105:switcherator.c ****         return;
1106:switcherator.c ****     }
1107:switcherator.c ****     hueCount = 0;
 585               		.loc 1 1107 0
 586 02e4 1092 0000 		sts hueCount+1,__zero_reg__
 587 02e8 1092 0000 		sts hueCount,__zero_reg__
1108:switcherator.c ****     if (currentHue < 0x00ff) {
 588               		.loc 1 1108 0
 589 02ec 8091 0000 		lds r24,currentHue
 590 02f0 9091 0000 		lds r25,currentHue+1
 591 02f4 8F3F      		cpi r24,-1
 592 02f6 9105      		cpc r25,__zero_reg__
 593 02f8 00F4      		brsh .L40
1109:switcherator.c ****         red = 255;
 594               		.loc 1 1109 0
 595 02fa 2FEF      		ldi r18,lo8(-1)
 596 02fc 30E0      		ldi r19,0
 597 02fe 3093 0000 		sts red+1,r19
 598 0302 2093 0000 		sts red,r18
 599 0306 00C0      		rjmp .L47
 600               	.L40:
1110:switcherator.c ****         green = currentHue;
1111:switcherator.c ****         blue = 0;
1112:switcherator.c ****     } else if (currentHue < 0x01ff) {
 601               		.loc 1 1112 0
 602 0308 8F3F      		cpi r24,-1
 603 030a 21E0      		ldi r18,1
 604 030c 9207      		cpc r25,r18
 605 030e 00F4      		brsh .L42
1113:switcherator.c ****         red = 255 - (currentHue - 0xff);
 606               		.loc 1 1113 0
 607 0310 2EEF      		ldi r18,lo8(-2)
 608 0312 31E0      		ldi r19,lo8(1)
 609 0314 281B      		sub r18,r24
 610 0316 390B      		sbc r19,r25
 611 0318 3093 0000 		sts red+1,r19
 612 031c 2093 0000 		sts red,r18
1114:switcherator.c ****         green = 255;
 613               		.loc 1 1114 0
 614 0320 8FEF      		ldi r24,lo8(-1)
 615 0322 90E0      		ldi r25,0
 616               	.L47:
 617 0324 9093 0000 		sts green+1,r25
 618 0328 8093 0000 		sts green,r24
1115:switcherator.c ****         blue = 0;
 619               		.loc 1 1115 0
 620 032c 1092 0000 		sts blue+1,__zero_reg__
 621 0330 1092 0000 		sts blue,__zero_reg__
 622 0334 00C0      		rjmp .L41
 623               	.L42:
1116:switcherator.c ****     } else if (currentHue < 0x02ff) {
 624               		.loc 1 1116 0
 625 0336 8F3F      		cpi r24,-1
 626 0338 22E0      		ldi r18,2
 627 033a 9207      		cpc r25,r18
 628 033c 00F4      		brsh .L43
1117:switcherator.c ****         red = 0;
 629               		.loc 1 1117 0
 630 033e 1092 0000 		sts red+1,__zero_reg__
 631 0342 1092 0000 		sts red,__zero_reg__
1118:switcherator.c ****         green = 255;
 632               		.loc 1 1118 0
 633 0346 2FEF      		ldi r18,lo8(-1)
 634 0348 30E0      		ldi r19,0
 635 034a 3093 0000 		sts green+1,r19
 636 034e 2093 0000 		sts green,r18
1119:switcherator.c ****         blue = (currentHue - 0x1ff);
 637               		.loc 1 1119 0
 638 0352 8F5F      		subi r24,-1
 639 0354 9140      		sbci r25,1
 640 0356 00C0      		rjmp .L48
 641               	.L43:
1120:switcherator.c ****     } else if (currentHue < 0x03ff) {
 642               		.loc 1 1120 0
 643 0358 8F3F      		cpi r24,-1
 644 035a 23E0      		ldi r18,3
 645 035c 9207      		cpc r25,r18
 646 035e 00F4      		brsh .L44
1121:switcherator.c ****         red = 0;
 647               		.loc 1 1121 0
 648 0360 1092 0000 		sts red+1,__zero_reg__
 649 0364 1092 0000 		sts red,__zero_reg__
1122:switcherator.c ****         green = 255 - (currentHue - 0x2ff);
 650               		.loc 1 1122 0
 651 0368 2EEF      		ldi r18,lo8(-2)
 652 036a 33E0      		ldi r19,lo8(3)
 653 036c 281B      		sub r18,r24
 654 036e 390B      		sbc r19,r25
 655 0370 3093 0000 		sts green+1,r19
 656 0374 2093 0000 		sts green,r18
 657               	.L49:
1123:switcherator.c ****         blue = 255;
 658               		.loc 1 1123 0
 659 0378 8FEF      		ldi r24,lo8(-1)
 660 037a 90E0      		ldi r25,0
 661               	.L48:
 662 037c 9093 0000 		sts blue+1,r25
 663 0380 8093 0000 		sts blue,r24
 664 0384 00C0      		rjmp .L41
 665               	.L44:
1124:switcherator.c ****     } else if (currentHue < 0x04ff) {
 666               		.loc 1 1124 0
 667 0386 8F3F      		cpi r24,-1
 668 0388 24E0      		ldi r18,4
 669 038a 9207      		cpc r25,r18
 670 038c 00F4      		brsh .L45
1125:switcherator.c ****         red = (currentHue - 0x3ff);
 671               		.loc 1 1125 0
 672 038e 8F5F      		subi r24,-1
 673 0390 9340      		sbci r25,3
 674 0392 9093 0000 		sts red+1,r25
 675 0396 8093 0000 		sts red,r24
1126:switcherator.c ****         green = 0;
 676               		.loc 1 1126 0
 677 039a 1092 0000 		sts green+1,__zero_reg__
 678 039e 1092 0000 		sts green,__zero_reg__
 679 03a2 00C0      		rjmp .L49
 680               	.L45:
1127:switcherator.c ****         blue = 255;
1128:switcherator.c ****     } else if (currentHue < 0x05ff) {
 681               		.loc 1 1128 0
 682 03a4 8F3F      		cpi r24,-1
 683 03a6 25E0      		ldi r18,5
 684 03a8 9207      		cpc r25,r18
 685 03aa 00F4      		brsh .L46
1129:switcherator.c ****         red = 255;
 686               		.loc 1 1129 0
 687 03ac 2FEF      		ldi r18,lo8(-1)
 688 03ae 30E0      		ldi r19,0
 689 03b0 3093 0000 		sts red+1,r19
 690 03b4 2093 0000 		sts red,r18
1130:switcherator.c ****         green = 0;
 691               		.loc 1 1130 0
 692 03b8 1092 0000 		sts green+1,__zero_reg__
 693 03bc 1092 0000 		sts green,__zero_reg__
1131:switcherator.c ****         blue = 255 - (currentHue - 0x4ff);
 694               		.loc 1 1131 0
 695 03c0 2EEF      		ldi r18,lo8(-2)
 696 03c2 35E0      		ldi r19,lo8(5)
 697 03c4 281B      		sub r18,r24
 698 03c6 390B      		sbc r19,r25
 699 03c8 3093 0000 		sts blue+1,r19
 700 03cc 2093 0000 		sts blue,r18
 701 03d0 00C0      		rjmp .L41
 702               	.L46:
1132:switcherator.c ****     } else {
1133:switcherator.c ****         red = 255;
 703               		.loc 1 1133 0
 704 03d2 8FEF      		ldi r24,lo8(-1)
 705 03d4 90E0      		ldi r25,0
 706 03d6 9093 0000 		sts red+1,r25
 707 03da 8093 0000 		sts red,r24
1134:switcherator.c ****         green = 0;
 708               		.loc 1 1134 0
 709 03de 1092 0000 		sts green+1,__zero_reg__
 710 03e2 1092 0000 		sts green,__zero_reg__
1135:switcherator.c ****         blue = 0;
 711               		.loc 1 1135 0
 712 03e6 1092 0000 		sts blue+1,__zero_reg__
 713 03ea 1092 0000 		sts blue,__zero_reg__
1136:switcherator.c ****         currentHue = 0;
 714               		.loc 1 1136 0
 715 03ee 1092 0000 		sts currentHue+1,__zero_reg__
 716 03f2 1092 0000 		sts currentHue,__zero_reg__
 717               	.L41:
1137:switcherator.c ****     }
1138:switcherator.c ****     red = red * bright / 16;
 718               		.loc 1 1138 0
 719 03f6 6091 0000 		lds r22,bright
 720 03fa 7091 0000 		lds r23,bright+1
 721 03fe 8091 0000 		lds r24,red
 722 0402 9091 0000 		lds r25,red+1
 723 0406 689F      		mul r22,r24
 724 0408 A001      		movw r20,r0
 725 040a 699F      		mul r22,r25
 726 040c 500D      		add r21,r0
 727 040e 789F      		mul r23,r24
 728 0410 500D      		add r21,r0
 729 0412 1124      		clr r1
 730 0414 E4E0      		ldi r30,4
 731               		1:
 732 0416 5695      		lsr r21
 733 0418 4795      		ror r20
 734 041a EA95      		dec r30
 735 041c 01F4      		brne 1b
 736 041e 5093 0000 		sts red+1,r21
 737 0422 4093 0000 		sts red,r20
1139:switcherator.c ****     green = green * bright / 16;
 738               		.loc 1 1139 0
 739 0426 8091 0000 		lds r24,green
 740 042a 9091 0000 		lds r25,green+1
 741 042e 689F      		mul r22,r24
 742 0430 9001      		movw r18,r0
 743 0432 699F      		mul r22,r25
 744 0434 300D      		add r19,r0
 745 0436 789F      		mul r23,r24
 746 0438 300D      		add r19,r0
 747 043a 1124      		clr r1
 748 043c F4E0      		ldi r31,4
 749               		1:
 750 043e 3695      		lsr r19
 751 0440 2795      		ror r18
 752 0442 FA95      		dec r31
 753 0444 01F4      		brne 1b
 754 0446 3093 0000 		sts green+1,r19
 755 044a 2093 0000 		sts green,r18
1140:switcherator.c ****     blue = blue * bright / 16;
 756               		.loc 1 1140 0
 757 044e E091 0000 		lds r30,blue
 758 0452 F091 0000 		lds r31,blue+1
 759 0456 6E9F      		mul r22,r30
 760 0458 C001      		movw r24,r0
 761 045a 6F9F      		mul r22,r31
 762 045c 900D      		add r25,r0
 763 045e 7E9F      		mul r23,r30
 764 0460 900D      		add r25,r0
 765 0462 1124      		clr r1
 766 0464 A4E0      		ldi r26,4
 767               		1:
 768 0466 9695      		lsr r25
 769 0468 8795      		ror r24
 770 046a AA95      		dec r26
 771 046c 01F4      		brne 1b
 772 046e 9093 0000 		sts blue+1,r25
 773 0472 8093 0000 		sts blue,r24
1141:switcherator.c ****     Red = red;
 774               		.loc 1 1141 0
 775 0476 4093 B400 		sts 180,r20
1142:switcherator.c ****     Green = green;
 776               		.loc 1 1142 0
 777 047a 28BD      		out 0x28,r18
1143:switcherator.c ****     Blue = blue;
 778               		.loc 1 1143 0
 779 047c 87BD      		out 0x27,r24
1144:switcherator.c ****     currentHue++;
 780               		.loc 1 1144 0
 781 047e 8091 0000 		lds r24,currentHue
 782 0482 9091 0000 		lds r25,currentHue+1
 783 0486 0196      		adiw r24,1
 784 0488 9093 0000 		sts currentHue+1,r25
 785 048c 8093 0000 		sts currentHue,r24
 786               	.L36:
 787 0490 0895      		ret
 788               	.LFE28:
 790               	.global	clearTheProgram
 792               	clearTheProgram:
 793               	.LFB32:
1145:switcherator.c **** }
1146:switcherator.c **** 
1147:switcherator.c **** // sets the pwm brightness value
1148:switcherator.c **** // bs 16
1149:switcherator.c **** 
1150:switcherator.c **** void brightnessSet(char * commandReceived) {
1151:switcherator.c ****     int brightValue = getSwitchNumber(commandReceived);
1152:switcherator.c ****     if (brightValue == 0) {
1153:switcherator.c ****         // display the brightness
1154:switcherator.c ****         itoa(oldBright, tempIntString, 10);
1155:switcherator.c ****         statusMsg[0] = 0;
1156:switcherator.c ****         strcat(statusMsg, "Set @");
1157:switcherator.c ****         strcat(statusMsg, tempIntString);
1158:switcherator.c ****         strcat(statusMsg, "B@");
1159:switcherator.c ****         itoa(bright, tempIntString, 10);
1160:switcherator.c ****         strcat(statusMsg, tempIntString);
1161:switcherator.c ****         sendMessage(statusMsg);
1162:switcherator.c ****     } else {
1163:switcherator.c ****         if (brightValue > 16)
1164:switcherator.c ****             brightValue = 16;
1165:switcherator.c ****         if (oldBright == bright) {
1166:switcherator.c ****             // currently not being overridden
1167:switcherator.c ****             bright = brightValue;
1168:switcherator.c ****         }
1169:switcherator.c ****         oldBright = brightValue;
1170:switcherator.c ****         switchChanged = 1;
1171:switcherator.c ****         ok();
1172:switcherator.c ****     }
1173:switcherator.c **** }
1174:switcherator.c **** 
1175:switcherator.c **** 
1176:switcherator.c **** /****************************************************************
1177:switcherator.c ****  *
1178:switcherator.c ****  *              All Things Program Related
1179:switcherator.c ****  *
1180:switcherator.c ****  ****************************************************************/
1181:switcherator.c **** 
1182:switcherator.c **** // programs and such kept in EEPROM
1183:switcherator.c **** // 1 byte day of week mask or 0 for everyday
1184:switcherator.c **** // 2 byte start time (minutes), 2 bytes duration (seconds), 1 byte additional program
1185:switcherator.c **** // If more than 4 switches are desired it will roll over to an additional program
1186:switcherator.c **** // DssddSSSSP
1187:switcherator.c **** // 0123456789   
1188:switcherator.c **** //static unsigned char weeklyProgram[MAX_PROGRAM][10];
1189:switcherator.c **** //uart_puts_P("NewProgram, ClearProg, ProgAddSwitch, ProgDays, ProgTime, ProgDispln PN\r\n");
1190:switcherator.c **** //uart_puts_P("NP:P#HHMMDur. - CP:P# - PA:P#S# PD:P#SMTWTFS-PT:P#HHMMDur. PI:P#\r\n");
1191:switcherator.c **** //uart_puts_P("P#=Prog Num,HH=Hour,MM=Min,Dur.=Duration(min) SMTWTFS=1010000=Sun/Tue\r\n");
1192:switcherator.c **** 
1193:switcherator.c **** // Create a new program
1194:switcherator.c **** // NP:HHMMDur.
1195:switcherator.c **** // 0123456789012
1196:switcherator.c **** 
1197:switcherator.c **** void newProgram(char * commandReceived) {
1198:switcherator.c ****     int programNumber = 255;
1199:switcherator.c ****     int hours = 0;
1200:switcherator.c ****     int minutes = 0;
1201:switcherator.c ****     int startTime = 0;
1202:switcherator.c ****     int duration = 0;
1203:switcherator.c ****     int x = 0;
1204:switcherator.c ****     // find an open program;
1205:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
1206:switcherator.c ****         // dont want it to wrap though 0 is a valid program
1207:switcherator.c ****         if (weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) {
1208:switcherator.c ****             // Use this one
1209:switcherator.c ****             programNumber = x;
1210:switcherator.c ****             // end the loop
1211:switcherator.c ****             break;
1212:switcherator.c ****         }
1213:switcherator.c ****     }
1214:switcherator.c ****     if (programNumber == 255) {
1215:switcherator.c ****         fail(8);
1216:switcherator.c ****         return;
1217:switcherator.c ****     }
1218:switcherator.c ****     clearTheProgram(programNumber);
1219:switcherator.c ****     tempIntString[0] = commandReceived[3];
1220:switcherator.c ****     tempIntString[1] = commandReceived[4];
1221:switcherator.c ****     hours = atoi(tempIntString);
1222:switcherator.c ****     tempIntString[0] = commandReceived[5];
1223:switcherator.c ****     tempIntString[1] = commandReceived[6];
1224:switcherator.c ****     minutes = atoi(tempIntString);
1225:switcherator.c ****     tempLongString[0] = commandReceived[7];
1226:switcherator.c ****     tempLongString[1] = commandReceived[8];
1227:switcherator.c ****     tempLongString[2] = commandReceived[9];
1228:switcherator.c ****     tempLongString[3] = commandReceived[10];
1229:switcherator.c ****     duration = atoi(tempLongString);
1230:switcherator.c ****     if (hours >= 24 || (hours == 0 && commandReceived[4] != '0')) {
1231:switcherator.c ****         fail(9);
1232:switcherator.c ****         return;
1233:switcherator.c ****     }
1234:switcherator.c ****     if (minutes >= 60 || (minutes == 0 && commandReceived[6] != '0')) {
1235:switcherator.c ****         fail(0x0a);
1236:switcherator.c ****         return;
1237:switcherator.c ****     }
1238:switcherator.c ****     if (duration == 0) {
1239:switcherator.c ****         fail(0x0b);
1240:switcherator.c ****         return;
1241:switcherator.c ****     }
1242:switcherator.c ****     duration *= 60; // convert to seconds
1243:switcherator.c ****     startTime = (hours * 60);
1244:switcherator.c ****     startTime += minutes; // stored in minutes
1245:switcherator.c ****     int temp = 0;
1246:switcherator.c ****     temp = (startTime >> 8);
1247:switcherator.c ****     weeklyProgram[programNumber][1] = temp;
1248:switcherator.c ****     temp = (startTime & 0xff);
1249:switcherator.c ****     weeklyProgram[programNumber][2] = temp;
1250:switcherator.c ****     temp = (duration >> 8);
1251:switcherator.c ****     weeklyProgram[programNumber][3] = temp;
1252:switcherator.c ****     temp = (duration & 0xff);
1253:switcherator.c ****     weeklyProgram[programNumber][4] = temp;
1254:switcherator.c ****     statusMsg[0] = 0;
1255:switcherator.c ****     strcat(statusMsg, "New prog#");
1256:switcherator.c ****     returnInt(programNumber, tempIntString);
1257:switcherator.c ****     strcat(statusMsg, tempIntString);
1258:switcherator.c ****     sendMessage(statusMsg);
1259:switcherator.c **** }
1260:switcherator.c **** 
1261:switcherator.c **** // clears an existing program
1262:switcherator.c **** // the clearTheProgram does the work so this is the interface
1263:switcherator.c **** // CP:P#
1264:switcherator.c **** // 01234
1265:switcherator.c **** 
1266:switcherator.c **** void clearProgram(char * commandReceived) {
1267:switcherator.c ****     int programNumber = getSwitchNumber(commandReceived);
1268:switcherator.c ****     if (programNumber >= MAX_PROGRAM || (programNumber == 0 && commandReceived[4] != '0')) {
1269:switcherator.c ****         fail(2);
1270:switcherator.c ****     } else {
1271:switcherator.c ****         itoa(programNumber, tempIntString, 10);
1272:switcherator.c ****         ok();
1273:switcherator.c ****         clearTheProgram(programNumber);
1274:switcherator.c ****     }
1275:switcherator.c **** }
1276:switcherator.c **** 
1277:switcherator.c **** // zeros out the program
1278:switcherator.c **** 
1279:switcherator.c **** void clearTheProgram(int programNumber) {
 794               		.loc 1 1279 0
 795               	.LVL39:
 796               	/* prologue: function */
 797               	/* frame size = 0 */
 798               	/* stack size = 0 */
 799               	.L__stack_usage = 0
 800               		.loc 1 1279 0
 801 0492 2AE0      		ldi r18,lo8(10)
 802 0494 AC01      		movw r20,r24
 803 0496 249F      		mul r18,r20
 804 0498 C001      		movw r24,r0
 805 049a 259F      		mul r18,r21
 806 049c 900D      		add r25,r0
 807 049e 1124      		clr __zero_reg__
 808               	.LVL40:
 809 04a0 8050      		subi r24,lo8(-(weeklyProgram))
 810 04a2 9040      		sbci r25,hi8(-(weeklyProgram))
1280:switcherator.c ****     int x = 0;
1281:switcherator.c ****     // some of these "0" is a valid option so make it 255
1282:switcherator.c ****     for (x = 0; x < 10; x++) {
 811               		.loc 1 1282 0
 812 04a4 20E0      		ldi r18,0
 813 04a6 30E0      		ldi r19,0
1283:switcherator.c ****         weeklyProgram[programNumber][x] = 255;
 814               		.loc 1 1283 0
 815 04a8 4FEF      		ldi r20,lo8(-1)
 816               	.LVL41:
 817               	.L51:
1279:switcherator.c **** void clearTheProgram(int programNumber) {
 818               		.loc 1 1279 0 discriminator 2
 819 04aa FC01      		movw r30,r24
 820 04ac E20F      		add r30,r18
 821 04ae F31F      		adc r31,r19
 822               		.loc 1 1283 0 discriminator 2
 823 04b0 4083      		st Z,r20
1282:switcherator.c ****     for (x = 0; x < 10; x++) {
 824               		.loc 1 1282 0 discriminator 2
 825 04b2 2F5F      		subi r18,-1
 826 04b4 3F4F      		sbci r19,-1
 827               	.LVL42:
 828 04b6 2A30      		cpi r18,10
 829 04b8 3105      		cpc r19,__zero_reg__
 830 04ba 01F4      		brne .L51
 831               	/* epilogue start */
1284:switcherator.c ****     }
1285:switcherator.c **** }
 832               		.loc 1 1285 0
 833 04bc 0895      		ret
 834               	.LFE32:
 836               	.global	findOpenSwitch
 838               	findOpenSwitch:
 839               	.LFB34:
1286:switcherator.c **** 
1287:switcherator.c **** // there are multiple switches per program.  This adds them.
1288:switcherator.c **** // For memory constraints each program natively has up to 4
1289:switcherator.c **** // switches.  For more than that another program will be linked
1290:switcherator.c **** // Program in memory:
1291:switcherator.c **** // DssddSSSSP
1292:switcherator.c **** // 0123456789
1293:switcherator.c **** // PA:P#S#
1294:switcherator.c **** // 0123456
1295:switcherator.c **** 
1296:switcherator.c **** void programAddSwitch(char * commandReceived) {
1297:switcherator.c ****     int programNumber = 0;
1298:switcherator.c ****     int switchNumber = 0;
1299:switcherator.c ****     tempIntString[0] = commandReceived[3];
1300:switcherator.c ****     tempIntString[1] = commandReceived[4];
1301:switcherator.c ****     programNumber = atoi(tempIntString);
1302:switcherator.c ****     tempIntString[0] = commandReceived[5];
1303:switcherator.c ****     tempIntString[1] = commandReceived[6];
1304:switcherator.c ****     switchNumber = atoi(tempIntString);
1305:switcherator.c ****     char switches[NUM_SWITCHES];
1306:switcherator.c ****     switches[0] = 0;
1307:switcherator.c ****     int switchCount = programGetSwitches(programNumber, switches);
1308:switcherator.c ****     int x = 0;
1309:switcherator.c ****     // see if the switch is already there
1310:switcherator.c ****     for (x = 0; x < switchCount; x++) {
1311:switcherator.c ****         if (switches[x] == switchNumber) {
1312:switcherator.c ****             fail(0x0c);
1313:switcherator.c ****             return;
1314:switcherator.c ****         }
1315:switcherator.c ****     }
1316:switcherator.c **** 
1317:switcherator.c ****     // check validity 
1318:switcherator.c ****     if ((programNumber >= MAX_PROGRAM) || (programNumber == 0 && commandReceived[4] != '0')) {
1319:switcherator.c ****         fail(2);
1320:switcherator.c ****         return;
1321:switcherator.c ****     }
1322:switcherator.c ****     if ((switchNumber >= NUM_SWITCHES) || (switchNumber == 0 && commandReceived[6] != '0')) {
1323:switcherator.c ****         fail(1);
1324:switcherator.c ****         return;
1325:switcherator.c ****     }
1326:switcherator.c ****     // check for valid program
1327:switcherator.c ****     // The day mask maxes out at 127 - the high but shouldn't be set if it is valid
1328:switcherator.c ****     // unless it is a overflow program in which case the first switch will be set
1329:switcherator.c ****     // 255 = not set
1330:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
1331:switcherator.c ****         fail(0x0d);
1332:switcherator.c ****         return;
1333:switcherator.c ****     }
1334:switcherator.c ****     int noSwitchYet = 1;
1335:switcherator.c ****     int blankSwitch = 0;
1336:switcherator.c ****     int overflowProgram = 255;
1337:switcherator.c ****     // prepare number string for output later
1338:switcherator.c ****     itoa(programNumber, tempIntString, 10);
1339:switcherator.c ****     // see if our program has a valid switch
1340:switcherator.c ****     blankSwitch = findOpenSwitch(programNumber);
1341:switcherator.c ****     while (noSwitchYet == 1) {
1342:switcherator.c ****         if (blankSwitch == 0) {
1343:switcherator.c ****             // our program is full.  Find or make another one
1344:switcherator.c ****             // first check if we already are overflowing.
1345:switcherator.c ****             overflowProgram = weeklyProgram[programNumber][9];
1346:switcherator.c ****             if (overflowProgram == 255) {
1347:switcherator.c ****                 // no overflow.  Need to create one.
1348:switcherator.c ****                 // find blank program slot
1349:switcherator.c ****                 int possibleBlank = 255;
1350:switcherator.c ****                 // yeah I know but programNumber 0 won't be an overflow so there
1351:switcherator.c ****                 for (x = (MAX_PROGRAM - 1); x > 0; x--) {
1352:switcherator.c ****                     // dont want it to wrap though 0 is a valid program
1353:switcherator.c ****                     if (weeklyProgram[x][0] == 255 && weeklyProgram[x][5] == 255) {
1354:switcherator.c ****                         // this is blank
1355:switcherator.c ****                         possibleBlank = x;
1356:switcherator.c ****                         // end the loop
1357:switcherator.c ****                         x = 0;
1358:switcherator.c ****                     }
1359:switcherator.c ****                 }
1360:switcherator.c ****                 if (possibleBlank == 255) {
1361:switcherator.c ****                     // oh oh, no room
1362:switcherator.c ****                     fail(0x0e);
1363:switcherator.c ****                     return;
1364:switcherator.c ****                 }
1365:switcherator.c ****                 // now record the overflow and move forward
1366:switcherator.c ****                 weeklyProgram[programNumber][9] = possibleBlank;
1367:switcherator.c ****                 programNumber = possibleBlank;
1368:switcherator.c ****                 // and now we loop again...
1369:switcherator.c ****             } else {
1370:switcherator.c ****                 // move to overflow program and try again
1371:switcherator.c ****                 programNumber = overflowProgram;
1372:switcherator.c ****             }
1373:switcherator.c ****         } else { // if(blankSwitch == 0)
1374:switcherator.c ****             // we have a program and a slot.  move on.
1375:switcherator.c ****             noSwitchYet = 0;
1376:switcherator.c ****         }
1377:switcherator.c ****     }
1378:switcherator.c ****     weeklyProgram[programNumber][blankSwitch] = switchNumber;
1379:switcherator.c ****     ok();
1380:switcherator.c **** }
1381:switcherator.c **** 
1382:switcherator.c **** // iterates through a program and returns the index of an open switch or 0 if none
1383:switcherator.c **** 
1384:switcherator.c **** int findOpenSwitch(int programNumber) {
 840               		.loc 1 1384 0
 841               	.LVL43:
 842               	/* prologue: function */
 843               	/* frame size = 0 */
 844               	/* stack size = 0 */
 845               	.L__stack_usage = 0
 846               		.loc 1 1384 0
 847 04be 2AE0      		ldi r18,lo8(10)
 848 04c0 AC01      		movw r20,r24
 849 04c2 249F      		mul r18,r20
 850 04c4 C001      		movw r24,r0
 851 04c6 259F      		mul r18,r21
 852 04c8 900D      		add r25,r0
 853 04ca 1124      		clr __zero_reg__
 854               	.LVL44:
 855 04cc 8050      		subi r24,lo8(-(weeklyProgram))
 856 04ce 9040      		sbci r25,hi8(-(weeklyProgram))
1385:switcherator.c ****     int switchIndex = 0;
1386:switcherator.c ****     int x = 0;
1387:switcherator.c ****     for (x = 5; x < 9; x++) {
 857               		.loc 1 1387 0
 858 04d0 25E0      		ldi r18,lo8(5)
 859 04d2 30E0      		ldi r19,0
 860               	.LVL45:
 861               	.L55:
1384:switcherator.c **** int findOpenSwitch(int programNumber) {
 862               		.loc 1 1384 0
 863 04d4 FC01      		movw r30,r24
 864 04d6 E20F      		add r30,r18
 865 04d8 F31F      		adc r31,r19
1388:switcherator.c ****         if (weeklyProgram[programNumber][x] == 255) {
 866               		.loc 1 1388 0
 867 04da 4081      		ld r20,Z
 868 04dc 4F3F      		cpi r20,lo8(-1)
 869 04de 01F0      		breq .L54
1387:switcherator.c ****     for (x = 5; x < 9; x++) {
 870               		.loc 1 1387 0
 871 04e0 2F5F      		subi r18,-1
 872 04e2 3F4F      		sbci r19,-1
 873               	.LVL46:
 874 04e4 2930      		cpi r18,9
 875 04e6 3105      		cpc r19,__zero_reg__
 876 04e8 01F4      		brne .L55
1389:switcherator.c ****             // blank switch
1390:switcherator.c ****             switchIndex = x;
1391:switcherator.c ****             return switchIndex;
1392:switcherator.c ****         }
1393:switcherator.c ****     }
1394:switcherator.c ****     return 0;
 877               		.loc 1 1394 0
 878 04ea 20E0      		ldi r18,0
 879 04ec 30E0      		ldi r19,0
 880               	.LVL47:
 881               	.L54:
1395:switcherator.c **** }
 882               		.loc 1 1395 0
 883 04ee C901      		movw r24,r18
 884 04f0 0895      		ret
 885               	.LFE34:
 887               	.global	programGetSwitches
 889               	programGetSwitches:
 890               	.LFB38:
1396:switcherator.c **** 
1397:switcherator.c **** // Sets the days a program will run
1398:switcherator.c **** // PD:P#SMTWTFS
1399:switcherator.c **** // 012345678901
1400:switcherator.c **** 
1401:switcherator.c **** void programSetDays(char * commandReceived) {
1402:switcherator.c ****     char tempReallyLongString[] = "0000000";
1403:switcherator.c ****     int programNumber = 0;
1404:switcherator.c ****     long weekLong = 0;
1405:switcherator.c ****     tempIntString[0] = commandReceived[3];
1406:switcherator.c ****     tempIntString[1] = commandReceived[4];
1407:switcherator.c ****     programNumber = atoi(tempIntString);
1408:switcherator.c ****     tempReallyLongString[0] = commandReceived[5];
1409:switcherator.c ****     tempReallyLongString[1] = commandReceived[6];
1410:switcherator.c ****     tempReallyLongString[2] = commandReceived[7];
1411:switcherator.c ****     tempReallyLongString[3] = commandReceived[8];
1412:switcherator.c ****     tempReallyLongString[4] = commandReceived[9];
1413:switcherator.c ****     tempReallyLongString[5] = commandReceived[10];
1414:switcherator.c ****     tempReallyLongString[6] = commandReceived[11];
1415:switcherator.c ****     weekLong = strtol(tempReallyLongString, 0, 2);
1416:switcherator.c ****     if ((programNumber >= MAX_PROGRAM) || (programNumber == 0 && commandReceived[4] != '0')) {
1417:switcherator.c ****         fail(2);
1418:switcherator.c ****         return;
1419:switcherator.c ****     }
1420:switcherator.c ****     // check for valid program
1421:switcherator.c ****     // The day mask maxes out at 127 - the high but shouldn't be set if it is valid
1422:switcherator.c ****     // unless it is a overflow program in which case the first switch will be set
1423:switcherator.c ****     // 255 = not set
1424:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
1425:switcherator.c ****         fail(0x0d);
1426:switcherator.c ****         return;
1427:switcherator.c ****     }
1428:switcherator.c ****     if ((weekLong & 0x7f) == 0) {
1429:switcherator.c ****         fail(0x0f);
1430:switcherator.c ****         return;
1431:switcherator.c ****     }
1432:switcherator.c ****     char weekdays = (weekLong & 0x7f);
1433:switcherator.c ****     weeklyProgram[programNumber][0] = weekdays;
1434:switcherator.c ****     ok();
1435:switcherator.c **** }
1436:switcherator.c **** 
1437:switcherator.c **** // DssddSSSSP
1438:switcherator.c **** // 0123456789   
1439:switcherator.c **** // PT:P#HHMMDur.
1440:switcherator.c **** // 0123456789012
1441:switcherator.c **** 
1442:switcherator.c **** void programSetTime(char * commandReceived) {
1443:switcherator.c ****     int programNumber = 0;
1444:switcherator.c ****     int hours = 0;
1445:switcherator.c ****     int minutes = 0;
1446:switcherator.c ****     int startTime = 0;
1447:switcherator.c ****     int duration = 0;
1448:switcherator.c ****     tempIntString[0] = commandReceived[3];
1449:switcherator.c ****     tempIntString[1] = commandReceived[4];
1450:switcherator.c ****     programNumber = atoi(tempIntString);
1451:switcherator.c ****     if (programNumber >= MAX_PROGRAM || (programNumber == 0 && commandReceived[4] != '0')) {
1452:switcherator.c ****         fail(2);
1453:switcherator.c ****         return;
1454:switcherator.c ****     }
1455:switcherator.c ****     // check for valid program
1456:switcherator.c ****     // The day mask maxes out at 127 - the high but shouldn't be set if it is valid
1457:switcherator.c ****     // unless it is a overflow program in which case the first switch will be set
1458:switcherator.c ****     // 255 = not set
1459:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
1460:switcherator.c ****         fail(0x0d);
1461:switcherator.c ****         return;
1462:switcherator.c ****     }
1463:switcherator.c ****     tempIntString[0] = commandReceived[5];
1464:switcherator.c ****     tempIntString[1] = commandReceived[6];
1465:switcherator.c ****     hours = atoi(tempIntString);
1466:switcherator.c ****     tempIntString[0] = commandReceived[7];
1467:switcherator.c ****     tempIntString[1] = commandReceived[8];
1468:switcherator.c ****     minutes = atoi(tempIntString);
1469:switcherator.c ****     tempLongString[0] = commandReceived[9];
1470:switcherator.c ****     tempLongString[1] = commandReceived[10];
1471:switcherator.c ****     tempLongString[2] = commandReceived[11];
1472:switcherator.c ****     tempLongString[3] = commandReceived[12];
1473:switcherator.c ****     duration = atoi(tempLongString);
1474:switcherator.c ****     if (hours >= 24 || (hours == 0 && commandReceived[6] != '0')) {
1475:switcherator.c ****         fail(9);
1476:switcherator.c ****         return;
1477:switcherator.c ****     }
1478:switcherator.c ****     if (minutes >= 60 || (minutes == 0 && commandReceived[8] != '0')) {
1479:switcherator.c ****         fail(0x0a);
1480:switcherator.c ****         return;
1481:switcherator.c ****     }
1482:switcherator.c ****     if (duration == 0) {
1483:switcherator.c ****         fail(0x0b);
1484:switcherator.c ****         return;
1485:switcherator.c ****     }
1486:switcherator.c ****     duration *= 60; // convert to seconds
1487:switcherator.c ****     startTime = (hours * 60);
1488:switcherator.c ****     startTime += minutes; // stored in minutes
1489:switcherator.c ****     int temp = 0;
1490:switcherator.c ****     temp = (startTime >> 8);
1491:switcherator.c ****     weeklyProgram[programNumber][1] = temp;
1492:switcherator.c ****     temp = (startTime & 0xff);
1493:switcherator.c ****     weeklyProgram[programNumber][2] = temp;
1494:switcherator.c ****     temp = (duration >> 8);
1495:switcherator.c ****     weeklyProgram[programNumber][3] = temp;
1496:switcherator.c ****     temp = (duration & 0xff);
1497:switcherator.c ****     weeklyProgram[programNumber][4] = temp;
1498:switcherator.c ****     ok();
1499:switcherator.c **** }
1500:switcherator.c **** 
1501:switcherator.c **** void programDisplay(char * commandReceived) {
1502:switcherator.c ****     int x = 0;
1503:switcherator.c ****     int programNumber = 0;
1504:switcherator.c ****     tempIntString[0] = commandReceived[3];
1505:switcherator.c ****     tempIntString[1] = commandReceived[4];
1506:switcherator.c ****     programNumber = atoi(tempIntString);
1507:switcherator.c ****     statusMsg[0] = 0;
1508:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
1509:switcherator.c ****         strcat(statusMsg, "P#");
1510:switcherator.c ****         returnInt(programNumber, tempIntString);
1511:switcherator.c ****         strcat(statusMsg, tempIntString);
1512:switcherator.c ****         strcat(statusMsg, "blank.");
1513:switcherator.c ****         sendMessage(statusMsg);
1514:switcherator.c ****         return;
1515:switcherator.c ****     }
1516:switcherator.c ****     char switches[NUM_SWITCHES];
1517:switcherator.c ****     switches[0] = 0;
1518:switcherator.c ****     int switchCount = 0;
1519:switcherator.c ****     switchCount = programGetSwitches(programNumber, switches);
1520:switcherator.c ****     statusMsg[0] = 0;
1521:switcherator.c ****     strcat(statusMsg, "Prog#");
1522:switcherator.c ****     itoa(programNumber, tempIntString, 10);
1523:switcherator.c ****     strcat(statusMsg, tempIntString);
1524:switcherator.c ****     if (switchCount == 0) {
1525:switcherator.c ****         strcat(switches, "S:-");
1526:switcherator.c ****     } else {
1527:switcherator.c ****         int temp = 0;
1528:switcherator.c ****         strcat(statusMsg, "S");
1529:switcherator.c ****         for (x = 0; x < switchCount; x++) {
1530:switcherator.c ****             strcat(statusMsg, ":");
1531:switcherator.c ****             temp = switches[x];
1532:switcherator.c ****             itoa(temp, tempIntString, 10);
1533:switcherator.c ****             strcat(statusMsg, tempIntString);
1534:switcherator.c ****         }
1535:switcherator.c ****     }
1536:switcherator.c ****     sendMessage(statusMsg);
1537:switcherator.c ****     statusMsg[0] = 0;
1538:switcherator.c ****     unsigned int time = 0;
1539:switcherator.c ****     time = weeklyProgram[programNumber][1];
1540:switcherator.c ****     time <<= 8;
1541:switcherator.c ****     time |= weeklyProgram[programNumber][2];
1542:switcherator.c ****     unsigned int hours = (time / 60);
1543:switcherator.c ****     unsigned int minutes = (time - (hours * 60));
1544:switcherator.c ****     time = weeklyProgram[programNumber][3];
1545:switcherator.c ****     time <<= 8;
1546:switcherator.c ****     time |= weeklyProgram[programNumber][4];
1547:switcherator.c ****     int duration = (time / 60);
1548:switcherator.c ****     char weekdays = 0;
1549:switcherator.c ****     weekdays = weeklyProgram[programNumber][0];
1550:switcherator.c ****     strcat(statusMsg, "T:");
1551:switcherator.c ****     itoa(hours, tempIntString, 10);
1552:switcherator.c ****     strcat(statusMsg, tempIntString);
1553:switcherator.c ****     strcat(statusMsg, ":");
1554:switcherator.c ****     itoa(minutes, tempIntString, 10);
1555:switcherator.c ****     strcat(statusMsg, tempIntString);
1556:switcherator.c ****     strcat(statusMsg, " Dur:");
1557:switcherator.c ****     itoa(duration, tempLongString, 10);
1558:switcherator.c ****     strcat(statusMsg, tempLongString);
1559:switcherator.c ****     strcat(statusMsg, "Days:");
1560:switcherator.c ****     if (weekdays == 255) {
1561:switcherator.c ****         strcat(statusMsg, "-------");
1562:switcherator.c ****         sendMessage(statusMsg);
1563:switcherator.c ****         return;
1564:switcherator.c ****     }
1565:switcherator.c ****     if (weekdays & 0x40) {
1566:switcherator.c ****         strcat(statusMsg, "S");
1567:switcherator.c ****     } else {
1568:switcherator.c ****         strcat(statusMsg, "-");
1569:switcherator.c ****     }
1570:switcherator.c ****     if (weekdays & 0x20) {
1571:switcherator.c ****         strcat(statusMsg, "M");
1572:switcherator.c ****     } else {
1573:switcherator.c ****         strcat(statusMsg, "-");
1574:switcherator.c ****     }
1575:switcherator.c ****     if (weekdays & 0x10) {
1576:switcherator.c ****         strcat(statusMsg, "T");
1577:switcherator.c ****     } else {
1578:switcherator.c ****         strcat(statusMsg, "-");
1579:switcherator.c ****     }
1580:switcherator.c ****     if (weekdays & 0x08) {
1581:switcherator.c ****         strcat(statusMsg, "W");
1582:switcherator.c ****     } else {
1583:switcherator.c ****         strcat(statusMsg, "-");
1584:switcherator.c ****     }
1585:switcherator.c ****     if (weekdays & 0x04) {
1586:switcherator.c ****         strcat(statusMsg, "T");
1587:switcherator.c ****     } else {
1588:switcherator.c ****         strcat(statusMsg, "-");
1589:switcherator.c ****     }
1590:switcherator.c ****     if (weekdays & 0x02) {
1591:switcherator.c ****         strcat(statusMsg, "F");
1592:switcherator.c ****     } else {
1593:switcherator.c ****         strcat(statusMsg, "-");
1594:switcherator.c ****     }
1595:switcherator.c ****     if (weekdays & 0x01) {
1596:switcherator.c ****         strcat(statusMsg, "S");
1597:switcherator.c ****     } else {
1598:switcherator.c ****         strcat(statusMsg, "-");
1599:switcherator.c ****     }
1600:switcherator.c **** 
1601:switcherator.c ****     sendMessage(statusMsg);
1602:switcherator.c **** }
1603:switcherator.c **** 
1604:switcherator.c **** // get the switches for a program
1605:switcherator.c **** // char * switches should be set as large as NUM_SWITCHES
1606:switcherator.c **** // so you don't overflow
1607:switcherator.c **** 
1608:switcherator.c **** int programGetSwitches(int programNumber, char * switches) {
 891               		.loc 1 1608 0
 892               	.LVL48:
 893 04f2 CF93      		push r28
 894               	.LCFI8:
 895 04f4 DF93      		push r29
 896               	.LCFI9:
 897               	/* prologue: function */
 898               	/* frame size = 0 */
 899               	/* stack size = 2 */
 900               	.L__stack_usage = 2
 901               	.LVL49:
1609:switcherator.c ****     int element = 0;
 902               		.loc 1 1609 0
 903 04f6 20E0      		ldi r18,0
 904 04f8 30E0      		ldi r19,0
1608:switcherator.c **** int programGetSwitches(int programNumber, char * switches) {
 905               		.loc 1 1608 0
 906 04fa CAE0      		ldi r28,lo8(10)
 907               	.LVL50:
 908               	.L61:
 909 04fc F901      		movw r30,r18
 910 04fe 3496      		adiw r30,4
 911 0500 C89F      		mul r28,r24
 912 0502 A001      		movw r20,r0
 913 0504 C99F      		mul r28,r25
 914 0506 500D      		add r21,r0
 915 0508 1124      		clr __zero_reg__
 916 050a 421B      		sub r20,r18
 917 050c 530B      		sbc r21,r19
 918 050e 4050      		subi r20,lo8(-(weeklyProgram))
 919 0510 5040      		sbci r21,hi8(-(weeklyProgram))
 920               	.LVL51:
 921               	.L60:
 922 0512 DA01      		movw r26,r20
 923 0514 A20F      		add r26,r18
 924 0516 B31F      		adc r27,r19
1610:switcherator.c ****     int x = 0;
1611:switcherator.c ****     // start loading the switch array
1612:switcherator.c ****     while (1) {
1613:switcherator.c ****         for (x = 5; x < 9; x++) {
1614:switcherator.c ****             if (weeklyProgram[programNumber][x] == 255) {
 925               		.loc 1 1614 0
 926 0518 1596      		adiw r26,5
 927 051a DC91      		ld r29,X
 928 051c DF3F      		cpi r29,lo8(-1)
 929 051e 01F0      		breq .L59
1608:switcherator.c **** int programGetSwitches(int programNumber, char * switches) {
 930               		.loc 1 1608 0
 931 0520 DB01      		movw r26,r22
 932 0522 A20F      		add r26,r18
 933 0524 B31F      		adc r27,r19
1615:switcherator.c ****                 // blank switch we are done
1616:switcherator.c ****                 return element;
1617:switcherator.c ****             } else {
1618:switcherator.c ****                 switches[element] = weeklyProgram[programNumber][x];
 934               		.loc 1 1618 0
 935 0526 DC93      		st X,r29
1619:switcherator.c ****                 element++;
 936               		.loc 1 1619 0
 937 0528 2F5F      		subi r18,-1
 938 052a 3F4F      		sbci r19,-1
 939               	.LVL52:
1613:switcherator.c ****         for (x = 5; x < 9; x++) {
 940               		.loc 1 1613 0
 941 052c 2E17      		cp r18,r30
 942 052e 3F07      		cpc r19,r31
 943 0530 01F4      		brne .L60
1620:switcherator.c ****             }
1621:switcherator.c ****         } // for x=5-9
1622:switcherator.c ****         // see if this program iterates around
1623:switcherator.c ****         if (weeklyProgram[programNumber][9] == 255) {
 944               		.loc 1 1623 0
 945 0532 C89F      		mul r28,r24
 946 0534 F001      		movw r30,r0
 947 0536 C99F      		mul r28,r25
 948 0538 F00D      		add r31,r0
 949 053a 1124      		clr __zero_reg__
 950 053c E050      		subi r30,lo8(-(weeklyProgram))
 951 053e F040      		sbci r31,hi8(-(weeklyProgram))
 952 0540 8185      		ldd r24,Z+9
 953               	.LVL53:
 954 0542 8F3F      		cpi r24,lo8(-1)
 955 0544 01F0      		breq .L59
1624:switcherator.c ****             // we are done;
1625:switcherator.c ****             return element;
1626:switcherator.c ****         } else {
1627:switcherator.c ****             // move to the next programNumber and continue
1628:switcherator.c ****             programNumber = weeklyProgram[programNumber][9];
 956               		.loc 1 1628 0
 957 0546 90E0      		ldi r25,0
 958               	.LVL54:
1629:switcherator.c ****         }
1630:switcherator.c ****     }
 959               		.loc 1 1630 0
 960 0548 00C0      		rjmp .L61
 961               	.LVL55:
 962               	.L59:
1631:switcherator.c **** }
 963               		.loc 1 1631 0
 964 054a C901      		movw r24,r18
 965               	/* epilogue start */
 966 054c DF91      		pop r29
 967 054e CF91      		pop r28
 968 0550 0895      		ret
 969               	.LFE38:
 971               	.global	startTheProgram
 973               	startTheProgram:
 974               	.LFB40:
1632:switcherator.c **** 
1633:switcherator.c **** // takes in a program number and time and turns on the program
1634:switcherator.c **** // SP P#Durat.
1635:switcherator.c **** // 01234567890
1636:switcherator.c **** 
1637:switcherator.c **** void startProgram(char * commandReceived) {
1638:switcherator.c ****     unsigned long duration;
1639:switcherator.c ****     int programNumber = 0;
1640:switcherator.c ****     // get switch number
1641:switcherator.c ****     tempIntString[0] = commandReceived[3];
1642:switcherator.c ****     tempIntString[1] = commandReceived[4];
1643:switcherator.c ****     programNumber = atoi(tempIntString);
1644:switcherator.c ****     if (programNumber >= MAX_PROGRAM) {
1645:switcherator.c ****         fail(2);
1646:switcherator.c ****         return;
1647:switcherator.c ****     }
1648:switcherator.c ****     // get duration
1649:switcherator.c ****     tempHugeString[0] = commandReceived[5];
1650:switcherator.c ****     tempHugeString[1] = commandReceived[6];
1651:switcherator.c ****     tempHugeString[2] = commandReceived[7];
1652:switcherator.c ****     tempHugeString[3] = commandReceived[8];
1653:switcherator.c ****     tempHugeString[4] = commandReceived[9];
1654:switcherator.c ****     tempHugeString[5] = commandReceived[10];
1655:switcherator.c ****     duration = atol(tempHugeString);
1656:switcherator.c ****     startTheProgram(programNumber, duration, 0);
1657:switcherator.c ****     ok();
1658:switcherator.c **** }
1659:switcherator.c **** 
1660:switcherator.c **** void startTheProgram(int programNumber, int duration, long time) {
 975               		.loc 1 1660 0
 976               	.LVL56:
 977 0552 8F92      		push r8
 978               	.LCFI10:
 979 0554 9F92      		push r9
 980               	.LCFI11:
 981 0556 AF92      		push r10
 982               	.LCFI12:
 983 0558 BF92      		push r11
 984               	.LCFI13:
 985 055a CF92      		push r12
 986               	.LCFI14:
 987 055c DF92      		push r13
 988               	.LCFI15:
 989 055e EF92      		push r14
 990               	.LCFI16:
 991 0560 FF92      		push r15
 992               	.LCFI17:
 993 0562 1F93      		push r17
 994               	.LCFI18:
 995 0564 CF93      		push r28
 996               	.LCFI19:
 997 0566 DF93      		push r29
 998               	.LCFI20:
 999 0568 CDB7      		in r28,__SP_L__
 1000 056a DEB7      		in r29,__SP_H__
 1001               	.LCFI21:
 1002 056c 6497      		sbiw r28,20
 1003               	.LCFI22:
 1004 056e 0FB6      		in __tmp_reg__,__SREG__
 1005 0570 F894      		cli
 1006 0572 DEBF      		out __SP_H__,r29
 1007 0574 0FBE      		out __SREG__,__tmp_reg__
 1008 0576 CDBF      		out __SP_L__,r28
 1009               	/* prologue: function */
 1010               	/* frame size = 20 */
 1011               	/* stack size = 31 */
 1012               	.L__stack_usage = 31
 1013 0578 4B01      		movw r8,r22
 1014               	.LVL57:
1661:switcherator.c ****     char switches[NUM_SWITCHES];
1662:switcherator.c ****     int switchCount = 0;
1663:switcherator.c ****     int thisSwitch = 0;
1664:switcherator.c ****     int x = 0;
1665:switcherator.c **** 
1666:switcherator.c ****     if (duration == 0) {
 1015               		.loc 1 1666 0
 1016 057a 6115      		cp r22,__zero_reg__
 1017 057c 7105      		cpc r23,__zero_reg__
 1018 057e 01F4      		brne .L70
 1019               	.LVL58:
1667:switcherator.c ****         // get the duration since we weren't fed it
1668:switcherator.c ****         duration = weeklyProgram[programNumber][3];
1669:switcherator.c ****         duration <<= 8;
1670:switcherator.c ****         duration = weeklyProgram[programNumber][4];
 1020               		.loc 1 1670 0
 1021 0580 6AE0      		ldi r22,lo8(10)
 1022 0582 689F      		mul r22,r24
 1023 0584 F001      		movw r30,r0
 1024 0586 699F      		mul r22,r25
 1025 0588 F00D      		add r31,r0
 1026 058a 1124      		clr __zero_reg__
 1027 058c E050      		subi r30,lo8(-(weeklyProgram))
 1028 058e F040      		sbci r31,hi8(-(weeklyProgram))
 1029 0590 8480      		ldd r8,Z+4
 1030 0592 912C      		mov r9,__zero_reg__
 1031               	.LVL59:
 1032               	.L70:
1671:switcherator.c ****     }
1672:switcherator.c ****     switchCount = programGetSwitches(programNumber, switches);
 1033               		.loc 1 1672 0
 1034 0594 BE01      		movw r22,r28
 1035 0596 6F5F      		subi r22,-1
 1036 0598 7F4F      		sbci r23,-1
 1037 059a 298B      		std Y+17,r18
 1038 059c 3A8B      		std Y+18,r19
 1039 059e 4B8B      		std Y+19,r20
 1040 05a0 5C8B      		std Y+20,r21
 1041 05a2 0E94 0000 		call programGetSwitches
 1042               	.LVL60:
 1043 05a6 AA24      		clr r10
 1044 05a8 97FC      		sbrc r9,7
 1045 05aa A094      		com r10
 1046 05ac BA2C      		mov r11,r10
 1047 05ae C090 0000 		lds r12,weeklySeconds
 1048 05b2 D090 0000 		lds r13,weeklySeconds+1
 1049 05b6 E090 0000 		lds r14,weeklySeconds+2
 1050 05ba F090 0000 		lds r15,weeklySeconds+3
1673:switcherator.c ****     // see if we were fed the start time so we don't go too long
1674:switcherator.c ****     // this may run multiple times
1675:switcherator.c ****     if (time == 0) {
 1051               		.loc 1 1675 0
 1052 05be 2989      		ldd r18,Y+17
 1053 05c0 3A89      		ldd r19,Y+18
 1054 05c2 4B89      		ldd r20,Y+19
 1055 05c4 5C89      		ldd r21,Y+20
 1056 05c6 2115      		cp r18,__zero_reg__
 1057 05c8 3105      		cpc r19,__zero_reg__
 1058 05ca 4105      		cpc r20,__zero_reg__
 1059 05cc 5105      		cpc r21,__zero_reg__
 1060 05ce 01F4      		brne .L71
1676:switcherator.c ****         time = weeklySeconds + duration;
 1061               		.loc 1 1676 0
 1062 05d0 A501      		movw r20,r10
 1063 05d2 9401      		movw r18,r8
 1064 05d4 2C0D      		add r18,r12
 1065 05d6 3D1D      		adc r19,r13
 1066 05d8 4E1D      		adc r20,r14
 1067 05da 5F1D      		adc r21,r15
 1068               	.LVL61:
 1069               	.L71:
1677:switcherator.c ****     }
1678:switcherator.c ****     for (x = 0; x < switchCount; x++) {
1679:switcherator.c ****         thisSwitch = switches[x];
1680:switcherator.c ****         // only update the time if it is longer than what the switch is already turned on to
1681:switcherator.c ****         if ((weeklySeconds + duration) > switchStatus[thisSwitch])
 1070               		.loc 1 1681 0
 1071 05dc C80C      		add r12,r8
 1072 05de D91C      		adc r13,r9
 1073 05e0 EA1C      		adc r14,r10
 1074 05e2 FB1C      		adc r15,r11
 1075 05e4 FE01      		movw r30,r28
 1076 05e6 3196      		adiw r30,1
1660:switcherator.c **** void startTheProgram(int programNumber, int duration, long time) {
 1077               		.loc 1 1660 0
 1078 05e8 BF01      		movw r22,r30
1678:switcherator.c ****     for (x = 0; x < switchCount; x++) {
 1079               		.loc 1 1678 0
 1080 05ea 00C0      		rjmp .L77
 1081               	.LVL62:
 1082               	.L74:
1679:switcherator.c ****         thisSwitch = switches[x];
 1083               		.loc 1 1679 0
 1084 05ec A191      		ld r26,Z+
 1085               	.LVL63:
 1086               		.loc 1 1681 0
 1087 05ee 14E0      		ldi r17,lo8(4)
 1088 05f0 A19F      		mul r26,r17
 1089 05f2 D001      		movw r26,r0
 1090 05f4 1124      		clr __zero_reg__
 1091               	.LVL64:
 1092 05f6 A050      		subi r26,lo8(-(switchStatus))
 1093 05f8 B040      		sbci r27,hi8(-(switchStatus))
 1094 05fa 8D90      		ld r8,X+
 1095 05fc 9D90      		ld r9,X+
 1096 05fe AD90      		ld r10,X+
 1097 0600 BC90      		ld r11,X
 1098 0602 1397      		sbiw r26,3
 1099 0604 8C14      		cp r8,r12
 1100 0606 9D04      		cpc r9,r13
 1101 0608 AE04      		cpc r10,r14
 1102 060a BF04      		cpc r11,r15
 1103 060c 00F4      		brsh .L77
1682:switcherator.c ****             switchStatus[thisSwitch] = time;
 1104               		.loc 1 1682 0
 1105 060e 2D93      		st X+,r18
 1106 0610 3D93      		st X+,r19
 1107 0612 4D93      		st X+,r20
 1108 0614 5C93      		st X,r21
 1109 0616 1397      		sbiw r26,3
 1110               	.LVL65:
 1111               	.L77:
1660:switcherator.c **** void startTheProgram(int programNumber, int duration, long time) {
 1112               		.loc 1 1660 0 discriminator 1
 1113 0618 DF01      		movw r26,r30
 1114 061a A61B      		sub r26,r22
 1115 061c B70B      		sbc r27,r23
1678:switcherator.c ****     for (x = 0; x < switchCount; x++) {
 1116               		.loc 1 1678 0 discriminator 1
 1117 061e A817      		cp r26,r24
 1118 0620 B907      		cpc r27,r25
 1119 0622 04F0      		brlt .L74
1683:switcherator.c ****     }
1684:switcherator.c ****     switchChanged = 1;
 1120               		.loc 1 1684 0
 1121 0624 81E0      		ldi r24,lo8(1)
 1122               	.LVL66:
 1123 0626 8093 0000 		sts switchChanged,r24
 1124               	/* epilogue start */
1685:switcherator.c **** }
 1125               		.loc 1 1685 0
 1126 062a 6496      		adiw r28,20
 1127 062c 0FB6      		in __tmp_reg__,__SREG__
 1128 062e F894      		cli
 1129 0630 DEBF      		out __SP_H__,r29
 1130 0632 0FBE      		out __SREG__,__tmp_reg__
 1131 0634 CDBF      		out __SP_L__,r28
 1132 0636 DF91      		pop r29
 1133 0638 CF91      		pop r28
 1134 063a 1F91      		pop r17
 1135 063c FF90      		pop r15
 1136 063e EF90      		pop r14
 1137 0640 DF90      		pop r13
 1138 0642 CF90      		pop r12
 1139 0644 BF90      		pop r11
 1140 0646 AF90      		pop r10
 1141 0648 9F90      		pop r9
 1142 064a 8F90      		pop r8
 1143 064c 0895      		ret
 1144               	.LFE40:
 1146               	.global	readEEPROM
 1148               	readEEPROM:
 1149               	.LFB42:
1686:switcherator.c **** 
1687:switcherator.c **** 
1688:switcherator.c **** /****************************************************************
1689:switcherator.c ****  *
1690:switcherator.c ****  *              All Things EEPROM Related
1691:switcherator.c ****  *
1692:switcherator.c ****  ****************************************************************/
1693:switcherator.c **** 
1694:switcherator.c **** // Get variables out of EEPROM and set things up
1695:switcherator.c **** 
1696:switcherator.c **** void generalInit(void) {
1697:switcherator.c ****     // read the program info
1698:switcherator.c ****     char tempStuff[14];
1699:switcherator.c ****     int x = 0;
1700:switcherator.c ****     // Go through the addresses and assign them if set
1701:switcherator.c ****     // decided later that this is a really bad idea. gets corrupted.  use default
1702:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_TX, RADIO_ADDR_TX_BYTES) == 1) {
1703:switcherator.c ****         tx_addr = formatAddress(tempStuff);
1704:switcherator.c ****         writeAddr(TX_ADDR, tx_addr);
1705:switcherator.c ****     }
1706:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R0, RADIO_ADDR_R0_BYTES) == 1) {
1707:switcherator.c ****         rx_addr_p0 = formatAddress(tempStuff);
1708:switcherator.c ****         writeAddr(RX_ADDR_P0, rx_addr_p0);
1709:switcherator.c ****     }
1710:switcherator.c ****      
1711:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R1, RADIO_ADDR_R1_BYTES) == 1) {
1712:switcherator.c ****         rx_addr_p1 = formatAddress(tempStuff);
1713:switcherator.c ****         writeAddr(RX_ADDR_P1, rx_addr_p1);
1714:switcherator.c ****     }
1715:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R2, RADIO_ADDR_R2_BYTES) == 1) {
1716:switcherator.c ****         rx_addr_p2 = tempStuff[0];
1717:switcherator.c ****         writeAddr(RX_ADDR_P2, rx_addr_p2);
1718:switcherator.c ****     }
1719:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R3, RADIO_ADDR_R3_BYTES) == 1) {
1720:switcherator.c ****         rx_addr_p3 = tempStuff[0];
1721:switcherator.c ****         writeAddr(RX_ADDR_P3, rx_addr_p3);
1722:switcherator.c ****     }
1723:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R4, RADIO_ADDR_R4_BYTES) == 1) {
1724:switcherator.c ****         rx_addr_p4 = tempStuff[0];
1725:switcherator.c ****         writeAddr(RX_ADDR_P4, rx_addr_p4);
1726:switcherator.c ****     }
1727:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R5, RADIO_ADDR_R5_BYTES) == 1) {
1728:switcherator.c ****         rx_addr_p5 = tempStuff[0];
1729:switcherator.c ****         writeAddr(RX_ADDR_P5, rx_addr_p5);
1730:switcherator.c ****     }
1731:switcherator.c ****     if (readEEPROM(tempStuff, TWEAK_TIMER, TWEAK_TIMER_BYTES) == 1) {
1732:switcherator.c ****         tweakTimer = tempStuff[0];
1733:switcherator.c ****         tweakTimer <<= 8;
1734:switcherator.c ****         tweakTimer |= tempStuff[1];
1735:switcherator.c ****     }
1736:switcherator.c **** 
1737:switcherator.c **** 
1738:switcherator.c ****     // process daylight savings
1739:switcherator.c ****     if (readEEPROM(tempStuff, DAYLIGHT_SAVE, DAYLIGHT_SAVE_BYTES) == 1) {
1740:switcherator.c ****         // Spring month
1741:switcherator.c ****         daylightSavings[0][0] = ((tempStuff[0] << 8) | (tempStuff[1]));
1742:switcherator.c ****         // Spring day
1743:switcherator.c ****         daylightSavings[0][1] = ((tempStuff[2] << 8) | (tempStuff[3]));
1744:switcherator.c ****         // Fall month
1745:switcherator.c ****         daylightSavings[1][0] = ((tempStuff[4] << 8) | (tempStuff[5]));
1746:switcherator.c ****         // Fall day
1747:switcherator.c ****         daylightSavings[1][1] = ((tempStuff[6] << 8) | (tempStuff[7]));
1748:switcherator.c ****     }
1749:switcherator.c **** 
1750:switcherator.c ****     if (readEEPROM(tempStuff, SERIAL_NUM, SERIAL_NUM_BYTES) == 1) {
1751:switcherator.c ****         serial = atol(tempStuff);
1752:switcherator.c ****         ltoa(serial, stringSerial, 10);
1753:switcherator.c ****     }
1754:switcherator.c **** 
1755:switcherator.c ****     // switches
1756:switcherator.c ****     if (readEEPROM(switchStuff, SWITCH_STUFF, SWITCH_STUFF_BYTES) == 1) {
1757:switcherator.c ****         readEEPROM(switchBright, BRIGHTNESS, BRIGHTNESS_BYTES);
1758:switcherator.c ****         volatile unsigned char *realPort = 0;
1759:switcherator.c ****         volatile unsigned char *realDDR = 0;
1760:switcherator.c ****         char realPin = 0;
1761:switcherator.c ****         char temp = 0;
1762:switcherator.c ****         // Pp - value of 255 (default) means nothing programmed
1763:switcherator.c ****         // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
1764:switcherator.c ****         // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
1765:switcherator.c ****         for (x = 0; x < NUM_SWITCHES; x++) {
1766:switcherator.c ****             temp = switchStuff[x];
1767:switcherator.c ****             if (temp > 15 && temp < 32) {
1768:switcherator.c ****                 realPort = &PORTB;
1769:switcherator.c ****                 realDDR = &DDRB;
1770:switcherator.c ****                 temp -= 16;
1771:switcherator.c **** #ifdef PINA
1772:switcherator.c ****             } else if (temp < 16) {
1773:switcherator.c ****                 realPort = &PORTA;
1774:switcherator.c ****                 realDDR = &DDRA;
1775:switcherator.c ****                 temp -= 0;
1776:switcherator.c **** #endif
1777:switcherator.c **** #ifdef PINC
1778:switcherator.c ****             } else if (temp < 48) {
1779:switcherator.c ****                 realPort = &PORTC;
1780:switcherator.c ****                 realDDR = &DDRC;
1781:switcherator.c ****                 temp -= 32;
1782:switcherator.c **** #endif
1783:switcherator.c **** #ifdef PIND
1784:switcherator.c ****             } else if (temp < 64) {
1785:switcherator.c ****                 realPort = &PORTD;
1786:switcherator.c ****                 realDDR = &DDRD;
1787:switcherator.c ****                 temp -= 48;
1788:switcherator.c **** #endif
1789:switcherator.c **** #ifdef PINE
1790:switcherator.c ****             } else if (temp < 80) {
1791:switcherator.c ****                 realPort = &PORTE;
1792:switcherator.c ****                 realDDR = &DDRE;
1793:switcherator.c ****                 temp -= 64;
1794:switcherator.c **** #endif
1795:switcherator.c **** #ifdef PINF
1796:switcherator.c ****             } else if (temp < 96) {
1797:switcherator.c ****                 realPort = &PORTF;
1798:switcherator.c ****                 realDDR = &DDRF;
1799:switcherator.c ****                 temp -= 80;
1800:switcherator.c **** #endif
1801:switcherator.c **** #ifdef PING
1802:switcherator.c ****             } else if (temp < 112) {
1803:switcherator.c ****                 realPort = &PORTG;
1804:switcherator.c ****                 realDDR = &DDRG;
1805:switcherator.c ****                 temp -= 96;
1806:switcherator.c **** #endif
1807:switcherator.c **** #ifdef PINH
1808:switcherator.c ****             } else if (temp < 128) {
1809:switcherator.c ****                 realPort = &PORTH;
1810:switcherator.c ****                 realDDR = &DDRH;
1811:switcherator.c ****                 temp -= 112;
1812:switcherator.c **** #endif
1813:switcherator.c **** #ifdef PINI
1814:switcherator.c ****             } else if (temp < 144) {
1815:switcherator.c ****                 realPort = &PORTI;
1816:switcherator.c ****                 realDDR = &DDRI;
1817:switcherator.c ****                 temp -= 128;
1818:switcherator.c **** #endif
1819:switcherator.c ****                 // pwm setup
1820:switcherator.c ****             } else {
1821:switcherator.c ****                 continue;
1822:switcherator.c ****             }
1823:switcherator.c ****             realPin = (temp / 2);
1824:switcherator.c ****             *realDDR |= (1 << realPin);
1825:switcherator.c ****             // figure out direction
1826:switcherator.c ****             if (temp % 2 == 0) {
1827:switcherator.c ****                 // 0 = low is on  1 = high is on
1828:switcherator.c ****                 *realPort |= (1 << realPin);
1829:switcherator.c ****             } else {
1830:switcherator.c ****                 *realPort &= ~(1 << realPin);
1831:switcherator.c ****             }
1832:switcherator.c ****         }
1833:switcherator.c ****     } else {
1834:switcherator.c ****         for (x = 0; x < NUM_SWITCHES; x++)
1835:switcherator.c ****             switchStuff[x] = 255;
1836:switcherator.c ****     }
1837:switcherator.c **** 
1838:switcherator.c ****     int memoryMarker = 0;
1839:switcherator.c ****     int y = 0;
1840:switcherator.c ****     // get the programs
1841:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
1842:switcherator.c ****         memoryMarker = (WEEKLY_PROGRAM + (x * WEEKLY_PROGRAM_BYTES));
1843:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, WEEKLY_PROGRAM_BYTES) == 1) {
1844:switcherator.c ****             for (y = 0; y < 10; y++) {
1845:switcherator.c ****                 weeklyProgram[x][y] = tempStuff[y];
1846:switcherator.c ****             }
1847:switcherator.c ****         }
1848:switcherator.c ****     }
1849:switcherator.c ****     // get the inputs
1850:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
1851:switcherator.c ****         memoryMarker = (INPUT + (x * INPUT_BYTES));
1852:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, INPUT_BYTES) == 1) {
1853:switcherator.c ****             for (y = 0; y < 8; y++) {
1854:switcherator.c ****                 inputs[x][y] = tempStuff[y];
1855:switcherator.c ****             }
1856:switcherator.c ****         }
1857:switcherator.c ****     }
1858:switcherator.c ****     // get the time limits
1859:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++) {
1860:switcherator.c ****         memoryMarker = (LIMIT + (x * LIMIT_BYTES));
1861:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, LIMIT_BYTES) == 1) {
1862:switcherator.c ****             for (y = 0; y < 3; y++) {
1863:switcherator.c ****                 timeLimits[x][y] = tempStuff[y];
1864:switcherator.c ****             }
1865:switcherator.c ****         }
1866:switcherator.c ****     }
1867:switcherator.c **** 
1868:switcherator.c ****     if (readEEPROM(tempStuff, PWM_DIR, PWM_DIR_BYTES) == 1) {
1869:switcherator.c ****         DDRD |= (1 << PIND3) | (1 << PIND5) | (1 << PIND6);
1870:switcherator.c ****         // make sure initial values are 0
1871:switcherator.c ****         Red = 0;
1872:switcherator.c ****         Green = 0;
1873:switcherator.c ****         Blue = 0;
1874:switcherator.c ****         // Set output phase correct whatevers
1875:switcherator.c ****         // set it to inverted if the direction is 0
1876:switcherator.c ****         if (tempStuff[0] == 0) {
1877:switcherator.c ****             TCCR0A = (1 << COM0A0) | (1 << COM0A1) | (1 << COM0B0) | (1 << COM0B1) | (1 << WGM00);
1878:switcherator.c ****             TCCR2A = (1 << COM2B0) | (1 << COM2B1) | (1 << WGM20);
1879:switcherator.c ****             pwmdir = 0;
1880:switcherator.c ****         } else {
1881:switcherator.c ****             TCCR0A = (1 << COM0A1) | (1 << COM0B1) | (1 << WGM00);
1882:switcherator.c ****             TCCR2A = (1 << COM2B1) | (1 << WGM20);
1883:switcherator.c ****             pwmdir = 1;
1884:switcherator.c ****         }
1885:switcherator.c ****         // F_CPU/64 timers
1886:switcherator.c ****         TCCR0B = (1 << CS01) | (1 << CS00);
1887:switcherator.c **** 
1888:switcherator.c ****         TCCR2B = (1 << CS22); // F_CPU/64
1889:switcherator.c ****     }
1890:switcherator.c **** 
1891:switcherator.c ****     // get the pwm value bytes
1892:switcherator.c ****     memoryMarker = (PWM_VALUE);
1893:switcherator.c ****     if (readEEPROM(tempStuff, memoryMarker, PWM_VALUE_BYTES) == 1) {
1894:switcherator.c ****         pwmValues[0] = tempStuff[0];
1895:switcherator.c ****         pwmValues[1] = tempStuff[1];
1896:switcherator.c ****         pwmValues[2] = tempStuff[2];
1897:switcherator.c ****     }
1898:switcherator.c ****     // get the color change
1899:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
1900:switcherator.c ****         memoryMarker = (COLOR_CHANGE + (x * COLOR_CHANGE_BYTES));
1901:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, PWM_VALUE_BYTES) == 1) {
1902:switcherator.c ****             for (y = 0; y < 3; y++) {
1903:switcherator.c ****                 colorChanges[x][y] = tempStuff[y];
1904:switcherator.c ****             }
1905:switcherator.c ****         }
1906:switcherator.c ****     }
1907:switcherator.c **** }
1908:switcherator.c **** 
1909:switcherator.c **** int readEEPROM(char * data, int memLocation, int memBytes) {
 1150               		.loc 1 1909 0
 1151               	.LVL67:
 1152 064e EF92      		push r14
 1153               	.LCFI23:
 1154 0650 FF92      		push r15
 1155               	.LCFI24:
 1156 0652 0F93      		push r16
 1157               	.LCFI25:
 1158 0654 1F93      		push r17
 1159               	.LCFI26:
 1160 0656 CF93      		push r28
 1161               	.LCFI27:
 1162 0658 DF93      		push r29
 1163               	.LCFI28:
 1164               	/* prologue: function */
 1165               	/* frame size = 0 */
 1166               	/* stack size = 6 */
 1167               	.L__stack_usage = 6
 1168 065a 7C01      		movw r14,r24
 1169 065c EB01      		movw r28,r22
 1170 065e 8A01      		movw r16,r20
 1171               	.LVL68:
 1172 0660 FC01      		movw r30,r24
1910:switcherator.c ****     uint16_t checkProgram;
1911:switcherator.c ****     int x = 0;
1912:switcherator.c ****     for (x = 0; x < 14; x++) {
 1173               		.loc 1 1912 0
 1174 0662 20E0      		ldi r18,0
 1175 0664 30E0      		ldi r19,0
 1176               	.LVL69:
 1177               	.L79:
1913:switcherator.c ****         data[x] = 0;
 1178               		.loc 1 1913 0 discriminator 2
 1179 0666 1192      		st Z+,__zero_reg__
1912:switcherator.c ****     for (x = 0; x < 14; x++) {
 1180               		.loc 1 1912 0 discriminator 2
 1181 0668 2F5F      		subi r18,-1
 1182 066a 3F4F      		sbci r19,-1
 1183               	.LVL70:
 1184 066c 2E30      		cpi r18,14
 1185 066e 3105      		cpc r19,__zero_reg__
 1186 0670 01F4      		brne .L79
1914:switcherator.c ****     }
1915:switcherator.c ****     // see if it has been programmed
1916:switcherator.c ****     checkProgram = eeprom_read_word((uint16_t*) memLocation);
 1187               		.loc 1 1916 0
 1188 0672 CE01      		movw r24,r28
 1189 0674 0E94 0000 		call __eerd_word_m328
 1190               	.LVL71:
1917:switcherator.c ****     // "DW" = 68,87 = 0x4457
1918:switcherator.c ****     if (checkProgram == 0x4457) {
 1191               		.loc 1 1918 0
 1192 0678 8735      		cpi r24,87
 1193 067a 9444      		sbci r25,68
 1194 067c 01F4      		brne .L81
 1195               	.LVL72:
 1196               	.LBB20:
 1197               	.LBB21:
1919:switcherator.c ****         // we've written here before. now get the data (except marker)
1920:switcherator.c ****         eeprom_read_block((void*) data, (const void*) (memLocation + 2), (memBytes - 2));
 1198               		.loc 1 1920 0
 1199 067e A801      		movw r20,r16
 1200 0680 4250      		subi r20,2
 1201 0682 5109      		sbc r21,__zero_reg__
 1202 0684 BE01      		movw r22,r28
 1203 0686 6E5F      		subi r22,-2
 1204 0688 7F4F      		sbci r23,-1
 1205 068a C701      		movw r24,r14
 1206               	.LVL73:
 1207 068c 0E94 0000 		call __eerd_block_m328
 1208               	.LVL74:
 1209 0690 21E0      		ldi r18,lo8(1)
 1210 0692 30E0      		ldi r19,0
 1211 0694 00C0      		rjmp .L80
 1212               	.LVL75:
 1213               	.L81:
 1214               	.LBE21:
 1215               	.LBE20:
1921:switcherator.c ****         return 1;
1922:switcherator.c ****     } else {
1923:switcherator.c ****         return 0;
 1216               		.loc 1 1923 0
 1217 0696 20E0      		ldi r18,0
 1218 0698 30E0      		ldi r19,0
 1219               	.LVL76:
 1220               	.L80:
1924:switcherator.c ****     }
1925:switcherator.c **** }
 1221               		.loc 1 1925 0
 1222 069a C901      		movw r24,r18
 1223               	/* epilogue start */
 1224 069c DF91      		pop r29
 1225 069e CF91      		pop r28
 1226               	.LVL77:
 1227 06a0 1F91      		pop r17
 1228 06a2 0F91      		pop r16
 1229               	.LVL78:
 1230 06a4 FF90      		pop r15
 1231 06a6 EF90      		pop r14
 1232               	.LVL79:
 1233 06a8 0895      		ret
 1234               	.LFE42:
 1236               	.global	writeEEPROM
 1238               	writeEEPROM:
 1239               	.LFB43:
1926:switcherator.c **** 
1927:switcherator.c **** void writeEEPROM(char * data, int memLocation, int memBytes) {
 1240               		.loc 1 1927 0
 1241               	.LVL80:
 1242 06aa CF93      		push r28
 1243               	.LCFI29:
 1244 06ac DF93      		push r29
 1245               	.LCFI30:
 1246               	/* prologue: function */
 1247               	/* frame size = 0 */
 1248               	/* stack size = 2 */
 1249               	.L__stack_usage = 2
 1250 06ae EB01      		movw r28,r22
 1251               	.LVL81:
1928:switcherator.c ****     uint16_t marker = 0x4457; // "DW" in ascii
1929:switcherator.c ****     eeprom_update_block((const void*) data, (void*) (memLocation + 2), (memBytes - 2));
 1252               		.loc 1 1929 0
 1253 06b0 4250      		subi r20,2
 1254 06b2 5109      		sbc r21,__zero_reg__
 1255               	.LVL82:
 1256 06b4 6E5F      		subi r22,-2
 1257 06b6 7F4F      		sbci r23,-1
 1258               	.LVL83:
 1259 06b8 0E94 0000 		call __eeupd_block_m328
 1260               	.LVL84:
1930:switcherator.c ****     eeprom_update_word((uint16_t*) memLocation, marker);
 1261               		.loc 1 1930 0
 1262 06bc 67E5      		ldi r22,lo8(87)
 1263 06be 74E4      		ldi r23,lo8(68)
 1264 06c0 CE01      		movw r24,r28
 1265               	/* epilogue start */
1931:switcherator.c **** }
 1266               		.loc 1 1931 0
 1267 06c2 DF91      		pop r29
 1268 06c4 CF91      		pop r28
 1269               	.LVL85:
1930:switcherator.c ****     eeprom_update_word((uint16_t*) memLocation, marker);
 1270               		.loc 1 1930 0
 1271 06c6 0C94 0000 		jmp __eeupd_word_m328
 1272               	.LVL86:
 1273               	.LFE43:
 1275               	.global	clearEEPROM
 1277               	clearEEPROM:
 1278               	.LFB44:
1932:switcherator.c **** 
1933:switcherator.c **** void clearEEPROM(int memLocation) {
 1279               		.loc 1 1933 0
 1280               	.LVL87:
 1281               	/* prologue: function */
 1282               	/* frame size = 0 */
 1283               	/* stack size = 0 */
 1284               	.L__stack_usage = 0
1934:switcherator.c ****     uint16_t marker = 0x0000; // blank it out
1935:switcherator.c ****     eeprom_update_word((uint16_t*) memLocation, marker);
 1285               		.loc 1 1935 0
 1286 06ca 60E0      		ldi r22,0
 1287 06cc 70E0      		ldi r23,0
 1288 06ce 0C94 0000 		jmp __eeupd_word_m328
 1289               	.LVL88:
 1290               	.LFE44:
 1292               	.global	clockInit
 1294               	clockInit:
 1295               	.LFB47:
1936:switcherator.c **** }
1937:switcherator.c **** 
1938:switcherator.c **** void saveToEEPROM(void) {
1939:switcherator.c ****     char tempStuff[14];
1940:switcherator.c ****     int x = 0;
1941:switcherator.c ****     // Go through the addresses and assign them if set
1942:switcherator.c ****     if (tx_addr > 0) {
1943:switcherator.c ****         unformatAddress(tx_addr, tempStuff);
1944:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_TX, RADIO_ADDR_TX_BYTES);
1945:switcherator.c ****     }
1946:switcherator.c ****     if (rx_addr_p0 > 0) {
1947:switcherator.c ****         unformatAddress(rx_addr_p0, tempStuff);
1948:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R0, RADIO_ADDR_R0_BYTES);
1949:switcherator.c ****     }
1950:switcherator.c ****     if (rx_addr_p1 > 0) {
1951:switcherator.c ****         unformatAddress(rx_addr_p1, tempStuff);
1952:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R1, RADIO_ADDR_R1_BYTES);
1953:switcherator.c ****     }
1954:switcherator.c ****     if (rx_addr_p2 > 0) {
1955:switcherator.c ****         tempStuff[0] = rx_addr_p2;
1956:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R2, RADIO_ADDR_R2_BYTES);
1957:switcherator.c ****     }
1958:switcherator.c ****     if (rx_addr_p3 > 0) {
1959:switcherator.c ****         tempStuff[0] = rx_addr_p3;
1960:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R3, RADIO_ADDR_R3_BYTES);
1961:switcherator.c ****     }
1962:switcherator.c ****     if (rx_addr_p4 > 0) {
1963:switcherator.c ****         tempStuff[0] = rx_addr_p4;
1964:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R4, RADIO_ADDR_R4_BYTES);
1965:switcherator.c ****     }
1966:switcherator.c ****     if (rx_addr_p5 > 0) {
1967:switcherator.c ****         tempStuff[0] = rx_addr_p5;
1968:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R5, RADIO_ADDR_R5_BYTES);
1969:switcherator.c ****     }
1970:switcherator.c **** 
1971:switcherator.c ****     if (tweakTimer != 0) {
1972:switcherator.c ****         tempStuff[0] = tweakTimer >> 8;
1973:switcherator.c ****         tempStuff[1] = (tweakTimer & 0xff);
1974:switcherator.c ****         writeEEPROM(tempStuff, TWEAK_TIMER, TWEAK_TIMER_BYTES);
1975:switcherator.c ****     }
1976:switcherator.c **** 
1977:switcherator.c **** 
1978:switcherator.c **** 
1979:switcherator.c ****     if (daylightSavings[0][0] > 0) {
1980:switcherator.c ****         tempStuff[0] = (daylightSavings[0][0] >> 8);
1981:switcherator.c ****         tempStuff[1] = (daylightSavings[0][0] & 0xff);
1982:switcherator.c ****         tempStuff[2] = (daylightSavings[0][1] >> 8);
1983:switcherator.c ****         tempStuff[3] = (daylightSavings[0][1] & 0xff);
1984:switcherator.c ****         tempStuff[4] = (daylightSavings[1][0] >> 8);
1985:switcherator.c ****         tempStuff[5] = (daylightSavings[1][0] & 0xff);
1986:switcherator.c ****         tempStuff[6] = (daylightSavings[1][1] >> 8);
1987:switcherator.c ****         tempStuff[7] = (daylightSavings[1][1] & 0xff);
1988:switcherator.c ****         writeEEPROM(tempStuff, DAYLIGHT_SAVE, DAYLIGHT_SAVE_BYTES);
1989:switcherator.c ****     }
1990:switcherator.c ****     if (serial > 0) {
1991:switcherator.c ****         ltoa(serial, tempStuff, 10);
1992:switcherator.c ****         writeEEPROM(tempStuff, SERIAL_NUM, SERIAL_NUM_BYTES);
1993:switcherator.c ****     }
1994:switcherator.c ****     char setupaSwitch = 0;
1995:switcherator.c ****     char setupPWM = 0;
1996:switcherator.c **** 
1997:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
1998:switcherator.c ****         if (switchStuff[x] < 255)
1999:switcherator.c ****             setupaSwitch = 1;
2000:switcherator.c ****         if (switchStuff[x] >= 200 && switchStuff[x] <= 230)
2001:switcherator.c ****             setupPWM = 1;
2002:switcherator.c ****     }
2003:switcherator.c ****     if (setupaSwitch == 1) {
2004:switcherator.c ****         writeEEPROM(switchStuff, SWITCH_STUFF, SWITCH_STUFF_BYTES);
2005:switcherator.c ****         writeEEPROM(switchBright, BRIGHTNESS, BRIGHTNESS_BYTES);
2006:switcherator.c ****     }
2007:switcherator.c ****     tempStuff[0] = pwmdir;
2008:switcherator.c ****     if (setupPWM == 1)
2009:switcherator.c ****         writeEEPROM(tempStuff, PWM_DIR, PWM_DIR_BYTES);
2010:switcherator.c **** 
2011:switcherator.c ****     int memoryMarker;
2012:switcherator.c **** 
2013:switcherator.c **** 
2014:switcherator.c **** 
2015:switcherator.c **** 
2016:switcherator.c ****     // save the programs
2017:switcherator.c ****     int y = 0;
2018:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
2019:switcherator.c ****         memoryMarker = (WEEKLY_PROGRAM + (x * WEEKLY_PROGRAM_BYTES));
2020:switcherator.c ****         if (weeklyProgram[x][0] != 255 || weeklyProgram[x][1] != 255) {
2021:switcherator.c ****             for (y = 0; y < 10; y++)
2022:switcherator.c ****                 tempStuff[y] = weeklyProgram[x][y];
2023:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, WEEKLY_PROGRAM_BYTES);
2024:switcherator.c ****         }
2025:switcherator.c ****     }
2026:switcherator.c **** 
2027:switcherator.c ****     // save the inputs
2028:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
2029:switcherator.c ****         memoryMarker = (INPUT + (x * INPUT_BYTES));
2030:switcherator.c ****         if (inputs[x][0] != 255) {
2031:switcherator.c ****             for (y = 0; y < 8; y++) {
2032:switcherator.c ****                 tempStuff[y] = inputs[x][y];
2033:switcherator.c ****             }
2034:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, INPUT_BYTES);
2035:switcherator.c ****         }
2036:switcherator.c ****     }
2037:switcherator.c **** 
2038:switcherator.c ****     // save the time limits
2039:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++) {
2040:switcherator.c ****         memoryMarker = (LIMIT + (x * LIMIT_BYTES));
2041:switcherator.c ****         if (timeLimits[x][2] > 0) {
2042:switcherator.c ****             for (y = 0; y < 3; y++) {
2043:switcherator.c ****                 tempStuff[y] = timeLimits[x][y];
2044:switcherator.c ****             }
2045:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, INPUT_BYTES);
2046:switcherator.c ****         }
2047:switcherator.c ****     }
2048:switcherator.c **** 
2049:switcherator.c **** 
2050:switcherator.c ****     // save the pwm value bytes
2051:switcherator.c ****     memoryMarker = (PWM_VALUE);
2052:switcherator.c ****     if (pwmValues[0] != 0 || pwmValues[1] != 0 || pwmValues[2] != 0) {
2053:switcherator.c ****         for (y = 0; y < 3; y++) {
2054:switcherator.c ****             tempStuff[y] = pwmValues[y];
2055:switcherator.c ****         }
2056:switcherator.c ****         writeEEPROM(tempStuff, memoryMarker, PWM_VALUE_BYTES);
2057:switcherator.c ****     }
2058:switcherator.c **** 
2059:switcherator.c ****     // save the color change
2060:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
2061:switcherator.c ****         memoryMarker = (COLOR_CHANGE + (x * COLOR_CHANGE_BYTES));
2062:switcherator.c ****         if (colorChanges[0][0] != 0 || colorChanges[0][1] != 1 || colorChanges[0][2] != 0) {
2063:switcherator.c ****             for (y = 0; y < 3; y++) {
2064:switcherator.c ****                 tempStuff[y] = inputs[x][y];
2065:switcherator.c ****             }
2066:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, COLOR_CHANGE_BYTES);
2067:switcherator.c ****         }
2068:switcherator.c ****     }
2069:switcherator.c ****     ok();
2070:switcherator.c **** }
2071:switcherator.c **** 
2072:switcherator.c **** void clearToEEPROM(void) {
2073:switcherator.c ****     int x = 0;
2074:switcherator.c ****     clearEEPROM(SERIAL_NUM);
2075:switcherator.c ****     clearEEPROM(DAYLIGHT_SAVE);
2076:switcherator.c ****     clearEEPROM(RADIO_ADDR_TX);
2077:switcherator.c ****     clearEEPROM(RADIO_ADDR_R0);
2078:switcherator.c ****     clearEEPROM(RADIO_ADDR_R1);
2079:switcherator.c ****     clearEEPROM(RADIO_ADDR_R2);
2080:switcherator.c ****     clearEEPROM(RADIO_ADDR_R3);
2081:switcherator.c ****     clearEEPROM(RADIO_ADDR_R4);
2082:switcherator.c ****     clearEEPROM(RADIO_ADDR_R5);
2083:switcherator.c ****     clearEEPROM(SWITCH_STUFF);
2084:switcherator.c ****     clearEEPROM(PWM_DIR);
2085:switcherator.c ****     clearEEPROM(BRIGHTNESS);
2086:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++)
2087:switcherator.c ****         clearEEPROM((INPUT + (x * INPUT_BYTES)));
2088:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++)
2089:switcherator.c ****         clearEEPROM((LIMIT + (x * LIMIT_BYTES)));
2090:switcherator.c ****     clearEEPROM(PWM_VALUE);
2091:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++)
2092:switcherator.c ****         clearEEPROM((COLOR_CHANGE + (x * COLOR_CHANGE_BYTES)));
2093:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++)
2094:switcherator.c ****         clearEEPROM((WEEKLY_PROGRAM + (x * WEEKLY_PROGRAM_BYTES)));
2095:switcherator.c ****     clearEEPROM(TWEAK_TIMER);
2096:switcherator.c ****     ok();
2097:switcherator.c **** }
2098:switcherator.c **** 
2099:switcherator.c **** /****************************************************************
2100:switcherator.c ****  *
2101:switcherator.c ****  *              All Things Clock Related
2102:switcherator.c ****  *
2103:switcherator.c ****  ****************************************************************/
2104:switcherator.c **** 
2105:switcherator.c **** 
2106:switcherator.c **** // initialize the clock
2107:switcherator.c **** 
2108:switcherator.c **** void clockInit(void) {
 1296               		.loc 1 2108 0
 1297               	/* prologue: function */
 1298               	/* frame size = 0 */
 1299               	/* stack size = 0 */
 1300               	.L__stack_usage = 0
2109:switcherator.c ****     // Set CTC mode (clear timer on compare)
2110:switcherator.c ****     TCCR1A = 0;
 1301               		.loc 1 2110 0
 1302 06d2 1092 8000 		sts 128,__zero_reg__
2111:switcherator.c ****     TCCR1B = (1 << WGM12);
 1303               		.loc 1 2111 0
 1304 06d6 88E0      		ldi r24,lo8(8)
 1305 06d8 8093 8100 		sts 129,r24
2112:switcherator.c ****     OCR1A = TIMER_RESET;
 1306               		.loc 1 2112 0
 1307 06dc 1092 8900 		sts 136+1,__zero_reg__
 1308 06e0 1092 8800 		sts 136,__zero_reg__
2113:switcherator.c ****     TIMSK1 = (1 << OCIE1A); // set interrupt
 1309               		.loc 1 2113 0
 1310 06e4 82E0      		ldi r24,lo8(2)
 1311 06e6 8093 6F00 		sts 111,r24
 1312 06ea 0895      		ret
 1313               	.LFE47:
 1315               	.global	startClock
 1317               	startClock:
 1318               	.LFB50:
2114:switcherator.c **** }
2115:switcherator.c **** 
2116:switcherator.c **** // we received a time command.  set the clock
2117:switcherator.c **** // Must be this format:
2118:switcherator.c **** // TI:MMDDYYYYHHMMSS
2119:switcherator.c **** // 012345678901234567
2120:switcherator.c **** 
2121:switcherator.c **** void setClock(char * commandReceived) {
2122:switcherator.c ****     long tempInt;
2123:switcherator.c ****     // iterate through and get the times.
2124:switcherator.c ****     tempLongString[0] = '0';
2125:switcherator.c ****     tempLongString[1] = '0';
2126:switcherator.c ****     // Can't see a good loop so just get to it.
2127:switcherator.c ****     // Month
2128:switcherator.c ****     tempLongString[2] = commandReceived[3];
2129:switcherator.c ****     tempLongString[3] = commandReceived[4];
2130:switcherator.c ****     globalMonth = atoi(tempLongString);
2131:switcherator.c ****     // Day
2132:switcherator.c ****     tempLongString[2] = commandReceived[5];
2133:switcherator.c ****     tempLongString[3] = commandReceived[6];
2134:switcherator.c ****     globalDay = atoi(tempLongString);
2135:switcherator.c ****     // hour
2136:switcherator.c ****     tempLongString[2] = commandReceived[11];
2137:switcherator.c ****     tempLongString[3] = commandReceived[12];
2138:switcherator.c ****     globalHour = atoi(tempLongString);
2139:switcherator.c ****     // minute
2140:switcherator.c ****     tempLongString[2] = commandReceived[13];
2141:switcherator.c ****     tempLongString[3] = commandReceived[14];
2142:switcherator.c ****     globalMinute = atoi(tempLongString);
2143:switcherator.c ****     // second
2144:switcherator.c ****     tempLongString[2] = commandReceived[15];
2145:switcherator.c ****     tempLongString[3] = commandReceived[16];
2146:switcherator.c ****     globalSecond = atoi(tempLongString);
2147:switcherator.c ****     // year
2148:switcherator.c ****     tempLongString[0] = commandReceived[7];
2149:switcherator.c ****     tempLongString[1] = commandReceived[8];
2150:switcherator.c ****     tempLongString[2] = commandReceived[9];
2151:switcherator.c ****     tempLongString[3] = commandReceived[10];
2152:switcherator.c ****     globalYear = atoi(tempLongString);
2153:switcherator.c ****     dow = getWeekday(globalYear, globalMonth, globalDay); // get day of week
2154:switcherator.c ****     tempInt = dow;
2155:switcherator.c ****     tempInt = tempInt * 24 * 60 * 60;
2156:switcherator.c ****     weeklySeconds = tempInt;
2157:switcherator.c ****     tempInt = globalHour;
2158:switcherator.c ****     tempInt = tempInt * 60 * 60;
2159:switcherator.c ****     weeklySeconds += tempInt;
2160:switcherator.c ****     tempInt = globalMinute;
2161:switcherator.c ****     tempInt = tempInt * 60;
2162:switcherator.c ****     weeklySeconds += tempInt;
2163:switcherator.c ****     weeklySeconds += globalSecond;
2164:switcherator.c ****     clockString();
2165:switcherator.c ****     sendMessage(statusMsg);
2166:switcherator.c ****     stopClock();
2167:switcherator.c ****     startClock();
2168:switcherator.c ****     panicMyClockIsNotSet = 0;
2169:switcherator.c ****     if(failCondition == 3) {
2170:switcherator.c ****         clearFail();      
2171:switcherator.c ****     }
2172:switcherator.c **** }
2173:switcherator.c **** 
2174:switcherator.c **** 
2175:switcherator.c **** // Change the clock values to a string
2176:switcherator.c **** 
2177:switcherator.c **** void clockString(void) {
2178:switcherator.c ****     statusMsg[0] = 0;
2179:switcherator.c **** 
2180:switcherator.c ****     strcat(statusMsg, " ");
2181:switcherator.c ****     returnInt(globalMonth, tempIntString);
2182:switcherator.c ****     strcat(statusMsg, tempIntString);
2183:switcherator.c ****     strcat(statusMsg, "/");
2184:switcherator.c ****     returnInt(globalDay, tempIntString);
2185:switcherator.c ****     strcat(statusMsg, tempIntString);
2186:switcherator.c ****     strcat(statusMsg, "/");
2187:switcherator.c ****     itoa(globalYear, tempIntString, 10);
2188:switcherator.c ****     strcat(statusMsg, tempIntString);
2189:switcherator.c ****     strcat(statusMsg, " ");
2190:switcherator.c ****     returnInt(globalHour, tempIntString);
2191:switcherator.c ****     strcat(statusMsg, tempIntString);
2192:switcherator.c ****     strcat(statusMsg, ":");
2193:switcherator.c ****     returnInt(globalMinute, tempIntString);
2194:switcherator.c ****     strcat(statusMsg, tempIntString);
2195:switcherator.c ****     strcat(statusMsg, ":");
2196:switcherator.c ****     returnInt(globalSecond, tempIntString);
2197:switcherator.c ****     strcat(statusMsg, tempIntString);
2198:switcherator.c **** }
2199:switcherator.c **** 
2200:switcherator.c **** // start the clock
2201:switcherator.c **** 
2202:switcherator.c **** void startClock(void) {
 1319               		.loc 1 2202 0
 1320               	/* prologue: function */
 1321               	/* frame size = 0 */
 1322               	/* stack size = 0 */
 1323               	.L__stack_usage = 0
2203:switcherator.c ****     TCNT1 = 65535;
 1324               		.loc 1 2203 0
 1325 06ec 8FEF      		ldi r24,lo8(-1)
 1326 06ee 9FEF      		ldi r25,lo8(-1)
 1327 06f0 9093 8500 		sts 132+1,r25
 1328 06f4 8093 8400 		sts 132,r24
2204:switcherator.c ****     TCCR1B |= TIMER_CLOCK_SEL;
 1329               		.loc 1 2204 0
 1330 06f8 E1E8      		ldi r30,lo8(-127)
 1331 06fa F0E0      		ldi r31,0
 1332 06fc 8081      		ld r24,Z
 1333 06fe 8560      		ori r24,lo8(5)
 1334 0700 8083      		st Z,r24
 1335 0702 0895      		ret
 1336               	.LFE50:
 1338               	.global	stopClock
 1340               	stopClock:
 1341               	.LFB51:
2205:switcherator.c **** }
2206:switcherator.c **** 
2207:switcherator.c **** void stopClock(void) {
 1342               		.loc 1 2207 0
 1343               	/* prologue: function */
 1344               	/* frame size = 0 */
 1345               	/* stack size = 0 */
 1346               	.L__stack_usage = 0
2208:switcherator.c ****     TCCR1B &= ~(TIMER_CLOCK_SEL);
 1347               		.loc 1 2208 0
 1348 0704 E1E8      		ldi r30,lo8(-127)
 1349 0706 F0E0      		ldi r31,0
 1350 0708 8081      		ld r24,Z
 1351 070a 8A7F      		andi r24,lo8(-6)
 1352 070c 8083      		st Z,r24
 1353 070e 0895      		ret
 1354               	.LFE51:
 1356               	.global	getWeekday
 1358               	getWeekday:
 1359               	.LFB52:
2209:switcherator.c **** }
2210:switcherator.c **** 
2211:switcherator.c **** // returns the weekday - sunday = 0
2212:switcherator.c **** 
2213:switcherator.c **** int getWeekday(int year, int month, int day) {
 1360               		.loc 1 2213 0
 1361               	.LVL89:
 1362 0710 CF93      		push r28
 1363               	.LCFI31:
 1364 0712 DF93      		push r29
 1365               	.LCFI32:
 1366               	/* prologue: function */
 1367               	/* frame size = 0 */
 1368               	/* stack size = 2 */
 1369               	.L__stack_usage = 2
 1370 0714 FB01      		movw r30,r22
 1371 0716 EA01      		movw r28,r20
2214:switcherator.c ****     int adjustment, mm, yy;
2215:switcherator.c **** 
2216:switcherator.c ****     adjustment = (14 - month) / 12; // Jan is 13, feb is 14 in calculation
 1372               		.loc 1 2216 0
 1373 0718 8EE0      		ldi r24,lo8(14)
 1374 071a 90E0      		ldi r25,0
 1375               	.LVL90:
 1376 071c 861B      		sub r24,r22
 1377 071e 970B      		sbc r25,r23
 1378 0720 6CE0      		ldi r22,lo8(12)
 1379 0722 70E0      		ldi r23,0
 1380               	.LVL91:
 1381 0724 0E94 0000 		call __divmodhi4
 1382               	.LVL92:
2217:switcherator.c ****     mm = month + 12 * adjustment - 2;
2218:switcherator.c ****     yy = globalYear - adjustment;
 1383               		.loc 1 2218 0
 1384 0728 2091 0000 		lds r18,globalYear
 1385 072c 3091 0000 		lds r19,globalYear+1
 1386 0730 261B      		sub r18,r22
 1387 0732 370B      		sbc r19,r23
 1388               	.LVL93:
2217:switcherator.c ****     mm = month + 12 * adjustment - 2;
 1389               		.loc 1 2217 0
 1390 0734 8CE0      		ldi r24,lo8(12)
 1391 0736 869F      		mul r24,r22
 1392 0738 A001      		movw r20,r0
 1393 073a 879F      		mul r24,r23
 1394 073c 500D      		add r21,r0
 1395 073e 1124      		clr __zero_reg__
 1396               	.LVL94:
 1397 0740 4E0F      		add r20,r30
 1398 0742 5F1F      		adc r21,r31
 1399 0744 4250      		subi r20,2
 1400 0746 5109      		sbc r21,__zero_reg__
2219:switcherator.c ****     return ((day + (13 * mm - 1) / 5 + yy + yy / 4 - yy / 100 + yy / 400) % 7);
 1401               		.loc 1 2219 0
 1402 0748 6DE0      		ldi r22,lo8(13)
 1403               	.LVL95:
 1404 074a 649F      		mul r22,r20
 1405 074c C001      		movw r24,r0
 1406 074e 659F      		mul r22,r21
 1407 0750 900D      		add r25,r0
 1408 0752 1124      		clr __zero_reg__
 1409 0754 0197      		sbiw r24,1
 1410 0756 65E0      		ldi r22,lo8(5)
 1411 0758 70E0      		ldi r23,0
 1412 075a 0E94 0000 		call __divmodhi4
 1413 075e C60F      		add r28,r22
 1414 0760 D71F      		adc r29,r23
 1415               	.LVL96:
 1416 0762 C20F      		add r28,r18
 1417 0764 D31F      		adc r29,r19
 1418 0766 F901      		movw r30,r18
 1419               	.LVL97:
 1420 0768 37FD      		sbrc r19,7
 1421 076a 3396      		adiw r30,3
 1422               	.L89:
 1423 076c F595      		asr r31
 1424 076e E795      		ror r30
 1425 0770 F595      		asr r31
 1426 0772 E795      		ror r30
 1427 0774 EC0F      		add r30,r28
 1428 0776 FD1F      		adc r31,r29
 1429 0778 C901      		movw r24,r18
 1430 077a 6CE9      		ldi r22,lo8(-100)
 1431 077c 7FEF      		ldi r23,lo8(-1)
 1432 077e 0E94 0000 		call __divmodhi4
 1433 0782 E60F      		add r30,r22
 1434 0784 F71F      		adc r31,r23
 1435 0786 C901      		movw r24,r18
 1436 0788 60E9      		ldi r22,lo8(-112)
 1437 078a 71E0      		ldi r23,lo8(1)
 1438 078c 0E94 0000 		call __divmodhi4
 1439 0790 E60F      		add r30,r22
 1440 0792 F71F      		adc r31,r23
 1441 0794 CF01      		movw r24,r30
 1442 0796 67E0      		ldi r22,lo8(7)
 1443 0798 70E0      		ldi r23,0
 1444 079a 0E94 0000 		call __divmodhi4
 1445               	/* epilogue start */
2220:switcherator.c **** }
 1446               		.loc 1 2220 0
 1447 079e DF91      		pop r29
 1448 07a0 CF91      		pop r28
 1449 07a2 0895      		ret
 1450               	.LFE52:
 1452               		.section	.rodata
 1453               	.LC0:
 1454 0000 0000      		.word	0
 1455 0002 1F00      		.word	31
 1456 0004 1C00      		.word	28
 1457 0006 1F00      		.word	31
 1458 0008 1E00      		.word	30
 1459 000a 1F00      		.word	31
 1460 000c 1E00      		.word	30
 1461 000e 1F00      		.word	31
 1462 0010 1F00      		.word	31
 1463 0012 1E00      		.word	30
 1464 0014 1F00      		.word	31
 1465 0016 1E00      		.word	30
 1466               		.text
 1467               	.global	getDayofYear
 1469               	getDayofYear:
 1470               	.LFB53:
2221:switcherator.c **** 
2222:switcherator.c **** // returns the day of the year (1 - 365 or 366)
2223:switcherator.c **** 
2224:switcherator.c **** int getDayofYear(int year, int month, int day) {
 1471               		.loc 1 2224 0
 1472               	.LVL98:
 1473 07a4 CF93      		push r28
 1474               	.LCFI33:
 1475 07a6 DF93      		push r29
 1476               	.LCFI34:
 1477 07a8 CDB7      		in r28,__SP_L__
 1478 07aa DEB7      		in r29,__SP_H__
 1479               	.LCFI35:
 1480 07ac 6897      		sbiw r28,24
 1481               	.LCFI36:
 1482 07ae 0FB6      		in __tmp_reg__,__SREG__
 1483 07b0 F894      		cli
 1484 07b2 DEBF      		out __SP_H__,r29
 1485 07b4 0FBE      		out __SREG__,__tmp_reg__
 1486 07b6 CDBF      		out __SP_L__,r28
 1487               	/* prologue: function */
 1488               	/* frame size = 24 */
 1489               	/* stack size = 26 */
 1490               	.L__stack_usage = 26
2225:switcherator.c ****     int months[12] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30};
 1491               		.loc 1 2225 0
 1492 07b8 28E1      		ldi r18,lo8(24)
 1493 07ba E0E0      		ldi r30,lo8(.LC0)
 1494 07bc F0E0      		ldi r31,hi8(.LC0)
 1495 07be DE01      		movw r26,r28
 1496 07c0 1196      		adiw r26,1
 1497               		0:
 1498 07c2 0190      		ld r0,Z+
 1499 07c4 0D92      		st X+,r0
 1500 07c6 2A95      		dec r18
 1501 07c8 01F4      		brne 0b
 1502               	.LVL99:
2226:switcherator.c ****     int x = 0;
2227:switcherator.c ****     // adjust feb for leap year
2228:switcherator.c ****     if ((year % 4) == 0)
 1503               		.loc 1 2228 0
 1504 07ca 8370      		andi r24,3
 1505 07cc 9927      		clr r25
 1506               	.LVL100:
 1507 07ce 892B      		or r24,r25
 1508 07d0 01F4      		brne .L91
2229:switcherator.c ****         months[3] = 29;
 1509               		.loc 1 2229 0
 1510 07d2 8DE1      		ldi r24,lo8(29)
 1511 07d4 90E0      		ldi r25,0
 1512 07d6 9887      		std Y+8,r25
 1513 07d8 8F83      		std Y+7,r24
 1514               	.L91:
 1515               	.LVL101:
 1516 07da FE01      		movw r30,r28
 1517 07dc 3196      		adiw r30,1
2230:switcherator.c ****     // start with the day of the month, then add amounts for each month
2231:switcherator.c ****     int doy = day;
 1518               		.loc 1 2231 0
 1519 07de 9A01      		movw r18,r20
2232:switcherator.c ****     for (x = 0; x < month; x++) {
 1520               		.loc 1 2232 0
 1521 07e0 80E0      		ldi r24,0
 1522 07e2 90E0      		ldi r25,0
 1523 07e4 00C0      		rjmp .L92
 1524               	.LVL102:
 1525               	.L93:
2233:switcherator.c ****         doy += months[x];
 1526               		.loc 1 2233 0 discriminator 2
 1527 07e6 4191      		ld r20,Z+
 1528 07e8 5191      		ld r21,Z+
 1529 07ea 240F      		add r18,r20
 1530 07ec 351F      		adc r19,r21
 1531               	.LVL103:
2232:switcherator.c ****     for (x = 0; x < month; x++) {
 1532               		.loc 1 2232 0 discriminator 2
 1533 07ee 0196      		adiw r24,1
 1534               	.LVL104:
 1535               	.L92:
2232:switcherator.c ****     for (x = 0; x < month; x++) {
 1536               		.loc 1 2232 0 is_stmt 0 discriminator 1
 1537 07f0 8617      		cp r24,r22
 1538 07f2 9707      		cpc r25,r23
 1539 07f4 04F0      		brlt .L93
2234:switcherator.c ****     }
2235:switcherator.c ****     return doy;
2236:switcherator.c **** }
 1540               		.loc 1 2236 0 is_stmt 1
 1541 07f6 C901      		movw r24,r18
 1542               	.LVL105:
 1543               	/* epilogue start */
 1544 07f8 6896      		adiw r28,24
 1545 07fa 0FB6      		in __tmp_reg__,__SREG__
 1546 07fc F894      		cli
 1547 07fe DEBF      		out __SP_H__,r29
 1548 0800 0FBE      		out __SREG__,__tmp_reg__
 1549 0802 CDBF      		out __SP_L__,r28
 1550 0804 DF91      		pop r29
 1551 0806 CF91      		pop r28
 1552 0808 0895      		ret
 1553               	.LFE53:
 1555               	.global	checkDaylightSavings
 1557               	checkDaylightSavings:
 1558               	.LFB55:
2237:switcherator.c **** 
2238:switcherator.c **** // Sets up the days we do daylight savings
2239:switcherator.c **** // DS:MMDD MMDD
2240:switcherator.c **** // 012345678901
2241:switcherator.c **** 
2242:switcherator.c **** void setDaylightSavings(char * commandReceived) {
2243:switcherator.c ****     int dlInt;
2244:switcherator.c ****     tempIntString[0] = commandReceived[3];
2245:switcherator.c ****     tempIntString[1] = commandReceived[4];
2246:switcherator.c ****     dlInt = atoi(tempIntString);
2247:switcherator.c ****     daylightSavings[0][0] = dlInt;
2248:switcherator.c ****     tempIntString[0] = commandReceived[5];
2249:switcherator.c ****     tempIntString[1] = commandReceived[6];
2250:switcherator.c ****     dlInt = atoi(tempIntString);
2251:switcherator.c ****     daylightSavings[0][1] = dlInt;
2252:switcherator.c ****     tempIntString[0] = commandReceived[8];
2253:switcherator.c ****     tempIntString[1] = commandReceived[9];
2254:switcherator.c ****     dlInt = atoi(tempIntString);
2255:switcherator.c ****     daylightSavings[1][0] = dlInt;
2256:switcherator.c ****     tempIntString[0] = commandReceived[10];
2257:switcherator.c ****     tempIntString[1] = commandReceived[11];
2258:switcherator.c ****     dlInt = atoi(tempIntString);
2259:switcherator.c ****     daylightSavings[1][1] = dlInt;
2260:switcherator.c ****     ok();
2261:switcherator.c **** }
2262:switcherator.c **** 
2263:switcherator.c **** // Decide if this 3:00am is daylight savings and adjust accordingly
2264:switcherator.c **** 
2265:switcherator.c **** void checkDaylightSavings(void) {
 1559               		.loc 1 2265 0
 1560               	/* prologue: function */
 1561               	/* frame size = 0 */
 1562               	/* stack size = 0 */
 1563               	.L__stack_usage = 0
2266:switcherator.c ****     // have we adjusted for daylight savings?
2267:switcherator.c ****     if (wasDaylightSavings == 1)
 1564               		.loc 1 2267 0
 1565 080a 8091 0000 		lds r24,wasDaylightSavings
 1566 080e 8130      		cpi r24,lo8(1)
 1567 0810 01F0      		breq .L94
2268:switcherator.c ****         return;
2269:switcherator.c ****     if (globalMonth == daylightSavings[0][0] && globalDay == daylightSavings[0][1]) {
 1568               		.loc 1 2269 0
 1569 0812 8091 0000 		lds r24,globalMonth
 1570 0816 9091 0000 		lds r25,globalMonth+1
 1571 081a 2091 0000 		lds r18,daylightSavings
 1572 081e 3091 0000 		lds r19,daylightSavings+1
 1573 0822 8217      		cp r24,r18
 1574 0824 9307      		cpc r25,r19
 1575 0826 01F4      		brne .L96
 1576               		.loc 1 2269 0 is_stmt 0 discriminator 1
 1577 0828 4091 0000 		lds r20,globalDay
 1578 082c 5091 0000 		lds r21,globalDay+1
 1579 0830 2091 0000 		lds r18,daylightSavings+2
 1580 0834 3091 0000 		lds r19,daylightSavings+2+1
 1581 0838 4217      		cp r20,r18
 1582 083a 5307      		cpc r21,r19
 1583 083c 01F4      		brne .L96
2270:switcherator.c ****         wasDaylightSavings = 1;
 1584               		.loc 1 2270 0 is_stmt 1
 1585 083e 81E0      		ldi r24,lo8(1)
 1586 0840 8093 0000 		sts wasDaylightSavings,r24
2271:switcherator.c ****         globalHour++;
 1587               		.loc 1 2271 0
 1588 0844 8091 0000 		lds r24,globalHour
 1589 0848 9091 0000 		lds r25,globalHour+1
 1590 084c 0196      		adiw r24,1
 1591 084e 00C0      		rjmp .L100
 1592               	.L96:
2272:switcherator.c ****     } else if (globalMonth == daylightSavings[1][0] && globalDay == daylightSavings[1][1]) {
 1593               		.loc 1 2272 0
 1594 0850 2091 0000 		lds r18,daylightSavings+4
 1595 0854 3091 0000 		lds r19,daylightSavings+4+1
 1596 0858 8217      		cp r24,r18
 1597 085a 9307      		cpc r25,r19
 1598 085c 01F4      		brne .L94
 1599               		.loc 1 2272 0 is_stmt 0 discriminator 1
 1600 085e 2091 0000 		lds r18,globalDay
 1601 0862 3091 0000 		lds r19,globalDay+1
 1602 0866 8091 0000 		lds r24,daylightSavings+6
 1603 086a 9091 0000 		lds r25,daylightSavings+6+1
 1604 086e 2817      		cp r18,r24
 1605 0870 3907      		cpc r19,r25
 1606 0872 01F4      		brne .L94
2273:switcherator.c ****         wasDaylightSavings = 1;
 1607               		.loc 1 2273 0 is_stmt 1
 1608 0874 81E0      		ldi r24,lo8(1)
 1609 0876 8093 0000 		sts wasDaylightSavings,r24
2274:switcherator.c ****         globalHour--;
 1610               		.loc 1 2274 0
 1611 087a 8091 0000 		lds r24,globalHour
 1612 087e 9091 0000 		lds r25,globalHour+1
 1613 0882 0197      		sbiw r24,1
 1614               	.L100:
 1615 0884 9093 0000 		sts globalHour+1,r25
 1616 0888 8093 0000 		sts globalHour,r24
 1617               	.L94:
 1618 088c 0895      		ret
 1619               	.LFE55:
 1621               	.global	advanceDay
 1623               	advanceDay:
 1624               	.LFB56:
2275:switcherator.c ****     }
2276:switcherator.c **** }
2277:switcherator.c **** 
2278:switcherator.c **** // Advance a day in the calendar. 
2279:switcherator.c **** 
2280:switcherator.c **** void advanceDay(void) {
 1625               		.loc 1 2280 0
 1626               	/* prologue: function */
 1627               	/* frame size = 0 */
 1628               	/* stack size = 0 */
 1629               	.L__stack_usage = 0
 1630               	.LVL106:
2281:switcherator.c ****     int x = 0;
2282:switcherator.c ****     // Reset the daylight savings for next time
2283:switcherator.c ****     wasDaylightSavings = 0;
 1631               		.loc 1 2283 0
 1632 088e 1092 0000 		sts wasDaylightSavings,__zero_reg__
2284:switcherator.c ****     // start with dow
2285:switcherator.c ****     dow++;
 1633               		.loc 1 2285 0
 1634 0892 8091 0000 		lds r24,dow
 1635 0896 9091 0000 		lds r25,dow+1
 1636 089a 0196      		adiw r24,1
 1637 089c 9093 0000 		sts dow+1,r25
 1638 08a0 8093 0000 		sts dow,r24
2286:switcherator.c ****     if (dow == 7) {
 1639               		.loc 1 2286 0
 1640 08a4 0797      		sbiw r24,7
 1641 08a6 01F0      		breq .L102
 1642               	.LVL107:
 1643               	.L107:
2287:switcherator.c ****         // reset it to Sunday
2288:switcherator.c ****         dow = 0;
2289:switcherator.c ****         weeklySeconds = 0;
2290:switcherator.c ****         // switchStatus might be more than a week (604,800 seconds)
2291:switcherator.c ****         for (x = 0; x < NUM_SWITCHES; x++) {
2292:switcherator.c ****             if (switchStatus[x] >= 604800)
2293:switcherator.c ****                 switchStatus[x] -= 604800;
2294:switcherator.c ****         }
2295:switcherator.c ****     }
2296:switcherator.c ****     // then the day
2297:switcherator.c ****     globalDay++;
 1644               		.loc 1 2297 0
 1645 08a8 2091 0000 		lds r18,globalDay
 1646 08ac 3091 0000 		lds r19,globalDay+1
 1647 08b0 2F5F      		subi r18,-1
 1648 08b2 3F4F      		sbci r19,-1
 1649 08b4 3093 0000 		sts globalDay+1,r19
 1650 08b8 2093 0000 		sts globalDay,r18
2298:switcherator.c ****     // If we aren't advancing a month just move on
2299:switcherator.c ****     if (globalDay <= 28) {
 1651               		.loc 1 2299 0
 1652 08bc 2D31      		cpi r18,29
 1653 08be 3105      		cpc r19,__zero_reg__
 1654 08c0 00F4      		brsh .L140
 1655 08c2 0895      		ret
 1656               	.LVL108:
 1657               	.L102:
2288:switcherator.c ****         dow = 0;
 1658               		.loc 1 2288 0
 1659 08c4 1092 0000 		sts dow+1,__zero_reg__
 1660 08c8 1092 0000 		sts dow,__zero_reg__
2289:switcherator.c ****         weeklySeconds = 0;
 1661               		.loc 1 2289 0
 1662 08cc 1092 0000 		sts weeklySeconds,__zero_reg__
 1663 08d0 1092 0000 		sts weeklySeconds+1,__zero_reg__
 1664 08d4 1092 0000 		sts weeklySeconds+2,__zero_reg__
 1665 08d8 1092 0000 		sts weeklySeconds+3,__zero_reg__
 1666 08dc E0E0      		ldi r30,lo8(switchStatus)
 1667 08de F0E0      		ldi r31,hi8(switchStatus)
 1668               	.LVL109:
 1669               	.L106:
2292:switcherator.c ****             if (switchStatus[x] >= 604800)
 1670               		.loc 1 2292 0
 1671 08e0 8081      		ld r24,Z
 1672 08e2 9181      		ldd r25,Z+1
 1673 08e4 A281      		ldd r26,Z+2
 1674 08e6 B381      		ldd r27,Z+3
 1675 08e8 8038      		cpi r24,-128
 1676 08ea 2AE3      		ldi r18,58
 1677 08ec 9207      		cpc r25,r18
 1678 08ee 29E0      		ldi r18,9
 1679 08f0 A207      		cpc r26,r18
 1680 08f2 B105      		cpc r27,__zero_reg__
 1681 08f4 00F0      		brlo .L105
2293:switcherator.c ****                 switchStatus[x] -= 604800;
 1682               		.loc 1 2293 0
 1683 08f6 8058      		subi r24,-128
 1684 08f8 9A43      		sbci r25,58
 1685 08fa A940      		sbci r26,9
 1686 08fc B109      		sbc r27,__zero_reg__
 1687 08fe 8083      		st Z,r24
 1688 0900 9183      		std Z+1,r25
 1689 0902 A283      		std Z+2,r26
 1690 0904 B383      		std Z+3,r27
 1691               	.L105:
 1692 0906 3496      		adiw r30,4
2291:switcherator.c ****         for (x = 0; x < NUM_SWITCHES; x++) {
 1693               		.loc 1 2291 0
 1694 0908 80E0      		ldi r24,hi8(switchStatus+64)
 1695 090a E030      		cpi r30,lo8(switchStatus+64)
 1696 090c F807      		cpc r31,r24
 1697 090e 01F4      		brne .L106
 1698 0910 00C0      		rjmp .L107
 1699               	.L140:
2300:switcherator.c ****         return;
2301:switcherator.c ****     }
2302:switcherator.c ****     // possibly advancing a month
2303:switcherator.c ****     switch (globalMonth) {
 1700               		.loc 1 2303 0
 1701 0912 8091 0000 		lds r24,globalMonth
 1702 0916 9091 0000 		lds r25,globalMonth+1
 1703 091a 8630      		cpi r24,6
 1704 091c 9105      		cpc r25,__zero_reg__
 1705 091e 01F0      		breq .L110
 1706 0920 00F4      		brsh .L112
 1707 0922 8330      		cpi r24,3
 1708 0924 9105      		cpc r25,__zero_reg__
 1709 0926 01F0      		breq .L108
 1710 0928 00F4      		brsh .L113
 1711 092a 8130      		cpi r24,1
 1712 092c 9105      		cpc r25,__zero_reg__
 1713 092e 01F0      		breq .L108
 1714 0930 0297      		sbiw r24,2
 1715 0932 01F0      		breq .+2
 1716 0934 00C0      		rjmp .L101
 1717 0936 00C0      		rjmp .L109
 1718               	.L113:
 1719 0938 8430      		cpi r24,4
 1720 093a 9105      		cpc r25,__zero_reg__
 1721 093c 01F0      		breq .L110
 1722 093e 8530      		cpi r24,5
 1723 0940 9105      		cpc r25,__zero_reg__
 1724 0942 01F0      		breq .+2
 1725 0944 00C0      		rjmp .L101
 1726 0946 00C0      		rjmp .L108
 1727               	.L112:
 1728 0948 8930      		cpi r24,9
 1729 094a 9105      		cpc r25,__zero_reg__
 1730 094c 01F0      		breq .L110
 1731 094e 00F0      		brlo .L108
 1732 0950 8B30      		cpi r24,11
 1733 0952 9105      		cpc r25,__zero_reg__
 1734 0954 01F0      		breq .L110
 1735 0956 00F0      		brlo .L108
 1736 0958 0C97      		sbiw r24,12
 1737 095a 01F4      		brne .L101
 1738 095c 00C0      		rjmp .L111
 1739               	.L110:
2304:switcherator.c ****             // 30 days have september, april, june and november
2305:switcherator.c ****         case 4:
2306:switcherator.c ****         case 6:
2307:switcherator.c ****         case 9:
2308:switcherator.c ****         case 11:
2309:switcherator.c ****             if (globalDay > 30) {
 1740               		.loc 1 2309 0
 1741 095e 2F31      		cpi r18,31
 1742 0960 3105      		cpc r19,__zero_reg__
 1743 0962 00F0      		brlo .L101
 1744 0964 00C0      		rjmp .L142
 1745               	.L108:
2310:switcherator.c ****                 globalDay = 1;
2311:switcherator.c ****                 globalMonth++;
2312:switcherator.c ****             } else {
2313:switcherator.c ****                 return;
2314:switcherator.c ****             }
2315:switcherator.c ****             break;
2316:switcherator.c ****         case 1:
2317:switcherator.c ****         case 3:
2318:switcherator.c ****         case 5:
2319:switcherator.c ****         case 7:
2320:switcherator.c ****         case 8:
2321:switcherator.c ****         case 10:
2322:switcherator.c ****             if (globalDay > 31) {
 1746               		.loc 1 2322 0
 1747 0966 2032      		cpi r18,32
 1748 0968 3105      		cpc r19,__zero_reg__
 1749 096a 00F0      		brlo .L101
 1750               	.L142:
2323:switcherator.c ****                 globalDay = 1;
 1751               		.loc 1 2323 0
 1752 096c 21E0      		ldi r18,lo8(1)
 1753 096e 30E0      		ldi r19,0
 1754 0970 3093 0000 		sts globalDay+1,r19
 1755 0974 2093 0000 		sts globalDay,r18
2324:switcherator.c ****                 globalMonth++;
 1756               		.loc 1 2324 0
 1757 0978 0196      		adiw r24,1
 1758 097a 00C0      		rjmp .L141
 1759               	.L111:
2325:switcherator.c ****             } else {
2326:switcherator.c ****                 return;
2327:switcherator.c ****             }
2328:switcherator.c ****             break;
2329:switcherator.c ****         case 12:
2330:switcherator.c ****             if (globalDay > 31) {
 1760               		.loc 1 2330 0
 1761 097c 2032      		cpi r18,32
 1762 097e 3105      		cpc r19,__zero_reg__
 1763 0980 00F0      		brlo .L101
2331:switcherator.c ****                 // happy new year
2332:switcherator.c ****                 globalDay = 1;
 1764               		.loc 1 2332 0
 1765 0982 81E0      		ldi r24,lo8(1)
 1766 0984 90E0      		ldi r25,0
 1767 0986 9093 0000 		sts globalDay+1,r25
 1768 098a 8093 0000 		sts globalDay,r24
2333:switcherator.c ****                 globalMonth = 1;
 1769               		.loc 1 2333 0
 1770 098e 9093 0000 		sts globalMonth+1,r25
 1771 0992 8093 0000 		sts globalMonth,r24
2334:switcherator.c ****                 globalYear++;
 1772               		.loc 1 2334 0
 1773 0996 8091 0000 		lds r24,globalYear
 1774 099a 9091 0000 		lds r25,globalYear+1
 1775 099e 0196      		adiw r24,1
 1776 09a0 9093 0000 		sts globalYear+1,r25
 1777 09a4 8093 0000 		sts globalYear,r24
2335:switcherator.c ****             } else {
2336:switcherator.c ****                 return;
2337:switcherator.c ****             }
2338:switcherator.c ****             break;
 1778               		.loc 1 2338 0
 1779 09a8 0895      		ret
 1780               	.L109:
2339:switcherator.c ****         case 2:
2340:switcherator.c ****             // leap year?
2341:switcherator.c ****             if (globalYear % 4 == 0) {
 1781               		.loc 1 2341 0
 1782 09aa 8091 0000 		lds r24,globalYear
 1783 09ae 9091 0000 		lds r25,globalYear+1
 1784 09b2 8370      		andi r24,3
 1785 09b4 9927      		clr r25
 1786 09b6 892B      		or r24,r25
 1787 09b8 01F4      		brne .L114
2342:switcherator.c ****                 // yes
2343:switcherator.c ****                 if (globalDay > 29) {
 1788               		.loc 1 2343 0
 1789 09ba 2D31      		cpi r18,29
 1790 09bc 3105      		cpc r19,__zero_reg__
 1791 09be 01F0      		breq .L101
 1792               	.L114:
2344:switcherator.c ****                     globalDay = 1;
2345:switcherator.c ****                     globalMonth++;
2346:switcherator.c ****                 } else {
2347:switcherator.c ****                     return;
2348:switcherator.c ****                 }
2349:switcherator.c ****             } else {
2350:switcherator.c ****                 if (globalDay > 28) {
2351:switcherator.c ****                     globalDay = 1;
 1793               		.loc 1 2351 0
 1794 09c0 81E0      		ldi r24,lo8(1)
 1795 09c2 90E0      		ldi r25,0
 1796 09c4 9093 0000 		sts globalDay+1,r25
 1797 09c8 8093 0000 		sts globalDay,r24
2352:switcherator.c ****                     globalMonth++;
 1798               		.loc 1 2352 0
 1799 09cc 83E0      		ldi r24,lo8(3)
 1800 09ce 90E0      		ldi r25,0
 1801               	.L141:
 1802 09d0 9093 0000 		sts globalMonth+1,r25
 1803 09d4 8093 0000 		sts globalMonth,r24
 1804               	.L101:
 1805 09d8 0895      		ret
 1806               	.LFE56:
 1808               	.global	timerCheck
 1810               	timerCheck:
 1811               	.LFB57:
2353:switcherator.c ****                 } else {
2354:switcherator.c ****                     return;
2355:switcherator.c ****                 }
2356:switcherator.c ****             }
2357:switcherator.c ****             break;
2358:switcherator.c ****     }
2359:switcherator.c ****     return;
2360:switcherator.c **** }
2361:switcherator.c **** 
2362:switcherator.c **** // runs every second.  Checks to see if we need to turn something on or off
2363:switcherator.c **** 
2364:switcherator.c **** void timerCheck(void) {
 1812               		.loc 1 2364 0
 1813 09da 6F92      		push r6
 1814               	.LCFI37:
 1815 09dc 7F92      		push r7
 1816               	.LCFI38:
 1817 09de 8F92      		push r8
 1818               	.LCFI39:
 1819 09e0 9F92      		push r9
 1820               	.LCFI40:
 1821 09e2 AF92      		push r10
 1822               	.LCFI41:
 1823 09e4 BF92      		push r11
 1824               	.LCFI42:
 1825 09e6 CF92      		push r12
 1826               	.LCFI43:
 1827 09e8 DF92      		push r13
 1828               	.LCFI44:
 1829 09ea EF92      		push r14
 1830               	.LCFI45:
 1831 09ec FF92      		push r15
 1832               	.LCFI46:
 1833 09ee 0F93      		push r16
 1834               	.LCFI47:
 1835 09f0 1F93      		push r17
 1836               	.LCFI48:
 1837 09f2 CF93      		push r28
 1838               	.LCFI49:
 1839 09f4 DF93      		push r29
 1840               	.LCFI50:
 1841               	/* prologue: function */
 1842               	/* frame size = 0 */
 1843               	/* stack size = 14 */
 1844               	.L__stack_usage = 14
 1845               	.LVL110:
2365:switcherator.c ****     int x = 0;
2366:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
2367:switcherator.c ****         // see if something should turn off
2368:switcherator.c ****         if ((switchStatus[x] > 0) && (switchStatus[x] < weeklySeconds)) {
 1846               		.loc 1 2368 0
 1847 09f6 4091 0000 		lds r20,weeklySeconds
 1848 09fa 5091 0000 		lds r21,weeklySeconds+1
 1849 09fe 6091 0000 		lds r22,weeklySeconds+2
 1850 0a02 7091 0000 		lds r23,weeklySeconds+3
 1851 0a06 2091 0000 		lds r18,switchChanged
 1852 0a0a E0E0      		ldi r30,lo8(switchStatus)
 1853 0a0c F0E0      		ldi r31,hi8(switchStatus)
 1854               	.LVL111:
 1855               	.L145:
 1856 0a0e 8081      		ld r24,Z
 1857 0a10 9181      		ldd r25,Z+1
 1858 0a12 A281      		ldd r26,Z+2
 1859 0a14 B381      		ldd r27,Z+3
 1860 0a16 0097      		sbiw r24,0
 1861 0a18 A105      		cpc r26,__zero_reg__
 1862 0a1a B105      		cpc r27,__zero_reg__
 1863 0a1c 01F0      		breq .L144
 1864               		.loc 1 2368 0 is_stmt 0 discriminator 1
 1865 0a1e 8417      		cp r24,r20
 1866 0a20 9507      		cpc r25,r21
 1867 0a22 A607      		cpc r26,r22
 1868 0a24 B707      		cpc r27,r23
 1869 0a26 00F4      		brsh .L144
2369:switcherator.c ****             switchChanged = 1;
2370:switcherator.c ****             switchStatus[x] = 0;
 1870               		.loc 1 2370 0 is_stmt 1
 1871 0a28 1082      		st Z,__zero_reg__
 1872 0a2a 1182      		std Z+1,__zero_reg__
 1873 0a2c 1282      		std Z+2,__zero_reg__
 1874 0a2e 1382      		std Z+3,__zero_reg__
2369:switcherator.c ****             switchChanged = 1;
 1875               		.loc 1 2369 0
 1876 0a30 21E0      		ldi r18,lo8(1)
 1877               	.L144:
 1878 0a32 3496      		adiw r30,4
2366:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 1879               		.loc 1 2366 0
 1880 0a34 80E0      		ldi r24,hi8(switchStatus+64)
 1881 0a36 E030      		cpi r30,lo8(switchStatus+64)
 1882 0a38 F807      		cpc r31,r24
 1883 0a3a 01F4      		brne .L145
 1884 0a3c 2093 0000 		sts switchChanged,r18
 1885 0a40 C0E0      		ldi r28,lo8(weeklyProgram+4)
 1886 0a42 D0E0      		ldi r29,hi8(weeklyProgram+4)
 1887 0a44 00E0      		ldi r16,0
 1888 0a46 10E0      		ldi r17,0
2371:switcherator.c ****         }
2372:switcherator.c ****     }
2373:switcherator.c ****     // see if something should turn on
2374:switcherator.c ****     // weeklyProgram format
2375:switcherator.c ****     // DssddSSSSP
2376:switcherator.c ****     // 0123456789
2377:switcherator.c ****     long time;
2378:switcherator.c ****     int today = 0;
2379:switcherator.c ****     int duration = 0;
2380:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
2381:switcherator.c ****         // check if there is a valid program
2382:switcherator.c ****         if (weeklyProgram[x][0] != 255 && weeklyProgram[x][1] != 255) { // yes
2383:switcherator.c ****             // see if it goes today
2384:switcherator.c ****             // if dow = 0 (sunday) the program stores this as 0x40 then down from there
2385:switcherator.c ****             today = (0x40 >> dow);
 1889               		.loc 1 2385 0
 1890 0a48 30E4      		ldi r19,lo8(64)
 1891 0a4a C32E      		mov r12,r19
 1892 0a4c D12C      		mov r13,__zero_reg__
 1893               	.L147:
2364:switcherator.c **** void timerCheck(void) {
 1894               		.loc 1 2364 0
 1895 0a4e FE01      		movw r30,r28
 1896 0a50 3497      		sbiw r30,4
2382:switcherator.c ****         if (weeklyProgram[x][0] != 255 && weeklyProgram[x][1] != 255) { // yes
 1897               		.loc 1 2382 0
 1898 0a52 8081      		ld r24,Z
 1899 0a54 8F3F      		cpi r24,lo8(-1)
 1900 0a56 01F4      		brne .+2
 1901 0a58 00C0      		rjmp .L146
2364:switcherator.c **** void timerCheck(void) {
 1902               		.loc 1 2364 0 discriminator 1
 1903 0a5a FE01      		movw r30,r28
 1904 0a5c 3397      		sbiw r30,3
2382:switcherator.c ****         if (weeklyProgram[x][0] != 255 && weeklyProgram[x][1] != 255) { // yes
 1905               		.loc 1 2382 0 discriminator 1
 1906 0a5e 2081      		ld r18,Z
 1907 0a60 2F3F      		cpi r18,lo8(-1)
 1908 0a62 01F4      		brne .+2
 1909 0a64 00C0      		rjmp .L146
 1910               		.loc 1 2385 0
 1911 0a66 7090 0000 		lds r7,dow
 1912 0a6a 6090 0000 		lds r6,dow+1
 1913               	.LVL112:
2386:switcherator.c ****             // k is today the day?
2387:switcherator.c ****             if (weeklyProgram[x][0] & today) {
 1914               		.loc 1 2387 0
 1915 0a6e 90E0      		ldi r25,0
2385:switcherator.c ****             today = (0x40 >> dow);
 1916               		.loc 1 2385 0
 1917 0a70 A601      		movw r20,r12
 1918 0a72 072C      		mov r0,r7
 1919 0a74 00C0      		rjmp 2f
 1920               		1:
 1921 0a76 5595      		asr r21
 1922 0a78 4795      		ror r20
 1923               		2:
 1924 0a7a 0A94      		dec r0
 1925 0a7c 02F4      		brpl 1b
 1926               		.loc 1 2387 0
 1927 0a7e 8423      		and r24,r20
 1928 0a80 9523      		and r25,r21
 1929 0a82 892B      		or r24,r25
 1930 0a84 01F4      		brne .+2
 1931 0a86 00C0      		rjmp .L146
2388:switcherator.c **** 
2389:switcherator.c ****                 // yes we run today
2390:switcherator.c ****                 time = weeklyProgram[x][1];
 1932               		.loc 1 2390 0
 1933 0a88 822F      		mov r24,r18
 1934 0a8a 90E0      		ldi r25,0
 1935 0a8c A0E0      		ldi r26,0
 1936 0a8e B0E0      		ldi r27,0
 1937               	.LVL113:
2391:switcherator.c ****                 time <<= 8;
 1938               		.loc 1 2391 0
 1939 0a90 2227      		clr r18
 1940 0a92 382F      		mov r19,r24
 1941 0a94 492F      		mov r20,r25
 1942 0a96 5A2F      		mov r21,r26
 1943               	.LVL114:
2364:switcherator.c **** void timerCheck(void) {
 1944               		.loc 1 2364 0
 1945 0a98 FE01      		movw r30,r28
 1946 0a9a 3297      		sbiw r30,2
2392:switcherator.c ****                 time |= weeklyProgram[x][2];
 1947               		.loc 1 2392 0
 1948 0a9c 8081      		ld r24,Z
 1949 0a9e 282B      		or r18,r24
 1950               	.LVL115:
2393:switcherator.c ****                 // weeklyProgram is stored in minutes
2394:switcherator.c ****                 time *= 60;
 1951               		.loc 1 2394 0
 1952 0aa0 ACE3      		ldi r26,lo8(60)
 1953 0aa2 B0E0      		ldi r27,0
 1954 0aa4 0E94 0000 		call __muluhisi3
 1955 0aa8 4B01      		movw r8,r22
 1956 0aaa 5C01      		movw r10,r24
 1957               	.LVL116:
2364:switcherator.c **** void timerCheck(void) {
 1958               		.loc 1 2364 0
 1959 0aac FE01      		movw r30,r28
 1960 0aae 3197      		sbiw r30,1
2395:switcherator.c ****                 duration = weeklyProgram[x][3];
 1961               		.loc 1 2395 0
 1962 0ab0 F081      		ld r31,Z
 1963               	.LVL117:
2396:switcherator.c ****                 duration <<= 8;
2397:switcherator.c ****                 duration |= weeklyProgram[x][4];
 1964               		.loc 1 2397 0
 1965 0ab2 E881      		ld r30,Y
 1966               	.LVL118:
2398:switcherator.c ****                 time += (dow * 86400); //seconds in day
 1967               		.loc 1 2398 0
 1968 0ab4 A72D      		mov r26,r7
 1969 0ab6 B62D      		mov r27,r6
 1970 0ab8 20E8      		ldi r18,lo8(-128)
 1971 0aba 31E5      		ldi r19,lo8(81)
 1972 0abc 41E0      		ldi r20,lo8(1)
 1973 0abe 50E0      		ldi r21,0
 1974 0ac0 0E94 0000 		call __muluhisi3
 1975 0ac4 860E      		add r8,r22
 1976 0ac6 971E      		adc r9,r23
 1977 0ac8 A81E      		adc r10,r24
 1978 0aca B91E      		adc r11,r25
 1979               	.LVL119:
2399:switcherator.c ****                 // check if we are between start & stop time
2400:switcherator.c ****                 if ((weeklySeconds >= time) && (weeklySeconds < (time + duration))) {
 1980               		.loc 1 2400 0
 1981 0acc 4091 0000 		lds r20,weeklySeconds
 1982 0ad0 5091 0000 		lds r21,weeklySeconds+1
 1983 0ad4 6091 0000 		lds r22,weeklySeconds+2
 1984 0ad8 7091 0000 		lds r23,weeklySeconds+3
 1985 0adc 4815      		cp r20,r8
 1986 0ade 5905      		cpc r21,r9
 1987 0ae0 6A05      		cpc r22,r10
 1988 0ae2 7B05      		cpc r23,r11
 1989 0ae4 00F0      		brlo .L146
2396:switcherator.c ****                 duration <<= 8;
 1990               		.loc 1 2396 0 discriminator 1
 1991 0ae6 FF2E      		mov r15,r31
 1992 0ae8 E12C      		mov r14,__zero_reg__
2397:switcherator.c ****                 duration |= weeklyProgram[x][4];
 1993               		.loc 1 2397 0 discriminator 1
 1994 0aea C701      		movw r24,r14
 1995 0aec 8E2B      		or r24,r30
 1996               		.loc 1 2400 0 discriminator 1
 1997 0aee AA27      		clr r26
 1998 0af0 97FD      		sbrc r25,7
 1999 0af2 A095      		com r26
 2000 0af4 BA2F      		mov r27,r26
 2001 0af6 880D      		add r24,r8
 2002 0af8 991D      		adc r25,r9
 2003 0afa AA1D      		adc r26,r10
 2004 0afc BB1D      		adc r27,r11
 2005 0afe 4817      		cp r20,r24
 2006 0b00 5907      		cpc r21,r25
 2007 0b02 6A07      		cpc r22,r26
 2008 0b04 7B07      		cpc r23,r27
 2009 0b06 00F4      		brsh .L146
2401:switcherator.c ****                     // feed time to it so the end time won't change
2402:switcherator.c ****                     startTheProgram(x, 0, time);
 2010               		.loc 1 2402 0
 2011 0b08 A501      		movw r20,r10
 2012 0b0a 9401      		movw r18,r8
 2013 0b0c 60E0      		ldi r22,0
 2014 0b0e 70E0      		ldi r23,0
 2015 0b10 C801      		movw r24,r16
 2016 0b12 0E94 0000 		call startTheProgram
 2017               	.LVL120:
 2018               	.L146:
2380:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 2019               		.loc 1 2380 0
 2020 0b16 0F5F      		subi r16,-1
 2021 0b18 1F4F      		sbci r17,-1
 2022               	.LVL121:
 2023 0b1a 2A96      		adiw r28,10
 2024 0b1c 0A30      		cpi r16,10
 2025 0b1e 1105      		cpc r17,__zero_reg__
 2026 0b20 01F0      		breq .+2
 2027 0b22 00C0      		rjmp .L147
 2028               	/* epilogue start */
2403:switcherator.c ****                 }
2404:switcherator.c ****             }
2405:switcherator.c ****         }
2406:switcherator.c ****     }
2407:switcherator.c **** }
 2029               		.loc 1 2407 0
 2030 0b24 DF91      		pop r29
 2031 0b26 CF91      		pop r28
 2032 0b28 1F91      		pop r17
 2033 0b2a 0F91      		pop r16
 2034               	.LVL122:
 2035 0b2c FF90      		pop r15
 2036 0b2e EF90      		pop r14
 2037 0b30 DF90      		pop r13
 2038 0b32 CF90      		pop r12
 2039 0b34 BF90      		pop r11
 2040 0b36 AF90      		pop r10
 2041 0b38 9F90      		pop r9
 2042 0b3a 8F90      		pop r8
 2043 0b3c 7F90      		pop r7
 2044 0b3e 6F90      		pop r6
 2045 0b40 0895      		ret
 2046               	.LFE57:
 2048               	.global	switchOnOff
 2050               	switchOnOff:
 2051               	.LFB58:
2408:switcherator.c **** 
2409:switcherator.c **** // iterate through the switches and turn them on or off
2410:switcherator.c **** 
2411:switcherator.c **** void switchOnOff(void) {
 2052               		.loc 1 2411 0
 2053 0b42 7F92      		push r7
 2054               	.LCFI51:
 2055 0b44 8F92      		push r8
 2056               	.LCFI52:
 2057 0b46 9F92      		push r9
 2058               	.LCFI53:
 2059 0b48 AF92      		push r10
 2060               	.LCFI54:
 2061 0b4a BF92      		push r11
 2062               	.LCFI55:
 2063 0b4c CF92      		push r12
 2064               	.LCFI56:
 2065 0b4e DF92      		push r13
 2066               	.LCFI57:
 2067 0b50 EF92      		push r14
 2068               	.LCFI58:
 2069 0b52 FF92      		push r15
 2070               	.LCFI59:
 2071 0b54 0F93      		push r16
 2072               	.LCFI60:
 2073 0b56 1F93      		push r17
 2074               	.LCFI61:
 2075 0b58 CF93      		push r28
 2076               	.LCFI62:
 2077 0b5a DF93      		push r29
 2078               	.LCFI63:
 2079 0b5c 00D0      		rcall .
 2080 0b5e 1F92      		push __zero_reg__
 2081               	.LCFI64:
 2082 0b60 CDB7      		in r28,__SP_L__
 2083 0b62 DEB7      		in r29,__SP_H__
 2084               	.LCFI65:
 2085               	/* prologue: function */
 2086               	/* frame size = 3 */
 2087               	/* stack size = 16 */
 2088               	.L__stack_usage = 16
 2089               	.LVL123:
 2090 0b64 10E0      		ldi r17,lo8(switchStuff)
 2091 0b66 812E      		mov r8,r17
 2092 0b68 10E0      		ldi r17,hi8(switchStuff)
 2093 0b6a 912E      		mov r9,r17
 2094 0b6c 00E0      		ldi r16,lo8(switchStatus)
 2095 0b6e C02E      		mov r12,r16
 2096 0b70 00E0      		ldi r16,hi8(switchStatus)
 2097 0b72 D02E      		mov r13,r16
2412:switcherator.c ****     char port[1];
2413:switcherator.c ****     char pin[1];
2414:switcherator.c ****     int realPin = 0;
2415:switcherator.c ****     int x = 0;
2416:switcherator.c ****     char direction[1];
2417:switcherator.c ****     volatile unsigned char *thisPort = 0;
 2098               		.loc 1 2417 0
 2099 0b74 00E0      		ldi r16,0
 2100 0b76 10E0      		ldi r17,0
2418:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 2101               		.loc 1 2418 0
 2102 0b78 E12C      		mov r14,__zero_reg__
 2103 0b7a F12C      		mov r15,__zero_reg__
2419:switcherator.c ****         // see if a switch is set up
2420:switcherator.c ****         if (switchStuff[x] != 255) {
2421:switcherator.c ****             // find out if this is pwm
2422:switcherator.c ****             if (switchStuff[x] >= 200 && switchStuff[x] <= 220) {
2423:switcherator.c ****                 // are we turning it on or off
2424:switcherator.c ****                 if (switchStatus[x] == 0) {
2425:switcherator.c ****                     // turning it off
2426:switcherator.c ****                     if (switchStuff[x] == 200) {
2427:switcherator.c ****                         Red = 0;
2428:switcherator.c ****                         Green = 0;
2429:switcherator.c ****                         Blue = 0;
2430:switcherator.c ****                     } else if (switchStuff[x] == 201) {
2431:switcherator.c ****                         Red = 0;
2432:switcherator.c ****                         Green = 0;
2433:switcherator.c ****                         Blue = 0;
2434:switcherator.c ****                         runHue = 0;
2435:switcherator.c ****                     } else if (switchStuff[x] == 202) {
2436:switcherator.c ****                         Red = 0;
2437:switcherator.c ****                         Green = 0;
2438:switcherator.c ****                         Blue = 0;
2439:switcherator.c ****                         runColorChanges = 0;
2440:switcherator.c ****                     } else if (switchStuff[x] == 212) {
2441:switcherator.c ****                         bright = oldBright;
2442:switcherator.c ****                     }
2443:switcherator.c ****                 } else {
2444:switcherator.c ****                     // turn it on
2445:switcherator.c ****                     // decide if it is a changing hue or static values
2446:switcherator.c ****                     if (switchStuff[x] == 200) {
2447:switcherator.c ****                         // even numbers are static colors;
2448:switcherator.c ****                         red = pwmValues[0];
2449:switcherator.c ****                         green = pwmValues[1];
2450:switcherator.c ****                         blue = pwmValues[2];
2451:switcherator.c ****                         red = red * bright / 16;
2452:switcherator.c ****                         green = green * bright / 16;
2453:switcherator.c ****                         blue = blue * bright / 16;
2454:switcherator.c ****                         Red = red;
2455:switcherator.c ****                         Green = green;
2456:switcherator.c ****                         Blue = blue;
2457:switcherator.c ****                     } else if (switchStuff[x] == 202) {
2458:switcherator.c ****                         runColorChanges = 1;
2459:switcherator.c ****                     } else if (switchStuff[x] == 212) {
2460:switcherator.c ****                         // change the brightness
2461:switcherator.c ****                         bright = switchBright[x];
2462:switcherator.c ****                     } else {
2463:switcherator.c ****                         // get the hue cycle going
2464:switcherator.c ****                         runHue = 1;
2465:switcherator.c ****                     }
2466:switcherator.c ****                 }
2467:switcherator.c ****                 continue;
2468:switcherator.c ****             }
2469:switcherator.c ****             // switch is set up. Get details
2470:switcherator.c ****             getPort(x, port, pin, direction);
2471:switcherator.c ****             // yeah pointers and casts and whatevers. this fixes it
2472:switcherator.c ****             realPin = pin[0];
2473:switcherator.c ****             if (port[0] == 'B')
2474:switcherator.c ****                 thisPort = &PORTB;
2475:switcherator.c **** #ifdef PORTA
2476:switcherator.c ****             else if (port[0] == 'A')
2477:switcherator.c ****                 thisPort = &PORTA;
2478:switcherator.c **** #endif
2479:switcherator.c **** #ifdef PORTC
2480:switcherator.c ****             else if (port[0] == 'C')
2481:switcherator.c ****                 thisPort = &PORTC;
2482:switcherator.c **** #endif
2483:switcherator.c **** #ifdef PORTD
2484:switcherator.c ****             else if (port[0] == 'D')
2485:switcherator.c ****                 thisPort = &PORTD;
2486:switcherator.c **** #endif
2487:switcherator.c **** #ifdef PORTE
2488:switcherator.c ****             else if (port[0] == 'E')
2489:switcherator.c ****                 thisPort = &PORTE;
2490:switcherator.c **** #endif
2491:switcherator.c **** #ifdef PORTF
2492:switcherator.c ****             else if (port[0] == 'F')
2493:switcherator.c ****                 thisPort = &PORTF;
2494:switcherator.c **** #endif
2495:switcherator.c **** #ifdef PORTG
2496:switcherator.c ****             else if (port[0] == 'G')
2497:switcherator.c ****                 thisPort = &PORTG;
2498:switcherator.c **** #endif
2499:switcherator.c **** #ifdef PORTH
2500:switcherator.c ****             else if (port[0] == 'H')
2501:switcherator.c ****                 thisPort = &PORTH;
2502:switcherator.c **** #endif
2503:switcherator.c **** #ifdef PORTI
2504:switcherator.c ****             else if (port[0] == 'I')
2505:switcherator.c ****                 thisPort = &PORTI;
2506:switcherator.c **** #endif
2507:switcherator.c ****             // k we have the port - now decide if we are turning it on or off and turn it on/off
2508:switcherator.c ****             if (switchStatus[x] == 0) {
2509:switcherator.c ****                 // turning it off
2510:switcherator.c ****                 if (direction[0] == 0) {
2511:switcherator.c ****                     *thisPort |= (1 << realPin);
2512:switcherator.c ****                 } else {
2513:switcherator.c ****                     *thisPort &= ~(1 << realPin);
2514:switcherator.c ****                 }
2515:switcherator.c ****             } else {
2516:switcherator.c ****                 // turning it on
2517:switcherator.c ****                 if (direction[0] == 0) {
2518:switcherator.c ****                     *thisPort &= ~(1 << realPin);
2519:switcherator.c ****                 } else {
2520:switcherator.c ****                     *thisPort |= (1 << realPin);
 2104               		.loc 1 2520 0
 2105 0b7c AA24      		clr r10
 2106 0b7e A394      		inc r10
 2107 0b80 B12C      		mov r11,__zero_reg__
2464:switcherator.c ****                         runHue = 1;
 2108               		.loc 1 2464 0
 2109 0b82 7724      		clr r7
 2110 0b84 7394      		inc r7
 2111               	.LVL124:
 2112               	.L176:
2420:switcherator.c ****         if (switchStuff[x] != 255) {
 2113               		.loc 1 2420 0
 2114 0b86 F401      		movw r30,r8
 2115 0b88 2191      		ld r18,Z+
 2116 0b8a 4F01      		movw r8,r30
 2117 0b8c 2F3F      		cpi r18,lo8(-1)
 2118 0b8e 01F4      		brne .+2
 2119 0b90 00C0      		rjmp .L163
2422:switcherator.c ****             if (switchStuff[x] >= 200 && switchStuff[x] <= 220) {
 2120               		.loc 1 2422 0
 2121 0b92 822F      		mov r24,r18
 2122 0b94 885C      		subi r24,lo8(-(56))
 2123 0b96 8531      		cpi r24,lo8(21)
 2124 0b98 00F0      		brlo .+2
 2125 0b9a 00C0      		rjmp .L164
2424:switcherator.c ****                 if (switchStatus[x] == 0) {
 2126               		.loc 1 2424 0
 2127 0b9c F601      		movw r30,r12
 2128 0b9e 8081      		ld r24,Z
 2129 0ba0 9181      		ldd r25,Z+1
 2130 0ba2 A281      		ldd r26,Z+2
 2131 0ba4 B381      		ldd r27,Z+3
 2132 0ba6 892B      		or r24,r25
 2133 0ba8 8A2B      		or r24,r26
 2134 0baa 8B2B      		or r24,r27
 2135 0bac 01F4      		brne .L165
2426:switcherator.c ****                     if (switchStuff[x] == 200) {
 2136               		.loc 1 2426 0
 2137 0bae 283C      		cpi r18,lo8(-56)
 2138 0bb0 01F4      		brne .L166
2427:switcherator.c ****                         Red = 0;
 2139               		.loc 1 2427 0
 2140 0bb2 1092 B400 		sts 180,__zero_reg__
2428:switcherator.c ****                         Green = 0;
 2141               		.loc 1 2428 0
 2142 0bb6 18BC      		out 0x28,__zero_reg__
2429:switcherator.c ****                         Blue = 0;
 2143               		.loc 1 2429 0
 2144 0bb8 17BC      		out 0x27,__zero_reg__
 2145 0bba 00C0      		rjmp .L163
 2146               	.L166:
2430:switcherator.c ****                     } else if (switchStuff[x] == 201) {
 2147               		.loc 1 2430 0
 2148 0bbc 293C      		cpi r18,lo8(-55)
 2149 0bbe 01F4      		brne .L167
2431:switcherator.c ****                         Red = 0;
 2150               		.loc 1 2431 0
 2151 0bc0 1092 B400 		sts 180,__zero_reg__
2432:switcherator.c ****                         Green = 0;
 2152               		.loc 1 2432 0
 2153 0bc4 18BC      		out 0x28,__zero_reg__
2433:switcherator.c ****                         Blue = 0;
 2154               		.loc 1 2433 0
 2155 0bc6 17BC      		out 0x27,__zero_reg__
2434:switcherator.c ****                         runHue = 0;
 2156               		.loc 1 2434 0
 2157 0bc8 1092 0000 		sts runHue,__zero_reg__
 2158 0bcc 00C0      		rjmp .L163
 2159               	.L167:
2435:switcherator.c ****                     } else if (switchStuff[x] == 202) {
 2160               		.loc 1 2435 0
 2161 0bce 2A3C      		cpi r18,lo8(-54)
 2162 0bd0 01F4      		brne .L168
2436:switcherator.c ****                         Red = 0;
 2163               		.loc 1 2436 0
 2164 0bd2 1092 B400 		sts 180,__zero_reg__
2437:switcherator.c ****                         Green = 0;
 2165               		.loc 1 2437 0
 2166 0bd6 18BC      		out 0x28,__zero_reg__
2438:switcherator.c ****                         Blue = 0;
 2167               		.loc 1 2438 0
 2168 0bd8 17BC      		out 0x27,__zero_reg__
2439:switcherator.c ****                         runColorChanges = 0;
 2169               		.loc 1 2439 0
 2170 0bda 1092 0000 		sts runColorChanges,__zero_reg__
 2171 0bde 00C0      		rjmp .L163
 2172               	.L168:
2440:switcherator.c ****                     } else if (switchStuff[x] == 212) {
 2173               		.loc 1 2440 0
 2174 0be0 243D      		cpi r18,lo8(-44)
 2175 0be2 01F0      		breq .+2
 2176 0be4 00C0      		rjmp .L163
2441:switcherator.c ****                         bright = oldBright;
 2177               		.loc 1 2441 0
 2178 0be6 8091 0000 		lds r24,oldBright
 2179 0bea 00C0      		rjmp .L184
 2180               	.L165:
2446:switcherator.c ****                     if (switchStuff[x] == 200) {
 2181               		.loc 1 2446 0
 2182 0bec 283C      		cpi r18,lo8(-56)
 2183 0bee 01F4      		brne .L169
2449:switcherator.c ****                         green = pwmValues[1];
 2184               		.loc 1 2449 0
 2185 0bf0 8091 0000 		lds r24,pwmValues+1
2450:switcherator.c ****                         blue = pwmValues[2];
 2186               		.loc 1 2450 0
 2187 0bf4 E091 0000 		lds r30,pwmValues+2
2451:switcherator.c ****                         red = red * bright / 16;
 2188               		.loc 1 2451 0
 2189 0bf8 6091 0000 		lds r22,bright
 2190 0bfc 7091 0000 		lds r23,bright+1
2448:switcherator.c ****                         red = pwmValues[0];
 2191               		.loc 1 2448 0
 2192 0c00 9091 0000 		lds r25,pwmValues
2451:switcherator.c ****                         red = red * bright / 16;
 2193               		.loc 1 2451 0
 2194 0c04 969F      		mul r25,r22
 2195 0c06 A001      		movw r20,r0
 2196 0c08 979F      		mul r25,r23
 2197 0c0a 500D      		add r21,r0
 2198 0c0c 1124      		clr __zero_reg__
 2199 0c0e F4E0      		ldi r31,4
 2200               		1:
 2201 0c10 5695      		lsr r21
 2202 0c12 4795      		ror r20
 2203 0c14 FA95      		dec r31
 2204 0c16 01F4      		brne 1b
 2205 0c18 5093 0000 		sts red+1,r21
 2206 0c1c 4093 0000 		sts red,r20
2452:switcherator.c ****                         green = green * bright / 16;
 2207               		.loc 1 2452 0
 2208 0c20 869F      		mul r24,r22
 2209 0c22 9001      		movw r18,r0
 2210 0c24 879F      		mul r24,r23
 2211 0c26 300D      		add r19,r0
 2212 0c28 1124      		clr __zero_reg__
 2213 0c2a A4E0      		ldi r26,4
 2214               		1:
 2215 0c2c 3695      		lsr r19
 2216 0c2e 2795      		ror r18
 2217 0c30 AA95      		dec r26
 2218 0c32 01F4      		brne 1b
 2219 0c34 3093 0000 		sts green+1,r19
 2220 0c38 2093 0000 		sts green,r18
2453:switcherator.c ****                         blue = blue * bright / 16;
 2221               		.loc 1 2453 0
 2222 0c3c E69F      		mul r30,r22
 2223 0c3e C001      		movw r24,r0
 2224 0c40 E79F      		mul r30,r23
 2225 0c42 900D      		add r25,r0
 2226 0c44 1124      		clr __zero_reg__
 2227 0c46 B4E0      		ldi r27,4
 2228               		1:
 2229 0c48 9695      		lsr r25
 2230 0c4a 8795      		ror r24
 2231 0c4c BA95      		dec r27
 2232 0c4e 01F4      		brne 1b
 2233 0c50 9093 0000 		sts blue+1,r25
 2234 0c54 8093 0000 		sts blue,r24
2454:switcherator.c ****                         Red = red;
 2235               		.loc 1 2454 0
 2236 0c58 4093 B400 		sts 180,r20
2455:switcherator.c ****                         Green = green;
 2237               		.loc 1 2455 0
 2238 0c5c 28BD      		out 0x28,r18
2456:switcherator.c ****                         Blue = blue;
 2239               		.loc 1 2456 0
 2240 0c5e 87BD      		out 0x27,r24
 2241 0c60 00C0      		rjmp .L163
 2242               	.L169:
2457:switcherator.c ****                     } else if (switchStuff[x] == 202) {
 2243               		.loc 1 2457 0
 2244 0c62 2A3C      		cpi r18,lo8(-54)
 2245 0c64 01F4      		brne .L170
2458:switcherator.c ****                         runColorChanges = 1;
 2246               		.loc 1 2458 0
 2247 0c66 7092 0000 		sts runColorChanges,r7
 2248 0c6a 00C0      		rjmp .L163
 2249               	.L170:
2459:switcherator.c ****                     } else if (switchStuff[x] == 212) {
 2250               		.loc 1 2459 0
 2251 0c6c 243D      		cpi r18,lo8(-44)
 2252 0c6e 01F4      		brne .L171
2411:switcherator.c **** void switchOnOff(void) {
 2253               		.loc 1 2411 0
 2254 0c70 F701      		movw r30,r14
 2255 0c72 E050      		subi r30,lo8(-(switchBright))
 2256 0c74 F040      		sbci r31,hi8(-(switchBright))
2461:switcherator.c ****                         bright = switchBright[x];
 2257               		.loc 1 2461 0
 2258 0c76 8081      		ld r24,Z
 2259               	.L184:
 2260 0c78 8093 0000 		sts bright,r24
 2261 0c7c 1092 0000 		sts bright+1,__zero_reg__
 2262 0c80 00C0      		rjmp .L163
 2263               	.L171:
2464:switcherator.c ****                         runHue = 1;
 2264               		.loc 1 2464 0
 2265 0c82 7092 0000 		sts runHue,r7
 2266 0c86 00C0      		rjmp .L163
 2267               	.L164:
2470:switcherator.c ****             getPort(x, port, pin, direction);
 2268               		.loc 1 2470 0
 2269 0c88 9E01      		movw r18,r28
 2270 0c8a 2F5F      		subi r18,-1
 2271 0c8c 3F4F      		sbci r19,-1
 2272 0c8e AE01      		movw r20,r28
 2273 0c90 4E5F      		subi r20,-2
 2274 0c92 5F4F      		sbci r21,-1
 2275 0c94 BE01      		movw r22,r28
 2276 0c96 6D5F      		subi r22,-3
 2277 0c98 7F4F      		sbci r23,-1
 2278 0c9a C701      		movw r24,r14
 2279 0c9c 0E94 0000 		call getPort
 2280               	.LVL125:
2472:switcherator.c ****             realPin = pin[0];
 2281               		.loc 1 2472 0
 2282 0ca0 2A81      		ldd r18,Y+2
2473:switcherator.c ****             if (port[0] == 'B')
 2283               		.loc 1 2473 0
 2284 0ca2 8B81      		ldd r24,Y+3
 2285 0ca4 8234      		cpi r24,lo8(66)
 2286 0ca6 01F0      		breq .L177
2480:switcherator.c ****             else if (port[0] == 'C')
 2287               		.loc 1 2480 0
 2288 0ca8 8334      		cpi r24,lo8(67)
 2289 0caa 01F0      		breq .L178
2484:switcherator.c ****             else if (port[0] == 'D')
 2290               		.loc 1 2484 0
 2291 0cac 8434      		cpi r24,lo8(68)
 2292 0cae 01F4      		brne .L172
 2293 0cb0 00C0      		rjmp .L179
 2294               	.L177:
2474:switcherator.c ****                 thisPort = &PORTB;
 2295               		.loc 1 2474 0
 2296 0cb2 05E2      		ldi r16,lo8(37)
 2297 0cb4 10E0      		ldi r17,0
 2298 0cb6 00C0      		rjmp .L172
 2299               	.L178:
2481:switcherator.c ****                 thisPort = &PORTC;
 2300               		.loc 1 2481 0
 2301 0cb8 08E2      		ldi r16,lo8(40)
 2302 0cba 10E0      		ldi r17,0
 2303 0cbc 00C0      		rjmp .L172
 2304               	.L179:
2485:switcherator.c ****                 thisPort = &PORTD;
 2305               		.loc 1 2485 0
 2306 0cbe 0BE2      		ldi r16,lo8(43)
 2307 0cc0 10E0      		ldi r17,0
 2308               	.L172:
 2309               	.LVL126:
2508:switcherator.c ****             if (switchStatus[x] == 0) {
 2310               		.loc 1 2508 0
 2311 0cc2 F601      		movw r30,r12
 2312 0cc4 8081      		ld r24,Z
 2313 0cc6 9181      		ldd r25,Z+1
 2314 0cc8 A281      		ldd r26,Z+2
 2315 0cca B381      		ldd r27,Z+3
 2316 0ccc 3981      		ldd r19,Y+1
2511:switcherator.c ****                     *thisPort |= (1 << realPin);
 2317               		.loc 1 2511 0
 2318 0cce F801      		movw r30,r16
2508:switcherator.c ****             if (switchStatus[x] == 0) {
 2319               		.loc 1 2508 0
 2320 0cd0 892B      		or r24,r25
 2321 0cd2 8A2B      		or r24,r26
 2322 0cd4 8B2B      		or r24,r27
 2323 0cd6 01F4      		brne .L173
2510:switcherator.c ****                 if (direction[0] == 0) {
 2324               		.loc 1 2510 0
 2325 0cd8 3111      		cpse r19,__zero_reg__
 2326 0cda 00C0      		rjmp .L186
 2327 0cdc 00C0      		rjmp .L175
 2328               	.L173:
2517:switcherator.c ****                 if (direction[0] == 0) {
 2329               		.loc 1 2517 0
 2330 0cde 3111      		cpse r19,__zero_reg__
 2331 0ce0 00C0      		rjmp .L175
 2332               	.L186:
2518:switcherator.c ****                     *thisPort &= ~(1 << realPin);
 2333               		.loc 1 2518 0
 2334 0ce2 3081      		ld r19,Z
 2335 0ce4 C501      		movw r24,r10
 2336 0ce6 022E      		mov r0,r18
 2337 0ce8 00C0      		rjmp 2f
 2338               		1:
 2339 0cea 880F      		lsl r24
 2340               		2:
 2341 0cec 0A94      		dec r0
 2342 0cee 02F4      		brpl 1b
 2343 0cf0 8095      		com r24
 2344 0cf2 3823      		and r19,r24
 2345 0cf4 00C0      		rjmp .L185
 2346               	.L175:
 2347               		.loc 1 2520 0
 2348 0cf6 3081      		ld r19,Z
 2349 0cf8 C501      		movw r24,r10
 2350 0cfa 022E      		mov r0,r18
 2351 0cfc 00C0      		rjmp 2f
 2352               		1:
 2353 0cfe 880F      		lsl r24
 2354               		2:
 2355 0d00 0A94      		dec r0
 2356 0d02 02F4      		brpl 1b
 2357 0d04 382B      		or r19,r24
 2358               	.L185:
 2359 0d06 3083      		st Z,r19
 2360               	.LVL127:
 2361               	.L163:
2418:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 2362               		.loc 1 2418 0
 2363 0d08 FFEF      		ldi r31,-1
 2364 0d0a EF1A      		sub r14,r31
 2365 0d0c FF0A      		sbc r15,r31
 2366               	.LVL128:
 2367 0d0e 84E0      		ldi r24,4
 2368 0d10 C80E      		add r12,r24
 2369 0d12 D11C      		adc r13,__zero_reg__
 2370 0d14 E0E1      		ldi r30,16
 2371 0d16 EE16      		cp r14,r30
 2372 0d18 F104      		cpc r15,__zero_reg__
 2373 0d1a 01F0      		breq .+2
 2374 0d1c 00C0      		rjmp .L176
 2375               	/* epilogue start */
2521:switcherator.c ****                 }
2522:switcherator.c ****             }
2523:switcherator.c ****         }
2524:switcherator.c ****     }
2525:switcherator.c **** }
 2376               		.loc 1 2525 0
 2377 0d1e 0F90      		pop __tmp_reg__
 2378 0d20 0F90      		pop __tmp_reg__
 2379 0d22 0F90      		pop __tmp_reg__
 2380 0d24 DF91      		pop r29
 2381 0d26 CF91      		pop r28
 2382 0d28 1F91      		pop r17
 2383 0d2a 0F91      		pop r16
 2384               	.LVL129:
 2385 0d2c FF90      		pop r15
 2386 0d2e EF90      		pop r14
 2387               	.LVL130:
 2388 0d30 DF90      		pop r13
 2389 0d32 CF90      		pop r12
 2390 0d34 BF90      		pop r11
 2391 0d36 AF90      		pop r10
 2392 0d38 9F90      		pop r9
 2393 0d3a 8F90      		pop r8
 2394 0d3c 7F90      		pop r7
 2395 0d3e 0895      		ret
 2396               	.LFE58:
 2398               		.section	.rodata.str1.1,"aMS",@progbits,1
 2399               	.LC1:
 2400 0000 3000      		.string	"0"
 2401               		.text
 2402               	.global	returnInt
 2404               	returnInt:
 2405               	.LFB62:
2526:switcherator.c **** 
2527:switcherator.c **** // sets the time limits for switches to affect progams
2528:switcherator.c **** // TL:##HHMMHHMMddddddd
2529:switcherator.c **** // 01234567890123456789
2530:switcherator.c **** 
2531:switcherator.c **** void setTimeLimits(char * commandReceived) {
2532:switcherator.c ****     char tempReallyLongString[] = "0000000";
2533:switcherator.c ****     int programNumber = 0;
2534:switcherator.c ****     long weekLong = 0;
2535:switcherator.c ****     long startTime = 0;
2536:switcherator.c ****     long stopTime = 0;
2537:switcherator.c ****     int x = 0;
2538:switcherator.c ****     statusMsg[0] = 0;
2539:switcherator.c ****     unsigned int startHour, startMinute, stopHour, stopMinute;
2540:switcherator.c ****     tempIntString[0] = commandReceived[3];
2541:switcherator.c ****     tempIntString[1] = commandReceived[4];
2542:switcherator.c ****     programNumber = atoi(tempIntString);
2543:switcherator.c ****     if (programNumber > NUM_LIMITS) {
2544:switcherator.c ****         fail(0x10);
2545:switcherator.c ****         return;
2546:switcherator.c ****     }
2547:switcherator.c ****     if (commandReceived[5] == 'x' || commandReceived[5] == 'x') {
2548:switcherator.c ****         timeLimits[programNumber][2] = 0;
2549:switcherator.c ****         ok();
2550:switcherator.c ****         return;
2551:switcherator.c ****     }
2552:switcherator.c ****     if (commandReceived[5] == '?') {
2553:switcherator.c ****         // show the limit.
2554:switcherator.c ****         startTime = timeLimits[programNumber][0];
2555:switcherator.c ****         stopTime = timeLimits[programNumber][1];
2556:switcherator.c ****         strcat(statusMsg, "Start:");
2557:switcherator.c ****         startHour = (startTime / 60 / 60);
2558:switcherator.c ****         returnInt(startHour, tempLongString);
2559:switcherator.c ****         strcat(statusMsg, tempLongString);
2560:switcherator.c ****         startMinute = ((startTime - (startHour * 60 * 60)) / 60);
2561:switcherator.c ****         strcat(statusMsg, ":");
2562:switcherator.c ****         returnInt(startMinute, tempLongString);
2563:switcherator.c ****         strcat(statusMsg, tempLongString);
2564:switcherator.c ****         strcat(statusMsg, "Stop:");
2565:switcherator.c ****         stopHour = (startTime / 60 / 60);
2566:switcherator.c ****         returnInt(stopHour, tempLongString);
2567:switcherator.c ****         strcat(statusMsg, tempLongString);
2568:switcherator.c ****         stopMinute = ((startTime - (stopHour * 60 * 60)) / 60);
2569:switcherator.c ****         strcat(statusMsg, ":");
2570:switcherator.c ****         returnInt(stopMinute, tempLongString);
2571:switcherator.c ****         strcat(statusMsg, tempLongString);
2572:switcherator.c ****         sendMessage(statusMsg);
2573:switcherator.c ****         return;
2574:switcherator.c ****     }
2575:switcherator.c ****     for (x = 0; x < 7; x++) {
2576:switcherator.c ****         tempReallyLongString[x] = commandReceived[x + 13];
2577:switcherator.c ****     }
2578:switcherator.c ****     weekLong = strtol(tempReallyLongString, 0, 2);
2579:switcherator.c ****     tempIntString[0] = commandReceived[5];
2580:switcherator.c ****     tempIntString[1] = commandReceived[6];
2581:switcherator.c ****     startHour = atoi(tempIntString);
2582:switcherator.c ****     tempIntString[0] = commandReceived[7];
2583:switcherator.c ****     tempIntString[1] = commandReceived[8];
2584:switcherator.c ****     startMinute = atoi(tempIntString);
2585:switcherator.c ****     tempIntString[0] = commandReceived[9];
2586:switcherator.c ****     tempIntString[1] = commandReceived[10];
2587:switcherator.c ****     stopHour = atoi(tempIntString);
2588:switcherator.c ****     tempIntString[0] = commandReceived[11];
2589:switcherator.c ****     tempIntString[1] = commandReceived[12];
2590:switcherator.c ****     stopMinute = atoi(tempIntString);
2591:switcherator.c ****     if (startHour > 23 || stopHour > 23) {
2592:switcherator.c ****         fail(0x09);
2593:switcherator.c ****         return;
2594:switcherator.c ****     }
2595:switcherator.c ****     if (startMinute > 59 || stopMinute > 59) {
2596:switcherator.c ****         fail(0x0A);
2597:switcherator.c ****         return;
2598:switcherator.c ****     }
2599:switcherator.c ****     startTime = startHour;
2600:switcherator.c ****     startTime = startTime * 60 * 60;
2601:switcherator.c ****     startTime += (startMinute * 60);
2602:switcherator.c ****     stopTime = stopHour;
2603:switcherator.c ****     stopTime = stopTime * 60 * 60;
2604:switcherator.c ****     stopTime += (stopMinute * 60);
2605:switcherator.c ****     timeLimits[programNumber][0] = startTime;
2606:switcherator.c ****     timeLimits[programNumber][1] = stopTime;
2607:switcherator.c ****     timeLimits[programNumber][2] = weekLong;
2608:switcherator.c ****     ok();
2609:switcherator.c **** 
2610:switcherator.c **** }
2611:switcherator.c **** 
2612:switcherator.c **** // take in 3 digits to tweak the clock time
2613:switcherator.c **** // CT xxxx
2614:switcherator.c **** 
2615:switcherator.c **** void clockTweak(char * commandReceived) {
2616:switcherator.c ****     int x = 0;
2617:switcherator.c ****     for (x = 0; x < 4; x++) {
2618:switcherator.c ****         tempLongString[x] = commandReceived[(x + 3)];
2619:switcherator.c ****     }
2620:switcherator.c ****     int adjustment = atoi(tempLongString);
2621:switcherator.c ****     if (adjustment == 0) {
2622:switcherator.c ****         itoa(tweakTimer, tempLongString, 10);
2623:switcherator.c ****         statusMsg[0] = 0;
2624:switcherator.c ****         strcat(statusMsg, "Curr Tweak:");
2625:switcherator.c ****         strcat(statusMsg, tempLongString);
2626:switcherator.c ****         sendMessage(statusMsg);
2627:switcherator.c ****         return;
2628:switcherator.c ****     }
2629:switcherator.c ****     tweakTimer += adjustment;
2630:switcherator.c ****     ok();
2631:switcherator.c **** }
2632:switcherator.c **** 
2633:switcherator.c **** /****************************************************************
2634:switcherator.c ****  *
2635:switcherator.c ****  *              All Things debug and output Related
2636:switcherator.c ****  *
2637:switcherator.c ****  ****************************************************************/
2638:switcherator.c **** 
2639:switcherator.c **** 
2640:switcherator.c **** 
2641:switcherator.c **** 
2642:switcherator.c **** 
2643:switcherator.c **** 
2644:switcherator.c **** // sends a general status
2645:switcherator.c **** // designed for radio but useful otherwise
2646:switcherator.c **** 
2647:switcherator.c **** void generalStatus(char * commandReceived) {
2648:switcherator.c ****     statusMsg[0] = 0;
2649:switcherator.c ****     int x = 0;
2650:switcherator.c ****     tempIntString[0] = commandReceived[2];
2651:switcherator.c ****     tempIntString[1] = commandReceived[3];
2652:switcherator.c ****     int switchNumber = 0;
2653:switcherator.c ****     switchNumber = atoi(tempIntString);
2654:switcherator.c ****     if (switchNumber > 0 || commandReceived[2] == '0') {
2655:switcherator.c ****         strcat(statusMsg, "weekly0x");
2656:switcherator.c ****         ltoa(weeklySeconds, tempLongString, 16);
2657:switcherator.c ****         strcat(statusMsg, tempLongString);
2658:switcherator.c ****         strcat(statusMsg, " Sw0x");
2659:switcherator.c ****         ltoa(switchStatus[switchNumber], tempLongString, 16);
2660:switcherator.c ****         strcat(statusMsg, tempLongString);
2661:switcherator.c ****         strcat(statusMsg, " SS ");
2662:switcherator.c ****         itoa(switchStuff[switchNumber], tempLongString, 10);
2663:switcherator.c ****         strcat(statusMsg, tempLongString);
2664:switcherator.c ****         sendMessage(statusMsg);
2665:switcherator.c ****         statusMsg[0] = 0;
2666:switcherator.c ****     }
2667:switcherator.c **** 
2668:switcherator.c ****     strcat(statusMsg, "S#");
2669:switcherator.c ****     int serialLength = 0;
2670:switcherator.c ****     //since a 0 serial number is not valid that means to return the serial number
2671:switcherator.c ****     serialLength = strlen(stringSerial);
2672:switcherator.c ****     while (serialLength < 6) {
2673:switcherator.c ****         strcat(statusMsg, "0");
2674:switcherator.c ****         serialLength++;
2675:switcherator.c ****     }
2676:switcherator.c ****     strcat(statusMsg, stringSerial);
2677:switcherator.c **** 
2678:switcherator.c ****     if (panicMyClockIsNotSet == 1) {
2679:switcherator.c ****         strcat(statusMsg, " T:xx/xx/xxxx xx:xx:xx");
2680:switcherator.c ****     } else {
2681:switcherator.c ****         strcat(statusMsg, " T:");
2682:switcherator.c ****         returnInt(globalMonth, tempLongString);
2683:switcherator.c ****         strcat(statusMsg, tempLongString);
2684:switcherator.c ****         strcat(statusMsg, "/");
2685:switcherator.c ****         returnInt(globalDay, tempLongString);
2686:switcherator.c ****         strcat(statusMsg, tempLongString);
2687:switcherator.c ****         strcat(statusMsg, "/");
2688:switcherator.c ****         returnInt(globalYear, tempLongString);
2689:switcherator.c ****         strcat(statusMsg, tempLongString);
2690:switcherator.c ****         strcat(statusMsg, " ");
2691:switcherator.c ****         returnInt(globalHour, tempLongString);
2692:switcherator.c ****         strcat(statusMsg, tempLongString);
2693:switcherator.c ****         strcat(statusMsg, ":");
2694:switcherator.c ****         returnInt(globalMinute, tempLongString);
2695:switcherator.c ****         strcat(statusMsg, tempLongString);
2696:switcherator.c ****         strcat(statusMsg, ":");
2697:switcherator.c ****         returnInt(globalSecond, tempLongString);
2698:switcherator.c ****         strcat(statusMsg, tempLongString);
2699:switcherator.c ****     }
2700:switcherator.c ****     sendMessage(statusMsg);
2701:switcherator.c ****     statusMsg[0] = 0;
2702:switcherator.c ****     if (commandReceived[2] == 'q')
2703:switcherator.c ****         return;
2704:switcherator.c ****     strcat(statusMsg, "Progs");
2705:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
2706:switcherator.c ****         returnInt(x, tempLongString);
2707:switcherator.c ****         strcat(statusMsg, tempLongString);
2708:switcherator.c ****         if (weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) {
2709:switcherator.c ****             strcat(statusMsg, "n");
2710:switcherator.c ****         } else {
2711:switcherator.c ****             strcat(statusMsg, "y");
2712:switcherator.c ****         }
2713:switcherator.c ****         // can only send 32 bytes at a time
2714:switcherator.c ****         if (strlen(statusMsg) > 24) {
2715:switcherator.c ****             sendMessage(statusMsg);
2716:switcherator.c ****             statusMsg[5] = 0;
2717:switcherator.c ****         }
2718:switcherator.c ****     }
2719:switcherator.c ****     sendMessage(statusMsg);
2720:switcherator.c ****     statusMsg[0] = 0;
2721:switcherator.c ****     strcat(statusMsg, "Sw");
2722:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
2723:switcherator.c ****         returnInt(x, tempLongString);
2724:switcherator.c ****         strcat(statusMsg, tempLongString);
2725:switcherator.c ****         if (switchStuff[x] == 255) {
2726:switcherator.c ****             strcat(statusMsg, "n");
2727:switcherator.c ****         } else {
2728:switcherator.c ****             strcat(statusMsg, "y");
2729:switcherator.c ****         }
2730:switcherator.c ****         // can only send 32 bytes at a time
2731:switcherator.c ****         if (strlen(statusMsg) > 24) {
2732:switcherator.c ****             sendMessage(statusMsg);
2733:switcherator.c ****             statusMsg[2] = 0;
2734:switcherator.c ****         }
2735:switcherator.c ****     }
2736:switcherator.c ****     sendMessage(statusMsg);
2737:switcherator.c ****     statusMsg[0] = 0;
2738:switcherator.c ****     strcat(statusMsg, "In");
2739:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
2740:switcherator.c ****         returnInt(x, tempLongString);
2741:switcherator.c ****         strcat(statusMsg, tempLongString);
2742:switcherator.c ****         if (inputs[x][0] == 255) {
2743:switcherator.c ****             strcat(statusMsg, "n");
2744:switcherator.c ****         } else {
2745:switcherator.c ****             strcat(statusMsg, "y");
2746:switcherator.c ****         }
2747:switcherator.c ****         // can only send 32 bytes at a time
2748:switcherator.c ****         if (x % 8 == 0 && x > 0) {
2749:switcherator.c ****             sendMessage(statusMsg);
2750:switcherator.c ****             statusMsg[2] = 0;
2751:switcherator.c ****         }
2752:switcherator.c ****     }
2753:switcherator.c ****     sendMessage(statusMsg);
2754:switcherator.c ****     statusMsg[0] = 0;
2755:switcherator.c ****     strcat(statusMsg, "SwOn?");
2756:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
2757:switcherator.c ****         returnInt(x, tempLongString);
2758:switcherator.c ****         strcat(statusMsg, tempLongString);
2759:switcherator.c ****         if (switchStatus[x] > 0) {
2760:switcherator.c ****             strcat(statusMsg, "y");
2761:switcherator.c ****         } else {
2762:switcherator.c ****             strcat(statusMsg, "n");
2763:switcherator.c ****         }
2764:switcherator.c ****         if (strlen(statusMsg) > 24) {
2765:switcherator.c ****             sendMessage(statusMsg);
2766:switcherator.c ****             statusMsg[5] = 0;
2767:switcherator.c ****         }
2768:switcherator.c ****     }
2769:switcherator.c ****     sendMessage(statusMsg);
2770:switcherator.c ****     statusMsg[0] = 0;
2771:switcherator.c **** }
2772:switcherator.c **** 
2773:switcherator.c **** void returnInt(int number, char * thisString) {
 2406               		.loc 1 2773 0
 2407               	.LVL131:
 2408 0d40 CF93      		push r28
 2409               	.LCFI66:
 2410 0d42 DF93      		push r29
 2411               	.LCFI67:
 2412               	/* prologue: function */
 2413               	/* frame size = 0 */
 2414               	/* stack size = 2 */
 2415               	.L__stack_usage = 2
 2416 0d44 EB01      		movw r28,r22
2774:switcherator.c ****     thisString[0] = 0;
 2417               		.loc 1 2774 0
 2418 0d46 1882      		st Y,__zero_reg__
2775:switcherator.c ****     itoa(number, tempHugeString, 10);
 2419               		.loc 1 2775 0
 2420 0d48 4AE0      		ldi r20,lo8(10)
 2421 0d4a 50E0      		ldi r21,0
 2422 0d4c 60E0      		ldi r22,lo8(tempHugeString)
 2423 0d4e 70E0      		ldi r23,hi8(tempHugeString)
 2424               	.LVL132:
 2425 0d50 0E94 0000 		call itoa
 2426               	.LVL133:
2776:switcherator.c ****     if (strlen(tempHugeString) == 1)
 2427               		.loc 1 2776 0
 2428 0d54 E0E0      		ldi r30,lo8(tempHugeString)
 2429 0d56 F0E0      		ldi r31,hi8(tempHugeString)
 2430               		0:
 2431 0d58 0190      		ld __tmp_reg__,Z+
 2432 0d5a 0020      		tst __tmp_reg__
 2433 0d5c 01F4      		brne 0b
 2434 0d5e E050      		subi r30,lo8(tempHugeString+2)
 2435 0d60 F040      		sbci r31,hi8(tempHugeString+2)
 2436 0d62 01F4      		brne .L188
2777:switcherator.c ****         strcat(thisString, "0");
 2437               		.loc 1 2777 0
 2438 0d64 60E0      		ldi r22,lo8(.LC1)
 2439 0d66 70E0      		ldi r23,hi8(.LC1)
 2440 0d68 CE01      		movw r24,r28
 2441 0d6a 0E94 0000 		call strcat
 2442               	.LVL134:
 2443               	.L188:
2778:switcherator.c ****     strcat(thisString, tempHugeString);
 2444               		.loc 1 2778 0
 2445 0d6e 60E0      		ldi r22,lo8(tempHugeString)
 2446 0d70 70E0      		ldi r23,hi8(tempHugeString)
 2447 0d72 CE01      		movw r24,r28
 2448               	/* epilogue start */
2779:switcherator.c **** }
 2449               		.loc 1 2779 0
 2450 0d74 DF91      		pop r29
 2451 0d76 CF91      		pop r28
 2452               	.LVL135:
2778:switcherator.c ****     strcat(thisString, tempHugeString);
 2453               		.loc 1 2778 0
 2454 0d78 0C94 0000 		jmp strcat
 2455               	.LVL136:
 2456               	.LFE62:
 2458               		.section	.rodata.str1.1
 2459               	.LC2:
 2460 0002 2000      		.string	" "
 2461               	.LC3:
 2462 0004 2F00      		.string	"/"
 2463               	.LC4:
 2464 0006 3A00      		.string	":"
 2465               		.text
 2466               	.global	clockString
 2468               	clockString:
 2469               	.LFB49:
2177:switcherator.c **** void clockString(void) {
 2470               		.loc 1 2177 0
 2471               	/* prologue: function */
 2472               	/* frame size = 0 */
 2473               	/* stack size = 0 */
 2474               	.L__stack_usage = 0
2178:switcherator.c ****     statusMsg[0] = 0;
 2475               		.loc 1 2178 0
 2476 0d7c 1092 0000 		sts statusMsg,__zero_reg__
2180:switcherator.c ****     strcat(statusMsg, " ");
 2477               		.loc 1 2180 0
 2478 0d80 60E0      		ldi r22,lo8(.LC2)
 2479 0d82 70E0      		ldi r23,hi8(.LC2)
 2480 0d84 80E0      		ldi r24,lo8(statusMsg)
 2481 0d86 90E0      		ldi r25,hi8(statusMsg)
 2482 0d88 0E94 0000 		call strcat
 2483               	.LVL137:
2181:switcherator.c ****     returnInt(globalMonth, tempIntString);
 2484               		.loc 1 2181 0
 2485 0d8c 60E0      		ldi r22,lo8(tempIntString)
 2486 0d8e 70E0      		ldi r23,hi8(tempIntString)
 2487 0d90 8091 0000 		lds r24,globalMonth
 2488 0d94 9091 0000 		lds r25,globalMonth+1
 2489 0d98 0E94 0000 		call returnInt
 2490               	.LVL138:
2182:switcherator.c ****     strcat(statusMsg, tempIntString);
 2491               		.loc 1 2182 0
 2492 0d9c 60E0      		ldi r22,lo8(tempIntString)
 2493 0d9e 70E0      		ldi r23,hi8(tempIntString)
 2494 0da0 80E0      		ldi r24,lo8(statusMsg)
 2495 0da2 90E0      		ldi r25,hi8(statusMsg)
 2496 0da4 0E94 0000 		call strcat
 2497               	.LVL139:
2183:switcherator.c ****     strcat(statusMsg, "/");
 2498               		.loc 1 2183 0
 2499 0da8 60E0      		ldi r22,lo8(.LC3)
 2500 0daa 70E0      		ldi r23,hi8(.LC3)
 2501 0dac 80E0      		ldi r24,lo8(statusMsg)
 2502 0dae 90E0      		ldi r25,hi8(statusMsg)
 2503 0db0 0E94 0000 		call strcat
 2504               	.LVL140:
2184:switcherator.c ****     returnInt(globalDay, tempIntString);
 2505               		.loc 1 2184 0
 2506 0db4 60E0      		ldi r22,lo8(tempIntString)
 2507 0db6 70E0      		ldi r23,hi8(tempIntString)
 2508 0db8 8091 0000 		lds r24,globalDay
 2509 0dbc 9091 0000 		lds r25,globalDay+1
 2510 0dc0 0E94 0000 		call returnInt
 2511               	.LVL141:
2185:switcherator.c ****     strcat(statusMsg, tempIntString);
 2512               		.loc 1 2185 0
 2513 0dc4 60E0      		ldi r22,lo8(tempIntString)
 2514 0dc6 70E0      		ldi r23,hi8(tempIntString)
 2515 0dc8 80E0      		ldi r24,lo8(statusMsg)
 2516 0dca 90E0      		ldi r25,hi8(statusMsg)
 2517 0dcc 0E94 0000 		call strcat
 2518               	.LVL142:
2186:switcherator.c ****     strcat(statusMsg, "/");
 2519               		.loc 1 2186 0
 2520 0dd0 60E0      		ldi r22,lo8(.LC3)
 2521 0dd2 70E0      		ldi r23,hi8(.LC3)
 2522 0dd4 80E0      		ldi r24,lo8(statusMsg)
 2523 0dd6 90E0      		ldi r25,hi8(statusMsg)
 2524 0dd8 0E94 0000 		call strcat
 2525               	.LVL143:
2187:switcherator.c ****     itoa(globalYear, tempIntString, 10);
 2526               		.loc 1 2187 0
 2527 0ddc 4AE0      		ldi r20,lo8(10)
 2528 0dde 50E0      		ldi r21,0
 2529 0de0 60E0      		ldi r22,lo8(tempIntString)
 2530 0de2 70E0      		ldi r23,hi8(tempIntString)
 2531 0de4 8091 0000 		lds r24,globalYear
 2532 0de8 9091 0000 		lds r25,globalYear+1
 2533 0dec 0E94 0000 		call itoa
 2534               	.LVL144:
2188:switcherator.c ****     strcat(statusMsg, tempIntString);
 2535               		.loc 1 2188 0
 2536 0df0 60E0      		ldi r22,lo8(tempIntString)
 2537 0df2 70E0      		ldi r23,hi8(tempIntString)
 2538 0df4 80E0      		ldi r24,lo8(statusMsg)
 2539 0df6 90E0      		ldi r25,hi8(statusMsg)
 2540 0df8 0E94 0000 		call strcat
 2541               	.LVL145:
2189:switcherator.c ****     strcat(statusMsg, " ");
 2542               		.loc 1 2189 0
 2543 0dfc 60E0      		ldi r22,lo8(.LC2)
 2544 0dfe 70E0      		ldi r23,hi8(.LC2)
 2545 0e00 80E0      		ldi r24,lo8(statusMsg)
 2546 0e02 90E0      		ldi r25,hi8(statusMsg)
 2547 0e04 0E94 0000 		call strcat
 2548               	.LVL146:
2190:switcherator.c ****     returnInt(globalHour, tempIntString);
 2549               		.loc 1 2190 0
 2550 0e08 60E0      		ldi r22,lo8(tempIntString)
 2551 0e0a 70E0      		ldi r23,hi8(tempIntString)
 2552 0e0c 8091 0000 		lds r24,globalHour
 2553 0e10 9091 0000 		lds r25,globalHour+1
 2554 0e14 0E94 0000 		call returnInt
 2555               	.LVL147:
2191:switcherator.c ****     strcat(statusMsg, tempIntString);
 2556               		.loc 1 2191 0
 2557 0e18 60E0      		ldi r22,lo8(tempIntString)
 2558 0e1a 70E0      		ldi r23,hi8(tempIntString)
 2559 0e1c 80E0      		ldi r24,lo8(statusMsg)
 2560 0e1e 90E0      		ldi r25,hi8(statusMsg)
 2561 0e20 0E94 0000 		call strcat
 2562               	.LVL148:
2192:switcherator.c ****     strcat(statusMsg, ":");
 2563               		.loc 1 2192 0
 2564 0e24 60E0      		ldi r22,lo8(.LC4)
 2565 0e26 70E0      		ldi r23,hi8(.LC4)
 2566 0e28 80E0      		ldi r24,lo8(statusMsg)
 2567 0e2a 90E0      		ldi r25,hi8(statusMsg)
 2568 0e2c 0E94 0000 		call strcat
 2569               	.LVL149:
2193:switcherator.c ****     returnInt(globalMinute, tempIntString);
 2570               		.loc 1 2193 0
 2571 0e30 60E0      		ldi r22,lo8(tempIntString)
 2572 0e32 70E0      		ldi r23,hi8(tempIntString)
 2573 0e34 8091 0000 		lds r24,globalMinute
 2574 0e38 9091 0000 		lds r25,globalMinute+1
 2575 0e3c 0E94 0000 		call returnInt
 2576               	.LVL150:
2194:switcherator.c ****     strcat(statusMsg, tempIntString);
 2577               		.loc 1 2194 0
 2578 0e40 60E0      		ldi r22,lo8(tempIntString)
 2579 0e42 70E0      		ldi r23,hi8(tempIntString)
 2580 0e44 80E0      		ldi r24,lo8(statusMsg)
 2581 0e46 90E0      		ldi r25,hi8(statusMsg)
 2582 0e48 0E94 0000 		call strcat
 2583               	.LVL151:
2195:switcherator.c ****     strcat(statusMsg, ":");
 2584               		.loc 1 2195 0
 2585 0e4c 60E0      		ldi r22,lo8(.LC4)
 2586 0e4e 70E0      		ldi r23,hi8(.LC4)
 2587 0e50 80E0      		ldi r24,lo8(statusMsg)
 2588 0e52 90E0      		ldi r25,hi8(statusMsg)
 2589 0e54 0E94 0000 		call strcat
 2590               	.LVL152:
2196:switcherator.c ****     returnInt(globalSecond, tempIntString);
 2591               		.loc 1 2196 0
 2592 0e58 60E0      		ldi r22,lo8(tempIntString)
 2593 0e5a 70E0      		ldi r23,hi8(tempIntString)
 2594 0e5c 8091 0000 		lds r24,globalSecond
 2595 0e60 9091 0000 		lds r25,globalSecond+1
 2596 0e64 0E94 0000 		call returnInt
 2597               	.LVL153:
2197:switcherator.c ****     strcat(statusMsg, tempIntString);
 2598               		.loc 1 2197 0
 2599 0e68 60E0      		ldi r22,lo8(tempIntString)
 2600 0e6a 70E0      		ldi r23,hi8(tempIntString)
 2601 0e6c 80E0      		ldi r24,lo8(statusMsg)
 2602 0e6e 90E0      		ldi r25,hi8(statusMsg)
 2603 0e70 0C94 0000 		jmp strcat
 2604               	.LVL154:
 2605               	.LFE49:
 2607               		.section	.rodata.str1.1
 2608               	.LC5:
 2609 0008 3078 00   		.string	"0x"
 2610               		.text
 2611               	.global	returnHex
 2613               	returnHex:
 2614               	.LFB63:
2780:switcherator.c **** 
2781:switcherator.c **** void returnHex(unsigned int number, char * thisString) {
 2615               		.loc 1 2781 0
 2616               	.LVL155:
 2617 0e74 0F93      		push r16
 2618               	.LCFI68:
 2619 0e76 1F93      		push r17
 2620               	.LCFI69:
 2621 0e78 CF93      		push r28
 2622               	.LCFI70:
 2623 0e7a DF93      		push r29
 2624               	.LCFI71:
 2625               	/* prologue: function */
 2626               	/* frame size = 0 */
 2627               	/* stack size = 4 */
 2628               	.L__stack_usage = 4
 2629 0e7c 8C01      		movw r16,r24
 2630 0e7e EB01      		movw r28,r22
2782:switcherator.c ****     thisString[0] = 0;
 2631               		.loc 1 2782 0
 2632 0e80 1882      		st Y,__zero_reg__
2783:switcherator.c ****     strcat(thisString, "0x");
 2633               		.loc 1 2783 0
 2634 0e82 60E0      		ldi r22,lo8(.LC5)
 2635 0e84 70E0      		ldi r23,hi8(.LC5)
 2636               	.LVL156:
 2637 0e86 CE01      		movw r24,r28
 2638               	.LVL157:
 2639 0e88 0E94 0000 		call strcat
 2640               	.LVL158:
2784:switcherator.c ****     itoa(number, tempHugeString, 16);
 2641               		.loc 1 2784 0
 2642 0e8c 40E1      		ldi r20,lo8(16)
 2643 0e8e 50E0      		ldi r21,0
 2644 0e90 60E0      		ldi r22,lo8(tempHugeString)
 2645 0e92 70E0      		ldi r23,hi8(tempHugeString)
 2646 0e94 C801      		movw r24,r16
 2647 0e96 0E94 0000 		call itoa
 2648               	.LVL159:
2785:switcherator.c ****     if (strlen(tempHugeString) == 1 || strlen(tempHugeString) == 3)
 2649               		.loc 1 2785 0
 2650 0e9a E0E0      		ldi r30,lo8(tempHugeString)
 2651 0e9c F0E0      		ldi r31,hi8(tempHugeString)
 2652               		0:
 2653 0e9e 0190      		ld __tmp_reg__,Z+
 2654 0ea0 0020      		tst __tmp_reg__
 2655 0ea2 01F4      		brne 0b
 2656 0ea4 3197      		sbiw r30,1
 2657 0ea6 E050      		subi r30,lo8(tempHugeString)
 2658 0ea8 F040      		sbci r31,hi8(tempHugeString)
 2659 0eaa E130      		cpi r30,1
 2660 0eac F105      		cpc r31,__zero_reg__
 2661 0eae 01F0      		breq .L191
 2662               		.loc 1 2785 0 is_stmt 0 discriminator 1
 2663 0eb0 3397      		sbiw r30,3
 2664 0eb2 01F4      		brne .L192
 2665               	.L191:
2786:switcherator.c ****         strcat(thisString, "0");
 2666               		.loc 1 2786 0 is_stmt 1
 2667 0eb4 60E0      		ldi r22,lo8(.LC1)
 2668 0eb6 70E0      		ldi r23,hi8(.LC1)
 2669 0eb8 CE01      		movw r24,r28
 2670 0eba 0E94 0000 		call strcat
 2671               	.LVL160:
 2672               	.L192:
2787:switcherator.c ****     strcat(thisString, tempHugeString);
 2673               		.loc 1 2787 0
 2674 0ebe 60E0      		ldi r22,lo8(tempHugeString)
 2675 0ec0 70E0      		ldi r23,hi8(tempHugeString)
 2676 0ec2 CE01      		movw r24,r28
 2677               	/* epilogue start */
2788:switcherator.c **** }
 2678               		.loc 1 2788 0
 2679 0ec4 DF91      		pop r29
 2680 0ec6 CF91      		pop r28
 2681               	.LVL161:
 2682 0ec8 1F91      		pop r17
 2683 0eca 0F91      		pop r16
 2684               	.LVL162:
2787:switcherator.c ****     strcat(thisString, tempHugeString);
 2685               		.loc 1 2787 0
 2686 0ecc 0C94 0000 		jmp strcat
 2687               	.LVL163:
 2688               	.LFE63:
 2690               	.global	returnHexWithout
 2692               	returnHexWithout:
 2693               	.LFB64:
2789:switcherator.c **** 
2790:switcherator.c **** 
2791:switcherator.c **** 
2792:switcherator.c **** // print hex without 0x
2793:switcherator.c **** 
2794:switcherator.c **** void returnHexWithout(unsigned int number, char * tempMe) {
 2694               		.loc 1 2794 0
 2695               	.LVL164:
 2696 0ed0 CF93      		push r28
 2697               	.LCFI72:
 2698 0ed2 DF93      		push r29
 2699               	.LCFI73:
 2700               	/* prologue: function */
 2701               	/* frame size = 0 */
 2702               	/* stack size = 2 */
 2703               	.L__stack_usage = 2
 2704 0ed4 EB01      		movw r28,r22
2795:switcherator.c ****     tempMe[0] = 0;
 2705               		.loc 1 2795 0
 2706 0ed6 1882      		st Y,__zero_reg__
2796:switcherator.c ****     itoa(number, tempHugeString, 16);
 2707               		.loc 1 2796 0
 2708 0ed8 40E1      		ldi r20,lo8(16)
 2709 0eda 50E0      		ldi r21,0
 2710 0edc 60E0      		ldi r22,lo8(tempHugeString)
 2711 0ede 70E0      		ldi r23,hi8(tempHugeString)
 2712               	.LVL165:
 2713 0ee0 0E94 0000 		call itoa
 2714               	.LVL166:
2797:switcherator.c ****     if (strlen(tempHugeString) == 1 || strlen(tempHugeString) == 3)
 2715               		.loc 1 2797 0
 2716 0ee4 E0E0      		ldi r30,lo8(tempHugeString)
 2717 0ee6 F0E0      		ldi r31,hi8(tempHugeString)
 2718               		0:
 2719 0ee8 0190      		ld __tmp_reg__,Z+
 2720 0eea 0020      		tst __tmp_reg__
 2721 0eec 01F4      		brne 0b
 2722 0eee 3197      		sbiw r30,1
 2723 0ef0 E050      		subi r30,lo8(tempHugeString)
 2724 0ef2 F040      		sbci r31,hi8(tempHugeString)
 2725 0ef4 E130      		cpi r30,1
 2726 0ef6 F105      		cpc r31,__zero_reg__
 2727 0ef8 01F0      		breq .L197
 2728               		.loc 1 2797 0 is_stmt 0 discriminator 1
 2729 0efa 3397      		sbiw r30,3
 2730 0efc 01F4      		brne .L198
 2731               	.L197:
2798:switcherator.c ****         strcat(tempMe, "0");
 2732               		.loc 1 2798 0 is_stmt 1
 2733 0efe 60E0      		ldi r22,lo8(.LC1)
 2734 0f00 70E0      		ldi r23,hi8(.LC1)
 2735 0f02 CE01      		movw r24,r28
 2736 0f04 0E94 0000 		call strcat
 2737               	.LVL167:
 2738               	.L198:
2799:switcherator.c ****     strcat(tempMe, tempHugeString);
 2739               		.loc 1 2799 0
 2740 0f08 60E0      		ldi r22,lo8(tempHugeString)
 2741 0f0a 70E0      		ldi r23,hi8(tempHugeString)
 2742 0f0c CE01      		movw r24,r28
 2743               	/* epilogue start */
2800:switcherator.c **** }
 2744               		.loc 1 2800 0
 2745 0f0e DF91      		pop r29
 2746 0f10 CF91      		pop r28
 2747               	.LVL168:
2799:switcherator.c ****     strcat(tempMe, tempHugeString);
 2748               		.loc 1 2799 0
 2749 0f12 0C94 0000 		jmp strcat
 2750               	.LVL169:
 2751               	.LFE64:
 2753               	.global	radioTest
 2755               	radioTest:
 2756               	.LFB66:
2801:switcherator.c **** 
2802:switcherator.c **** // Clock interrupt - fires when the compare is off
2803:switcherator.c **** 
2804:switcherator.c **** /****************************************************************
2805:switcherator.c ****  *
2806:switcherator.c ****  *              All Things Radio Related
2807:switcherator.c ****  *
2808:switcherator.c ****  ****************************************************************/
2809:switcherator.c **** 
2810:switcherator.c **** // initialize the radio
2811:switcherator.c **** 
2812:switcherator.c **** void radioInit(void) {
2813:switcherator.c ****     nrfInit();
2814:switcherator.c ****     rx_addr_p0 = SET_RX_ADDR_P0;
2815:switcherator.c ****     tx_addr = SET_TX_ADDR;
2816:switcherator.c ****     // use defaults the radio has
2817:switcherator.c ****     rx_addr_p1 = readAddr(RX_ADDR_P1);
2818:switcherator.c ****     rx_addr_p2 = readAddr(RX_ADDR_P2);
2819:switcherator.c ****     rx_addr_p3 = readAddr(RX_ADDR_P3);
2820:switcherator.c ****     rx_addr_p4 = readAddr(RX_ADDR_P4);
2821:switcherator.c ****     rx_addr_p5 = readAddr(RX_ADDR_P5);
2822:switcherator.c **** 
2823:switcherator.c ****     writeReg(RF_SETUP, SET_RF_SETUP);
2824:switcherator.c ****     writeAddr(RX_ADDR_P0, rx_addr_p0);
2825:switcherator.c ****     writeAddr(TX_ADDR, tx_addr);
2826:switcherator.c ****     writeReg(DYNPD, SET_DYNPD);
2827:switcherator.c ****     writeReg(FEATURE, SET_FEATURE);
2828:switcherator.c ****     writeReg(RF_CH, SET_RF_CH);
2829:switcherator.c ****     writeReg(CONFIG, SET_CONFIG);
2830:switcherator.c ****     writeReg(SETUP_RETR, SET_SETUP_RETR);
2831:switcherator.c **** 
2832:switcherator.c ****     // We've written the address - now see if we get the same result
2833:switcherator.c ****     radioTest();
2834:switcherator.c ****     
2835:switcherator.c ****     startRadio();
2836:switcherator.c **** 
2837:switcherator.c **** }
2838:switcherator.c **** 
2839:switcherator.c **** // radio test - just make sure it is still working
2840:switcherator.c **** int radioTest(void) {
 2757               		.loc 1 2840 0
 2758 0f16 AF92      		push r10
 2759               	.LCFI74:
 2760 0f18 BF92      		push r11
 2761               	.LCFI75:
 2762 0f1a CF92      		push r12
 2763               	.LCFI76:
 2764 0f1c DF92      		push r13
 2765               	.LCFI77:
 2766 0f1e EF92      		push r14
 2767               	.LCFI78:
 2768 0f20 FF92      		push r15
 2769               	.LCFI79:
 2770 0f22 0F93      		push r16
 2771               	.LCFI80:
 2772 0f24 1F93      		push r17
 2773               	.LCFI81:
 2774               	/* prologue: function */
 2775               	/* frame size = 0 */
 2776               	/* stack size = 8 */
 2777               	.L__stack_usage = 8
2841:switcherator.c ****     uint64_t test_addr;
2842:switcherator.c ****     test_addr = readAddr(RX_ADDR_P0);    
 2778               		.loc 1 2842 0
 2779 0f26 8AE0      		ldi r24,lo8(10)
 2780 0f28 0E94 0000 		call readAddr
 2781               	.LVL170:
2843:switcherator.c ****     if (test_addr != rx_addr_p0) {
 2782               		.loc 1 2843 0
 2783 0f2c A090 0000 		lds r10,rx_addr_p0
 2784 0f30 B090 0000 		lds r11,rx_addr_p0+1
 2785 0f34 C090 0000 		lds r12,rx_addr_p0+2
 2786 0f38 D090 0000 		lds r13,rx_addr_p0+3
 2787 0f3c E090 0000 		lds r14,rx_addr_p0+4
 2788 0f40 F090 0000 		lds r15,rx_addr_p0+5
 2789 0f44 0091 0000 		lds r16,rx_addr_p0+6
 2790 0f48 1091 0000 		lds r17,rx_addr_p0+7
 2791 0f4c 0E94 0000 		call __cmpdi2
 2792 0f50 01F0      		breq .L204
2844:switcherator.c ****         // nope.  broken
2845:switcherator.c ****         failCondition = 1;
 2793               		.loc 1 2845 0
 2794 0f52 81E0      		ldi r24,lo8(1)
 2795               	.LVL171:
 2796 0f54 8093 0000 		sts failCondition,r24
2846:switcherator.c ****         return -1;
 2797               		.loc 1 2846 0
 2798 0f58 2FEF      		ldi r18,lo8(-1)
 2799 0f5a 3FEF      		ldi r19,lo8(-1)
 2800 0f5c 00C0      		rjmp .L203
 2801               	.LVL172:
 2802               	.L204:
2847:switcherator.c ****     }
2848:switcherator.c ****     return 0;
 2803               		.loc 1 2848 0
 2804 0f5e 20E0      		ldi r18,0
 2805 0f60 30E0      		ldi r19,0
 2806               	.LVL173:
 2807               	.L203:
2849:switcherator.c **** }
 2808               		.loc 1 2849 0
 2809 0f62 C901      		movw r24,r18
 2810               	/* epilogue start */
 2811 0f64 1F91      		pop r17
 2812 0f66 0F91      		pop r16
 2813 0f68 FF90      		pop r15
 2814 0f6a EF90      		pop r14
 2815 0f6c DF90      		pop r13
 2816 0f6e CF90      		pop r12
 2817 0f70 BF90      		pop r11
 2818 0f72 AF90      		pop r10
 2819 0f74 0895      		ret
 2820               	.LFE66:
 2822               	.global	radioInit
 2824               	radioInit:
 2825               	.LFB65:
2812:switcherator.c **** void radioInit(void) {
 2826               		.loc 1 2812 0
 2827 0f76 0F93      		push r16
 2828               	.LCFI82:
 2829 0f78 1F93      		push r17
 2830               	.LCFI83:
 2831               	/* prologue: function */
 2832               	/* frame size = 0 */
 2833               	/* stack size = 2 */
 2834               	.L__stack_usage = 2
2813:switcherator.c ****     nrfInit();
 2835               		.loc 1 2813 0
 2836 0f7a 0E94 0000 		call nrfInit
 2837               	.LVL174:
2814:switcherator.c ****     rx_addr_p0 = SET_RX_ADDR_P0;
 2838               		.loc 1 2814 0
 2839 0f7e 92E0      		ldi r25,lo8(2)
 2840 0f80 9093 0000 		sts rx_addr_p0,r25
 2841 0f84 80EF      		ldi r24,lo8(-16)
 2842 0f86 8093 0000 		sts rx_addr_p0+1,r24
 2843 0f8a 8093 0000 		sts rx_addr_p0+2,r24
 2844 0f8e 8093 0000 		sts rx_addr_p0+3,r24
 2845 0f92 8093 0000 		sts rx_addr_p0+4,r24
 2846 0f96 1092 0000 		sts rx_addr_p0+5,__zero_reg__
 2847 0f9a 1092 0000 		sts rx_addr_p0+6,__zero_reg__
 2848 0f9e 1092 0000 		sts rx_addr_p0+7,__zero_reg__
2815:switcherator.c ****     tx_addr = SET_TX_ADDR;
 2849               		.loc 1 2815 0
 2850 0fa2 9093 0000 		sts tx_addr,r25
 2851 0fa6 8093 0000 		sts tx_addr+1,r24
 2852 0faa 8093 0000 		sts tx_addr+2,r24
 2853 0fae 8093 0000 		sts tx_addr+3,r24
 2854 0fb2 8093 0000 		sts tx_addr+4,r24
 2855 0fb6 1092 0000 		sts tx_addr+5,__zero_reg__
 2856 0fba 1092 0000 		sts tx_addr+6,__zero_reg__
 2857 0fbe 1092 0000 		sts tx_addr+7,__zero_reg__
2817:switcherator.c ****     rx_addr_p1 = readAddr(RX_ADDR_P1);
 2858               		.loc 1 2817 0
 2859 0fc2 8BE0      		ldi r24,lo8(11)
 2860 0fc4 0E94 0000 		call readAddr
 2861               	.LVL175:
 2862 0fc8 2093 0000 		sts rx_addr_p1,r18
 2863 0fcc 3093 0000 		sts rx_addr_p1+1,r19
 2864 0fd0 4093 0000 		sts rx_addr_p1+2,r20
 2865 0fd4 5093 0000 		sts rx_addr_p1+3,r21
 2866 0fd8 6093 0000 		sts rx_addr_p1+4,r22
 2867 0fdc 7093 0000 		sts rx_addr_p1+5,r23
 2868 0fe0 8093 0000 		sts rx_addr_p1+6,r24
 2869 0fe4 9093 0000 		sts rx_addr_p1+7,r25
2818:switcherator.c ****     rx_addr_p2 = readAddr(RX_ADDR_P2);
 2870               		.loc 1 2818 0
 2871 0fe8 8CE0      		ldi r24,lo8(12)
 2872 0fea 0E94 0000 		call readAddr
 2873               	.LVL176:
 2874 0fee 2093 0000 		sts rx_addr_p2,r18
 2875 0ff2 3093 0000 		sts rx_addr_p2+1,r19
 2876 0ff6 4093 0000 		sts rx_addr_p2+2,r20
 2877 0ffa 5093 0000 		sts rx_addr_p2+3,r21
 2878 0ffe 6093 0000 		sts rx_addr_p2+4,r22
 2879 1002 7093 0000 		sts rx_addr_p2+5,r23
 2880 1006 8093 0000 		sts rx_addr_p2+6,r24
 2881 100a 9093 0000 		sts rx_addr_p2+7,r25
2819:switcherator.c ****     rx_addr_p3 = readAddr(RX_ADDR_P3);
 2882               		.loc 1 2819 0
 2883 100e 8DE0      		ldi r24,lo8(13)
 2884 1010 0E94 0000 		call readAddr
 2885               	.LVL177:
 2886 1014 2093 0000 		sts rx_addr_p3,r18
 2887 1018 3093 0000 		sts rx_addr_p3+1,r19
 2888 101c 4093 0000 		sts rx_addr_p3+2,r20
 2889 1020 5093 0000 		sts rx_addr_p3+3,r21
 2890 1024 6093 0000 		sts rx_addr_p3+4,r22
 2891 1028 7093 0000 		sts rx_addr_p3+5,r23
 2892 102c 8093 0000 		sts rx_addr_p3+6,r24
 2893 1030 9093 0000 		sts rx_addr_p3+7,r25
2820:switcherator.c ****     rx_addr_p4 = readAddr(RX_ADDR_P4);
 2894               		.loc 1 2820 0
 2895 1034 8EE0      		ldi r24,lo8(14)
 2896 1036 0E94 0000 		call readAddr
 2897               	.LVL178:
 2898 103a 2093 0000 		sts rx_addr_p4,r18
 2899 103e 3093 0000 		sts rx_addr_p4+1,r19
 2900 1042 4093 0000 		sts rx_addr_p4+2,r20
 2901 1046 5093 0000 		sts rx_addr_p4+3,r21
 2902 104a 6093 0000 		sts rx_addr_p4+4,r22
 2903 104e 7093 0000 		sts rx_addr_p4+5,r23
 2904 1052 8093 0000 		sts rx_addr_p4+6,r24
 2905 1056 9093 0000 		sts rx_addr_p4+7,r25
2821:switcherator.c ****     rx_addr_p5 = readAddr(RX_ADDR_P5);
 2906               		.loc 1 2821 0
 2907 105a 8FE0      		ldi r24,lo8(15)
 2908 105c 0E94 0000 		call readAddr
 2909               	.LVL179:
 2910 1060 2093 0000 		sts rx_addr_p5,r18
 2911 1064 3093 0000 		sts rx_addr_p5+1,r19
 2912 1068 4093 0000 		sts rx_addr_p5+2,r20
 2913 106c 5093 0000 		sts rx_addr_p5+3,r21
 2914 1070 6093 0000 		sts rx_addr_p5+4,r22
 2915 1074 7093 0000 		sts rx_addr_p5+5,r23
 2916 1078 8093 0000 		sts rx_addr_p5+6,r24
 2917 107c 9093 0000 		sts rx_addr_p5+7,r25
2823:switcherator.c ****     writeReg(RF_SETUP, SET_RF_SETUP);
 2918               		.loc 1 2823 0
 2919 1080 66E0      		ldi r22,lo8(6)
 2920 1082 86E0      		ldi r24,lo8(6)
 2921 1084 0E94 0000 		call writeReg
 2922               	.LVL180:
2824:switcherator.c ****     writeAddr(RX_ADDR_P0, rx_addr_p0);
 2923               		.loc 1 2824 0
 2924 1088 0091 0000 		lds r16,rx_addr_p0
 2925 108c 1091 0000 		lds r17,rx_addr_p0+1
 2926 1090 2091 0000 		lds r18,rx_addr_p0+2
 2927 1094 3091 0000 		lds r19,rx_addr_p0+3
 2928 1098 4091 0000 		lds r20,rx_addr_p0+4
 2929 109c 5091 0000 		lds r21,rx_addr_p0+5
 2930 10a0 6091 0000 		lds r22,rx_addr_p0+6
 2931 10a4 7091 0000 		lds r23,rx_addr_p0+7
 2932 10a8 8AE0      		ldi r24,lo8(10)
 2933 10aa 0E94 0000 		call writeAddr
 2934               	.LVL181:
2825:switcherator.c ****     writeAddr(TX_ADDR, tx_addr);
 2935               		.loc 1 2825 0
 2936 10ae 0091 0000 		lds r16,tx_addr
 2937 10b2 1091 0000 		lds r17,tx_addr+1
 2938 10b6 2091 0000 		lds r18,tx_addr+2
 2939 10ba 3091 0000 		lds r19,tx_addr+3
 2940 10be 4091 0000 		lds r20,tx_addr+4
 2941 10c2 5091 0000 		lds r21,tx_addr+5
 2942 10c6 6091 0000 		lds r22,tx_addr+6
 2943 10ca 7091 0000 		lds r23,tx_addr+7
 2944 10ce 80E1      		ldi r24,lo8(16)
 2945 10d0 0E94 0000 		call writeAddr
 2946               	.LVL182:
2826:switcherator.c ****     writeReg(DYNPD, SET_DYNPD);
 2947               		.loc 1 2826 0
 2948 10d4 6FE3      		ldi r22,lo8(63)
 2949 10d6 8CE1      		ldi r24,lo8(28)
 2950 10d8 0E94 0000 		call writeReg
 2951               	.LVL183:
2827:switcherator.c ****     writeReg(FEATURE, SET_FEATURE);
 2952               		.loc 1 2827 0
 2953 10dc 64E0      		ldi r22,lo8(4)
 2954 10de 8DE1      		ldi r24,lo8(29)
 2955 10e0 0E94 0000 		call writeReg
 2956               	.LVL184:
2828:switcherator.c ****     writeReg(RF_CH, SET_RF_CH);
 2957               		.loc 1 2828 0
 2958 10e4 6AE2      		ldi r22,lo8(42)
 2959 10e6 85E0      		ldi r24,lo8(5)
 2960 10e8 0E94 0000 		call writeReg
 2961               	.LVL185:
2829:switcherator.c ****     writeReg(CONFIG, SET_CONFIG);
 2962               		.loc 1 2829 0
 2963 10ec 68E0      		ldi r22,lo8(8)
 2964 10ee 80E0      		ldi r24,0
 2965 10f0 0E94 0000 		call writeReg
 2966               	.LVL186:
2830:switcherator.c ****     writeReg(SETUP_RETR, SET_SETUP_RETR);
 2967               		.loc 1 2830 0
 2968 10f4 6FE0      		ldi r22,lo8(15)
 2969 10f6 84E0      		ldi r24,lo8(4)
 2970 10f8 0E94 0000 		call writeReg
 2971               	.LVL187:
2833:switcherator.c ****     radioTest();
 2972               		.loc 1 2833 0
 2973 10fc 0E94 0000 		call radioTest
 2974               	.LVL188:
 2975               	/* epilogue start */
2837:switcherator.c **** }
 2976               		.loc 1 2837 0
 2977 1100 1F91      		pop r17
 2978 1102 0F91      		pop r16
2835:switcherator.c ****     startRadio();
 2979               		.loc 1 2835 0
 2980 1104 0C94 0000 		jmp startRadio
 2981               	.LVL189:
 2982               	.LFE65:
 2984               	.global	formatAddress
 2986               	formatAddress:
 2987               	.LFB67:
2850:switcherator.c **** 
2851:switcherator.c **** // Take in an address and return a long long with the number
2852:switcherator.c **** 
2853:switcherator.c **** uint64_t formatAddress(char * address) {
 2988               		.loc 1 2853 0
 2989               	.LVL190:
 2990 1108 0F93      		push r16
 2991               	.LCFI84:
 2992 110a CF93      		push r28
 2993               	.LCFI85:
 2994               	/* prologue: function */
 2995               	/* frame size = 0 */
 2996               	/* stack size = 2 */
 2997               	.L__stack_usage = 2
 2998               	.LVL191:
 2999 110c DC01      		movw r26,r24
2854:switcherator.c ****     int x = 0;
2855:switcherator.c ****     uint64_t newAddress = 0;
 3000               		.loc 1 2855 0
 3001 110e 20E0      		ldi r18,0
 3002 1110 30E0      		ldi r19,0
 3003 1112 40E0      		ldi r20,0
 3004 1114 50E0      		ldi r21,0
 3005 1116 60E0      		ldi r22,0
 3006 1118 70E0      		ldi r23,0
 3007 111a 80E0      		ldi r24,0
 3008               	.LVL192:
 3009 111c 90E0      		ldi r25,0
2856:switcherator.c ****     int tempInt;
2857:switcherator.c ****     for (x = 0; x < 5; x++) {
 3010               		.loc 1 2857 0
 3011 111e E0E0      		ldi r30,0
 3012 1120 F0E0      		ldi r31,0
 3013               	.LVL193:
 3014               	.L209:
2858:switcherator.c ****         tempInt = address[x];
 3015               		.loc 1 2858 0
 3016 1122 CD91      		ld r28,X+
 3017               	.LVL194:
 3018 1124 C22B      		or r28,r18
 3019               	.LVL195:
2859:switcherator.c ****         if (x < 4) {
2860:switcherator.c ****             newAddress |= (tempInt);
2861:switcherator.c ****             newAddress <<= 8;
 3020               		.loc 1 2861 0
 3021 1126 2C2F      		mov r18,r28
2859:switcherator.c ****         if (x < 4) {
 3022               		.loc 1 2859 0
 3023 1128 E430      		cpi r30,4
 3024 112a F105      		cpc r31,__zero_reg__
 3025 112c 01F0      		breq .L208
 3026               		.loc 1 2861 0
 3027 112e 08E0      		ldi r16,lo8(8)
 3028 1130 0E94 0000 		call __ashldi3
 3029               	.LVL196:
 3030               	.L208:
2857:switcherator.c ****     for (x = 0; x < 5; x++) {
 3031               		.loc 1 2857 0
 3032 1134 3196      		adiw r30,1
 3033               	.LVL197:
 3034 1136 E530      		cpi r30,5
 3035 1138 F105      		cpc r31,__zero_reg__
 3036 113a 01F4      		brne .L209
 3037               	/* epilogue start */
2862:switcherator.c ****         } else
2863:switcherator.c ****             newAddress |= tempInt;
2864:switcherator.c ****     }
2865:switcherator.c ****     return newAddress;
2866:switcherator.c **** }
 3038               		.loc 1 2866 0
 3039 113c CF91      		pop r28
 3040 113e 0F91      		pop r16
 3041 1140 0895      		ret
 3042               	.LFE67:
 3044               	.global	generalInit
 3046               	generalInit:
 3047               	.LFB41:
1696:switcherator.c **** void generalInit(void) {
 3048               		.loc 1 1696 0
 3049 1142 EF92      		push r14
 3050               	.LCFI86:
 3051 1144 FF92      		push r15
 3052               	.LCFI87:
 3053 1146 0F93      		push r16
 3054               	.LCFI88:
 3055 1148 1F93      		push r17
 3056               	.LCFI89:
 3057 114a CF93      		push r28
 3058               	.LCFI90:
 3059 114c DF93      		push r29
 3060               	.LCFI91:
 3061 114e CDB7      		in r28,__SP_L__
 3062 1150 DEB7      		in r29,__SP_H__
 3063               	.LCFI92:
 3064 1152 2E97      		sbiw r28,14
 3065               	.LCFI93:
 3066 1154 0FB6      		in __tmp_reg__,__SREG__
 3067 1156 F894      		cli
 3068 1158 DEBF      		out __SP_H__,r29
 3069 115a 0FBE      		out __SREG__,__tmp_reg__
 3070 115c CDBF      		out __SP_L__,r28
 3071               	/* prologue: function */
 3072               	/* frame size = 14 */
 3073               	/* stack size = 20 */
 3074               	.L__stack_usage = 20
 3075               	.LVL198:
1702:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_TX, RADIO_ADDR_TX_BYTES) == 1) {
 3076               		.loc 1 1702 0
 3077 115e 47E0      		ldi r20,lo8(7)
 3078 1160 50E0      		ldi r21,0
 3079 1162 6EE0      		ldi r22,lo8(14)
 3080 1164 70E0      		ldi r23,0
 3081 1166 CE01      		movw r24,r28
 3082 1168 0196      		adiw r24,1
 3083 116a 0E94 0000 		call readEEPROM
 3084               	.LVL199:
 3085 116e 0197      		sbiw r24,1
 3086 1170 01F4      		brne .L212
1703:switcherator.c ****         tx_addr = formatAddress(tempStuff);
 3087               		.loc 1 1703 0
 3088 1172 CE01      		movw r24,r28
 3089 1174 0196      		adiw r24,1
 3090 1176 0E94 0000 		call formatAddress
 3091               	.LVL200:
 3092 117a 2093 0000 		sts tx_addr,r18
 3093 117e 3093 0000 		sts tx_addr+1,r19
 3094 1182 4093 0000 		sts tx_addr+2,r20
 3095 1186 5093 0000 		sts tx_addr+3,r21
 3096 118a 6093 0000 		sts tx_addr+4,r22
 3097 118e 7093 0000 		sts tx_addr+5,r23
 3098 1192 8093 0000 		sts tx_addr+6,r24
 3099 1196 9093 0000 		sts tx_addr+7,r25
1704:switcherator.c ****         writeAddr(TX_ADDR, tx_addr);
 3100               		.loc 1 1704 0
 3101 119a 8901      		movw r16,r18
 3102 119c 9A01      		movw r18,r20
 3103 119e AB01      		movw r20,r22
 3104 11a0 BC01      		movw r22,r24
 3105 11a2 80E1      		ldi r24,lo8(16)
 3106 11a4 0E94 0000 		call writeAddr
 3107               	.LVL201:
 3108               	.L212:
1706:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R0, RADIO_ADDR_R0_BYTES) == 1) {
 3109               		.loc 1 1706 0
 3110 11a8 47E0      		ldi r20,lo8(7)
 3111 11aa 50E0      		ldi r21,0
 3112 11ac 65E1      		ldi r22,lo8(21)
 3113 11ae 70E0      		ldi r23,0
 3114 11b0 CE01      		movw r24,r28
 3115 11b2 0196      		adiw r24,1
 3116 11b4 0E94 0000 		call readEEPROM
 3117               	.LVL202:
 3118 11b8 0197      		sbiw r24,1
 3119 11ba 01F4      		brne .L213
1707:switcherator.c ****         rx_addr_p0 = formatAddress(tempStuff);
 3120               		.loc 1 1707 0
 3121 11bc CE01      		movw r24,r28
 3122 11be 0196      		adiw r24,1
 3123 11c0 0E94 0000 		call formatAddress
 3124               	.LVL203:
 3125 11c4 2093 0000 		sts rx_addr_p0,r18
 3126 11c8 3093 0000 		sts rx_addr_p0+1,r19
 3127 11cc 4093 0000 		sts rx_addr_p0+2,r20
 3128 11d0 5093 0000 		sts rx_addr_p0+3,r21
 3129 11d4 6093 0000 		sts rx_addr_p0+4,r22
 3130 11d8 7093 0000 		sts rx_addr_p0+5,r23
 3131 11dc 8093 0000 		sts rx_addr_p0+6,r24
 3132 11e0 9093 0000 		sts rx_addr_p0+7,r25
1708:switcherator.c ****         writeAddr(RX_ADDR_P0, rx_addr_p0);
 3133               		.loc 1 1708 0
 3134 11e4 8901      		movw r16,r18
 3135 11e6 9A01      		movw r18,r20
 3136 11e8 AB01      		movw r20,r22
 3137 11ea BC01      		movw r22,r24
 3138 11ec 8AE0      		ldi r24,lo8(10)
 3139 11ee 0E94 0000 		call writeAddr
 3140               	.LVL204:
 3141               	.L213:
1711:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R1, RADIO_ADDR_R1_BYTES) == 1) {
 3142               		.loc 1 1711 0
 3143 11f2 47E0      		ldi r20,lo8(7)
 3144 11f4 50E0      		ldi r21,0
 3145 11f6 6CE1      		ldi r22,lo8(28)
 3146 11f8 70E0      		ldi r23,0
 3147 11fa CE01      		movw r24,r28
 3148 11fc 0196      		adiw r24,1
 3149 11fe 0E94 0000 		call readEEPROM
 3150               	.LVL205:
 3151 1202 0197      		sbiw r24,1
 3152 1204 01F4      		brne .L214
1712:switcherator.c ****         rx_addr_p1 = formatAddress(tempStuff);
 3153               		.loc 1 1712 0
 3154 1206 CE01      		movw r24,r28
 3155 1208 0196      		adiw r24,1
 3156 120a 0E94 0000 		call formatAddress
 3157               	.LVL206:
 3158 120e 2093 0000 		sts rx_addr_p1,r18
 3159 1212 3093 0000 		sts rx_addr_p1+1,r19
 3160 1216 4093 0000 		sts rx_addr_p1+2,r20
 3161 121a 5093 0000 		sts rx_addr_p1+3,r21
 3162 121e 6093 0000 		sts rx_addr_p1+4,r22
 3163 1222 7093 0000 		sts rx_addr_p1+5,r23
 3164 1226 8093 0000 		sts rx_addr_p1+6,r24
 3165 122a 9093 0000 		sts rx_addr_p1+7,r25
1713:switcherator.c ****         writeAddr(RX_ADDR_P1, rx_addr_p1);
 3166               		.loc 1 1713 0
 3167 122e 8901      		movw r16,r18
 3168 1230 9A01      		movw r18,r20
 3169 1232 AB01      		movw r20,r22
 3170 1234 BC01      		movw r22,r24
 3171 1236 8BE0      		ldi r24,lo8(11)
 3172 1238 0E94 0000 		call writeAddr
 3173               	.LVL207:
 3174               	.L214:
1715:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R2, RADIO_ADDR_R2_BYTES) == 1) {
 3175               		.loc 1 1715 0
 3176 123c 43E0      		ldi r20,lo8(3)
 3177 123e 50E0      		ldi r21,0
 3178 1240 63E2      		ldi r22,lo8(35)
 3179 1242 70E0      		ldi r23,0
 3180 1244 CE01      		movw r24,r28
 3181 1246 0196      		adiw r24,1
 3182 1248 0E94 0000 		call readEEPROM
 3183               	.LVL208:
 3184 124c 0197      		sbiw r24,1
 3185 124e 01F4      		brne .L215
1716:switcherator.c ****         rx_addr_p2 = tempStuff[0];
 3186               		.loc 1 1716 0
 3187 1250 0981      		ldd r16,Y+1
 3188 1252 0093 0000 		sts rx_addr_p2,r16
 3189 1256 1092 0000 		sts rx_addr_p2+1,__zero_reg__
 3190 125a 1092 0000 		sts rx_addr_p2+2,__zero_reg__
 3191 125e 1092 0000 		sts rx_addr_p2+3,__zero_reg__
 3192 1262 1092 0000 		sts rx_addr_p2+4,__zero_reg__
 3193 1266 1092 0000 		sts rx_addr_p2+5,__zero_reg__
 3194 126a 1092 0000 		sts rx_addr_p2+6,__zero_reg__
 3195 126e 1092 0000 		sts rx_addr_p2+7,__zero_reg__
1717:switcherator.c ****         writeAddr(RX_ADDR_P2, rx_addr_p2);
 3196               		.loc 1 1717 0
 3197 1272 10E0      		ldi r17,0
 3198 1274 20E0      		ldi r18,0
 3199 1276 30E0      		ldi r19,0
 3200 1278 40E0      		ldi r20,0
 3201 127a 50E0      		ldi r21,0
 3202 127c 60E0      		ldi r22,0
 3203 127e 70E0      		ldi r23,0
 3204 1280 8CE0      		ldi r24,lo8(12)
 3205 1282 0E94 0000 		call writeAddr
 3206               	.LVL209:
 3207               	.L215:
1719:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R3, RADIO_ADDR_R3_BYTES) == 1) {
 3208               		.loc 1 1719 0
 3209 1286 43E0      		ldi r20,lo8(3)
 3210 1288 50E0      		ldi r21,0
 3211 128a 66E2      		ldi r22,lo8(38)
 3212 128c 70E0      		ldi r23,0
 3213 128e CE01      		movw r24,r28
 3214 1290 0196      		adiw r24,1
 3215 1292 0E94 0000 		call readEEPROM
 3216               	.LVL210:
 3217 1296 0197      		sbiw r24,1
 3218 1298 01F4      		brne .L216
1720:switcherator.c ****         rx_addr_p3 = tempStuff[0];
 3219               		.loc 1 1720 0
 3220 129a 0981      		ldd r16,Y+1
 3221 129c 0093 0000 		sts rx_addr_p3,r16
 3222 12a0 1092 0000 		sts rx_addr_p3+1,__zero_reg__
 3223 12a4 1092 0000 		sts rx_addr_p3+2,__zero_reg__
 3224 12a8 1092 0000 		sts rx_addr_p3+3,__zero_reg__
 3225 12ac 1092 0000 		sts rx_addr_p3+4,__zero_reg__
 3226 12b0 1092 0000 		sts rx_addr_p3+5,__zero_reg__
 3227 12b4 1092 0000 		sts rx_addr_p3+6,__zero_reg__
 3228 12b8 1092 0000 		sts rx_addr_p3+7,__zero_reg__
1721:switcherator.c ****         writeAddr(RX_ADDR_P3, rx_addr_p3);
 3229               		.loc 1 1721 0
 3230 12bc 10E0      		ldi r17,0
 3231 12be 20E0      		ldi r18,0
 3232 12c0 30E0      		ldi r19,0
 3233 12c2 40E0      		ldi r20,0
 3234 12c4 50E0      		ldi r21,0
 3235 12c6 60E0      		ldi r22,0
 3236 12c8 70E0      		ldi r23,0
 3237 12ca 8DE0      		ldi r24,lo8(13)
 3238 12cc 0E94 0000 		call writeAddr
 3239               	.LVL211:
 3240               	.L216:
1723:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R4, RADIO_ADDR_R4_BYTES) == 1) {
 3241               		.loc 1 1723 0
 3242 12d0 43E0      		ldi r20,lo8(3)
 3243 12d2 50E0      		ldi r21,0
 3244 12d4 69E2      		ldi r22,lo8(41)
 3245 12d6 70E0      		ldi r23,0
 3246 12d8 CE01      		movw r24,r28
 3247 12da 0196      		adiw r24,1
 3248 12dc 0E94 0000 		call readEEPROM
 3249               	.LVL212:
 3250 12e0 0197      		sbiw r24,1
 3251 12e2 01F4      		brne .L217
1724:switcherator.c ****         rx_addr_p4 = tempStuff[0];
 3252               		.loc 1 1724 0
 3253 12e4 0981      		ldd r16,Y+1
 3254 12e6 0093 0000 		sts rx_addr_p4,r16
 3255 12ea 1092 0000 		sts rx_addr_p4+1,__zero_reg__
 3256 12ee 1092 0000 		sts rx_addr_p4+2,__zero_reg__
 3257 12f2 1092 0000 		sts rx_addr_p4+3,__zero_reg__
 3258 12f6 1092 0000 		sts rx_addr_p4+4,__zero_reg__
 3259 12fa 1092 0000 		sts rx_addr_p4+5,__zero_reg__
 3260 12fe 1092 0000 		sts rx_addr_p4+6,__zero_reg__
 3261 1302 1092 0000 		sts rx_addr_p4+7,__zero_reg__
1725:switcherator.c ****         writeAddr(RX_ADDR_P4, rx_addr_p4);
 3262               		.loc 1 1725 0
 3263 1306 10E0      		ldi r17,0
 3264 1308 20E0      		ldi r18,0
 3265 130a 30E0      		ldi r19,0
 3266 130c 40E0      		ldi r20,0
 3267 130e 50E0      		ldi r21,0
 3268 1310 60E0      		ldi r22,0
 3269 1312 70E0      		ldi r23,0
 3270 1314 8EE0      		ldi r24,lo8(14)
 3271 1316 0E94 0000 		call writeAddr
 3272               	.LVL213:
 3273               	.L217:
1727:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R5, RADIO_ADDR_R5_BYTES) == 1) {
 3274               		.loc 1 1727 0
 3275 131a 43E0      		ldi r20,lo8(3)
 3276 131c 50E0      		ldi r21,0
 3277 131e 6CE2      		ldi r22,lo8(44)
 3278 1320 70E0      		ldi r23,0
 3279 1322 CE01      		movw r24,r28
 3280 1324 0196      		adiw r24,1
 3281 1326 0E94 0000 		call readEEPROM
 3282               	.LVL214:
 3283 132a 0197      		sbiw r24,1
 3284 132c 01F4      		brne .L218
1728:switcherator.c ****         rx_addr_p5 = tempStuff[0];
 3285               		.loc 1 1728 0
 3286 132e 0981      		ldd r16,Y+1
 3287 1330 0093 0000 		sts rx_addr_p5,r16
 3288 1334 1092 0000 		sts rx_addr_p5+1,__zero_reg__
 3289 1338 1092 0000 		sts rx_addr_p5+2,__zero_reg__
 3290 133c 1092 0000 		sts rx_addr_p5+3,__zero_reg__
 3291 1340 1092 0000 		sts rx_addr_p5+4,__zero_reg__
 3292 1344 1092 0000 		sts rx_addr_p5+5,__zero_reg__
 3293 1348 1092 0000 		sts rx_addr_p5+6,__zero_reg__
 3294 134c 1092 0000 		sts rx_addr_p5+7,__zero_reg__
1729:switcherator.c ****         writeAddr(RX_ADDR_P5, rx_addr_p5);
 3295               		.loc 1 1729 0
 3296 1350 10E0      		ldi r17,0
 3297 1352 20E0      		ldi r18,0
 3298 1354 30E0      		ldi r19,0
 3299 1356 40E0      		ldi r20,0
 3300 1358 50E0      		ldi r21,0
 3301 135a 60E0      		ldi r22,0
 3302 135c 70E0      		ldi r23,0
 3303 135e 8FE0      		ldi r24,lo8(15)
 3304 1360 0E94 0000 		call writeAddr
 3305               	.LVL215:
 3306               	.L218:
1731:switcherator.c ****     if (readEEPROM(tempStuff, TWEAK_TIMER, TWEAK_TIMER_BYTES) == 1) {
 3307               		.loc 1 1731 0
 3308 1364 44E0      		ldi r20,lo8(4)
 3309 1366 50E0      		ldi r21,0
 3310 1368 69E1      		ldi r22,lo8(25)
 3311 136a 71E0      		ldi r23,lo8(1)
 3312 136c CE01      		movw r24,r28
 3313 136e 0196      		adiw r24,1
 3314 1370 0E94 0000 		call readEEPROM
 3315               	.LVL216:
 3316 1374 0197      		sbiw r24,1
 3317 1376 01F4      		brne .L219
1732:switcherator.c ****         tweakTimer = tempStuff[0];
 3318               		.loc 1 1732 0
 3319 1378 8981      		ldd r24,Y+1
 3320 137a 90E0      		ldi r25,0
 3321 137c A0E0      		ldi r26,0
 3322 137e B0E0      		ldi r27,0
1733:switcherator.c ****         tweakTimer <<= 8;
 3323               		.loc 1 1733 0
 3324 1380 BA2F      		mov r27,r26
 3325 1382 A92F      		mov r26,r25
 3326 1384 982F      		mov r25,r24
 3327 1386 8827      		clr r24
1734:switcherator.c ****         tweakTimer |= tempStuff[1];
 3328               		.loc 1 1734 0
 3329 1388 2A81      		ldd r18,Y+2
 3330 138a 822B      		or r24,r18
 3331 138c 8093 0000 		sts tweakTimer,r24
 3332 1390 9093 0000 		sts tweakTimer+1,r25
 3333 1394 A093 0000 		sts tweakTimer+2,r26
 3334 1398 B093 0000 		sts tweakTimer+3,r27
 3335               	.L219:
1739:switcherator.c ****     if (readEEPROM(tempStuff, DAYLIGHT_SAVE, DAYLIGHT_SAVE_BYTES) == 1) {
 3336               		.loc 1 1739 0
 3337 139c 4AE0      		ldi r20,lo8(10)
 3338 139e 50E0      		ldi r21,0
 3339 13a0 66E0      		ldi r22,lo8(6)
 3340 13a2 70E0      		ldi r23,0
 3341 13a4 CE01      		movw r24,r28
 3342 13a6 0196      		adiw r24,1
 3343 13a8 0E94 0000 		call readEEPROM
 3344               	.LVL217:
 3345 13ac 0197      		sbiw r24,1
 3346 13ae 01F4      		brne .L220
1741:switcherator.c ****         daylightSavings[0][0] = ((tempStuff[0] << 8) | (tempStuff[1]));
 3347               		.loc 1 1741 0
 3348 13b0 9981      		ldd r25,Y+1
 3349 13b2 80E0      		ldi r24,0
 3350 13b4 2A81      		ldd r18,Y+2
 3351 13b6 822B      		or r24,r18
 3352 13b8 9093 0000 		sts daylightSavings+1,r25
 3353 13bc 8093 0000 		sts daylightSavings,r24
1743:switcherator.c ****         daylightSavings[0][1] = ((tempStuff[2] << 8) | (tempStuff[3]));
 3354               		.loc 1 1743 0
 3355 13c0 9B81      		ldd r25,Y+3
 3356 13c2 80E0      		ldi r24,0
 3357 13c4 2C81      		ldd r18,Y+4
 3358 13c6 822B      		or r24,r18
 3359 13c8 9093 0000 		sts daylightSavings+2+1,r25
 3360 13cc 8093 0000 		sts daylightSavings+2,r24
1745:switcherator.c ****         daylightSavings[1][0] = ((tempStuff[4] << 8) | (tempStuff[5]));
 3361               		.loc 1 1745 0
 3362 13d0 9D81      		ldd r25,Y+5
 3363 13d2 80E0      		ldi r24,0
 3364 13d4 2E81      		ldd r18,Y+6
 3365 13d6 822B      		or r24,r18
 3366 13d8 9093 0000 		sts daylightSavings+4+1,r25
 3367 13dc 8093 0000 		sts daylightSavings+4,r24
1747:switcherator.c ****         daylightSavings[1][1] = ((tempStuff[6] << 8) | (tempStuff[7]));
 3368               		.loc 1 1747 0
 3369 13e0 9F81      		ldd r25,Y+7
 3370 13e2 80E0      		ldi r24,0
 3371 13e4 2885      		ldd r18,Y+8
 3372 13e6 822B      		or r24,r18
 3373 13e8 9093 0000 		sts daylightSavings+6+1,r25
 3374 13ec 8093 0000 		sts daylightSavings+6,r24
 3375               	.L220:
1750:switcherator.c ****     if (readEEPROM(tempStuff, SERIAL_NUM, SERIAL_NUM_BYTES) == 1) {
 3376               		.loc 1 1750 0
 3377 13f0 48E0      		ldi r20,lo8(8)
 3378 13f2 50E0      		ldi r21,0
 3379 13f4 60E0      		ldi r22,0
 3380 13f6 70E0      		ldi r23,0
 3381 13f8 CE01      		movw r24,r28
 3382 13fa 0196      		adiw r24,1
 3383 13fc 0E94 0000 		call readEEPROM
 3384               	.LVL218:
 3385 1400 0197      		sbiw r24,1
 3386 1402 01F4      		brne .L221
1751:switcherator.c ****         serial = atol(tempStuff);
 3387               		.loc 1 1751 0
 3388 1404 CE01      		movw r24,r28
 3389 1406 0196      		adiw r24,1
 3390 1408 0E94 0000 		call atol
 3391               	.LVL219:
 3392 140c 6093 0000 		sts serial,r22
 3393 1410 7093 0000 		sts serial+1,r23
 3394 1414 8093 0000 		sts serial+2,r24
 3395 1418 9093 0000 		sts serial+3,r25
1752:switcherator.c ****         ltoa(serial, stringSerial, 10);
 3396               		.loc 1 1752 0
 3397 141c 2AE0      		ldi r18,lo8(10)
 3398 141e 30E0      		ldi r19,0
 3399 1420 40E0      		ldi r20,lo8(stringSerial)
 3400 1422 50E0      		ldi r21,hi8(stringSerial)
 3401 1424 0E94 0000 		call ltoa
 3402               	.LVL220:
 3403               	.L221:
1756:switcherator.c ****     if (readEEPROM(switchStuff, SWITCH_STUFF, SWITCH_STUFF_BYTES) == 1) {
 3404               		.loc 1 1756 0
 3405 1428 42E1      		ldi r20,lo8(18)
 3406 142a 50E0      		ldi r21,0
 3407 142c 60E3      		ldi r22,lo8(48)
 3408 142e 70E0      		ldi r23,0
 3409 1430 80E0      		ldi r24,lo8(switchStuff)
 3410 1432 90E0      		ldi r25,hi8(switchStuff)
 3411 1434 0E94 0000 		call readEEPROM
 3412               	.LVL221:
 3413 1438 0197      		sbiw r24,1
 3414 143a 01F0      		breq .+2
 3415 143c 00C0      		rjmp .L222
 3416               	.LBB22:
1757:switcherator.c ****         readEEPROM(switchBright, BRIGHTNESS, BRIGHTNESS_BYTES);
 3417               		.loc 1 1757 0
 3418 143e 42E1      		ldi r20,lo8(18)
 3419 1440 50E0      		ldi r21,0
 3420 1442 60E2      		ldi r22,lo8(32)
 3421 1444 71E0      		ldi r23,lo8(1)
 3422 1446 80E0      		ldi r24,lo8(switchBright)
 3423 1448 90E0      		ldi r25,hi8(switchBright)
 3424 144a 0E94 0000 		call readEEPROM
 3425               	.LVL222:
 3426 144e 80E0      		ldi r24,lo8(switchStuff)
 3427 1450 90E0      		ldi r25,hi8(switchStuff)
1824:switcherator.c ****             *realDDR |= (1 << realPin);
 3428               		.loc 1 1824 0
 3429 1452 41E0      		ldi r20,lo8(1)
 3430 1454 50E0      		ldi r21,0
 3431               	.LVL223:
 3432               	.L227:
1766:switcherator.c ****             temp = switchStuff[x];
 3433               		.loc 1 1766 0
 3434 1456 FC01      		movw r30,r24
 3435 1458 2191      		ld r18,Z+
 3436 145a CF01      		movw r24,r30
 3437               	.LVL224:
1767:switcherator.c ****             if (temp > 15 && temp < 32) {
 3438               		.loc 1 1767 0
 3439 145c 622F      		mov r22,r18
 3440 145e 6051      		subi r22,lo8(-(-16))
 3441 1460 6031      		cpi r22,lo8(16)
 3442 1462 00F0      		brlo .L248
1778:switcherator.c ****             } else if (temp < 48) {
 3443               		.loc 1 1778 0
 3444 1464 2033      		cpi r18,lo8(48)
 3445 1466 00F4      		brsh .L224
 3446               	.LVL225:
1781:switcherator.c ****                 temp -= 32;
 3447               		.loc 1 1781 0
 3448 1468 6051      		subi r22,lo8(-(-16))
 3449               	.LVL226:
1780:switcherator.c ****                 realDDR = &DDRC;
 3450               		.loc 1 1780 0
 3451 146a A7E2      		ldi r26,lo8(39)
 3452 146c B0E0      		ldi r27,0
1779:switcherator.c ****                 realPort = &PORTC;
 3453               		.loc 1 1779 0
 3454 146e E8E2      		ldi r30,lo8(40)
 3455 1470 F0E0      		ldi r31,0
 3456 1472 00C0      		rjmp .L223
 3457               	.LVL227:
 3458               	.L224:
1784:switcherator.c ****             } else if (temp < 64) {
 3459               		.loc 1 1784 0
 3460 1474 2034      		cpi r18,lo8(64)
 3461 1476 00F4      		brsh .L225
 3462               	.LVL228:
1787:switcherator.c ****                 temp -= 48;
 3463               		.loc 1 1787 0
 3464 1478 622F      		mov r22,r18
 3465 147a 6053      		subi r22,lo8(-(-48))
 3466               	.LVL229:
1786:switcherator.c ****                 realDDR = &DDRD;
 3467               		.loc 1 1786 0
 3468 147c AAE2      		ldi r26,lo8(42)
 3469 147e B0E0      		ldi r27,0
1785:switcherator.c ****                 realPort = &PORTD;
 3470               		.loc 1 1785 0
 3471 1480 EBE2      		ldi r30,lo8(43)
 3472 1482 F0E0      		ldi r31,0
 3473 1484 00C0      		rjmp .L223
 3474               	.LVL230:
 3475               	.L248:
1769:switcherator.c ****                 realDDR = &DDRB;
 3476               		.loc 1 1769 0
 3477 1486 A4E2      		ldi r26,lo8(36)
 3478 1488 B0E0      		ldi r27,0
1768:switcherator.c ****                 realPort = &PORTB;
 3479               		.loc 1 1768 0
 3480 148a E5E2      		ldi r30,lo8(37)
 3481 148c F0E0      		ldi r31,0
 3482               	.LVL231:
 3483               	.L223:
1824:switcherator.c ****             *realDDR |= (1 << realPin);
 3484               		.loc 1 1824 0
 3485 148e 7C91      		ld r23,X
1823:switcherator.c ****             realPin = (temp / 2);
 3486               		.loc 1 1823 0
 3487 1490 262F      		mov r18,r22
 3488 1492 2695      		lsr r18
 3489               	.LVL232:
1824:switcherator.c ****             *realDDR |= (1 << realPin);
 3490               		.loc 1 1824 0
 3491 1494 8A01      		movw r16,r20
 3492 1496 00C0      		rjmp 2f
 3493               		1:
 3494 1498 000F      		lsl r16
 3495 149a 111F      		rol r17
 3496               		2:
 3497 149c 2A95      		dec r18
 3498 149e 02F4      		brpl 1b
 3499 14a0 9801      		movw r18,r16
 3500               	.LVL233:
 3501 14a2 702B      		or r23,r16
 3502 14a4 7C93      		st X,r23
1826:switcherator.c ****             if (temp % 2 == 0) {
 3503               		.loc 1 1826 0
 3504 14a6 60FD      		sbrc r22,0
 3505 14a8 00C0      		rjmp .L226
1828:switcherator.c ****                 *realPort |= (1 << realPin);
 3506               		.loc 1 1828 0
 3507 14aa 2081      		ld r18,Z
 3508 14ac 202B      		or r18,r16
 3509 14ae 00C0      		rjmp .L259
 3510               	.L226:
1830:switcherator.c ****                 *realPort &= ~(1 << realPin);
 3511               		.loc 1 1830 0
 3512 14b0 3081      		ld r19,Z
 3513 14b2 2095      		com r18
 3514 14b4 2323      		and r18,r19
 3515               	.L259:
 3516 14b6 2083      		st Z,r18
 3517               	.LVL234:
 3518               	.L225:
1765:switcherator.c ****         for (x = 0; x < NUM_SWITCHES; x++) {
 3519               		.loc 1 1765 0
 3520 14b8 10E0      		ldi r17,hi8(switchStuff+16)
 3521 14ba 8030      		cpi r24,lo8(switchStuff+16)
 3522 14bc 9107      		cpc r25,r17
 3523 14be 01F4      		brne .L227
 3524               	.L230:
 3525               	.LVL235:
 3526 14c0 40E0      		ldi r20,lo8(weeklyProgram)
 3527 14c2 E42E      		mov r14,r20
 3528 14c4 40E0      		ldi r20,hi8(weeklyProgram)
 3529 14c6 F42E      		mov r15,r20
1785:switcherator.c ****                 realPort = &PORTD;
 3530               		.loc 1 1785 0
 3531 14c8 01EA      		ldi r16,lo8(-95)
 3532 14ca 10E0      		ldi r17,0
 3533 14cc 00C0      		rjmp .L228
 3534               	.L222:
 3535 14ce E0E0      		ldi r30,lo8(switchStuff)
 3536 14d0 F0E0      		ldi r31,hi8(switchStuff)
 3537               	.LBE22:
1835:switcherator.c ****             switchStuff[x] = 255;
 3538               		.loc 1 1835 0
 3539 14d2 8FEF      		ldi r24,lo8(-1)
 3540               	.LVL236:
 3541               	.L229:
1835:switcherator.c ****             switchStuff[x] = 255;
 3542               		.loc 1 1835 0 is_stmt 0 discriminator 2
 3543 14d4 8193      		st Z+,r24
1834:switcherator.c ****         for (x = 0; x < NUM_SWITCHES; x++)
 3544               		.loc 1 1834 0 is_stmt 1 discriminator 2
 3545 14d6 20E0      		ldi r18,hi8(switchStuff+16)
 3546 14d8 E030      		cpi r30,lo8(switchStuff+16)
 3547 14da F207      		cpc r31,r18
 3548 14dc 01F4      		brne .L229
 3549 14de 00C0      		rjmp .L230
 3550               	.L228:
 3551               	.LVL237:
1843:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, WEEKLY_PROGRAM_BYTES) == 1) {
 3552               		.loc 1 1843 0
 3553 14e0 4CE0      		ldi r20,lo8(12)
 3554 14e2 50E0      		ldi r21,0
 3555 14e4 B801      		movw r22,r16
 3556 14e6 CE01      		movw r24,r28
 3557 14e8 0196      		adiw r24,1
 3558 14ea 0E94 0000 		call readEEPROM
 3559               	.LVL238:
 3560 14ee 0197      		sbiw r24,1
 3561 14f0 01F0      		breq .L231
 3562               	.L234:
 3563 14f2 045F      		subi r16,-12
 3564 14f4 1F4F      		sbci r17,-1
 3565               	.LVL239:
 3566 14f6 8AE0      		ldi r24,10
 3567 14f8 E80E      		add r14,r24
 3568 14fa F11C      		adc r15,__zero_reg__
1841:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 3569               		.loc 1 1841 0
 3570 14fc 0931      		cpi r16,25
 3571 14fe 91E0      		ldi r25,1
 3572 1500 1907      		cpc r17,r25
 3573 1502 01F4      		brne .L228
 3574 1504 00C0      		rjmp .L257
 3575               	.LVL240:
 3576               	.L231:
 3577 1506 FE01      		movw r30,r28
 3578 1508 3196      		adiw r30,1
1843:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, WEEKLY_PROGRAM_BYTES) == 1) {
 3579               		.loc 1 1843 0
 3580 150a 80E0      		ldi r24,0
 3581 150c 90E0      		ldi r25,0
 3582               	.L233:
1845:switcherator.c ****                 weeklyProgram[x][y] = tempStuff[y];
 3583               		.loc 1 1845 0 discriminator 2
 3584 150e 2191      		ld r18,Z+
1696:switcherator.c **** void generalInit(void) {
 3585               		.loc 1 1696 0 discriminator 2
 3586 1510 D701      		movw r26,r14
 3587 1512 A80F      		add r26,r24
 3588 1514 B91F      		adc r27,r25
1845:switcherator.c ****                 weeklyProgram[x][y] = tempStuff[y];
 3589               		.loc 1 1845 0 discriminator 2
 3590 1516 2C93      		st X,r18
1844:switcherator.c ****             for (y = 0; y < 10; y++) {
 3591               		.loc 1 1844 0 discriminator 2
 3592 1518 0196      		adiw r24,1
 3593               	.LVL241:
 3594 151a 8A30      		cpi r24,10
 3595 151c 9105      		cpc r25,__zero_reg__
 3596 151e 01F4      		brne .L233
 3597 1520 00C0      		rjmp .L234
 3598               	.LVL242:
 3599               	.L257:
 3600 1522 30E0      		ldi r19,lo8(inputs)
 3601 1524 E32E      		mov r14,r19
 3602 1526 30E0      		ldi r19,hi8(inputs)
 3603 1528 F32E      		mov r15,r19
1841:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 3604               		.loc 1 1841 0
 3605 152a 02E4      		ldi r16,lo8(66)
 3606 152c 10E0      		ldi r17,0
 3607               	.LVL243:
 3608               	.L236:
1852:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, INPUT_BYTES) == 1) {
 3609               		.loc 1 1852 0
 3610 152e 4AE0      		ldi r20,lo8(10)
 3611 1530 50E0      		ldi r21,0
 3612 1532 B801      		movw r22,r16
 3613 1534 CE01      		movw r24,r28
 3614 1536 0196      		adiw r24,1
 3615 1538 0E94 0000 		call readEEPROM
 3616               	.LVL244:
 3617 153c 0197      		sbiw r24,1
 3618 153e 01F0      		breq .L235
 3619               	.L239:
 3620 1540 065F      		subi r16,-10
 3621 1542 1F4F      		sbci r17,-1
 3622               	.LVL245:
 3623 1544 E8E0      		ldi r30,8
 3624 1546 EE0E      		add r14,r30
 3625 1548 F11C      		adc r15,__zero_reg__
1850:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 3626               		.loc 1 1850 0
 3627 154a 0A36      		cpi r16,106
 3628 154c 1105      		cpc r17,__zero_reg__
 3629 154e 01F4      		brne .L236
 3630 1550 00C0      		rjmp .L258
 3631               	.LVL246:
 3632               	.L235:
 3633 1552 FE01      		movw r30,r28
 3634 1554 3196      		adiw r30,1
1852:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, INPUT_BYTES) == 1) {
 3635               		.loc 1 1852 0
 3636 1556 80E0      		ldi r24,0
 3637 1558 90E0      		ldi r25,0
 3638               	.L238:
1854:switcherator.c ****                 inputs[x][y] = tempStuff[y];
 3639               		.loc 1 1854 0 discriminator 2
 3640 155a 2191      		ld r18,Z+
1696:switcherator.c **** void generalInit(void) {
 3641               		.loc 1 1696 0 discriminator 2
 3642 155c D701      		movw r26,r14
 3643 155e A80F      		add r26,r24
 3644 1560 B91F      		adc r27,r25
1854:switcherator.c ****                 inputs[x][y] = tempStuff[y];
 3645               		.loc 1 1854 0 discriminator 2
 3646 1562 2C93      		st X,r18
1853:switcherator.c ****             for (y = 0; y < 8; y++) {
 3647               		.loc 1 1853 0 discriminator 2
 3648 1564 0196      		adiw r24,1
 3649               	.LVL247:
 3650 1566 8830      		cpi r24,8
 3651 1568 9105      		cpc r25,__zero_reg__
 3652 156a 01F4      		brne .L238
 3653 156c 00C0      		rjmp .L239
 3654               	.LVL248:
 3655               	.L258:
 3656 156e 00E0      		ldi r16,lo8(timeLimits)
 3657 1570 10E0      		ldi r17,hi8(timeLimits)
 3658               	.LVL249:
1850:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 3659               		.loc 1 1850 0
 3660 1572 2AE6      		ldi r18,lo8(106)
 3661 1574 E22E      		mov r14,r18
 3662 1576 F12C      		mov r15,__zero_reg__
 3663               	.L241:
 3664               	.LVL250:
1861:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, LIMIT_BYTES) == 1) {
 3665               		.loc 1 1861 0
 3666 1578 45E0      		ldi r20,lo8(5)
 3667 157a 50E0      		ldi r21,0
 3668 157c B701      		movw r22,r14
 3669 157e CE01      		movw r24,r28
 3670 1580 0196      		adiw r24,1
 3671 1582 0E94 0000 		call readEEPROM
 3672               	.LVL251:
 3673 1586 0197      		sbiw r24,1
 3674 1588 01F4      		brne .L240
 3675               	.LVL252:
1863:switcherator.c ****                 timeLimits[x][y] = tempStuff[y];
 3676               		.loc 1 1863 0 discriminator 1
 3677 158a 8981      		ldd r24,Y+1
 3678 158c 90E0      		ldi r25,0
 3679 158e A0E0      		ldi r26,0
 3680 1590 B0E0      		ldi r27,0
 3681 1592 F801      		movw r30,r16
 3682 1594 8083      		st Z,r24
 3683 1596 9183      		std Z+1,r25
 3684 1598 A283      		std Z+2,r26
 3685 159a B383      		std Z+3,r27
 3686               	.LVL253:
 3687 159c 8A81      		ldd r24,Y+2
 3688 159e 90E0      		ldi r25,0
 3689 15a0 A0E0      		ldi r26,0
 3690 15a2 B0E0      		ldi r27,0
 3691 15a4 8483      		std Z+4,r24
 3692 15a6 9583      		std Z+5,r25
 3693 15a8 A683      		std Z+6,r26
 3694 15aa B783      		std Z+7,r27
 3695               	.LVL254:
 3696 15ac 8B81      		ldd r24,Y+3
 3697 15ae 90E0      		ldi r25,0
 3698 15b0 A0E0      		ldi r26,0
 3699 15b2 B0E0      		ldi r27,0
 3700 15b4 8087      		std Z+8,r24
 3701 15b6 9187      		std Z+9,r25
 3702 15b8 A287      		std Z+10,r26
 3703 15ba B387      		std Z+11,r27
 3704               	.LVL255:
 3705               	.L240:
 3706 15bc F5E0      		ldi r31,5
 3707 15be EF0E      		add r14,r31
 3708 15c0 F11C      		adc r15,__zero_reg__
 3709               	.LVL256:
 3710 15c2 045F      		subi r16,-12
 3711 15c4 1F4F      		sbci r17,-1
1859:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++) {
 3712               		.loc 1 1859 0
 3713 15c6 2EE7      		ldi r18,126
 3714 15c8 E216      		cp r14,r18
 3715 15ca F104      		cpc r15,__zero_reg__
 3716 15cc 01F4      		brne .L241
1868:switcherator.c ****     if (readEEPROM(tempStuff, PWM_DIR, PWM_DIR_BYTES) == 1) {
 3717               		.loc 1 1868 0
 3718 15ce 43E0      		ldi r20,lo8(3)
 3719 15d0 50E0      		ldi r21,0
 3720 15d2 6DE1      		ldi r22,lo8(29)
 3721 15d4 71E0      		ldi r23,lo8(1)
 3722 15d6 CE01      		movw r24,r28
 3723 15d8 0196      		adiw r24,1
 3724 15da 0E94 0000 		call readEEPROM
 3725               	.LVL257:
 3726 15de 0197      		sbiw r24,1
 3727 15e0 01F4      		brne .L242
1869:switcherator.c ****         DDRD |= (1 << PIND3) | (1 << PIND5) | (1 << PIND6);
 3728               		.loc 1 1869 0
 3729 15e2 8AB1      		in r24,0xa
 3730 15e4 8866      		ori r24,lo8(104)
 3731 15e6 8AB9      		out 0xa,r24
1871:switcherator.c ****         Red = 0;
 3732               		.loc 1 1871 0
 3733 15e8 1092 B400 		sts 180,__zero_reg__
1872:switcherator.c ****         Green = 0;
 3734               		.loc 1 1872 0
 3735 15ec 18BC      		out 0x28,__zero_reg__
1873:switcherator.c ****         Blue = 0;
 3736               		.loc 1 1873 0
 3737 15ee 17BC      		out 0x27,__zero_reg__
1876:switcherator.c ****         if (tempStuff[0] == 0) {
 3738               		.loc 1 1876 0
 3739 15f0 8981      		ldd r24,Y+1
 3740 15f2 8111      		cpse r24,__zero_reg__
 3741 15f4 00C0      		rjmp .L243
1877:switcherator.c ****             TCCR0A = (1 << COM0A0) | (1 << COM0A1) | (1 << COM0B0) | (1 << COM0B1) | (1 << WGM00);
 3742               		.loc 1 1877 0
 3743 15f6 81EF      		ldi r24,lo8(-15)
 3744 15f8 84BD      		out 0x24,r24
1878:switcherator.c ****             TCCR2A = (1 << COM2B0) | (1 << COM2B1) | (1 << WGM20);
 3745               		.loc 1 1878 0
 3746 15fa 81E3      		ldi r24,lo8(49)
 3747 15fc 8093 B000 		sts 176,r24
1879:switcherator.c ****             pwmdir = 0;
 3748               		.loc 1 1879 0
 3749 1600 1092 0000 		sts pwmdir,__zero_reg__
 3750 1604 00C0      		rjmp .L244
 3751               	.L243:
1881:switcherator.c ****             TCCR0A = (1 << COM0A1) | (1 << COM0B1) | (1 << WGM00);
 3752               		.loc 1 1881 0
 3753 1606 81EA      		ldi r24,lo8(-95)
 3754 1608 84BD      		out 0x24,r24
1882:switcherator.c ****             TCCR2A = (1 << COM2B1) | (1 << WGM20);
 3755               		.loc 1 1882 0
 3756 160a 81E2      		ldi r24,lo8(33)
 3757 160c 8093 B000 		sts 176,r24
1883:switcherator.c ****             pwmdir = 1;
 3758               		.loc 1 1883 0
 3759 1610 81E0      		ldi r24,lo8(1)
 3760 1612 8093 0000 		sts pwmdir,r24
 3761               	.L244:
1886:switcherator.c ****         TCCR0B = (1 << CS01) | (1 << CS00);
 3762               		.loc 1 1886 0
 3763 1616 83E0      		ldi r24,lo8(3)
 3764 1618 85BD      		out 0x25,r24
1888:switcherator.c ****         TCCR2B = (1 << CS22); // F_CPU/64
 3765               		.loc 1 1888 0
 3766 161a 84E0      		ldi r24,lo8(4)
 3767 161c 8093 B100 		sts 177,r24
 3768               	.L242:
 3769               	.LVL258:
1893:switcherator.c ****     if (readEEPROM(tempStuff, memoryMarker, PWM_VALUE_BYTES) == 1) {
 3770               		.loc 1 1893 0
 3771 1620 45E0      		ldi r20,lo8(5)
 3772 1622 50E0      		ldi r21,0
 3773 1624 6EE7      		ldi r22,lo8(126)
 3774 1626 70E0      		ldi r23,0
 3775 1628 CE01      		movw r24,r28
 3776 162a 0196      		adiw r24,1
 3777 162c 0E94 0000 		call readEEPROM
 3778               	.LVL259:
 3779 1630 0197      		sbiw r24,1
 3780 1632 01F4      		brne .L245
1894:switcherator.c ****         pwmValues[0] = tempStuff[0];
 3781               		.loc 1 1894 0
 3782 1634 8981      		ldd r24,Y+1
 3783 1636 8093 0000 		sts pwmValues,r24
1895:switcherator.c ****         pwmValues[1] = tempStuff[1];
 3784               		.loc 1 1895 0
 3785 163a 8A81      		ldd r24,Y+2
 3786 163c 8093 0000 		sts pwmValues+1,r24
1896:switcherator.c ****         pwmValues[2] = tempStuff[2];
 3787               		.loc 1 1896 0
 3788 1640 8B81      		ldd r24,Y+3
 3789 1642 8093 0000 		sts pwmValues+2,r24
 3790               	.L245:
 3791               	.LVL260:
 3792 1646 00E0      		ldi r16,lo8(colorChanges+2)
 3793 1648 10E0      		ldi r17,hi8(colorChanges+2)
1850:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 3794               		.loc 1 1850 0 discriminator 1
 3795 164a 93E8      		ldi r25,lo8(-125)
 3796 164c E92E      		mov r14,r25
 3797 164e F12C      		mov r15,__zero_reg__
 3798               	.LVL261:
 3799               	.L247:
1901:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, PWM_VALUE_BYTES) == 1) {
 3800               		.loc 1 1901 0
 3801 1650 45E0      		ldi r20,lo8(5)
 3802 1652 50E0      		ldi r21,0
 3803 1654 B701      		movw r22,r14
 3804 1656 CE01      		movw r24,r28
 3805 1658 0196      		adiw r24,1
 3806 165a 0E94 0000 		call readEEPROM
 3807               	.LVL262:
 3808 165e 0197      		sbiw r24,1
 3809 1660 01F4      		brne .L246
 3810               	.LVL263:
1696:switcherator.c **** void generalInit(void) {
 3811               		.loc 1 1696 0 discriminator 1
 3812 1662 F801      		movw r30,r16
 3813 1664 3297      		sbiw r30,2
1903:switcherator.c ****                 colorChanges[x][y] = tempStuff[y];
 3814               		.loc 1 1903 0 discriminator 1
 3815 1666 8981      		ldd r24,Y+1
 3816 1668 8083      		st Z,r24
 3817               	.LVL264:
1696:switcherator.c **** void generalInit(void) {
 3818               		.loc 1 1696 0 discriminator 1
 3819 166a F801      		movw r30,r16
 3820 166c 3197      		sbiw r30,1
1903:switcherator.c ****                 colorChanges[x][y] = tempStuff[y];
 3821               		.loc 1 1903 0 discriminator 1
 3822 166e 8A81      		ldd r24,Y+2
 3823 1670 8083      		st Z,r24
 3824               	.LVL265:
 3825 1672 8B81      		ldd r24,Y+3
 3826 1674 F801      		movw r30,r16
 3827 1676 8083      		st Z,r24
 3828               	.LVL266:
 3829               	.L246:
 3830 1678 F5E0      		ldi r31,5
 3831 167a EF0E      		add r14,r31
 3832 167c F11C      		adc r15,__zero_reg__
 3833               	.LVL267:
 3834 167e 0D5F      		subi r16,-3
 3835 1680 1F4F      		sbci r17,-1
1899:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 3836               		.loc 1 1899 0
 3837 1682 21EA      		ldi r18,-95
 3838 1684 E216      		cp r14,r18
 3839 1686 F104      		cpc r15,__zero_reg__
 3840 1688 01F4      		brne .L247
 3841               	/* epilogue start */
1907:switcherator.c **** }
 3842               		.loc 1 1907 0
 3843 168a 2E96      		adiw r28,14
 3844 168c 0FB6      		in __tmp_reg__,__SREG__
 3845 168e F894      		cli
 3846 1690 DEBF      		out __SP_H__,r29
 3847 1692 0FBE      		out __SREG__,__tmp_reg__
 3848 1694 CDBF      		out __SP_L__,r28
 3849 1696 DF91      		pop r29
 3850 1698 CF91      		pop r28
 3851 169a 1F91      		pop r17
 3852 169c 0F91      		pop r16
 3853 169e FF90      		pop r15
 3854 16a0 EF90      		pop r14
 3855               	.LVL268:
 3856 16a2 0895      		ret
 3857               	.LFE41:
 3859               	.global	unformatAddress
 3861               	unformatAddress:
 3862               	.LFB71:
2867:switcherator.c **** 
2868:switcherator.c **** // send receive addresses
2869:switcherator.c **** //static uint64_t rx_addr_p0, rx_addr_p1, rx_addr_p2, rx_addr_p3, rx_addr_p4, rx_addr_p5, tx_addr;
2870:switcherator.c **** 
2871:switcherator.c **** // display's a given address
2872:switcherator.c **** //RD:N RC:N 0xnnnnnnnnnn
2873:switcherator.c **** //0123
2874:switcherator.c **** 
2875:switcherator.c **** void radioDisplayAddress(char * commandReceived) {
2876:switcherator.c ****     int x = 0;
2877:switcherator.c ****     char tempRadioString[6];
2878:switcherator.c ****     statusMsg[0] = 0;
2879:switcherator.c ****     switch (commandReceived[3]) {
2880:switcherator.c ****         case '1':
2881:switcherator.c ****             unformatAddress(rx_addr_p1, tempRadioString);
2882:switcherator.c ****             strcat(statusMsg, "r1-0x");
2883:switcherator.c ****             break;
2884:switcherator.c ****         case '2':
2885:switcherator.c ****             unformatAddress(rx_addr_p2, tempRadioString);
2886:switcherator.c ****             strcat(statusMsg, "r2-0x");
2887:switcherator.c ****             break;
2888:switcherator.c ****         case '3':
2889:switcherator.c ****             unformatAddress(rx_addr_p3, tempRadioString);
2890:switcherator.c ****             strcat(statusMsg, "r3-0x");
2891:switcherator.c ****             break;
2892:switcherator.c ****         case '4':
2893:switcherator.c ****             unformatAddress(rx_addr_p4, tempRadioString);
2894:switcherator.c ****             strcat(statusMsg, "r4-0x");
2895:switcherator.c ****             break;
2896:switcherator.c ****         case '5':
2897:switcherator.c ****             unformatAddress(rx_addr_p5, tempRadioString);
2898:switcherator.c ****             strcat(statusMsg, "r5-0x");
2899:switcherator.c ****             break;
2900:switcherator.c ****         case 'T':
2901:switcherator.c ****             unformatAddress(tx_addr, tempRadioString);
2902:switcherator.c ****             strcat(statusMsg, "t-0x");
2903:switcherator.c ****             break;
2904:switcherator.c ****         default:
2905:switcherator.c ****             unformatAddress(rx_addr_p0, tempRadioString);
2906:switcherator.c ****             strcat(statusMsg, "r0-0x");
2907:switcherator.c ****             break;
2908:switcherator.c ****     }
2909:switcherator.c ****     for (x = 0; x < 5; x++) {
2910:switcherator.c ****         returnHexWithout(tempRadioString[x], tempLongString);
2911:switcherator.c ****         strcat(statusMsg, tempLongString);
2912:switcherator.c ****     }
2913:switcherator.c ****     sendMessage(statusMsg);
2914:switcherator.c **** }
2915:switcherator.c **** 
2916:switcherator.c **** // change the radio address
2917:switcherator.c **** // send receive addresses
2918:switcherator.c **** //static uint64_t rx_addr_p0, rx_addr_p1, rx_addr_p2, rx_addr_p3, rx_addr_p4, rx_addr_p5, tx_addr;
2919:switcherator.c **** 
2920:switcherator.c **** //RD:N RC:N 0xnnnnnnnnnn
2921:switcherator.c **** //     01234567890123456
2922:switcherator.c **** 
2923:switcherator.c **** void radioChangeAddress(char * commandReceived) {
2924:switcherator.c ****     int x = 0;
2925:switcherator.c ****     statusMsg[0] = 0;
2926:switcherator.c ****     int tempInt = 0;
2927:switcherator.c ****     uint64_t newAddress = 0;
2928:switcherator.c ****     char tempString[] = "0x00";
2929:switcherator.c ****     char tempRadioString[] = "00000";
2930:switcherator.c ****     for (x = 0; x < 5; x++) {
2931:switcherator.c ****         tempString[2] = commandReceived[((x * 2) + 7)];
2932:switcherator.c ****         tempString[3] = commandReceived[((x * 2) + 8)];
2933:switcherator.c ****         tempInt = strtol(tempString, 0, 0);
2934:switcherator.c ****         newAddress |= tempInt;
2935:switcherator.c ****         if (x < 4)
2936:switcherator.c ****             newAddress <<= 8;
2937:switcherator.c ****     }
2938:switcherator.c ****     switch (commandReceived[3]) {
2939:switcherator.c ****         case '0':
2940:switcherator.c ****             rx_addr_p0 = newAddress;
2941:switcherator.c ****             strcat(statusMsg, "r0 0x");
2942:switcherator.c ****             writeAddr(RX_ADDR_P0, newAddress);
2943:switcherator.c ****             break;
2944:switcherator.c ****         case '1':
2945:switcherator.c ****             rx_addr_p1 = newAddress;
2946:switcherator.c ****             strcat(statusMsg, "r1 0x");
2947:switcherator.c ****             writeAddr(RX_ADDR_P1, newAddress);
2948:switcherator.c ****             break;
2949:switcherator.c ****         case '2':
2950:switcherator.c ****             rx_addr_p2 = newAddress;
2951:switcherator.c ****             strcat(statusMsg, "r2 0x");
2952:switcherator.c ****             writeAddr(RX_ADDR_P2, newAddress);
2953:switcherator.c ****             break;
2954:switcherator.c ****         case '3':
2955:switcherator.c ****             rx_addr_p3 = newAddress;
2956:switcherator.c ****             strcat(statusMsg, "r3 0x");
2957:switcherator.c ****             writeAddr(RX_ADDR_P3, newAddress);
2958:switcherator.c ****             break;
2959:switcherator.c ****         case '4':
2960:switcherator.c ****             rx_addr_p4 = newAddress;
2961:switcherator.c ****             strcat(statusMsg, "r4 0x");
2962:switcherator.c ****             writeAddr(RX_ADDR_P4, newAddress);
2963:switcherator.c ****             break;
2964:switcherator.c ****         case '5':
2965:switcherator.c ****             rx_addr_p5 = newAddress;
2966:switcherator.c ****             strcat(statusMsg, "r5 0x");
2967:switcherator.c ****             writeAddr(RX_ADDR_P5, newAddress);
2968:switcherator.c ****             break;
2969:switcherator.c ****         case 'T':
2970:switcherator.c ****             tx_addr = newAddress;
2971:switcherator.c ****             strcat(statusMsg, "t 0x");
2972:switcherator.c ****             writeAddr(TX_ADDR, newAddress);
2973:switcherator.c ****             break;
2974:switcherator.c ****     }
2975:switcherator.c ****     unformatAddress(newAddress, tempRadioString);
2976:switcherator.c ****     for (x = 0; x < 5; x++) {
2977:switcherator.c ****         returnHexWithout(tempRadioString[x], tempLongString);
2978:switcherator.c ****         strcat(statusMsg, tempLongString);
2979:switcherator.c ****     }
2980:switcherator.c ****     sendMessage(statusMsg);
2981:switcherator.c **** }
2982:switcherator.c **** 
2983:switcherator.c **** // sets or views the serial number
2984:switcherator.c **** // SE nnnnnn
2985:switcherator.c **** // 012345678
2986:switcherator.c **** 
2987:switcherator.c **** void serialNumber(char * commandReceived) {
2988:switcherator.c ****     tempHugeString[0] = commandReceived[3];
2989:switcherator.c ****     tempHugeString[1] = commandReceived[4];
2990:switcherator.c ****     tempHugeString[2] = commandReceived[5];
2991:switcherator.c ****     tempHugeString[3] = commandReceived[6];
2992:switcherator.c ****     tempHugeString[4] = commandReceived[7];
2993:switcherator.c ****     tempHugeString[5] = commandReceived[8];
2994:switcherator.c ****     long temp = atol(tempHugeString);
2995:switcherator.c ****     int serialLength = 0;
2996:switcherator.c ****     statusMsg[0] = 0;
2997:switcherator.c ****     //since a 0 serial number is not valid that means to return the serial number
2998:switcherator.c ****     strcat(statusMsg, "Ser#");
2999:switcherator.c ****     if (temp > 0) {
3000:switcherator.c ****         // new serial number
3001:switcherator.c ****         serial = temp;
3002:switcherator.c ****         ltoa(serial, stringSerial, 10);
3003:switcherator.c **** 
3004:switcherator.c ****     }
3005:switcherator.c ****     serialLength = strlen(stringSerial);
3006:switcherator.c ****     while (serialLength < 6) {
3007:switcherator.c ****         strcat(statusMsg, "0");
3008:switcherator.c ****         serialLength++;
3009:switcherator.c ****     }
3010:switcherator.c ****     strcat(statusMsg, stringSerial);
3011:switcherator.c ****     sendMessage(statusMsg);
3012:switcherator.c **** }
3013:switcherator.c **** 
3014:switcherator.c **** // take the int and return the array
3015:switcherator.c **** 
3016:switcherator.c **** void unformatAddress(uint64_t oldAddress, char * formattedAddress) {
 3863               		.loc 1 3016 0
 3864               	.LVL269:
 3865 16a4 0F93      		push r16
 3866               	.LCFI94:
 3867 16a6 1F93      		push r17
 3868               	.LCFI95:
 3869               	/* prologue: function */
 3870               	/* frame size = 0 */
 3871               	/* stack size = 2 */
 3872               	.L__stack_usage = 2
 3873 16a8 F801      		movw r30,r16
 3874               	.LVL270:
3017:switcherator.c ****     uint64_t tempInt = oldAddress;
3018:switcherator.c ****     formattedAddress[4] = (tempInt & 0xff);
 3875               		.loc 1 3018 0
 3876 16aa 2483      		std Z+4,r18
3019:switcherator.c ****     tempInt >>= 8;
 3877               		.loc 1 3019 0
 3878 16ac 08E0      		ldi r16,lo8(8)
 3879               	.LVL271:
 3880 16ae 0E94 0000 		call __lshrdi3
 3881               	.LVL272:
3020:switcherator.c ****     formattedAddress[3] = (tempInt & 0xff);
 3882               		.loc 1 3020 0
 3883 16b2 2383      		std Z+3,r18
3021:switcherator.c ****     tempInt >>= 8;
 3884               		.loc 1 3021 0
 3885 16b4 0E94 0000 		call __lshrdi3
 3886               	.LVL273:
3022:switcherator.c ****     formattedAddress[2] = (tempInt & 0xff);
 3887               		.loc 1 3022 0
 3888 16b8 2283      		std Z+2,r18
3023:switcherator.c ****     tempInt >>= 8;
 3889               		.loc 1 3023 0
 3890 16ba 0E94 0000 		call __lshrdi3
 3891               	.LVL274:
3024:switcherator.c ****     formattedAddress[1] = (tempInt & 0xff);
 3892               		.loc 1 3024 0
 3893 16be 2183      		std Z+1,r18
 3894               	.LVL275:
3025:switcherator.c ****     tempInt >>= 8;
 3895               		.loc 1 3025 0
 3896 16c0 0E94 0000 		call __lshrdi3
 3897               	.LVL276:
3026:switcherator.c ****     formattedAddress[0] = (tempInt & 0xff);
 3898               		.loc 1 3026 0
 3899 16c4 2083      		st Z,r18
 3900               	/* epilogue start */
3027:switcherator.c **** }
 3901               		.loc 1 3027 0
 3902 16c6 1F91      		pop r17
 3903 16c8 0F91      		pop r16
 3904 16ca 0895      		ret
 3905               	.LFE71:
 3907               	.global	getInput
 3909               	getInput:
 3910               	.LFB77:
3028:switcherator.c **** 
3029:switcherator.c **** void sendMessage(char * myResponse) {
3030:switcherator.c ****     _delay_us(100);
3031:switcherator.c ****     int transmitLength = strlen(myResponse);
3032:switcherator.c ****     if(!transmit(myResponse, transmitLength)) {
3033:switcherator.c ****         failCondition = 2;
3034:switcherator.c ****     } else {
3035:switcherator.c ****         failCondition = 0;
3036:switcherator.c ****         clearFail();
3037:switcherator.c ****     }
3038:switcherator.c ****     startRx();
3039:switcherator.c **** }
3040:switcherator.c **** 
3041:switcherator.c **** 
3042:switcherator.c **** /****************************************************************
3043:switcherator.c ****  *
3044:switcherator.c ****  *              All Things Input Related
3045:switcherator.c ****  *
3046:switcherator.c ****  ****************************************************************/
3047:switcherator.c **** 
3048:switcherator.c **** // sets up an input on one of the analog pins
3049:switcherator.c **** // DI:##Ppx?##DuraPO
3050:switcherator.c **** // AI:##PpLLLHHH?##DuraPOw
3051:switcherator.c **** // 0123456789012345678901234
3052:switcherator.c **** // int Port/pin like switches, low%,high%, switch/program, dur, poll time
3053:switcherator.c **** // inputs[NUM_INPUTS]
3054:switcherator.c **** 
3055:switcherator.c **** void setAnalogInput(char * commandReceived) {
3056:switcherator.c ****     int x = 0;
3057:switcherator.c ****     int inputNumber, lowPercent, highPercent, pollTime, outputNum, duration;
3058:switcherator.c ****     char pin = 0;
3059:switcherator.c ****     inputNumber = lowPercent = highPercent = pollTime = outputNum = duration = 0;
3060:switcherator.c ****     int switchNumber = 0;
3061:switcherator.c ****     long temp = 0;
3062:switcherator.c ****     char whichRGB = 0;
3063:switcherator.c ****     tempIntString[0] = commandReceived[3];
3064:switcherator.c ****     tempIntString[1] = commandReceived[4];
3065:switcherator.c ****     inputNumber = atoi(tempIntString);
3066:switcherator.c ****     if (inputNumber >= NUM_INPUTS) {
3067:switcherator.c ****         fail(0x11);
3068:switcherator.c ****         return;
3069:switcherator.c ****     }
3070:switcherator.c ****     tempIntString[0] = '0';
3071:switcherator.c ****     tempIntString[1] = commandReceived[6];
3072:switcherator.c ****     pin = atoi(tempIntString);
3073:switcherator.c ****     if (pin > 7) {
3074:switcherator.c ****         fail(0x04);
3075:switcherator.c ****         return;
3076:switcherator.c ****     }
3077:switcherator.c **** 
3078:switcherator.c ****     tempIntString[0] = commandReceived[14];
3079:switcherator.c ****     tempIntString[1] = commandReceived[15];
3080:switcherator.c ****     switchNumber = atoi(tempIntString);
3081:switcherator.c **** 
3082:switcherator.c ****     tempIntString[0] = commandReceived[20];
3083:switcherator.c ****     tempIntString[1] = commandReceived[21];
3084:switcherator.c ****     pollTime = atoi(tempIntString);
3085:switcherator.c **** 
3086:switcherator.c ****     tempIntString[0] = '0';
3087:switcherator.c ****     tempIntString[1] = commandReceived[22];
3088:switcherator.c ****     whichRGB = atoi(tempIntString);
3089:switcherator.c **** 
3090:switcherator.c ****     tempLongString[0] = '0';
3091:switcherator.c ****     tempLongString[1] = commandReceived[7];
3092:switcherator.c ****     tempLongString[2] = commandReceived[8];
3093:switcherator.c ****     tempLongString[3] = commandReceived[9];
3094:switcherator.c ****     lowPercent = atoi(tempLongString);
3095:switcherator.c ****     tempLongString[1] = commandReceived[10];
3096:switcherator.c ****     tempLongString[2] = commandReceived[11];
3097:switcherator.c ****     tempLongString[3] = commandReceived[12];
3098:switcherator.c ****     highPercent = atoi(tempLongString);
3099:switcherator.c **** 
3100:switcherator.c ****     tempLongString[0] = commandReceived[16];
3101:switcherator.c ****     tempLongString[1] = commandReceived[17];
3102:switcherator.c ****     tempLongString[2] = commandReceived[18];
3103:switcherator.c ****     tempLongString[3] = commandReceived[19];
3104:switcherator.c ****     duration = atoi(tempLongString);
3105:switcherator.c **** 
3106:switcherator.c ****     // pLHsDDP p int pin/port like sw, L%,H% (0,255 - digital), s - 0-127=switch, 128-255 = prog
3107:switcherator.c ****     // 0123456
3108:switcherator.c ****     // dur in seconds, poll time in secs or  0 for continuous. 
3109:switcherator.c ****     // #= analogIn num, p=pin, LLL=low%, HHH=High%,? = 'P'rog or 'S', ## = num
3110:switcherator.c ****     // Durat. = duration in seconds, POLL = poll time in seconds or 0 for 1/10
3111:switcherator.c ****     if (commandReceived[5] != 'C' && commandReceived[5] != 'c') {
3112:switcherator.c ****         fail(0x03);
3113:switcherator.c ****         return;
3114:switcherator.c ****     }
3115:switcherator.c ****     // Port / Pin
3116:switcherator.c ****     // value of 255 (default) means nothing programmed
3117:switcherator.c ****     // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
3118:switcherator.c ****     // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
3119:switcherator.c ****     // pin is abs(value/2)-the base - PINB3 = (22-16)/2  PINB3 (22-16)%2 = 0 - low (23-16)%2 = 1 - 
3120:switcherator.c ****     // port is C.  This is analog in so its not normal but need to set the DDR anyway
3121:switcherator.c ****     // get the pin
3122:switcherator.c ****     temp = pin * 2;
3123:switcherator.c ****     // add # for port C
3124:switcherator.c ****     temp += 32;
3125:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
3126:switcherator.c ****         if (switchStuff[x] == temp) {
3127:switcherator.c **** 
3128:switcherator.c ****             fail(0x12);
3129:switcherator.c ****             return;
3130:switcherator.c ****         }
3131:switcherator.c ****     }
3132:switcherator.c ****     inputs[inputNumber][0] = temp;
3133:switcherator.c ****     DDRC &= ~(1 << pin);
3134:switcherator.c ****     temp = lowPercent;
3135:switcherator.c ****     temp = temp * 255;
3136:switcherator.c ****     temp = temp / 100;
3137:switcherator.c ****     inputs[inputNumber][1] = temp;
3138:switcherator.c ****     temp = highPercent;
3139:switcherator.c ****     temp = temp * 255;
3140:switcherator.c ****     temp = temp / 100;
3141:switcherator.c ****     if (temp == 255) // if the top is 255 we need it to be 254 so its not digital
3142:switcherator.c ****         temp = 254;
3143:switcherator.c **** 
3144:switcherator.c ****     inputs[inputNumber][2] = temp;
3145:switcherator.c ****     // 128 switches and 128 programs possible
3146:switcherator.c ****     if (commandReceived[13] == 'P' || commandReceived[13] == 'p') {
3147:switcherator.c ****         switchNumber += 128;
3148:switcherator.c ****     }
3149:switcherator.c ****     inputs[inputNumber][3] = switchNumber;
3150:switcherator.c ****     temp = duration >> 8;
3151:switcherator.c ****     inputs[inputNumber][4] = temp;
3152:switcherator.c ****     temp = duration & 0xff;
3153:switcherator.c ****     inputs[inputNumber][5] = temp;
3154:switcherator.c **** 
3155:switcherator.c **** 
3156:switcherator.c ****     if (pollTime > 255)
3157:switcherator.c ****         pollTime = 255;
3158:switcherator.c ****     inputs[inputNumber][6] = pollTime;
3159:switcherator.c **** 
3160:switcherator.c ****     // if we are using a RGB switch then which ones do we activate (mask)
3161:switcherator.c ****     if (whichRGB > 7)
3162:switcherator.c ****         whichRGB = 7;
3163:switcherator.c ****     inputs[inputNumber][7] = whichRGB;
3164:switcherator.c **** 
3165:switcherator.c **** 
3166:switcherator.c ****     // set ADMUX when we do a conversion
3167:switcherator.c ****     // Set prescaler 1/32. why not... ;-)
3168:switcherator.c ****     ADCSRA |= (1 << ADPS2) || (1 << ADPS0);
3169:switcherator.c **** 
3170:switcherator.c **** 
3171:switcherator.c ****     ok();
3172:switcherator.c **** }
3173:switcherator.c **** 
3174:switcherator.c **** // set up an input on a regular pin
3175:switcherator.c **** // DI:##Ppx?##DuraPO
3176:switcherator.c **** // 012345678901234567890
3177:switcherator.c **** // #=digital in num, P=Port,p=pin, x=High or Low, ?='P'rog or 'S'witch,
3178:switcherator.c **** // ## = prog/switch num, Durat.=duration in seconds, POLL=poll time in sec or 0 for 1/10
3179:switcherator.c **** 
3180:switcherator.c **** void setDigitalInput(char * commandReceived) {
3181:switcherator.c ****     int x = 0;
3182:switcherator.c ****     int inputNumber, pollTime, outputNum, duration;
3183:switcherator.c ****     volatile unsigned char *realDDR = 0;
3184:switcherator.c ****     volatile unsigned char *realPort = 0;
3185:switcherator.c ****     char pin = 0;
3186:switcherator.c ****     inputNumber = pollTime = outputNum = duration = 0;
3187:switcherator.c ****     int switchNumber = 0;
3188:switcherator.c ****     int temp = 0;
3189:switcherator.c ****     tempIntString[0] = commandReceived[3];
3190:switcherator.c ****     tempIntString[1] = commandReceived[4];
3191:switcherator.c ****     inputNumber = atoi(tempIntString);
3192:switcherator.c ****     if (inputNumber >= NUM_INPUTS) {
3193:switcherator.c ****         fail(0x11);
3194:switcherator.c ****         return;
3195:switcherator.c ****     }
3196:switcherator.c ****     tempIntString[0] = '0';
3197:switcherator.c ****     tempIntString[1] = commandReceived[6];
3198:switcherator.c ****     pin = atoi(tempIntString);
3199:switcherator.c ****     if (pin > 7) {
3200:switcherator.c ****         fail(0x04);
3201:switcherator.c ****         return;
3202:switcherator.c ****     }
3203:switcherator.c **** 
3204:switcherator.c ****     tempIntString[0] = commandReceived[9];
3205:switcherator.c ****     tempIntString[1] = commandReceived[10];
3206:switcherator.c ****     switchNumber = atoi(tempIntString);
3207:switcherator.c **** 
3208:switcherator.c ****     tempIntString[0] = commandReceived[15];
3209:switcherator.c ****     tempIntString[1] = commandReceived[16];
3210:switcherator.c ****     pollTime = atoi(tempIntString);
3211:switcherator.c **** 
3212:switcherator.c ****     tempLongString[0] = commandReceived[11];
3213:switcherator.c ****     tempLongString[1] = commandReceived[12];
3214:switcherator.c ****     tempLongString[2] = commandReceived[13];
3215:switcherator.c ****     tempLongString[3] = commandReceived[14];
3216:switcherator.c ****     duration = atoi(tempLongString);
3217:switcherator.c ****     // if we are activating a program
3218:switcherator.c ****     if (commandReceived[8] == 'P' || commandReceived[8] == 'p') {
3219:switcherator.c ****         switchNumber += 128;
3220:switcherator.c ****     }
3221:switcherator.c ****     temp = pin * 2;
3222:switcherator.c ****     if (commandReceived[5] == 'B' || commandReceived[5] == 'b') {
3223:switcherator.c ****         realDDR = &DDRB;
3224:switcherator.c ****         realPort = &PORTB;
3225:switcherator.c ****         temp += 16;
3226:switcherator.c **** #ifdef PORTA
3227:switcherator.c ****     } else if (commandReceived[5] == 'A' || commandReceived[5] == 'a') {
3228:switcherator.c ****         realDDR = &DDRA;
3229:switcherator.c ****         realPort = &PORTA;
3230:switcherator.c ****         temp += 0;
3231:switcherator.c **** #endif        
3232:switcherator.c **** #ifdef PORTC
3233:switcherator.c ****     } else if (commandReceived[5] == 'C' || commandReceived[5] == 'c') {
3234:switcherator.c ****         realDDR = &DDRC;
3235:switcherator.c ****         realPort = &PORTC;
3236:switcherator.c ****         temp += 32;
3237:switcherator.c **** #endif        
3238:switcherator.c **** #ifdef PORTD
3239:switcherator.c ****     } else if (commandReceived[5] == 'D' || commandReceived[5] == 'd') {
3240:switcherator.c ****         realDDR = &DDRD;
3241:switcherator.c ****         realPort = &PORTD;
3242:switcherator.c ****         temp += 48;
3243:switcherator.c **** #endif        
3244:switcherator.c **** #ifdef PORTE
3245:switcherator.c ****     } else if (commandReceived[5] == 'E' || commandReceived[5] == 'e') {
3246:switcherator.c ****         realDDR = &DDRE;
3247:switcherator.c ****         realPort = &PORTE;
3248:switcherator.c ****         temp += 64;
3249:switcherator.c **** #endif        
3250:switcherator.c **** #ifdef PORTF
3251:switcherator.c ****     } else if (commandReceived[5] == 'F' || commandReceived[5] == 'f') {
3252:switcherator.c ****         realDDR = &DDRF;
3253:switcherator.c ****         realPort = &PORTF;
3254:switcherator.c ****         temp += 80;
3255:switcherator.c **** #endif        
3256:switcherator.c **** #ifdef PORTG
3257:switcherator.c ****     } else if (commandReceived[5] == 'G' || commandReceived[5] == 'g') {
3258:switcherator.c ****         realDDR = &DDRG;
3259:switcherator.c ****         realPort = &PORTG;
3260:switcherator.c ****         temp += 96;
3261:switcherator.c **** #endif        
3262:switcherator.c **** #ifdef PORTH
3263:switcherator.c ****     } else if (commandReceived[5] == 'H' || commandReceived[5] == 'h') {
3264:switcherator.c ****         realDDR = &DDRH;
3265:switcherator.c ****         realPort = &PORTH;
3266:switcherator.c ****         temp += 112;
3267:switcherator.c **** #endif        
3268:switcherator.c **** #ifdef PORTI
3269:switcherator.c ****     } else if (commandReceived[5] == 'I' || commandReceived[5] == 'i') {
3270:switcherator.c ****         realDDR = &DDRI;
3271:switcherator.c ****         realPort = &PORTI;
3272:switcherator.c ****         temp += 128;
3273:switcherator.c **** #endif        
3274:switcherator.c ****     }
3275:switcherator.c ****     // value of 255 (default) means nothing programmed
3276:switcherator.c ****     // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
3277:switcherator.c ****     // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
3278:switcherator.c ****     // pin is abs(value/2)-the base - PINB3 = (22-16)/2  PINB3 (22-16)%2 = 0 - low (23-16)%2 = 1 - 
3279:switcherator.c ****     // port is C.  This is analog in so its not normal but need to set the DDR anyway
3280:switcherator.c ****     // get the pin
3281:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
3282:switcherator.c ****         if (switchStuff[x] == temp || switchStuff[x] == (temp + 1)) {
3283:switcherator.c ****             fail(0x12);
3284:switcherator.c ****             return;
3285:switcherator.c ****         }
3286:switcherator.c ****     }
3287:switcherator.c **** 
3288:switcherator.c ****     inputs[inputNumber][0] = temp;
3289:switcherator.c **** 
3290:switcherator.c ****     if (commandReceived[7] == 'H' || commandReceived[7] == 'h' ||
3291:switcherator.c ****             commandReceived[7] == '1') {
3292:switcherator.c ****         inputs[inputNumber][1] = 0;
3293:switcherator.c ****         inputs[inputNumber][2] = 255;
3294:switcherator.c ****     } else {
3295:switcherator.c ****         inputs[inputNumber][1] = 255;
3296:switcherator.c ****         inputs[inputNumber][2] = 0;
3297:switcherator.c ****     }
3298:switcherator.c ****     inputs[inputNumber][3] = switchNumber;
3299:switcherator.c ****     temp = duration >> 8;
3300:switcherator.c ****     inputs[inputNumber][4] = temp;
3301:switcherator.c ****     temp = duration & 0xff;
3302:switcherator.c ****     inputs[inputNumber][5] = temp;
3303:switcherator.c **** 
3304:switcherator.c ****     if (pollTime > 255)
3305:switcherator.c ****         pollTime = 255;
3306:switcherator.c ****     inputs[inputNumber][6] = pollTime;
3307:switcherator.c **** 
3308:switcherator.c ****     *realDDR &= ~(1 << pin);
3309:switcherator.c ****     *realPort |= (1 << pin);
3310:switcherator.c **** 
3311:switcherator.c ****     ok();
3312:switcherator.c ****     // DI:##Ppx?##DuraPO
3313:switcherator.c ****     // 012345678901234567890
3314:switcherator.c **** }
3315:switcherator.c **** 
3316:switcherator.c **** // inputs[NUM_INPUTS] - is the following
3317:switcherator.c **** // pLHsDDP p int pin/port like sw, L%,H% (0,255 - digital), s - 0-127=switch, 128-255 = prog
3318:switcherator.c **** // 0123456
3319:switcherator.c **** // Port / Pin
3320:switcherator.c **** // value of 255 (default) means nothing programmed
3321:switcherator.c **** // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
3322:switcherator.c **** // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
3323:switcherator.c **** 
3324:switcherator.c **** // see if we check any inputs this second
3325:switcherator.c **** 
3326:switcherator.c **** void inputCheck(void) {
3327:switcherator.c ****     int x = 0;
3328:switcherator.c ****     int pollTime = 0;
3329:switcherator.c ****     // figure out if we care about our inputs
3330:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
3331:switcherator.c ****         // see if it is a valid input
3332:switcherator.c ****         if (inputs[x][0] == 255)
3333:switcherator.c ****             continue; // not valid. Skip
3334:switcherator.c ****         pollTime = inputs[x][6];
3335:switcherator.c ****         // see if it is one we check continuously or every second
3336:switcherator.c ****         if (pollTime == 0 || pollTime == 1) {
3337:switcherator.c ****             getInput(x);
3338:switcherator.c ****             // see if we it is the right second otherwise
3339:switcherator.c ****         } else if (weeklySeconds % pollTime == 0) {
3340:switcherator.c ****             getInput(x);
3341:switcherator.c ****         }
3342:switcherator.c ****     }
3343:switcherator.c **** }
3344:switcherator.c **** 
3345:switcherator.c **** // see if we check inputs continuously (every 10th)
3346:switcherator.c **** 
3347:switcherator.c **** void inputTenthCheck(void) {
3348:switcherator.c ****     int x = 0;
3349:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
3350:switcherator.c ****         // see if it is valid and marked continuously
3351:switcherator.c ****         if (inputs[x][0] != 255 && inputs[x][6] == 0)
3352:switcherator.c ****             getInput(x);
3353:switcherator.c ****     }
3354:switcherator.c **** }
3355:switcherator.c **** 
3356:switcherator.c **** // inputs[NUM_INPUTS] - is the following
3357:switcherator.c **** // pLHsDDPw p int pin/port like sw, L%,H% (0,255 - digital), s - 0-127=switch, 128-255 = prog
3358:switcherator.c **** // 01234567 - w= which analog out if needed
3359:switcherator.c **** // Port / Pin
3360:switcherator.c **** // value of 255 (default) means nothing programmed
3361:switcherator.c **** // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
3362:switcherator.c **** // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
3363:switcherator.c **** 
3364:switcherator.c **** 
3365:switcherator.c **** // actually check the input and do something based on that
3366:switcherator.c **** 
3367:switcherator.c **** void getInput(int inputNumber) {
 3911               		.loc 1 3367 0
 3912               	.LVL277:
 3913 16cc 2F92      		push r2
 3914               	.LCFI96:
 3915 16ce 3F92      		push r3
 3916               	.LCFI97:
 3917 16d0 4F92      		push r4
 3918               	.LCFI98:
 3919 16d2 5F92      		push r5
 3920               	.LCFI99:
 3921 16d4 6F92      		push r6
 3922               	.LCFI100:
 3923 16d6 7F92      		push r7
 3924               	.LCFI101:
 3925 16d8 8F92      		push r8
 3926               	.LCFI102:
 3927 16da 9F92      		push r9
 3928               	.LCFI103:
 3929 16dc AF92      		push r10
 3930               	.LCFI104:
 3931 16de BF92      		push r11
 3932               	.LCFI105:
 3933 16e0 CF92      		push r12
 3934               	.LCFI106:
 3935 16e2 DF92      		push r13
 3936               	.LCFI107:
 3937 16e4 EF92      		push r14
 3938               	.LCFI108:
 3939 16e6 FF92      		push r15
 3940               	.LCFI109:
 3941 16e8 0F93      		push r16
 3942               	.LCFI110:
 3943 16ea 1F93      		push r17
 3944               	.LCFI111:
 3945 16ec CF93      		push r28
 3946               	.LCFI112:
 3947 16ee DF93      		push r29
 3948               	.LCFI113:
 3949 16f0 CDB7      		in r28,__SP_L__
 3950 16f2 DEB7      		in r29,__SP_H__
 3951               	.LCFI114:
 3952 16f4 2C97      		sbiw r28,12
 3953               	.LCFI115:
 3954 16f6 0FB6      		in __tmp_reg__,__SREG__
 3955 16f8 F894      		cli
 3956 16fa DEBF      		out __SP_H__,r29
 3957 16fc 0FBE      		out __SREG__,__tmp_reg__
 3958 16fe CDBF      		out __SP_L__,r28
 3959               	/* prologue: function */
 3960               	/* frame size = 12 */
 3961               	/* stack size = 30 */
 3962               	.L__stack_usage = 30
 3963 1700 FC01      		movw r30,r24
 3964               	.LVL278:
3368:switcherator.c ****     int x = 0;
3369:switcherator.c ****     unsigned int outputNum, duration, low, high, switchNumber;
3370:switcherator.c ****     volatile unsigned char *thisPin = 0;
3371:switcherator.c ****     long temp = 0;
3372:switcherator.c ****     char test = 0;
3373:switcherator.c ****     char pwmValue = 0;
3374:switcherator.c ****     char whichRGB = 0;
3375:switcherator.c ****     // set up how many seconds are at the beginning of today
3376:switcherator.c ****     long daySeconds = (dow * 86400);
 3965               		.loc 1 3376 0
 3966 1702 2090 0000 		lds r2,dow
 3967 1706 3090 0000 		lds r3,dow+1
 3968 170a 2101      		movw r4,r2
 3969 170c 612C      		mov r6,__zero_reg__
 3970 170e 712C      		mov r7,__zero_reg__
 3971 1710 A301      		movw r20,r6
 3972 1712 9201      		movw r18,r4
 3973 1714 60E8      		ldi r22,lo8(-128)
 3974 1716 71E5      		ldi r23,lo8(81)
 3975 1718 81E0      		ldi r24,lo8(1)
 3976 171a 90E0      		ldi r25,0
 3977 171c 0E94 0000 		call __mulsi3
 3978 1720 4B01      		movw r8,r22
 3979 1722 5C01      		movw r10,r24
 3980               	.LVL279:
3377:switcherator.c ****     long startTime, stopTime;
3378:switcherator.c ****     startTime = stopTime = 0;
3379:switcherator.c ****     outputNum = duration = low = high = switchNumber = 0;
3380:switcherator.c ****     outputNum = inputs[inputNumber][0];
 3981               		.loc 1 3380 0
 3982 1724 43E0      		ldi r20,3
 3983               		1:
 3984 1726 EE0F      		lsl r30
 3985 1728 FF1F      		rol r31
 3986 172a 4A95      		dec r20
 3987 172c 01F4      		brne 1b
 3988 172e E050      		subi r30,lo8(-(inputs))
 3989 1730 F040      		sbci r31,hi8(-(inputs))
 3990 1732 6081      		ld r22,Z
 3991               	.LVL280:
3381:switcherator.c ****     low = inputs[inputNumber][1];
 3992               		.loc 1 3381 0
 3993 1734 C180      		ldd r12,Z+1
 3994 1736 EC2C      		mov r14,r12
 3995 1738 F12C      		mov r15,__zero_reg__
 3996               	.LVL281:
3382:switcherator.c ****     high = inputs[inputNumber][2];
 3997               		.loc 1 3382 0
 3998 173a 0281      		ldd r16,Z+2
 3999 173c 0983      		std Y+1,r16
 4000               	.LVL282:
3383:switcherator.c ****     switchNumber = inputs[inputNumber][3];
 4001               		.loc 1 3383 0
 4002 173e 0381      		ldd r16,Z+3
 4003               	.LVL283:
 4004 1740 10E0      		ldi r17,0
 4005               	.LVL284:
3384:switcherator.c ****     temp = inputs[inputNumber][4];
3385:switcherator.c ****     duration = (temp << 8);
 4006               		.loc 1 3385 0
 4007 1742 3481      		ldd r19,Z+4
 4008 1744 20E0      		ldi r18,0
3386:switcherator.c ****     temp = inputs[inputNumber][5];
3387:switcherator.c ****     duration |= temp;
 4009               		.loc 1 3387 0
 4010 1746 8581      		ldd r24,Z+5
 4011               	.LVL285:
 4012 1748 A901      		movw r20,r18
 4013 174a 482B      		or r20,r24
 4014 174c 5C87      		std Y+12,r21
 4015 174e 4B87      		std Y+11,r20
 4016               	.LVL286:
3388:switcherator.c ****     whichRGB = inputs[inputNumber][7];
 4017               		.loc 1 3388 0
 4018 1750 D780      		ldd r13,Z+7
 4019               	.LVL287:
3389:switcherator.c ****     // if this is an analog input than both the low% or the high% will not be 255
3390:switcherator.c ****     if (low != 255 && high != 255) {
 4020               		.loc 1 3390 0
 4021 1752 5FEF      		ldi r21,-1
 4022 1754 E516      		cp r14,r21
 4023 1756 F104      		cpc r15,__zero_reg__
 4024 1758 01F4      		brne .+2
 4025 175a 00C0      		rjmp .L262
3382:switcherator.c ****     high = inputs[inputNumber][2];
 4026               		.loc 1 3382 0 discriminator 1
 4027 175c F981      		ldd r31,Y+1
 4028 175e EF2F      		mov r30,r31
 4029               	.LVL288:
 4030 1760 F0E0      		ldi r31,0
 4031 1762 FA87      		std Y+10,r31
 4032 1764 E987      		std Y+9,r30
 4033               		.loc 1 3390 0 discriminator 1
 4034 1766 EF3F      		cpi r30,-1
 4035 1768 F105      		cpc r31,__zero_reg__
 4036 176a 01F4      		brne .+2
 4037 176c 00C0      		rjmp .L262
3380:switcherator.c ****     outputNum = inputs[inputNumber][0];
 4038               		.loc 1 3380 0
 4039 176e 70E0      		ldi r23,0
3391:switcherator.c ****         // this is an analog input
3392:switcherator.c ****         // currently only port C is supported for analog inputs
3393:switcherator.c ****         temp = outputNum - 32;
 4040               		.loc 1 3393 0
 4041 1770 6052      		subi r22,32
 4042 1772 7109      		sbc r23,__zero_reg__
 4043               	.LVL289:
 4044 1774 CB01      		movw r24,r22
 4045 1776 A0E0      		ldi r26,0
 4046 1778 B0E0      		ldi r27,0
 4047               	.LVL290:
3394:switcherator.c ****         temp = temp / 2;
 4048               		.loc 1 3394 0
 4049 177a B595      		asr r27
 4050 177c A795      		ror r26
 4051 177e 9795      		ror r25
 4052 1780 8795      		ror r24
 4053               	.LVL291:
3395:switcherator.c ****         if (temp > 7) // if things got goofed up somehow 
 4054               		.loc 1 3395 0
 4055 1782 8830      		cpi r24,8
 4056 1784 9105      		cpc r25,__zero_reg__
 4057 1786 A105      		cpc r26,__zero_reg__
 4058 1788 B105      		cpc r27,__zero_reg__
 4059 178a 04F0      		brlt .+2
 4060 178c 00C0      		rjmp .L261
3396:switcherator.c ****             return;
3397:switcherator.c ****         ADMUX = temp; // which pin to check
 4061               		.loc 1 3397 0
 4062 178e 8093 7C00 		sts 124,r24
3398:switcherator.c ****         ADCSRA |= (1 << ADEN) | (1 << ADSC); // turn on ADC and start a conversion
 4063               		.loc 1 3398 0
 4064 1792 8091 7A00 		lds r24,122
 4065               	.LVL292:
 4066 1796 806C      		ori r24,lo8(-64)
 4067 1798 8093 7A00 		sts 122,r24
 4068               	.L265:
3399:switcherator.c ****         loop_until_bit_is_set(ADCSRA, ADIF);
 4069               		.loc 1 3399 0 discriminator 1
 4070 179c 8091 7A00 		lds r24,122
 4071 17a0 84FF      		sbrs r24,4
 4072 17a2 00C0      		rjmp .L265
3400:switcherator.c ****         temp = ADC;
 4073               		.loc 1 3400 0
 4074 17a4 2091 7800 		lds r18,120
 4075 17a8 3091 7900 		lds r19,120+1
 4076               	.LVL293:
3401:switcherator.c ****         temp = temp * 255;
 4077               		.loc 1 3401 0
 4078 17ac AFEF      		ldi r26,lo8(-1)
 4079 17ae B0E0      		ldi r27,0
 4080 17b0 0E94 0000 		call __umulhisi3
 4081               	.LVL294:
3402:switcherator.c ****         temp = temp / 1024; // now its a number between 0 and 255;
 4082               		.loc 1 3402 0
 4083 17b4 2AE0      		ldi r18,10
 4084               		1:
 4085 17b6 9595      		asr r25
 4086 17b8 8795      		ror r24
 4087 17ba 7795      		ror r23
 4088 17bc 6795      		ror r22
 4089 17be 2A95      		dec r18
 4090 17c0 01F4      		brne 1b
 4091               	.LVL295:
3403:switcherator.c ****         ADCSRA |= (1 << ADIF); // clear the ADC
 4092               		.loc 1 3403 0
 4093 17c2 2091 7A00 		lds r18,122
 4094 17c6 2061      		ori r18,lo8(16)
 4095 17c8 2093 7A00 		sts 122,r18
3404:switcherator.c ****         // see if we are turning on the switch
3405:switcherator.c ****         if (temp > low && temp < (high + 1)) {
 4096               		.loc 1 3405 0
 4097 17cc 4C2C      		mov r4,r12
 4098 17ce 512C      		mov r5,__zero_reg__
 4099 17d0 612C      		mov r6,__zero_reg__
 4100 17d2 712C      		mov r7,__zero_reg__
 4101 17d4 4616      		cp r4,r22
 4102 17d6 5706      		cpc r5,r23
 4103 17d8 6806      		cpc r6,r24
 4104 17da 7906      		cpc r7,r25
 4105 17dc 04F0      		brlt .+2
 4106 17de 00C0      		rjmp .L261
 4107               		.loc 1 3405 0 is_stmt 0 discriminator 1
 4108 17e0 A985      		ldd r26,Y+9
 4109 17e2 BA85      		ldd r27,Y+10
 4110 17e4 1196      		adiw r26,1
 4111 17e6 9D01      		movw r18,r26
 4112 17e8 40E0      		ldi r20,0
 4113 17ea 50E0      		ldi r21,0
 4114               	.LVL296:
 4115 17ec 6217      		cp r22,r18
 4116 17ee 7307      		cpc r23,r19
 4117 17f0 8407      		cpc r24,r20
 4118 17f2 9507      		cpc r25,r21
 4119 17f4 04F0      		brlt .+2
 4120 17f6 00C0      		rjmp .L261
3406:switcherator.c ****             // see if it is a PWM switch (not a program)
3407:switcherator.c ****             if (switchNumber < 128 && switchStuff[switchNumber] == 200) {
 4121               		.loc 1 3407 0 is_stmt 1
 4122 17f8 0038      		cpi r16,-128
 4123 17fa 1105      		cpc r17,__zero_reg__
 4124 17fc 00F4      		brsh .L267
 4125               		.loc 1 3407 0 is_stmt 0 discriminator 1
 4126 17fe F801      		movw r30,r16
 4127               	.LVL297:
 4128 1800 E050      		subi r30,lo8(-(switchStuff))
 4129 1802 F040      		sbci r31,hi8(-(switchStuff))
 4130 1804 2081      		ld r18,Z
 4131 1806 283C      		cpi r18,lo8(-56)
 4132 1808 01F0      		breq .+2
 4133 180a 00C0      		rjmp .L298
3408:switcherator.c ****                 // this is a PWM so we're doing it based on the relative ADC value
3409:switcherator.c ****                 // see if we are using the whole range.
3410:switcherator.c ****                 if ((high - low) > 250) {
 4134               		.loc 1 3410 0 is_stmt 1
 4135 180c 4985      		ldd r20,Y+9
 4136 180e 5A85      		ldd r21,Y+10
 4137 1810 4E19      		sub r20,r14
 4138 1812 5F09      		sbc r21,r15
 4139 1814 4B3F      		cpi r20,-5
 4140 1816 5105      		cpc r21,__zero_reg__
 4141 1818 00F0      		brlo .+2
 4142 181a 00C0      		rjmp .L298
 4143               	.LVL298:
 4144               	.LBB23:
3411:switcherator.c ****                     pwmValue = temp;
3412:switcherator.c ****                 } else {
3413:switcherator.c ****                     // figure out what percentage between the values we are
3414:switcherator.c ****                     char range = high - low;
3415:switcherator.c ****                     temp = temp - low;
 4145               		.loc 1 3415 0
 4146 181c 9B01      		movw r18,r22
 4147 181e AC01      		movw r20,r24
 4148 1820 2419      		sub r18,r4
 4149 1822 3509      		sbc r19,r5
 4150 1824 4609      		sbc r20,r6
 4151 1826 5709      		sbc r21,r7
 4152               	.LVL299:
3416:switcherator.c ****                     temp = temp * 255;
 4153               		.loc 1 3416 0
 4154 1828 AFEF      		ldi r26,lo8(-1)
 4155 182a B0E0      		ldi r27,0
 4156 182c 0E94 0000 		call __muluhisi3
 4157               	.LVL300:
3414:switcherator.c ****                     char range = high - low;
 4158               		.loc 1 3414 0
 4159 1830 2981      		ldd r18,Y+1
 4160 1832 2C19      		sub r18,r12
 4161               	.LVL301:
3417:switcherator.c ****                     temp = temp / range; // now we have a relative value between 0&255
 4162               		.loc 1 3417 0
 4163 1834 30E0      		ldi r19,0
 4164 1836 40E0      		ldi r20,0
 4165 1838 50E0      		ldi r21,0
 4166 183a 0E94 0000 		call __divmodsi4
 4167               	.LVL302:
3418:switcherator.c ****                     pwmValue = temp;
 4168               		.loc 1 3418 0
 4169 183e 822F      		mov r24,r18
 4170               	.LVL303:
3419:switcherator.c ****                     // see if we are changing RGB
3420:switcherator.c ****                     if (whichRGB & 4)
 4171               		.loc 1 3420 0
 4172 1840 D2FC      		sbrc r13,2
3421:switcherator.c ****                         pwmValues[0] = pwmValue;
 4173               		.loc 1 3421 0
 4174 1842 2093 0000 		sts pwmValues,r18
 4175               	.L269:
3422:switcherator.c ****                     if (whichRGB & 2)
 4176               		.loc 1 3422 0
 4177 1846 D1FC      		sbrc r13,1
3423:switcherator.c ****                         pwmValues[1] = pwmValue;
 4178               		.loc 1 3423 0
 4179 1848 8093 0000 		sts pwmValues+1,r24
 4180               	.L270:
3424:switcherator.c ****                     if (whichRGB & 1)
 4181               		.loc 1 3424 0
 4182 184c D0FC      		sbrc r13,0
3425:switcherator.c ****                         pwmValues[2] = pwmValue;
 4183               		.loc 1 3425 0
 4184 184e 8093 0000 		sts pwmValues+2,r24
 4185               	.L271:
3426:switcherator.c ****                     if (whichRGB & 7) // if anything changed
 4186               		.loc 1 3426 0
 4187 1852 8D2D      		mov r24,r13
 4188 1854 8770      		andi r24,lo8(7)
 4189 1856 01F4      		brne .+2
 4190 1858 00C0      		rjmp .L298
3427:switcherator.c ****                         switchChanged = 1;
 4191               		.loc 1 3427 0
 4192 185a 81E0      		ldi r24,lo8(1)
 4193 185c 8093 0000 		sts switchChanged,r24
 4194 1860 00C0      		rjmp .L298
 4195               	.LVL304:
 4196               	.L267:
 4197 1862 E0E0      		ldi r30,lo8(timeLimits+8)
 4198 1864 F0E0      		ldi r31,hi8(timeLimits+8)
 4199               	.LVL305:
 4200               	.LBE23:
3367:switcherator.c **** void getInput(int inputNumber) {
 4201               		.loc 1 3367 0
 4202 1866 20E0      		ldi r18,0
 4203               	.LVL306:
 4204               	.L274:
3428:switcherator.c ****                 }
3429:switcherator.c ****             }
3430:switcherator.c ****             // k we set up PWM now make it so it switches on
3431:switcherator.c ****             if (switchNumber < 128) { // its a switch
3432:switcherator.c ****                 if (switchStatus[switchNumber] == 0) // the switch is off
3433:switcherator.c ****                     switchChanged = 1;
3434:switcherator.c ****                 if (switchStatus[switchNumber] < (weeklySeconds + duration))
3435:switcherator.c ****                     switchStatus[switchNumber] = (weeklySeconds + duration);
3436:switcherator.c ****             } else { // its a program;
3437:switcherator.c ****                 test = 0;
3438:switcherator.c ****                 // check and make sure we are within the time limits (eg dusk to dawn)
3439:switcherator.c ****                 // first if no time limits set up then ignore it
3440:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
3441:switcherator.c ****                     if (timeLimits[x][2] > 0)
 4205               		.loc 1 3441 0
 4206 1868 8081      		ld r24,Z
 4207 186a 9181      		ldd r25,Z+1
 4208 186c A281      		ldd r26,Z+2
 4209 186e B381      		ldd r27,Z+3
 4210 1870 892B      		or r24,r25
 4211 1872 8A2B      		or r24,r26
 4212 1874 8B2B      		or r24,r27
 4213 1876 01F0      		breq .L273
3442:switcherator.c ****                         test = 1;
 4214               		.loc 1 3442 0
 4215 1878 21E0      		ldi r18,lo8(1)
 4216               	.L273:
 4217               	.LVL307:
 4218 187a 3C96      		adiw r30,12
3440:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
 4219               		.loc 1 3440 0
 4220 187c 30E0      		ldi r19,hi8(timeLimits+56)
 4221 187e E030      		cpi r30,lo8(timeLimits+56)
 4222 1880 F307      		cpc r31,r19
 4223 1882 01F4      		brne .L274
3443:switcherator.c ****                 }
3444:switcherator.c ****                 // no limits set up
3445:switcherator.c ****                 if (test == 0)
 4224               		.loc 1 3445 0
 4225 1884 2111      		cpse r18,__zero_reg__
 4226 1886 00C0      		rjmp .L275
3446:switcherator.c ****                     startTheProgram((switchNumber - 128), duration, 0);
 4227               		.loc 1 3446 0
 4228 1888 20E0      		ldi r18,0
 4229 188a 30E0      		ldi r19,0
 4230 188c A901      		movw r20,r18
 4231               	.LVL308:
 4232 188e 6B85      		ldd r22,Y+11
 4233 1890 7C85      		ldd r23,Y+12
 4234               	.LVL309:
 4235 1892 C801      		movw r24,r16
 4236 1894 8058      		subi r24,-128
 4237 1896 9109      		sbc r25,__zero_reg__
 4238 1898 0E94 0000 		call startTheProgram
 4239               	.LVL310:
 4240               	.L275:
 4241 189c 80E0      		ldi r24,lo8(timeLimits)
 4242 189e E82E      		mov r14,r24
 4243 18a0 80E0      		ldi r24,hi8(timeLimits)
 4244 18a2 F82E      		mov r15,r24
 4245               	.LVL311:
3447:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
3448:switcherator.c ****                     startTime = timeLimits[x][0];
3449:switcherator.c ****                     stopTime = timeLimits[x][1];
3450:switcherator.c ****                     // deal with nights that cross midnight
3451:switcherator.c ****                     if (stopTime < startTime) {
3452:switcherator.c ****                         temp = dow;
3453:switcherator.c ****                         // weekly seconds resets at the end of the week. so do lots of 9
3454:switcherator.c ****                         if (weeklySeconds <= (stopTime + daySeconds)) {
3455:switcherator.c ****                             // k this is dow + 1
3456:switcherator.c ****                             if (temp == 0)
3457:switcherator.c ****                                 temp = 6;
3458:switcherator.c ****                             else
3459:switcherator.c ****                                 temp--;
3460:switcherator.c ****                             if (timeLimits[x][2] & (1 << temp))
3461:switcherator.c ****                                 startTheProgram((switchNumber - 128), duration, 0);
3462:switcherator.c ****                         } else if (weeklySeconds >= (startTime + daySeconds)) {
3463:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
3464:switcherator.c ****                                 startTheProgram((switchNumber - 128), duration, 0);
3465:switcherator.c ****                         }
3466:switcherator.c ****                     } else {
3467:switcherator.c ****                         if (weeklySeconds >= (startTime + daySeconds) &&
3468:switcherator.c ****                                 weeklySeconds <= (stopTime + daySeconds)) {
3469:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
 4246               		.loc 1 3469 0 discriminator 1
 4247 18a4 CC24      		clr r12
 4248 18a6 C394      		inc r12
 4249 18a8 D12C      		mov r13,__zero_reg__
3470:switcherator.c ****                                 startTheProgram((switchNumber - 128), duration, 0);
 4250               		.loc 1 3470 0 discriminator 1
 4251 18aa 0058      		subi r16,-128
 4252 18ac 1109      		sbc r17,__zero_reg__
 4253               	.LVL312:
 4254               	.L280:
3448:switcherator.c ****                     startTime = timeLimits[x][0];
 4255               		.loc 1 3448 0
 4256 18ae D701      		movw r26,r14
 4257 18b0 4D90      		ld r4,X+
 4258 18b2 5D90      		ld r5,X+
 4259 18b4 6D90      		ld r6,X+
 4260 18b6 7C90      		ld r7,X
 4261 18b8 1397      		sbiw r26,3
 4262               	.LVL313:
3449:switcherator.c ****                     stopTime = timeLimits[x][1];
 4263               		.loc 1 3449 0
 4264 18ba 1496      		adiw r26,4
 4265 18bc 4D91      		ld r20,X+
 4266 18be 5D91      		ld r21,X+
 4267 18c0 6D91      		ld r22,X+
 4268 18c2 7C91      		ld r23,X
 4269 18c4 1797      		sbiw r26,4+3
 4270               	.LVL314:
 4271 18c6 8091 0000 		lds r24,weeklySeconds
 4272 18ca 9091 0000 		lds r25,weeklySeconds+1
 4273 18ce A091 0000 		lds r26,weeklySeconds+2
 4274 18d2 B091 0000 		lds r27,weeklySeconds+3
3451:switcherator.c ****                     if (stopTime < startTime) {
 4275               		.loc 1 3451 0
 4276 18d6 4415      		cp r20,r4
 4277 18d8 5505      		cpc r21,r5
 4278 18da 6605      		cpc r22,r6
 4279 18dc 7705      		cpc r23,r7
 4280 18de 04F0      		brlt .+2
 4281 18e0 00C0      		rjmp .L276
3452:switcherator.c ****                         temp = dow;
 4282               		.loc 1 3452 0
 4283 18e2 2091 0000 		lds r18,dow
 4284 18e6 3091 0000 		lds r19,dow+1
 4285               	.LVL315:
3454:switcherator.c ****                         if (weeklySeconds <= (stopTime + daySeconds)) {
 4286               		.loc 1 3454 0
 4287 18ea 480D      		add r20,r8
 4288 18ec 591D      		adc r21,r9
 4289 18ee 6A1D      		adc r22,r10
 4290 18f0 7B1D      		adc r23,r11
 4291               	.LVL316:
 4292 18f2 4817      		cp r20,r24
 4293 18f4 5907      		cpc r21,r25
 4294 18f6 6A07      		cpc r22,r26
 4295 18f8 7B07      		cpc r23,r27
 4296 18fa 00F0      		brlo .L277
3452:switcherator.c ****                         temp = dow;
 4297               		.loc 1 3452 0
 4298 18fc C901      		movw r24,r18
 4299 18fe A0E0      		ldi r26,0
 4300 1900 B0E0      		ldi r27,0
3456:switcherator.c ****                             if (temp == 0)
 4301               		.loc 1 3456 0
 4302 1902 0097      		sbiw r24,0
 4303 1904 A105      		cpc r26,__zero_reg__
 4304 1906 B105      		cpc r27,__zero_reg__
 4305 1908 01F0      		breq .L300
3459:switcherator.c ****                                 temp--;
 4306               		.loc 1 3459 0
 4307 190a 0197      		sbiw r24,1
 4308 190c A109      		sbc r26,__zero_reg__
 4309 190e B109      		sbc r27,__zero_reg__
 4310               	.LVL317:
 4311 1910 00C0      		rjmp .L278
 4312               	.LVL318:
 4313               	.L300:
3457:switcherator.c ****                                 temp = 6;
 4314               		.loc 1 3457 0
 4315 1912 86E0      		ldi r24,lo8(6)
 4316 1914 90E0      		ldi r25,0
 4317 1916 A0E0      		ldi r26,0
 4318 1918 B0E0      		ldi r27,0
 4319               	.LVL319:
 4320               	.L278:
3460:switcherator.c ****                             if (timeLimits[x][2] & (1 << temp))
 4321               		.loc 1 3460 0
 4322 191a 9601      		movw r18,r12
 4323 191c 00C0      		rjmp 2f
 4324               		1:
 4325 191e 220F      		lsl r18
 4326 1920 331F      		rol r19
 4327               		2:
 4328 1922 8A95      		dec r24
 4329 1924 02F4      		brpl 1b
 4330 1926 A901      		movw r20,r18
 4331 1928 6627      		clr r22
 4332 192a 57FD      		sbrc r21,7
 4333 192c 6095      		com r22
 4334 192e 762F      		mov r23,r22
 4335 1930 F701      		movw r30,r14
 4336 1932 8085      		ldd r24,Z+8
 4337 1934 9185      		ldd r25,Z+9
 4338 1936 A285      		ldd r26,Z+10
 4339 1938 B385      		ldd r27,Z+11
 4340 193a 4823      		and r20,r24
 4341 193c 5923      		and r21,r25
 4342 193e 6A23      		and r22,r26
 4343 1940 7B23      		and r23,r27
 4344 1942 452B      		or r20,r21
 4345 1944 462B      		or r20,r22
 4346 1946 472B      		or r20,r23
 4347 1948 01F4      		brne .+2
 4348 194a 00C0      		rjmp .L279
 4349 194c 00C0      		rjmp .L352
 4350               	.LVL320:
 4351               	.L277:
3462:switcherator.c ****                         } else if (weeklySeconds >= (startTime + daySeconds)) {
 4352               		.loc 1 3462 0
 4353 194e 480C      		add r4,r8
 4354 1950 591C      		adc r5,r9
 4355 1952 6A1C      		adc r6,r10
 4356 1954 7B1C      		adc r7,r11
 4357               	.LVL321:
 4358 1956 8415      		cp r24,r4
 4359 1958 9505      		cpc r25,r5
 4360 195a A605      		cpc r26,r6
 4361 195c B705      		cpc r27,r7
 4362 195e 00F0      		brlo .L279
3463:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
 4363               		.loc 1 3463 0
 4364 1960 C601      		movw r24,r12
 4365 1962 00C0      		rjmp 2f
 4366               		1:
 4367 1964 880F      		lsl r24
 4368 1966 991F      		rol r25
 4369               		2:
 4370 1968 2A95      		dec r18
 4371 196a 02F4      		brpl 1b
 4372 196c 00C0      		rjmp .L356
 4373               	.LVL322:
 4374               	.L276:
3467:switcherator.c ****                         if (weeklySeconds >= (startTime + daySeconds) &&
 4375               		.loc 1 3467 0
 4376 196e 480C      		add r4,r8
 4377 1970 591C      		adc r5,r9
 4378 1972 6A1C      		adc r6,r10
 4379 1974 7B1C      		adc r7,r11
 4380               	.LVL323:
 4381 1976 8415      		cp r24,r4
 4382 1978 9505      		cpc r25,r5
 4383 197a A605      		cpc r26,r6
 4384 197c B705      		cpc r27,r7
 4385 197e 00F0      		brlo .L279
3468:switcherator.c ****                                 weeklySeconds <= (stopTime + daySeconds)) {
 4386               		.loc 1 3468 0 discriminator 1
 4387 1980 480D      		add r20,r8
 4388 1982 591D      		adc r21,r9
 4389 1984 6A1D      		adc r22,r10
 4390 1986 7B1D      		adc r23,r11
 4391               	.LVL324:
3467:switcherator.c ****                         if (weeklySeconds >= (startTime + daySeconds) &&
 4392               		.loc 1 3467 0 discriminator 1
 4393 1988 4817      		cp r20,r24
 4394 198a 5907      		cpc r21,r25
 4395 198c 6A07      		cpc r22,r26
 4396 198e 7B07      		cpc r23,r27
 4397 1990 00F0      		brlo .L279
3469:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
 4398               		.loc 1 3469 0
 4399 1992 C601      		movw r24,r12
 4400 1994 0090 0000 		lds r0,dow
 4401 1998 00C0      		rjmp 2f
 4402               		1:
 4403 199a 880F      		lsl r24
 4404 199c 991F      		rol r25
 4405               		2:
 4406 199e 0A94      		dec r0
 4407 19a0 02F4      		brpl 1b
 4408               	.L356:
 4409 19a2 AA27      		clr r26
 4410 19a4 97FD      		sbrc r25,7
 4411 19a6 A095      		com r26
 4412 19a8 BA2F      		mov r27,r26
 4413 19aa F701      		movw r30,r14
 4414 19ac 4085      		ldd r20,Z+8
 4415 19ae 5185      		ldd r21,Z+9
 4416 19b0 6285      		ldd r22,Z+10
 4417 19b2 7385      		ldd r23,Z+11
 4418 19b4 8423      		and r24,r20
 4419 19b6 9523      		and r25,r21
 4420 19b8 A623      		and r26,r22
 4421 19ba B723      		and r27,r23
 4422 19bc 892B      		or r24,r25
 4423 19be 8A2B      		or r24,r26
 4424 19c0 8B2B      		or r24,r27
 4425 19c2 01F0      		breq .L279
 4426               	.L352:
 4427               		.loc 1 3470 0
 4428 19c4 20E0      		ldi r18,0
 4429 19c6 30E0      		ldi r19,0
 4430 19c8 A901      		movw r20,r18
 4431 19ca 6B85      		ldd r22,Y+11
 4432 19cc 7C85      		ldd r23,Y+12
 4433 19ce C801      		movw r24,r16
 4434 19d0 0E94 0000 		call startTheProgram
 4435               	.LVL325:
 4436               	.L279:
 4437 19d4 FCE0      		ldi r31,12
 4438 19d6 EF0E      		add r14,r31
 4439 19d8 F11C      		adc r15,__zero_reg__
3447:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
 4440               		.loc 1 3447 0
 4441 19da 20E0      		ldi r18,lo8(timeLimits+48)
 4442 19dc E216      		cp r14,r18
 4443 19de 20E0      		ldi r18,hi8(timeLimits+48)
 4444 19e0 F206      		cpc r15,r18
 4445 19e2 01F0      		breq .+2
 4446 19e4 00C0      		rjmp .L280
 4447 19e6 00C0      		rjmp .L261
 4448               	.LVL326:
 4449               	.L262:
 4450               	.LBB24:
3471:switcherator.c ****                         }
3472:switcherator.c ****                     }
3473:switcherator.c ****                 } // end of the for
3474:switcherator.c ****             }
3475:switcherator.c ****         }
3476:switcherator.c **** 
3477:switcherator.c ****     } else {
3478:switcherator.c ****         // this is a digital input
3479:switcherator.c ****         // value of 255 (default) means nothing programmed
3480:switcherator.c ****         // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
3481:switcherator.c ****         // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG        
3482:switcherator.c ****         // figure out what we are dealing with and check it.
3483:switcherator.c ****         temp = outputNum;
 4451               		.loc 1 3483 0
 4452 19e8 862F      		mov r24,r22
 4453 19ea 90E0      		ldi r25,0
 4454 19ec A0E0      		ldi r26,0
 4455 19ee B0E0      		ldi r27,0
 4456               	.LVL327:
3484:switcherator.c ****         if (temp > 15 && temp < 32) {
 4457               		.loc 1 3484 0
 4458 19f0 AC01      		movw r20,r24
 4459 19f2 BD01      		movw r22,r26
 4460               	.LVL328:
 4461 19f4 4051      		subi r20,16
 4462 19f6 5109      		sbc r21,__zero_reg__
 4463 19f8 6109      		sbc r22,__zero_reg__
 4464 19fa 7109      		sbc r23,__zero_reg__
 4465 19fc 4031      		cpi r20,16
 4466 19fe 5105      		cpc r21,__zero_reg__
 4467 1a00 6105      		cpc r22,__zero_reg__
 4468 1a02 7105      		cpc r23,__zero_reg__
 4469 1a04 00F4      		brsh .L281
 4470               	.LVL329:
3485:switcherator.c ****             thisPin = &PINB;
3486:switcherator.c ****             temp -= 16;
 4471               		.loc 1 3486 0
 4472 1a06 CB01      		movw r24,r22
 4473 1a08 BA01      		movw r22,r20
 4474               	.LVL330:
3485:switcherator.c ****             thisPin = &PINB;
 4475               		.loc 1 3485 0
 4476 1a0a B3E2      		ldi r27,lo8(35)
 4477 1a0c CB2E      		mov r12,r27
 4478 1a0e D12C      		mov r13,__zero_reg__
 4479 1a10 00C0      		rjmp .L282
 4480               	.LVL331:
 4481               	.L281:
3487:switcherator.c **** #ifdef PINA
3488:switcherator.c ****         } else if (temp < 16) {
3489:switcherator.c ****             thisPin = &PINA;
3490:switcherator.c ****             temp -= 0;
3491:switcherator.c **** #endif
3492:switcherator.c **** #ifdef PINC
3493:switcherator.c ****         } else if (temp < 48) {
 4482               		.loc 1 3493 0
 4483 1a12 8033      		cpi r24,48
 4484 1a14 9105      		cpc r25,__zero_reg__
 4485 1a16 A105      		cpc r26,__zero_reg__
 4486 1a18 B105      		cpc r27,__zero_reg__
 4487 1a1a 04F4      		brge .L283
 4488               	.LVL332:
3494:switcherator.c ****             thisPin = &PINC;
3495:switcherator.c ****             temp -= 32;
 4489               		.loc 1 3495 0
 4490 1a1c BC01      		movw r22,r24
 4491 1a1e CD01      		movw r24,r26
 4492               	.LVL333:
 4493 1a20 6052      		subi r22,32
 4494 1a22 7109      		sbc r23,__zero_reg__
 4495 1a24 8109      		sbc r24,__zero_reg__
 4496 1a26 9109      		sbc r25,__zero_reg__
 4497               	.LVL334:
3494:switcherator.c ****             thisPin = &PINC;
 4498               		.loc 1 3494 0
 4499 1a28 A6E2      		ldi r26,lo8(38)
 4500 1a2a CA2E      		mov r12,r26
 4501 1a2c D12C      		mov r13,__zero_reg__
 4502 1a2e 00C0      		rjmp .L282
 4503               	.LVL335:
 4504               	.L283:
3496:switcherator.c **** #endif
3497:switcherator.c **** #ifdef PIND
3498:switcherator.c ****         } else if (temp < 64) {
 4505               		.loc 1 3498 0
 4506 1a30 8034      		cpi r24,64
 4507 1a32 9105      		cpc r25,__zero_reg__
 4508 1a34 A105      		cpc r26,__zero_reg__
 4509 1a36 B105      		cpc r27,__zero_reg__
 4510 1a38 04F0      		brlt .+2
 4511 1a3a 00C0      		rjmp .L261
 4512               	.LVL336:
3499:switcherator.c ****             thisPin = &PIND;
3500:switcherator.c ****             temp -= 48;
 4513               		.loc 1 3500 0
 4514 1a3c BC01      		movw r22,r24
 4515 1a3e CD01      		movw r24,r26
 4516               	.LVL337:
 4517 1a40 6053      		subi r22,48
 4518 1a42 7109      		sbc r23,__zero_reg__
 4519 1a44 8109      		sbc r24,__zero_reg__
 4520 1a46 9109      		sbc r25,__zero_reg__
 4521               	.LVL338:
3499:switcherator.c ****             thisPin = &PIND;
 4522               		.loc 1 3499 0
 4523 1a48 F9E2      		ldi r31,lo8(41)
 4524 1a4a CF2E      		mov r12,r31
 4525 1a4c D12C      		mov r13,__zero_reg__
 4526               	.LVL339:
 4527               	.L282:
3501:switcherator.c **** #endif
3502:switcherator.c **** #ifdef PINE
3503:switcherator.c ****         } else if (temp < 80) {
3504:switcherator.c ****             thisPin = &PINE;
3505:switcherator.c ****             temp -= 64;
3506:switcherator.c **** #endif
3507:switcherator.c **** #ifdef PINF
3508:switcherator.c ****         } else if (temp < 96) {
3509:switcherator.c ****             thisPin = &PINF;
3510:switcherator.c ****             temp -= 80;
3511:switcherator.c **** #endif
3512:switcherator.c **** #ifdef PING
3513:switcherator.c ****         } else if (temp < 112) {
3514:switcherator.c ****             thisPin = &PING;
3515:switcherator.c ****             temp -= 96;
3516:switcherator.c **** #endif
3517:switcherator.c **** #ifdef PINH
3518:switcherator.c ****         } else if (temp < 128) {
3519:switcherator.c ****             thisPin = &PINH;
3520:switcherator.c ****             temp -= 112;
3521:switcherator.c **** #endif
3522:switcherator.c **** #ifdef PINI
3523:switcherator.c ****         } else if (temp < 144) {
3524:switcherator.c ****             thisPin = &PINI;
3525:switcherator.c ****             temp -= 128;
3526:switcherator.c **** #endif
3527:switcherator.c ****         } else {
3528:switcherator.c ****             // something went wrong.  Who cares.
3529:switcherator.c ****             return;
3530:switcherator.c ****         }
3531:switcherator.c ****         // if we want the input to be high then low = 0.  If we want it to be 
3532:switcherator.c ****         // low to be on then low = 255;
3533:switcherator.c ****         temp = temp / 2;
 4528               		.loc 1 3533 0
 4529 1a4e 22E0      		ldi r18,lo8(2)
 4530 1a50 30E0      		ldi r19,0
 4531 1a52 40E0      		ldi r20,0
 4532 1a54 50E0      		ldi r21,0
 4533 1a56 0E94 0000 		call __divmodsi4
 4534               	.LVL340:
3534:switcherator.c ****         if (temp > 7) {
 4535               		.loc 1 3534 0
 4536 1a5a 2830      		cpi r18,8
 4537 1a5c 3105      		cpc r19,__zero_reg__
 4538 1a5e 4105      		cpc r20,__zero_reg__
 4539 1a60 5105      		cpc r21,__zero_reg__
 4540 1a62 04F0      		brlt .+2
 4541 1a64 00C0      		rjmp .L261
3535:switcherator.c ****             return; // something wrong again
3536:switcherator.c ****         }
3537:switcherator.c ****         int pinsOn = *thisPin;
 4542               		.loc 1 3537 0
 4543 1a66 D601      		movw r26,r12
 4544 1a68 8C91      		ld r24,X
 4545               	.LVL341:
 4546 1a6a 90E0      		ldi r25,0
3538:switcherator.c ****         char yeaOurInputIsOn = 0;
3539:switcherator.c ****         if (pinsOn & (1 << temp)) {
 4547               		.loc 1 3539 0
 4548 1a6c 00C0      		rjmp 2f
 4549               		1:
 4550 1a6e 9595      		asr r25
 4551 1a70 8795      		ror r24
 4552               		2:
 4553 1a72 2A95      		dec r18
 4554 1a74 02F4      		brpl 1b
 4555               	.LVL342:
 4556 1a76 80FF      		sbrs r24,0
 4557 1a78 00C0      		rjmp .L284
3540:switcherator.c ****             // pin is high
3541:switcherator.c ****             if (low == 0)
 4558               		.loc 1 3541 0
 4559 1a7a EF28      		or r14,r15
 4560 1a7c 01F4      		brne .+2
 4561 1a7e 00C0      		rjmp .L285
 4562 1a80 00C0      		rjmp .L261
 4563               	.L284:
3542:switcherator.c ****                 yeaOurInputIsOn = 1;
3543:switcherator.c ****         } else {
3544:switcherator.c ****             // pin is low
3545:switcherator.c ****             if (low == 255)
 4564               		.loc 1 3545 0
 4565 1a82 BFEF      		ldi r27,-1
 4566 1a84 EB16      		cp r14,r27
 4567 1a86 F104      		cpc r15,__zero_reg__
 4568 1a88 01F0      		breq .+2
 4569 1a8a 00C0      		rjmp .L261
 4570 1a8c 00C0      		rjmp .L285
 4571               	.LVL343:
 4572               	.L298:
3546:switcherator.c ****                 yeaOurInputIsOn = 1;
3547:switcherator.c ****         }
3548:switcherator.c ****         if (yeaOurInputIsOn == 1) {
3549:switcherator.c ****             if (switchNumber < 128) { // this is a switch
3550:switcherator.c ****                 if (switchStatus[switchNumber] == 0) // the switch is off
 4573               		.loc 1 3550 0
 4574 1a8e 000F      		lsl r16
 4575 1a90 111F      		rol r17
 4576 1a92 000F      		lsl r16
 4577 1a94 111F      		rol r17
 4578               	.LVL344:
 4579 1a96 F801      		movw r30,r16
 4580 1a98 E050      		subi r30,lo8(-(switchStatus))
 4581 1a9a F040      		sbci r31,hi8(-(switchStatus))
 4582 1a9c 4081      		ld r20,Z
 4583 1a9e 5181      		ldd r21,Z+1
 4584 1aa0 6281      		ldd r22,Z+2
 4585 1aa2 7381      		ldd r23,Z+3
 4586 1aa4 4115      		cp r20,__zero_reg__
 4587 1aa6 5105      		cpc r21,__zero_reg__
 4588 1aa8 6105      		cpc r22,__zero_reg__
 4589 1aaa 7105      		cpc r23,__zero_reg__
 4590 1aac 01F4      		brne .L286
3551:switcherator.c ****                     switchChanged = 1;
 4591               		.loc 1 3551 0
 4592 1aae 81E0      		ldi r24,lo8(1)
 4593 1ab0 8093 0000 		sts switchChanged,r24
 4594               	.L286:
3552:switcherator.c ****                 if ((switchStatus[switchNumber]) < (weeklySeconds + duration))
 4595               		.loc 1 3552 0
 4596 1ab4 8091 0000 		lds r24,weeklySeconds
 4597 1ab8 9091 0000 		lds r25,weeklySeconds+1
 4598 1abc A091 0000 		lds r26,weeklySeconds+2
 4599 1ac0 B091 0000 		lds r27,weeklySeconds+3
 4600 1ac4 EB85      		ldd r30,Y+11
 4601 1ac6 FC85      		ldd r31,Y+12
 4602 1ac8 8E0F      		add r24,r30
 4603 1aca 9F1F      		adc r25,r31
 4604 1acc A11D      		adc r26,__zero_reg__
 4605 1ace B11D      		adc r27,__zero_reg__
 4606 1ad0 4817      		cp r20,r24
 4607 1ad2 5907      		cpc r21,r25
 4608 1ad4 6A07      		cpc r22,r26
 4609 1ad6 7B07      		cpc r23,r27
 4610 1ad8 00F0      		brlo .+2
 4611 1ada 00C0      		rjmp .L261
3553:switcherator.c ****                     switchStatus[switchNumber] = (weeklySeconds + duration);
 4612               		.loc 1 3553 0
 4613 1adc F801      		movw r30,r16
 4614 1ade E050      		subi r30,lo8(-(switchStatus))
 4615 1ae0 F040      		sbci r31,hi8(-(switchStatus))
 4616 1ae2 8083      		st Z,r24
 4617 1ae4 9183      		std Z+1,r25
 4618 1ae6 A283      		std Z+2,r26
 4619 1ae8 B383      		std Z+3,r27
 4620 1aea 00C0      		rjmp .L261
 4621               	.LVL345:
 4622               	.L288:
3554:switcherator.c ****             } else { // its a program;
3555:switcherator.c ****                 test = 0;
3556:switcherator.c ****                 // check and make sure we are within the time limits (eg dusk to dawn)
3557:switcherator.c ****                 // first if no time limits set up then ignore it
3558:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
3559:switcherator.c ****                     if (timeLimits[x][2] > 0)
 4623               		.loc 1 3559 0
 4624 1aec 8081      		ld r24,Z
 4625 1aee 9181      		ldd r25,Z+1
 4626 1af0 A281      		ldd r26,Z+2
 4627 1af2 B381      		ldd r27,Z+3
 4628 1af4 892B      		or r24,r25
 4629 1af6 8A2B      		or r24,r26
 4630 1af8 8B2B      		or r24,r27
 4631 1afa 01F0      		breq .L287
3560:switcherator.c ****                         test = 1;
 4632               		.loc 1 3560 0
 4633 1afc 21E0      		ldi r18,lo8(1)
 4634               	.L287:
 4635               	.LVL346:
 4636 1afe 3C96      		adiw r30,12
3558:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
 4637               		.loc 1 3558 0
 4638 1b00 30E0      		ldi r19,hi8(timeLimits+56)
 4639 1b02 E030      		cpi r30,lo8(timeLimits+56)
 4640 1b04 F307      		cpc r31,r19
 4641 1b06 01F4      		brne .L288
3561:switcherator.c ****                 }
3562:switcherator.c ****                 // no limits set up
3563:switcherator.c ****                 if (test == 0)
 4642               		.loc 1 3563 0
 4643 1b08 2111      		cpse r18,__zero_reg__
 4644 1b0a 00C0      		rjmp .L289
3564:switcherator.c ****                     startTheProgram((switchNumber - 128), duration, 0);
 4645               		.loc 1 3564 0
 4646 1b0c 20E0      		ldi r18,0
 4647 1b0e 30E0      		ldi r19,0
 4648 1b10 A901      		movw r20,r18
 4649               	.LVL347:
 4650 1b12 6B85      		ldd r22,Y+11
 4651 1b14 7C85      		ldd r23,Y+12
 4652 1b16 C801      		movw r24,r16
 4653 1b18 8058      		subi r24,-128
 4654 1b1a 9109      		sbc r25,__zero_reg__
 4655 1b1c 0E94 0000 		call startTheProgram
 4656               	.LVL348:
 4657               	.L289:
3565:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
3566:switcherator.c ****                     startTime = timeLimits[x][0];
3567:switcherator.c ****                     stopTime = timeLimits[x][1];
3568:switcherator.c ****                     // deal with nights that cross midnight
3569:switcherator.c ****                     if (stopTime < startTime) {
3570:switcherator.c ****                         temp = dow;
3571:switcherator.c ****                         // weekly seconds resets at the end of the week. so do lots of 9
3572:switcherator.c ****                         if (weeklySeconds <= (stopTime + daySeconds)) {
3573:switcherator.c ****                             // k this is dow + 1
3574:switcherator.c ****                             if (temp == 0)
3575:switcherator.c ****                                 temp = 6;
3576:switcherator.c ****                             else
3577:switcherator.c ****                                 temp--;
 4658               		.loc 1 3577 0 discriminator 1
 4659 1b20 D301      		movw r26,r6
 4660 1b22 C201      		movw r24,r4
 4661 1b24 0197      		sbiw r24,1
 4662 1b26 A109      		sbc r26,__zero_reg__
 4663 1b28 B109      		sbc r27,__zero_reg__
3578:switcherator.c ****                             if (timeLimits[x][2] & (1 << temp))
 4664               		.loc 1 3578 0 discriminator 1
 4665 1b2a 4528      		or r4,r5
 4666 1b2c 4628      		or r4,r6
 4667 1b2e 4728      		or r4,r7
 4668 1b30 01F4      		brne .L290
 4669 1b32 76E0      		ldi r23,lo8(6)
 4670 1b34 472E      		mov r4,r23
 4671 1b36 512C      		mov r5,__zero_reg__
 4672 1b38 612C      		mov r6,__zero_reg__
 4673 1b3a 712C      		mov r7,__zero_reg__
 4674 1b3c 00C0      		rjmp .L291
 4675               	.L290:
 4676 1b3e 2C01      		movw r4,r24
 4677 1b40 3D01      		movw r6,r26
 4678               	.L291:
 4679 1b42 81E0      		ldi r24,lo8(1)
 4680 1b44 90E0      		ldi r25,0
 4681 1b46 AC01      		movw r20,r24
 4682 1b48 00C0      		rjmp 2f
 4683               		1:
 4684 1b4a 440F      		lsl r20
 4685 1b4c 551F      		rol r21
 4686               		2:
 4687 1b4e 4A94      		dec r4
 4688 1b50 02F4      		brpl 1b
 4689 1b52 9A01      		movw r18,r20
 4690 1b54 4427      		clr r20
 4691 1b56 37FD      		sbrc r19,7
 4692 1b58 4095      		com r20
 4693 1b5a 542F      		mov r21,r20
 4694 1b5c 2983      		std Y+1,r18
 4695 1b5e 3A83      		std Y+2,r19
 4696 1b60 4B83      		std Y+3,r20
 4697 1b62 5C83      		std Y+4,r21
3579:switcherator.c ****                                 startTheProgram((switchNumber - 128), duration, 0);
3580:switcherator.c ****                         } else if (weeklySeconds >= (startTime + daySeconds)) {
3581:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
 4698               		.loc 1 3581 0 discriminator 1
 4699 1b64 2C01      		movw r4,r24
 4700 1b66 00C0      		rjmp 2f
 4701               		1:
 4702 1b68 440C      		lsl r4
 4703 1b6a 551C      		rol r5
 4704               		2:
 4705 1b6c 2A94      		dec r2
 4706 1b6e 02F4      		brpl 1b
 4707 1b70 6624      		clr r6
 4708 1b72 57FC      		sbrc r5,7
 4709 1b74 6094      		com r6
 4710 1b76 762C      		mov r7,r6
 4711 1b78 60E0      		ldi r22,lo8(timeLimits)
 4712 1b7a E62E      		mov r14,r22
 4713 1b7c 60E0      		ldi r22,hi8(timeLimits)
 4714 1b7e F62E      		mov r15,r22
 4715               	.LVL349:
3582:switcherator.c ****                                 startTheProgram((switchNumber - 128), duration, 0);
3583:switcherator.c ****                         }
3584:switcherator.c ****                     } else {
3585:switcherator.c ****                         if (weeklySeconds >= (startTime + daySeconds) &&
3586:switcherator.c ****                                 weeklySeconds <= (stopTime + daySeconds)) {
3587:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
3588:switcherator.c ****                                 startTheProgram((switchNumber - 128), duration, 0);
 4716               		.loc 1 3588 0 discriminator 1
 4717 1b80 6801      		movw r12,r16
 4718               	.LVL350:
 4719 1b82 30E8      		ldi r19,-128
 4720 1b84 C31A      		sub r12,r19
 4721 1b86 D108      		sbc r13,__zero_reg__
 4722               	.LVL351:
 4723               	.L295:
3566:switcherator.c ****                     startTime = timeLimits[x][0];
 4724               		.loc 1 3566 0
 4725 1b88 D701      		movw r26,r14
 4726 1b8a 8D91      		ld r24,X+
 4727 1b8c 9D91      		ld r25,X+
 4728 1b8e 0D90      		ld __tmp_reg__,X+
 4729 1b90 BC91      		ld r27,X
 4730 1b92 A02D      		mov r26,__tmp_reg__
 4731 1b94 8D83      		std Y+5,r24
 4732 1b96 9E83      		std Y+6,r25
 4733 1b98 AF83      		std Y+7,r26
 4734 1b9a B887      		std Y+8,r27
 4735               	.LVL352:
3567:switcherator.c ****                     stopTime = timeLimits[x][1];
 4736               		.loc 1 3567 0
 4737 1b9c F701      		movw r30,r14
 4738 1b9e 4481      		ldd r20,Z+4
 4739 1ba0 5581      		ldd r21,Z+5
 4740 1ba2 6681      		ldd r22,Z+6
 4741 1ba4 7781      		ldd r23,Z+7
 4742               	.LVL353:
 4743 1ba6 8091 0000 		lds r24,weeklySeconds
 4744 1baa 9091 0000 		lds r25,weeklySeconds+1
 4745 1bae A091 0000 		lds r26,weeklySeconds+2
 4746 1bb2 B091 0000 		lds r27,weeklySeconds+3
 4747               	.LVL354:
3569:switcherator.c ****                     if (stopTime < startTime) {
 4748               		.loc 1 3569 0
 4749 1bb6 0D81      		ldd r16,Y+5
 4750 1bb8 1E81      		ldd r17,Y+6
 4751 1bba 2F81      		ldd r18,Y+7
 4752 1bbc 3885      		ldd r19,Y+8
 4753 1bbe 4017      		cp r20,r16
 4754 1bc0 5107      		cpc r21,r17
 4755 1bc2 6207      		cpc r22,r18
 4756 1bc4 7307      		cpc r23,r19
 4757 1bc6 04F4      		brge .L292
3572:switcherator.c ****                         if (weeklySeconds <= (stopTime + daySeconds)) {
 4758               		.loc 1 3572 0
 4759 1bc8 480D      		add r20,r8
 4760 1bca 591D      		adc r21,r9
 4761 1bcc 6A1D      		adc r22,r10
 4762 1bce 7B1D      		adc r23,r11
 4763               	.LVL355:
 4764 1bd0 4817      		cp r20,r24
 4765 1bd2 5907      		cpc r21,r25
 4766 1bd4 6A07      		cpc r22,r26
 4767 1bd6 7B07      		cpc r23,r27
 4768 1bd8 00F0      		brlo .L293
3578:switcherator.c ****                             if (timeLimits[x][2] & (1 << temp))
 4769               		.loc 1 3578 0
 4770 1bda 8085      		ldd r24,Z+8
 4771 1bdc 9185      		ldd r25,Z+9
 4772 1bde A285      		ldd r26,Z+10
 4773 1be0 B385      		ldd r27,Z+11
 4774 1be2 2981      		ldd r18,Y+1
 4775 1be4 3A81      		ldd r19,Y+2
 4776 1be6 4B81      		ldd r20,Y+3
 4777 1be8 5C81      		ldd r21,Y+4
 4778 1bea 8223      		and r24,r18
 4779 1bec 9323      		and r25,r19
 4780 1bee A423      		and r26,r20
 4781 1bf0 B523      		and r27,r21
 4782 1bf2 00C0      		rjmp .L359
 4783               	.L293:
3580:switcherator.c ****                         } else if (weeklySeconds >= (startTime + daySeconds)) {
 4784               		.loc 1 3580 0
 4785 1bf4 4D81      		ldd r20,Y+5
 4786 1bf6 5E81      		ldd r21,Y+6
 4787 1bf8 6F81      		ldd r22,Y+7
 4788 1bfa 7885      		ldd r23,Y+8
 4789 1bfc 480D      		add r20,r8
 4790 1bfe 591D      		adc r21,r9
 4791 1c00 6A1D      		adc r22,r10
 4792 1c02 7B1D      		adc r23,r11
 4793 1c04 8417      		cp r24,r20
 4794 1c06 9507      		cpc r25,r21
 4795 1c08 A607      		cpc r26,r22
 4796 1c0a B707      		cpc r27,r23
 4797 1c0c 00F0      		brlo .L294
 4798 1c0e 00C0      		rjmp .L361
 4799               	.LVL356:
 4800               	.L292:
3585:switcherator.c ****                         if (weeklySeconds >= (startTime + daySeconds) &&
 4801               		.loc 1 3585 0
 4802 1c10 0D81      		ldd r16,Y+5
 4803 1c12 1E81      		ldd r17,Y+6
 4804 1c14 2F81      		ldd r18,Y+7
 4805 1c16 3885      		ldd r19,Y+8
 4806 1c18 080D      		add r16,r8
 4807 1c1a 191D      		adc r17,r9
 4808 1c1c 2A1D      		adc r18,r10
 4809 1c1e 3B1D      		adc r19,r11
 4810 1c20 8017      		cp r24,r16
 4811 1c22 9107      		cpc r25,r17
 4812 1c24 A207      		cpc r26,r18
 4813 1c26 B307      		cpc r27,r19
 4814 1c28 00F0      		brlo .L294
3586:switcherator.c ****                                 weeklySeconds <= (stopTime + daySeconds)) {
 4815               		.loc 1 3586 0 discriminator 1
 4816 1c2a 480D      		add r20,r8
 4817 1c2c 591D      		adc r21,r9
 4818 1c2e 6A1D      		adc r22,r10
 4819 1c30 7B1D      		adc r23,r11
 4820               	.LVL357:
3585:switcherator.c ****                         if (weeklySeconds >= (startTime + daySeconds) &&
 4821               		.loc 1 3585 0 discriminator 1
 4822 1c32 4817      		cp r20,r24
 4823 1c34 5907      		cpc r21,r25
 4824 1c36 6A07      		cpc r22,r26
 4825 1c38 7B07      		cpc r23,r27
 4826 1c3a 00F0      		brlo .L294
 4827               	.L361:
3587:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
 4828               		.loc 1 3587 0
 4829 1c3c F701      		movw r30,r14
 4830 1c3e 8085      		ldd r24,Z+8
 4831 1c40 9185      		ldd r25,Z+9
 4832 1c42 A285      		ldd r26,Z+10
 4833 1c44 B385      		ldd r27,Z+11
 4834 1c46 8421      		and r24,r4
 4835 1c48 9521      		and r25,r5
 4836 1c4a A621      		and r26,r6
 4837 1c4c B721      		and r27,r7
 4838               	.L359:
 4839 1c4e 892B      		or r24,r25
 4840 1c50 8A2B      		or r24,r26
 4841 1c52 8B2B      		or r24,r27
 4842 1c54 01F0      		breq .L294
 4843               		.loc 1 3588 0
 4844 1c56 20E0      		ldi r18,0
 4845 1c58 30E0      		ldi r19,0
 4846 1c5a A901      		movw r20,r18
 4847 1c5c 6B85      		ldd r22,Y+11
 4848 1c5e 7C85      		ldd r23,Y+12
 4849 1c60 C601      		movw r24,r12
 4850 1c62 0E94 0000 		call startTheProgram
 4851               	.LVL358:
 4852               	.L294:
 4853 1c66 FCE0      		ldi r31,12
 4854 1c68 EF0E      		add r14,r31
 4855 1c6a F11C      		adc r15,__zero_reg__
3565:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
 4856               		.loc 1 3565 0
 4857 1c6c 00E0      		ldi r16,lo8(timeLimits+48)
 4858 1c6e E016      		cp r14,r16
 4859 1c70 00E0      		ldi r16,hi8(timeLimits+48)
 4860 1c72 F006      		cpc r15,r16
 4861 1c74 01F0      		breq .+2
 4862 1c76 00C0      		rjmp .L295
 4863 1c78 00C0      		rjmp .L261
 4864               	.LVL359:
 4865               	.L285:
3549:switcherator.c ****             if (switchNumber < 128) { // this is a switch
 4866               		.loc 1 3549 0
 4867 1c7a 0038      		cpi r16,-128
 4868 1c7c 1105      		cpc r17,__zero_reg__
 4869 1c7e 00F4      		brsh .+2
 4870 1c80 00C0      		rjmp .L298
 4871 1c82 E0E0      		ldi r30,lo8(timeLimits+8)
 4872 1c84 F0E0      		ldi r31,hi8(timeLimits+8)
3367:switcherator.c **** void getInput(int inputNumber) {
 4873               		.loc 1 3367 0
 4874 1c86 20E0      		ldi r18,0
 4875               	.LVL360:
 4876 1c88 00C0      		rjmp .L288
 4877               	.LVL361:
 4878               	.L261:
 4879               	/* epilogue start */
 4880               	.LBE24:
3589:switcherator.c ****                         }
3590:switcherator.c ****                     }
3591:switcherator.c ****                 } // end of the for
3592:switcherator.c ****             }
3593:switcherator.c ****         }
3594:switcherator.c ****     }
3595:switcherator.c **** }
 4881               		.loc 1 3595 0
 4882 1c8a 2C96      		adiw r28,12
 4883 1c8c 0FB6      		in __tmp_reg__,__SREG__
 4884 1c8e F894      		cli
 4885 1c90 DEBF      		out __SP_H__,r29
 4886 1c92 0FBE      		out __SREG__,__tmp_reg__
 4887 1c94 CDBF      		out __SP_L__,r28
 4888 1c96 DF91      		pop r29
 4889 1c98 CF91      		pop r28
 4890 1c9a 1F91      		pop r17
 4891 1c9c 0F91      		pop r16
 4892 1c9e FF90      		pop r15
 4893 1ca0 EF90      		pop r14
 4894 1ca2 DF90      		pop r13
 4895               	.LVL362:
 4896 1ca4 CF90      		pop r12
 4897 1ca6 BF90      		pop r11
 4898 1ca8 AF90      		pop r10
 4899 1caa 9F90      		pop r9
 4900 1cac 8F90      		pop r8
 4901               	.LVL363:
 4902 1cae 7F90      		pop r7
 4903 1cb0 6F90      		pop r6
 4904 1cb2 5F90      		pop r5
 4905 1cb4 4F90      		pop r4
 4906 1cb6 3F90      		pop r3
 4907 1cb8 2F90      		pop r2
 4908 1cba 0895      		ret
 4909               	.LFE77:
 4911               	.global	inputTenthCheck
 4913               	inputTenthCheck:
 4914               	.LFB76:
3347:switcherator.c **** void inputTenthCheck(void) {
 4915               		.loc 1 3347 0
 4916 1cbc 0F93      		push r16
 4917               	.LCFI116:
 4918 1cbe 1F93      		push r17
 4919               	.LCFI117:
 4920 1cc0 CF93      		push r28
 4921               	.LCFI118:
 4922 1cc2 DF93      		push r29
 4923               	.LCFI119:
 4924               	/* prologue: function */
 4925               	/* frame size = 0 */
 4926               	/* stack size = 4 */
 4927               	.L__stack_usage = 4
 4928               	.LVL364:
 4929 1cc4 00E0      		ldi r16,lo8(inputs+6)
 4930 1cc6 10E0      		ldi r17,hi8(inputs+6)
3349:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 4931               		.loc 1 3349 0
 4932 1cc8 C0E0      		ldi r28,0
 4933 1cca D0E0      		ldi r29,0
 4934               	.LVL365:
 4935               	.L365:
3347:switcherator.c **** void inputTenthCheck(void) {
 4936               		.loc 1 3347 0
 4937 1ccc F801      		movw r30,r16
 4938 1cce 3697      		sbiw r30,6
3351:switcherator.c ****         if (inputs[x][0] != 255 && inputs[x][6] == 0)
 4939               		.loc 1 3351 0
 4940 1cd0 8081      		ld r24,Z
 4941 1cd2 8F3F      		cpi r24,lo8(-1)
 4942 1cd4 01F0      		breq .L364
3351:switcherator.c ****         if (inputs[x][0] != 255 && inputs[x][6] == 0)
 4943               		.loc 1 3351 0 is_stmt 0 discriminator 1
 4944 1cd6 F801      		movw r30,r16
 4945 1cd8 8081      		ld r24,Z
 4946 1cda 8111      		cpse r24,__zero_reg__
 4947 1cdc 00C0      		rjmp .L364
3352:switcherator.c ****             getInput(x);
 4948               		.loc 1 3352 0 is_stmt 1
 4949 1cde CE01      		movw r24,r28
 4950 1ce0 0E94 0000 		call getInput
 4951               	.LVL366:
 4952               	.L364:
3349:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 4953               		.loc 1 3349 0
 4954 1ce4 2196      		adiw r28,1
 4955               	.LVL367:
 4956 1ce6 085F      		subi r16,-8
 4957 1ce8 1F4F      		sbci r17,-1
 4958 1cea C430      		cpi r28,4
 4959 1cec D105      		cpc r29,__zero_reg__
 4960 1cee 01F4      		brne .L365
 4961               	/* epilogue start */
3354:switcherator.c **** }
 4962               		.loc 1 3354 0
 4963 1cf0 DF91      		pop r29
 4964 1cf2 CF91      		pop r28
 4965               	.LVL368:
 4966 1cf4 1F91      		pop r17
 4967 1cf6 0F91      		pop r16
 4968 1cf8 0895      		ret
 4969               	.LFE76:
 4971               	.global	inputCheck
 4973               	inputCheck:
 4974               	.LFB75:
3326:switcherator.c **** void inputCheck(void) {
 4975               		.loc 1 3326 0
 4976 1cfa 0F93      		push r16
 4977               	.LCFI120:
 4978 1cfc 1F93      		push r17
 4979               	.LCFI121:
 4980 1cfe CF93      		push r28
 4981               	.LCFI122:
 4982 1d00 DF93      		push r29
 4983               	.LCFI123:
 4984               	/* prologue: function */
 4985               	/* frame size = 0 */
 4986               	/* stack size = 4 */
 4987               	.L__stack_usage = 4
 4988               	.LVL369:
 4989 1d02 00E0      		ldi r16,lo8(inputs+6)
 4990 1d04 10E0      		ldi r17,hi8(inputs+6)
3330:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 4991               		.loc 1 3330 0
 4992 1d06 C0E0      		ldi r28,0
 4993 1d08 D0E0      		ldi r29,0
 4994               	.LVL370:
 4995               	.L373:
3326:switcherator.c **** void inputCheck(void) {
 4996               		.loc 1 3326 0
 4997 1d0a F801      		movw r30,r16
 4998 1d0c 3697      		sbiw r30,6
3332:switcherator.c ****         if (inputs[x][0] == 255)
 4999               		.loc 1 3332 0
 5000 1d0e 8081      		ld r24,Z
 5001 1d10 8F3F      		cpi r24,lo8(-1)
 5002 1d12 01F0      		breq .L371
3334:switcherator.c ****         pollTime = inputs[x][6];
 5003               		.loc 1 3334 0
 5004 1d14 F801      		movw r30,r16
 5005 1d16 2081      		ld r18,Z
 5006               	.LVL371:
3336:switcherator.c ****         if (pollTime == 0 || pollTime == 1) {
 5007               		.loc 1 3336 0
 5008 1d18 2230      		cpi r18,lo8(2)
 5009 1d1a 00F4      		brsh .L372
 5010 1d1c 00C0      		rjmp .L378
 5011               	.L372:
3339:switcherator.c ****         } else if (weeklySeconds % pollTime == 0) {
 5012               		.loc 1 3339 0
 5013 1d1e 30E0      		ldi r19,0
 5014 1d20 40E0      		ldi r20,0
 5015 1d22 50E0      		ldi r21,0
 5016 1d24 6091 0000 		lds r22,weeklySeconds
 5017 1d28 7091 0000 		lds r23,weeklySeconds+1
 5018 1d2c 8091 0000 		lds r24,weeklySeconds+2
 5019 1d30 9091 0000 		lds r25,weeklySeconds+3
 5020 1d34 0E94 0000 		call __udivmodsi4
 5021               	.LVL372:
 5022 1d38 672B      		or r22,r23
 5023 1d3a 682B      		or r22,r24
 5024 1d3c 692B      		or r22,r25
 5025 1d3e 01F4      		brne .L371
 5026               	.L378:
3340:switcherator.c ****             getInput(x);
 5027               		.loc 1 3340 0
 5028 1d40 CE01      		movw r24,r28
 5029 1d42 0E94 0000 		call getInput
 5030               	.LVL373:
 5031               	.L371:
3330:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 5032               		.loc 1 3330 0
 5033 1d46 2196      		adiw r28,1
 5034               	.LVL374:
 5035 1d48 085F      		subi r16,-8
 5036 1d4a 1F4F      		sbci r17,-1
 5037 1d4c C430      		cpi r28,4
 5038 1d4e D105      		cpc r29,__zero_reg__
 5039 1d50 01F4      		brne .L373
 5040               	/* epilogue start */
3343:switcherator.c **** }
 5041               		.loc 1 3343 0
 5042 1d52 DF91      		pop r29
 5043 1d54 CF91      		pop r28
 5044               	.LVL375:
 5045 1d56 1F91      		pop r17
 5046 1d58 0F91      		pop r16
 5047 1d5a 0895      		ret
 5048               	.LFE75:
 5050               	.global	flashFail
 5052               	flashFail:
 5053               	.LFB79:
3596:switcherator.c **** 
3597:switcherator.c **** // clears an input
3598:switcherator.c **** // CI nn = input number
3599:switcherator.c **** 
3600:switcherator.c **** void clearInput(char * commandReceived) {
3601:switcherator.c ****     int inputNumber = 0;
3602:switcherator.c ****     volatile unsigned char *thisPort = 0;
3603:switcherator.c ****     tempIntString[0] = commandReceived[3];
3604:switcherator.c ****     tempIntString[1] = commandReceived[4];
3605:switcherator.c ****     inputNumber = atoi(tempIntString);
3606:switcherator.c ****     int temp = inputs[inputNumber][0];
3607:switcherator.c ****     if (temp > 15 && temp < 32) {
3608:switcherator.c ****         thisPort = &PINB;
3609:switcherator.c ****         temp -= 16;
3610:switcherator.c **** #ifdef PINA
3611:switcherator.c ****     } else if (temp < 16) {
3612:switcherator.c ****         thisPort = &PINA;
3613:switcherator.c ****         temp -= 0;
3614:switcherator.c **** #endif
3615:switcherator.c **** #ifdef PINC
3616:switcherator.c ****     } else if (temp < 48) {
3617:switcherator.c ****         thisPort = &PINC;
3618:switcherator.c ****         temp -= 32;
3619:switcherator.c **** #endif
3620:switcherator.c **** #ifdef PIND
3621:switcherator.c ****     } else if (temp < 64) {
3622:switcherator.c ****         thisPort = &PIND;
3623:switcherator.c ****         temp -= 48;
3624:switcherator.c **** #endif
3625:switcherator.c **** #ifdef PINE
3626:switcherator.c ****     } else if (temp < 80) {
3627:switcherator.c ****         thisPort = &PINE;
3628:switcherator.c ****         temp -= 64;
3629:switcherator.c **** #endif
3630:switcherator.c **** #ifdef PINF
3631:switcherator.c ****     } else if (temp < 96) {
3632:switcherator.c ****         thisPort = &PINF;
3633:switcherator.c ****         temp -= 80;
3634:switcherator.c **** #endif
3635:switcherator.c **** #ifdef PING
3636:switcherator.c ****     } else if (temp < 112) {
3637:switcherator.c ****         thisPort = &PING;
3638:switcherator.c ****         temp -= 96;
3639:switcherator.c **** #endif
3640:switcherator.c **** #ifdef PINH
3641:switcherator.c ****     } else if (temp < 128) {
3642:switcherator.c ****         thisPort = &PINH;
3643:switcherator.c ****         temp -= 112;
3644:switcherator.c **** #endif
3645:switcherator.c **** #ifdef PINI
3646:switcherator.c ****     } else if (temp < 144) {
3647:switcherator.c ****         thisPort = &PINI;
3648:switcherator.c ****         temp -= 128;
3649:switcherator.c **** #endif
3650:switcherator.c ****     } else {
3651:switcherator.c ****         ok();
3652:switcherator.c ****         return;
3653:switcherator.c ****     }
3654:switcherator.c ****     // zero out the port
3655:switcherator.c ****     *thisPort &= ~(1 << temp);
3656:switcherator.c ****     inputs[inputNumber][0] = 255;
3657:switcherator.c ****     ok();
3658:switcherator.c **** }
3659:switcherator.c **** 
3660:switcherator.c **** /****************************************************************
3661:switcherator.c ****  *
3662:switcherator.c ****  *              All Things Interrupt and on offish Related
3663:switcherator.c ****  *
3664:switcherator.c ****  ****************************************************************/
3665:switcherator.c **** 
3666:switcherator.c **** 
3667:switcherator.c **** // Flashes the indicator pin to determine problems
3668:switcherator.c **** 
3669:switcherator.c **** void flashFail(void) {
 5054               		.loc 1 3669 0
 5055               	/* prologue: function */
 5056               	/* frame size = 0 */
 5057               	/* stack size = 0 */
 5058               	.L__stack_usage = 0
3670:switcherator.c ****     failTimer++;
 5059               		.loc 1 3670 0
 5060 1d5c 8091 0000 		lds r24,failTimer
 5061 1d60 8F5F      		subi r24,lo8(-(1))
 5062 1d62 8093 0000 		sts failTimer,r24
3671:switcherator.c ****     INDICATOR_DDR |= INDICATOR_PIN;
 5063               		.loc 1 3671 0
 5064 1d66 529A      		sbi 0xa,2
3672:switcherator.c ****     // different timings for different fails
3673:switcherator.c ****     if (failCondition == 1) {
 5065               		.loc 1 3673 0
 5066 1d68 9091 0000 		lds r25,failCondition
 5067 1d6c 9130      		cpi r25,lo8(1)
 5068 1d6e 01F4      		brne .L380
3674:switcherator.c ****         if (failTimer == 2) {
 5069               		.loc 1 3674 0
 5070 1d70 8230      		cpi r24,lo8(2)
 5071 1d72 01F4      		brne .L381
 5072 1d74 00C0      		rjmp .L398
 5073               	.L381:
3675:switcherator.c ****             INDICATOR_PORT |= INDICATOR_PIN;
3676:switcherator.c ****         } else if (failTimer == 4) {
 5074               		.loc 1 3676 0
 5075 1d76 8430      		cpi r24,lo8(4)
 5076 1d78 01F4      		brne .L383
 5077 1d7a 00C0      		rjmp .L396
 5078               	.L383:
3677:switcherator.c ****             INDICATOR_PORT &= ~(INDICATOR_PIN);
3678:switcherator.c ****         } else if (failTimer == 24)
 5079               		.loc 1 3678 0
 5080 1d7c 8831      		cpi r24,lo8(24)
 5081 1d7e 01F4      		brne .L379
 5082 1d80 00C0      		rjmp .L397
 5083               	.L380:
3679:switcherator.c ****             failTimer = 0;
3680:switcherator.c ****     } else if (failCondition == 2) {
 5084               		.loc 1 3680 0
 5085 1d82 9230      		cpi r25,lo8(2)
 5086 1d84 01F4      		brne .L384
3681:switcherator.c ****         if (failTimer == 2) {
 5087               		.loc 1 3681 0
 5088 1d86 8230      		cpi r24,lo8(2)
 5089 1d88 01F4      		brne .L385
 5090 1d8a 00C0      		rjmp .L398
 5091               	.L385:
3682:switcherator.c ****             INDICATOR_PORT |= INDICATOR_PIN;
3683:switcherator.c ****         } else if (failTimer == 4) {
 5092               		.loc 1 3683 0
 5093 1d8c 8430      		cpi r24,lo8(4)
 5094 1d8e 01F4      		brne .L386
 5095 1d90 00C0      		rjmp .L396
 5096               	.L386:
3684:switcherator.c ****             INDICATOR_PORT &= ~(INDICATOR_PIN);
3685:switcherator.c ****         } else if (failTimer == 8) {
 5097               		.loc 1 3685 0
 5098 1d92 8830      		cpi r24,lo8(8)
 5099 1d94 01F4      		brne .L387
 5100 1d96 00C0      		rjmp .L398
 5101               	.L387:
3686:switcherator.c ****             INDICATOR_PORT |= INDICATOR_PIN;
3687:switcherator.c ****         } else if (failTimer == 10) {
 5102               		.loc 1 3687 0
 5103 1d98 8A30      		cpi r24,lo8(10)
 5104 1d9a 01F4      		brne .L388
 5105 1d9c 00C0      		rjmp .L396
 5106               	.L388:
3688:switcherator.c ****             INDICATOR_PORT &= ~(INDICATOR_PIN);
3689:switcherator.c ****         } else if (failTimer == 30)
 5107               		.loc 1 3689 0
 5108 1d9e 8E31      		cpi r24,lo8(30)
 5109 1da0 01F4      		brne .L379
 5110 1da2 00C0      		rjmp .L397
 5111               	.L384:
3690:switcherator.c ****             failTimer = 0;
3691:switcherator.c ****     } else if (failCondition == 3) {
 5112               		.loc 1 3691 0
 5113 1da4 9330      		cpi r25,lo8(3)
 5114 1da6 01F4      		brne .L379
3692:switcherator.c ****         if (failTimer == 2) {
 5115               		.loc 1 3692 0
 5116 1da8 8230      		cpi r24,lo8(2)
 5117 1daa 01F4      		brne .L389
 5118 1dac 00C0      		rjmp .L398
 5119               	.L389:
3693:switcherator.c ****             INDICATOR_PORT |= INDICATOR_PIN;
3694:switcherator.c ****         } else if (failTimer == 4) {
 5120               		.loc 1 3694 0
 5121 1dae 8430      		cpi r24,lo8(4)
 5122 1db0 01F4      		brne .L390
 5123 1db2 00C0      		rjmp .L396
 5124               	.L390:
3695:switcherator.c ****             INDICATOR_PORT &= ~(INDICATOR_PIN);
3696:switcherator.c ****         } else if (failTimer == 8) {
 5125               		.loc 1 3696 0
 5126 1db4 8830      		cpi r24,lo8(8)
 5127 1db6 01F4      		brne .L391
 5128 1db8 00C0      		rjmp .L398
 5129               	.L391:
3697:switcherator.c ****             INDICATOR_PORT |= INDICATOR_PIN;
3698:switcherator.c ****         } else if (failTimer == 10) {
 5130               		.loc 1 3698 0
 5131 1dba 8A30      		cpi r24,lo8(10)
 5132 1dbc 01F4      		brne .L392
 5133 1dbe 00C0      		rjmp .L396
 5134               	.L392:
3699:switcherator.c ****             INDICATOR_PORT &= ~(INDICATOR_PIN);
3700:switcherator.c ****         } else if (failTimer == 14) {
 5135               		.loc 1 3700 0
 5136 1dc0 8E30      		cpi r24,lo8(14)
 5137 1dc2 01F4      		brne .L393
 5138               	.L398:
3701:switcherator.c ****             INDICATOR_PORT |= INDICATOR_PIN;
 5139               		.loc 1 3701 0
 5140 1dc4 5A9A      		sbi 0xb,2
 5141 1dc6 0895      		ret
 5142               	.L393:
3702:switcherator.c ****         } else if (failTimer == 16) {
 5143               		.loc 1 3702 0
 5144 1dc8 8031      		cpi r24,lo8(16)
 5145 1dca 01F4      		brne .L394
 5146               	.L396:
3703:switcherator.c ****             INDICATOR_PORT &= ~(INDICATOR_PIN);
 5147               		.loc 1 3703 0
 5148 1dcc 5A98      		cbi 0xb,2
 5149 1dce 0895      		ret
 5150               	.L394:
3704:switcherator.c ****         } else if (failTimer == 36)
 5151               		.loc 1 3704 0
 5152 1dd0 8432      		cpi r24,lo8(36)
 5153 1dd2 01F4      		brne .L379
 5154               	.L397:
3705:switcherator.c ****             failTimer = 0;
 5155               		.loc 1 3705 0
 5156 1dd4 1092 0000 		sts failTimer,__zero_reg__
 5157               	.L379:
 5158 1dd8 0895      		ret
 5159               	.LFE79:
 5161               	.global	clearFail
 5163               	clearFail:
 5164               	.LFB80:
3706:switcherator.c ****         }
3707:switcherator.c **** }
3708:switcherator.c **** 
3709:switcherator.c **** // turns off the indicator pin
3710:switcherator.c **** void clearFail(void) {
 5165               		.loc 1 3710 0
 5166               	/* prologue: function */
 5167               	/* frame size = 0 */
 5168               	/* stack size = 0 */
 5169               	.L__stack_usage = 0
3711:switcherator.c ****     failTimer = 0;
 5170               		.loc 1 3711 0
 5171 1dda 1092 0000 		sts failTimer,__zero_reg__
3712:switcherator.c ****     INDICATOR_PORT |= (INDICATOR_PIN);
 5172               		.loc 1 3712 0
 5173 1dde 5A9A      		sbi 0xb,2
3713:switcherator.c ****     INDICATOR_DDR |= (INDICATOR_PIN);
 5174               		.loc 1 3713 0
 5175 1de0 529A      		sbi 0xa,2
 5176 1de2 0895      		ret
 5177               	.LFE80:
 5179               	.global	sendMessage
 5181               	sendMessage:
 5182               	.LFB72:
3029:switcherator.c **** void sendMessage(char * myResponse) {
 5183               		.loc 1 3029 0
 5184               	.LVL376:
 5185               	/* prologue: function */
 5186               	/* frame size = 0 */
 5187               	/* stack size = 0 */
 5188               	.L__stack_usage = 0
 5189               	.LBB25:
 5190               	.LBB26:
 5191               		.file 2 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h"
   1:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
   6:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
   9:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  12:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  17:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  21:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  33:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  35:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  38:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  41:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  42:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  46:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /** \file */
  47:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \code
  49:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \endcode
  53:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  54:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     used.
  58:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  59:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  68:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  77:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  81:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** */
  82:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  83:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  87:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  88:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  93:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  94:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  97:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  98:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
 103:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 104:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /**
 105:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 107:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 109:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 112:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 114:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 120:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 125:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 129:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 132:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 140:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****  */
 141:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** void
 142:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** {
 144:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 153:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 156:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 159:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#else
 160:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#endif
 163:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 164:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 165:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 166:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #else
 167:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	{
 172:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		{
 176:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		}
 180:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		return;
 181:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	}
 182:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	else
 183:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
 186:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** }
 187:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 188:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /**
 189:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 191:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 193:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 196:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 198:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 202:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   
 207:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 211:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****  
 214:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 222:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****  */
 223:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** void
 224:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** {
 226:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 235:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 238:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 241:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#else
 242:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		//round up by default
 243:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#endif
 245:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 246:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 5192               		.loc 2 246 0
 5193 1de4 AFE8      		ldi r26,lo8(399)
 5194 1de6 B1E0      		ldi r27,hi8(399)
 5195 1de8 1197      		1: sbiw r26,1
 5196 1dea 01F4      		brne 1b
 5197 1dec 00C0      		rjmp .
 5198 1dee 0000      		nop
 5199               	.LBE26:
 5200               	.LBE25:
3031:switcherator.c ****     int transmitLength = strlen(myResponse);
 5201               		.loc 1 3031 0
 5202 1df0 DC01      		movw r26,r24
 5203               		0:
 5204 1df2 0D90      		ld __tmp_reg__,X+
 5205 1df4 0020      		tst __tmp_reg__
 5206 1df6 01F4      		brne 0b
 5207 1df8 BD01      		movw r22,r26
 5208 1dfa 6150      		subi r22,1
 5209 1dfc 7109      		sbc r23,__zero_reg__
 5210 1dfe 681B      		sub r22,r24
 5211 1e00 790B      		sbc r23,r25
3032:switcherator.c ****     if(!transmit(myResponse, transmitLength)) {
 5212               		.loc 1 3032 0
 5213 1e02 0E94 0000 		call transmit
 5214               	.LVL377:
 5215 1e06 8111      		cpse r24,__zero_reg__
 5216 1e08 00C0      		rjmp .L401
3033:switcherator.c ****         failCondition = 2;
 5217               		.loc 1 3033 0
 5218 1e0a 82E0      		ldi r24,lo8(2)
 5219 1e0c 8093 0000 		sts failCondition,r24
 5220 1e10 00C0      		rjmp .L402
 5221               	.L401:
3035:switcherator.c ****         failCondition = 0;
 5222               		.loc 1 3035 0
 5223 1e12 1092 0000 		sts failCondition,__zero_reg__
3036:switcherator.c ****         clearFail();
 5224               		.loc 1 3036 0
 5225 1e16 0E94 0000 		call clearFail
 5226               	.LVL378:
 5227               	.L402:
3038:switcherator.c ****     startRx();
 5228               		.loc 1 3038 0
 5229 1e1a 0C94 0000 		jmp startRx
 5230               	.LVL379:
 5231               	.LFE72:
 5233               		.section	.rodata.str1.1
 5234               	.LC6:
 5235 000b 5365 7223 		.string	"Ser#"
 5235      00
 5236               		.text
 5237               	.global	serialNumber
 5239               	serialNumber:
 5240               	.LFB70:
2987:switcherator.c **** void serialNumber(char * commandReceived) {
 5241               		.loc 1 2987 0
 5242               	.LVL380:
 5243 1e1e CF92      		push r12
 5244               	.LCFI124:
 5245 1e20 DF92      		push r13
 5246               	.LCFI125:
 5247 1e22 EF92      		push r14
 5248               	.LCFI126:
 5249 1e24 FF92      		push r15
 5250               	.LCFI127:
 5251 1e26 CF93      		push r28
 5252               	.LCFI128:
 5253 1e28 DF93      		push r29
 5254               	.LCFI129:
 5255               	/* prologue: function */
 5256               	/* frame size = 0 */
 5257               	/* stack size = 6 */
 5258               	.L__stack_usage = 6
 5259 1e2a FC01      		movw r30,r24
2988:switcherator.c ****     tempHugeString[0] = commandReceived[3];
 5260               		.loc 1 2988 0
 5261 1e2c 8381      		ldd r24,Z+3
 5262               	.LVL381:
 5263 1e2e 8093 0000 		sts tempHugeString,r24
2989:switcherator.c ****     tempHugeString[1] = commandReceived[4];
 5264               		.loc 1 2989 0
 5265 1e32 8481      		ldd r24,Z+4
 5266 1e34 8093 0000 		sts tempHugeString+1,r24
2990:switcherator.c ****     tempHugeString[2] = commandReceived[5];
 5267               		.loc 1 2990 0
 5268 1e38 8581      		ldd r24,Z+5
 5269 1e3a 8093 0000 		sts tempHugeString+2,r24
2991:switcherator.c ****     tempHugeString[3] = commandReceived[6];
 5270               		.loc 1 2991 0
 5271 1e3e 8681      		ldd r24,Z+6
 5272 1e40 8093 0000 		sts tempHugeString+3,r24
2992:switcherator.c ****     tempHugeString[4] = commandReceived[7];
 5273               		.loc 1 2992 0
 5274 1e44 8781      		ldd r24,Z+7
 5275 1e46 8093 0000 		sts tempHugeString+4,r24
2993:switcherator.c ****     tempHugeString[5] = commandReceived[8];
 5276               		.loc 1 2993 0
 5277 1e4a 8085      		ldd r24,Z+8
 5278 1e4c 8093 0000 		sts tempHugeString+5,r24
2994:switcherator.c ****     long temp = atol(tempHugeString);
 5279               		.loc 1 2994 0
 5280 1e50 80E0      		ldi r24,lo8(tempHugeString)
 5281 1e52 90E0      		ldi r25,hi8(tempHugeString)
 5282 1e54 0E94 0000 		call atol
 5283               	.LVL382:
 5284 1e58 6B01      		movw r12,r22
 5285 1e5a 7C01      		movw r14,r24
 5286               	.LVL383:
2996:switcherator.c ****     statusMsg[0] = 0;
 5287               		.loc 1 2996 0
 5288 1e5c 1092 0000 		sts statusMsg,__zero_reg__
2998:switcherator.c ****     strcat(statusMsg, "Ser#");
 5289               		.loc 1 2998 0
 5290 1e60 60E0      		ldi r22,lo8(.LC6)
 5291 1e62 70E0      		ldi r23,hi8(.LC6)
 5292 1e64 80E0      		ldi r24,lo8(statusMsg)
 5293 1e66 90E0      		ldi r25,hi8(statusMsg)
 5294 1e68 0E94 0000 		call strcat
 5295               	.LVL384:
2999:switcherator.c ****     if (temp > 0) {
 5296               		.loc 1 2999 0
 5297 1e6c 1C14      		cp __zero_reg__,r12
 5298 1e6e 1D04      		cpc __zero_reg__,r13
 5299 1e70 1E04      		cpc __zero_reg__,r14
 5300 1e72 1F04      		cpc __zero_reg__,r15
 5301 1e74 04F4      		brge .L404
3001:switcherator.c ****         serial = temp;
 5302               		.loc 1 3001 0
 5303 1e76 C092 0000 		sts serial,r12
 5304 1e7a D092 0000 		sts serial+1,r13
 5305 1e7e E092 0000 		sts serial+2,r14
 5306 1e82 F092 0000 		sts serial+3,r15
3002:switcherator.c ****         ltoa(serial, stringSerial, 10);
 5307               		.loc 1 3002 0
 5308 1e86 2AE0      		ldi r18,lo8(10)
 5309 1e88 30E0      		ldi r19,0
 5310 1e8a 40E0      		ldi r20,lo8(stringSerial)
 5311 1e8c 50E0      		ldi r21,hi8(stringSerial)
 5312 1e8e C701      		movw r24,r14
 5313 1e90 B601      		movw r22,r12
 5314 1e92 0E94 0000 		call ltoa
 5315               	.LVL385:
 5316               	.L404:
3005:switcherator.c ****     serialLength = strlen(stringSerial);
 5317               		.loc 1 3005 0
 5318 1e96 C0E0      		ldi r28,lo8(stringSerial)
 5319 1e98 D0E0      		ldi r29,hi8(stringSerial)
 5320               		0:
 5321 1e9a 0990      		ld __tmp_reg__,Y+
 5322 1e9c 0020      		tst __tmp_reg__
 5323 1e9e 01F4      		brne 0b
 5324               	.LVL386:
 5325 1ea0 2197      		sbiw r28,1
 5326 1ea2 C050      		subi r28,lo8(stringSerial)
 5327 1ea4 D040      		sbci r29,hi8(stringSerial)
 5328               	.LVL387:
3006:switcherator.c ****     while (serialLength < 6) {
 5329               		.loc 1 3006 0
 5330 1ea6 00C0      		rjmp .L405
 5331               	.L406:
3007:switcherator.c ****         strcat(statusMsg, "0");
 5332               		.loc 1 3007 0
 5333 1ea8 60E0      		ldi r22,lo8(.LC1)
 5334 1eaa 70E0      		ldi r23,hi8(.LC1)
 5335 1eac 80E0      		ldi r24,lo8(statusMsg)
 5336 1eae 90E0      		ldi r25,hi8(statusMsg)
 5337 1eb0 0E94 0000 		call strcat
 5338               	.LVL388:
3008:switcherator.c ****         serialLength++;
 5339               		.loc 1 3008 0
 5340 1eb4 2196      		adiw r28,1
 5341               	.LVL389:
 5342               	.L405:
3006:switcherator.c ****     while (serialLength < 6) {
 5343               		.loc 1 3006 0 discriminator 1
 5344 1eb6 C630      		cpi r28,6
 5345 1eb8 D105      		cpc r29,__zero_reg__
 5346 1eba 04F0      		brlt .L406
3010:switcherator.c ****     strcat(statusMsg, stringSerial);
 5347               		.loc 1 3010 0
 5348 1ebc 60E0      		ldi r22,lo8(stringSerial)
 5349 1ebe 70E0      		ldi r23,hi8(stringSerial)
 5350 1ec0 80E0      		ldi r24,lo8(statusMsg)
 5351 1ec2 90E0      		ldi r25,hi8(statusMsg)
 5352 1ec4 0E94 0000 		call strcat
 5353               	.LVL390:
3011:switcherator.c ****     sendMessage(statusMsg);
 5354               		.loc 1 3011 0
 5355 1ec8 80E0      		ldi r24,lo8(statusMsg)
 5356 1eca 90E0      		ldi r25,hi8(statusMsg)
 5357               	/* epilogue start */
3012:switcherator.c **** }
 5358               		.loc 1 3012 0
 5359 1ecc DF91      		pop r29
 5360 1ece CF91      		pop r28
 5361               	.LVL391:
 5362 1ed0 FF90      		pop r15
 5363 1ed2 EF90      		pop r14
 5364 1ed4 DF90      		pop r13
 5365 1ed6 CF90      		pop r12
 5366               	.LVL392:
3011:switcherator.c ****     sendMessage(statusMsg);
 5367               		.loc 1 3011 0
 5368 1ed8 0C94 0000 		jmp sendMessage
 5369               	.LVL393:
 5370               	.LFE70:
 5372               		.section	.rodata.str1.1
 5373               	.LC9:
 5374 0010 7230 2030 		.string	"r0 0x"
 5374      7800 
 5375               	.LC10:
 5376 0016 7231 2030 		.string	"r1 0x"
 5376      7800 
 5377               	.LC11:
 5378 001c 7232 2030 		.string	"r2 0x"
 5378      7800 
 5379               	.LC12:
 5380 0022 7233 2030 		.string	"r3 0x"
 5380      7800 
 5381               	.LC13:
 5382 0028 7234 2030 		.string	"r4 0x"
 5382      7800 
 5383               	.LC14:
 5384 002e 7235 2030 		.string	"r5 0x"
 5384      7800 
 5385               	.LC15:
 5386 0034 7420 3078 		.string	"t 0x"
 5386      00
 5387               	.LC7:
 5388 0039 3078 3030 		.string	"0x00"
 5388      00
 5389               	.LC8:
 5390 003e 3030 3030 		.string	"00000"
 5390      3000 
 5391               		.text
 5392               	.global	radioChangeAddress
 5394               	radioChangeAddress:
 5395               	.LFB69:
2923:switcherator.c **** void radioChangeAddress(char * commandReceived) {
 5396               		.loc 1 2923 0
 5397               	.LVL394:
 5398 1edc 2F92      		push r2
 5399               	.LCFI130:
 5400 1ede 3F92      		push r3
 5401               	.LCFI131:
 5402 1ee0 4F92      		push r4
 5403               	.LCFI132:
 5404 1ee2 5F92      		push r5
 5405               	.LCFI133:
 5406 1ee4 6F92      		push r6
 5407               	.LCFI134:
 5408 1ee6 7F92      		push r7
 5409               	.LCFI135:
 5410 1ee8 8F92      		push r8
 5411               	.LCFI136:
 5412 1eea 9F92      		push r9
 5413               	.LCFI137:
 5414 1eec AF92      		push r10
 5415               	.LCFI138:
 5416 1eee BF92      		push r11
 5417               	.LCFI139:
 5418 1ef0 CF92      		push r12
 5419               	.LCFI140:
 5420 1ef2 DF92      		push r13
 5421               	.LCFI141:
 5422 1ef4 EF92      		push r14
 5423               	.LCFI142:
 5424 1ef6 FF92      		push r15
 5425               	.LCFI143:
 5426 1ef8 0F93      		push r16
 5427               	.LCFI144:
 5428 1efa 1F93      		push r17
 5429               	.LCFI145:
 5430 1efc CF93      		push r28
 5431               	.LCFI146:
 5432 1efe DF93      		push r29
 5433               	.LCFI147:
 5434 1f00 CDB7      		in r28,__SP_L__
 5435 1f02 DEB7      		in r29,__SP_H__
 5436               	.LCFI148:
 5437 1f04 2B97      		sbiw r28,11
 5438               	.LCFI149:
 5439 1f06 0FB6      		in __tmp_reg__,__SREG__
 5440 1f08 F894      		cli
 5441 1f0a DEBF      		out __SP_H__,r29
 5442 1f0c 0FBE      		out __SREG__,__tmp_reg__
 5443 1f0e CDBF      		out __SP_L__,r28
 5444               	/* prologue: function */
 5445               	/* frame size = 11 */
 5446               	/* stack size = 29 */
 5447               	.L__stack_usage = 29
 5448 1f10 5C01      		movw r10,r24
 5449               	.LVL395:
2925:switcherator.c ****     statusMsg[0] = 0;
 5450               		.loc 1 2925 0
 5451 1f12 1092 0000 		sts statusMsg,__zero_reg__
 5452               	.LVL396:
2928:switcherator.c ****     char tempString[] = "0x00";
 5453               		.loc 1 2928 0
 5454 1f16 85E0      		ldi r24,lo8(5)
 5455               	.LVL397:
 5456 1f18 E0E0      		ldi r30,lo8(.LC7)
 5457 1f1a F0E0      		ldi r31,hi8(.LC7)
 5458 1f1c DE01      		movw r26,r28
 5459 1f1e 1796      		adiw r26,7
 5460               		0:
 5461 1f20 0190      		ld r0,Z+
 5462 1f22 0D92      		st X+,r0
 5463 1f24 8A95      		dec r24
 5464 1f26 01F4      		brne 0b
2929:switcherator.c ****     char tempRadioString[] = "00000";
 5465               		.loc 1 2929 0
 5466 1f28 86E0      		ldi r24,lo8(6)
 5467 1f2a E0E0      		ldi r30,lo8(.LC8)
 5468 1f2c F0E0      		ldi r31,hi8(.LC8)
 5469 1f2e DE01      		movw r26,r28
 5470 1f30 1196      		adiw r26,1
 5471               		0:
 5472 1f32 0190      		ld r0,Z+
 5473 1f34 0D92      		st X+,r0
 5474 1f36 8A95      		dec r24
 5475 1f38 01F4      		brne 0b
2923:switcherator.c **** void radioChangeAddress(char * commandReceived) {
 5476               		.loc 1 2923 0
 5477 1f3a 6501      		movw r12,r10
 5478 1f3c 88E0      		ldi r24,8
 5479 1f3e C80E      		add r12,r24
 5480 1f40 D11C      		adc r13,__zero_reg__
2927:switcherator.c ****     uint64_t newAddress = 0;
 5481               		.loc 1 2927 0
 5482 1f42 212C      		mov r2,__zero_reg__
 5483 1f44 312C      		mov r3,__zero_reg__
 5484 1f46 412C      		mov r4,__zero_reg__
 5485 1f48 512C      		mov r5,__zero_reg__
 5486 1f4a 612C      		mov r6,__zero_reg__
 5487 1f4c 712C      		mov r7,__zero_reg__
 5488 1f4e 812C      		mov r8,__zero_reg__
 5489 1f50 912C      		mov r9,__zero_reg__
2930:switcherator.c ****     for (x = 0; x < 5; x++) {
 5490               		.loc 1 2930 0
 5491 1f52 E12C      		mov r14,__zero_reg__
 5492 1f54 F12C      		mov r15,__zero_reg__
 5493               	.LVL398:
 5494               	.L409:
2923:switcherator.c **** void radioChangeAddress(char * commandReceived) {
 5495               		.loc 1 2923 0
 5496 1f56 F601      		movw r30,r12
 5497 1f58 3197      		sbiw r30,1
2931:switcherator.c ****         tempString[2] = commandReceived[((x * 2) + 7)];
 5498               		.loc 1 2931 0
 5499 1f5a 8081      		ld r24,Z
 5500 1f5c 8987      		std Y+9,r24
2932:switcherator.c ****         tempString[3] = commandReceived[((x * 2) + 8)];
 5501               		.loc 1 2932 0
 5502 1f5e F601      		movw r30,r12
 5503 1f60 8081      		ld r24,Z
 5504 1f62 8A87      		std Y+10,r24
2933:switcherator.c ****         tempInt = strtol(tempString, 0, 0);
 5505               		.loc 1 2933 0
 5506 1f64 40E0      		ldi r20,0
 5507 1f66 50E0      		ldi r21,0
 5508 1f68 60E0      		ldi r22,0
 5509 1f6a 70E0      		ldi r23,0
 5510 1f6c CE01      		movw r24,r28
 5511 1f6e 0796      		adiw r24,7
 5512 1f70 0E94 0000 		call strtol
 5513               	.LVL399:
2934:switcherator.c ****         newAddress |= tempInt;
 5514               		.loc 1 2934 0
 5515 1f74 872F      		mov r24,r23
 5516 1f76 880F      		lsl r24
 5517 1f78 880B      		sbc r24,r24
 5518 1f7a 262A      		or r2,r22
 5519 1f7c 372A      		or r3,r23
 5520 1f7e 482A      		or r4,r24
 5521 1f80 582A      		or r5,r24
 5522 1f82 682A      		or r6,r24
 5523 1f84 782A      		or r7,r24
 5524 1f86 882A      		or r8,r24
 5525 1f88 982A      		or r9,r24
 5526               	.LVL400:
2935:switcherator.c ****         if (x < 4)
 5527               		.loc 1 2935 0
 5528 1f8a F4E0      		ldi r31,4
 5529 1f8c EF16      		cp r14,r31
 5530 1f8e F104      		cpc r15,__zero_reg__
 5531 1f90 01F0      		breq .L408
2936:switcherator.c ****             newAddress <<= 8;
 5532               		.loc 1 2936 0
 5533 1f92 9101      		movw r18,r2
 5534 1f94 A201      		movw r20,r4
 5535 1f96 B301      		movw r22,r6
 5536 1f98 C401      		movw r24,r8
 5537 1f9a 08E0      		ldi r16,lo8(8)
 5538 1f9c 0E94 0000 		call __ashldi3
 5539 1fa0 1901      		movw r2,r18
 5540               	.LVL401:
 5541 1fa2 2A01      		movw r4,r20
 5542 1fa4 3B01      		movw r6,r22
 5543 1fa6 4C01      		movw r8,r24
 5544               	.LVL402:
 5545               	.L408:
2930:switcherator.c ****     for (x = 0; x < 5; x++) {
 5546               		.loc 1 2930 0
 5547 1fa8 8FEF      		ldi r24,-1
 5548 1faa E81A      		sub r14,r24
 5549 1fac F80A      		sbc r15,r24
 5550               	.LVL403:
 5551 1fae E2E0      		ldi r30,2
 5552 1fb0 CE0E      		add r12,r30
 5553 1fb2 D11C      		adc r13,__zero_reg__
 5554 1fb4 F5E0      		ldi r31,5
 5555 1fb6 EF16      		cp r14,r31
 5556 1fb8 F104      		cpc r15,__zero_reg__
 5557 1fba 01F4      		brne .L409
2938:switcherator.c ****     switch (commandReceived[3]) {
 5558               		.loc 1 2938 0
 5559 1fbc F501      		movw r30,r10
 5560 1fbe 8381      		ldd r24,Z+3
 5561 1fc0 8333      		cpi r24,lo8(51)
 5562 1fc2 01F4      		brne .+2
 5563 1fc4 00C0      		rjmp .L414
 5564 1fc6 00F4      		brsh .L418
 5565 1fc8 8133      		cpi r24,lo8(49)
 5566 1fca 01F0      		breq .L412
 5567 1fcc 00F0      		brlo .+2
 5568 1fce 00C0      		rjmp .L413
 5569 1fd0 8033      		cpi r24,lo8(48)
 5570 1fd2 01F0      		breq .+2
 5571 1fd4 00C0      		rjmp .L410
 5572 1fd6 00C0      		rjmp .L411
 5573               	.L418:
 5574 1fd8 8533      		cpi r24,lo8(53)
 5575 1fda 01F4      		brne .+2
 5576 1fdc 00C0      		rjmp .L416
 5577 1fde 00F4      		brsh .+2
 5578 1fe0 00C0      		rjmp .L415
 5579 1fe2 8435      		cpi r24,lo8(84)
 5580 1fe4 01F0      		breq .+2
 5581 1fe6 00C0      		rjmp .L410
 5582 1fe8 00C0      		rjmp .L417
 5583               	.L411:
2940:switcherator.c ****             rx_addr_p0 = newAddress;
 5584               		.loc 1 2940 0
 5585 1fea 2092 0000 		sts rx_addr_p0,r2
 5586 1fee 3092 0000 		sts rx_addr_p0+1,r3
 5587 1ff2 4092 0000 		sts rx_addr_p0+2,r4
 5588 1ff6 5092 0000 		sts rx_addr_p0+3,r5
 5589 1ffa 6092 0000 		sts rx_addr_p0+4,r6
 5590 1ffe 7092 0000 		sts rx_addr_p0+5,r7
 5591 2002 8092 0000 		sts rx_addr_p0+6,r8
 5592 2006 9092 0000 		sts rx_addr_p0+7,r9
2941:switcherator.c ****             strcat(statusMsg, "r0 0x");
 5593               		.loc 1 2941 0
 5594 200a 60E0      		ldi r22,lo8(.LC9)
 5595 200c 70E0      		ldi r23,hi8(.LC9)
 5596 200e 80E0      		ldi r24,lo8(statusMsg)
 5597 2010 90E0      		ldi r25,hi8(statusMsg)
 5598 2012 0E94 0000 		call strcat
 5599               	.LVL404:
2942:switcherator.c ****             writeAddr(RX_ADDR_P0, newAddress);
 5600               		.loc 1 2942 0
 5601 2016 8101      		movw r16,r2
 5602 2018 9201      		movw r18,r4
 5603 201a A301      		movw r20,r6
 5604 201c B401      		movw r22,r8
 5605 201e 8AE0      		ldi r24,lo8(10)
 5606 2020 00C0      		rjmp .L425
 5607               	.L412:
2945:switcherator.c ****             rx_addr_p1 = newAddress;
 5608               		.loc 1 2945 0
 5609 2022 2092 0000 		sts rx_addr_p1,r2
 5610 2026 3092 0000 		sts rx_addr_p1+1,r3
 5611 202a 4092 0000 		sts rx_addr_p1+2,r4
 5612 202e 5092 0000 		sts rx_addr_p1+3,r5
 5613 2032 6092 0000 		sts rx_addr_p1+4,r6
 5614 2036 7092 0000 		sts rx_addr_p1+5,r7
 5615 203a 8092 0000 		sts rx_addr_p1+6,r8
 5616 203e 9092 0000 		sts rx_addr_p1+7,r9
2946:switcherator.c ****             strcat(statusMsg, "r1 0x");
 5617               		.loc 1 2946 0
 5618 2042 60E0      		ldi r22,lo8(.LC10)
 5619 2044 70E0      		ldi r23,hi8(.LC10)
 5620 2046 80E0      		ldi r24,lo8(statusMsg)
 5621 2048 90E0      		ldi r25,hi8(statusMsg)
 5622 204a 0E94 0000 		call strcat
 5623               	.LVL405:
2947:switcherator.c ****             writeAddr(RX_ADDR_P1, newAddress);
 5624               		.loc 1 2947 0
 5625 204e 8101      		movw r16,r2
 5626 2050 9201      		movw r18,r4
 5627 2052 A301      		movw r20,r6
 5628 2054 B401      		movw r22,r8
 5629 2056 8BE0      		ldi r24,lo8(11)
 5630 2058 00C0      		rjmp .L425
 5631               	.L413:
2950:switcherator.c ****             rx_addr_p2 = newAddress;
 5632               		.loc 1 2950 0
 5633 205a 2092 0000 		sts rx_addr_p2,r2
 5634 205e 3092 0000 		sts rx_addr_p2+1,r3
 5635 2062 4092 0000 		sts rx_addr_p2+2,r4
 5636 2066 5092 0000 		sts rx_addr_p2+3,r5
 5637 206a 6092 0000 		sts rx_addr_p2+4,r6
 5638 206e 7092 0000 		sts rx_addr_p2+5,r7
 5639 2072 8092 0000 		sts rx_addr_p2+6,r8
 5640 2076 9092 0000 		sts rx_addr_p2+7,r9
2951:switcherator.c ****             strcat(statusMsg, "r2 0x");
 5641               		.loc 1 2951 0
 5642 207a 60E0      		ldi r22,lo8(.LC11)
 5643 207c 70E0      		ldi r23,hi8(.LC11)
 5644 207e 80E0      		ldi r24,lo8(statusMsg)
 5645 2080 90E0      		ldi r25,hi8(statusMsg)
 5646 2082 0E94 0000 		call strcat
 5647               	.LVL406:
2952:switcherator.c ****             writeAddr(RX_ADDR_P2, newAddress);
 5648               		.loc 1 2952 0
 5649 2086 8101      		movw r16,r2
 5650 2088 9201      		movw r18,r4
 5651 208a A301      		movw r20,r6
 5652 208c B401      		movw r22,r8
 5653 208e 8CE0      		ldi r24,lo8(12)
 5654 2090 00C0      		rjmp .L425
 5655               	.L414:
2955:switcherator.c ****             rx_addr_p3 = newAddress;
 5656               		.loc 1 2955 0
 5657 2092 2092 0000 		sts rx_addr_p3,r2
 5658 2096 3092 0000 		sts rx_addr_p3+1,r3
 5659 209a 4092 0000 		sts rx_addr_p3+2,r4
 5660 209e 5092 0000 		sts rx_addr_p3+3,r5
 5661 20a2 6092 0000 		sts rx_addr_p3+4,r6
 5662 20a6 7092 0000 		sts rx_addr_p3+5,r7
 5663 20aa 8092 0000 		sts rx_addr_p3+6,r8
 5664 20ae 9092 0000 		sts rx_addr_p3+7,r9
2956:switcherator.c ****             strcat(statusMsg, "r3 0x");
 5665               		.loc 1 2956 0
 5666 20b2 60E0      		ldi r22,lo8(.LC12)
 5667 20b4 70E0      		ldi r23,hi8(.LC12)
 5668 20b6 80E0      		ldi r24,lo8(statusMsg)
 5669 20b8 90E0      		ldi r25,hi8(statusMsg)
 5670 20ba 0E94 0000 		call strcat
 5671               	.LVL407:
2957:switcherator.c ****             writeAddr(RX_ADDR_P3, newAddress);
 5672               		.loc 1 2957 0
 5673 20be 8101      		movw r16,r2
 5674 20c0 9201      		movw r18,r4
 5675 20c2 A301      		movw r20,r6
 5676 20c4 B401      		movw r22,r8
 5677 20c6 8DE0      		ldi r24,lo8(13)
 5678 20c8 00C0      		rjmp .L425
 5679               	.L415:
2960:switcherator.c ****             rx_addr_p4 = newAddress;
 5680               		.loc 1 2960 0
 5681 20ca 2092 0000 		sts rx_addr_p4,r2
 5682 20ce 3092 0000 		sts rx_addr_p4+1,r3
 5683 20d2 4092 0000 		sts rx_addr_p4+2,r4
 5684 20d6 5092 0000 		sts rx_addr_p4+3,r5
 5685 20da 6092 0000 		sts rx_addr_p4+4,r6
 5686 20de 7092 0000 		sts rx_addr_p4+5,r7
 5687 20e2 8092 0000 		sts rx_addr_p4+6,r8
 5688 20e6 9092 0000 		sts rx_addr_p4+7,r9
2961:switcherator.c ****             strcat(statusMsg, "r4 0x");
 5689               		.loc 1 2961 0
 5690 20ea 60E0      		ldi r22,lo8(.LC13)
 5691 20ec 70E0      		ldi r23,hi8(.LC13)
 5692 20ee 80E0      		ldi r24,lo8(statusMsg)
 5693 20f0 90E0      		ldi r25,hi8(statusMsg)
 5694 20f2 0E94 0000 		call strcat
 5695               	.LVL408:
2962:switcherator.c ****             writeAddr(RX_ADDR_P4, newAddress);
 5696               		.loc 1 2962 0
 5697 20f6 8101      		movw r16,r2
 5698 20f8 9201      		movw r18,r4
 5699 20fa A301      		movw r20,r6
 5700 20fc B401      		movw r22,r8
 5701 20fe 8EE0      		ldi r24,lo8(14)
 5702 2100 00C0      		rjmp .L425
 5703               	.L416:
2965:switcherator.c ****             rx_addr_p5 = newAddress;
 5704               		.loc 1 2965 0
 5705 2102 2092 0000 		sts rx_addr_p5,r2
 5706 2106 3092 0000 		sts rx_addr_p5+1,r3
 5707 210a 4092 0000 		sts rx_addr_p5+2,r4
 5708 210e 5092 0000 		sts rx_addr_p5+3,r5
 5709 2112 6092 0000 		sts rx_addr_p5+4,r6
 5710 2116 7092 0000 		sts rx_addr_p5+5,r7
 5711 211a 8092 0000 		sts rx_addr_p5+6,r8
 5712 211e 9092 0000 		sts rx_addr_p5+7,r9
2966:switcherator.c ****             strcat(statusMsg, "r5 0x");
 5713               		.loc 1 2966 0
 5714 2122 60E0      		ldi r22,lo8(.LC14)
 5715 2124 70E0      		ldi r23,hi8(.LC14)
 5716 2126 80E0      		ldi r24,lo8(statusMsg)
 5717 2128 90E0      		ldi r25,hi8(statusMsg)
 5718 212a 0E94 0000 		call strcat
 5719               	.LVL409:
2967:switcherator.c ****             writeAddr(RX_ADDR_P5, newAddress);
 5720               		.loc 1 2967 0
 5721 212e 8101      		movw r16,r2
 5722 2130 9201      		movw r18,r4
 5723 2132 A301      		movw r20,r6
 5724 2134 B401      		movw r22,r8
 5725 2136 8FE0      		ldi r24,lo8(15)
 5726 2138 00C0      		rjmp .L425
 5727               	.L417:
2970:switcherator.c ****             tx_addr = newAddress;
 5728               		.loc 1 2970 0
 5729 213a 2092 0000 		sts tx_addr,r2
 5730 213e 3092 0000 		sts tx_addr+1,r3
 5731 2142 4092 0000 		sts tx_addr+2,r4
 5732 2146 5092 0000 		sts tx_addr+3,r5
 5733 214a 6092 0000 		sts tx_addr+4,r6
 5734 214e 7092 0000 		sts tx_addr+5,r7
 5735 2152 8092 0000 		sts tx_addr+6,r8
 5736 2156 9092 0000 		sts tx_addr+7,r9
2971:switcherator.c ****             strcat(statusMsg, "t 0x");
 5737               		.loc 1 2971 0
 5738 215a 60E0      		ldi r22,lo8(.LC15)
 5739 215c 70E0      		ldi r23,hi8(.LC15)
 5740 215e 80E0      		ldi r24,lo8(statusMsg)
 5741 2160 90E0      		ldi r25,hi8(statusMsg)
 5742 2162 0E94 0000 		call strcat
 5743               	.LVL410:
2972:switcherator.c ****             writeAddr(TX_ADDR, newAddress);
 5744               		.loc 1 2972 0
 5745 2166 8101      		movw r16,r2
 5746 2168 9201      		movw r18,r4
 5747 216a A301      		movw r20,r6
 5748 216c B401      		movw r22,r8
 5749 216e 80E1      		ldi r24,lo8(16)
 5750               	.L425:
 5751 2170 0E94 0000 		call writeAddr
 5752               	.LVL411:
 5753               	.L410:
2975:switcherator.c ****     unformatAddress(newAddress, tempRadioString);
 5754               		.loc 1 2975 0
 5755 2174 8E01      		movw r16,r28
 5756 2176 0F5F      		subi r16,-1
 5757 2178 1F4F      		sbci r17,-1
 5758 217a 9101      		movw r18,r2
 5759 217c A201      		movw r20,r4
 5760 217e B301      		movw r22,r6
 5761 2180 C401      		movw r24,r8
 5762 2182 0E94 0000 		call unformatAddress
 5763               	.LVL412:
 5764 2186 7801      		movw r14,r16
2923:switcherator.c **** void radioChangeAddress(char * commandReceived) {
 5765               		.loc 1 2923 0
 5766 2188 6E01      		movw r12,r28
 5767 218a F6E0      		ldi r31,6
 5768 218c CF0E      		add r12,r31
 5769 218e D11C      		adc r13,__zero_reg__
 5770               	.LVL413:
 5771               	.L419:
2977:switcherator.c ****         returnHexWithout(tempRadioString[x], tempLongString);
 5772               		.loc 1 2977 0 discriminator 2
 5773 2190 60E0      		ldi r22,lo8(tempLongString)
 5774 2192 70E0      		ldi r23,hi8(tempLongString)
 5775 2194 F701      		movw r30,r14
 5776 2196 8191      		ld r24,Z+
 5777 2198 7F01      		movw r14,r30
 5778 219a 90E0      		ldi r25,0
 5779 219c 0E94 0000 		call returnHexWithout
 5780               	.LVL414:
2978:switcherator.c ****         strcat(statusMsg, tempLongString);
 5781               		.loc 1 2978 0 discriminator 2
 5782 21a0 60E0      		ldi r22,lo8(tempLongString)
 5783 21a2 70E0      		ldi r23,hi8(tempLongString)
 5784 21a4 80E0      		ldi r24,lo8(statusMsg)
 5785 21a6 90E0      		ldi r25,hi8(statusMsg)
 5786 21a8 0E94 0000 		call strcat
 5787               	.LVL415:
2976:switcherator.c ****     for (x = 0; x < 5; x++) {
 5788               		.loc 1 2976 0 discriminator 2
 5789 21ac EC14      		cp r14,r12
 5790 21ae FD04      		cpc r15,r13
 5791 21b0 01F4      		brne .L419
2980:switcherator.c ****     sendMessage(statusMsg);
 5792               		.loc 1 2980 0
 5793 21b2 80E0      		ldi r24,lo8(statusMsg)
 5794 21b4 90E0      		ldi r25,hi8(statusMsg)
 5795 21b6 0E94 0000 		call sendMessage
 5796               	.LVL416:
 5797               	/* epilogue start */
2981:switcherator.c **** }
 5798               		.loc 1 2981 0
 5799 21ba 2B96      		adiw r28,11
 5800 21bc 0FB6      		in __tmp_reg__,__SREG__
 5801 21be F894      		cli
 5802 21c0 DEBF      		out __SP_H__,r29
 5803 21c2 0FBE      		out __SREG__,__tmp_reg__
 5804 21c4 CDBF      		out __SP_L__,r28
 5805 21c6 DF91      		pop r29
 5806 21c8 CF91      		pop r28
 5807 21ca 1F91      		pop r17
 5808 21cc 0F91      		pop r16
 5809 21ce FF90      		pop r15
 5810 21d0 EF90      		pop r14
 5811 21d2 DF90      		pop r13
 5812 21d4 CF90      		pop r12
 5813 21d6 BF90      		pop r11
 5814 21d8 AF90      		pop r10
 5815               	.LVL417:
 5816 21da 9F90      		pop r9
 5817               	.LVL418:
 5818 21dc 8F90      		pop r8
 5819 21de 7F90      		pop r7
 5820 21e0 6F90      		pop r6
 5821 21e2 5F90      		pop r5
 5822 21e4 4F90      		pop r4
 5823 21e6 3F90      		pop r3
 5824 21e8 2F90      		pop r2
 5825 21ea 0895      		ret
 5826               	.LFE69:
 5828               		.section	.rodata.str1.1
 5829               	.LC16:
 5830 0044 7231 2D30 		.string	"r1-0x"
 5830      7800 
 5831               	.LC17:
 5832 004a 7232 2D30 		.string	"r2-0x"
 5832      7800 
 5833               	.LC18:
 5834 0050 7233 2D30 		.string	"r3-0x"
 5834      7800 
 5835               	.LC19:
 5836 0056 7234 2D30 		.string	"r4-0x"
 5836      7800 
 5837               	.LC20:
 5838 005c 7235 2D30 		.string	"r5-0x"
 5838      7800 
 5839               	.LC21:
 5840 0062 742D 3078 		.string	"t-0x"
 5840      00
 5841               	.LC22:
 5842 0067 7230 2D30 		.string	"r0-0x"
 5842      7800 
 5843               		.text
 5844               	.global	radioDisplayAddress
 5846               	radioDisplayAddress:
 5847               	.LFB68:
2875:switcherator.c **** void radioDisplayAddress(char * commandReceived) {
 5848               		.loc 1 2875 0
 5849               	.LVL419:
 5850 21ec EF92      		push r14
 5851               	.LCFI150:
 5852 21ee FF92      		push r15
 5853               	.LCFI151:
 5854 21f0 0F93      		push r16
 5855               	.LCFI152:
 5856 21f2 1F93      		push r17
 5857               	.LCFI153:
 5858 21f4 CF93      		push r28
 5859               	.LCFI154:
 5860 21f6 DF93      		push r29
 5861               	.LCFI155:
 5862 21f8 00D0      		rcall .
 5863 21fa 00D0      		rcall .
 5864 21fc 00D0      		rcall .
 5865               	.LCFI156:
 5866 21fe CDB7      		in r28,__SP_L__
 5867 2200 DEB7      		in r29,__SP_H__
 5868               	.LCFI157:
 5869               	/* prologue: function */
 5870               	/* frame size = 6 */
 5871               	/* stack size = 12 */
 5872               	.L__stack_usage = 12
 5873               	.LVL420:
2878:switcherator.c ****     statusMsg[0] = 0;
 5874               		.loc 1 2878 0
 5875 2202 1092 0000 		sts statusMsg,__zero_reg__
2879:switcherator.c ****     switch (commandReceived[3]) {
 5876               		.loc 1 2879 0
 5877 2206 FC01      		movw r30,r24
 5878 2208 8381      		ldd r24,Z+3
 5879               	.LVL421:
 5880 220a 8333      		cpi r24,lo8(51)
 5881 220c 01F4      		brne .+2
 5882 220e 00C0      		rjmp .L430
 5883 2210 00F4      		brsh .L434
 5884 2212 8133      		cpi r24,lo8(49)
 5885 2214 01F0      		breq .L428
 5886 2216 8233      		cpi r24,lo8(50)
 5887 2218 01F0      		breq .+2
 5888 221a 00C0      		rjmp .L427
 5889 221c 00C0      		rjmp .L429
 5890               	.L434:
 5891 221e 8533      		cpi r24,lo8(53)
 5892 2220 01F4      		brne .+2
 5893 2222 00C0      		rjmp .L432
 5894 2224 00F4      		brsh .+2
 5895 2226 00C0      		rjmp .L431
 5896 2228 8435      		cpi r24,lo8(84)
 5897 222a 01F0      		breq .+2
 5898 222c 00C0      		rjmp .L427
 5899 222e 00C0      		rjmp .L433
 5900               	.L428:
2881:switcherator.c ****             unformatAddress(rx_addr_p1, tempRadioString);
 5901               		.loc 1 2881 0
 5902 2230 2091 0000 		lds r18,rx_addr_p1
 5903 2234 3091 0000 		lds r19,rx_addr_p1+1
 5904 2238 4091 0000 		lds r20,rx_addr_p1+2
 5905 223c 5091 0000 		lds r21,rx_addr_p1+3
 5906 2240 6091 0000 		lds r22,rx_addr_p1+4
 5907 2244 7091 0000 		lds r23,rx_addr_p1+5
 5908 2248 8E01      		movw r16,r28
 5909 224a 0F5F      		subi r16,-1
 5910 224c 1F4F      		sbci r17,-1
 5911 224e 8091 0000 		lds r24,rx_addr_p1+6
 5912 2252 9091 0000 		lds r25,rx_addr_p1+7
 5913 2256 0E94 0000 		call unformatAddress
 5914               	.LVL422:
2882:switcherator.c ****             strcat(statusMsg, "r1-0x");
 5915               		.loc 1 2882 0
 5916 225a 60E0      		ldi r22,lo8(.LC16)
 5917 225c 70E0      		ldi r23,hi8(.LC16)
 5918               	.L438:
 5919 225e 80E0      		ldi r24,lo8(statusMsg)
 5920 2260 90E0      		ldi r25,hi8(statusMsg)
 5921 2262 0E94 0000 		call strcat
 5922               	.LVL423:
 5923 2266 8E01      		movw r16,r28
 5924 2268 0F5F      		subi r16,-1
 5925 226a 1F4F      		sbci r17,-1
2875:switcherator.c **** void radioDisplayAddress(char * commandReceived) {
 5926               		.loc 1 2875 0
 5927 226c 7E01      		movw r14,r28
 5928 226e F6E0      		ldi r31,6
 5929 2270 EF0E      		add r14,r31
 5930 2272 F11C      		adc r15,__zero_reg__
 5931 2274 00C0      		rjmp .L435
 5932               	.LVL424:
 5933               	.L429:
2885:switcherator.c ****             unformatAddress(rx_addr_p2, tempRadioString);
 5934               		.loc 1 2885 0
 5935 2276 2091 0000 		lds r18,rx_addr_p2
 5936 227a 3091 0000 		lds r19,rx_addr_p2+1
 5937 227e 4091 0000 		lds r20,rx_addr_p2+2
 5938 2282 5091 0000 		lds r21,rx_addr_p2+3
 5939 2286 6091 0000 		lds r22,rx_addr_p2+4
 5940 228a 7091 0000 		lds r23,rx_addr_p2+5
 5941 228e 8E01      		movw r16,r28
 5942 2290 0F5F      		subi r16,-1
 5943 2292 1F4F      		sbci r17,-1
 5944 2294 8091 0000 		lds r24,rx_addr_p2+6
 5945 2298 9091 0000 		lds r25,rx_addr_p2+7
 5946 229c 0E94 0000 		call unformatAddress
 5947               	.LVL425:
2886:switcherator.c ****             strcat(statusMsg, "r2-0x");
 5948               		.loc 1 2886 0
 5949 22a0 60E0      		ldi r22,lo8(.LC17)
 5950 22a2 70E0      		ldi r23,hi8(.LC17)
 5951 22a4 00C0      		rjmp .L438
 5952               	.LVL426:
 5953               	.L430:
2889:switcherator.c ****             unformatAddress(rx_addr_p3, tempRadioString);
 5954               		.loc 1 2889 0
 5955 22a6 2091 0000 		lds r18,rx_addr_p3
 5956 22aa 3091 0000 		lds r19,rx_addr_p3+1
 5957 22ae 4091 0000 		lds r20,rx_addr_p3+2
 5958 22b2 5091 0000 		lds r21,rx_addr_p3+3
 5959 22b6 6091 0000 		lds r22,rx_addr_p3+4
 5960 22ba 7091 0000 		lds r23,rx_addr_p3+5
 5961 22be 8E01      		movw r16,r28
 5962 22c0 0F5F      		subi r16,-1
 5963 22c2 1F4F      		sbci r17,-1
 5964 22c4 8091 0000 		lds r24,rx_addr_p3+6
 5965 22c8 9091 0000 		lds r25,rx_addr_p3+7
 5966 22cc 0E94 0000 		call unformatAddress
 5967               	.LVL427:
2890:switcherator.c ****             strcat(statusMsg, "r3-0x");
 5968               		.loc 1 2890 0
 5969 22d0 60E0      		ldi r22,lo8(.LC18)
 5970 22d2 70E0      		ldi r23,hi8(.LC18)
 5971 22d4 00C0      		rjmp .L438
 5972               	.LVL428:
 5973               	.L431:
2893:switcherator.c ****             unformatAddress(rx_addr_p4, tempRadioString);
 5974               		.loc 1 2893 0
 5975 22d6 2091 0000 		lds r18,rx_addr_p4
 5976 22da 3091 0000 		lds r19,rx_addr_p4+1
 5977 22de 4091 0000 		lds r20,rx_addr_p4+2
 5978 22e2 5091 0000 		lds r21,rx_addr_p4+3
 5979 22e6 6091 0000 		lds r22,rx_addr_p4+4
 5980 22ea 7091 0000 		lds r23,rx_addr_p4+5
 5981 22ee 8E01      		movw r16,r28
 5982 22f0 0F5F      		subi r16,-1
 5983 22f2 1F4F      		sbci r17,-1
 5984 22f4 8091 0000 		lds r24,rx_addr_p4+6
 5985 22f8 9091 0000 		lds r25,rx_addr_p4+7
 5986 22fc 0E94 0000 		call unformatAddress
 5987               	.LVL429:
2894:switcherator.c ****             strcat(statusMsg, "r4-0x");
 5988               		.loc 1 2894 0
 5989 2300 60E0      		ldi r22,lo8(.LC19)
 5990 2302 70E0      		ldi r23,hi8(.LC19)
 5991 2304 00C0      		rjmp .L438
 5992               	.LVL430:
 5993               	.L432:
2897:switcherator.c ****             unformatAddress(rx_addr_p5, tempRadioString);
 5994               		.loc 1 2897 0
 5995 2306 2091 0000 		lds r18,rx_addr_p5
 5996 230a 3091 0000 		lds r19,rx_addr_p5+1
 5997 230e 4091 0000 		lds r20,rx_addr_p5+2
 5998 2312 5091 0000 		lds r21,rx_addr_p5+3
 5999 2316 6091 0000 		lds r22,rx_addr_p5+4
 6000 231a 7091 0000 		lds r23,rx_addr_p5+5
 6001 231e 8E01      		movw r16,r28
 6002 2320 0F5F      		subi r16,-1
 6003 2322 1F4F      		sbci r17,-1
 6004 2324 8091 0000 		lds r24,rx_addr_p5+6
 6005 2328 9091 0000 		lds r25,rx_addr_p5+7
 6006 232c 0E94 0000 		call unformatAddress
 6007               	.LVL431:
2898:switcherator.c ****             strcat(statusMsg, "r5-0x");
 6008               		.loc 1 2898 0
 6009 2330 60E0      		ldi r22,lo8(.LC20)
 6010 2332 70E0      		ldi r23,hi8(.LC20)
 6011 2334 00C0      		rjmp .L438
 6012               	.LVL432:
 6013               	.L433:
2901:switcherator.c ****             unformatAddress(tx_addr, tempRadioString);
 6014               		.loc 1 2901 0
 6015 2336 2091 0000 		lds r18,tx_addr
 6016 233a 3091 0000 		lds r19,tx_addr+1
 6017 233e 4091 0000 		lds r20,tx_addr+2
 6018 2342 5091 0000 		lds r21,tx_addr+3
 6019 2346 6091 0000 		lds r22,tx_addr+4
 6020 234a 7091 0000 		lds r23,tx_addr+5
 6021 234e 8E01      		movw r16,r28
 6022 2350 0F5F      		subi r16,-1
 6023 2352 1F4F      		sbci r17,-1
 6024 2354 8091 0000 		lds r24,tx_addr+6
 6025 2358 9091 0000 		lds r25,tx_addr+7
 6026 235c 0E94 0000 		call unformatAddress
 6027               	.LVL433:
2902:switcherator.c ****             strcat(statusMsg, "t-0x");
 6028               		.loc 1 2902 0
 6029 2360 60E0      		ldi r22,lo8(.LC21)
 6030 2362 70E0      		ldi r23,hi8(.LC21)
 6031 2364 00C0      		rjmp .L438
 6032               	.LVL434:
 6033               	.L427:
2905:switcherator.c ****             unformatAddress(rx_addr_p0, tempRadioString);
 6034               		.loc 1 2905 0
 6035 2366 2091 0000 		lds r18,rx_addr_p0
 6036 236a 3091 0000 		lds r19,rx_addr_p0+1
 6037 236e 4091 0000 		lds r20,rx_addr_p0+2
 6038 2372 5091 0000 		lds r21,rx_addr_p0+3
 6039 2376 6091 0000 		lds r22,rx_addr_p0+4
 6040 237a 7091 0000 		lds r23,rx_addr_p0+5
 6041 237e 8E01      		movw r16,r28
 6042 2380 0F5F      		subi r16,-1
 6043 2382 1F4F      		sbci r17,-1
 6044 2384 8091 0000 		lds r24,rx_addr_p0+6
 6045 2388 9091 0000 		lds r25,rx_addr_p0+7
 6046 238c 0E94 0000 		call unformatAddress
 6047               	.LVL435:
2906:switcherator.c ****             strcat(statusMsg, "r0-0x");
 6048               		.loc 1 2906 0
 6049 2390 60E0      		ldi r22,lo8(.LC22)
 6050 2392 70E0      		ldi r23,hi8(.LC22)
 6051 2394 00C0      		rjmp .L438
 6052               	.LVL436:
 6053               	.L435:
2910:switcherator.c ****         returnHexWithout(tempRadioString[x], tempLongString);
 6054               		.loc 1 2910 0 discriminator 2
 6055 2396 60E0      		ldi r22,lo8(tempLongString)
 6056 2398 70E0      		ldi r23,hi8(tempLongString)
 6057 239a F801      		movw r30,r16
 6058 239c 8191      		ld r24,Z+
 6059 239e 8F01      		movw r16,r30
 6060 23a0 90E0      		ldi r25,0
 6061 23a2 0E94 0000 		call returnHexWithout
 6062               	.LVL437:
2911:switcherator.c ****         strcat(statusMsg, tempLongString);
 6063               		.loc 1 2911 0 discriminator 2
 6064 23a6 60E0      		ldi r22,lo8(tempLongString)
 6065 23a8 70E0      		ldi r23,hi8(tempLongString)
 6066 23aa 80E0      		ldi r24,lo8(statusMsg)
 6067 23ac 90E0      		ldi r25,hi8(statusMsg)
 6068 23ae 0E94 0000 		call strcat
 6069               	.LVL438:
2909:switcherator.c ****     for (x = 0; x < 5; x++) {
 6070               		.loc 1 2909 0 discriminator 2
 6071 23b2 0E15      		cp r16,r14
 6072 23b4 1F05      		cpc r17,r15
 6073 23b6 01F4      		brne .L435
2913:switcherator.c ****     sendMessage(statusMsg);
 6074               		.loc 1 2913 0
 6075 23b8 80E0      		ldi r24,lo8(statusMsg)
 6076 23ba 90E0      		ldi r25,hi8(statusMsg)
 6077 23bc 0E94 0000 		call sendMessage
 6078               	.LVL439:
 6079               	/* epilogue start */
2914:switcherator.c **** }
 6080               		.loc 1 2914 0
 6081 23c0 2696      		adiw r28,6
 6082 23c2 0FB6      		in __tmp_reg__,__SREG__
 6083 23c4 F894      		cli
 6084 23c6 DEBF      		out __SP_H__,r29
 6085 23c8 0FBE      		out __SREG__,__tmp_reg__
 6086 23ca CDBF      		out __SP_L__,r28
 6087 23cc DF91      		pop r29
 6088 23ce CF91      		pop r28
 6089 23d0 1F91      		pop r17
 6090 23d2 0F91      		pop r16
 6091 23d4 FF90      		pop r15
 6092 23d6 EF90      		pop r14
 6093 23d8 0895      		ret
 6094               	.LFE68:
 6096               		.section	.rodata.str1.1
 6097               	.LC23:
 6098 006d 7765 656B 		.string	"weekly0x"
 6098      6C79 3078 
 6098      00
 6099               	.LC24:
 6100 0076 2053 7730 		.string	" Sw0x"
 6100      7800 
 6101               	.LC25:
 6102 007c 2053 5320 		.string	" SS "
 6102      00
 6103               	.LC26:
 6104 0081 5323 00   		.string	"S#"
 6105               	.LC27:
 6106 0084 2054 3A78 		.string	" T:xx/xx/xxxx xx:xx:xx"
 6106      782F 7878 
 6106      2F78 7878 
 6106      7820 7878 
 6106      3A78 783A 
 6107               	.LC28:
 6108 009b 2054 3A00 		.string	" T:"
 6109               	.LC29:
 6110 009f 5072 6F67 		.string	"Progs"
 6110      7300 
 6111               	.LC30:
 6112 00a5 6E00      		.string	"n"
 6113               	.LC31:
 6114 00a7 7900      		.string	"y"
 6115               	.LC32:
 6116 00a9 5377 00   		.string	"Sw"
 6117               	.LC33:
 6118 00ac 496E 00   		.string	"In"
 6119               	.LC34:
 6120 00af 5377 4F6E 		.string	"SwOn?"
 6120      3F00 
 6121               		.text
 6122               	.global	generalStatus
 6124               	generalStatus:
 6125               	.LFB61:
2647:switcherator.c **** void generalStatus(char * commandReceived) {
 6126               		.loc 1 2647 0
 6127               	.LVL440:
 6128 23da FF92      		push r15
 6129               	.LCFI158:
 6130 23dc 0F93      		push r16
 6131               	.LCFI159:
 6132 23de 1F93      		push r17
 6133               	.LCFI160:
 6134 23e0 CF93      		push r28
 6135               	.LCFI161:
 6136 23e2 DF93      		push r29
 6137               	.LCFI162:
 6138               	/* prologue: function */
 6139               	/* frame size = 0 */
 6140               	/* stack size = 5 */
 6141               	.L__stack_usage = 5
 6142 23e4 EC01      		movw r28,r24
2648:switcherator.c ****     statusMsg[0] = 0;
 6143               		.loc 1 2648 0
 6144 23e6 1092 0000 		sts statusMsg,__zero_reg__
 6145               	.LVL441:
2650:switcherator.c ****     tempIntString[0] = commandReceived[2];
 6146               		.loc 1 2650 0
 6147 23ea FA80      		ldd r15,Y+2
 6148 23ec F092 0000 		sts tempIntString,r15
2651:switcherator.c ****     tempIntString[1] = commandReceived[3];
 6149               		.loc 1 2651 0
 6150 23f0 8B81      		ldd r24,Y+3
 6151               	.LVL442:
 6152 23f2 8093 0000 		sts tempIntString+1,r24
 6153               	.LVL443:
2653:switcherator.c ****     switchNumber = atoi(tempIntString);
 6154               		.loc 1 2653 0
 6155 23f6 80E0      		ldi r24,lo8(tempIntString)
 6156 23f8 90E0      		ldi r25,hi8(tempIntString)
 6157 23fa 0E94 0000 		call atoi
 6158               	.LVL444:
 6159 23fe 8C01      		movw r16,r24
 6160               	.LVL445:
2654:switcherator.c ****     if (switchNumber > 0 || commandReceived[2] == '0') {
 6161               		.loc 1 2654 0
 6162 2400 1816      		cp __zero_reg__,r24
 6163 2402 1906      		cpc __zero_reg__,r25
 6164 2404 04F0      		brlt .L440
2654:switcherator.c ****     if (switchNumber > 0 || commandReceived[2] == '0') {
 6165               		.loc 1 2654 0 is_stmt 0 discriminator 1
 6166 2406 80E3      		ldi r24,lo8(48)
 6167 2408 F812      		cpse r15,r24
 6168 240a 00C0      		rjmp .L441
 6169               	.L440:
2655:switcherator.c ****         strcat(statusMsg, "weekly0x");
 6170               		.loc 1 2655 0 is_stmt 1
 6171 240c 60E0      		ldi r22,lo8(.LC23)
 6172 240e 70E0      		ldi r23,hi8(.LC23)
 6173 2410 80E0      		ldi r24,lo8(statusMsg)
 6174 2412 90E0      		ldi r25,hi8(statusMsg)
 6175 2414 0E94 0000 		call strcat
 6176               	.LVL446:
2656:switcherator.c ****         ltoa(weeklySeconds, tempLongString, 16);
 6177               		.loc 1 2656 0
 6178 2418 6091 0000 		lds r22,weeklySeconds
 6179 241c 7091 0000 		lds r23,weeklySeconds+1
 6180 2420 8091 0000 		lds r24,weeklySeconds+2
 6181 2424 9091 0000 		lds r25,weeklySeconds+3
 6182 2428 20E1      		ldi r18,lo8(16)
 6183 242a 30E0      		ldi r19,0
 6184 242c 40E0      		ldi r20,lo8(tempLongString)
 6185 242e 50E0      		ldi r21,hi8(tempLongString)
 6186 2430 0E94 0000 		call ltoa
 6187               	.LVL447:
2657:switcherator.c ****         strcat(statusMsg, tempLongString);
 6188               		.loc 1 2657 0
 6189 2434 60E0      		ldi r22,lo8(tempLongString)
 6190 2436 70E0      		ldi r23,hi8(tempLongString)
 6191 2438 80E0      		ldi r24,lo8(statusMsg)
 6192 243a 90E0      		ldi r25,hi8(statusMsg)
 6193 243c 0E94 0000 		call strcat
 6194               	.LVL448:
2658:switcherator.c ****         strcat(statusMsg, " Sw0x");
 6195               		.loc 1 2658 0
 6196 2440 60E0      		ldi r22,lo8(.LC24)
 6197 2442 70E0      		ldi r23,hi8(.LC24)
 6198 2444 80E0      		ldi r24,lo8(statusMsg)
 6199 2446 90E0      		ldi r25,hi8(statusMsg)
 6200 2448 0E94 0000 		call strcat
 6201               	.LVL449:
2659:switcherator.c ****         ltoa(switchStatus[switchNumber], tempLongString, 16);
 6202               		.loc 1 2659 0
 6203 244c F801      		movw r30,r16
 6204 244e EE0F      		lsl r30
 6205 2450 FF1F      		rol r31
 6206 2452 EE0F      		lsl r30
 6207 2454 FF1F      		rol r31
 6208 2456 E050      		subi r30,lo8(-(switchStatus))
 6209 2458 F040      		sbci r31,hi8(-(switchStatus))
 6210 245a 6081      		ld r22,Z
 6211 245c 7181      		ldd r23,Z+1
 6212 245e 8281      		ldd r24,Z+2
 6213 2460 9381      		ldd r25,Z+3
 6214 2462 20E1      		ldi r18,lo8(16)
 6215 2464 30E0      		ldi r19,0
 6216 2466 40E0      		ldi r20,lo8(tempLongString)
 6217 2468 50E0      		ldi r21,hi8(tempLongString)
 6218 246a 0E94 0000 		call ltoa
 6219               	.LVL450:
2660:switcherator.c ****         strcat(statusMsg, tempLongString);
 6220               		.loc 1 2660 0
 6221 246e 60E0      		ldi r22,lo8(tempLongString)
 6222 2470 70E0      		ldi r23,hi8(tempLongString)
 6223 2472 80E0      		ldi r24,lo8(statusMsg)
 6224 2474 90E0      		ldi r25,hi8(statusMsg)
 6225 2476 0E94 0000 		call strcat
 6226               	.LVL451:
2661:switcherator.c ****         strcat(statusMsg, " SS ");
 6227               		.loc 1 2661 0
 6228 247a 60E0      		ldi r22,lo8(.LC25)
 6229 247c 70E0      		ldi r23,hi8(.LC25)
 6230 247e 80E0      		ldi r24,lo8(statusMsg)
 6231 2480 90E0      		ldi r25,hi8(statusMsg)
 6232 2482 0E94 0000 		call strcat
 6233               	.LVL452:
2662:switcherator.c ****         itoa(switchStuff[switchNumber], tempLongString, 10);
 6234               		.loc 1 2662 0
 6235 2486 F801      		movw r30,r16
 6236 2488 E050      		subi r30,lo8(-(switchStuff))
 6237 248a F040      		sbci r31,hi8(-(switchStuff))
 6238 248c 4AE0      		ldi r20,lo8(10)
 6239 248e 50E0      		ldi r21,0
 6240 2490 60E0      		ldi r22,lo8(tempLongString)
 6241 2492 70E0      		ldi r23,hi8(tempLongString)
 6242 2494 8081      		ld r24,Z
 6243 2496 90E0      		ldi r25,0
 6244 2498 0E94 0000 		call itoa
 6245               	.LVL453:
2663:switcherator.c ****         strcat(statusMsg, tempLongString);
 6246               		.loc 1 2663 0
 6247 249c 60E0      		ldi r22,lo8(tempLongString)
 6248 249e 70E0      		ldi r23,hi8(tempLongString)
 6249 24a0 80E0      		ldi r24,lo8(statusMsg)
 6250 24a2 90E0      		ldi r25,hi8(statusMsg)
 6251 24a4 0E94 0000 		call strcat
 6252               	.LVL454:
2664:switcherator.c ****         sendMessage(statusMsg);
 6253               		.loc 1 2664 0
 6254 24a8 80E0      		ldi r24,lo8(statusMsg)
 6255 24aa 90E0      		ldi r25,hi8(statusMsg)
 6256 24ac 0E94 0000 		call sendMessage
 6257               	.LVL455:
2665:switcherator.c ****         statusMsg[0] = 0;
 6258               		.loc 1 2665 0
 6259 24b0 1092 0000 		sts statusMsg,__zero_reg__
 6260               	.L441:
2668:switcherator.c ****     strcat(statusMsg, "S#");
 6261               		.loc 1 2668 0
 6262 24b4 60E0      		ldi r22,lo8(.LC26)
 6263 24b6 70E0      		ldi r23,hi8(.LC26)
 6264 24b8 80E0      		ldi r24,lo8(statusMsg)
 6265 24ba 90E0      		ldi r25,hi8(statusMsg)
 6266 24bc 0E94 0000 		call strcat
 6267               	.LVL456:
2671:switcherator.c ****     serialLength = strlen(stringSerial);
 6268               		.loc 1 2671 0
 6269 24c0 E0E0      		ldi r30,lo8(stringSerial)
 6270 24c2 F0E0      		ldi r31,hi8(stringSerial)
 6271 24c4 DF01      		movw r26,r30
 6272               		0:
 6273 24c6 0D90      		ld __tmp_reg__,X+
 6274 24c8 0020      		tst __tmp_reg__
 6275 24ca 01F4      		brne 0b
 6276 24cc 8D01      		movw r16,r26
 6277               	.LVL457:
 6278 24ce 0150      		subi r16,1
 6279 24d0 1109      		sbc r17,__zero_reg__
 6280 24d2 0E1B      		sub r16,r30
 6281 24d4 1F0B      		sbc r17,r31
 6282               	.LVL458:
2672:switcherator.c ****     while (serialLength < 6) {
 6283               		.loc 1 2672 0
 6284 24d6 00C0      		rjmp .L442
 6285               	.L443:
2673:switcherator.c ****         strcat(statusMsg, "0");
 6286               		.loc 1 2673 0
 6287 24d8 60E0      		ldi r22,lo8(.LC1)
 6288 24da 70E0      		ldi r23,hi8(.LC1)
 6289 24dc 80E0      		ldi r24,lo8(statusMsg)
 6290 24de 90E0      		ldi r25,hi8(statusMsg)
 6291 24e0 0E94 0000 		call strcat
 6292               	.LVL459:
2674:switcherator.c ****         serialLength++;
 6293               		.loc 1 2674 0
 6294 24e4 0F5F      		subi r16,-1
 6295 24e6 1F4F      		sbci r17,-1
 6296               	.LVL460:
 6297               	.L442:
2672:switcherator.c ****     while (serialLength < 6) {
 6298               		.loc 1 2672 0 discriminator 1
 6299 24e8 0630      		cpi r16,6
 6300 24ea 1105      		cpc r17,__zero_reg__
 6301 24ec 04F0      		brlt .L443
2676:switcherator.c ****     strcat(statusMsg, stringSerial);
 6302               		.loc 1 2676 0
 6303 24ee 60E0      		ldi r22,lo8(stringSerial)
 6304 24f0 70E0      		ldi r23,hi8(stringSerial)
 6305 24f2 80E0      		ldi r24,lo8(statusMsg)
 6306 24f4 90E0      		ldi r25,hi8(statusMsg)
 6307 24f6 0E94 0000 		call strcat
 6308               	.LVL461:
2678:switcherator.c ****     if (panicMyClockIsNotSet == 1) {
 6309               		.loc 1 2678 0
 6310 24fa 8091 0000 		lds r24,panicMyClockIsNotSet
 6311 24fe 8130      		cpi r24,lo8(1)
 6312 2500 01F4      		brne .L444
2679:switcherator.c ****         strcat(statusMsg, " T:xx/xx/xxxx xx:xx:xx");
 6313               		.loc 1 2679 0
 6314 2502 60E0      		ldi r22,lo8(.LC27)
 6315 2504 70E0      		ldi r23,hi8(.LC27)
 6316 2506 00C0      		rjmp .L469
 6317               	.L444:
2681:switcherator.c ****         strcat(statusMsg, " T:");
 6318               		.loc 1 2681 0
 6319 2508 60E0      		ldi r22,lo8(.LC28)
 6320 250a 70E0      		ldi r23,hi8(.LC28)
 6321 250c 80E0      		ldi r24,lo8(statusMsg)
 6322 250e 90E0      		ldi r25,hi8(statusMsg)
 6323 2510 0E94 0000 		call strcat
 6324               	.LVL462:
2682:switcherator.c ****         returnInt(globalMonth, tempLongString);
 6325               		.loc 1 2682 0
 6326 2514 60E0      		ldi r22,lo8(tempLongString)
 6327 2516 70E0      		ldi r23,hi8(tempLongString)
 6328 2518 8091 0000 		lds r24,globalMonth
 6329 251c 9091 0000 		lds r25,globalMonth+1
 6330 2520 0E94 0000 		call returnInt
 6331               	.LVL463:
2683:switcherator.c ****         strcat(statusMsg, tempLongString);
 6332               		.loc 1 2683 0
 6333 2524 60E0      		ldi r22,lo8(tempLongString)
 6334 2526 70E0      		ldi r23,hi8(tempLongString)
 6335 2528 80E0      		ldi r24,lo8(statusMsg)
 6336 252a 90E0      		ldi r25,hi8(statusMsg)
 6337 252c 0E94 0000 		call strcat
 6338               	.LVL464:
2684:switcherator.c ****         strcat(statusMsg, "/");
 6339               		.loc 1 2684 0
 6340 2530 60E0      		ldi r22,lo8(.LC3)
 6341 2532 70E0      		ldi r23,hi8(.LC3)
 6342 2534 80E0      		ldi r24,lo8(statusMsg)
 6343 2536 90E0      		ldi r25,hi8(statusMsg)
 6344 2538 0E94 0000 		call strcat
 6345               	.LVL465:
2685:switcherator.c ****         returnInt(globalDay, tempLongString);
 6346               		.loc 1 2685 0
 6347 253c 60E0      		ldi r22,lo8(tempLongString)
 6348 253e 70E0      		ldi r23,hi8(tempLongString)
 6349 2540 8091 0000 		lds r24,globalDay
 6350 2544 9091 0000 		lds r25,globalDay+1
 6351 2548 0E94 0000 		call returnInt
 6352               	.LVL466:
2686:switcherator.c ****         strcat(statusMsg, tempLongString);
 6353               		.loc 1 2686 0
 6354 254c 60E0      		ldi r22,lo8(tempLongString)
 6355 254e 70E0      		ldi r23,hi8(tempLongString)
 6356 2550 80E0      		ldi r24,lo8(statusMsg)
 6357 2552 90E0      		ldi r25,hi8(statusMsg)
 6358 2554 0E94 0000 		call strcat
 6359               	.LVL467:
2687:switcherator.c ****         strcat(statusMsg, "/");
 6360               		.loc 1 2687 0
 6361 2558 60E0      		ldi r22,lo8(.LC3)
 6362 255a 70E0      		ldi r23,hi8(.LC3)
 6363 255c 80E0      		ldi r24,lo8(statusMsg)
 6364 255e 90E0      		ldi r25,hi8(statusMsg)
 6365 2560 0E94 0000 		call strcat
 6366               	.LVL468:
2688:switcherator.c ****         returnInt(globalYear, tempLongString);
 6367               		.loc 1 2688 0
 6368 2564 60E0      		ldi r22,lo8(tempLongString)
 6369 2566 70E0      		ldi r23,hi8(tempLongString)
 6370 2568 8091 0000 		lds r24,globalYear
 6371 256c 9091 0000 		lds r25,globalYear+1
 6372 2570 0E94 0000 		call returnInt
 6373               	.LVL469:
2689:switcherator.c ****         strcat(statusMsg, tempLongString);
 6374               		.loc 1 2689 0
 6375 2574 60E0      		ldi r22,lo8(tempLongString)
 6376 2576 70E0      		ldi r23,hi8(tempLongString)
 6377 2578 80E0      		ldi r24,lo8(statusMsg)
 6378 257a 90E0      		ldi r25,hi8(statusMsg)
 6379 257c 0E94 0000 		call strcat
 6380               	.LVL470:
2690:switcherator.c ****         strcat(statusMsg, " ");
 6381               		.loc 1 2690 0
 6382 2580 60E0      		ldi r22,lo8(.LC2)
 6383 2582 70E0      		ldi r23,hi8(.LC2)
 6384 2584 80E0      		ldi r24,lo8(statusMsg)
 6385 2586 90E0      		ldi r25,hi8(statusMsg)
 6386 2588 0E94 0000 		call strcat
 6387               	.LVL471:
2691:switcherator.c ****         returnInt(globalHour, tempLongString);
 6388               		.loc 1 2691 0
 6389 258c 60E0      		ldi r22,lo8(tempLongString)
 6390 258e 70E0      		ldi r23,hi8(tempLongString)
 6391 2590 8091 0000 		lds r24,globalHour
 6392 2594 9091 0000 		lds r25,globalHour+1
 6393 2598 0E94 0000 		call returnInt
 6394               	.LVL472:
2692:switcherator.c ****         strcat(statusMsg, tempLongString);
 6395               		.loc 1 2692 0
 6396 259c 60E0      		ldi r22,lo8(tempLongString)
 6397 259e 70E0      		ldi r23,hi8(tempLongString)
 6398 25a0 80E0      		ldi r24,lo8(statusMsg)
 6399 25a2 90E0      		ldi r25,hi8(statusMsg)
 6400 25a4 0E94 0000 		call strcat
 6401               	.LVL473:
2693:switcherator.c ****         strcat(statusMsg, ":");
 6402               		.loc 1 2693 0
 6403 25a8 60E0      		ldi r22,lo8(.LC4)
 6404 25aa 70E0      		ldi r23,hi8(.LC4)
 6405 25ac 80E0      		ldi r24,lo8(statusMsg)
 6406 25ae 90E0      		ldi r25,hi8(statusMsg)
 6407 25b0 0E94 0000 		call strcat
 6408               	.LVL474:
2694:switcherator.c ****         returnInt(globalMinute, tempLongString);
 6409               		.loc 1 2694 0
 6410 25b4 60E0      		ldi r22,lo8(tempLongString)
 6411 25b6 70E0      		ldi r23,hi8(tempLongString)
 6412 25b8 8091 0000 		lds r24,globalMinute
 6413 25bc 9091 0000 		lds r25,globalMinute+1
 6414 25c0 0E94 0000 		call returnInt
 6415               	.LVL475:
2695:switcherator.c ****         strcat(statusMsg, tempLongString);
 6416               		.loc 1 2695 0
 6417 25c4 60E0      		ldi r22,lo8(tempLongString)
 6418 25c6 70E0      		ldi r23,hi8(tempLongString)
 6419 25c8 80E0      		ldi r24,lo8(statusMsg)
 6420 25ca 90E0      		ldi r25,hi8(statusMsg)
 6421 25cc 0E94 0000 		call strcat
 6422               	.LVL476:
2696:switcherator.c ****         strcat(statusMsg, ":");
 6423               		.loc 1 2696 0
 6424 25d0 60E0      		ldi r22,lo8(.LC4)
 6425 25d2 70E0      		ldi r23,hi8(.LC4)
 6426 25d4 80E0      		ldi r24,lo8(statusMsg)
 6427 25d6 90E0      		ldi r25,hi8(statusMsg)
 6428 25d8 0E94 0000 		call strcat
 6429               	.LVL477:
2697:switcherator.c ****         returnInt(globalSecond, tempLongString);
 6430               		.loc 1 2697 0
 6431 25dc 60E0      		ldi r22,lo8(tempLongString)
 6432 25de 70E0      		ldi r23,hi8(tempLongString)
 6433 25e0 8091 0000 		lds r24,globalSecond
 6434 25e4 9091 0000 		lds r25,globalSecond+1
 6435 25e8 0E94 0000 		call returnInt
 6436               	.LVL478:
2698:switcherator.c ****         strcat(statusMsg, tempLongString);
 6437               		.loc 1 2698 0
 6438 25ec 60E0      		ldi r22,lo8(tempLongString)
 6439 25ee 70E0      		ldi r23,hi8(tempLongString)
 6440               	.L469:
 6441 25f0 80E0      		ldi r24,lo8(statusMsg)
 6442 25f2 90E0      		ldi r25,hi8(statusMsg)
 6443 25f4 0E94 0000 		call strcat
 6444               	.LVL479:
2700:switcherator.c ****     sendMessage(statusMsg);
 6445               		.loc 1 2700 0
 6446 25f8 80E0      		ldi r24,lo8(statusMsg)
 6447 25fa 90E0      		ldi r25,hi8(statusMsg)
 6448 25fc 0E94 0000 		call sendMessage
 6449               	.LVL480:
2701:switcherator.c ****     statusMsg[0] = 0;
 6450               		.loc 1 2701 0
 6451 2600 1092 0000 		sts statusMsg,__zero_reg__
2702:switcherator.c ****     if (commandReceived[2] == 'q')
 6452               		.loc 1 2702 0
 6453 2604 8A81      		ldd r24,Y+2
 6454 2606 8137      		cpi r24,lo8(113)
 6455 2608 01F4      		brne .+2
 6456 260a 00C0      		rjmp .L439
2704:switcherator.c ****     strcat(statusMsg, "Progs");
 6457               		.loc 1 2704 0
 6458 260c 60E0      		ldi r22,lo8(.LC29)
 6459 260e 70E0      		ldi r23,hi8(.LC29)
 6460 2610 80E0      		ldi r24,lo8(statusMsg)
 6461 2612 90E0      		ldi r25,hi8(statusMsg)
 6462 2614 0E94 0000 		call strcat
 6463               	.LVL481:
 6464 2618 00E0      		ldi r16,lo8(weeklyProgram+1)
 6465 261a 10E0      		ldi r17,hi8(weeklyProgram+1)
 6466               	.LVL482:
2705:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 6467               		.loc 1 2705 0
 6468 261c C0E0      		ldi r28,0
 6469 261e D0E0      		ldi r29,0
 6470               	.LVL483:
 6471               	.L450:
2706:switcherator.c ****         returnInt(x, tempLongString);
 6472               		.loc 1 2706 0
 6473 2620 60E0      		ldi r22,lo8(tempLongString)
 6474 2622 70E0      		ldi r23,hi8(tempLongString)
 6475 2624 CE01      		movw r24,r28
 6476 2626 0E94 0000 		call returnInt
 6477               	.LVL484:
2707:switcherator.c ****         strcat(statusMsg, tempLongString);
 6478               		.loc 1 2707 0
 6479 262a 60E0      		ldi r22,lo8(tempLongString)
 6480 262c 70E0      		ldi r23,hi8(tempLongString)
 6481 262e 80E0      		ldi r24,lo8(statusMsg)
 6482 2630 90E0      		ldi r25,hi8(statusMsg)
 6483 2632 0E94 0000 		call strcat
 6484               	.LVL485:
2647:switcherator.c **** void generalStatus(char * commandReceived) {
 6485               		.loc 1 2647 0
 6486 2636 F801      		movw r30,r16
 6487 2638 3197      		sbiw r30,1
2708:switcherator.c ****         if (weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) {
 6488               		.loc 1 2708 0
 6489 263a 8081      		ld r24,Z
 6490 263c 8F3F      		cpi r24,lo8(-1)
 6491 263e 01F4      		brne .L447
2708:switcherator.c ****         if (weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) {
 6492               		.loc 1 2708 0 is_stmt 0 discriminator 1
 6493 2640 F801      		movw r30,r16
 6494 2642 8081      		ld r24,Z
 6495 2644 8F3F      		cpi r24,lo8(-1)
 6496 2646 01F4      		brne .L447
2709:switcherator.c ****             strcat(statusMsg, "n");
 6497               		.loc 1 2709 0 is_stmt 1
 6498 2648 60E0      		ldi r22,lo8(.LC30)
 6499 264a 70E0      		ldi r23,hi8(.LC30)
 6500 264c 00C0      		rjmp .L470
 6501               	.L447:
2711:switcherator.c ****             strcat(statusMsg, "y");
 6502               		.loc 1 2711 0
 6503 264e 60E0      		ldi r22,lo8(.LC31)
 6504 2650 70E0      		ldi r23,hi8(.LC31)
 6505               	.L470:
 6506 2652 80E0      		ldi r24,lo8(statusMsg)
 6507 2654 90E0      		ldi r25,hi8(statusMsg)
 6508 2656 0E94 0000 		call strcat
 6509               	.LVL486:
2714:switcherator.c ****         if (strlen(statusMsg) > 24) {
 6510               		.loc 1 2714 0
 6511 265a E0E0      		ldi r30,lo8(statusMsg)
 6512 265c F0E0      		ldi r31,hi8(statusMsg)
 6513               		0:
 6514 265e 0190      		ld __tmp_reg__,Z+
 6515 2660 0020      		tst __tmp_reg__
 6516 2662 01F4      		brne 0b
 6517 2664 3197      		sbiw r30,1
 6518 2666 E050      		subi r30,lo8(statusMsg)
 6519 2668 F040      		sbci r31,hi8(statusMsg)
 6520 266a 7997      		sbiw r30,25
 6521 266c 00F0      		brlo .L449
2715:switcherator.c ****             sendMessage(statusMsg);
 6522               		.loc 1 2715 0
 6523 266e 80E0      		ldi r24,lo8(statusMsg)
 6524 2670 90E0      		ldi r25,hi8(statusMsg)
 6525 2672 0E94 0000 		call sendMessage
 6526               	.LVL487:
2716:switcherator.c ****             statusMsg[5] = 0;
 6527               		.loc 1 2716 0
 6528 2676 1092 0000 		sts statusMsg+5,__zero_reg__
 6529               	.L449:
2705:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 6530               		.loc 1 2705 0
 6531 267a 2196      		adiw r28,1
 6532               	.LVL488:
 6533 267c 065F      		subi r16,-10
 6534 267e 1F4F      		sbci r17,-1
 6535 2680 CA30      		cpi r28,10
 6536 2682 D105      		cpc r29,__zero_reg__
 6537 2684 01F4      		brne .L450
2719:switcherator.c ****     sendMessage(statusMsg);
 6538               		.loc 1 2719 0
 6539 2686 80E0      		ldi r24,lo8(statusMsg)
 6540 2688 90E0      		ldi r25,hi8(statusMsg)
 6541 268a 0E94 0000 		call sendMessage
 6542               	.LVL489:
2720:switcherator.c ****     statusMsg[0] = 0;
 6543               		.loc 1 2720 0
 6544 268e 1092 0000 		sts statusMsg,__zero_reg__
2721:switcherator.c ****     strcat(statusMsg, "Sw");
 6545               		.loc 1 2721 0
 6546 2692 60E0      		ldi r22,lo8(.LC32)
 6547 2694 70E0      		ldi r23,hi8(.LC32)
 6548 2696 80E0      		ldi r24,lo8(statusMsg)
 6549 2698 90E0      		ldi r25,hi8(statusMsg)
 6550 269a 0E94 0000 		call strcat
 6551               	.LVL490:
 6552 269e 00E0      		ldi r16,lo8(switchStuff)
 6553 26a0 10E0      		ldi r17,hi8(switchStuff)
2722:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 6554               		.loc 1 2722 0
 6555 26a2 C0E0      		ldi r28,0
 6556 26a4 D0E0      		ldi r29,0
 6557               	.LVL491:
 6558               	.L454:
2723:switcherator.c ****         returnInt(x, tempLongString);
 6559               		.loc 1 2723 0
 6560 26a6 60E0      		ldi r22,lo8(tempLongString)
 6561 26a8 70E0      		ldi r23,hi8(tempLongString)
 6562 26aa CE01      		movw r24,r28
 6563 26ac 0E94 0000 		call returnInt
 6564               	.LVL492:
2724:switcherator.c ****         strcat(statusMsg, tempLongString);
 6565               		.loc 1 2724 0
 6566 26b0 60E0      		ldi r22,lo8(tempLongString)
 6567 26b2 70E0      		ldi r23,hi8(tempLongString)
 6568 26b4 80E0      		ldi r24,lo8(statusMsg)
 6569 26b6 90E0      		ldi r25,hi8(statusMsg)
 6570 26b8 0E94 0000 		call strcat
 6571               	.LVL493:
2725:switcherator.c ****         if (switchStuff[x] == 255) {
 6572               		.loc 1 2725 0
 6573 26bc D801      		movw r26,r16
 6574 26be 8D91      		ld r24,X+
 6575 26c0 8D01      		movw r16,r26
 6576 26c2 8F3F      		cpi r24,lo8(-1)
 6577 26c4 01F4      		brne .L451
2726:switcherator.c ****             strcat(statusMsg, "n");
 6578               		.loc 1 2726 0
 6579 26c6 60E0      		ldi r22,lo8(.LC30)
 6580 26c8 70E0      		ldi r23,hi8(.LC30)
 6581 26ca 00C0      		rjmp .L471
 6582               	.L451:
2728:switcherator.c ****             strcat(statusMsg, "y");
 6583               		.loc 1 2728 0
 6584 26cc 60E0      		ldi r22,lo8(.LC31)
 6585 26ce 70E0      		ldi r23,hi8(.LC31)
 6586               	.L471:
 6587 26d0 80E0      		ldi r24,lo8(statusMsg)
 6588 26d2 90E0      		ldi r25,hi8(statusMsg)
 6589 26d4 0E94 0000 		call strcat
 6590               	.LVL494:
2731:switcherator.c ****         if (strlen(statusMsg) > 24) {
 6591               		.loc 1 2731 0
 6592 26d8 E0E0      		ldi r30,lo8(statusMsg)
 6593 26da F0E0      		ldi r31,hi8(statusMsg)
 6594               		0:
 6595 26dc 0190      		ld __tmp_reg__,Z+
 6596 26de 0020      		tst __tmp_reg__
 6597 26e0 01F4      		brne 0b
 6598 26e2 3197      		sbiw r30,1
 6599 26e4 E050      		subi r30,lo8(statusMsg)
 6600 26e6 F040      		sbci r31,hi8(statusMsg)
 6601 26e8 7997      		sbiw r30,25
 6602 26ea 00F0      		brlo .L453
2732:switcherator.c ****             sendMessage(statusMsg);
 6603               		.loc 1 2732 0
 6604 26ec 80E0      		ldi r24,lo8(statusMsg)
 6605 26ee 90E0      		ldi r25,hi8(statusMsg)
 6606 26f0 0E94 0000 		call sendMessage
 6607               	.LVL495:
2733:switcherator.c ****             statusMsg[2] = 0;
 6608               		.loc 1 2733 0
 6609 26f4 1092 0000 		sts statusMsg+2,__zero_reg__
 6610               	.L453:
2722:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 6611               		.loc 1 2722 0
 6612 26f8 2196      		adiw r28,1
 6613               	.LVL496:
 6614 26fa C031      		cpi r28,16
 6615 26fc D105      		cpc r29,__zero_reg__
 6616 26fe 01F4      		brne .L454
2736:switcherator.c ****     sendMessage(statusMsg);
 6617               		.loc 1 2736 0
 6618 2700 80E0      		ldi r24,lo8(statusMsg)
 6619 2702 90E0      		ldi r25,hi8(statusMsg)
 6620 2704 0E94 0000 		call sendMessage
 6621               	.LVL497:
2737:switcherator.c ****     statusMsg[0] = 0;
 6622               		.loc 1 2737 0
 6623 2708 1092 0000 		sts statusMsg,__zero_reg__
2738:switcherator.c ****     strcat(statusMsg, "In");
 6624               		.loc 1 2738 0
 6625 270c 60E0      		ldi r22,lo8(.LC33)
 6626 270e 70E0      		ldi r23,hi8(.LC33)
 6627 2710 80E0      		ldi r24,lo8(statusMsg)
 6628 2712 90E0      		ldi r25,hi8(statusMsg)
 6629 2714 0E94 0000 		call strcat
 6630               	.LVL498:
 6631 2718 00E0      		ldi r16,lo8(inputs)
 6632 271a 10E0      		ldi r17,hi8(inputs)
2739:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 6633               		.loc 1 2739 0
 6634 271c C0E0      		ldi r28,0
 6635 271e D0E0      		ldi r29,0
 6636               	.LVL499:
 6637               	.L457:
2740:switcherator.c ****         returnInt(x, tempLongString);
 6638               		.loc 1 2740 0
 6639 2720 60E0      		ldi r22,lo8(tempLongString)
 6640 2722 70E0      		ldi r23,hi8(tempLongString)
 6641 2724 CE01      		movw r24,r28
 6642 2726 0E94 0000 		call returnInt
 6643               	.LVL500:
2741:switcherator.c ****         strcat(statusMsg, tempLongString);
 6644               		.loc 1 2741 0
 6645 272a 60E0      		ldi r22,lo8(tempLongString)
 6646 272c 70E0      		ldi r23,hi8(tempLongString)
 6647 272e 80E0      		ldi r24,lo8(statusMsg)
 6648 2730 90E0      		ldi r25,hi8(statusMsg)
 6649 2732 0E94 0000 		call strcat
 6650               	.LVL501:
2742:switcherator.c ****         if (inputs[x][0] == 255) {
 6651               		.loc 1 2742 0
 6652 2736 F801      		movw r30,r16
 6653 2738 8081      		ld r24,Z
 6654 273a 8F3F      		cpi r24,lo8(-1)
 6655 273c 01F4      		brne .L455
2743:switcherator.c ****             strcat(statusMsg, "n");
 6656               		.loc 1 2743 0
 6657 273e 60E0      		ldi r22,lo8(.LC30)
 6658 2740 70E0      		ldi r23,hi8(.LC30)
 6659 2742 00C0      		rjmp .L472
 6660               	.L455:
2745:switcherator.c ****             strcat(statusMsg, "y");
 6661               		.loc 1 2745 0
 6662 2744 60E0      		ldi r22,lo8(.LC31)
 6663 2746 70E0      		ldi r23,hi8(.LC31)
 6664               	.L472:
 6665 2748 80E0      		ldi r24,lo8(statusMsg)
 6666 274a 90E0      		ldi r25,hi8(statusMsg)
 6667 274c 0E94 0000 		call strcat
 6668               	.LVL502:
2739:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 6669               		.loc 1 2739 0
 6670 2750 2196      		adiw r28,1
 6671               	.LVL503:
 6672 2752 085F      		subi r16,-8
 6673 2754 1F4F      		sbci r17,-1
 6674 2756 C430      		cpi r28,4
 6675 2758 D105      		cpc r29,__zero_reg__
 6676 275a 01F4      		brne .L457
2753:switcherator.c ****     sendMessage(statusMsg);
 6677               		.loc 1 2753 0
 6678 275c 80E0      		ldi r24,lo8(statusMsg)
 6679 275e 90E0      		ldi r25,hi8(statusMsg)
 6680 2760 0E94 0000 		call sendMessage
 6681               	.LVL504:
2754:switcherator.c ****     statusMsg[0] = 0;
 6682               		.loc 1 2754 0
 6683 2764 1092 0000 		sts statusMsg,__zero_reg__
2755:switcherator.c ****     strcat(statusMsg, "SwOn?");
 6684               		.loc 1 2755 0
 6685 2768 60E0      		ldi r22,lo8(.LC34)
 6686 276a 70E0      		ldi r23,hi8(.LC34)
 6687 276c 80E0      		ldi r24,lo8(statusMsg)
 6688 276e 90E0      		ldi r25,hi8(statusMsg)
 6689 2770 0E94 0000 		call strcat
 6690               	.LVL505:
 6691 2774 00E0      		ldi r16,lo8(switchStatus)
 6692 2776 10E0      		ldi r17,hi8(switchStatus)
2756:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 6693               		.loc 1 2756 0
 6694 2778 C0E0      		ldi r28,0
 6695 277a D0E0      		ldi r29,0
 6696               	.LVL506:
 6697               	.L461:
2757:switcherator.c ****         returnInt(x, tempLongString);
 6698               		.loc 1 2757 0
 6699 277c 60E0      		ldi r22,lo8(tempLongString)
 6700 277e 70E0      		ldi r23,hi8(tempLongString)
 6701 2780 CE01      		movw r24,r28
 6702 2782 0E94 0000 		call returnInt
 6703               	.LVL507:
2758:switcherator.c ****         strcat(statusMsg, tempLongString);
 6704               		.loc 1 2758 0
 6705 2786 60E0      		ldi r22,lo8(tempLongString)
 6706 2788 70E0      		ldi r23,hi8(tempLongString)
 6707 278a 80E0      		ldi r24,lo8(statusMsg)
 6708 278c 90E0      		ldi r25,hi8(statusMsg)
 6709 278e 0E94 0000 		call strcat
 6710               	.LVL508:
2759:switcherator.c ****         if (switchStatus[x] > 0) {
 6711               		.loc 1 2759 0
 6712 2792 D801      		movw r26,r16
 6713 2794 4D91      		ld r20,X+
 6714 2796 5D91      		ld r21,X+
 6715 2798 6D91      		ld r22,X+
 6716 279a 7D91      		ld r23,X+
 6717 279c 8D01      		movw r16,r26
 6718 279e 452B      		or r20,r21
 6719 27a0 462B      		or r20,r22
 6720 27a2 472B      		or r20,r23
 6721 27a4 01F0      		breq .L458
2760:switcherator.c ****             strcat(statusMsg, "y");
 6722               		.loc 1 2760 0
 6723 27a6 60E0      		ldi r22,lo8(.LC31)
 6724 27a8 70E0      		ldi r23,hi8(.LC31)
 6725 27aa 00C0      		rjmp .L473
 6726               	.L458:
2762:switcherator.c ****             strcat(statusMsg, "n");
 6727               		.loc 1 2762 0
 6728 27ac 60E0      		ldi r22,lo8(.LC30)
 6729 27ae 70E0      		ldi r23,hi8(.LC30)
 6730               	.L473:
 6731 27b0 80E0      		ldi r24,lo8(statusMsg)
 6732 27b2 90E0      		ldi r25,hi8(statusMsg)
 6733 27b4 0E94 0000 		call strcat
 6734               	.LVL509:
2764:switcherator.c ****         if (strlen(statusMsg) > 24) {
 6735               		.loc 1 2764 0
 6736 27b8 E0E0      		ldi r30,lo8(statusMsg)
 6737 27ba F0E0      		ldi r31,hi8(statusMsg)
 6738               		0:
 6739 27bc 0190      		ld __tmp_reg__,Z+
 6740 27be 0020      		tst __tmp_reg__
 6741 27c0 01F4      		brne 0b
 6742 27c2 3197      		sbiw r30,1
 6743 27c4 E050      		subi r30,lo8(statusMsg)
 6744 27c6 F040      		sbci r31,hi8(statusMsg)
 6745 27c8 7997      		sbiw r30,25
 6746 27ca 00F0      		brlo .L460
2765:switcherator.c ****             sendMessage(statusMsg);
 6747               		.loc 1 2765 0
 6748 27cc 80E0      		ldi r24,lo8(statusMsg)
 6749 27ce 90E0      		ldi r25,hi8(statusMsg)
 6750 27d0 0E94 0000 		call sendMessage
 6751               	.LVL510:
2766:switcherator.c ****             statusMsg[5] = 0;
 6752               		.loc 1 2766 0
 6753 27d4 1092 0000 		sts statusMsg+5,__zero_reg__
 6754               	.L460:
2756:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 6755               		.loc 1 2756 0
 6756 27d8 2196      		adiw r28,1
 6757               	.LVL511:
 6758 27da C031      		cpi r28,16
 6759 27dc D105      		cpc r29,__zero_reg__
 6760 27de 01F4      		brne .L461
2769:switcherator.c ****     sendMessage(statusMsg);
 6761               		.loc 1 2769 0
 6762 27e0 80E0      		ldi r24,lo8(statusMsg)
 6763 27e2 90E0      		ldi r25,hi8(statusMsg)
 6764 27e4 0E94 0000 		call sendMessage
 6765               	.LVL512:
2770:switcherator.c ****     statusMsg[0] = 0;
 6766               		.loc 1 2770 0
 6767 27e8 1092 0000 		sts statusMsg,__zero_reg__
 6768               	.LVL513:
 6769               	.L439:
 6770               	/* epilogue start */
2771:switcherator.c **** }
 6771               		.loc 1 2771 0
 6772 27ec DF91      		pop r29
 6773 27ee CF91      		pop r28
 6774 27f0 1F91      		pop r17
 6775 27f2 0F91      		pop r16
 6776 27f4 FF90      		pop r15
 6777 27f6 0895      		ret
 6778               	.LFE61:
 6780               		.section	.rodata.str1.1
 6781               	.LC35:
 6782 00b5 5023 00   		.string	"P#"
 6783               	.LC36:
 6784 00b8 626C 616E 		.string	"blank."
 6784      6B2E 00
 6785               	.LC37:
 6786 00bf 5072 6F67 		.string	"Prog#"
 6786      2300 
 6787               	.LC38:
 6788 00c5 533A 2D00 		.string	"S:-"
 6789               	.LC39:
 6790 00c9 5300      		.string	"S"
 6791               	.LC40:
 6792 00cb 543A 00   		.string	"T:"
 6793               	.LC41:
 6794 00ce 2044 7572 		.string	" Dur:"
 6794      3A00 
 6795               	.LC42:
 6796 00d4 4461 7973 		.string	"Days:"
 6796      3A00 
 6797               	.LC43:
 6798 00da 2D2D 2D2D 		.string	"-------"
 6798      2D2D 2D00 
 6799               	.LC44:
 6800 00e2 2D00      		.string	"-"
 6801               	.LC45:
 6802 00e4 4D00      		.string	"M"
 6803               	.LC46:
 6804 00e6 5400      		.string	"T"
 6805               	.LC47:
 6806 00e8 5700      		.string	"W"
 6807               	.LC48:
 6808 00ea 4600      		.string	"F"
 6809               		.text
 6810               	.global	programDisplay
 6812               	programDisplay:
 6813               	.LFB37:
1501:switcherator.c **** void programDisplay(char * commandReceived) {
 6814               		.loc 1 1501 0
 6815               	.LVL514:
 6816 27f8 AF92      		push r10
 6817               	.LCFI163:
 6818 27fa BF92      		push r11
 6819               	.LCFI164:
 6820 27fc CF92      		push r12
 6821               	.LCFI165:
 6822 27fe DF92      		push r13
 6823               	.LCFI166:
 6824 2800 EF92      		push r14
 6825               	.LCFI167:
 6826 2802 FF92      		push r15
 6827               	.LCFI168:
 6828 2804 0F93      		push r16
 6829               	.LCFI169:
 6830 2806 1F93      		push r17
 6831               	.LCFI170:
 6832 2808 CF93      		push r28
 6833               	.LCFI171:
 6834 280a DF93      		push r29
 6835               	.LCFI172:
 6836 280c CDB7      		in r28,__SP_L__
 6837 280e DEB7      		in r29,__SP_H__
 6838               	.LCFI173:
 6839 2810 6097      		sbiw r28,16
 6840               	.LCFI174:
 6841 2812 0FB6      		in __tmp_reg__,__SREG__
 6842 2814 F894      		cli
 6843 2816 DEBF      		out __SP_H__,r29
 6844 2818 0FBE      		out __SREG__,__tmp_reg__
 6845 281a CDBF      		out __SP_L__,r28
 6846               	/* prologue: function */
 6847               	/* frame size = 16 */
 6848               	/* stack size = 26 */
 6849               	.L__stack_usage = 26
 6850               	.LVL515:
1504:switcherator.c ****     tempIntString[0] = commandReceived[3];
 6851               		.loc 1 1504 0
 6852 281c FC01      		movw r30,r24
 6853 281e 2381      		ldd r18,Z+3
 6854 2820 2093 0000 		sts tempIntString,r18
1505:switcherator.c ****     tempIntString[1] = commandReceived[4];
 6855               		.loc 1 1505 0
 6856 2824 8481      		ldd r24,Z+4
 6857               	.LVL516:
 6858 2826 8093 0000 		sts tempIntString+1,r24
1506:switcherator.c ****     programNumber = atoi(tempIntString);
 6859               		.loc 1 1506 0
 6860 282a 80E0      		ldi r24,lo8(tempIntString)
 6861 282c 90E0      		ldi r25,hi8(tempIntString)
 6862 282e 0E94 0000 		call atoi
 6863               	.LVL517:
 6864 2832 8C01      		movw r16,r24
 6865               	.LVL518:
1507:switcherator.c ****     statusMsg[0] = 0;
 6866               		.loc 1 1507 0
 6867 2834 1092 0000 		sts statusMsg,__zero_reg__
1508:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 6868               		.loc 1 1508 0
 6869 2838 8AE0      		ldi r24,lo8(10)
 6870 283a 809F      		mul r24,r16
 6871 283c F001      		movw r30,r0
 6872 283e 819F      		mul r24,r17
 6873 2840 F00D      		add r31,r0
 6874 2842 1124      		clr __zero_reg__
 6875 2844 E050      		subi r30,lo8(-(weeklyProgram))
 6876 2846 F040      		sbci r31,hi8(-(weeklyProgram))
 6877 2848 8081      		ld r24,Z
 6878 284a 8F3F      		cpi r24,lo8(-1)
 6879 284c 01F4      		brne .L475
1508:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 6880               		.loc 1 1508 0 is_stmt 0 discriminator 1
 6881 284e 8181      		ldd r24,Z+1
 6882 2850 8F3F      		cpi r24,lo8(-1)
 6883 2852 01F4      		brne .L475
1509:switcherator.c ****         strcat(statusMsg, "P#");
 6884               		.loc 1 1509 0 is_stmt 1
 6885 2854 60E0      		ldi r22,lo8(.LC35)
 6886 2856 70E0      		ldi r23,hi8(.LC35)
 6887 2858 80E0      		ldi r24,lo8(statusMsg)
 6888 285a 90E0      		ldi r25,hi8(statusMsg)
 6889 285c 0E94 0000 		call strcat
 6890               	.LVL519:
1510:switcherator.c ****         returnInt(programNumber, tempIntString);
 6891               		.loc 1 1510 0
 6892 2860 60E0      		ldi r22,lo8(tempIntString)
 6893 2862 70E0      		ldi r23,hi8(tempIntString)
 6894 2864 C801      		movw r24,r16
 6895 2866 0E94 0000 		call returnInt
 6896               	.LVL520:
1511:switcherator.c ****         strcat(statusMsg, tempIntString);
 6897               		.loc 1 1511 0
 6898 286a 60E0      		ldi r22,lo8(tempIntString)
 6899 286c 70E0      		ldi r23,hi8(tempIntString)
 6900 286e 80E0      		ldi r24,lo8(statusMsg)
 6901 2870 90E0      		ldi r25,hi8(statusMsg)
 6902 2872 0E94 0000 		call strcat
 6903               	.LVL521:
1512:switcherator.c ****         strcat(statusMsg, "blank.");
 6904               		.loc 1 1512 0
 6905 2876 60E0      		ldi r22,lo8(.LC36)
 6906 2878 70E0      		ldi r23,hi8(.LC36)
 6907 287a 00C0      		rjmp .L503
 6908               	.L475:
1517:switcherator.c ****     switches[0] = 0;
 6909               		.loc 1 1517 0
 6910 287c 1982      		std Y+1,__zero_reg__
 6911               	.LVL522:
1519:switcherator.c ****     switchCount = programGetSwitches(programNumber, switches);
 6912               		.loc 1 1519 0
 6913 287e BE01      		movw r22,r28
 6914 2880 6F5F      		subi r22,-1
 6915 2882 7F4F      		sbci r23,-1
 6916 2884 C801      		movw r24,r16
 6917 2886 0E94 0000 		call programGetSwitches
 6918               	.LVL523:
 6919 288a 6C01      		movw r12,r24
 6920               	.LVL524:
1520:switcherator.c ****     statusMsg[0] = 0;
 6921               		.loc 1 1520 0
 6922 288c 1092 0000 		sts statusMsg,__zero_reg__
1521:switcherator.c ****     strcat(statusMsg, "Prog#");
 6923               		.loc 1 1521 0
 6924 2890 60E0      		ldi r22,lo8(.LC37)
 6925 2892 70E0      		ldi r23,hi8(.LC37)
 6926 2894 80E0      		ldi r24,lo8(statusMsg)
 6927 2896 90E0      		ldi r25,hi8(statusMsg)
 6928 2898 0E94 0000 		call strcat
 6929               	.LVL525:
1522:switcherator.c ****     itoa(programNumber, tempIntString, 10);
 6930               		.loc 1 1522 0
 6931 289c 4AE0      		ldi r20,lo8(10)
 6932 289e 50E0      		ldi r21,0
 6933 28a0 60E0      		ldi r22,lo8(tempIntString)
 6934 28a2 70E0      		ldi r23,hi8(tempIntString)
 6935 28a4 C801      		movw r24,r16
 6936 28a6 0E94 0000 		call itoa
 6937               	.LVL526:
1523:switcherator.c ****     strcat(statusMsg, tempIntString);
 6938               		.loc 1 1523 0
 6939 28aa 60E0      		ldi r22,lo8(tempIntString)
 6940 28ac 70E0      		ldi r23,hi8(tempIntString)
 6941 28ae 80E0      		ldi r24,lo8(statusMsg)
 6942 28b0 90E0      		ldi r25,hi8(statusMsg)
 6943 28b2 0E94 0000 		call strcat
 6944               	.LVL527:
1524:switcherator.c ****     if (switchCount == 0) {
 6945               		.loc 1 1524 0
 6946 28b6 C114      		cp r12,__zero_reg__
 6947 28b8 D104      		cpc r13,__zero_reg__
 6948 28ba 01F4      		brne .L477
1525:switcherator.c ****         strcat(switches, "S:-");
 6949               		.loc 1 1525 0
 6950 28bc 60E0      		ldi r22,lo8(.LC38)
 6951 28be 70E0      		ldi r23,hi8(.LC38)
 6952 28c0 CE01      		movw r24,r28
 6953 28c2 0196      		adiw r24,1
 6954 28c4 0E94 0000 		call strcat
 6955               	.LVL528:
 6956 28c8 00C0      		rjmp .L478
 6957               	.L477:
 6958               	.LVL529:
 6959               	.LBB27:
1528:switcherator.c ****         strcat(statusMsg, "S");
 6960               		.loc 1 1528 0
 6961 28ca 60E0      		ldi r22,lo8(.LC39)
 6962 28cc 70E0      		ldi r23,hi8(.LC39)
 6963 28ce 80E0      		ldi r24,lo8(statusMsg)
 6964 28d0 90E0      		ldi r25,hi8(statusMsg)
 6965 28d2 0E94 0000 		call strcat
 6966               	.LVL530:
 6967 28d6 EE24      		clr r14
 6968 28d8 E394      		inc r14
 6969 28da F12C      		mov r15,__zero_reg__
 6970 28dc EC0E      		add r14,r28
 6971 28de FD1E      		adc r15,r29
1501:switcherator.c **** void programDisplay(char * commandReceived) {
 6972               		.loc 1 1501 0
 6973 28e0 5701      		movw r10,r14
1529:switcherator.c ****         for (x = 0; x < switchCount; x++) {
 6974               		.loc 1 1529 0
 6975 28e2 00C0      		rjmp .L479
 6976               	.LVL531:
 6977               	.L480:
1530:switcherator.c ****             strcat(statusMsg, ":");
 6978               		.loc 1 1530 0 discriminator 2
 6979 28e4 60E0      		ldi r22,lo8(.LC4)
 6980 28e6 70E0      		ldi r23,hi8(.LC4)
 6981 28e8 80E0      		ldi r24,lo8(statusMsg)
 6982 28ea 90E0      		ldi r25,hi8(statusMsg)
 6983 28ec 0E94 0000 		call strcat
 6984               	.LVL532:
1532:switcherator.c ****             itoa(temp, tempIntString, 10);
 6985               		.loc 1 1532 0 discriminator 2
 6986 28f0 4AE0      		ldi r20,lo8(10)
 6987 28f2 50E0      		ldi r21,0
 6988 28f4 60E0      		ldi r22,lo8(tempIntString)
 6989 28f6 70E0      		ldi r23,hi8(tempIntString)
 6990 28f8 F701      		movw r30,r14
 6991 28fa 8191      		ld r24,Z+
 6992 28fc 7F01      		movw r14,r30
 6993               	.LVL533:
 6994 28fe 90E0      		ldi r25,0
 6995 2900 0E94 0000 		call itoa
 6996               	.LVL534:
1533:switcherator.c ****             strcat(statusMsg, tempIntString);
 6997               		.loc 1 1533 0 discriminator 2
 6998 2904 60E0      		ldi r22,lo8(tempIntString)
 6999 2906 70E0      		ldi r23,hi8(tempIntString)
 7000 2908 80E0      		ldi r24,lo8(statusMsg)
 7001 290a 90E0      		ldi r25,hi8(statusMsg)
 7002 290c 0E94 0000 		call strcat
 7003               	.LVL535:
 7004               	.L479:
1501:switcherator.c **** void programDisplay(char * commandReceived) {
 7005               		.loc 1 1501 0 discriminator 1
 7006 2910 C701      		movw r24,r14
 7007 2912 8A19      		sub r24,r10
 7008 2914 9B09      		sbc r25,r11
1529:switcherator.c ****         for (x = 0; x < switchCount; x++) {
 7009               		.loc 1 1529 0 discriminator 1
 7010 2916 8C15      		cp r24,r12
 7011 2918 9D05      		cpc r25,r13
 7012 291a 04F0      		brlt .L480
 7013               	.L478:
 7014               	.LBE27:
1536:switcherator.c ****     sendMessage(statusMsg);
 7015               		.loc 1 1536 0
 7016 291c 80E0      		ldi r24,lo8(statusMsg)
 7017 291e 90E0      		ldi r25,hi8(statusMsg)
 7018 2920 0E94 0000 		call sendMessage
 7019               	.LVL536:
1537:switcherator.c ****     statusMsg[0] = 0;
 7020               		.loc 1 1537 0
 7021 2924 1092 0000 		sts statusMsg,__zero_reg__
 7022               	.LVL537:
1539:switcherator.c ****     time = weeklyProgram[programNumber][1];
 7023               		.loc 1 1539 0
 7024 2928 8AE0      		ldi r24,lo8(10)
 7025 292a 809F      		mul r24,r16
 7026 292c F001      		movw r30,r0
 7027 292e 819F      		mul r24,r17
 7028 2930 F00D      		add r31,r0
 7029 2932 1124      		clr __zero_reg__
 7030 2934 E050      		subi r30,lo8(-(weeklyProgram))
 7031 2936 F040      		sbci r31,hi8(-(weeklyProgram))
 7032               	.LVL538:
1540:switcherator.c ****     time <<= 8;
 7033               		.loc 1 1540 0
 7034 2938 9181      		ldd r25,Z+1
 7035 293a 80E0      		ldi r24,0
 7036               	.LVL539:
1541:switcherator.c ****     time |= weeklyProgram[programNumber][2];
 7037               		.loc 1 1541 0
 7038 293c 2281      		ldd r18,Z+2
 7039 293e AC01      		movw r20,r24
 7040 2940 422B      		or r20,r18
 7041 2942 9A01      		movw r18,r20
 7042               	.LVL540:
1542:switcherator.c ****     unsigned int hours = (time / 60);
 7043               		.loc 1 1542 0
 7044 2944 6CE3      		ldi r22,lo8(60)
 7045 2946 E62E      		mov r14,r22
 7046 2948 F12C      		mov r15,__zero_reg__
 7047 294a C901      		movw r24,r18
 7048 294c B701      		movw r22,r14
 7049 294e 0E94 0000 		call __udivmodhi4
 7050 2952 8B01      		movw r16,r22
 7051               	.LVL541:
1543:switcherator.c ****     unsigned int minutes = (time - (hours * 60));
 7052               		.loc 1 1543 0
 7053 2954 4CE3      		ldi r20,lo8(60)
 7054 2956 469F      		mul r20,r22
 7055 2958 C001      		movw r24,r0
 7056 295a 479F      		mul r20,r23
 7057 295c 900D      		add r25,r0
 7058 295e 1124      		clr __zero_reg__
 7059 2960 6901      		movw r12,r18
 7060               	.LVL542:
 7061 2962 C81A      		sub r12,r24
 7062 2964 D90A      		sbc r13,r25
 7063               	.LVL543:
1545:switcherator.c ****     time <<= 8;
 7064               		.loc 1 1545 0
 7065 2966 3381      		ldd r19,Z+3
 7066 2968 20E0      		ldi r18,0
1546:switcherator.c ****     time |= weeklyProgram[programNumber][4];
 7067               		.loc 1 1546 0
 7068 296a 8481      		ldd r24,Z+4
 7069 296c A901      		movw r20,r18
 7070 296e 482B      		or r20,r24
 7071 2970 CA01      		movw r24,r20
1547:switcherator.c ****     int duration = (time / 60);
 7072               		.loc 1 1547 0
 7073 2972 B701      		movw r22,r14
 7074 2974 0E94 0000 		call __udivmodhi4
 7075 2978 B62E      		mov r11,r22
 7076 297a E72E      		mov r14,r23
 7077               	.LVL544:
1549:switcherator.c ****     weekdays = weeklyProgram[programNumber][0];
 7078               		.loc 1 1549 0
 7079 297c F080      		ld r15,Z
 7080               	.LVL545:
1550:switcherator.c ****     strcat(statusMsg, "T:");
 7081               		.loc 1 1550 0
 7082 297e 60E0      		ldi r22,lo8(.LC40)
 7083 2980 70E0      		ldi r23,hi8(.LC40)
 7084 2982 80E0      		ldi r24,lo8(statusMsg)
 7085 2984 90E0      		ldi r25,hi8(statusMsg)
 7086 2986 0E94 0000 		call strcat
 7087               	.LVL546:
1551:switcherator.c ****     itoa(hours, tempIntString, 10);
 7088               		.loc 1 1551 0
 7089 298a 4AE0      		ldi r20,lo8(10)
 7090 298c 50E0      		ldi r21,0
 7091 298e 60E0      		ldi r22,lo8(tempIntString)
 7092 2990 70E0      		ldi r23,hi8(tempIntString)
 7093 2992 C801      		movw r24,r16
 7094 2994 0E94 0000 		call itoa
 7095               	.LVL547:
1552:switcherator.c ****     strcat(statusMsg, tempIntString);
 7096               		.loc 1 1552 0
 7097 2998 60E0      		ldi r22,lo8(tempIntString)
 7098 299a 70E0      		ldi r23,hi8(tempIntString)
 7099 299c 80E0      		ldi r24,lo8(statusMsg)
 7100 299e 90E0      		ldi r25,hi8(statusMsg)
 7101 29a0 0E94 0000 		call strcat
 7102               	.LVL548:
1553:switcherator.c ****     strcat(statusMsg, ":");
 7103               		.loc 1 1553 0
 7104 29a4 60E0      		ldi r22,lo8(.LC4)
 7105 29a6 70E0      		ldi r23,hi8(.LC4)
 7106 29a8 80E0      		ldi r24,lo8(statusMsg)
 7107 29aa 90E0      		ldi r25,hi8(statusMsg)
 7108 29ac 0E94 0000 		call strcat
 7109               	.LVL549:
1554:switcherator.c ****     itoa(minutes, tempIntString, 10);
 7110               		.loc 1 1554 0
 7111 29b0 4AE0      		ldi r20,lo8(10)
 7112 29b2 50E0      		ldi r21,0
 7113 29b4 60E0      		ldi r22,lo8(tempIntString)
 7114 29b6 70E0      		ldi r23,hi8(tempIntString)
 7115 29b8 C601      		movw r24,r12
 7116 29ba 0E94 0000 		call itoa
 7117               	.LVL550:
1555:switcherator.c ****     strcat(statusMsg, tempIntString);
 7118               		.loc 1 1555 0
 7119 29be 60E0      		ldi r22,lo8(tempIntString)
 7120 29c0 70E0      		ldi r23,hi8(tempIntString)
 7121 29c2 80E0      		ldi r24,lo8(statusMsg)
 7122 29c4 90E0      		ldi r25,hi8(statusMsg)
 7123 29c6 0E94 0000 		call strcat
 7124               	.LVL551:
1556:switcherator.c ****     strcat(statusMsg, " Dur:");
 7125               		.loc 1 1556 0
 7126 29ca 60E0      		ldi r22,lo8(.LC41)
 7127 29cc 70E0      		ldi r23,hi8(.LC41)
 7128 29ce 80E0      		ldi r24,lo8(statusMsg)
 7129 29d0 90E0      		ldi r25,hi8(statusMsg)
 7130 29d2 0E94 0000 		call strcat
 7131               	.LVL552:
1557:switcherator.c ****     itoa(duration, tempLongString, 10);
 7132               		.loc 1 1557 0
 7133 29d6 4AE0      		ldi r20,lo8(10)
 7134 29d8 50E0      		ldi r21,0
 7135 29da 60E0      		ldi r22,lo8(tempLongString)
 7136 29dc 70E0      		ldi r23,hi8(tempLongString)
 7137 29de 8B2D      		mov r24,r11
 7138 29e0 9E2D      		mov r25,r14
 7139 29e2 0E94 0000 		call itoa
 7140               	.LVL553:
1558:switcherator.c ****     strcat(statusMsg, tempLongString);
 7141               		.loc 1 1558 0
 7142 29e6 60E0      		ldi r22,lo8(tempLongString)
 7143 29e8 70E0      		ldi r23,hi8(tempLongString)
 7144 29ea 80E0      		ldi r24,lo8(statusMsg)
 7145 29ec 90E0      		ldi r25,hi8(statusMsg)
 7146 29ee 0E94 0000 		call strcat
 7147               	.LVL554:
1559:switcherator.c ****     strcat(statusMsg, "Days:");
 7148               		.loc 1 1559 0
 7149 29f2 60E0      		ldi r22,lo8(.LC42)
 7150 29f4 70E0      		ldi r23,hi8(.LC42)
 7151 29f6 80E0      		ldi r24,lo8(statusMsg)
 7152 29f8 90E0      		ldi r25,hi8(statusMsg)
 7153 29fa 0E94 0000 		call strcat
 7154               	.LVL555:
1560:switcherator.c ****     if (weekdays == 255) {
 7155               		.loc 1 1560 0
 7156 29fe 5FEF      		ldi r21,lo8(-1)
 7157 2a00 F512      		cpse r15,r21
 7158 2a02 00C0      		rjmp .L481
1561:switcherator.c ****         strcat(statusMsg, "-------");
 7159               		.loc 1 1561 0
 7160 2a04 60E0      		ldi r22,lo8(.LC43)
 7161 2a06 70E0      		ldi r23,hi8(.LC43)
 7162 2a08 00C0      		rjmp .L503
 7163               	.L481:
1565:switcherator.c ****     if (weekdays & 0x40) {
 7164               		.loc 1 1565 0
 7165 2a0a F6FE      		sbrs r15,6
 7166 2a0c 00C0      		rjmp .L482
1566:switcherator.c ****         strcat(statusMsg, "S");
 7167               		.loc 1 1566 0
 7168 2a0e 60E0      		ldi r22,lo8(.LC39)
 7169 2a10 70E0      		ldi r23,hi8(.LC39)
 7170 2a12 00C0      		rjmp .L497
 7171               	.L482:
1568:switcherator.c ****         strcat(statusMsg, "-");
 7172               		.loc 1 1568 0
 7173 2a14 60E0      		ldi r22,lo8(.LC44)
 7174 2a16 70E0      		ldi r23,hi8(.LC44)
 7175               	.L497:
 7176 2a18 80E0      		ldi r24,lo8(statusMsg)
 7177 2a1a 90E0      		ldi r25,hi8(statusMsg)
 7178 2a1c 0E94 0000 		call strcat
 7179               	.LVL556:
1570:switcherator.c ****     if (weekdays & 0x20) {
 7180               		.loc 1 1570 0
 7181 2a20 F5FE      		sbrs r15,5
 7182 2a22 00C0      		rjmp .L484
1571:switcherator.c ****         strcat(statusMsg, "M");
 7183               		.loc 1 1571 0
 7184 2a24 60E0      		ldi r22,lo8(.LC45)
 7185 2a26 70E0      		ldi r23,hi8(.LC45)
 7186 2a28 00C0      		rjmp .L498
 7187               	.L484:
1573:switcherator.c ****         strcat(statusMsg, "-");
 7188               		.loc 1 1573 0
 7189 2a2a 60E0      		ldi r22,lo8(.LC44)
 7190 2a2c 70E0      		ldi r23,hi8(.LC44)
 7191               	.L498:
 7192 2a2e 80E0      		ldi r24,lo8(statusMsg)
 7193 2a30 90E0      		ldi r25,hi8(statusMsg)
 7194 2a32 0E94 0000 		call strcat
 7195               	.LVL557:
1575:switcherator.c ****     if (weekdays & 0x10) {
 7196               		.loc 1 1575 0
 7197 2a36 F4FE      		sbrs r15,4
 7198 2a38 00C0      		rjmp .L486
1576:switcherator.c ****         strcat(statusMsg, "T");
 7199               		.loc 1 1576 0
 7200 2a3a 60E0      		ldi r22,lo8(.LC46)
 7201 2a3c 70E0      		ldi r23,hi8(.LC46)
 7202 2a3e 00C0      		rjmp .L499
 7203               	.L486:
1578:switcherator.c ****         strcat(statusMsg, "-");
 7204               		.loc 1 1578 0
 7205 2a40 60E0      		ldi r22,lo8(.LC44)
 7206 2a42 70E0      		ldi r23,hi8(.LC44)
 7207               	.L499:
 7208 2a44 80E0      		ldi r24,lo8(statusMsg)
 7209 2a46 90E0      		ldi r25,hi8(statusMsg)
 7210 2a48 0E94 0000 		call strcat
 7211               	.LVL558:
1580:switcherator.c ****     if (weekdays & 0x08) {
 7212               		.loc 1 1580 0
 7213 2a4c F3FE      		sbrs r15,3
 7214 2a4e 00C0      		rjmp .L488
1581:switcherator.c ****         strcat(statusMsg, "W");
 7215               		.loc 1 1581 0
 7216 2a50 60E0      		ldi r22,lo8(.LC47)
 7217 2a52 70E0      		ldi r23,hi8(.LC47)
 7218 2a54 00C0      		rjmp .L500
 7219               	.L488:
1583:switcherator.c ****         strcat(statusMsg, "-");
 7220               		.loc 1 1583 0
 7221 2a56 60E0      		ldi r22,lo8(.LC44)
 7222 2a58 70E0      		ldi r23,hi8(.LC44)
 7223               	.L500:
 7224 2a5a 80E0      		ldi r24,lo8(statusMsg)
 7225 2a5c 90E0      		ldi r25,hi8(statusMsg)
 7226 2a5e 0E94 0000 		call strcat
 7227               	.LVL559:
1585:switcherator.c ****     if (weekdays & 0x04) {
 7228               		.loc 1 1585 0
 7229 2a62 F2FE      		sbrs r15,2
 7230 2a64 00C0      		rjmp .L490
1586:switcherator.c ****         strcat(statusMsg, "T");
 7231               		.loc 1 1586 0
 7232 2a66 60E0      		ldi r22,lo8(.LC46)
 7233 2a68 70E0      		ldi r23,hi8(.LC46)
 7234 2a6a 00C0      		rjmp .L501
 7235               	.L490:
1588:switcherator.c ****         strcat(statusMsg, "-");
 7236               		.loc 1 1588 0
 7237 2a6c 60E0      		ldi r22,lo8(.LC44)
 7238 2a6e 70E0      		ldi r23,hi8(.LC44)
 7239               	.L501:
 7240 2a70 80E0      		ldi r24,lo8(statusMsg)
 7241 2a72 90E0      		ldi r25,hi8(statusMsg)
 7242 2a74 0E94 0000 		call strcat
 7243               	.LVL560:
1590:switcherator.c ****     if (weekdays & 0x02) {
 7244               		.loc 1 1590 0
 7245 2a78 F1FE      		sbrs r15,1
 7246 2a7a 00C0      		rjmp .L492
1591:switcherator.c ****         strcat(statusMsg, "F");
 7247               		.loc 1 1591 0
 7248 2a7c 60E0      		ldi r22,lo8(.LC48)
 7249 2a7e 70E0      		ldi r23,hi8(.LC48)
 7250 2a80 00C0      		rjmp .L502
 7251               	.L492:
1593:switcherator.c ****         strcat(statusMsg, "-");
 7252               		.loc 1 1593 0
 7253 2a82 60E0      		ldi r22,lo8(.LC44)
 7254 2a84 70E0      		ldi r23,hi8(.LC44)
 7255               	.L502:
 7256 2a86 80E0      		ldi r24,lo8(statusMsg)
 7257 2a88 90E0      		ldi r25,hi8(statusMsg)
 7258 2a8a 0E94 0000 		call strcat
 7259               	.LVL561:
1595:switcherator.c ****     if (weekdays & 0x01) {
 7260               		.loc 1 1595 0
 7261 2a8e F0FE      		sbrs r15,0
 7262 2a90 00C0      		rjmp .L494
1596:switcherator.c ****         strcat(statusMsg, "S");
 7263               		.loc 1 1596 0
 7264 2a92 60E0      		ldi r22,lo8(.LC39)
 7265 2a94 70E0      		ldi r23,hi8(.LC39)
 7266 2a96 00C0      		rjmp .L503
 7267               	.L494:
1598:switcherator.c ****         strcat(statusMsg, "-");
 7268               		.loc 1 1598 0
 7269 2a98 60E0      		ldi r22,lo8(.LC44)
 7270 2a9a 70E0      		ldi r23,hi8(.LC44)
 7271               	.LVL562:
 7272               	.L503:
 7273 2a9c 80E0      		ldi r24,lo8(statusMsg)
 7274 2a9e 90E0      		ldi r25,hi8(statusMsg)
 7275 2aa0 0E94 0000 		call strcat
 7276               	.LVL563:
1601:switcherator.c ****     sendMessage(statusMsg);
 7277               		.loc 1 1601 0
 7278 2aa4 80E0      		ldi r24,lo8(statusMsg)
 7279 2aa6 90E0      		ldi r25,hi8(statusMsg)
 7280 2aa8 0E94 0000 		call sendMessage
 7281               	.LVL564:
 7282               	/* epilogue start */
1602:switcherator.c **** }
 7283               		.loc 1 1602 0
 7284 2aac 6096      		adiw r28,16
 7285 2aae 0FB6      		in __tmp_reg__,__SREG__
 7286 2ab0 F894      		cli
 7287 2ab2 DEBF      		out __SP_H__,r29
 7288 2ab4 0FBE      		out __SREG__,__tmp_reg__
 7289 2ab6 CDBF      		out __SP_L__,r28
 7290 2ab8 DF91      		pop r29
 7291 2aba CF91      		pop r28
 7292 2abc 1F91      		pop r17
 7293 2abe 0F91      		pop r16
 7294 2ac0 FF90      		pop r15
 7295 2ac2 EF90      		pop r14
 7296 2ac4 DF90      		pop r13
 7297 2ac6 CF90      		pop r12
 7298 2ac8 BF90      		pop r11
 7299 2aca AF90      		pop r10
 7300 2acc 0895      		ret
 7301               	.LFE37:
 7303               		.section	.rodata.str1.1
 7304               	.LC49:
 7305 00ec 5661 6C20 		.string	"Val 0x"
 7305      3078 00
 7306               	.LC50:
 7307 00f3 2C00      		.string	","
 7308               	.LC51:
 7309 00f5 2064 6972 		.string	" dir "
 7309      2000 
 7310               	.LC52:
 7311 00fb 436F 6C20 		.string	"Col Ch"
 7311      4368 00
 7312               	.LC53:
 7313 0102 5057 4D20 		.string	"PWM "
 7313      00
 7314               	.LC54:
 7315 0107 7374 6174 		.string	"static"
 7315      6963 00
 7316               	.LC55:
 7317 010e 436F 6C43 		.string	"ColCh"
 7317      6800 
 7318               	.LC56:
 7319 0114 6875 6500 		.string	"hue"
 7320               	.LC57:
 7321 0118 6F6E 2073 		.string	"on sw# "
 7321      7723 2000 
 7322               		.text
 7323               	.global	pwmSummary
 7325               	pwmSummary:
 7326               	.LFB26:
 998:switcherator.c **** void pwmSummary(void) {
 7327               		.loc 1 998 0
 7328 2ace CF92      		push r12
 7329               	.LCFI175:
 7330 2ad0 DF92      		push r13
 7331               	.LCFI176:
 7332 2ad2 EF92      		push r14
 7333               	.LCFI177:
 7334 2ad4 FF92      		push r15
 7335               	.LCFI178:
 7336 2ad6 0F93      		push r16
 7337               	.LCFI179:
 7338 2ad8 1F93      		push r17
 7339               	.LCFI180:
 7340 2ada CF93      		push r28
 7341               	.LCFI181:
 7342 2adc DF93      		push r29
 7343               	.LCFI182:
 7344 2ade 1F92      		push __zero_reg__
 7345               	.LCFI183:
 7346 2ae0 CDB7      		in r28,__SP_L__
 7347 2ae2 DEB7      		in r29,__SP_H__
 7348               	.LCFI184:
 7349               	/* prologue: function */
 7350               	/* frame size = 1 */
 7351               	/* stack size = 9 */
 7352               	.L__stack_usage = 9
 999:switcherator.c ****     statusMsg[0] = 0;
 7353               		.loc 1 999 0
 7354 2ae4 1092 0000 		sts statusMsg,__zero_reg__
1000:switcherator.c ****     strcat(statusMsg, "Val 0x");
 7355               		.loc 1 1000 0
 7356 2ae8 60E0      		ldi r22,lo8(.LC49)
 7357 2aea 70E0      		ldi r23,hi8(.LC49)
 7358 2aec 80E0      		ldi r24,lo8(statusMsg)
 7359 2aee 90E0      		ldi r25,hi8(statusMsg)
 7360 2af0 0E94 0000 		call strcat
 7361               	.LVL565:
 7362 2af4 00E0      		ldi r16,lo8(pwmValues)
 7363 2af6 10E0      		ldi r17,hi8(pwmValues)
1002:switcherator.c ****     for (x = 0; x < 3; x++) {
 7364               		.loc 1 1002 0
 7365 2af8 E12C      		mov r14,__zero_reg__
 7366 2afa F12C      		mov r15,__zero_reg__
 7367 2afc 00C0      		rjmp .L505
 7368               	.LVL566:
 7369               	.L506:
1004:switcherator.c ****             strcat(statusMsg, ",");
 7370               		.loc 1 1004 0
 7371 2afe 60E0      		ldi r22,lo8(.LC50)
 7372 2b00 70E0      		ldi r23,hi8(.LC50)
 7373 2b02 80E0      		ldi r24,lo8(statusMsg)
 7374 2b04 90E0      		ldi r25,hi8(statusMsg)
 7375 2b06 0E94 0000 		call strcat
 7376               	.LVL567:
 7377               	.L505:
1005:switcherator.c ****         returnHexWithout(pwmValues[x], tempLongString);
 7378               		.loc 1 1005 0
 7379 2b0a 60E0      		ldi r22,lo8(tempLongString)
 7380 2b0c 70E0      		ldi r23,hi8(tempLongString)
 7381 2b0e F801      		movw r30,r16
 7382 2b10 8191      		ld r24,Z+
 7383 2b12 8F01      		movw r16,r30
 7384 2b14 90E0      		ldi r25,0
 7385 2b16 0E94 0000 		call returnHexWithout
 7386               	.LVL568:
1006:switcherator.c ****         strcat(statusMsg, tempLongString);
 7387               		.loc 1 1006 0
 7388 2b1a 60E0      		ldi r22,lo8(tempLongString)
 7389 2b1c 70E0      		ldi r23,hi8(tempLongString)
 7390 2b1e 80E0      		ldi r24,lo8(statusMsg)
 7391 2b20 90E0      		ldi r25,hi8(statusMsg)
 7392 2b22 0E94 0000 		call strcat
 7393               	.LVL569:
1002:switcherator.c ****     for (x = 0; x < 3; x++) {
 7394               		.loc 1 1002 0
 7395 2b26 FFEF      		ldi r31,-1
 7396 2b28 EF1A      		sub r14,r31
 7397 2b2a FF0A      		sbc r15,r31
 7398               	.LVL570:
 7399 2b2c 83E0      		ldi r24,3
 7400 2b2e E816      		cp r14,r24
 7401 2b30 F104      		cpc r15,__zero_reg__
 7402 2b32 01F4      		brne .L506
1008:switcherator.c ****     strcat(statusMsg, " dir ");
 7403               		.loc 1 1008 0
 7404 2b34 60E0      		ldi r22,lo8(.LC51)
 7405 2b36 70E0      		ldi r23,hi8(.LC51)
 7406 2b38 80E0      		ldi r24,lo8(statusMsg)
 7407 2b3a 90E0      		ldi r25,hi8(statusMsg)
 7408 2b3c 0E94 0000 		call strcat
 7409               	.LVL571:
1009:switcherator.c ****     returnInt(pwmdir, tempLongString);
 7410               		.loc 1 1009 0
 7411 2b40 60E0      		ldi r22,lo8(tempLongString)
 7412 2b42 70E0      		ldi r23,hi8(tempLongString)
 7413 2b44 8091 0000 		lds r24,pwmdir
 7414 2b48 90E0      		ldi r25,0
 7415 2b4a 0E94 0000 		call returnInt
 7416               	.LVL572:
1010:switcherator.c ****     strcat(statusMsg, tempLongString);
 7417               		.loc 1 1010 0
 7418 2b4e 60E0      		ldi r22,lo8(tempLongString)
 7419 2b50 70E0      		ldi r23,hi8(tempLongString)
 7420 2b52 80E0      		ldi r24,lo8(statusMsg)
 7421 2b54 90E0      		ldi r25,hi8(statusMsg)
 7422 2b56 0E94 0000 		call strcat
 7423               	.LVL573:
1011:switcherator.c ****     sendMessage(statusMsg);
 7424               		.loc 1 1011 0
 7425 2b5a 80E0      		ldi r24,lo8(statusMsg)
 7426 2b5c 90E0      		ldi r25,hi8(statusMsg)
 7427 2b5e 0E94 0000 		call sendMessage
 7428               	.LVL574:
1012:switcherator.c ****     statusMsg[0] = 0;
 7429               		.loc 1 1012 0
 7430 2b62 1092 0000 		sts statusMsg,__zero_reg__
1013:switcherator.c ****     strcat(statusMsg, "Col Ch");
 7431               		.loc 1 1013 0
 7432 2b66 60E0      		ldi r22,lo8(.LC52)
 7433 2b68 70E0      		ldi r23,hi8(.LC52)
 7434 2b6a 80E0      		ldi r24,lo8(statusMsg)
 7435 2b6c 90E0      		ldi r25,hi8(statusMsg)
 7436 2b6e 0E94 0000 		call strcat
 7437               	.LVL575:
 7438 2b72 E0E0      		ldi r30,lo8(colorChanges)
 7439 2b74 EE2E      		mov r14,r30
 7440 2b76 E0E0      		ldi r30,hi8(colorChanges)
 7441 2b78 FE2E      		mov r15,r30
1015:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 7442               		.loc 1 1015 0
 7443 2b7a C12C      		mov r12,__zero_reg__
 7444 2b7c D12C      		mov r13,__zero_reg__
 7445 2b7e 00C0      		rjmp .L507
 7446               	.LVL576:
 7447               	.L510:
1017:switcherator.c ****             strcat(statusMsg, ",");
 7448               		.loc 1 1017 0
 7449 2b80 60E0      		ldi r22,lo8(.LC50)
 7450 2b82 70E0      		ldi r23,hi8(.LC50)
 7451 2b84 80E0      		ldi r24,lo8(statusMsg)
 7452 2b86 90E0      		ldi r25,hi8(statusMsg)
 7453 2b88 0E94 0000 		call strcat
 7454               	.LVL577:
 7455 2b8c E3E0      		ldi r30,3
 7456 2b8e EE0E      		add r14,r30
 7457 2b90 F11C      		adc r15,__zero_reg__
 7458               	.LVL578:
 7459               	.L507:
1018:switcherator.c ****         strcat(statusMsg, "0x");
 7460               		.loc 1 1018 0
 7461 2b92 60E0      		ldi r22,lo8(.LC5)
 7462 2b94 70E0      		ldi r23,hi8(.LC5)
 7463 2b96 80E0      		ldi r24,lo8(statusMsg)
 7464 2b98 90E0      		ldi r25,hi8(statusMsg)
 7465 2b9a 0E94 0000 		call strcat
 7466               	.LVL579:
1019:switcherator.c ****         for (y = 0; y < 3; y++) {
 7467               		.loc 1 1019 0
 7468 2b9e 00E0      		ldi r16,0
 7469 2ba0 10E0      		ldi r17,0
 7470               	.LVL580:
 7471               	.L508:
 998:switcherator.c **** void pwmSummary(void) {
 7472               		.loc 1 998 0 discriminator 2
 7473 2ba2 F701      		movw r30,r14
 7474 2ba4 E00F      		add r30,r16
 7475 2ba6 F11F      		adc r31,r17
1020:switcherator.c ****             returnHexWithout(colorChanges[x][y], tempLongString);
 7476               		.loc 1 1020 0 discriminator 2
 7477 2ba8 60E0      		ldi r22,lo8(tempLongString)
 7478 2baa 70E0      		ldi r23,hi8(tempLongString)
 7479 2bac 8081      		ld r24,Z
 7480 2bae 90E0      		ldi r25,0
 7481 2bb0 0E94 0000 		call returnHexWithout
 7482               	.LVL581:
1021:switcherator.c ****             strcat(statusMsg, tempLongString);
 7483               		.loc 1 1021 0 discriminator 2
 7484 2bb4 60E0      		ldi r22,lo8(tempLongString)
 7485 2bb6 70E0      		ldi r23,hi8(tempLongString)
 7486 2bb8 80E0      		ldi r24,lo8(statusMsg)
 7487 2bba 90E0      		ldi r25,hi8(statusMsg)
 7488 2bbc 0E94 0000 		call strcat
 7489               	.LVL582:
1019:switcherator.c ****         for (y = 0; y < 3; y++) {
 7490               		.loc 1 1019 0 discriminator 2
 7491 2bc0 0F5F      		subi r16,-1
 7492 2bc2 1F4F      		sbci r17,-1
 7493               	.LVL583:
 7494 2bc4 0330      		cpi r16,3
 7495 2bc6 1105      		cpc r17,__zero_reg__
 7496 2bc8 01F4      		brne .L508
1023:switcherator.c ****         if (strlen(statusMsg) > 25 && (x + 1) < NUM_COLOR_CHANGES) {
 7497               		.loc 1 1023 0
 7498 2bca E0E0      		ldi r30,lo8(statusMsg)
 7499 2bcc F0E0      		ldi r31,hi8(statusMsg)
 7500               		0:
 7501 2bce 0190      		ld __tmp_reg__,Z+
 7502 2bd0 0020      		tst __tmp_reg__
 7503 2bd2 01F4      		brne 0b
 7504 2bd4 3197      		sbiw r30,1
 7505 2bd6 E050      		subi r30,lo8(statusMsg)
 7506 2bd8 F040      		sbci r31,hi8(statusMsg)
 7507 2bda 7A97      		sbiw r30,26
 7508 2bdc 00F0      		brlo .L509
1023:switcherator.c ****         if (strlen(statusMsg) > 25 && (x + 1) < NUM_COLOR_CHANGES) {
 7509               		.loc 1 1023 0 is_stmt 0 discriminator 1
 7510 2bde F5E0      		ldi r31,5
 7511 2be0 CF16      		cp r12,r31
 7512 2be2 D104      		cpc r13,__zero_reg__
 7513 2be4 01F0      		breq .L509
1024:switcherator.c ****             sendMessage(statusMsg);
 7514               		.loc 1 1024 0 is_stmt 1
 7515 2be6 80E0      		ldi r24,lo8(statusMsg)
 7516 2be8 90E0      		ldi r25,hi8(statusMsg)
 7517 2bea 0E94 0000 		call sendMessage
 7518               	.LVL584:
1025:switcherator.c ****             statusMsg[6] = 0;
 7519               		.loc 1 1025 0
 7520 2bee 1092 0000 		sts statusMsg+6,__zero_reg__
 7521               	.L509:
1015:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 7522               		.loc 1 1015 0
 7523 2bf2 8FEF      		ldi r24,-1
 7524 2bf4 C81A      		sub r12,r24
 7525 2bf6 D80A      		sbc r13,r24
 7526               	.LVL585:
 7527 2bf8 E6E0      		ldi r30,6
 7528 2bfa CE16      		cp r12,r30
 7529 2bfc D104      		cpc r13,__zero_reg__
 7530 2bfe 01F0      		breq .+2
 7531 2c00 00C0      		rjmp .L510
1028:switcherator.c ****     sendMessage(statusMsg);
 7532               		.loc 1 1028 0
 7533 2c02 80E0      		ldi r24,lo8(statusMsg)
 7534 2c04 90E0      		ldi r25,hi8(statusMsg)
 7535 2c06 0E94 0000 		call sendMessage
 7536               	.LVL586:
1029:switcherator.c ****     statusMsg[0] = 0;
 7537               		.loc 1 1029 0
 7538 2c0a 1092 0000 		sts statusMsg,__zero_reg__
 7539               	.LVL587:
 7540 2c0e 00E0      		ldi r16,lo8(switchStuff)
 7541 2c10 10E0      		ldi r17,hi8(switchStuff)
 7542               	.LVL588:
1030:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 7543               		.loc 1 1030 0
 7544 2c12 E12C      		mov r14,__zero_reg__
 7545 2c14 F12C      		mov r15,__zero_reg__
 7546               	.LVL589:
 7547               	.L515:
1031:switcherator.c ****         if ((switchStuff[x] >= 200) && (switchStuff[x] <= 220)) {
 7548               		.loc 1 1031 0
 7549 2c16 F801      		movw r30,r16
 7550 2c18 2191      		ld r18,Z+
 7551 2c1a 8F01      		movw r16,r30
 7552 2c1c 822F      		mov r24,r18
 7553 2c1e 885C      		subi r24,lo8(-(56))
 7554 2c20 8531      		cpi r24,lo8(21)
 7555 2c22 00F4      		brsh .L511
1032:switcherator.c ****             strcat(statusMsg, "PWM ");
 7556               		.loc 1 1032 0
 7557 2c24 60E0      		ldi r22,lo8(.LC53)
 7558 2c26 70E0      		ldi r23,hi8(.LC53)
 7559 2c28 80E0      		ldi r24,lo8(statusMsg)
 7560 2c2a 90E0      		ldi r25,hi8(statusMsg)
 7561 2c2c 2983      		std Y+1,r18
 7562 2c2e 0E94 0000 		call strcat
 7563               	.LVL590:
1033:switcherator.c ****             if (switchStuff[x] == 200) {
 7564               		.loc 1 1033 0
 7565 2c32 2981      		ldd r18,Y+1
 7566 2c34 283C      		cpi r18,lo8(-56)
 7567 2c36 01F4      		brne .L512
1034:switcherator.c ****                 strcat(statusMsg, "static");
 7568               		.loc 1 1034 0
 7569 2c38 60E0      		ldi r22,lo8(.LC54)
 7570 2c3a 70E0      		ldi r23,hi8(.LC54)
 7571 2c3c 00C0      		rjmp .L521
 7572               	.L512:
1035:switcherator.c ****             } else if (switchStuff[x] == 202) {
 7573               		.loc 1 1035 0
 7574 2c3e 2A3C      		cpi r18,lo8(-54)
 7575 2c40 01F4      		brne .L514
1036:switcherator.c ****                 strcat(statusMsg, "ColCh");
 7576               		.loc 1 1036 0
 7577 2c42 60E0      		ldi r22,lo8(.LC55)
 7578 2c44 70E0      		ldi r23,hi8(.LC55)
 7579 2c46 00C0      		rjmp .L521
 7580               	.L514:
1038:switcherator.c ****                 strcat(statusMsg, "hue");
 7581               		.loc 1 1038 0
 7582 2c48 60E0      		ldi r22,lo8(.LC56)
 7583 2c4a 70E0      		ldi r23,hi8(.LC56)
 7584               	.L521:
 7585 2c4c 80E0      		ldi r24,lo8(statusMsg)
 7586 2c4e 90E0      		ldi r25,hi8(statusMsg)
 7587 2c50 0E94 0000 		call strcat
 7588               	.LVL591:
1040:switcherator.c ****             strcat(statusMsg, "on sw# ");
 7589               		.loc 1 1040 0
 7590 2c54 60E0      		ldi r22,lo8(.LC57)
 7591 2c56 70E0      		ldi r23,hi8(.LC57)
 7592 2c58 80E0      		ldi r24,lo8(statusMsg)
 7593 2c5a 90E0      		ldi r25,hi8(statusMsg)
 7594 2c5c 0E94 0000 		call strcat
 7595               	.LVL592:
1041:switcherator.c ****             returnInt(x, tempLongString);
 7596               		.loc 1 1041 0
 7597 2c60 60E0      		ldi r22,lo8(tempLongString)
 7598 2c62 70E0      		ldi r23,hi8(tempLongString)
 7599 2c64 C701      		movw r24,r14
 7600 2c66 0E94 0000 		call returnInt
 7601               	.LVL593:
1042:switcherator.c ****             strcat(statusMsg, tempLongString);
 7602               		.loc 1 1042 0
 7603 2c6a 60E0      		ldi r22,lo8(tempLongString)
 7604 2c6c 70E0      		ldi r23,hi8(tempLongString)
 7605 2c6e 80E0      		ldi r24,lo8(statusMsg)
 7606 2c70 90E0      		ldi r25,hi8(statusMsg)
 7607 2c72 0E94 0000 		call strcat
 7608               	.LVL594:
1043:switcherator.c ****             sendMessage(statusMsg);
 7609               		.loc 1 1043 0
 7610 2c76 80E0      		ldi r24,lo8(statusMsg)
 7611 2c78 90E0      		ldi r25,hi8(statusMsg)
 7612 2c7a 0E94 0000 		call sendMessage
 7613               	.LVL595:
1044:switcherator.c ****             statusMsg[0] = 0;
 7614               		.loc 1 1044 0
 7615 2c7e 1092 0000 		sts statusMsg,__zero_reg__
 7616               	.L511:
1030:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 7617               		.loc 1 1030 0
 7618 2c82 FFEF      		ldi r31,-1
 7619 2c84 EF1A      		sub r14,r31
 7620 2c86 FF0A      		sbc r15,r31
 7621               	.LVL596:
 7622 2c88 80E1      		ldi r24,16
 7623 2c8a E816      		cp r14,r24
 7624 2c8c F104      		cpc r15,__zero_reg__
 7625 2c8e 01F4      		brne .L515
 7626               	/* epilogue start */
1047:switcherator.c **** }
 7627               		.loc 1 1047 0
 7628 2c90 0F90      		pop __tmp_reg__
 7629 2c92 DF91      		pop r29
 7630 2c94 CF91      		pop r28
 7631 2c96 1F91      		pop r17
 7632 2c98 0F91      		pop r16
 7633 2c9a FF90      		pop r15
 7634 2c9c EF90      		pop r14
 7635               	.LVL597:
 7636 2c9e DF90      		pop r13
 7637 2ca0 CF90      		pop r12
 7638 2ca2 0895      		ret
 7639               	.LFE26:
 7641               		.section	.rodata.str1.1
 7642               	.LC58:
 7643 0120 436F 4300 		.string	"CoC"
 7644               	.LC59:
 7645 0124 4272 7400 		.string	"Brt"
 7646               	.LC60:
 7647 0128 4669 7800 		.string	"Fix"
 7648               	.LC61:
 7649 012c 4875 6500 		.string	"Hue"
 7650               	.LC62:
 7651 0130 4C00      		.string	"L"
 7652               	.LC63:
 7653 0132 4800      		.string	"H"
 7654               		.text
 7655               	.global	switchDisplay
 7657               	switchDisplay:
 7658               	.LFB16:
 621:switcherator.c **** void switchDisplay(char * commandReceived) {
 7659               		.loc 1 621 0
 7660               	.LVL598:
 7661 2ca4 CF93      		push r28
 7662               	.LCFI185:
 7663 2ca6 DF93      		push r29
 7664               	.LCFI186:
 7665 2ca8 CDB7      		in r28,__SP_L__
 7666 2caa DEB7      		in r29,__SP_H__
 7667               	.LCFI187:
 7668 2cac A397      		sbiw r28,35
 7669               	.LCFI188:
 7670 2cae 0FB6      		in __tmp_reg__,__SREG__
 7671 2cb0 F894      		cli
 7672 2cb2 DEBF      		out __SP_H__,r29
 7673 2cb4 0FBE      		out __SREG__,__tmp_reg__
 7674 2cb6 CDBF      		out __SP_L__,r28
 7675               	/* prologue: function */
 7676               	/* frame size = 35 */
 7677               	/* stack size = 37 */
 7678               	.L__stack_usage = 37
 622:switcherator.c ****     char port[] = {0};
 7679               		.loc 1 622 0
 7680 2cb8 1BA2      		std Y+35,__zero_reg__
 623:switcherator.c ****     char pin[] = {0};
 7681               		.loc 1 623 0
 7682 2cba 1AA2      		std Y+34,__zero_reg__
 624:switcherator.c ****     char direction[] = {0};
 7683               		.loc 1 624 0
 7684 2cbc 19A2      		std Y+33,__zero_reg__
 7685               	.LVL599:
 628:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 7686               		.loc 1 628 0
 7687 2cbe 0E94 0000 		call getSwitchNumber
 7688               	.LVL600:
 629:switcherator.c ****     statusMsg[0] = 0;
 7689               		.loc 1 629 0
 7690 2cc2 1982      		std Y+1,__zero_reg__
 631:switcherator.c ****     if (switchStuff[switchNumber] >= 200 && switchStuff[switchNumber] <= 220) {
 7691               		.loc 1 631 0
 7692 2cc4 FC01      		movw r30,r24
 7693 2cc6 E050      		subi r30,lo8(-(switchStuff))
 7694 2cc8 F040      		sbci r31,hi8(-(switchStuff))
 7695 2cca 2081      		ld r18,Z
 7696 2ccc 322F      		mov r19,r18
 7697 2cce 385C      		subi r19,lo8(-(56))
 7698 2cd0 3531      		cpi r19,lo8(21)
 7699 2cd2 00F4      		brsh .L523
 633:switcherator.c ****         if (switchStuff[switchNumber] % 2 == 0) {
 7700               		.loc 1 633 0
 7701 2cd4 20FD      		sbrc r18,0
 7702 2cd6 00C0      		rjmp .L524
 634:switcherator.c ****             if (switchStuff[switchNumber] == 202) {
 7703               		.loc 1 634 0
 7704 2cd8 2A3C      		cpi r18,lo8(-54)
 7705 2cda 01F4      		brne .L525
 635:switcherator.c ****                 strcat(statusMsg, "CoC");
 7706               		.loc 1 635 0
 7707 2cdc 60E0      		ldi r22,lo8(.LC58)
 7708 2cde 70E0      		ldi r23,hi8(.LC58)
 7709 2ce0 00C0      		rjmp .L529
 7710               	.L525:
 636:switcherator.c ****             } else if (switchStuff[switchNumber] == 212) {
 7711               		.loc 1 636 0
 7712 2ce2 243D      		cpi r18,lo8(-44)
 7713 2ce4 01F4      		brne .L527
 637:switcherator.c ****                 strcat(statusMsg, "Brt");
 7714               		.loc 1 637 0
 7715 2ce6 60E0      		ldi r22,lo8(.LC59)
 7716 2ce8 70E0      		ldi r23,hi8(.LC59)
 7717 2cea 00C0      		rjmp .L529
 7718               	.L527:
 639:switcherator.c ****                 strcat(statusMsg, "Fix");
 7719               		.loc 1 639 0
 7720 2cec 60E0      		ldi r22,lo8(.LC60)
 7721 2cee 70E0      		ldi r23,hi8(.LC60)
 7722 2cf0 00C0      		rjmp .L529
 7723               	.L524:
 642:switcherator.c ****             strcat(statusMsg, "Hue");
 7724               		.loc 1 642 0
 7725 2cf2 60E0      		ldi r22,lo8(.LC61)
 7726 2cf4 70E0      		ldi r23,hi8(.LC61)
 7727 2cf6 00C0      		rjmp .L529
 7728               	.L523:
 645:switcherator.c ****         getPort(switchNumber, port, pin, direction);
 7729               		.loc 1 645 0
 7730 2cf8 9E01      		movw r18,r28
 7731 2cfa 2F5D      		subi r18,-33
 7732 2cfc 3F4F      		sbci r19,-1
 7733 2cfe AE01      		movw r20,r28
 7734 2d00 4E5D      		subi r20,-34
 7735 2d02 5F4F      		sbci r21,-1
 7736 2d04 BE01      		movw r22,r28
 7737 2d06 6D5D      		subi r22,-35
 7738 2d08 7F4F      		sbci r23,-1
 7739 2d0a 0E94 0000 		call getPort
 7740               	.LVL601:
 646:switcherator.c ****         tempIntString[0] = port[0];
 7741               		.loc 1 646 0
 7742 2d0e 8BA1      		ldd r24,Y+35
 7743 2d10 8093 0000 		sts tempIntString,r24
 647:switcherator.c ****         tempIntString[1] = 0;
 7744               		.loc 1 647 0
 7745 2d14 1092 0000 		sts tempIntString+1,__zero_reg__
 648:switcherator.c ****         strcat(statusMsg, tempIntString);
 7746               		.loc 1 648 0
 7747 2d18 60E0      		ldi r22,lo8(tempIntString)
 7748 2d1a 70E0      		ldi r23,hi8(tempIntString)
 7749 2d1c CE01      		movw r24,r28
 7750 2d1e 0196      		adiw r24,1
 7751 2d20 0E94 0000 		call strcat
 7752               	.LVL602:
 650:switcherator.c ****         itoa(realPin, tempIntString, 10);
 7753               		.loc 1 650 0
 7754 2d24 4AE0      		ldi r20,lo8(10)
 7755 2d26 50E0      		ldi r21,0
 7756 2d28 60E0      		ldi r22,lo8(tempIntString)
 7757 2d2a 70E0      		ldi r23,hi8(tempIntString)
 7758 2d2c 8AA1      		ldd r24,Y+34
 7759 2d2e 90E0      		ldi r25,0
 7760 2d30 0E94 0000 		call itoa
 7761               	.LVL603:
 651:switcherator.c ****         strcat(statusMsg, tempIntString);
 7762               		.loc 1 651 0
 7763 2d34 60E0      		ldi r22,lo8(tempIntString)
 7764 2d36 70E0      		ldi r23,hi8(tempIntString)
 7765 2d38 CE01      		movw r24,r28
 7766 2d3a 0196      		adiw r24,1
 7767 2d3c 0E94 0000 		call strcat
 7768               	.LVL604:
 652:switcherator.c ****         if (direction[0] == 0) {
 7769               		.loc 1 652 0
 7770 2d40 89A1      		ldd r24,Y+33
 7771 2d42 8111      		cpse r24,__zero_reg__
 7772 2d44 00C0      		rjmp .L528
 653:switcherator.c ****             strcat(statusMsg, "L");
 7773               		.loc 1 653 0
 7774 2d46 60E0      		ldi r22,lo8(.LC62)
 7775 2d48 70E0      		ldi r23,hi8(.LC62)
 7776 2d4a 00C0      		rjmp .L529
 7777               	.L528:
 655:switcherator.c ****             strcat(statusMsg, "H");
 7778               		.loc 1 655 0
 7779 2d4c 60E0      		ldi r22,lo8(.LC63)
 7780 2d4e 70E0      		ldi r23,hi8(.LC63)
 7781               	.L529:
 7782 2d50 CE01      		movw r24,r28
 7783 2d52 0196      		adiw r24,1
 7784 2d54 0E94 0000 		call strcat
 7785               	.LVL605:
 658:switcherator.c ****     sendMessage(statusMsg);
 7786               		.loc 1 658 0
 7787 2d58 CE01      		movw r24,r28
 7788 2d5a 0196      		adiw r24,1
 7789 2d5c 0E94 0000 		call sendMessage
 7790               	.LVL606:
 7791               	/* epilogue start */
 660:switcherator.c **** }
 7792               		.loc 1 660 0
 7793 2d60 A396      		adiw r28,35
 7794 2d62 0FB6      		in __tmp_reg__,__SREG__
 7795 2d64 F894      		cli
 7796 2d66 DEBF      		out __SP_H__,r29
 7797 2d68 0FBE      		out __SREG__,__tmp_reg__
 7798 2d6a CDBF      		out __SP_L__,r28
 7799 2d6c DF91      		pop r29
 7800 2d6e CF91      		pop r28
 7801 2d70 0895      		ret
 7802               	.LFE16:
 7804               		.section	.rodata.str1.1
 7805               	.LC64:
 7806 0134 6F6B 00   		.string	"ok"
 7807               		.text
 7808               	.global	ok
 7810               	ok:
 7811               	.LFB11:
 410:switcherator.c **** void ok(void) {
 7812               		.loc 1 410 0
 7813               	/* prologue: function */
 7814               	/* frame size = 0 */
 7815               	/* stack size = 0 */
 7816               	.L__stack_usage = 0
 411:switcherator.c ****     sendMessage("ok");
 7817               		.loc 1 411 0
 7818 2d72 80E0      		ldi r24,lo8(.LC64)
 7819 2d74 90E0      		ldi r25,hi8(.LC64)
 7820 2d76 0C94 0000 		jmp sendMessage
 7821               	.LVL607:
 7822               	.LFE11:
 7824               	.global	clearInput
 7826               	clearInput:
 7827               	.LFB78:
3600:switcherator.c **** void clearInput(char * commandReceived) {
 7828               		.loc 1 3600 0
 7829               	.LVL608:
 7830               	/* prologue: function */
 7831               	/* frame size = 0 */
 7832               	/* stack size = 0 */
 7833               	.L__stack_usage = 0
3603:switcherator.c ****     tempIntString[0] = commandReceived[3];
 7834               		.loc 1 3603 0
 7835 2d7a FC01      		movw r30,r24
 7836 2d7c 2381      		ldd r18,Z+3
 7837 2d7e 2093 0000 		sts tempIntString,r18
3604:switcherator.c ****     tempIntString[1] = commandReceived[4];
 7838               		.loc 1 3604 0
 7839 2d82 8481      		ldd r24,Z+4
 7840               	.LVL609:
 7841 2d84 8093 0000 		sts tempIntString+1,r24
3605:switcherator.c ****     inputNumber = atoi(tempIntString);
 7842               		.loc 1 3605 0
 7843 2d88 80E0      		ldi r24,lo8(tempIntString)
 7844 2d8a 90E0      		ldi r25,hi8(tempIntString)
 7845 2d8c 0E94 0000 		call atoi
 7846               	.LVL610:
3606:switcherator.c ****     int temp = inputs[inputNumber][0];
 7847               		.loc 1 3606 0
 7848 2d90 F3E0      		ldi r31,3
 7849               		1:
 7850 2d92 880F      		lsl r24
 7851 2d94 991F      		rol r25
 7852 2d96 FA95      		dec r31
 7853 2d98 01F4      		brne 1b
 7854               	.LVL611:
 7855 2d9a FC01      		movw r30,r24
 7856 2d9c E050      		subi r30,lo8(-(inputs))
 7857 2d9e F040      		sbci r31,hi8(-(inputs))
 7858 2da0 2081      		ld r18,Z
 7859 2da2 30E0      		ldi r19,0
 7860               	.LVL612:
3607:switcherator.c ****     if (temp > 15 && temp < 32) {
 7861               		.loc 1 3607 0
 7862 2da4 A901      		movw r20,r18
 7863 2da6 4051      		subi r20,16
 7864 2da8 5109      		sbc r21,__zero_reg__
 7865 2daa 4031      		cpi r20,16
 7866 2dac 5105      		cpc r21,__zero_reg__
 7867 2dae 00F4      		brsh .L532
 7868               	.LVL613:
3609:switcherator.c ****         temp -= 16;
 7869               		.loc 1 3609 0
 7870 2db0 9A01      		movw r18,r20
 7871               	.LVL614:
3608:switcherator.c ****         thisPort = &PINB;
 7872               		.loc 1 3608 0
 7873 2db2 E3E2      		ldi r30,lo8(35)
 7874 2db4 F0E0      		ldi r31,0
 7875 2db6 00C0      		rjmp .L533
 7876               	.LVL615:
 7877               	.L532:
3616:switcherator.c ****     } else if (temp < 48) {
 7878               		.loc 1 3616 0
 7879 2db8 2033      		cpi r18,48
 7880 2dba 3105      		cpc r19,__zero_reg__
 7881 2dbc 04F4      		brge .L534
 7882               	.LVL616:
3618:switcherator.c ****         temp -= 32;
 7883               		.loc 1 3618 0
 7884 2dbe 2052      		subi r18,32
 7885 2dc0 3109      		sbc r19,__zero_reg__
 7886               	.LVL617:
3617:switcherator.c ****         thisPort = &PINC;
 7887               		.loc 1 3617 0
 7888 2dc2 E6E2      		ldi r30,lo8(38)
 7889 2dc4 F0E0      		ldi r31,0
 7890 2dc6 00C0      		rjmp .L533
 7891               	.LVL618:
 7892               	.L534:
3621:switcherator.c ****     } else if (temp < 64) {
 7893               		.loc 1 3621 0
 7894 2dc8 2034      		cpi r18,64
 7895 2dca 3105      		cpc r19,__zero_reg__
 7896 2dcc 04F4      		brge .L536
 7897               	.LVL619:
3623:switcherator.c ****         temp -= 48;
 7898               		.loc 1 3623 0
 7899 2dce 2053      		subi r18,48
 7900 2dd0 3109      		sbc r19,__zero_reg__
 7901               	.LVL620:
3622:switcherator.c ****         thisPort = &PIND;
 7902               		.loc 1 3622 0
 7903 2dd2 E9E2      		ldi r30,lo8(41)
 7904 2dd4 F0E0      		ldi r31,0
 7905               	.LVL621:
 7906               	.L533:
3655:switcherator.c ****     *thisPort &= ~(1 << temp);
 7907               		.loc 1 3655 0
 7908 2dd6 3081      		ld r19,Z
 7909 2dd8 41E0      		ldi r20,lo8(1)
 7910 2dda 50E0      		ldi r21,0
 7911 2ddc 00C0      		rjmp 2f
 7912               		1:
 7913 2dde 440F      		lsl r20
 7914               		2:
 7915 2de0 2A95      		dec r18
 7916 2de2 02F4      		brpl 1b
 7917 2de4 4095      		com r20
 7918 2de6 4323      		and r20,r19
 7919 2de8 4083      		st Z,r20
3656:switcherator.c ****     inputs[inputNumber][0] = 255;
 7920               		.loc 1 3656 0
 7921 2dea FC01      		movw r30,r24
 7922               	.LVL622:
 7923 2dec E050      		subi r30,lo8(-(inputs))
 7924 2dee F040      		sbci r31,hi8(-(inputs))
 7925 2df0 2FEF      		ldi r18,lo8(-1)
 7926 2df2 2083      		st Z,r18
 7927               	.L536:
3657:switcherator.c ****     ok();
 7928               		.loc 1 3657 0
 7929 2df4 0C94 0000 		jmp ok
 7930               	.LVL623:
 7931               	.LFE78:
 7933               	.global	setDaylightSavings
 7935               	setDaylightSavings:
 7936               	.LFB54:
2242:switcherator.c **** void setDaylightSavings(char * commandReceived) {
 7937               		.loc 1 2242 0
 7938               	.LVL624:
 7939 2df8 EF92      		push r14
 7940               	.LCFI189:
 7941 2dfa FF92      		push r15
 7942               	.LCFI190:
 7943 2dfc 0F93      		push r16
 7944               	.LCFI191:
 7945 2dfe 1F93      		push r17
 7946               	.LCFI192:
 7947 2e00 CF93      		push r28
 7948               	.LCFI193:
 7949 2e02 DF93      		push r29
 7950               	.LCFI194:
 7951               	/* prologue: function */
 7952               	/* frame size = 0 */
 7953               	/* stack size = 6 */
 7954               	.L__stack_usage = 6
 7955 2e04 EC01      		movw r28,r24
2244:switcherator.c ****     tempIntString[0] = commandReceived[3];
 7956               		.loc 1 2244 0
 7957 2e06 A0E0      		ldi r26,lo8(tempIntString)
 7958 2e08 EA2E      		mov r14,r26
 7959 2e0a A0E0      		ldi r26,hi8(tempIntString)
 7960 2e0c FA2E      		mov r15,r26
 7961 2e0e 8B81      		ldd r24,Y+3
 7962               	.LVL625:
 7963 2e10 F701      		movw r30,r14
 7964 2e12 8083      		st Z,r24
2245:switcherator.c ****     tempIntString[1] = commandReceived[4];
 7965               		.loc 1 2245 0
 7966 2e14 00E0      		ldi r16,lo8(tempIntString+1)
 7967 2e16 10E0      		ldi r17,hi8(tempIntString+1)
 7968 2e18 8C81      		ldd r24,Y+4
 7969 2e1a F801      		movw r30,r16
 7970 2e1c 8083      		st Z,r24
2246:switcherator.c ****     dlInt = atoi(tempIntString);
 7971               		.loc 1 2246 0
 7972 2e1e C701      		movw r24,r14
 7973 2e20 0E94 0000 		call atoi
 7974               	.LVL626:
2247:switcherator.c ****     daylightSavings[0][0] = dlInt;
 7975               		.loc 1 2247 0
 7976 2e24 9093 0000 		sts daylightSavings+1,r25
 7977 2e28 8093 0000 		sts daylightSavings,r24
2248:switcherator.c ****     tempIntString[0] = commandReceived[5];
 7978               		.loc 1 2248 0
 7979 2e2c 8D81      		ldd r24,Y+5
 7980               	.LVL627:
 7981 2e2e F701      		movw r30,r14
 7982 2e30 8083      		st Z,r24
2249:switcherator.c ****     tempIntString[1] = commandReceived[6];
 7983               		.loc 1 2249 0
 7984 2e32 8E81      		ldd r24,Y+6
 7985 2e34 F801      		movw r30,r16
 7986 2e36 8083      		st Z,r24
2250:switcherator.c ****     dlInt = atoi(tempIntString);
 7987               		.loc 1 2250 0
 7988 2e38 C701      		movw r24,r14
 7989 2e3a 0E94 0000 		call atoi
 7990               	.LVL628:
2251:switcherator.c ****     daylightSavings[0][1] = dlInt;
 7991               		.loc 1 2251 0
 7992 2e3e 9093 0000 		sts daylightSavings+2+1,r25
 7993 2e42 8093 0000 		sts daylightSavings+2,r24
2252:switcherator.c ****     tempIntString[0] = commandReceived[8];
 7994               		.loc 1 2252 0
 7995 2e46 8885      		ldd r24,Y+8
 7996               	.LVL629:
 7997 2e48 F701      		movw r30,r14
 7998 2e4a 8083      		st Z,r24
2253:switcherator.c ****     tempIntString[1] = commandReceived[9];
 7999               		.loc 1 2253 0
 8000 2e4c 8985      		ldd r24,Y+9
 8001 2e4e F801      		movw r30,r16
 8002 2e50 8083      		st Z,r24
2254:switcherator.c ****     dlInt = atoi(tempIntString);
 8003               		.loc 1 2254 0
 8004 2e52 C701      		movw r24,r14
 8005 2e54 0E94 0000 		call atoi
 8006               	.LVL630:
2255:switcherator.c ****     daylightSavings[1][0] = dlInt;
 8007               		.loc 1 2255 0
 8008 2e58 9093 0000 		sts daylightSavings+4+1,r25
 8009 2e5c 8093 0000 		sts daylightSavings+4,r24
2256:switcherator.c ****     tempIntString[0] = commandReceived[10];
 8010               		.loc 1 2256 0
 8011 2e60 8A85      		ldd r24,Y+10
 8012               	.LVL631:
 8013 2e62 F701      		movw r30,r14
 8014 2e64 8083      		st Z,r24
2257:switcherator.c ****     tempIntString[1] = commandReceived[11];
 8015               		.loc 1 2257 0
 8016 2e66 8B85      		ldd r24,Y+11
 8017 2e68 F801      		movw r30,r16
 8018 2e6a 8083      		st Z,r24
2258:switcherator.c ****     dlInt = atoi(tempIntString);
 8019               		.loc 1 2258 0
 8020 2e6c C701      		movw r24,r14
 8021 2e6e 0E94 0000 		call atoi
 8022               	.LVL632:
2259:switcherator.c ****     daylightSavings[1][1] = dlInt;
 8023               		.loc 1 2259 0
 8024 2e72 9093 0000 		sts daylightSavings+6+1,r25
 8025 2e76 8093 0000 		sts daylightSavings+6,r24
 8026               	/* epilogue start */
2261:switcherator.c **** }
 8027               		.loc 1 2261 0
 8028 2e7a DF91      		pop r29
 8029 2e7c CF91      		pop r28
 8030               	.LVL633:
 8031 2e7e 1F91      		pop r17
 8032 2e80 0F91      		pop r16
 8033 2e82 FF90      		pop r15
 8034 2e84 EF90      		pop r14
2260:switcherator.c ****     ok();
 8035               		.loc 1 2260 0
 8036 2e86 0C94 0000 		jmp ok
 8037               	.LVL634:
 8038               	.LFE54:
 8040               	.global	clearToEEPROM
 8042               	clearToEEPROM:
 8043               	.LFB46:
2072:switcherator.c **** void clearToEEPROM(void) {
 8044               		.loc 1 2072 0
 8045 2e8a CF93      		push r28
 8046               	.LCFI195:
 8047 2e8c DF93      		push r29
 8048               	.LCFI196:
 8049               	/* prologue: function */
 8050               	/* frame size = 0 */
 8051               	/* stack size = 2 */
 8052               	.L__stack_usage = 2
 8053               	.LVL635:
2074:switcherator.c ****     clearEEPROM(SERIAL_NUM);
 8054               		.loc 1 2074 0
 8055 2e8e 80E0      		ldi r24,0
 8056 2e90 90E0      		ldi r25,0
 8057 2e92 0E94 0000 		call clearEEPROM
 8058               	.LVL636:
2075:switcherator.c ****     clearEEPROM(DAYLIGHT_SAVE);
 8059               		.loc 1 2075 0
 8060 2e96 86E0      		ldi r24,lo8(6)
 8061 2e98 90E0      		ldi r25,0
 8062 2e9a 0E94 0000 		call clearEEPROM
 8063               	.LVL637:
2076:switcherator.c ****     clearEEPROM(RADIO_ADDR_TX);
 8064               		.loc 1 2076 0
 8065 2e9e 8EE0      		ldi r24,lo8(14)
 8066 2ea0 90E0      		ldi r25,0
 8067 2ea2 0E94 0000 		call clearEEPROM
 8068               	.LVL638:
2077:switcherator.c ****     clearEEPROM(RADIO_ADDR_R0);
 8069               		.loc 1 2077 0
 8070 2ea6 85E1      		ldi r24,lo8(21)
 8071 2ea8 90E0      		ldi r25,0
 8072 2eaa 0E94 0000 		call clearEEPROM
 8073               	.LVL639:
2078:switcherator.c ****     clearEEPROM(RADIO_ADDR_R1);
 8074               		.loc 1 2078 0
 8075 2eae 8CE1      		ldi r24,lo8(28)
 8076 2eb0 90E0      		ldi r25,0
 8077 2eb2 0E94 0000 		call clearEEPROM
 8078               	.LVL640:
2079:switcherator.c ****     clearEEPROM(RADIO_ADDR_R2);
 8079               		.loc 1 2079 0
 8080 2eb6 83E2      		ldi r24,lo8(35)
 8081 2eb8 90E0      		ldi r25,0
 8082 2eba 0E94 0000 		call clearEEPROM
 8083               	.LVL641:
2080:switcherator.c ****     clearEEPROM(RADIO_ADDR_R3);
 8084               		.loc 1 2080 0
 8085 2ebe 86E2      		ldi r24,lo8(38)
 8086 2ec0 90E0      		ldi r25,0
 8087 2ec2 0E94 0000 		call clearEEPROM
 8088               	.LVL642:
2081:switcherator.c ****     clearEEPROM(RADIO_ADDR_R4);
 8089               		.loc 1 2081 0
 8090 2ec6 89E2      		ldi r24,lo8(41)
 8091 2ec8 90E0      		ldi r25,0
 8092 2eca 0E94 0000 		call clearEEPROM
 8093               	.LVL643:
2082:switcherator.c ****     clearEEPROM(RADIO_ADDR_R5);
 8094               		.loc 1 2082 0
 8095 2ece 8CE2      		ldi r24,lo8(44)
 8096 2ed0 90E0      		ldi r25,0
 8097 2ed2 0E94 0000 		call clearEEPROM
 8098               	.LVL644:
2083:switcherator.c ****     clearEEPROM(SWITCH_STUFF);
 8099               		.loc 1 2083 0
 8100 2ed6 80E3      		ldi r24,lo8(48)
 8101 2ed8 90E0      		ldi r25,0
 8102 2eda 0E94 0000 		call clearEEPROM
 8103               	.LVL645:
2084:switcherator.c ****     clearEEPROM(PWM_DIR);
 8104               		.loc 1 2084 0
 8105 2ede 8DE1      		ldi r24,lo8(29)
 8106 2ee0 91E0      		ldi r25,lo8(1)
 8107 2ee2 0E94 0000 		call clearEEPROM
 8108               	.LVL646:
2085:switcherator.c ****     clearEEPROM(BRIGHTNESS);
 8109               		.loc 1 2085 0
 8110 2ee6 80E2      		ldi r24,lo8(32)
 8111 2ee8 91E0      		ldi r25,lo8(1)
 8112 2eea 0E94 0000 		call clearEEPROM
 8113               	.LVL647:
2087:switcherator.c ****         clearEEPROM((INPUT + (x * INPUT_BYTES)));
 8114               		.loc 1 2087 0
 8115 2eee 82E4      		ldi r24,lo8(66)
 8116 2ef0 90E0      		ldi r25,0
 8117 2ef2 0E94 0000 		call clearEEPROM
 8118               	.LVL648:
 8119 2ef6 8CE4      		ldi r24,lo8(76)
 8120 2ef8 90E0      		ldi r25,0
 8121 2efa 0E94 0000 		call clearEEPROM
 8122               	.LVL649:
 8123 2efe 86E5      		ldi r24,lo8(86)
 8124 2f00 90E0      		ldi r25,0
 8125 2f02 0E94 0000 		call clearEEPROM
 8126               	.LVL650:
 8127 2f06 80E6      		ldi r24,lo8(96)
 8128 2f08 90E0      		ldi r25,0
 8129 2f0a 0E94 0000 		call clearEEPROM
 8130               	.LVL651:
2089:switcherator.c ****         clearEEPROM((LIMIT + (x * LIMIT_BYTES)));
 8131               		.loc 1 2089 0
 8132 2f0e 8AE6      		ldi r24,lo8(106)
 8133 2f10 90E0      		ldi r25,0
 8134 2f12 0E94 0000 		call clearEEPROM
 8135               	.LVL652:
 8136 2f16 8FE6      		ldi r24,lo8(111)
 8137 2f18 90E0      		ldi r25,0
 8138 2f1a 0E94 0000 		call clearEEPROM
 8139               	.LVL653:
 8140 2f1e 84E7      		ldi r24,lo8(116)
 8141 2f20 90E0      		ldi r25,0
 8142 2f22 0E94 0000 		call clearEEPROM
 8143               	.LVL654:
 8144 2f26 89E7      		ldi r24,lo8(121)
 8145 2f28 90E0      		ldi r25,0
 8146 2f2a 0E94 0000 		call clearEEPROM
 8147               	.LVL655:
2090:switcherator.c ****     clearEEPROM(PWM_VALUE);
 8148               		.loc 1 2090 0
 8149 2f2e 8EE7      		ldi r24,lo8(126)
 8150 2f30 90E0      		ldi r25,0
 8151 2f32 0E94 0000 		call clearEEPROM
 8152               	.LVL656:
2092:switcherator.c ****         clearEEPROM((COLOR_CHANGE + (x * COLOR_CHANGE_BYTES)));
 8153               		.loc 1 2092 0
 8154 2f36 83E8      		ldi r24,lo8(-125)
 8155 2f38 90E0      		ldi r25,0
 8156 2f3a 0E94 0000 		call clearEEPROM
 8157               	.LVL657:
 8158 2f3e 88E8      		ldi r24,lo8(-120)
 8159 2f40 90E0      		ldi r25,0
 8160 2f42 0E94 0000 		call clearEEPROM
 8161               	.LVL658:
 8162 2f46 8DE8      		ldi r24,lo8(-115)
 8163 2f48 90E0      		ldi r25,0
 8164 2f4a 0E94 0000 		call clearEEPROM
 8165               	.LVL659:
 8166 2f4e 82E9      		ldi r24,lo8(-110)
 8167 2f50 90E0      		ldi r25,0
 8168 2f52 0E94 0000 		call clearEEPROM
 8169               	.LVL660:
 8170 2f56 87E9      		ldi r24,lo8(-105)
 8171 2f58 90E0      		ldi r25,0
 8172 2f5a 0E94 0000 		call clearEEPROM
 8173               	.LVL661:
 8174 2f5e 8CE9      		ldi r24,lo8(-100)
 8175 2f60 90E0      		ldi r25,0
 8176 2f62 0E94 0000 		call clearEEPROM
 8177               	.LVL662:
 8178 2f66 C1EA      		ldi r28,lo8(-95)
 8179 2f68 D0E0      		ldi r29,0
 8180               	.LVL663:
 8181               	.L539:
2094:switcherator.c ****         clearEEPROM((WEEKLY_PROGRAM + (x * WEEKLY_PROGRAM_BYTES)));
 8182               		.loc 1 2094 0 discriminator 2
 8183 2f6a CE01      		movw r24,r28
 8184 2f6c 0E94 0000 		call clearEEPROM
 8185               	.LVL664:
 8186 2f70 2C96      		adiw r28,12
2093:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++)
 8187               		.loc 1 2093 0 discriminator 2
 8188 2f72 C931      		cpi r28,25
 8189 2f74 81E0      		ldi r24,1
 8190 2f76 D807      		cpc r29,r24
 8191 2f78 01F4      		brne .L539
2095:switcherator.c ****     clearEEPROM(TWEAK_TIMER);
 8192               		.loc 1 2095 0
 8193 2f7a 89E1      		ldi r24,lo8(25)
 8194 2f7c 91E0      		ldi r25,lo8(1)
 8195 2f7e 0E94 0000 		call clearEEPROM
 8196               	.LVL665:
 8197               	/* epilogue start */
2097:switcherator.c **** }
 8198               		.loc 1 2097 0
 8199 2f82 DF91      		pop r29
 8200 2f84 CF91      		pop r28
2096:switcherator.c ****     ok();
 8201               		.loc 1 2096 0
 8202 2f86 0C94 0000 		jmp ok
 8203               	.LVL666:
 8204               	.LFE46:
 8206               	.global	saveToEEPROM
 8208               	saveToEEPROM:
 8209               	.LFB45:
1938:switcherator.c **** void saveToEEPROM(void) {
 8210               		.loc 1 1938 0
 8211 2f8a BF92      		push r11
 8212               	.LCFI197:
 8213 2f8c CF92      		push r12
 8214               	.LCFI198:
 8215 2f8e DF92      		push r13
 8216               	.LCFI199:
 8217 2f90 EF92      		push r14
 8218               	.LCFI200:
 8219 2f92 FF92      		push r15
 8220               	.LCFI201:
 8221 2f94 0F93      		push r16
 8222               	.LCFI202:
 8223 2f96 1F93      		push r17
 8224               	.LCFI203:
 8225 2f98 CF93      		push r28
 8226               	.LCFI204:
 8227 2f9a DF93      		push r29
 8228               	.LCFI205:
 8229 2f9c CDB7      		in r28,__SP_L__
 8230 2f9e DEB7      		in r29,__SP_H__
 8231               	.LCFI206:
 8232 2fa0 2E97      		sbiw r28,14
 8233               	.LCFI207:
 8234 2fa2 0FB6      		in __tmp_reg__,__SREG__
 8235 2fa4 F894      		cli
 8236 2fa6 DEBF      		out __SP_H__,r29
 8237 2fa8 0FBE      		out __SREG__,__tmp_reg__
 8238 2faa CDBF      		out __SP_L__,r28
 8239               	/* prologue: function */
 8240               	/* frame size = 14 */
 8241               	/* stack size = 23 */
 8242               	.L__stack_usage = 23
 8243               	.LVL667:
1942:switcherator.c ****     if (tx_addr > 0) {
 8244               		.loc 1 1942 0
 8245 2fac B090 0000 		lds r11,tx_addr
 8246 2fb0 C090 0000 		lds r12,tx_addr+1
 8247 2fb4 D090 0000 		lds r13,tx_addr+2
 8248 2fb8 E090 0000 		lds r14,tx_addr+3
 8249 2fbc F090 0000 		lds r15,tx_addr+4
 8250 2fc0 B091 0000 		lds r27,tx_addr+5
 8251 2fc4 F091 0000 		lds r31,tx_addr+6
 8252 2fc8 E091 0000 		lds r30,tx_addr+7
 8253 2fcc 2B2D      		mov r18,r11
 8254 2fce 3C2D      		mov r19,r12
 8255 2fd0 4D2D      		mov r20,r13
 8256 2fd2 5E2D      		mov r21,r14
 8257 2fd4 6F2D      		mov r22,r15
 8258 2fd6 7B2F      		mov r23,r27
 8259 2fd8 8F2F      		mov r24,r31
 8260 2fda 9E2F      		mov r25,r30
 8261 2fdc A0E0      		ldi r26,0
 8262 2fde 0E94 0000 		call __cmpdi2_s8
 8263 2fe2 01F0      		breq .L542
1943:switcherator.c ****         unformatAddress(tx_addr, tempStuff);
 8264               		.loc 1 1943 0
 8265 2fe4 8E01      		movw r16,r28
 8266 2fe6 0F5F      		subi r16,-1
 8267 2fe8 1F4F      		sbci r17,-1
 8268 2fea 0E94 0000 		call unformatAddress
 8269               	.LVL668:
1944:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_TX, RADIO_ADDR_TX_BYTES);
 8270               		.loc 1 1944 0
 8271 2fee 47E0      		ldi r20,lo8(7)
 8272 2ff0 50E0      		ldi r21,0
 8273 2ff2 6EE0      		ldi r22,lo8(14)
 8274 2ff4 70E0      		ldi r23,0
 8275 2ff6 C801      		movw r24,r16
 8276 2ff8 0E94 0000 		call writeEEPROM
 8277               	.LVL669:
 8278               	.L542:
1946:switcherator.c ****     if (rx_addr_p0 > 0) {
 8279               		.loc 1 1946 0
 8280 2ffc B090 0000 		lds r11,rx_addr_p0
 8281 3000 C090 0000 		lds r12,rx_addr_p0+1
 8282 3004 D090 0000 		lds r13,rx_addr_p0+2
 8283 3008 E090 0000 		lds r14,rx_addr_p0+3
 8284 300c F090 0000 		lds r15,rx_addr_p0+4
 8285 3010 B091 0000 		lds r27,rx_addr_p0+5
 8286 3014 F091 0000 		lds r31,rx_addr_p0+6
 8287 3018 E091 0000 		lds r30,rx_addr_p0+7
 8288 301c 2B2D      		mov r18,r11
 8289 301e 3C2D      		mov r19,r12
 8290 3020 4D2D      		mov r20,r13
 8291 3022 5E2D      		mov r21,r14
 8292 3024 6F2D      		mov r22,r15
 8293 3026 7B2F      		mov r23,r27
 8294 3028 8F2F      		mov r24,r31
 8295 302a 9E2F      		mov r25,r30
 8296 302c A0E0      		ldi r26,0
 8297 302e 0E94 0000 		call __cmpdi2_s8
 8298 3032 01F0      		breq .L543
1947:switcherator.c ****         unformatAddress(rx_addr_p0, tempStuff);
 8299               		.loc 1 1947 0
 8300 3034 8E01      		movw r16,r28
 8301 3036 0F5F      		subi r16,-1
 8302 3038 1F4F      		sbci r17,-1
 8303 303a 0E94 0000 		call unformatAddress
 8304               	.LVL670:
1948:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R0, RADIO_ADDR_R0_BYTES);
 8305               		.loc 1 1948 0
 8306 303e 47E0      		ldi r20,lo8(7)
 8307 3040 50E0      		ldi r21,0
 8308 3042 65E1      		ldi r22,lo8(21)
 8309 3044 70E0      		ldi r23,0
 8310 3046 C801      		movw r24,r16
 8311 3048 0E94 0000 		call writeEEPROM
 8312               	.LVL671:
 8313               	.L543:
1950:switcherator.c ****     if (rx_addr_p1 > 0) {
 8314               		.loc 1 1950 0
 8315 304c B090 0000 		lds r11,rx_addr_p1
 8316 3050 C090 0000 		lds r12,rx_addr_p1+1
 8317 3054 D090 0000 		lds r13,rx_addr_p1+2
 8318 3058 E090 0000 		lds r14,rx_addr_p1+3
 8319 305c F090 0000 		lds r15,rx_addr_p1+4
 8320 3060 B091 0000 		lds r27,rx_addr_p1+5
 8321 3064 F091 0000 		lds r31,rx_addr_p1+6
 8322 3068 E091 0000 		lds r30,rx_addr_p1+7
 8323 306c 2B2D      		mov r18,r11
 8324 306e 3C2D      		mov r19,r12
 8325 3070 4D2D      		mov r20,r13
 8326 3072 5E2D      		mov r21,r14
 8327 3074 6F2D      		mov r22,r15
 8328 3076 7B2F      		mov r23,r27
 8329 3078 8F2F      		mov r24,r31
 8330 307a 9E2F      		mov r25,r30
 8331 307c A0E0      		ldi r26,0
 8332 307e 0E94 0000 		call __cmpdi2_s8
 8333 3082 01F0      		breq .L544
1951:switcherator.c ****         unformatAddress(rx_addr_p1, tempStuff);
 8334               		.loc 1 1951 0
 8335 3084 8E01      		movw r16,r28
 8336 3086 0F5F      		subi r16,-1
 8337 3088 1F4F      		sbci r17,-1
 8338 308a 0E94 0000 		call unformatAddress
 8339               	.LVL672:
1952:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R1, RADIO_ADDR_R1_BYTES);
 8340               		.loc 1 1952 0
 8341 308e 47E0      		ldi r20,lo8(7)
 8342 3090 50E0      		ldi r21,0
 8343 3092 6CE1      		ldi r22,lo8(28)
 8344 3094 70E0      		ldi r23,0
 8345 3096 C801      		movw r24,r16
 8346 3098 0E94 0000 		call writeEEPROM
 8347               	.LVL673:
 8348               	.L544:
1954:switcherator.c ****     if (rx_addr_p2 > 0) {
 8349               		.loc 1 1954 0
 8350 309c E091 0000 		lds r30,rx_addr_p2
 8351 30a0 3091 0000 		lds r19,rx_addr_p2+1
 8352 30a4 4091 0000 		lds r20,rx_addr_p2+2
 8353 30a8 5091 0000 		lds r21,rx_addr_p2+3
 8354 30ac 6091 0000 		lds r22,rx_addr_p2+4
 8355 30b0 7091 0000 		lds r23,rx_addr_p2+5
 8356 30b4 2E2F      		mov r18,r30
 8357 30b6 8091 0000 		lds r24,rx_addr_p2+6
 8358 30ba 9091 0000 		lds r25,rx_addr_p2+7
 8359 30be A0E0      		ldi r26,0
 8360 30c0 0E94 0000 		call __cmpdi2_s8
 8361 30c4 01F0      		breq .L545
1955:switcherator.c ****         tempStuff[0] = rx_addr_p2;
 8362               		.loc 1 1955 0
 8363 30c6 E983      		std Y+1,r30
1956:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R2, RADIO_ADDR_R2_BYTES);
 8364               		.loc 1 1956 0
 8365 30c8 43E0      		ldi r20,lo8(3)
 8366 30ca 50E0      		ldi r21,0
 8367 30cc 63E2      		ldi r22,lo8(35)
 8368 30ce 70E0      		ldi r23,0
 8369 30d0 CE01      		movw r24,r28
 8370 30d2 0196      		adiw r24,1
 8371 30d4 0E94 0000 		call writeEEPROM
 8372               	.LVL674:
 8373               	.L545:
1958:switcherator.c ****     if (rx_addr_p3 > 0) {
 8374               		.loc 1 1958 0
 8375 30d8 E091 0000 		lds r30,rx_addr_p3
 8376 30dc 3091 0000 		lds r19,rx_addr_p3+1
 8377 30e0 4091 0000 		lds r20,rx_addr_p3+2
 8378 30e4 5091 0000 		lds r21,rx_addr_p3+3
 8379 30e8 6091 0000 		lds r22,rx_addr_p3+4
 8380 30ec 7091 0000 		lds r23,rx_addr_p3+5
 8381 30f0 2E2F      		mov r18,r30
 8382 30f2 8091 0000 		lds r24,rx_addr_p3+6
 8383 30f6 9091 0000 		lds r25,rx_addr_p3+7
 8384 30fa A0E0      		ldi r26,0
 8385 30fc 0E94 0000 		call __cmpdi2_s8
 8386 3100 01F0      		breq .L546
1959:switcherator.c ****         tempStuff[0] = rx_addr_p3;
 8387               		.loc 1 1959 0
 8388 3102 E983      		std Y+1,r30
1960:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R3, RADIO_ADDR_R3_BYTES);
 8389               		.loc 1 1960 0
 8390 3104 43E0      		ldi r20,lo8(3)
 8391 3106 50E0      		ldi r21,0
 8392 3108 66E2      		ldi r22,lo8(38)
 8393 310a 70E0      		ldi r23,0
 8394 310c CE01      		movw r24,r28
 8395 310e 0196      		adiw r24,1
 8396 3110 0E94 0000 		call writeEEPROM
 8397               	.LVL675:
 8398               	.L546:
1962:switcherator.c ****     if (rx_addr_p4 > 0) {
 8399               		.loc 1 1962 0
 8400 3114 E091 0000 		lds r30,rx_addr_p4
 8401 3118 3091 0000 		lds r19,rx_addr_p4+1
 8402 311c 4091 0000 		lds r20,rx_addr_p4+2
 8403 3120 5091 0000 		lds r21,rx_addr_p4+3
 8404 3124 6091 0000 		lds r22,rx_addr_p4+4
 8405 3128 7091 0000 		lds r23,rx_addr_p4+5
 8406 312c 2E2F      		mov r18,r30
 8407 312e 8091 0000 		lds r24,rx_addr_p4+6
 8408 3132 9091 0000 		lds r25,rx_addr_p4+7
 8409 3136 A0E0      		ldi r26,0
 8410 3138 0E94 0000 		call __cmpdi2_s8
 8411 313c 01F0      		breq .L547
1963:switcherator.c ****         tempStuff[0] = rx_addr_p4;
 8412               		.loc 1 1963 0
 8413 313e E983      		std Y+1,r30
1964:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R4, RADIO_ADDR_R4_BYTES);
 8414               		.loc 1 1964 0
 8415 3140 43E0      		ldi r20,lo8(3)
 8416 3142 50E0      		ldi r21,0
 8417 3144 69E2      		ldi r22,lo8(41)
 8418 3146 70E0      		ldi r23,0
 8419 3148 CE01      		movw r24,r28
 8420 314a 0196      		adiw r24,1
 8421 314c 0E94 0000 		call writeEEPROM
 8422               	.LVL676:
 8423               	.L547:
1966:switcherator.c ****     if (rx_addr_p5 > 0) {
 8424               		.loc 1 1966 0
 8425 3150 E091 0000 		lds r30,rx_addr_p5
 8426 3154 3091 0000 		lds r19,rx_addr_p5+1
 8427 3158 4091 0000 		lds r20,rx_addr_p5+2
 8428 315c 5091 0000 		lds r21,rx_addr_p5+3
 8429 3160 6091 0000 		lds r22,rx_addr_p5+4
 8430 3164 7091 0000 		lds r23,rx_addr_p5+5
 8431 3168 2E2F      		mov r18,r30
 8432 316a 8091 0000 		lds r24,rx_addr_p5+6
 8433 316e 9091 0000 		lds r25,rx_addr_p5+7
 8434 3172 A0E0      		ldi r26,0
 8435 3174 0E94 0000 		call __cmpdi2_s8
 8436 3178 01F0      		breq .L548
1967:switcherator.c ****         tempStuff[0] = rx_addr_p5;
 8437               		.loc 1 1967 0
 8438 317a E983      		std Y+1,r30
1968:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R5, RADIO_ADDR_R5_BYTES);
 8439               		.loc 1 1968 0
 8440 317c 43E0      		ldi r20,lo8(3)
 8441 317e 50E0      		ldi r21,0
 8442 3180 6CE2      		ldi r22,lo8(44)
 8443 3182 70E0      		ldi r23,0
 8444 3184 CE01      		movw r24,r28
 8445 3186 0196      		adiw r24,1
 8446 3188 0E94 0000 		call writeEEPROM
 8447               	.LVL677:
 8448               	.L548:
1971:switcherator.c ****     if (tweakTimer != 0) {
 8449               		.loc 1 1971 0
 8450 318c 8091 0000 		lds r24,tweakTimer
 8451 3190 9091 0000 		lds r25,tweakTimer+1
 8452 3194 A091 0000 		lds r26,tweakTimer+2
 8453 3198 B091 0000 		lds r27,tweakTimer+3
 8454 319c 0097      		sbiw r24,0
 8455 319e A105      		cpc r26,__zero_reg__
 8456 31a0 B105      		cpc r27,__zero_reg__
 8457 31a2 01F0      		breq .L549
1972:switcherator.c ****         tempStuff[0] = tweakTimer >> 8;
 8458               		.loc 1 1972 0
 8459 31a4 9983      		std Y+1,r25
1973:switcherator.c ****         tempStuff[1] = (tweakTimer & 0xff);
 8460               		.loc 1 1973 0
 8461 31a6 8A83      		std Y+2,r24
1974:switcherator.c ****         writeEEPROM(tempStuff, TWEAK_TIMER, TWEAK_TIMER_BYTES);
 8462               		.loc 1 1974 0
 8463 31a8 44E0      		ldi r20,lo8(4)
 8464 31aa 50E0      		ldi r21,0
 8465 31ac 69E1      		ldi r22,lo8(25)
 8466 31ae 71E0      		ldi r23,lo8(1)
 8467 31b0 CE01      		movw r24,r28
 8468 31b2 0196      		adiw r24,1
 8469 31b4 0E94 0000 		call writeEEPROM
 8470               	.LVL678:
 8471               	.L549:
1979:switcherator.c ****     if (daylightSavings[0][0] > 0) {
 8472               		.loc 1 1979 0
 8473 31b8 8091 0000 		lds r24,daylightSavings
 8474 31bc 9091 0000 		lds r25,daylightSavings+1
 8475 31c0 0097      		sbiw r24,0
 8476 31c2 01F0      		breq .L550
1980:switcherator.c ****         tempStuff[0] = (daylightSavings[0][0] >> 8);
 8477               		.loc 1 1980 0
 8478 31c4 9983      		std Y+1,r25
1981:switcherator.c ****         tempStuff[1] = (daylightSavings[0][0] & 0xff);
 8479               		.loc 1 1981 0
 8480 31c6 8A83      		std Y+2,r24
1982:switcherator.c ****         tempStuff[2] = (daylightSavings[0][1] >> 8);
 8481               		.loc 1 1982 0
 8482 31c8 8091 0000 		lds r24,daylightSavings+2
 8483 31cc 9091 0000 		lds r25,daylightSavings+3
 8484 31d0 9B83      		std Y+3,r25
1983:switcherator.c ****         tempStuff[3] = (daylightSavings[0][1] & 0xff);
 8485               		.loc 1 1983 0
 8486 31d2 8C83      		std Y+4,r24
1984:switcherator.c ****         tempStuff[4] = (daylightSavings[1][0] >> 8);
 8487               		.loc 1 1984 0
 8488 31d4 8091 0000 		lds r24,daylightSavings+4
 8489 31d8 9091 0000 		lds r25,daylightSavings+5
 8490 31dc 9D83      		std Y+5,r25
1985:switcherator.c ****         tempStuff[5] = (daylightSavings[1][0] & 0xff);
 8491               		.loc 1 1985 0
 8492 31de 8E83      		std Y+6,r24
1986:switcherator.c ****         tempStuff[6] = (daylightSavings[1][1] >> 8);
 8493               		.loc 1 1986 0
 8494 31e0 8091 0000 		lds r24,daylightSavings+6
 8495 31e4 9091 0000 		lds r25,daylightSavings+7
 8496 31e8 9F83      		std Y+7,r25
1987:switcherator.c ****         tempStuff[7] = (daylightSavings[1][1] & 0xff);
 8497               		.loc 1 1987 0
 8498 31ea 8887      		std Y+8,r24
1988:switcherator.c ****         writeEEPROM(tempStuff, DAYLIGHT_SAVE, DAYLIGHT_SAVE_BYTES);
 8499               		.loc 1 1988 0
 8500 31ec 4AE0      		ldi r20,lo8(10)
 8501 31ee 50E0      		ldi r21,0
 8502 31f0 66E0      		ldi r22,lo8(6)
 8503 31f2 70E0      		ldi r23,0
 8504 31f4 CE01      		movw r24,r28
 8505 31f6 0196      		adiw r24,1
 8506 31f8 0E94 0000 		call writeEEPROM
 8507               	.LVL679:
 8508               	.L550:
1990:switcherator.c ****     if (serial > 0) {
 8509               		.loc 1 1990 0
 8510 31fc 6091 0000 		lds r22,serial
 8511 3200 7091 0000 		lds r23,serial+1
 8512 3204 8091 0000 		lds r24,serial+2
 8513 3208 9091 0000 		lds r25,serial+3
 8514 320c 1616      		cp __zero_reg__,r22
 8515 320e 1706      		cpc __zero_reg__,r23
 8516 3210 1806      		cpc __zero_reg__,r24
 8517 3212 1906      		cpc __zero_reg__,r25
 8518 3214 04F4      		brge .L551
1991:switcherator.c ****         ltoa(serial, tempStuff, 10);
 8519               		.loc 1 1991 0
 8520 3216 2AE0      		ldi r18,lo8(10)
 8521 3218 30E0      		ldi r19,0
 8522 321a AE01      		movw r20,r28
 8523 321c 4F5F      		subi r20,-1
 8524 321e 5F4F      		sbci r21,-1
 8525 3220 0E94 0000 		call ltoa
 8526               	.LVL680:
1992:switcherator.c ****         writeEEPROM(tempStuff, SERIAL_NUM, SERIAL_NUM_BYTES);
 8527               		.loc 1 1992 0
 8528 3224 48E0      		ldi r20,lo8(8)
 8529 3226 50E0      		ldi r21,0
 8530 3228 60E0      		ldi r22,0
 8531 322a 70E0      		ldi r23,0
 8532 322c CE01      		movw r24,r28
 8533 322e 0196      		adiw r24,1
 8534 3230 0E94 0000 		call writeEEPROM
 8535               	.LVL681:
 8536               	.L551:
 8537 3234 E0E0      		ldi r30,lo8(switchStuff)
 8538 3236 F0E0      		ldi r31,hi8(switchStuff)
1995:switcherator.c ****     char setupPWM = 0;
 8539               		.loc 1 1995 0
 8540 3238 10E0      		ldi r17,0
1994:switcherator.c ****     char setupaSwitch = 0;
 8541               		.loc 1 1994 0
 8542 323a 80E0      		ldi r24,0
 8543               	.LVL682:
 8544               	.L554:
1998:switcherator.c ****         if (switchStuff[x] < 255)
 8545               		.loc 1 1998 0
 8546 323c 9191      		ld r25,Z+
 8547 323e 9F3F      		cpi r25,lo8(-1)
 8548 3240 01F0      		breq .L552
1999:switcherator.c ****             setupaSwitch = 1;
 8549               		.loc 1 1999 0
 8550 3242 81E0      		ldi r24,lo8(1)
 8551               	.L552:
 8552               	.LVL683:
2000:switcherator.c ****         if (switchStuff[x] >= 200 && switchStuff[x] <= 230)
 8553               		.loc 1 2000 0
 8554 3244 985C      		subi r25,lo8(-(56))
 8555 3246 9F31      		cpi r25,lo8(31)
 8556 3248 00F4      		brsh .L553
2001:switcherator.c ****             setupPWM = 1;
 8557               		.loc 1 2001 0
 8558 324a 11E0      		ldi r17,lo8(1)
 8559               	.L553:
 8560               	.LVL684:
1997:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 8561               		.loc 1 1997 0
 8562 324c 90E0      		ldi r25,hi8(switchStuff+16)
 8563 324e E030      		cpi r30,lo8(switchStuff+16)
 8564 3250 F907      		cpc r31,r25
 8565 3252 01F4      		brne .L554
2003:switcherator.c ****     if (setupaSwitch == 1) {
 8566               		.loc 1 2003 0
 8567 3254 8130      		cpi r24,lo8(1)
 8568 3256 01F4      		brne .L555
2004:switcherator.c ****         writeEEPROM(switchStuff, SWITCH_STUFF, SWITCH_STUFF_BYTES);
 8569               		.loc 1 2004 0
 8570 3258 42E1      		ldi r20,lo8(18)
 8571 325a 50E0      		ldi r21,0
 8572 325c 60E3      		ldi r22,lo8(48)
 8573 325e 70E0      		ldi r23,0
 8574 3260 80E0      		ldi r24,lo8(switchStuff)
 8575 3262 90E0      		ldi r25,hi8(switchStuff)
 8576               	.LVL685:
 8577 3264 0E94 0000 		call writeEEPROM
 8578               	.LVL686:
2005:switcherator.c ****         writeEEPROM(switchBright, BRIGHTNESS, BRIGHTNESS_BYTES);
 8579               		.loc 1 2005 0
 8580 3268 42E1      		ldi r20,lo8(18)
 8581 326a 50E0      		ldi r21,0
 8582 326c 60E2      		ldi r22,lo8(32)
 8583 326e 71E0      		ldi r23,lo8(1)
 8584 3270 80E0      		ldi r24,lo8(switchBright)
 8585 3272 90E0      		ldi r25,hi8(switchBright)
 8586 3274 0E94 0000 		call writeEEPROM
 8587               	.LVL687:
 8588               	.L555:
2007:switcherator.c ****     tempStuff[0] = pwmdir;
 8589               		.loc 1 2007 0
 8590 3278 8091 0000 		lds r24,pwmdir
 8591 327c 8983      		std Y+1,r24
2008:switcherator.c ****     if (setupPWM == 1)
 8592               		.loc 1 2008 0
 8593 327e 1130      		cpi r17,lo8(1)
 8594 3280 01F4      		brne .L556
2009:switcherator.c ****         writeEEPROM(tempStuff, PWM_DIR, PWM_DIR_BYTES);
 8595               		.loc 1 2009 0
 8596 3282 43E0      		ldi r20,lo8(3)
 8597 3284 50E0      		ldi r21,0
 8598 3286 6DE1      		ldi r22,lo8(29)
 8599 3288 71E0      		ldi r23,lo8(1)
 8600 328a CE01      		movw r24,r28
 8601 328c 0196      		adiw r24,1
 8602 328e 0E94 0000 		call writeEEPROM
 8603               	.LVL688:
 8604               	.L556:
 8605 3292 20E0      		ldi r18,lo8(weeklyProgram)
 8606 3294 E22E      		mov r14,r18
 8607 3296 20E0      		ldi r18,hi8(weeklyProgram)
 8608 3298 F22E      		mov r15,r18
 8609 329a 30E0      		ldi r19,lo8(weeklyProgram+1)
 8610 329c C32E      		mov r12,r19
 8611 329e 30E0      		ldi r19,hi8(weeklyProgram+1)
 8612 32a0 D32E      		mov r13,r19
2001:switcherator.c ****             setupPWM = 1;
 8613               		.loc 1 2001 0 discriminator 1
 8614 32a2 01EA      		ldi r16,lo8(-95)
 8615 32a4 10E0      		ldi r17,0
 8616               	.LVL689:
 8617               	.L560:
2019:switcherator.c ****         memoryMarker = (WEEKLY_PROGRAM + (x * WEEKLY_PROGRAM_BYTES));
 8618               		.loc 1 2019 0
 8619 32a6 B801      		movw r22,r16
 8620               	.LVL690:
2020:switcherator.c ****         if (weeklyProgram[x][0] != 255 || weeklyProgram[x][1] != 255) {
 8621               		.loc 1 2020 0
 8622 32a8 F701      		movw r30,r14
 8623 32aa 8081      		ld r24,Z
 8624 32ac 8F3F      		cpi r24,lo8(-1)
 8625 32ae 01F4      		brne .L557
2020:switcherator.c ****         if (weeklyProgram[x][0] != 255 || weeklyProgram[x][1] != 255) {
 8626               		.loc 1 2020 0 is_stmt 0 discriminator 1
 8627 32b0 F601      		movw r30,r12
 8628 32b2 8081      		ld r24,Z
 8629 32b4 8F3F      		cpi r24,lo8(-1)
 8630 32b6 01F0      		breq .L558
 8631               	.L557:
 8632 32b8 FE01      		movw r30,r28
 8633 32ba 3196      		adiw r30,1
2001:switcherator.c ****             setupPWM = 1;
 8634               		.loc 1 2001 0 is_stmt 1 discriminator 2
 8635 32bc 80E0      		ldi r24,0
 8636 32be 90E0      		ldi r25,0
 8637               	.L559:
1938:switcherator.c **** void saveToEEPROM(void) {
 8638               		.loc 1 1938 0 discriminator 2
 8639 32c0 D701      		movw r26,r14
 8640 32c2 A80F      		add r26,r24
 8641 32c4 B91F      		adc r27,r25
2022:switcherator.c ****                 tempStuff[y] = weeklyProgram[x][y];
 8642               		.loc 1 2022 0 discriminator 2
 8643 32c6 2C91      		ld r18,X
 8644 32c8 2193      		st Z+,r18
2021:switcherator.c ****             for (y = 0; y < 10; y++)
 8645               		.loc 1 2021 0 discriminator 2
 8646 32ca 0196      		adiw r24,1
 8647               	.LVL691:
 8648 32cc 8A30      		cpi r24,10
 8649 32ce 9105      		cpc r25,__zero_reg__
 8650 32d0 01F4      		brne .L559
2023:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, WEEKLY_PROGRAM_BYTES);
 8651               		.loc 1 2023 0
 8652 32d2 4CE0      		ldi r20,lo8(12)
 8653 32d4 50E0      		ldi r21,0
 8654 32d6 CE01      		movw r24,r28
 8655               	.LVL692:
 8656 32d8 0196      		adiw r24,1
 8657 32da 0E94 0000 		call writeEEPROM
 8658               	.LVL693:
 8659               	.L558:
 8660 32de FAE0      		ldi r31,10
 8661 32e0 EF0E      		add r14,r31
 8662 32e2 F11C      		adc r15,__zero_reg__
 8663 32e4 8AE0      		ldi r24,10
 8664 32e6 C80E      		add r12,r24
 8665 32e8 D11C      		adc r13,__zero_reg__
 8666 32ea 045F      		subi r16,-12
 8667 32ec 1F4F      		sbci r17,-1
2018:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 8668               		.loc 1 2018 0
 8669 32ee 0931      		cpi r16,25
 8670 32f0 91E0      		ldi r25,1
 8671 32f2 1907      		cpc r17,r25
 8672 32f4 01F4      		brne .L560
 8673 32f6 90E0      		ldi r25,lo8(inputs)
 8674 32f8 E92E      		mov r14,r25
 8675 32fa 90E0      		ldi r25,hi8(inputs)
 8676 32fc F92E      		mov r15,r25
 8677 32fe 02E4      		ldi r16,lo8(66)
 8678 3300 10E0      		ldi r17,0
 8679               	.L563:
2030:switcherator.c ****         if (inputs[x][0] != 255) {
 8680               		.loc 1 2030 0
 8681 3302 F701      		movw r30,r14
 8682 3304 8081      		ld r24,Z
 8683 3306 8F3F      		cpi r24,lo8(-1)
 8684 3308 01F0      		breq .L561
 8685 330a FE01      		movw r30,r28
 8686 330c 3196      		adiw r30,1
 8687 330e 80E0      		ldi r24,0
 8688 3310 90E0      		ldi r25,0
 8689               	.L562:
1938:switcherator.c **** void saveToEEPROM(void) {
 8690               		.loc 1 1938 0 discriminator 2
 8691 3312 D701      		movw r26,r14
 8692 3314 A80F      		add r26,r24
 8693 3316 B91F      		adc r27,r25
2032:switcherator.c ****                 tempStuff[y] = inputs[x][y];
 8694               		.loc 1 2032 0 discriminator 2
 8695 3318 2C91      		ld r18,X
 8696 331a 2193      		st Z+,r18
2031:switcherator.c ****             for (y = 0; y < 8; y++) {
 8697               		.loc 1 2031 0 discriminator 2
 8698 331c 0196      		adiw r24,1
 8699               	.LVL694:
 8700 331e 8830      		cpi r24,8
 8701 3320 9105      		cpc r25,__zero_reg__
 8702 3322 01F4      		brne .L562
2034:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, INPUT_BYTES);
 8703               		.loc 1 2034 0
 8704 3324 4AE0      		ldi r20,lo8(10)
 8705 3326 50E0      		ldi r21,0
 8706 3328 B801      		movw r22,r16
 8707 332a CE01      		movw r24,r28
 8708               	.LVL695:
 8709 332c 0196      		adiw r24,1
 8710 332e 0E94 0000 		call writeEEPROM
 8711               	.LVL696:
 8712               	.L561:
 8713 3332 F8E0      		ldi r31,8
 8714 3334 EF0E      		add r14,r31
 8715 3336 F11C      		adc r15,__zero_reg__
 8716 3338 065F      		subi r16,-10
 8717 333a 1F4F      		sbci r17,-1
2028:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 8718               		.loc 1 2028 0
 8719 333c 0A36      		cpi r16,106
 8720 333e 1105      		cpc r17,__zero_reg__
 8721 3340 01F4      		brne .L563
 8722 3342 00E0      		ldi r16,lo8(timeLimits)
 8723 3344 10E0      		ldi r17,hi8(timeLimits)
 8724 3346 8AE6      		ldi r24,lo8(106)
 8725 3348 E82E      		mov r14,r24
 8726 334a F12C      		mov r15,__zero_reg__
 8727               	.L565:
2041:switcherator.c ****         if (timeLimits[x][2] > 0) {
 8728               		.loc 1 2041 0
 8729 334c F801      		movw r30,r16
 8730 334e 8085      		ldd r24,Z+8
 8731 3350 9185      		ldd r25,Z+9
 8732 3352 A285      		ldd r26,Z+10
 8733 3354 B385      		ldd r27,Z+11
 8734 3356 0097      		sbiw r24,0
 8735 3358 A105      		cpc r26,__zero_reg__
 8736 335a B105      		cpc r27,__zero_reg__
 8737 335c 01F0      		breq .L564
 8738               	.LVL697:
2043:switcherator.c ****                 tempStuff[y] = timeLimits[x][y];
 8739               		.loc 1 2043 0 discriminator 1
 8740 335e 2081      		ld r18,Z
 8741 3360 2983      		std Y+1,r18
 8742               	.LVL698:
 8743 3362 2481      		ldd r18,Z+4
 8744 3364 2A83      		std Y+2,r18
 8745               	.LVL699:
 8746 3366 8B83      		std Y+3,r24
 8747               	.LVL700:
2045:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, INPUT_BYTES);
 8748               		.loc 1 2045 0 discriminator 1
 8749 3368 4AE0      		ldi r20,lo8(10)
 8750 336a 50E0      		ldi r21,0
 8751 336c B701      		movw r22,r14
 8752 336e CE01      		movw r24,r28
 8753 3370 0196      		adiw r24,1
 8754 3372 0E94 0000 		call writeEEPROM
 8755               	.LVL701:
 8756               	.L564:
 8757 3376 045F      		subi r16,-12
 8758 3378 1F4F      		sbci r17,-1
 8759 337a F5E0      		ldi r31,5
 8760 337c EF0E      		add r14,r31
 8761 337e F11C      		adc r15,__zero_reg__
2039:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++) {
 8762               		.loc 1 2039 0
 8763 3380 8EE7      		ldi r24,126
 8764 3382 E816      		cp r14,r24
 8765 3384 F104      		cpc r15,__zero_reg__
 8766 3386 01F4      		brne .L565
 8767               	.LVL702:
2052:switcherator.c ****     if (pwmValues[0] != 0 || pwmValues[1] != 0 || pwmValues[2] != 0) {
 8768               		.loc 1 2052 0
 8769 3388 8091 0000 		lds r24,pwmValues
 8770 338c 8111      		cpse r24,__zero_reg__
 8771 338e 00C0      		rjmp .L566
2052:switcherator.c ****     if (pwmValues[0] != 0 || pwmValues[1] != 0 || pwmValues[2] != 0) {
 8772               		.loc 1 2052 0 is_stmt 0 discriminator 1
 8773 3390 9091 0000 		lds r25,pwmValues+1
 8774 3394 9923      		tst r25
 8775 3396 01F0      		breq .L567
 8776               	.L566:
 8777               	.LVL703:
2054:switcherator.c ****             tempStuff[y] = pwmValues[y];
 8778               		.loc 1 2054 0 is_stmt 1 discriminator 1
 8779 3398 8983      		std Y+1,r24
 8780               	.LVL704:
 8781 339a 8091 0000 		lds r24,pwmValues+1
 8782 339e 8A83      		std Y+2,r24
 8783               	.LVL705:
 8784 33a0 8091 0000 		lds r24,pwmValues+2
 8785 33a4 8B83      		std Y+3,r24
 8786               	.LVL706:
2056:switcherator.c ****         writeEEPROM(tempStuff, memoryMarker, PWM_VALUE_BYTES);
 8787               		.loc 1 2056 0 discriminator 1
 8788 33a6 45E0      		ldi r20,lo8(5)
 8789 33a8 50E0      		ldi r21,0
 8790 33aa 6EE7      		ldi r22,lo8(126)
 8791 33ac 70E0      		ldi r23,0
 8792 33ae CE01      		movw r24,r28
 8793 33b0 0196      		adiw r24,1
 8794 33b2 0E94 0000 		call writeEEPROM
 8795               	.LVL707:
 8796               	.L569:
 8797 33b6 B0E0      		ldi r27,lo8(inputs+2)
 8798 33b8 EB2E      		mov r14,r27
 8799 33ba B0E0      		ldi r27,hi8(inputs+2)
 8800 33bc FB2E      		mov r15,r27
2028:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 8801               		.loc 1 2028 0 discriminator 1
 8802 33be 03E8      		ldi r16,lo8(-125)
 8803 33c0 10E0      		ldi r17,0
 8804 33c2 00C0      		rjmp .L568
 8805               	.LVL708:
 8806               	.L567:
2052:switcherator.c ****     if (pwmValues[0] != 0 || pwmValues[1] != 0 || pwmValues[2] != 0) {
 8807               		.loc 1 2052 0 discriminator 1
 8808 33c4 9091 0000 		lds r25,pwmValues+2
 8809 33c8 9111      		cpse r25,__zero_reg__
 8810 33ca 00C0      		rjmp .L566
 8811 33cc 00C0      		rjmp .L569
 8812               	.LVL709:
 8813               	.L568:
2061:switcherator.c ****         memoryMarker = (COLOR_CHANGE + (x * COLOR_CHANGE_BYTES));
 8814               		.loc 1 2061 0
 8815 33ce B801      		movw r22,r16
 8816               	.LVL710:
2062:switcherator.c ****         if (colorChanges[0][0] != 0 || colorChanges[0][1] != 1 || colorChanges[0][2] != 0) {
 8817               		.loc 1 2062 0
 8818 33d0 8091 0000 		lds r24,colorChanges
 8819 33d4 8111      		cpse r24,__zero_reg__
 8820 33d6 00C0      		rjmp .L570
2062:switcherator.c ****         if (colorChanges[0][0] != 0 || colorChanges[0][1] != 1 || colorChanges[0][2] != 0) {
 8821               		.loc 1 2062 0 is_stmt 0 discriminator 1
 8822 33d8 8091 0000 		lds r24,colorChanges+1
 8823 33dc 8130      		cpi r24,lo8(1)
 8824 33de 01F0      		breq .L571
 8825               	.L570:
 8826               	.LVL711:
1938:switcherator.c **** void saveToEEPROM(void) {
 8827               		.loc 1 1938 0 is_stmt 1 discriminator 1
 8828 33e0 F701      		movw r30,r14
 8829 33e2 3297      		sbiw r30,2
2064:switcherator.c ****                 tempStuff[y] = inputs[x][y];
 8830               		.loc 1 2064 0 discriminator 1
 8831 33e4 8081      		ld r24,Z
 8832 33e6 8983      		std Y+1,r24
 8833               	.LVL712:
1938:switcherator.c **** void saveToEEPROM(void) {
 8834               		.loc 1 1938 0 discriminator 1
 8835 33e8 F701      		movw r30,r14
 8836 33ea 3197      		sbiw r30,1
2064:switcherator.c ****                 tempStuff[y] = inputs[x][y];
 8837               		.loc 1 2064 0 discriminator 1
 8838 33ec 8081      		ld r24,Z
 8839 33ee 8A83      		std Y+2,r24
 8840               	.LVL713:
 8841 33f0 F701      		movw r30,r14
 8842 33f2 8081      		ld r24,Z
 8843 33f4 8B83      		std Y+3,r24
 8844               	.LVL714:
2066:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, COLOR_CHANGE_BYTES);
 8845               		.loc 1 2066 0 discriminator 1
 8846 33f6 45E0      		ldi r20,lo8(5)
 8847 33f8 50E0      		ldi r21,0
 8848 33fa CE01      		movw r24,r28
 8849 33fc 0196      		adiw r24,1
 8850 33fe 0E94 0000 		call writeEEPROM
 8851               	.LVL715:
 8852 3402 00C0      		rjmp .L572
 8853               	.LVL716:
 8854               	.L571:
2062:switcherator.c ****         if (colorChanges[0][0] != 0 || colorChanges[0][1] != 1 || colorChanges[0][2] != 0) {
 8855               		.loc 1 2062 0 discriminator 1
 8856 3404 8091 0000 		lds r24,colorChanges+2
 8857 3408 8111      		cpse r24,__zero_reg__
 8858 340a 00C0      		rjmp .L570
 8859               	.LVL717:
 8860               	.L572:
 8861 340c F8E0      		ldi r31,8
 8862 340e EF0E      		add r14,r31
 8863 3410 F11C      		adc r15,__zero_reg__
 8864 3412 0B5F      		subi r16,-5
 8865 3414 1F4F      		sbci r17,-1
2060:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 8866               		.loc 1 2060 0
 8867 3416 013A      		cpi r16,-95
 8868 3418 1105      		cpc r17,__zero_reg__
 8869 341a 01F4      		brne .L568
2069:switcherator.c ****     ok();
 8870               		.loc 1 2069 0
 8871 341c 0E94 0000 		call ok
 8872               	.LVL718:
 8873               	/* epilogue start */
2070:switcherator.c **** }
 8874               		.loc 1 2070 0
 8875 3420 2E96      		adiw r28,14
 8876 3422 0FB6      		in __tmp_reg__,__SREG__
 8877 3424 F894      		cli
 8878 3426 DEBF      		out __SP_H__,r29
 8879 3428 0FBE      		out __SREG__,__tmp_reg__
 8880 342a CDBF      		out __SP_L__,r28
 8881 342c DF91      		pop r29
 8882 342e CF91      		pop r28
 8883 3430 1F91      		pop r17
 8884               	.LVL719:
 8885 3432 0F91      		pop r16
 8886 3434 FF90      		pop r15
 8887 3436 EF90      		pop r14
 8888 3438 DF90      		pop r13
 8889 343a CF90      		pop r12
 8890 343c BF90      		pop r11
 8891 343e 0895      		ret
 8892               	.LFE45:
 8894               	.global	pwmValueSet
 8896               	pwmValueSet:
 8897               	.LFB24:
 952:switcherator.c **** void pwmValueSet(char * commandReceived) {
 8898               		.loc 1 952 0
 8899               	.LVL720:
 8900 3440 CF92      		push r12
 8901               	.LCFI208:
 8902 3442 DF92      		push r13
 8903               	.LCFI209:
 8904 3444 EF92      		push r14
 8905               	.LCFI210:
 8906 3446 FF92      		push r15
 8907               	.LCFI211:
 8908 3448 0F93      		push r16
 8909               	.LCFI212:
 8910 344a 1F93      		push r17
 8911               	.LCFI213:
 8912 344c CF93      		push r28
 8913               	.LCFI214:
 8914 344e DF93      		push r29
 8915               	.LCFI215:
 8916               	/* prologue: function */
 8917               	/* frame size = 0 */
 8918               	/* stack size = 8 */
 8919               	.L__stack_usage = 8
 8920 3450 EC01      		movw r28,r24
 953:switcherator.c ****     tempLongString[3] = 0;
 8921               		.loc 1 953 0
 8922 3452 1092 0000 		sts tempLongString+3,__zero_reg__
 954:switcherator.c ****     tempLongString[0] = commandReceived[6];
 8923               		.loc 1 954 0
 8924 3456 40E0      		ldi r20,lo8(tempLongString)
 8925 3458 C42E      		mov r12,r20
 8926 345a 40E0      		ldi r20,hi8(tempLongString)
 8927 345c D42E      		mov r13,r20
 8928 345e 8E81      		ldd r24,Y+6
 8929               	.LVL721:
 8930 3460 F601      		movw r30,r12
 8931 3462 8083      		st Z,r24
 955:switcherator.c ****     tempLongString[1] = commandReceived[7];
 8932               		.loc 1 955 0
 8933 3464 50E0      		ldi r21,lo8(tempLongString+1)
 8934 3466 E52E      		mov r14,r21
 8935 3468 50E0      		ldi r21,hi8(tempLongString+1)
 8936 346a F52E      		mov r15,r21
 8937 346c 8F81      		ldd r24,Y+7
 8938 346e F701      		movw r30,r14
 8939 3470 8083      		st Z,r24
 956:switcherator.c ****     tempLongString[2] = commandReceived[8];
 8940               		.loc 1 956 0
 8941 3472 00E0      		ldi r16,lo8(tempLongString+2)
 8942 3474 10E0      		ldi r17,hi8(tempLongString+2)
 8943 3476 8885      		ldd r24,Y+8
 8944 3478 F801      		movw r30,r16
 8945 347a 8083      		st Z,r24
 957:switcherator.c ****     pwmValues[0] = atoi(tempLongString);
 8946               		.loc 1 957 0
 8947 347c C601      		movw r24,r12
 8948 347e 0E94 0000 		call atoi
 8949               	.LVL722:
 8950 3482 8093 0000 		sts pwmValues,r24
 958:switcherator.c ****     tempLongString[0] = commandReceived[10];
 8951               		.loc 1 958 0
 8952 3486 8A85      		ldd r24,Y+10
 8953 3488 F601      		movw r30,r12
 8954 348a 8083      		st Z,r24
 959:switcherator.c ****     tempLongString[1] = commandReceived[11];
 8955               		.loc 1 959 0
 8956 348c 8B85      		ldd r24,Y+11
 8957 348e F701      		movw r30,r14
 8958 3490 8083      		st Z,r24
 960:switcherator.c ****     tempLongString[2] = commandReceived[12];
 8959               		.loc 1 960 0
 8960 3492 8C85      		ldd r24,Y+12
 8961 3494 F801      		movw r30,r16
 8962 3496 8083      		st Z,r24
 961:switcherator.c ****     pwmValues[1] = atoi(tempLongString);
 8963               		.loc 1 961 0
 8964 3498 C601      		movw r24,r12
 8965 349a 0E94 0000 		call atoi
 8966               	.LVL723:
 8967 349e 8093 0000 		sts pwmValues+1,r24
 962:switcherator.c ****     tempLongString[0] = commandReceived[14];
 8968               		.loc 1 962 0
 8969 34a2 8E85      		ldd r24,Y+14
 8970 34a4 F601      		movw r30,r12
 8971 34a6 8083      		st Z,r24
 963:switcherator.c ****     tempLongString[1] = commandReceived[15];
 8972               		.loc 1 963 0
 8973 34a8 8F85      		ldd r24,Y+15
 8974 34aa F701      		movw r30,r14
 8975 34ac 8083      		st Z,r24
 964:switcherator.c ****     tempLongString[2] = commandReceived[16];
 8976               		.loc 1 964 0
 8977 34ae 8889      		ldd r24,Y+16
 8978 34b0 F801      		movw r30,r16
 8979 34b2 8083      		st Z,r24
 965:switcherator.c ****     pwmValues[2] = atoi(tempLongString);
 8980               		.loc 1 965 0
 8981 34b4 C601      		movw r24,r12
 8982 34b6 0E94 0000 		call atoi
 8983               	.LVL724:
 8984 34ba 8093 0000 		sts pwmValues+2,r24
 966:switcherator.c ****     statusMsg[0] = 0;
 8985               		.loc 1 966 0
 8986 34be 1092 0000 		sts statusMsg,__zero_reg__
 8987               	/* epilogue start */
 968:switcherator.c **** }
 8988               		.loc 1 968 0
 8989 34c2 DF91      		pop r29
 8990 34c4 CF91      		pop r28
 8991               	.LVL725:
 8992 34c6 1F91      		pop r17
 8993 34c8 0F91      		pop r16
 8994 34ca FF90      		pop r15
 8995 34cc EF90      		pop r14
 8996 34ce DF90      		pop r13
 8997 34d0 CF90      		pop r12
 967:switcherator.c ****     ok();
 8998               		.loc 1 967 0
 8999 34d2 0C94 0000 		jmp ok
 9000               	.LVL726:
 9001               	.LFE24:
 9003               	.global	setHueSpeed
 9005               	setHueSpeed:
 9006               	.LFB23:
 937:switcherator.c **** void setHueSpeed(char * commandReceived) {
 9007               		.loc 1 937 0
 9008               	.LVL727:
 9009               	/* prologue: function */
 9010               	/* frame size = 0 */
 9011               	/* stack size = 0 */
 9012               	.L__stack_usage = 0
 938:switcherator.c ****     tempIntString[0] = commandReceived[3];
 9013               		.loc 1 938 0
 9014 34d6 FC01      		movw r30,r24
 9015 34d8 2381      		ldd r18,Z+3
 9016 34da 2093 0000 		sts tempIntString,r18
 939:switcherator.c ****     tempIntString[1] = commandReceived[4];
 9017               		.loc 1 939 0
 9018 34de 8481      		ldd r24,Z+4
 9019               	.LVL728:
 9020 34e0 8093 0000 		sts tempIntString+1,r24
 9021               	.LVL729:
 941:switcherator.c ****     programNumber = atoi(tempIntString);
 9022               		.loc 1 941 0
 9023 34e4 80E0      		ldi r24,lo8(tempIntString)
 9024 34e6 90E0      		ldi r25,hi8(tempIntString)
 9025 34e8 0E94 0000 		call atoi
 9026               	.LVL730:
 942:switcherator.c ****     if (programNumber > 0)
 9027               		.loc 1 942 0
 9028 34ec 1816      		cp __zero_reg__,r24
 9029 34ee 1906      		cpc __zero_reg__,r25
 9030 34f0 04F4      		brge .L599
 943:switcherator.c ****         hueSpeed = programNumber;
 9031               		.loc 1 943 0
 9032 34f2 9093 0000 		sts hueSpeed+1,r25
 9033 34f6 8093 0000 		sts hueSpeed,r24
 9034               	.L599:
 944:switcherator.c ****     ok();
 9035               		.loc 1 944 0
 9036 34fa 0C94 0000 		jmp ok
 9037               	.LVL731:
 9038               	.LFE23:
 9040               	.global	cycleHue
 9042               	cycleHue:
 9043               	.LFB22:
 921:switcherator.c **** void cycleHue(char * commandReceived) {
 9044               		.loc 1 921 0
 9045               	.LVL732:
 9046               	/* prologue: function */
 9047               	/* frame size = 0 */
 9048               	/* stack size = 0 */
 9049               	.L__stack_usage = 0
 9050 34fe FC01      		movw r30,r24
 923:switcherator.c ****     tempLongString[0] = commandReceived[5];
 9051               		.loc 1 923 0
 9052 3500 8581      		ldd r24,Z+5
 9053               	.LVL733:
 9054 3502 8093 0000 		sts tempLongString,r24
 924:switcherator.c ****     tempLongString[1] = commandReceived[6];
 9055               		.loc 1 924 0
 9056 3506 8681      		ldd r24,Z+6
 9057 3508 8093 0000 		sts tempLongString+1,r24
 925:switcherator.c ****     tempLongString[2] = commandReceived[7];
 9058               		.loc 1 925 0
 9059 350c 8781      		ldd r24,Z+7
 9060 350e 8093 0000 		sts tempLongString+2,r24
 926:switcherator.c ****     tempLongString[3] = commandReceived[8];
 9061               		.loc 1 926 0
 9062 3512 8085      		ldd r24,Z+8
 9063 3514 8093 0000 		sts tempLongString+3,r24
 9064               	.LVL734:
 928:switcherator.c ****     programNumber = atoi(tempLongString);
 9065               		.loc 1 928 0
 9066 3518 80E0      		ldi r24,lo8(tempLongString)
 9067 351a 90E0      		ldi r25,hi8(tempLongString)
 9068 351c 0E94 0000 		call atoi
 9069               	.LVL735:
 929:switcherator.c ****     if (programNumber > 0)
 9070               		.loc 1 929 0
 9071 3520 1816      		cp __zero_reg__,r24
 9072 3522 1906      		cpc __zero_reg__,r25
 9073 3524 04F4      		brge .L601
 930:switcherator.c ****         colorChangeSpeed = programNumber;
 9074               		.loc 1 930 0
 9075 3526 9093 0000 		sts colorChangeSpeed+1,r25
 9076 352a 8093 0000 		sts colorChangeSpeed,r24
 9077               	.L601:
 931:switcherator.c ****     ok();
 9078               		.loc 1 931 0
 9079 352e 0C94 0000 		jmp ok
 9080               	.LVL736:
 9081               	.LFE22:
 9083               	.global	switchClear
 9085               	switchClear:
 9086               	.LFB14:
 544:switcherator.c **** void switchClear(char * commandReceived) {
 9087               		.loc 1 544 0
 9088               	.LVL737:
 9089               	/* prologue: function */
 9090               	/* frame size = 0 */
 9091               	/* stack size = 0 */
 9092               	.L__stack_usage = 0
 547:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 9093               		.loc 1 547 0
 9094 3532 0E94 0000 		call getSwitchNumber
 9095               	.LVL738:
 548:switcherator.c ****     clearTheSwitch(switchNumber);
 9096               		.loc 1 548 0
 9097 3536 0E94 0000 		call clearTheSwitch
 9098               	.LVL739:
 549:switcherator.c ****     ok();
 9099               		.loc 1 549 0
 9100 353a 0C94 0000 		jmp ok
 9101               	.LVL740:
 9102               	.LFE14:
 9104               		.section	.rodata.str1.1
 9105               	.LC65:
 9106 0137 4375 7272 		.string	"Curr Tweak:"
 9106      2054 7765 
 9106      616B 3A00 
 9107               		.text
 9108               	.global	clockTweak
 9110               	clockTweak:
 9111               	.LFB60:
2615:switcherator.c **** void clockTweak(char * commandReceived) {
 9112               		.loc 1 2615 0
 9113               	.LVL741:
 9114               	/* prologue: function */
 9115               	/* frame size = 0 */
 9116               	/* stack size = 0 */
 9117               	.L__stack_usage = 0
 9118 353e FC01      		movw r30,r24
 9119               	.LVL742:
2618:switcherator.c ****         tempLongString[x] = commandReceived[(x + 3)];
 9120               		.loc 1 2618 0
 9121 3540 8381      		ldd r24,Z+3
 9122               	.LVL743:
 9123 3542 8093 0000 		sts tempLongString,r24
 9124               	.LVL744:
 9125 3546 8481      		ldd r24,Z+4
 9126 3548 8093 0000 		sts tempLongString+1,r24
 9127               	.LVL745:
 9128 354c 8581      		ldd r24,Z+5
 9129 354e 8093 0000 		sts tempLongString+2,r24
 9130               	.LVL746:
 9131 3552 8681      		ldd r24,Z+6
 9132 3554 8093 0000 		sts tempLongString+3,r24
 9133               	.LVL747:
2620:switcherator.c ****     int adjustment = atoi(tempLongString);
 9134               		.loc 1 2620 0
 9135 3558 80E0      		ldi r24,lo8(tempLongString)
 9136 355a 90E0      		ldi r25,hi8(tempLongString)
 9137 355c 0E94 0000 		call atoi
 9138               	.LVL748:
2621:switcherator.c ****     if (adjustment == 0) {
 9139               		.loc 1 2621 0
 9140 3560 0097      		sbiw r24,0
 9141 3562 01F4      		brne .L604
2622:switcherator.c ****         itoa(tweakTimer, tempLongString, 10);
 9142               		.loc 1 2622 0
 9143 3564 4AE0      		ldi r20,lo8(10)
 9144 3566 50E0      		ldi r21,0
 9145 3568 60E0      		ldi r22,lo8(tempLongString)
 9146 356a 70E0      		ldi r23,hi8(tempLongString)
 9147 356c 8091 0000 		lds r24,tweakTimer
 9148 3570 9091 0000 		lds r25,tweakTimer+1
 9149               	.LVL749:
 9150 3574 0E94 0000 		call itoa
 9151               	.LVL750:
2623:switcherator.c ****         statusMsg[0] = 0;
 9152               		.loc 1 2623 0
 9153 3578 1092 0000 		sts statusMsg,__zero_reg__
2624:switcherator.c ****         strcat(statusMsg, "Curr Tweak:");
 9154               		.loc 1 2624 0
 9155 357c 60E0      		ldi r22,lo8(.LC65)
 9156 357e 70E0      		ldi r23,hi8(.LC65)
 9157 3580 80E0      		ldi r24,lo8(statusMsg)
 9158 3582 90E0      		ldi r25,hi8(statusMsg)
 9159 3584 0E94 0000 		call strcat
 9160               	.LVL751:
2625:switcherator.c ****         strcat(statusMsg, tempLongString);
 9161               		.loc 1 2625 0
 9162 3588 60E0      		ldi r22,lo8(tempLongString)
 9163 358a 70E0      		ldi r23,hi8(tempLongString)
 9164 358c 80E0      		ldi r24,lo8(statusMsg)
 9165 358e 90E0      		ldi r25,hi8(statusMsg)
 9166 3590 0E94 0000 		call strcat
 9167               	.LVL752:
2626:switcherator.c ****         sendMessage(statusMsg);
 9168               		.loc 1 2626 0
 9169 3594 80E0      		ldi r24,lo8(statusMsg)
 9170 3596 90E0      		ldi r25,hi8(statusMsg)
 9171 3598 0C94 0000 		jmp sendMessage
 9172               	.LVL753:
 9173               	.L604:
2629:switcherator.c ****     tweakTimer += adjustment;
 9174               		.loc 1 2629 0
 9175 359c AA27      		clr r26
 9176 359e 97FD      		sbrc r25,7
 9177 35a0 A095      		com r26
 9178 35a2 BA2F      		mov r27,r26
 9179 35a4 4091 0000 		lds r20,tweakTimer
 9180 35a8 5091 0000 		lds r21,tweakTimer+1
 9181 35ac 6091 0000 		lds r22,tweakTimer+2
 9182 35b0 7091 0000 		lds r23,tweakTimer+3
 9183 35b4 480F      		add r20,r24
 9184 35b6 591F      		adc r21,r25
 9185 35b8 6A1F      		adc r22,r26
 9186 35ba 7B1F      		adc r23,r27
 9187 35bc 4093 0000 		sts tweakTimer,r20
 9188 35c0 5093 0000 		sts tweakTimer+1,r21
 9189 35c4 6093 0000 		sts tweakTimer+2,r22
 9190 35c8 7093 0000 		sts tweakTimer+3,r23
2630:switcherator.c ****     ok();
 9191               		.loc 1 2630 0
 9192 35cc 0C94 0000 		jmp ok
 9193               	.LVL754:
 9194               	.LFE60:
 9196               		.section	.rodata.str1.1
 9197               	.LC66:
 9198 0143 5365 7420 		.string	"Set @"
 9198      4000 
 9199               	.LC67:
 9200 0149 4240 00   		.string	"B@"
 9201               		.text
 9202               	.global	brightnessSet
 9204               	brightnessSet:
 9205               	.LFB29:
1150:switcherator.c **** void brightnessSet(char * commandReceived) {
 9206               		.loc 1 1150 0
 9207               	.LVL755:
 9208               	/* prologue: function */
 9209               	/* frame size = 0 */
 9210               	/* stack size = 0 */
 9211               	.L__stack_usage = 0
1151:switcherator.c ****     int brightValue = getSwitchNumber(commandReceived);
 9212               		.loc 1 1151 0
 9213 35d0 0E94 0000 		call getSwitchNumber
 9214               	.LVL756:
 9215 35d4 9C01      		movw r18,r24
 9216               	.LVL757:
 9217 35d6 8091 0000 		lds r24,oldBright
1152:switcherator.c ****     if (brightValue == 0) {
 9218               		.loc 1 1152 0
 9219 35da 2115      		cp r18,__zero_reg__
 9220 35dc 3105      		cpc r19,__zero_reg__
 9221 35de 01F4      		brne .L606
1154:switcherator.c ****         itoa(oldBright, tempIntString, 10);
 9222               		.loc 1 1154 0
 9223 35e0 4AE0      		ldi r20,lo8(10)
 9224 35e2 50E0      		ldi r21,0
 9225 35e4 60E0      		ldi r22,lo8(tempIntString)
 9226 35e6 70E0      		ldi r23,hi8(tempIntString)
 9227 35e8 90E0      		ldi r25,0
 9228 35ea 0E94 0000 		call itoa
 9229               	.LVL758:
1155:switcherator.c ****         statusMsg[0] = 0;
 9230               		.loc 1 1155 0
 9231 35ee 1092 0000 		sts statusMsg,__zero_reg__
1156:switcherator.c ****         strcat(statusMsg, "Set @");
 9232               		.loc 1 1156 0
 9233 35f2 60E0      		ldi r22,lo8(.LC66)
 9234 35f4 70E0      		ldi r23,hi8(.LC66)
 9235 35f6 80E0      		ldi r24,lo8(statusMsg)
 9236 35f8 90E0      		ldi r25,hi8(statusMsg)
 9237 35fa 0E94 0000 		call strcat
 9238               	.LVL759:
1157:switcherator.c ****         strcat(statusMsg, tempIntString);
 9239               		.loc 1 1157 0
 9240 35fe 60E0      		ldi r22,lo8(tempIntString)
 9241 3600 70E0      		ldi r23,hi8(tempIntString)
 9242 3602 80E0      		ldi r24,lo8(statusMsg)
 9243 3604 90E0      		ldi r25,hi8(statusMsg)
 9244 3606 0E94 0000 		call strcat
 9245               	.LVL760:
1158:switcherator.c ****         strcat(statusMsg, "B@");
 9246               		.loc 1 1158 0
 9247 360a 60E0      		ldi r22,lo8(.LC67)
 9248 360c 70E0      		ldi r23,hi8(.LC67)
 9249 360e 80E0      		ldi r24,lo8(statusMsg)
 9250 3610 90E0      		ldi r25,hi8(statusMsg)
 9251 3612 0E94 0000 		call strcat
 9252               	.LVL761:
1159:switcherator.c ****         itoa(bright, tempIntString, 10);
 9253               		.loc 1 1159 0
 9254 3616 4AE0      		ldi r20,lo8(10)
 9255 3618 50E0      		ldi r21,0
 9256 361a 60E0      		ldi r22,lo8(tempIntString)
 9257 361c 70E0      		ldi r23,hi8(tempIntString)
 9258 361e 8091 0000 		lds r24,bright
 9259 3622 9091 0000 		lds r25,bright+1
 9260 3626 0E94 0000 		call itoa
 9261               	.LVL762:
1160:switcherator.c ****         strcat(statusMsg, tempIntString);
 9262               		.loc 1 1160 0
 9263 362a 60E0      		ldi r22,lo8(tempIntString)
 9264 362c 70E0      		ldi r23,hi8(tempIntString)
 9265 362e 80E0      		ldi r24,lo8(statusMsg)
 9266 3630 90E0      		ldi r25,hi8(statusMsg)
 9267 3632 0E94 0000 		call strcat
 9268               	.LVL763:
1161:switcherator.c ****         sendMessage(statusMsg);
 9269               		.loc 1 1161 0
 9270 3636 80E0      		ldi r24,lo8(statusMsg)
 9271 3638 90E0      		ldi r25,hi8(statusMsg)
 9272 363a 0C94 0000 		jmp sendMessage
 9273               	.LVL764:
 9274               	.L606:
 9275 363e 2131      		cpi r18,17
 9276 3640 3105      		cpc r19,__zero_reg__
 9277 3642 04F0      		brlt .L607
 9278 3644 20E1      		ldi r18,lo8(16)
 9279 3646 30E0      		ldi r19,0
 9280               	.LVL765:
 9281               	.L607:
1165:switcherator.c ****         if (oldBright == bright) {
 9282               		.loc 1 1165 0
 9283 3648 90E0      		ldi r25,0
 9284 364a 4091 0000 		lds r20,bright
 9285 364e 5091 0000 		lds r21,bright+1
 9286 3652 8417      		cp r24,r20
 9287 3654 9507      		cpc r25,r21
 9288 3656 01F4      		brne .L608
1167:switcherator.c ****             bright = brightValue;
 9289               		.loc 1 1167 0
 9290 3658 3093 0000 		sts bright+1,r19
 9291 365c 2093 0000 		sts bright,r18
 9292               	.L608:
1169:switcherator.c ****         oldBright = brightValue;
 9293               		.loc 1 1169 0
 9294 3660 2093 0000 		sts oldBright,r18
1170:switcherator.c ****         switchChanged = 1;
 9295               		.loc 1 1170 0
 9296 3664 81E0      		ldi r24,lo8(1)
 9297 3666 8093 0000 		sts switchChanged,r24
1171:switcherator.c ****         ok();
 9298               		.loc 1 1171 0
 9299 366a 0C94 0000 		jmp ok
 9300               	.LVL766:
 9301               	.LFE29:
 9303               		.section	.rodata.str1.1
 9304               	.LC68:
 9305 014c 6661 696C 		.string	"fail 0x"
 9305      2030 7800 
 9306               		.text
 9307               	.global	fail
 9309               	fail:
 9310               	.LFB10:
 402:switcherator.c **** void fail(int failCode) {
 9311               		.loc 1 402 0
 9312               	.LVL767:
 9313 366e CF93      		push r28
 9314               	.LCFI216:
 9315 3670 DF93      		push r29
 9316               	.LCFI217:
 9317               	/* prologue: function */
 9318               	/* frame size = 0 */
 9319               	/* stack size = 2 */
 9320               	.L__stack_usage = 2
 9321 3672 EC01      		movw r28,r24
 403:switcherator.c ****     statusMsg[0] = 0;
 9322               		.loc 1 403 0
 9323 3674 1092 0000 		sts statusMsg,__zero_reg__
 404:switcherator.c ****     strcat(statusMsg, "fail 0x");
 9324               		.loc 1 404 0
 9325 3678 60E0      		ldi r22,lo8(.LC68)
 9326 367a 70E0      		ldi r23,hi8(.LC68)
 9327 367c 80E0      		ldi r24,lo8(statusMsg)
 9328 367e 90E0      		ldi r25,hi8(statusMsg)
 9329               	.LVL768:
 9330 3680 0E94 0000 		call strcat
 9331               	.LVL769:
 405:switcherator.c ****     returnHex(failCode, tempIntString);
 9332               		.loc 1 405 0
 9333 3684 60E0      		ldi r22,lo8(tempIntString)
 9334 3686 70E0      		ldi r23,hi8(tempIntString)
 9335 3688 CE01      		movw r24,r28
 9336 368a 0E94 0000 		call returnHex
 9337               	.LVL770:
 406:switcherator.c ****     strcat(statusMsg, tempIntString);
 9338               		.loc 1 406 0
 9339 368e 60E0      		ldi r22,lo8(tempIntString)
 9340 3690 70E0      		ldi r23,hi8(tempIntString)
 9341 3692 80E0      		ldi r24,lo8(statusMsg)
 9342 3694 90E0      		ldi r25,hi8(statusMsg)
 9343 3696 0E94 0000 		call strcat
 9344               	.LVL771:
 407:switcherator.c ****     sendMessage(statusMsg);
 9345               		.loc 1 407 0
 9346 369a 80E0      		ldi r24,lo8(statusMsg)
 9347 369c 90E0      		ldi r25,hi8(statusMsg)
 9348               	/* epilogue start */
 408:switcherator.c **** }
 9349               		.loc 1 408 0
 9350 369e DF91      		pop r29
 9351 36a0 CF91      		pop r28
 9352               	.LVL772:
 407:switcherator.c ****     sendMessage(statusMsg);
 9353               		.loc 1 407 0
 9354 36a2 0C94 0000 		jmp sendMessage
 9355               	.LVL773:
 9356               	.LFE10:
 9358               	.global	setDigitalInput
 9360               	setDigitalInput:
 9361               	.LFB74:
3180:switcherator.c **** void setDigitalInput(char * commandReceived) {
 9362               		.loc 1 3180 0
 9363               	.LVL774:
 9364 36a6 5F92      		push r5
 9365               	.LCFI218:
 9366 36a8 6F92      		push r6
 9367               	.LCFI219:
 9368 36aa 7F92      		push r7
 9369               	.LCFI220:
 9370 36ac 8F92      		push r8
 9371               	.LCFI221:
 9372 36ae 9F92      		push r9
 9373               	.LCFI222:
 9374 36b0 AF92      		push r10
 9375               	.LCFI223:
 9376 36b2 BF92      		push r11
 9377               	.LCFI224:
 9378 36b4 CF92      		push r12
 9379               	.LCFI225:
 9380 36b6 DF92      		push r13
 9381               	.LCFI226:
 9382 36b8 EF92      		push r14
 9383               	.LCFI227:
 9384 36ba FF92      		push r15
 9385               	.LCFI228:
 9386 36bc 0F93      		push r16
 9387               	.LCFI229:
 9388 36be 1F93      		push r17
 9389               	.LCFI230:
 9390 36c0 CF93      		push r28
 9391               	.LCFI231:
 9392 36c2 DF93      		push r29
 9393               	.LCFI232:
 9394               	/* prologue: function */
 9395               	/* frame size = 0 */
 9396               	/* stack size = 15 */
 9397               	.L__stack_usage = 15
 9398 36c4 EC01      		movw r28,r24
 9399               	.LVL775:
3189:switcherator.c ****     tempIntString[0] = commandReceived[3];
 9400               		.loc 1 3189 0
 9401 36c6 8B81      		ldd r24,Y+3
 9402               	.LVL776:
 9403 36c8 8093 0000 		sts tempIntString,r24
3190:switcherator.c ****     tempIntString[1] = commandReceived[4];
 9404               		.loc 1 3190 0
 9405 36cc 8C81      		ldd r24,Y+4
 9406 36ce 8093 0000 		sts tempIntString+1,r24
3191:switcherator.c ****     inputNumber = atoi(tempIntString);
 9407               		.loc 1 3191 0
 9408 36d2 80E0      		ldi r24,lo8(tempIntString)
 9409 36d4 90E0      		ldi r25,hi8(tempIntString)
 9410 36d6 0E94 0000 		call atoi
 9411               	.LVL777:
 9412 36da 7C01      		movw r14,r24
 9413               	.LVL778:
3192:switcherator.c ****     if (inputNumber >= NUM_INPUTS) {
 9414               		.loc 1 3192 0
 9415 36dc 84E0      		ldi r24,4
 9416 36de E816      		cp r14,r24
 9417 36e0 F104      		cpc r15,__zero_reg__
 9418 36e2 04F0      		brlt .L611
3193:switcherator.c ****         fail(0x11);
 9419               		.loc 1 3193 0
 9420 36e4 81E1      		ldi r24,lo8(17)
 9421 36e6 90E0      		ldi r25,0
 9422 36e8 00C0      		rjmp .L648
 9423               	.L611:
3196:switcherator.c ****     tempIntString[0] = '0';
 9424               		.loc 1 3196 0
 9425 36ea 80E3      		ldi r24,lo8(48)
 9426 36ec 8093 0000 		sts tempIntString,r24
3197:switcherator.c ****     tempIntString[1] = commandReceived[6];
 9427               		.loc 1 3197 0
 9428 36f0 8E81      		ldd r24,Y+6
 9429 36f2 8093 0000 		sts tempIntString+1,r24
3198:switcherator.c ****     pin = atoi(tempIntString);
 9430               		.loc 1 3198 0
 9431 36f6 80E0      		ldi r24,lo8(tempIntString)
 9432 36f8 90E0      		ldi r25,hi8(tempIntString)
 9433 36fa 0E94 0000 		call atoi
 9434               	.LVL779:
 9435 36fe 6C01      		movw r12,r24
 9436               	.LVL780:
3199:switcherator.c ****     if (pin > 7) {
 9437               		.loc 1 3199 0
 9438 3700 E7E0      		ldi r30,lo8(7)
 9439 3702 E817      		cp r30,r24
 9440 3704 00F4      		brsh .L612
3200:switcherator.c ****         fail(0x04);
 9441               		.loc 1 3200 0
 9442 3706 84E0      		ldi r24,lo8(4)
 9443 3708 90E0      		ldi r25,0
 9444               	.LVL781:
 9445               	.L648:
 9446               	/* epilogue start */
3314:switcherator.c **** }
 9447               		.loc 1 3314 0
 9448 370a DF91      		pop r29
 9449 370c CF91      		pop r28
 9450               	.LVL782:
 9451 370e 1F91      		pop r17
 9452 3710 0F91      		pop r16
 9453 3712 FF90      		pop r15
 9454 3714 EF90      		pop r14
 9455               	.LVL783:
 9456 3716 DF90      		pop r13
 9457 3718 CF90      		pop r12
 9458 371a BF90      		pop r11
 9459 371c AF90      		pop r10
 9460 371e 9F90      		pop r9
 9461 3720 8F90      		pop r8
 9462 3722 7F90      		pop r7
 9463 3724 6F90      		pop r6
 9464 3726 5F90      		pop r5
3200:switcherator.c ****         fail(0x04);
 9465               		.loc 1 3200 0
 9466 3728 0C94 0000 		jmp fail
 9467               	.LVL784:
 9468               	.L612:
3204:switcherator.c ****     tempIntString[0] = commandReceived[9];
 9469               		.loc 1 3204 0
 9470 372c 8985      		ldd r24,Y+9
 9471 372e 8093 0000 		sts tempIntString,r24
3205:switcherator.c ****     tempIntString[1] = commandReceived[10];
 9472               		.loc 1 3205 0
 9473 3732 8A85      		ldd r24,Y+10
 9474 3734 8093 0000 		sts tempIntString+1,r24
3206:switcherator.c ****     switchNumber = atoi(tempIntString);
 9475               		.loc 1 3206 0
 9476 3738 80E0      		ldi r24,lo8(tempIntString)
 9477 373a 90E0      		ldi r25,hi8(tempIntString)
 9478 373c 0E94 0000 		call atoi
 9479               	.LVL785:
 9480 3740 8C01      		movw r16,r24
 9481               	.LVL786:
3208:switcherator.c ****     tempIntString[0] = commandReceived[15];
 9482               		.loc 1 3208 0
 9483 3742 8F85      		ldd r24,Y+15
 9484 3744 8093 0000 		sts tempIntString,r24
3209:switcherator.c ****     tempIntString[1] = commandReceived[16];
 9485               		.loc 1 3209 0
 9486 3748 8889      		ldd r24,Y+16
 9487 374a 8093 0000 		sts tempIntString+1,r24
3210:switcherator.c ****     pollTime = atoi(tempIntString);
 9488               		.loc 1 3210 0
 9489 374e 80E0      		ldi r24,lo8(tempIntString)
 9490 3750 90E0      		ldi r25,hi8(tempIntString)
 9491 3752 0E94 0000 		call atoi
 9492               	.LVL787:
 9493 3756 4C01      		movw r8,r24
 9494               	.LVL788:
3212:switcherator.c ****     tempLongString[0] = commandReceived[11];
 9495               		.loc 1 3212 0
 9496 3758 8B85      		ldd r24,Y+11
 9497 375a 8093 0000 		sts tempLongString,r24
3213:switcherator.c ****     tempLongString[1] = commandReceived[12];
 9498               		.loc 1 3213 0
 9499 375e 8C85      		ldd r24,Y+12
 9500 3760 8093 0000 		sts tempLongString+1,r24
3214:switcherator.c ****     tempLongString[2] = commandReceived[13];
 9501               		.loc 1 3214 0
 9502 3764 8D85      		ldd r24,Y+13
 9503 3766 8093 0000 		sts tempLongString+2,r24
3215:switcherator.c ****     tempLongString[3] = commandReceived[14];
 9504               		.loc 1 3215 0
 9505 376a 8E85      		ldd r24,Y+14
 9506 376c 8093 0000 		sts tempLongString+3,r24
3216:switcherator.c ****     duration = atoi(tempLongString);
 9507               		.loc 1 3216 0
 9508 3770 80E0      		ldi r24,lo8(tempLongString)
 9509 3772 90E0      		ldi r25,hi8(tempLongString)
 9510 3774 0E94 0000 		call atoi
 9511               	.LVL789:
 9512 3778 582E      		mov r5,r24
 9513               	.LVL790:
3218:switcherator.c ****     if (commandReceived[8] == 'P' || commandReceived[8] == 'p') {
 9514               		.loc 1 3218 0
 9515 377a 2885      		ldd r18,Y+8
 9516 377c 2035      		cpi r18,lo8(80)
 9517 377e 01F0      		breq .L613
3218:switcherator.c ****     if (commandReceived[8] == 'P' || commandReceived[8] == 'p') {
 9518               		.loc 1 3218 0 is_stmt 0 discriminator 1
 9519 3780 2037      		cpi r18,lo8(112)
 9520 3782 01F4      		brne .L614
 9521               	.L613:
3219:switcherator.c ****         switchNumber += 128;
 9522               		.loc 1 3219 0 is_stmt 1
 9523 3784 0058      		subi r16,-128
 9524 3786 1F4F      		sbci r17,-1
 9525               	.LVL791:
 9526               	.L614:
3221:switcherator.c ****     temp = pin * 2;
 9527               		.loc 1 3221 0
 9528 3788 B601      		movw r22,r12
 9529 378a 7727      		clr r23
 9530 378c 9B01      		movw r18,r22
 9531 378e 220F      		lsl r18
 9532 3790 331F      		rol r19
 9533               	.LVL792:
3222:switcherator.c ****     if (commandReceived[5] == 'B' || commandReceived[5] == 'b') {
 9534               		.loc 1 3222 0
 9535 3792 4D81      		ldd r20,Y+5
 9536 3794 4234      		cpi r20,lo8(66)
 9537 3796 01F0      		breq .L615
3222:switcherator.c ****     if (commandReceived[5] == 'B' || commandReceived[5] == 'b') {
 9538               		.loc 1 3222 0 is_stmt 0 discriminator 1
 9539 3798 4236      		cpi r20,lo8(98)
 9540 379a 01F4      		brne .L616
 9541               	.L615:
 9542               	.LVL793:
3225:switcherator.c ****         temp += 16;
 9543               		.loc 1 3225 0 is_stmt 1
 9544 379c 205F      		subi r18,-16
 9545 379e 3F4F      		sbci r19,-1
 9546               	.LVL794:
3224:switcherator.c ****         realPort = &PORTB;
 9547               		.loc 1 3224 0
 9548 37a0 B5E2      		ldi r27,lo8(37)
 9549 37a2 6B2E      		mov r6,r27
 9550 37a4 712C      		mov r7,__zero_reg__
3223:switcherator.c ****         realDDR = &DDRB;
 9551               		.loc 1 3223 0
 9552 37a6 A4E2      		ldi r26,lo8(36)
 9553 37a8 B0E0      		ldi r27,0
3225:switcherator.c ****         temp += 16;
 9554               		.loc 1 3225 0
 9555 37aa 00C0      		rjmp .L617
 9556               	.LVL795:
 9557               	.L616:
3233:switcherator.c ****     } else if (commandReceived[5] == 'C' || commandReceived[5] == 'c') {
 9558               		.loc 1 3233 0
 9559 37ac 4334      		cpi r20,lo8(67)
 9560 37ae 01F0      		breq .L618
3233:switcherator.c ****     } else if (commandReceived[5] == 'C' || commandReceived[5] == 'c') {
 9561               		.loc 1 3233 0 is_stmt 0 discriminator 1
 9562 37b0 4336      		cpi r20,lo8(99)
 9563 37b2 01F4      		brne .L619
 9564               	.L618:
 9565               	.LVL796:
3236:switcherator.c ****         temp += 32;
 9566               		.loc 1 3236 0 is_stmt 1
 9567 37b4 205E      		subi r18,-32
 9568 37b6 3F4F      		sbci r19,-1
 9569               	.LVL797:
3235:switcherator.c ****         realPort = &PORTC;
 9570               		.loc 1 3235 0
 9571 37b8 A8E2      		ldi r26,lo8(40)
 9572 37ba 6A2E      		mov r6,r26
 9573 37bc 712C      		mov r7,__zero_reg__
3234:switcherator.c ****         realDDR = &DDRC;
 9574               		.loc 1 3234 0
 9575 37be A7E2      		ldi r26,lo8(39)
 9576 37c0 B0E0      		ldi r27,0
3236:switcherator.c ****         temp += 32;
 9577               		.loc 1 3236 0
 9578 37c2 00C0      		rjmp .L617
 9579               	.LVL798:
 9580               	.L619:
3239:switcherator.c ****     } else if (commandReceived[5] == 'D' || commandReceived[5] == 'd') {
 9581               		.loc 1 3239 0
 9582 37c4 4434      		cpi r20,lo8(68)
 9583 37c6 01F0      		breq .L620
3239:switcherator.c ****     } else if (commandReceived[5] == 'D' || commandReceived[5] == 'd') {
 9584               		.loc 1 3239 0 is_stmt 0 discriminator 1
 9585 37c8 4436      		cpi r20,lo8(100)
 9586 37ca 01F4      		brne .L628
 9587               	.L620:
 9588               	.LVL799:
3242:switcherator.c ****         temp += 48;
 9589               		.loc 1 3242 0 is_stmt 1
 9590 37cc 205D      		subi r18,-48
 9591 37ce 3F4F      		sbci r19,-1
 9592               	.LVL800:
3241:switcherator.c ****         realPort = &PORTD;
 9593               		.loc 1 3241 0
 9594 37d0 FBE2      		ldi r31,lo8(43)
 9595 37d2 6F2E      		mov r6,r31
 9596 37d4 712C      		mov r7,__zero_reg__
3240:switcherator.c ****         realDDR = &DDRD;
 9597               		.loc 1 3240 0
 9598 37d6 AAE2      		ldi r26,lo8(42)
 9599 37d8 B0E0      		ldi r27,0
 9600 37da 00C0      		rjmp .L617
 9601               	.LVL801:
 9602               	.L628:
3184:switcherator.c ****     volatile unsigned char *realPort = 0;
 9603               		.loc 1 3184 0
 9604 37dc 612C      		mov r6,__zero_reg__
 9605 37de 712C      		mov r7,__zero_reg__
3183:switcherator.c ****     volatile unsigned char *realDDR = 0;
 9606               		.loc 1 3183 0
 9607 37e0 A0E0      		ldi r26,0
 9608 37e2 B0E0      		ldi r27,0
 9609               	.LVL802:
 9610               	.L617:
 9611 37e4 40E0      		ldi r20,lo8(switchStuff)
 9612 37e6 50E0      		ldi r21,hi8(switchStuff)
3282:switcherator.c ****         if (switchStuff[x] == temp || switchStuff[x] == (temp + 1)) {
 9613               		.loc 1 3282 0
 9614 37e8 5901      		movw r10,r18
 9615 37ea FFEF      		ldi r31,-1
 9616 37ec AF1A      		sub r10,r31
 9617 37ee BF0A      		sbc r11,r31
 9618               	.LVL803:
 9619               	.L623:
 9620 37f0 FA01      		movw r30,r20
 9621 37f2 C190      		ld r12,Z+
 9622 37f4 AF01      		movw r20,r30
 9623 37f6 D12C      		mov r13,__zero_reg__
 9624 37f8 C216      		cp r12,r18
 9625 37fa D306      		cpc r13,r19
 9626 37fc 01F0      		breq .L621
3282:switcherator.c ****         if (switchStuff[x] == temp || switchStuff[x] == (temp + 1)) {
 9627               		.loc 1 3282 0 is_stmt 0 discriminator 1
 9628 37fe CA14      		cp r12,r10
 9629 3800 DB04      		cpc r13,r11
 9630 3802 01F4      		brne .L622
 9631               	.L621:
3283:switcherator.c ****             fail(0x12);
 9632               		.loc 1 3283 0 is_stmt 1
 9633 3804 82E1      		ldi r24,lo8(18)
 9634 3806 90E0      		ldi r25,0
 9635 3808 00C0      		rjmp .L648
 9636               	.L622:
3281:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 9637               		.loc 1 3281 0
 9638 380a F0E0      		ldi r31,hi8(switchStuff+16)
 9639 380c 4030      		cpi r20,lo8(switchStuff+16)
 9640 380e 5F07      		cpc r21,r31
 9641 3810 01F4      		brne .L623
3288:switcherator.c ****     inputs[inputNumber][0] = temp;
 9642               		.loc 1 3288 0
 9643 3812 A701      		movw r20,r14
 9644 3814 73E0      		ldi r23,3
 9645               		1:
 9646 3816 440F      		lsl r20
 9647 3818 551F      		rol r21
 9648 381a 7A95      		dec r23
 9649 381c 01F4      		brne 1b
 9650 381e E0E0      		ldi r30,lo8(inputs)
 9651 3820 EE2E      		mov r14,r30
 9652 3822 E0E0      		ldi r30,hi8(inputs)
 9653 3824 FE2E      		mov r15,r30
 9654               	.LVL804:
 9655 3826 E40E      		add r14,r20
 9656 3828 F51E      		adc r15,r21
 9657 382a F701      		movw r30,r14
 9658 382c 2083      		st Z,r18
3290:switcherator.c ****     if (commandReceived[7] == 'H' || commandReceived[7] == 'h' ||
 9659               		.loc 1 3290 0
 9660 382e 2F81      		ldd r18,Y+7
 9661               	.LVL805:
 9662 3830 2834      		cpi r18,lo8(72)
 9663 3832 01F0      		breq .L624
3290:switcherator.c ****     if (commandReceived[7] == 'H' || commandReceived[7] == 'h' ||
 9664               		.loc 1 3290 0 is_stmt 0 discriminator 1
 9665 3834 2836      		cpi r18,lo8(104)
 9666 3836 01F0      		breq .L624
 9667 3838 2133      		cpi r18,lo8(49)
 9668 383a 01F4      		brne .L625
 9669               	.L624:
3292:switcherator.c ****         inputs[inputNumber][1] = 0;
 9670               		.loc 1 3292 0 is_stmt 1
 9671 383c EA01      		movw r28,r20
 9672               	.LVL806:
 9673 383e C050      		subi r28,lo8(-(inputs))
 9674 3840 D040      		sbci r29,hi8(-(inputs))
 9675 3842 1982      		std Y+1,__zero_reg__
3293:switcherator.c ****         inputs[inputNumber][2] = 255;
 9676               		.loc 1 3293 0
 9677 3844 2FEF      		ldi r18,lo8(-1)
 9678 3846 2A83      		std Y+2,r18
 9679 3848 00C0      		rjmp .L626
 9680               	.LVL807:
 9681               	.L625:
3295:switcherator.c ****         inputs[inputNumber][1] = 255;
 9682               		.loc 1 3295 0
 9683 384a 2FEF      		ldi r18,lo8(-1)
 9684 384c F701      		movw r30,r14
 9685 384e 2183      		std Z+1,r18
3296:switcherator.c ****         inputs[inputNumber][2] = 0;
 9686               		.loc 1 3296 0
 9687 3850 1282      		std Z+2,__zero_reg__
 9688               	.LVL808:
 9689               	.L626:
3298:switcherator.c ****     inputs[inputNumber][3] = switchNumber;
 9690               		.loc 1 3298 0
 9691 3852 EA01      		movw r28,r20
 9692 3854 C050      		subi r28,lo8(-(inputs))
 9693 3856 D040      		sbci r29,hi8(-(inputs))
 9694 3858 0B83      		std Y+3,r16
 9695               	.LVL809:
3300:switcherator.c ****     inputs[inputNumber][4] = temp;
 9696               		.loc 1 3300 0
 9697 385a 9C83      		std Y+4,r25
 9698               	.LVL810:
3302:switcherator.c ****     inputs[inputNumber][5] = temp;
 9699               		.loc 1 3302 0
 9700 385c 5D82      		std Y+5,r5
 9701               	.LVL811:
3306:switcherator.c ****     inputs[inputNumber][6] = pollTime;
 9702               		.loc 1 3306 0
 9703 385e 9401      		movw r18,r8
 9704 3860 2F3F      		cpi r18,-1
 9705 3862 3105      		cpc r19,__zero_reg__
 9706 3864 01F0      		breq .L627
 9707 3866 04F0      		brlt .L627
 9708 3868 2FEF      		ldi r18,lo8(-1)
 9709 386a 30E0      		ldi r19,0
 9710               	.L627:
 9711 386c 2E83      		std Y+6,r18
3308:switcherator.c ****     *realDDR &= ~(1 << pin);
 9712               		.loc 1 3308 0
 9713 386e 8C91      		ld r24,X
 9714 3870 21E0      		ldi r18,lo8(1)
 9715 3872 30E0      		ldi r19,0
 9716 3874 00C0      		rjmp 2f
 9717               		1:
 9718 3876 220F      		lsl r18
 9719               		2:
 9720 3878 6A95      		dec r22
 9721 387a 02F4      		brpl 1b
 9722 387c 922F      		mov r25,r18
 9723               	.LVL812:
 9724 387e 9095      		com r25
 9725 3880 8923      		and r24,r25
 9726 3882 8C93      		st X,r24
3309:switcherator.c ****     *realPort |= (1 << pin);
 9727               		.loc 1 3309 0
 9728 3884 F301      		movw r30,r6
 9729 3886 8081      		ld r24,Z
 9730 3888 822B      		or r24,r18
 9731 388a 8083      		st Z,r24
 9732               	/* epilogue start */
3314:switcherator.c **** }
 9733               		.loc 1 3314 0
 9734 388c DF91      		pop r29
 9735 388e CF91      		pop r28
 9736               	.LVL813:
 9737 3890 1F91      		pop r17
 9738 3892 0F91      		pop r16
 9739 3894 FF90      		pop r15
 9740 3896 EF90      		pop r14
 9741 3898 DF90      		pop r13
 9742 389a CF90      		pop r12
 9743 389c BF90      		pop r11
 9744 389e AF90      		pop r10
 9745 38a0 9F90      		pop r9
 9746               	.LVL814:
 9747 38a2 8F90      		pop r8
 9748 38a4 7F90      		pop r7
 9749 38a6 6F90      		pop r6
 9750               	.LVL815:
 9751 38a8 5F90      		pop r5
 9752               	.LVL816:
3311:switcherator.c ****     ok();
 9753               		.loc 1 3311 0
 9754 38aa 0C94 0000 		jmp ok
 9755               	.LVL817:
 9756               	.LFE74:
 9758               	.global	setAnalogInput
 9760               	setAnalogInput:
 9761               	.LFB73:
3055:switcherator.c **** void setAnalogInput(char * commandReceived) {
 9762               		.loc 1 3055 0
 9763               	.LVL818:
 9764 38ae 2F92      		push r2
 9765               	.LCFI233:
 9766 38b0 3F92      		push r3
 9767               	.LCFI234:
 9768 38b2 4F92      		push r4
 9769               	.LCFI235:
 9770 38b4 5F92      		push r5
 9771               	.LCFI236:
 9772 38b6 6F92      		push r6
 9773               	.LCFI237:
 9774 38b8 7F92      		push r7
 9775               	.LCFI238:
 9776 38ba 8F92      		push r8
 9777               	.LCFI239:
 9778 38bc 9F92      		push r9
 9779               	.LCFI240:
 9780 38be AF92      		push r10
 9781               	.LCFI241:
 9782 38c0 BF92      		push r11
 9783               	.LCFI242:
 9784 38c2 CF92      		push r12
 9785               	.LCFI243:
 9786 38c4 DF92      		push r13
 9787               	.LCFI244:
 9788 38c6 EF92      		push r14
 9789               	.LCFI245:
 9790 38c8 FF92      		push r15
 9791               	.LCFI246:
 9792 38ca 0F93      		push r16
 9793               	.LCFI247:
 9794 38cc 1F93      		push r17
 9795               	.LCFI248:
 9796 38ce CF93      		push r28
 9797               	.LCFI249:
 9798 38d0 DF93      		push r29
 9799               	.LCFI250:
 9800 38d2 00D0      		rcall .
 9801 38d4 1F92      		push __zero_reg__
 9802               	.LCFI251:
 9803 38d6 CDB7      		in r28,__SP_L__
 9804 38d8 DEB7      		in r29,__SP_H__
 9805               	.LCFI252:
 9806               	/* prologue: function */
 9807               	/* frame size = 3 */
 9808               	/* stack size = 21 */
 9809               	.L__stack_usage = 21
 9810 38da 9B83      		std Y+3,r25
 9811 38dc 8A83      		std Y+2,r24
 9812               	.LVL819:
3063:switcherator.c ****     tempIntString[0] = commandReceived[3];
 9813               		.loc 1 3063 0
 9814 38de DC01      		movw r26,r24
 9815 38e0 1396      		adiw r26,3
 9816 38e2 8C91      		ld r24,X
 9817 38e4 1397      		sbiw r26,3
 9818               	.LVL820:
 9819 38e6 8093 0000 		sts tempIntString,r24
3064:switcherator.c ****     tempIntString[1] = commandReceived[4];
 9820               		.loc 1 3064 0
 9821 38ea 1496      		adiw r26,4
 9822 38ec 8C91      		ld r24,X
 9823 38ee 8093 0000 		sts tempIntString+1,r24
3065:switcherator.c ****     inputNumber = atoi(tempIntString);
 9824               		.loc 1 3065 0
 9825 38f2 80E0      		ldi r24,lo8(tempIntString)
 9826 38f4 90E0      		ldi r25,hi8(tempIntString)
 9827 38f6 0E94 0000 		call atoi
 9828               	.LVL821:
 9829 38fa 8C01      		movw r16,r24
 9830               	.LVL822:
3066:switcherator.c ****     if (inputNumber >= NUM_INPUTS) {
 9831               		.loc 1 3066 0
 9832 38fc 8430      		cpi r24,4
 9833 38fe 9105      		cpc r25,__zero_reg__
 9834 3900 04F0      		brlt .L650
3067:switcherator.c ****         fail(0x11);
 9835               		.loc 1 3067 0
 9836 3902 81E1      		ldi r24,lo8(17)
 9837 3904 90E0      		ldi r25,0
 9838 3906 00C0      		rjmp .L671
 9839               	.L650:
3070:switcherator.c ****     tempIntString[0] = '0';
 9840               		.loc 1 3070 0
 9841 3908 50E3      		ldi r21,lo8(48)
 9842 390a B52E      		mov r11,r21
 9843 390c B092 0000 		sts tempIntString,r11
3071:switcherator.c ****     tempIntString[1] = commandReceived[6];
 9844               		.loc 1 3071 0
 9845 3910 EA81      		ldd r30,Y+2
 9846 3912 FB81      		ldd r31,Y+3
 9847 3914 8681      		ldd r24,Z+6
 9848 3916 8093 0000 		sts tempIntString+1,r24
3072:switcherator.c ****     pin = atoi(tempIntString);
 9849               		.loc 1 3072 0
 9850 391a 80E0      		ldi r24,lo8(tempIntString)
 9851 391c 90E0      		ldi r25,hi8(tempIntString)
 9852 391e 0E94 0000 		call atoi
 9853               	.LVL823:
 9854 3922 6C01      		movw r12,r24
 9855               	.LVL824:
3073:switcherator.c ****     if (pin > 7) {
 9856               		.loc 1 3073 0
 9857 3924 F7E0      		ldi r31,lo8(7)
 9858 3926 F817      		cp r31,r24
 9859 3928 00F4      		brsh .L651
3074:switcherator.c ****         fail(0x04);
 9860               		.loc 1 3074 0
 9861 392a 84E0      		ldi r24,lo8(4)
 9862 392c 90E0      		ldi r25,0
 9863               	.LVL825:
 9864               	.L671:
 9865               	/* epilogue start */
3172:switcherator.c **** }
 9866               		.loc 1 3172 0
 9867 392e 0F90      		pop __tmp_reg__
 9868 3930 0F90      		pop __tmp_reg__
 9869 3932 0F90      		pop __tmp_reg__
 9870 3934 DF91      		pop r29
 9871 3936 CF91      		pop r28
 9872 3938 1F91      		pop r17
 9873 393a 0F91      		pop r16
 9874               	.LVL826:
 9875 393c FF90      		pop r15
 9876 393e EF90      		pop r14
 9877 3940 DF90      		pop r13
 9878 3942 CF90      		pop r12
 9879 3944 BF90      		pop r11
 9880 3946 AF90      		pop r10
 9881 3948 9F90      		pop r9
 9882 394a 8F90      		pop r8
 9883 394c 7F90      		pop r7
 9884 394e 6F90      		pop r6
 9885 3950 5F90      		pop r5
 9886 3952 4F90      		pop r4
 9887 3954 3F90      		pop r3
 9888 3956 2F90      		pop r2
3074:switcherator.c ****         fail(0x04);
 9889               		.loc 1 3074 0
 9890 3958 0C94 0000 		jmp fail
 9891               	.LVL827:
 9892               	.L651:
3078:switcherator.c ****     tempIntString[0] = commandReceived[14];
 9893               		.loc 1 3078 0
 9894 395c AA81      		ldd r26,Y+2
 9895 395e BB81      		ldd r27,Y+3
 9896 3960 1E96      		adiw r26,14
 9897 3962 8C91      		ld r24,X
 9898 3964 1E97      		sbiw r26,14
 9899 3966 8093 0000 		sts tempIntString,r24
3079:switcherator.c ****     tempIntString[1] = commandReceived[15];
 9900               		.loc 1 3079 0
 9901 396a 1F96      		adiw r26,15
 9902 396c 8C91      		ld r24,X
 9903 396e 8093 0000 		sts tempIntString+1,r24
3080:switcherator.c ****     switchNumber = atoi(tempIntString);
 9904               		.loc 1 3080 0
 9905 3972 80E0      		ldi r24,lo8(tempIntString)
 9906 3974 90E0      		ldi r25,hi8(tempIntString)
 9907 3976 0E94 0000 		call atoi
 9908               	.LVL828:
 9909 397a 7C01      		movw r14,r24
 9910               	.LVL829:
3082:switcherator.c ****     tempIntString[0] = commandReceived[20];
 9911               		.loc 1 3082 0
 9912 397c EA81      		ldd r30,Y+2
 9913 397e FB81      		ldd r31,Y+3
 9914 3980 8489      		ldd r24,Z+20
 9915 3982 8093 0000 		sts tempIntString,r24
3083:switcherator.c ****     tempIntString[1] = commandReceived[21];
 9916               		.loc 1 3083 0
 9917 3986 8589      		ldd r24,Z+21
 9918 3988 8093 0000 		sts tempIntString+1,r24
3084:switcherator.c ****     pollTime = atoi(tempIntString);
 9919               		.loc 1 3084 0
 9920 398c 80E0      		ldi r24,lo8(tempIntString)
 9921 398e 90E0      		ldi r25,hi8(tempIntString)
 9922 3990 0E94 0000 		call atoi
 9923               	.LVL830:
 9924 3994 782E      		mov r7,r24
 9925 3996 892E      		mov r8,r25
 9926               	.LVL831:
3086:switcherator.c ****     tempIntString[0] = '0';
 9927               		.loc 1 3086 0
 9928 3998 B092 0000 		sts tempIntString,r11
3087:switcherator.c ****     tempIntString[1] = commandReceived[22];
 9929               		.loc 1 3087 0
 9930 399c AA81      		ldd r26,Y+2
 9931 399e BB81      		ldd r27,Y+3
 9932 39a0 5696      		adiw r26,22
 9933 39a2 8C91      		ld r24,X
 9934 39a4 8093 0000 		sts tempIntString+1,r24
3088:switcherator.c ****     whichRGB = atoi(tempIntString);
 9935               		.loc 1 3088 0
 9936 39a8 80E0      		ldi r24,lo8(tempIntString)
 9937 39aa 90E0      		ldi r25,hi8(tempIntString)
 9938 39ac 0E94 0000 		call atoi
 9939               	.LVL832:
 9940 39b0 982E      		mov r9,r24
 9941               	.LVL833:
3090:switcherator.c ****     tempLongString[0] = '0';
 9942               		.loc 1 3090 0
 9943 39b2 B092 0000 		sts tempLongString,r11
3091:switcherator.c ****     tempLongString[1] = commandReceived[7];
 9944               		.loc 1 3091 0
 9945 39b6 EA81      		ldd r30,Y+2
 9946 39b8 FB81      		ldd r31,Y+3
 9947 39ba 8781      		ldd r24,Z+7
 9948 39bc 8093 0000 		sts tempLongString+1,r24
3092:switcherator.c ****     tempLongString[2] = commandReceived[8];
 9949               		.loc 1 3092 0
 9950 39c0 8085      		ldd r24,Z+8
 9951 39c2 8093 0000 		sts tempLongString+2,r24
3093:switcherator.c ****     tempLongString[3] = commandReceived[9];
 9952               		.loc 1 3093 0
 9953 39c6 8185      		ldd r24,Z+9
 9954 39c8 8093 0000 		sts tempLongString+3,r24
3094:switcherator.c ****     lowPercent = atoi(tempLongString);
 9955               		.loc 1 3094 0
 9956 39cc 80E0      		ldi r24,lo8(tempLongString)
 9957 39ce 90E0      		ldi r25,hi8(tempLongString)
 9958 39d0 0E94 0000 		call atoi
 9959               	.LVL834:
 9960 39d4 5C01      		movw r10,r24
 9961               	.LVL835:
3095:switcherator.c ****     tempLongString[1] = commandReceived[10];
 9962               		.loc 1 3095 0
 9963 39d6 AA81      		ldd r26,Y+2
 9964 39d8 BB81      		ldd r27,Y+3
 9965 39da 1A96      		adiw r26,10
 9966 39dc 8C91      		ld r24,X
 9967 39de 1A97      		sbiw r26,10
 9968 39e0 8093 0000 		sts tempLongString+1,r24
3096:switcherator.c ****     tempLongString[2] = commandReceived[11];
 9969               		.loc 1 3096 0
 9970 39e4 1B96      		adiw r26,11
 9971 39e6 8C91      		ld r24,X
 9972 39e8 1B97      		sbiw r26,11
 9973 39ea 8093 0000 		sts tempLongString+2,r24
3097:switcherator.c ****     tempLongString[3] = commandReceived[12];
 9974               		.loc 1 3097 0
 9975 39ee 1C96      		adiw r26,12
 9976 39f0 8C91      		ld r24,X
 9977 39f2 8093 0000 		sts tempLongString+3,r24
3098:switcherator.c ****     highPercent = atoi(tempLongString);
 9978               		.loc 1 3098 0
 9979 39f6 80E0      		ldi r24,lo8(tempLongString)
 9980 39f8 90E0      		ldi r25,hi8(tempLongString)
 9981 39fa 0E94 0000 		call atoi
 9982               	.LVL836:
 9983 39fe 2C01      		movw r4,r24
 9984               	.LVL837:
3100:switcherator.c ****     tempLongString[0] = commandReceived[16];
 9985               		.loc 1 3100 0
 9986 3a00 EA81      		ldd r30,Y+2
 9987 3a02 FB81      		ldd r31,Y+3
 9988 3a04 8089      		ldd r24,Z+16
 9989 3a06 8093 0000 		sts tempLongString,r24
3101:switcherator.c ****     tempLongString[1] = commandReceived[17];
 9990               		.loc 1 3101 0
 9991 3a0a 8189      		ldd r24,Z+17
 9992 3a0c 8093 0000 		sts tempLongString+1,r24
3102:switcherator.c ****     tempLongString[2] = commandReceived[18];
 9993               		.loc 1 3102 0
 9994 3a10 8289      		ldd r24,Z+18
 9995 3a12 8093 0000 		sts tempLongString+2,r24
3103:switcherator.c ****     tempLongString[3] = commandReceived[19];
 9996               		.loc 1 3103 0
 9997 3a16 8389      		ldd r24,Z+19
 9998 3a18 8093 0000 		sts tempLongString+3,r24
3104:switcherator.c ****     duration = atoi(tempLongString);
 9999               		.loc 1 3104 0
 10000 3a1c 80E0      		ldi r24,lo8(tempLongString)
 10001 3a1e 90E0      		ldi r25,hi8(tempLongString)
 10002 3a20 0E94 0000 		call atoi
 10003               	.LVL838:
 10004 3a24 682E      		mov r6,r24
 10005 3a26 9983      		std Y+1,r25
 10006               	.LVL839:
3111:switcherator.c ****     if (commandReceived[5] != 'C' && commandReceived[5] != 'c') {
 10007               		.loc 1 3111 0
 10008 3a28 AA81      		ldd r26,Y+2
 10009 3a2a BB81      		ldd r27,Y+3
 10010 3a2c 1596      		adiw r26,5
 10011 3a2e 8C91      		ld r24,X
 10012 3a30 8334      		cpi r24,lo8(67)
 10013 3a32 01F0      		breq .L652
3111:switcherator.c ****     if (commandReceived[5] != 'C' && commandReceived[5] != 'c') {
 10014               		.loc 1 3111 0 is_stmt 0 discriminator 1
 10015 3a34 8336      		cpi r24,lo8(99)
 10016 3a36 01F0      		breq .L652
3112:switcherator.c ****         fail(0x03);
 10017               		.loc 1 3112 0 is_stmt 1
 10018 3a38 83E0      		ldi r24,lo8(3)
 10019 3a3a 90E0      		ldi r25,0
 10020 3a3c 00C0      		rjmp .L671
 10021               	.L652:
3122:switcherator.c ****     temp = pin * 2;
 10022               		.loc 1 3122 0
 10023 3a3e DD24      		clr r13
 10024               	.LVL840:
 10025 3a40 C601      		movw r24,r12
 10026 3a42 880F      		lsl r24
 10027 3a44 991F      		rol r25
 10028 3a46 AA27      		clr r26
 10029 3a48 97FD      		sbrc r25,7
 10030 3a4a A095      		com r26
 10031 3a4c BA2F      		mov r27,r26
 10032               	.LVL841:
3124:switcherator.c ****     temp += 32;
 10033               		.loc 1 3124 0
 10034 3a4e 8096      		adiw r24,32
 10035 3a50 A11D      		adc r26,__zero_reg__
 10036 3a52 B11D      		adc r27,__zero_reg__
 10037               	.LVL842:
 10038 3a54 E0E0      		ldi r30,lo8(switchStuff)
 10039 3a56 F0E0      		ldi r31,hi8(switchStuff)
 10040               	.LVL843:
 10041               	.L654:
3126:switcherator.c ****         if (switchStuff[x] == temp) {
 10042               		.loc 1 3126 0
 10043 3a58 4191      		ld r20,Z+
 10044 3a5a 50E0      		ldi r21,0
 10045 3a5c 60E0      		ldi r22,0
 10046 3a5e 70E0      		ldi r23,0
 10047 3a60 4817      		cp r20,r24
 10048 3a62 5907      		cpc r21,r25
 10049 3a64 6A07      		cpc r22,r26
 10050 3a66 7B07      		cpc r23,r27
 10051 3a68 01F4      		brne .L653
3128:switcherator.c ****             fail(0x12);
 10052               		.loc 1 3128 0
 10053 3a6a 82E1      		ldi r24,lo8(18)
 10054 3a6c 90E0      		ldi r25,0
 10055               	.LVL844:
 10056 3a6e 00C0      		rjmp .L671
 10057               	.LVL845:
 10058               	.L653:
3125:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 10059               		.loc 1 3125 0
 10060 3a70 20E0      		ldi r18,hi8(switchStuff+16)
 10061 3a72 E030      		cpi r30,lo8(switchStuff+16)
 10062 3a74 F207      		cpc r31,r18
 10063 3a76 01F4      		brne .L654
3132:switcherator.c ****     inputs[inputNumber][0] = temp;
 10064               		.loc 1 3132 0
 10065 3a78 93E0      		ldi r25,3
 10066               		1:
 10067 3a7a 000F      		lsl r16
 10068 3a7c 111F      		rol r17
 10069 3a7e 9A95      		dec r25
 10070 3a80 01F4      		brne 1b
 10071               	.LVL846:
 10072 3a82 20E0      		ldi r18,lo8(inputs)
 10073 3a84 222E      		mov r2,r18
 10074 3a86 20E0      		ldi r18,hi8(inputs)
 10075 3a88 322E      		mov r3,r18
 10076 3a8a 200E      		add r2,r16
 10077 3a8c 311E      		adc r3,r17
 10078 3a8e F101      		movw r30,r2
 10079 3a90 8083      		st Z,r24
3133:switcherator.c ****     DDRC &= ~(1 << pin);
 10080               		.loc 1 3133 0
 10081 3a92 27B1      		in r18,0x7
 10082 3a94 81E0      		ldi r24,lo8(1)
 10083 3a96 90E0      		ldi r25,0
 10084               	.LVL847:
 10085 3a98 00C0      		rjmp 2f
 10086               		1:
 10087 3a9a 880F      		lsl r24
 10088               		2:
 10089 3a9c CA94      		dec r12
 10090 3a9e 02F4      		brpl 1b
 10091 3aa0 8095      		com r24
 10092 3aa2 8223      		and r24,r18
 10093 3aa4 87B9      		out 0x7,r24
 10094               	.LVL848:
3135:switcherator.c ****     temp = temp * 255;
 10095               		.loc 1 3135 0
 10096 3aa6 2FEF      		ldi r18,lo8(-1)
 10097 3aa8 30E0      		ldi r19,0
 10098 3aaa D501      		movw r26,r10
 10099 3aac 0E94 0000 		call __usmulhisi3
 10100               	.LVL849:
3136:switcherator.c ****     temp = temp / 100;
 10101               		.loc 1 3136 0
 10102 3ab0 34E6      		ldi r19,lo8(100)
 10103 3ab2 A32E      		mov r10,r19
 10104 3ab4 B12C      		mov r11,__zero_reg__
 10105 3ab6 C12C      		mov r12,__zero_reg__
 10106 3ab8 D12C      		mov r13,__zero_reg__
 10107               	.LVL850:
 10108 3aba A601      		movw r20,r12
 10109 3abc 9501      		movw r18,r10
 10110 3abe 0E94 0000 		call __divmodsi4
 10111               	.LVL851:
3137:switcherator.c ****     inputs[inputNumber][1] = temp;
 10112               		.loc 1 3137 0
 10113 3ac2 D101      		movw r26,r2
 10114 3ac4 1196      		adiw r26,1
 10115 3ac6 2C93      		st X,r18
 10116               	.LVL852:
3139:switcherator.c ****     temp = temp * 255;
 10117               		.loc 1 3139 0
 10118 3ac8 2FEF      		ldi r18,lo8(-1)
 10119 3aca 30E0      		ldi r19,0
 10120 3acc D201      		movw r26,r4
 10121 3ace 0E94 0000 		call __usmulhisi3
 10122               	.LVL853:
3140:switcherator.c ****     temp = temp / 100;
 10123               		.loc 1 3140 0
 10124 3ad2 A601      		movw r20,r12
 10125 3ad4 9501      		movw r18,r10
 10126 3ad6 0E94 0000 		call __divmodsi4
 10127               	.LVL854:
3141:switcherator.c ****     if (temp == 255) // if the top is 255 we need it to be 254 so its not digital
 10128               		.loc 1 3141 0
 10129 3ada 2F3F      		cpi r18,-1
 10130 3adc 3105      		cpc r19,__zero_reg__
 10131 3ade 4105      		cpc r20,__zero_reg__
 10132 3ae0 5105      		cpc r21,__zero_reg__
 10133 3ae2 01F4      		brne .L655
3142:switcherator.c ****         temp = 254;
 10134               		.loc 1 3142 0
 10135 3ae4 2EEF      		ldi r18,lo8(-2)
 10136 3ae6 30E0      		ldi r19,0
 10137 3ae8 40E0      		ldi r20,0
 10138 3aea 50E0      		ldi r21,0
 10139               	.LVL855:
 10140               	.L655:
3144:switcherator.c ****     inputs[inputNumber][2] = temp;
 10141               		.loc 1 3144 0
 10142 3aec F801      		movw r30,r16
 10143 3aee E050      		subi r30,lo8(-(inputs))
 10144 3af0 F040      		sbci r31,hi8(-(inputs))
 10145 3af2 2283      		std Z+2,r18
3146:switcherator.c ****     if (commandReceived[13] == 'P' || commandReceived[13] == 'p') {
 10146               		.loc 1 3146 0
 10147 3af4 EA81      		ldd r30,Y+2
 10148 3af6 FB81      		ldd r31,Y+3
 10149 3af8 8585      		ldd r24,Z+13
 10150 3afa 8035      		cpi r24,lo8(80)
 10151 3afc 01F0      		breq .L656
3146:switcherator.c ****     if (commandReceived[13] == 'P' || commandReceived[13] == 'p') {
 10152               		.loc 1 3146 0 is_stmt 0 discriminator 1
 10153 3afe 8037      		cpi r24,lo8(112)
 10154 3b00 01F4      		brne .L657
 10155               	.L656:
3147:switcherator.c ****         switchNumber += 128;
 10156               		.loc 1 3147 0 is_stmt 1
 10157 3b02 F0E8      		ldi r31,-128
 10158 3b04 EF0E      		add r14,r31
 10159 3b06 F11C      		adc r15,__zero_reg__
 10160               	.LVL856:
 10161               	.L657:
3149:switcherator.c ****     inputs[inputNumber][3] = switchNumber;
 10162               		.loc 1 3149 0
 10163 3b08 F801      		movw r30,r16
 10164 3b0a E050      		subi r30,lo8(-(inputs))
 10165 3b0c F040      		sbci r31,hi8(-(inputs))
 10166 3b0e E382      		std Z+3,r14
 10167               	.LVL857:
3151:switcherator.c ****     inputs[inputNumber][4] = temp;
 10168               		.loc 1 3151 0
 10169 3b10 2981      		ldd r18,Y+1
 10170 3b12 2483      		std Z+4,r18
 10171               	.LVL858:
3153:switcherator.c ****     inputs[inputNumber][5] = temp;
 10172               		.loc 1 3153 0
 10173 3b14 6582      		std Z+5,r6
 10174               	.LVL859:
3158:switcherator.c ****     inputs[inputNumber][6] = pollTime;
 10175               		.loc 1 3158 0
 10176 3b16 872D      		mov r24,r7
 10177 3b18 982D      		mov r25,r8
 10178 3b1a 8F3F      		cpi r24,-1
 10179 3b1c 9105      		cpc r25,__zero_reg__
 10180 3b1e 01F0      		breq .L658
 10181 3b20 04F0      		brlt .L658
 10182 3b22 8FEF      		ldi r24,lo8(-1)
 10183 3b24 90E0      		ldi r25,0
 10184               	.L658:
 10185 3b26 8683      		std Z+6,r24
 10186               	.LVL860:
3163:switcherator.c ****     inputs[inputNumber][7] = whichRGB;
 10187               		.loc 1 3163 0
 10188 3b28 F801      		movw r30,r16
 10189 3b2a E050      		subi r30,lo8(-(inputs))
 10190 3b2c F040      		sbci r31,hi8(-(inputs))
 10191 3b2e 892D      		mov r24,r9
 10192 3b30 8830      		cpi r24,lo8(8)
 10193 3b32 00F0      		brlo .L659
 10194 3b34 87E0      		ldi r24,lo8(7)
 10195               	.L659:
 10196 3b36 8783      		std Z+7,r24
3168:switcherator.c ****     ADCSRA |= (1 << ADPS2) || (1 << ADPS0);
 10197               		.loc 1 3168 0
 10198 3b38 8091 7A00 		lds r24,122
 10199 3b3c 8160      		ori r24,lo8(1)
 10200 3b3e 8093 7A00 		sts 122,r24
 10201               	/* epilogue start */
3172:switcherator.c **** }
 10202               		.loc 1 3172 0
 10203 3b42 0F90      		pop __tmp_reg__
 10204 3b44 0F90      		pop __tmp_reg__
 10205 3b46 0F90      		pop __tmp_reg__
 10206 3b48 DF91      		pop r29
 10207 3b4a CF91      		pop r28
 10208 3b4c 1F91      		pop r17
 10209 3b4e 0F91      		pop r16
 10210 3b50 FF90      		pop r15
 10211 3b52 EF90      		pop r14
 10212 3b54 DF90      		pop r13
 10213 3b56 CF90      		pop r12
 10214 3b58 BF90      		pop r11
 10215 3b5a AF90      		pop r10
 10216 3b5c 9F90      		pop r9
 10217               	.LVL861:
 10218 3b5e 8F90      		pop r8
 10219               	.LVL862:
 10220 3b60 7F90      		pop r7
 10221               	.LVL863:
 10222 3b62 6F90      		pop r6
 10223               	.LVL864:
 10224 3b64 5F90      		pop r5
 10225 3b66 4F90      		pop r4
 10226               	.LVL865:
 10227 3b68 3F90      		pop r3
 10228 3b6a 2F90      		pop r2
3171:switcherator.c ****     ok();
 10229               		.loc 1 3171 0
 10230 3b6c 0C94 0000 		jmp ok
 10231               	.LVL866:
 10232               	.LFE73:
 10234               	.global	startProgram
 10236               	startProgram:
 10237               	.LFB39:
1637:switcherator.c **** void startProgram(char * commandReceived) {
 10238               		.loc 1 1637 0
 10239               	.LVL867:
 10240 3b70 0F93      		push r16
 10241               	.LCFI253:
 10242 3b72 1F93      		push r17
 10243               	.LCFI254:
 10244 3b74 CF93      		push r28
 10245               	.LCFI255:
 10246 3b76 DF93      		push r29
 10247               	.LCFI256:
 10248               	/* prologue: function */
 10249               	/* frame size = 0 */
 10250               	/* stack size = 4 */
 10251               	.L__stack_usage = 4
 10252 3b78 EC01      		movw r28,r24
 10253               	.LVL868:
1641:switcherator.c ****     tempIntString[0] = commandReceived[3];
 10254               		.loc 1 1641 0
 10255 3b7a 8B81      		ldd r24,Y+3
 10256               	.LVL869:
 10257 3b7c 8093 0000 		sts tempIntString,r24
1642:switcherator.c ****     tempIntString[1] = commandReceived[4];
 10258               		.loc 1 1642 0
 10259 3b80 8C81      		ldd r24,Y+4
 10260 3b82 8093 0000 		sts tempIntString+1,r24
1643:switcherator.c ****     programNumber = atoi(tempIntString);
 10261               		.loc 1 1643 0
 10262 3b86 80E0      		ldi r24,lo8(tempIntString)
 10263 3b88 90E0      		ldi r25,hi8(tempIntString)
 10264 3b8a 0E94 0000 		call atoi
 10265               	.LVL870:
 10266 3b8e 8C01      		movw r16,r24
 10267               	.LVL871:
1644:switcherator.c ****     if (programNumber >= MAX_PROGRAM) {
 10268               		.loc 1 1644 0
 10269 3b90 8A30      		cpi r24,10
 10270 3b92 9105      		cpc r25,__zero_reg__
 10271 3b94 04F0      		brlt .L673
1645:switcherator.c ****         fail(2);
 10272               		.loc 1 1645 0
 10273 3b96 82E0      		ldi r24,lo8(2)
 10274 3b98 90E0      		ldi r25,0
 10275               	/* epilogue start */
1658:switcherator.c **** }
 10276               		.loc 1 1658 0
 10277 3b9a DF91      		pop r29
 10278 3b9c CF91      		pop r28
 10279               	.LVL872:
 10280 3b9e 1F91      		pop r17
 10281 3ba0 0F91      		pop r16
 10282               	.LVL873:
1645:switcherator.c ****         fail(2);
 10283               		.loc 1 1645 0
 10284 3ba2 0C94 0000 		jmp fail
 10285               	.LVL874:
 10286               	.L673:
1649:switcherator.c ****     tempHugeString[0] = commandReceived[5];
 10287               		.loc 1 1649 0
 10288 3ba6 8D81      		ldd r24,Y+5
 10289 3ba8 8093 0000 		sts tempHugeString,r24
1650:switcherator.c ****     tempHugeString[1] = commandReceived[6];
 10290               		.loc 1 1650 0
 10291 3bac 8E81      		ldd r24,Y+6
 10292 3bae 8093 0000 		sts tempHugeString+1,r24
1651:switcherator.c ****     tempHugeString[2] = commandReceived[7];
 10293               		.loc 1 1651 0
 10294 3bb2 8F81      		ldd r24,Y+7
 10295 3bb4 8093 0000 		sts tempHugeString+2,r24
1652:switcherator.c ****     tempHugeString[3] = commandReceived[8];
 10296               		.loc 1 1652 0
 10297 3bb8 8885      		ldd r24,Y+8
 10298 3bba 8093 0000 		sts tempHugeString+3,r24
1653:switcherator.c ****     tempHugeString[4] = commandReceived[9];
 10299               		.loc 1 1653 0
 10300 3bbe 8985      		ldd r24,Y+9
 10301 3bc0 8093 0000 		sts tempHugeString+4,r24
1654:switcherator.c ****     tempHugeString[5] = commandReceived[10];
 10302               		.loc 1 1654 0
 10303 3bc4 8A85      		ldd r24,Y+10
 10304 3bc6 8093 0000 		sts tempHugeString+5,r24
1655:switcherator.c ****     duration = atol(tempHugeString);
 10305               		.loc 1 1655 0
 10306 3bca 80E0      		ldi r24,lo8(tempHugeString)
 10307 3bcc 90E0      		ldi r25,hi8(tempHugeString)
 10308 3bce 0E94 0000 		call atol
 10309               	.LVL875:
1656:switcherator.c ****     startTheProgram(programNumber, duration, 0);
 10310               		.loc 1 1656 0
 10311 3bd2 20E0      		ldi r18,0
 10312 3bd4 30E0      		ldi r19,0
 10313 3bd6 A901      		movw r20,r18
 10314 3bd8 C801      		movw r24,r16
 10315 3bda 0E94 0000 		call startTheProgram
 10316               	.LVL876:
 10317               	/* epilogue start */
1658:switcherator.c **** }
 10318               		.loc 1 1658 0
 10319 3bde DF91      		pop r29
 10320 3be0 CF91      		pop r28
 10321               	.LVL877:
 10322 3be2 1F91      		pop r17
 10323 3be4 0F91      		pop r16
 10324               	.LVL878:
1657:switcherator.c ****     ok();
 10325               		.loc 1 1657 0
 10326 3be6 0C94 0000 		jmp ok
 10327               	.LVL879:
 10328               	.LFE39:
 10330               	.global	programSetTime
 10332               	programSetTime:
 10333               	.LFB36:
1442:switcherator.c **** void programSetTime(char * commandReceived) {
 10334               		.loc 1 1442 0
 10335               	.LVL880:
 10336 3bea AF92      		push r10
 10337               	.LCFI257:
 10338 3bec BF92      		push r11
 10339               	.LCFI258:
 10340 3bee CF92      		push r12
 10341               	.LCFI259:
 10342 3bf0 DF92      		push r13
 10343               	.LCFI260:
 10344 3bf2 EF92      		push r14
 10345               	.LCFI261:
 10346 3bf4 FF92      		push r15
 10347               	.LCFI262:
 10348 3bf6 0F93      		push r16
 10349               	.LCFI263:
 10350 3bf8 1F93      		push r17
 10351               	.LCFI264:
 10352 3bfa CF93      		push r28
 10353               	.LCFI265:
 10354 3bfc DF93      		push r29
 10355               	.LCFI266:
 10356               	/* prologue: function */
 10357               	/* frame size = 0 */
 10358               	/* stack size = 10 */
 10359               	.L__stack_usage = 10
 10360 3bfe EC01      		movw r28,r24
 10361               	.LVL881:
1448:switcherator.c ****     tempIntString[0] = commandReceived[3];
 10362               		.loc 1 1448 0
 10363 3c00 8B81      		ldd r24,Y+3
 10364               	.LVL882:
 10365 3c02 8093 0000 		sts tempIntString,r24
1449:switcherator.c ****     tempIntString[1] = commandReceived[4];
 10366               		.loc 1 1449 0
 10367 3c06 FC80      		ldd r15,Y+4
 10368 3c08 F092 0000 		sts tempIntString+1,r15
1450:switcherator.c ****     programNumber = atoi(tempIntString);
 10369               		.loc 1 1450 0
 10370 3c0c 80E0      		ldi r24,lo8(tempIntString)
 10371 3c0e 90E0      		ldi r25,hi8(tempIntString)
 10372 3c10 0E94 0000 		call atoi
 10373               	.LVL883:
 10374 3c14 8C01      		movw r16,r24
 10375               	.LVL884:
1451:switcherator.c ****     if (programNumber >= MAX_PROGRAM || (programNumber == 0 && commandReceived[4] != '0')) {
 10376               		.loc 1 1451 0
 10377 3c16 8A30      		cpi r24,10
 10378 3c18 9105      		cpc r25,__zero_reg__
 10379 3c1a 04F4      		brge .L675
1451:switcherator.c ****     if (programNumber >= MAX_PROGRAM || (programNumber == 0 && commandReceived[4] != '0')) {
 10380               		.loc 1 1451 0 is_stmt 0 discriminator 1
 10381 3c1c 0097      		sbiw r24,0
 10382 3c1e 01F4      		brne .L676
 10383 3c20 20E3      		ldi r18,lo8(48)
 10384 3c22 F216      		cp r15,r18
 10385 3c24 01F0      		breq .L676
 10386               	.L675:
1452:switcherator.c ****         fail(2);
 10387               		.loc 1 1452 0 is_stmt 1
 10388 3c26 82E0      		ldi r24,lo8(2)
 10389 3c28 90E0      		ldi r25,0
 10390 3c2a 00C0      		rjmp .L692
 10391               	.L676:
1459:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 10392               		.loc 1 1459 0
 10393 3c2c 8AE0      		ldi r24,lo8(10)
 10394 3c2e 809F      		mul r24,r16
 10395 3c30 F001      		movw r30,r0
 10396 3c32 819F      		mul r24,r17
 10397 3c34 F00D      		add r31,r0
 10398 3c36 1124      		clr __zero_reg__
 10399 3c38 E050      		subi r30,lo8(-(weeklyProgram))
 10400 3c3a F040      		sbci r31,hi8(-(weeklyProgram))
 10401 3c3c 8081      		ld r24,Z
 10402 3c3e 8F3F      		cpi r24,lo8(-1)
 10403 3c40 01F4      		brne .L677
1459:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 10404               		.loc 1 1459 0 is_stmt 0 discriminator 1
 10405 3c42 8181      		ldd r24,Z+1
 10406 3c44 8F3F      		cpi r24,lo8(-1)
 10407 3c46 01F4      		brne .L677
1460:switcherator.c ****         fail(0x0d);
 10408               		.loc 1 1460 0 is_stmt 1
 10409 3c48 8DE0      		ldi r24,lo8(13)
 10410 3c4a 90E0      		ldi r25,0
 10411               	.LVL885:
 10412               	.L692:
 10413               	/* epilogue start */
1499:switcherator.c **** }
 10414               		.loc 1 1499 0
 10415 3c4c DF91      		pop r29
 10416 3c4e CF91      		pop r28
 10417               	.LVL886:
 10418 3c50 1F91      		pop r17
 10419 3c52 0F91      		pop r16
 10420               	.LVL887:
 10421 3c54 FF90      		pop r15
 10422 3c56 EF90      		pop r14
 10423 3c58 DF90      		pop r13
 10424 3c5a CF90      		pop r12
 10425 3c5c BF90      		pop r11
 10426 3c5e AF90      		pop r10
1460:switcherator.c ****         fail(0x0d);
 10427               		.loc 1 1460 0
 10428 3c60 0C94 0000 		jmp fail
 10429               	.LVL888:
 10430               	.L677:
1463:switcherator.c ****     tempIntString[0] = commandReceived[5];
 10431               		.loc 1 1463 0
 10432 3c64 8D81      		ldd r24,Y+5
 10433 3c66 8093 0000 		sts tempIntString,r24
1464:switcherator.c ****     tempIntString[1] = commandReceived[6];
 10434               		.loc 1 1464 0
 10435 3c6a AE80      		ldd r10,Y+6
 10436 3c6c A092 0000 		sts tempIntString+1,r10
1465:switcherator.c ****     hours = atoi(tempIntString);
 10437               		.loc 1 1465 0
 10438 3c70 80E0      		ldi r24,lo8(tempIntString)
 10439 3c72 90E0      		ldi r25,hi8(tempIntString)
 10440 3c74 0E94 0000 		call atoi
 10441               	.LVL889:
 10442 3c78 6C01      		movw r12,r24
 10443               	.LVL890:
1466:switcherator.c ****     tempIntString[0] = commandReceived[7];
 10444               		.loc 1 1466 0
 10445 3c7a 8F81      		ldd r24,Y+7
 10446 3c7c 8093 0000 		sts tempIntString,r24
1467:switcherator.c ****     tempIntString[1] = commandReceived[8];
 10447               		.loc 1 1467 0
 10448 3c80 B884      		ldd r11,Y+8
 10449 3c82 B092 0000 		sts tempIntString+1,r11
1468:switcherator.c ****     minutes = atoi(tempIntString);
 10450               		.loc 1 1468 0
 10451 3c86 80E0      		ldi r24,lo8(tempIntString)
 10452 3c88 90E0      		ldi r25,hi8(tempIntString)
 10453 3c8a 0E94 0000 		call atoi
 10454               	.LVL891:
 10455 3c8e 7C01      		movw r14,r24
 10456               	.LVL892:
1469:switcherator.c ****     tempLongString[0] = commandReceived[9];
 10457               		.loc 1 1469 0
 10458 3c90 8985      		ldd r24,Y+9
 10459 3c92 8093 0000 		sts tempLongString,r24
1470:switcherator.c ****     tempLongString[1] = commandReceived[10];
 10460               		.loc 1 1470 0
 10461 3c96 8A85      		ldd r24,Y+10
 10462 3c98 8093 0000 		sts tempLongString+1,r24
1471:switcherator.c ****     tempLongString[2] = commandReceived[11];
 10463               		.loc 1 1471 0
 10464 3c9c 8B85      		ldd r24,Y+11
 10465 3c9e 8093 0000 		sts tempLongString+2,r24
1472:switcherator.c ****     tempLongString[3] = commandReceived[12];
 10466               		.loc 1 1472 0
 10467 3ca2 8C85      		ldd r24,Y+12
 10468 3ca4 8093 0000 		sts tempLongString+3,r24
1473:switcherator.c ****     duration = atoi(tempLongString);
 10469               		.loc 1 1473 0
 10470 3ca8 80E0      		ldi r24,lo8(tempLongString)
 10471 3caa 90E0      		ldi r25,hi8(tempLongString)
 10472 3cac 0E94 0000 		call atoi
 10473               	.LVL893:
1474:switcherator.c ****     if (hours >= 24 || (hours == 0 && commandReceived[6] != '0')) {
 10474               		.loc 1 1474 0
 10475 3cb0 28E1      		ldi r18,24
 10476 3cb2 C216      		cp r12,r18
 10477 3cb4 D104      		cpc r13,__zero_reg__
 10478 3cb6 04F4      		brge .L678
1474:switcherator.c ****     if (hours >= 24 || (hours == 0 && commandReceived[6] != '0')) {
 10479               		.loc 1 1474 0 is_stmt 0 discriminator 1
 10480 3cb8 C114      		cp r12,__zero_reg__
 10481 3cba D104      		cpc r13,__zero_reg__
 10482 3cbc 01F4      		brne .L679
 10483 3cbe 20E3      		ldi r18,lo8(48)
 10484 3cc0 A216      		cp r10,r18
 10485 3cc2 01F0      		breq .L679
 10486               	.L678:
1475:switcherator.c ****         fail(9);
 10487               		.loc 1 1475 0 is_stmt 1
 10488 3cc4 89E0      		ldi r24,lo8(9)
 10489 3cc6 90E0      		ldi r25,0
 10490               	.LVL894:
 10491 3cc8 00C0      		rjmp .L692
 10492               	.LVL895:
 10493               	.L679:
1478:switcherator.c ****     if (minutes >= 60 || (minutes == 0 && commandReceived[8] != '0')) {
 10494               		.loc 1 1478 0
 10495 3cca 2CE3      		ldi r18,60
 10496 3ccc E216      		cp r14,r18
 10497 3cce F104      		cpc r15,__zero_reg__
 10498 3cd0 04F4      		brge .L680
1478:switcherator.c ****     if (minutes >= 60 || (minutes == 0 && commandReceived[8] != '0')) {
 10499               		.loc 1 1478 0 is_stmt 0 discriminator 1
 10500 3cd2 E114      		cp r14,__zero_reg__
 10501 3cd4 F104      		cpc r15,__zero_reg__
 10502 3cd6 01F4      		brne .L681
 10503 3cd8 20E3      		ldi r18,lo8(48)
 10504 3cda B216      		cp r11,r18
 10505 3cdc 01F0      		breq .L681
 10506               	.L680:
1479:switcherator.c ****         fail(0x0a);
 10507               		.loc 1 1479 0 is_stmt 1
 10508 3cde 8AE0      		ldi r24,lo8(10)
 10509 3ce0 90E0      		ldi r25,0
 10510               	.LVL896:
 10511 3ce2 00C0      		rjmp .L692
 10512               	.LVL897:
 10513               	.L681:
1482:switcherator.c ****     if (duration == 0) {
 10514               		.loc 1 1482 0
 10515 3ce4 0097      		sbiw r24,0
 10516 3ce6 01F4      		brne .L682
1483:switcherator.c ****         fail(0x0b);
 10517               		.loc 1 1483 0
 10518 3ce8 8BE0      		ldi r24,lo8(11)
 10519 3cea 90E0      		ldi r25,0
 10520               	.LVL898:
 10521 3cec 00C0      		rjmp .L692
 10522               	.LVL899:
 10523               	.L682:
1486:switcherator.c ****     duration *= 60; // convert to seconds
 10524               		.loc 1 1486 0
 10525 3cee 6CE3      		ldi r22,lo8(60)
 10526 3cf0 689F      		mul r22,r24
 10527 3cf2 A001      		movw r20,r0
 10528 3cf4 699F      		mul r22,r25
 10529 3cf6 500D      		add r21,r0
 10530 3cf8 1124      		clr __zero_reg__
 10531               	.LVL900:
1487:switcherator.c ****     startTime = (hours * 60);
 10532               		.loc 1 1487 0
 10533 3cfa 6C9D      		mul r22,r12
 10534 3cfc 9001      		movw r18,r0
 10535 3cfe 6D9D      		mul r22,r13
 10536 3d00 300D      		add r19,r0
 10537 3d02 1124      		clr __zero_reg__
 10538               	.LVL901:
1488:switcherator.c ****     startTime += minutes; // stored in minutes
 10539               		.loc 1 1488 0
 10540 3d04 2E0D      		add r18,r14
 10541 3d06 3F1D      		adc r19,r15
 10542               	.LVL902:
1491:switcherator.c ****     weeklyProgram[programNumber][1] = temp;
 10543               		.loc 1 1491 0
 10544 3d08 8AE0      		ldi r24,lo8(10)
 10545 3d0a 809F      		mul r24,r16
 10546 3d0c F001      		movw r30,r0
 10547 3d0e 819F      		mul r24,r17
 10548 3d10 F00D      		add r31,r0
 10549 3d12 1124      		clr __zero_reg__
 10550 3d14 E050      		subi r30,lo8(-(weeklyProgram))
 10551 3d16 F040      		sbci r31,hi8(-(weeklyProgram))
 10552 3d18 3183      		std Z+1,r19
 10553               	.LVL903:
1493:switcherator.c ****     weeklyProgram[programNumber][2] = temp;
 10554               		.loc 1 1493 0
 10555 3d1a 2283      		std Z+2,r18
 10556               	.LVL904:
1495:switcherator.c ****     weeklyProgram[programNumber][3] = temp;
 10557               		.loc 1 1495 0
 10558 3d1c 5383      		std Z+3,r21
 10559               	.LVL905:
1496:switcherator.c ****     temp = (duration & 0xff);
 10560               		.loc 1 1496 0
 10561 3d1e 5527      		clr r21
 10562               	.LVL906:
1497:switcherator.c ****     weeklyProgram[programNumber][4] = temp;
 10563               		.loc 1 1497 0
 10564 3d20 4483      		std Z+4,r20
 10565               	/* epilogue start */
1499:switcherator.c **** }
 10566               		.loc 1 1499 0
 10567 3d22 DF91      		pop r29
 10568 3d24 CF91      		pop r28
 10569               	.LVL907:
 10570 3d26 1F91      		pop r17
 10571 3d28 0F91      		pop r16
 10572               	.LVL908:
 10573 3d2a FF90      		pop r15
 10574 3d2c EF90      		pop r14
 10575               	.LVL909:
 10576 3d2e DF90      		pop r13
 10577 3d30 CF90      		pop r12
 10578               	.LVL910:
 10579 3d32 BF90      		pop r11
 10580 3d34 AF90      		pop r10
1498:switcherator.c ****     ok();
 10581               		.loc 1 1498 0
 10582 3d36 0C94 0000 		jmp ok
 10583               	.LVL911:
 10584               	.LFE36:
 10586               		.section	.rodata.str1.1
 10587               	.LC69:
 10588 0154 3030 3030 		.string	"0000000"
 10588      3030 3000 
 10589               		.text
 10590               	.global	programSetDays
 10592               	programSetDays:
 10593               	.LFB35:
1401:switcherator.c **** void programSetDays(char * commandReceived) {
 10594               		.loc 1 1401 0
 10595               	.LVL912:
 10596 3d3a EF92      		push r14
 10597               	.LCFI267:
 10598 3d3c FF92      		push r15
 10599               	.LCFI268:
 10600 3d3e 0F93      		push r16
 10601               	.LCFI269:
 10602 3d40 1F93      		push r17
 10603               	.LCFI270:
 10604 3d42 CF93      		push r28
 10605               	.LCFI271:
 10606 3d44 DF93      		push r29
 10607               	.LCFI272:
 10608 3d46 CDB7      		in r28,__SP_L__
 10609 3d48 DEB7      		in r29,__SP_H__
 10610               	.LCFI273:
 10611 3d4a 2897      		sbiw r28,8
 10612               	.LCFI274:
 10613 3d4c 0FB6      		in __tmp_reg__,__SREG__
 10614 3d4e F894      		cli
 10615 3d50 DEBF      		out __SP_H__,r29
 10616 3d52 0FBE      		out __SREG__,__tmp_reg__
 10617 3d54 CDBF      		out __SP_L__,r28
 10618               	/* prologue: function */
 10619               	/* frame size = 8 */
 10620               	/* stack size = 14 */
 10621               	.L__stack_usage = 14
 10622 3d56 7C01      		movw r14,r24
1402:switcherator.c ****     char tempReallyLongString[] = "0000000";
 10623               		.loc 1 1402 0
 10624 3d58 88E0      		ldi r24,lo8(8)
 10625               	.LVL913:
 10626 3d5a E0E0      		ldi r30,lo8(.LC69)
 10627 3d5c F0E0      		ldi r31,hi8(.LC69)
 10628 3d5e DE01      		movw r26,r28
 10629 3d60 1196      		adiw r26,1
 10630               		0:
 10631 3d62 0190      		ld r0,Z+
 10632 3d64 0D92      		st X+,r0
 10633 3d66 8A95      		dec r24
 10634 3d68 01F4      		brne 0b
 10635               	.LVL914:
1405:switcherator.c ****     tempIntString[0] = commandReceived[3];
 10636               		.loc 1 1405 0
 10637 3d6a F701      		movw r30,r14
 10638 3d6c 8381      		ldd r24,Z+3
 10639 3d6e 8093 0000 		sts tempIntString,r24
1406:switcherator.c ****     tempIntString[1] = commandReceived[4];
 10640               		.loc 1 1406 0
 10641 3d72 8481      		ldd r24,Z+4
 10642 3d74 8093 0000 		sts tempIntString+1,r24
1407:switcherator.c ****     programNumber = atoi(tempIntString);
 10643               		.loc 1 1407 0
 10644 3d78 80E0      		ldi r24,lo8(tempIntString)
 10645 3d7a 90E0      		ldi r25,hi8(tempIntString)
 10646 3d7c 0E94 0000 		call atoi
 10647               	.LVL915:
 10648 3d80 8C01      		movw r16,r24
 10649               	.LVL916:
1408:switcherator.c ****     tempReallyLongString[0] = commandReceived[5];
 10650               		.loc 1 1408 0
 10651 3d82 F701      		movw r30,r14
 10652 3d84 8581      		ldd r24,Z+5
 10653 3d86 8983      		std Y+1,r24
1409:switcherator.c ****     tempReallyLongString[1] = commandReceived[6];
 10654               		.loc 1 1409 0
 10655 3d88 8681      		ldd r24,Z+6
 10656 3d8a 8A83      		std Y+2,r24
1410:switcherator.c ****     tempReallyLongString[2] = commandReceived[7];
 10657               		.loc 1 1410 0
 10658 3d8c 8781      		ldd r24,Z+7
 10659 3d8e 8B83      		std Y+3,r24
1411:switcherator.c ****     tempReallyLongString[3] = commandReceived[8];
 10660               		.loc 1 1411 0
 10661 3d90 8085      		ldd r24,Z+8
 10662 3d92 8C83      		std Y+4,r24
1412:switcherator.c ****     tempReallyLongString[4] = commandReceived[9];
 10663               		.loc 1 1412 0
 10664 3d94 8185      		ldd r24,Z+9
 10665 3d96 8D83      		std Y+5,r24
1413:switcherator.c ****     tempReallyLongString[5] = commandReceived[10];
 10666               		.loc 1 1413 0
 10667 3d98 8285      		ldd r24,Z+10
 10668 3d9a 8E83      		std Y+6,r24
1414:switcherator.c ****     tempReallyLongString[6] = commandReceived[11];
 10669               		.loc 1 1414 0
 10670 3d9c 8385      		ldd r24,Z+11
 10671 3d9e 8F83      		std Y+7,r24
1415:switcherator.c ****     weekLong = strtol(tempReallyLongString, 0, 2);
 10672               		.loc 1 1415 0
 10673 3da0 42E0      		ldi r20,lo8(2)
 10674 3da2 50E0      		ldi r21,0
 10675 3da4 60E0      		ldi r22,0
 10676 3da6 70E0      		ldi r23,0
 10677 3da8 CE01      		movw r24,r28
 10678 3daa 0196      		adiw r24,1
 10679 3dac 0E94 0000 		call strtol
 10680               	.LVL917:
1416:switcherator.c ****     if ((programNumber >= MAX_PROGRAM) || (programNumber == 0 && commandReceived[4] != '0')) {
 10681               		.loc 1 1416 0
 10682 3db0 0A30      		cpi r16,10
 10683 3db2 1105      		cpc r17,__zero_reg__
 10684 3db4 04F4      		brge .L694
1416:switcherator.c ****     if ((programNumber >= MAX_PROGRAM) || (programNumber == 0 && commandReceived[4] != '0')) {
 10685               		.loc 1 1416 0 is_stmt 0 discriminator 1
 10686 3db6 0115      		cp r16,__zero_reg__
 10687 3db8 1105      		cpc r17,__zero_reg__
 10688 3dba 01F4      		brne .L695
 10689 3dbc F701      		movw r30,r14
 10690 3dbe 2481      		ldd r18,Z+4
 10691 3dc0 2033      		cpi r18,lo8(48)
 10692 3dc2 01F0      		breq .L695
 10693               	.L694:
1417:switcherator.c ****         fail(2);
 10694               		.loc 1 1417 0 is_stmt 1
 10695 3dc4 82E0      		ldi r24,lo8(2)
 10696 3dc6 90E0      		ldi r25,0
 10697 3dc8 00C0      		rjmp .L703
 10698               	.L695:
1424:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 10699               		.loc 1 1424 0
 10700 3dca 2AE0      		ldi r18,lo8(10)
 10701 3dcc 209F      		mul r18,r16
 10702 3dce F001      		movw r30,r0
 10703 3dd0 219F      		mul r18,r17
 10704 3dd2 F00D      		add r31,r0
 10705 3dd4 1124      		clr __zero_reg__
 10706 3dd6 E050      		subi r30,lo8(-(weeklyProgram))
 10707 3dd8 F040      		sbci r31,hi8(-(weeklyProgram))
 10708 3dda 2081      		ld r18,Z
 10709 3ddc 2F3F      		cpi r18,lo8(-1)
 10710 3dde 01F4      		brne .L697
1424:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 10711               		.loc 1 1424 0 is_stmt 0 discriminator 1
 10712 3de0 2181      		ldd r18,Z+1
 10713 3de2 2F3F      		cpi r18,lo8(-1)
 10714 3de4 01F4      		brne .L697
1425:switcherator.c ****         fail(0x0d);
 10715               		.loc 1 1425 0 is_stmt 1
 10716 3de6 8DE0      		ldi r24,lo8(13)
 10717 3de8 90E0      		ldi r25,0
 10718 3dea 00C0      		rjmp .L703
 10719               	.L697:
1428:switcherator.c ****     if ((weekLong & 0x7f) == 0) {
 10720               		.loc 1 1428 0
 10721 3dec AB01      		movw r20,r22
 10722 3dee BC01      		movw r22,r24
 10723 3df0 4F77      		andi r20,127
 10724 3df2 5527      		clr r21
 10725 3df4 6627      		clr r22
 10726 3df6 7727      		clr r23
 10727 3df8 4115      		cp r20,__zero_reg__
 10728 3dfa 5105      		cpc r21,__zero_reg__
 10729 3dfc 6105      		cpc r22,__zero_reg__
 10730 3dfe 7105      		cpc r23,__zero_reg__
 10731 3e00 01F4      		brne .L698
1429:switcherator.c ****         fail(0x0f);
 10732               		.loc 1 1429 0
 10733 3e02 8FE0      		ldi r24,lo8(15)
 10734 3e04 90E0      		ldi r25,0
 10735               	.L703:
 10736 3e06 0E94 0000 		call fail
 10737               	.LVL918:
 10738 3e0a 00C0      		rjmp .L693
 10739               	.LVL919:
 10740               	.L698:
1433:switcherator.c ****     weeklyProgram[programNumber][0] = weekdays;
 10741               		.loc 1 1433 0
 10742 3e0c 8AE0      		ldi r24,lo8(10)
 10743 3e0e 809F      		mul r24,r16
 10744 3e10 F001      		movw r30,r0
 10745 3e12 819F      		mul r24,r17
 10746 3e14 F00D      		add r31,r0
 10747 3e16 1124      		clr __zero_reg__
 10748 3e18 E050      		subi r30,lo8(-(weeklyProgram))
 10749 3e1a F040      		sbci r31,hi8(-(weeklyProgram))
1432:switcherator.c ****     char weekdays = (weekLong & 0x7f);
 10750               		.loc 1 1432 0
 10751 3e1c 4083      		st Z,r20
1434:switcherator.c ****     ok();
 10752               		.loc 1 1434 0
 10753 3e1e 0E94 0000 		call ok
 10754               	.LVL920:
 10755               	.L693:
 10756               	/* epilogue start */
1435:switcherator.c **** }
 10757               		.loc 1 1435 0
 10758 3e22 2896      		adiw r28,8
 10759 3e24 0FB6      		in __tmp_reg__,__SREG__
 10760 3e26 F894      		cli
 10761 3e28 DEBF      		out __SP_H__,r29
 10762 3e2a 0FBE      		out __SREG__,__tmp_reg__
 10763 3e2c CDBF      		out __SP_L__,r28
 10764 3e2e DF91      		pop r29
 10765 3e30 CF91      		pop r28
 10766 3e32 1F91      		pop r17
 10767 3e34 0F91      		pop r16
 10768               	.LVL921:
 10769 3e36 FF90      		pop r15
 10770 3e38 EF90      		pop r14
 10771               	.LVL922:
 10772 3e3a 0895      		ret
 10773               	.LFE35:
 10775               	.global	programAddSwitch
 10777               	programAddSwitch:
 10778               	.LFB33:
1296:switcherator.c **** void programAddSwitch(char * commandReceived) {
 10779               		.loc 1 1296 0
 10780               	.LVL923:
 10781 3e3c CF92      		push r12
 10782               	.LCFI275:
 10783 3e3e DF92      		push r13
 10784               	.LCFI276:
 10785 3e40 EF92      		push r14
 10786               	.LCFI277:
 10787 3e42 FF92      		push r15
 10788               	.LCFI278:
 10789 3e44 0F93      		push r16
 10790               	.LCFI279:
 10791 3e46 1F93      		push r17
 10792               	.LCFI280:
 10793 3e48 CF93      		push r28
 10794               	.LCFI281:
 10795 3e4a DF93      		push r29
 10796               	.LCFI282:
 10797 3e4c CDB7      		in r28,__SP_L__
 10798 3e4e DEB7      		in r29,__SP_H__
 10799               	.LCFI283:
 10800 3e50 6097      		sbiw r28,16
 10801               	.LCFI284:
 10802 3e52 0FB6      		in __tmp_reg__,__SREG__
 10803 3e54 F894      		cli
 10804 3e56 DEBF      		out __SP_H__,r29
 10805 3e58 0FBE      		out __SREG__,__tmp_reg__
 10806 3e5a CDBF      		out __SP_L__,r28
 10807               	/* prologue: function */
 10808               	/* frame size = 16 */
 10809               	/* stack size = 24 */
 10810               	.L__stack_usage = 24
 10811 3e5c 7C01      		movw r14,r24
 10812               	.LVL924:
1299:switcherator.c ****     tempIntString[0] = commandReceived[3];
 10813               		.loc 1 1299 0
 10814 3e5e FC01      		movw r30,r24
 10815 3e60 8381      		ldd r24,Z+3
 10816               	.LVL925:
 10817 3e62 8093 0000 		sts tempIntString,r24
1300:switcherator.c ****     tempIntString[1] = commandReceived[4];
 10818               		.loc 1 1300 0
 10819 3e66 8481      		ldd r24,Z+4
 10820 3e68 8093 0000 		sts tempIntString+1,r24
1301:switcherator.c ****     programNumber = atoi(tempIntString);
 10821               		.loc 1 1301 0
 10822 3e6c 80E0      		ldi r24,lo8(tempIntString)
 10823 3e6e 90E0      		ldi r25,hi8(tempIntString)
 10824 3e70 0E94 0000 		call atoi
 10825               	.LVL926:
 10826 3e74 8C01      		movw r16,r24
 10827               	.LVL927:
1302:switcherator.c ****     tempIntString[0] = commandReceived[5];
 10828               		.loc 1 1302 0
 10829 3e76 F701      		movw r30,r14
 10830 3e78 8581      		ldd r24,Z+5
 10831 3e7a 8093 0000 		sts tempIntString,r24
1303:switcherator.c ****     tempIntString[1] = commandReceived[6];
 10832               		.loc 1 1303 0
 10833 3e7e 8681      		ldd r24,Z+6
 10834 3e80 8093 0000 		sts tempIntString+1,r24
1304:switcherator.c ****     switchNumber = atoi(tempIntString);
 10835               		.loc 1 1304 0
 10836 3e84 80E0      		ldi r24,lo8(tempIntString)
 10837 3e86 90E0      		ldi r25,hi8(tempIntString)
 10838 3e88 0E94 0000 		call atoi
 10839               	.LVL928:
 10840 3e8c 6C01      		movw r12,r24
 10841               	.LVL929:
1306:switcherator.c ****     switches[0] = 0;
 10842               		.loc 1 1306 0
 10843 3e8e 1982      		std Y+1,__zero_reg__
1307:switcherator.c ****     int switchCount = programGetSwitches(programNumber, switches);
 10844               		.loc 1 1307 0
 10845 3e90 BE01      		movw r22,r28
 10846 3e92 6F5F      		subi r22,-1
 10847 3e94 7F4F      		sbci r23,-1
 10848 3e96 C801      		movw r24,r16
 10849 3e98 0E94 0000 		call programGetSwitches
 10850               	.LVL930:
 10851 3e9c FE01      		movw r30,r28
 10852 3e9e 3196      		adiw r30,1
1296:switcherator.c **** void programAddSwitch(char * commandReceived) {
 10853               		.loc 1 1296 0
 10854 3ea0 AF01      		movw r20,r30
1310:switcherator.c ****     for (x = 0; x < switchCount; x++) {
 10855               		.loc 1 1310 0
 10856 3ea2 00C0      		rjmp .L705
 10857               	.LVL931:
 10858               	.L707:
1311:switcherator.c ****         if (switches[x] == switchNumber) {
 10859               		.loc 1 1311 0
 10860 3ea4 2191      		ld r18,Z+
 10861 3ea6 30E0      		ldi r19,0
 10862 3ea8 2C15      		cp r18,r12
 10863 3eaa 3D05      		cpc r19,r13
 10864 3eac 01F4      		brne .L705
1312:switcherator.c ****             fail(0x0c);
 10865               		.loc 1 1312 0
 10866 3eae 8CE0      		ldi r24,lo8(12)
 10867 3eb0 90E0      		ldi r25,0
 10868               	.LVL932:
 10869 3eb2 00C0      		rjmp .L731
 10870               	.LVL933:
 10871               	.L705:
1296:switcherator.c **** void programAddSwitch(char * commandReceived) {
 10872               		.loc 1 1296 0 discriminator 1
 10873 3eb4 9F01      		movw r18,r30
 10874 3eb6 241B      		sub r18,r20
 10875 3eb8 350B      		sbc r19,r21
1310:switcherator.c ****     for (x = 0; x < switchCount; x++) {
 10876               		.loc 1 1310 0 discriminator 1
 10877 3eba 2817      		cp r18,r24
 10878 3ebc 3907      		cpc r19,r25
 10879 3ebe 04F0      		brlt .L707
1318:switcherator.c ****     if ((programNumber >= MAX_PROGRAM) || (programNumber == 0 && commandReceived[4] != '0')) {
 10880               		.loc 1 1318 0
 10881 3ec0 0A30      		cpi r16,10
 10882 3ec2 1105      		cpc r17,__zero_reg__
 10883 3ec4 04F4      		brge .L708
1318:switcherator.c ****     if ((programNumber >= MAX_PROGRAM) || (programNumber == 0 && commandReceived[4] != '0')) {
 10884               		.loc 1 1318 0 is_stmt 0 discriminator 1
 10885 3ec6 0115      		cp r16,__zero_reg__
 10886 3ec8 1105      		cpc r17,__zero_reg__
 10887 3eca 01F4      		brne .L709
 10888 3ecc F701      		movw r30,r14
 10889 3ece 8481      		ldd r24,Z+4
 10890               	.LVL934:
 10891 3ed0 8033      		cpi r24,lo8(48)
 10892 3ed2 01F0      		breq .L709
 10893               	.L708:
1319:switcherator.c ****         fail(2);
 10894               		.loc 1 1319 0 is_stmt 1
 10895 3ed4 82E0      		ldi r24,lo8(2)
 10896 3ed6 90E0      		ldi r25,0
 10897 3ed8 00C0      		rjmp .L731
 10898               	.L709:
1322:switcherator.c ****     if ((switchNumber >= NUM_SWITCHES) || (switchNumber == 0 && commandReceived[6] != '0')) {
 10899               		.loc 1 1322 0
 10900 3eda F0E1      		ldi r31,16
 10901 3edc CF16      		cp r12,r31
 10902 3ede D104      		cpc r13,__zero_reg__
 10903 3ee0 04F4      		brge .L710
1322:switcherator.c ****     if ((switchNumber >= NUM_SWITCHES) || (switchNumber == 0 && commandReceived[6] != '0')) {
 10904               		.loc 1 1322 0 is_stmt 0 discriminator 1
 10905 3ee2 C114      		cp r12,__zero_reg__
 10906 3ee4 D104      		cpc r13,__zero_reg__
 10907 3ee6 01F4      		brne .L711
 10908 3ee8 F701      		movw r30,r14
 10909 3eea 8681      		ldd r24,Z+6
 10910 3eec 8033      		cpi r24,lo8(48)
 10911 3eee 01F0      		breq .L711
 10912               	.L710:
1323:switcherator.c ****         fail(1);
 10913               		.loc 1 1323 0 is_stmt 1
 10914 3ef0 81E0      		ldi r24,lo8(1)
 10915 3ef2 90E0      		ldi r25,0
 10916 3ef4 00C0      		rjmp .L731
 10917               	.L711:
1330:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 10918               		.loc 1 1330 0
 10919 3ef6 8AE0      		ldi r24,lo8(10)
 10920 3ef8 809F      		mul r24,r16
 10921 3efa F001      		movw r30,r0
 10922 3efc 819F      		mul r24,r17
 10923 3efe F00D      		add r31,r0
 10924 3f00 1124      		clr __zero_reg__
 10925 3f02 E050      		subi r30,lo8(-(weeklyProgram))
 10926 3f04 F040      		sbci r31,hi8(-(weeklyProgram))
 10927 3f06 8081      		ld r24,Z
 10928 3f08 8F3F      		cpi r24,lo8(-1)
 10929 3f0a 01F4      		brne .L712
1330:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 10930               		.loc 1 1330 0 is_stmt 0 discriminator 1
 10931 3f0c 8181      		ldd r24,Z+1
 10932 3f0e 8F3F      		cpi r24,lo8(-1)
 10933 3f10 01F4      		brne .L712
1331:switcherator.c ****         fail(0x0d);
 10934               		.loc 1 1331 0 is_stmt 1
 10935 3f12 8DE0      		ldi r24,lo8(13)
 10936 3f14 90E0      		ldi r25,0
 10937 3f16 00C0      		rjmp .L731
 10938               	.L712:
 10939               	.LVL935:
1338:switcherator.c ****     itoa(programNumber, tempIntString, 10);
 10940               		.loc 1 1338 0
 10941 3f18 4AE0      		ldi r20,lo8(10)
 10942 3f1a 50E0      		ldi r21,0
 10943 3f1c 60E0      		ldi r22,lo8(tempIntString)
 10944 3f1e 70E0      		ldi r23,hi8(tempIntString)
 10945 3f20 C801      		movw r24,r16
 10946 3f22 0E94 0000 		call itoa
 10947               	.LVL936:
1340:switcherator.c ****     blankSwitch = findOpenSwitch(programNumber);
 10948               		.loc 1 1340 0
 10949 3f26 C801      		movw r24,r16
 10950 3f28 0E94 0000 		call findOpenSwitch
 10951               	.LVL937:
1342:switcherator.c ****         if (blankSwitch == 0) {
 10952               		.loc 1 1342 0
 10953 3f2c 0097      		sbiw r24,0
 10954 3f2e 01F4      		brne .L713
1345:switcherator.c ****             overflowProgram = weeklyProgram[programNumber][9];
 10955               		.loc 1 1345 0
 10956 3f30 4AE0      		ldi r20,lo8(10)
 10957               	.LVL938:
 10958               	.L730:
 10959 3f32 409F      		mul r20,r16
 10960 3f34 F001      		movw r30,r0
 10961 3f36 419F      		mul r20,r17
 10962 3f38 F00D      		add r31,r0
 10963 3f3a 1124      		clr __zero_reg__
 10964 3f3c E050      		subi r30,lo8(-(weeklyProgram))
 10965 3f3e F040      		sbci r31,hi8(-(weeklyProgram))
 10966 3f40 8185      		ldd r24,Z+9
 10967 3f42 90E0      		ldi r25,0
 10968               	.LVL939:
1346:switcherator.c ****             if (overflowProgram == 255) {
 10969               		.loc 1 1346 0
 10970 3f44 8F3F      		cpi r24,-1
 10971 3f46 9105      		cpc r25,__zero_reg__
 10972 3f48 01F4      		brne .L720
 10973 3f4a 2FEF      		ldi r18,lo8(-1)
 10974 3f4c 30E0      		ldi r19,0
 10975 3f4e 89E0      		ldi r24,lo8(9)
 10976 3f50 90E0      		ldi r25,0
 10977               	.LVL940:
 10978               	.L716:
 10979               	.LBB28:
1353:switcherator.c ****                     if (weeklyProgram[x][0] == 255 && weeklyProgram[x][5] == 255) {
 10980               		.loc 1 1353 0
 10981 3f52 489F      		mul r20,r24
 10982 3f54 F001      		movw r30,r0
 10983 3f56 499F      		mul r20,r25
 10984 3f58 F00D      		add r31,r0
 10985 3f5a 1124      		clr __zero_reg__
 10986 3f5c E050      		subi r30,lo8(-(weeklyProgram))
 10987 3f5e F040      		sbci r31,hi8(-(weeklyProgram))
 10988 3f60 5081      		ld r21,Z
 10989 3f62 5F3F      		cpi r21,lo8(-1)
 10990 3f64 01F4      		brne .L715
1353:switcherator.c ****                     if (weeklyProgram[x][0] == 255 && weeklyProgram[x][5] == 255) {
 10991               		.loc 1 1353 0 is_stmt 0 discriminator 1
 10992 3f66 5581      		ldd r21,Z+5
 10993 3f68 5F3F      		cpi r21,lo8(-1)
 10994 3f6a 01F4      		brne .L715
1353:switcherator.c ****                     if (weeklyProgram[x][0] == 255 && weeklyProgram[x][5] == 255) {
 10995               		.loc 1 1353 0
 10996 3f6c 9C01      		movw r18,r24
1357:switcherator.c ****                         x = 0;
 10997               		.loc 1 1357 0 is_stmt 1
 10998 3f6e 80E0      		ldi r24,0
 10999 3f70 90E0      		ldi r25,0
 11000               	.L715:
 11001               	.LVL941:
1351:switcherator.c ****                 for (x = (MAX_PROGRAM - 1); x > 0; x--) {
 11002               		.loc 1 1351 0
 11003 3f72 0197      		sbiw r24,1
 11004               	.LVL942:
 11005 3f74 1816      		cp __zero_reg__,r24
 11006 3f76 1906      		cpc __zero_reg__,r25
 11007 3f78 04F0      		brlt .L716
1360:switcherator.c ****                 if (possibleBlank == 255) {
 11008               		.loc 1 1360 0
 11009 3f7a 2F3F      		cpi r18,-1
 11010 3f7c 3105      		cpc r19,__zero_reg__
 11011 3f7e 01F4      		brne .L717
1362:switcherator.c ****                     fail(0x0e);
 11012               		.loc 1 1362 0
 11013 3f80 8EE0      		ldi r24,lo8(14)
 11014 3f82 90E0      		ldi r25,0
 11015               	.LVL943:
 11016               	.L731:
 11017 3f84 0E94 0000 		call fail
 11018               	.LVL944:
 11019 3f88 00C0      		rjmp .L704
 11020               	.LVL945:
 11021               	.L717:
1366:switcherator.c ****                 weeklyProgram[programNumber][9] = possibleBlank;
 11022               		.loc 1 1366 0
 11023 3f8a 409F      		mul r20,r16
 11024 3f8c F001      		movw r30,r0
 11025 3f8e 419F      		mul r20,r17
 11026 3f90 F00D      		add r31,r0
 11027 3f92 1124      		clr __zero_reg__
 11028 3f94 E050      		subi r30,lo8(-(weeklyProgram))
 11029 3f96 F040      		sbci r31,hi8(-(weeklyProgram))
 11030 3f98 2187      		std Z+9,r18
 11031               	.LVL946:
 11032 3f9a 8901      		movw r16,r18
 11033 3f9c 00C0      		rjmp .L730
 11034               	.LVL947:
 11035               	.L720:
 11036               	.LBE28:
1346:switcherator.c ****             if (overflowProgram == 255) {
 11037               		.loc 1 1346 0
 11038 3f9e 8C01      		movw r16,r24
 11039               	.LVL948:
 11040 3fa0 00C0      		rjmp .L730
 11041               	.LVL949:
 11042               	.L713:
1378:switcherator.c ****     weeklyProgram[programNumber][blankSwitch] = switchNumber;
 11043               		.loc 1 1378 0 discriminator 1
 11044 3fa2 2AE0      		ldi r18,lo8(10)
 11045 3fa4 209F      		mul r18,r16
 11046 3fa6 F001      		movw r30,r0
 11047 3fa8 219F      		mul r18,r17
 11048 3faa F00D      		add r31,r0
 11049 3fac 1124      		clr __zero_reg__
 11050 3fae E80F      		add r30,r24
 11051 3fb0 F91F      		adc r31,r25
 11052 3fb2 E050      		subi r30,lo8(-(weeklyProgram))
 11053 3fb4 F040      		sbci r31,hi8(-(weeklyProgram))
 11054 3fb6 C082      		st Z,r12
1379:switcherator.c ****     ok();
 11055               		.loc 1 1379 0 discriminator 1
 11056 3fb8 0E94 0000 		call ok
 11057               	.LVL950:
 11058               	.L704:
 11059               	/* epilogue start */
1380:switcherator.c **** }
 11060               		.loc 1 1380 0
 11061 3fbc 6096      		adiw r28,16
 11062 3fbe 0FB6      		in __tmp_reg__,__SREG__
 11063 3fc0 F894      		cli
 11064 3fc2 DEBF      		out __SP_H__,r29
 11065 3fc4 0FBE      		out __SREG__,__tmp_reg__
 11066 3fc6 CDBF      		out __SP_L__,r28
 11067 3fc8 DF91      		pop r29
 11068 3fca CF91      		pop r28
 11069 3fcc 1F91      		pop r17
 11070 3fce 0F91      		pop r16
 11071               	.LVL951:
 11072 3fd0 FF90      		pop r15
 11073 3fd2 EF90      		pop r14
 11074               	.LVL952:
 11075 3fd4 DF90      		pop r13
 11076 3fd6 CF90      		pop r12
 11077               	.LVL953:
 11078 3fd8 0895      		ret
 11079               	.LFE33:
 11081               	.global	clearProgram
 11083               	clearProgram:
 11084               	.LFB31:
1266:switcherator.c **** void clearProgram(char * commandReceived) {
 11085               		.loc 1 1266 0
 11086               	.LVL954:
 11087 3fda 0F93      		push r16
 11088               	.LCFI285:
 11089 3fdc 1F93      		push r17
 11090               	.LCFI286:
 11091 3fde CF93      		push r28
 11092               	.LCFI287:
 11093 3fe0 DF93      		push r29
 11094               	.LCFI288:
 11095               	/* prologue: function */
 11096               	/* frame size = 0 */
 11097               	/* stack size = 4 */
 11098               	.L__stack_usage = 4
 11099 3fe2 8C01      		movw r16,r24
1267:switcherator.c ****     int programNumber = getSwitchNumber(commandReceived);
 11100               		.loc 1 1267 0
 11101 3fe4 0E94 0000 		call getSwitchNumber
 11102               	.LVL955:
 11103 3fe8 EC01      		movw r28,r24
 11104               	.LVL956:
1268:switcherator.c ****     if (programNumber >= MAX_PROGRAM || (programNumber == 0 && commandReceived[4] != '0')) {
 11105               		.loc 1 1268 0
 11106 3fea 8A30      		cpi r24,10
 11107 3fec 9105      		cpc r25,__zero_reg__
 11108 3fee 04F4      		brge .L733
1268:switcherator.c ****     if (programNumber >= MAX_PROGRAM || (programNumber == 0 && commandReceived[4] != '0')) {
 11109               		.loc 1 1268 0 is_stmt 0 discriminator 1
 11110 3ff0 0097      		sbiw r24,0
 11111 3ff2 01F4      		brne .L734
 11112 3ff4 F801      		movw r30,r16
 11113 3ff6 8481      		ldd r24,Z+4
 11114               	.LVL957:
 11115 3ff8 8033      		cpi r24,lo8(48)
 11116 3ffa 01F0      		breq .L734
 11117               	.L733:
1269:switcherator.c ****         fail(2);
 11118               		.loc 1 1269 0 is_stmt 1
 11119 3ffc 82E0      		ldi r24,lo8(2)
 11120 3ffe 90E0      		ldi r25,0
 11121               	/* epilogue start */
1275:switcherator.c **** }
 11122               		.loc 1 1275 0
 11123 4000 DF91      		pop r29
 11124 4002 CF91      		pop r28
 11125               	.LVL958:
 11126 4004 1F91      		pop r17
 11127 4006 0F91      		pop r16
 11128               	.LVL959:
1269:switcherator.c ****         fail(2);
 11129               		.loc 1 1269 0
 11130 4008 0C94 0000 		jmp fail
 11131               	.LVL960:
 11132               	.L734:
1271:switcherator.c ****         itoa(programNumber, tempIntString, 10);
 11133               		.loc 1 1271 0
 11134 400c 4AE0      		ldi r20,lo8(10)
 11135 400e 50E0      		ldi r21,0
 11136 4010 60E0      		ldi r22,lo8(tempIntString)
 11137 4012 70E0      		ldi r23,hi8(tempIntString)
 11138 4014 CE01      		movw r24,r28
 11139 4016 0E94 0000 		call itoa
 11140               	.LVL961:
1272:switcherator.c ****         ok();
 11141               		.loc 1 1272 0
 11142 401a 0E94 0000 		call ok
 11143               	.LVL962:
1273:switcherator.c ****         clearTheProgram(programNumber);
 11144               		.loc 1 1273 0
 11145 401e CE01      		movw r24,r28
 11146               	/* epilogue start */
1275:switcherator.c **** }
 11147               		.loc 1 1275 0
 11148 4020 DF91      		pop r29
 11149 4022 CF91      		pop r28
 11150               	.LVL963:
 11151 4024 1F91      		pop r17
 11152 4026 0F91      		pop r16
 11153               	.LVL964:
1273:switcherator.c ****         clearTheProgram(programNumber);
 11154               		.loc 1 1273 0
 11155 4028 0C94 0000 		jmp clearTheProgram
 11156               	.LVL965:
 11157               	.LFE31:
 11159               	.global	colorChangeSet
 11161               	colorChangeSet:
 11162               	.LFB25:
 974:switcherator.c **** void colorChangeSet(char * commandReceived) {
 11163               		.loc 1 974 0
 11164               	.LVL966:
 11165 402c EF92      		push r14
 11166               	.LCFI289:
 11167 402e FF92      		push r15
 11168               	.LCFI290:
 11169 4030 0F93      		push r16
 11170               	.LCFI291:
 11171 4032 1F93      		push r17
 11172               	.LCFI292:
 11173 4034 CF93      		push r28
 11174               	.LCFI293:
 11175 4036 DF93      		push r29
 11176               	.LCFI294:
 11177               	/* prologue: function */
 11178               	/* frame size = 0 */
 11179               	/* stack size = 6 */
 11180               	.L__stack_usage = 6
 11181 4038 EC01      		movw r28,r24
 975:switcherator.c ****     int programNumber = getSwitchNumber(commandReceived);
 11182               		.loc 1 975 0
 11183 403a 0E94 0000 		call getSwitchNumber
 11184               	.LVL967:
 11185 403e 7C01      		movw r14,r24
 11186               	.LVL968:
 976:switcherator.c ****     if (programNumber >= NUM_COLOR_CHANGES) {
 11187               		.loc 1 976 0
 11188 4040 86E0      		ldi r24,6
 11189 4042 E816      		cp r14,r24
 11190 4044 F104      		cpc r15,__zero_reg__
 11191 4046 04F0      		brlt .L739
 977:switcherator.c ****         fail(7);
 11192               		.loc 1 977 0
 11193 4048 87E0      		ldi r24,lo8(7)
 11194 404a 90E0      		ldi r25,0
 11195               	/* epilogue start */
 994:switcherator.c **** }
 11196               		.loc 1 994 0
 11197 404c DF91      		pop r29
 11198 404e CF91      		pop r28
 11199               	.LVL969:
 11200 4050 1F91      		pop r17
 11201 4052 0F91      		pop r16
 11202 4054 FF90      		pop r15
 11203 4056 EF90      		pop r14
 11204               	.LVL970:
 977:switcherator.c ****         fail(7);
 11205               		.loc 1 977 0
 11206 4058 0C94 0000 		jmp fail
 11207               	.LVL971:
 11208               	.L739:
 980:switcherator.c ****     tempLongString[3] = 0;
 11209               		.loc 1 980 0
 11210 405c 1092 0000 		sts tempLongString+3,__zero_reg__
 981:switcherator.c ****     tempLongString[0] = commandReceived[6];
 11211               		.loc 1 981 0
 11212 4060 8E81      		ldd r24,Y+6
 11213 4062 8093 0000 		sts tempLongString,r24
 982:switcherator.c ****     tempLongString[1] = commandReceived[7];
 11214               		.loc 1 982 0
 11215 4066 8F81      		ldd r24,Y+7
 11216 4068 8093 0000 		sts tempLongString+1,r24
 983:switcherator.c ****     tempLongString[2] = commandReceived[8];
 11217               		.loc 1 983 0
 11218 406c 8885      		ldd r24,Y+8
 11219 406e 8093 0000 		sts tempLongString+2,r24
 984:switcherator.c ****     colorChanges[programNumber][0] = atoi(tempLongString);
 11220               		.loc 1 984 0
 11221 4072 80E0      		ldi r24,lo8(tempLongString)
 11222 4074 90E0      		ldi r25,hi8(tempLongString)
 11223 4076 0E94 0000 		call atoi
 11224               	.LVL972:
 11225 407a 8701      		movw r16,r14
 11226 407c 000F      		lsl r16
 11227 407e 111F      		rol r17
 11228 4080 0E0D      		add r16,r14
 11229 4082 1F1D      		adc r17,r15
 11230 4084 0050      		subi r16,lo8(-(colorChanges))
 11231 4086 1040      		sbci r17,hi8(-(colorChanges))
 11232 4088 F801      		movw r30,r16
 11233 408a 8083      		st Z,r24
 985:switcherator.c ****     tempLongString[0] = commandReceived[10];
 11234               		.loc 1 985 0
 11235 408c 8A85      		ldd r24,Y+10
 11236 408e 8093 0000 		sts tempLongString,r24
 986:switcherator.c ****     tempLongString[1] = commandReceived[11];
 11237               		.loc 1 986 0
 11238 4092 8B85      		ldd r24,Y+11
 11239 4094 8093 0000 		sts tempLongString+1,r24
 987:switcherator.c ****     tempLongString[2] = commandReceived[12];
 11240               		.loc 1 987 0
 11241 4098 8C85      		ldd r24,Y+12
 11242 409a 8093 0000 		sts tempLongString+2,r24
 988:switcherator.c ****     colorChanges[programNumber][1] = atoi(tempLongString);
 11243               		.loc 1 988 0
 11244 409e 80E0      		ldi r24,lo8(tempLongString)
 11245 40a0 90E0      		ldi r25,hi8(tempLongString)
 11246 40a2 0E94 0000 		call atoi
 11247               	.LVL973:
 11248 40a6 F801      		movw r30,r16
 11249 40a8 8183      		std Z+1,r24
 989:switcherator.c ****     tempLongString[0] = commandReceived[14];
 11250               		.loc 1 989 0
 11251 40aa 8E85      		ldd r24,Y+14
 11252 40ac 8093 0000 		sts tempLongString,r24
 990:switcherator.c ****     tempLongString[1] = commandReceived[15];
 11253               		.loc 1 990 0
 11254 40b0 8F85      		ldd r24,Y+15
 11255 40b2 8093 0000 		sts tempLongString+1,r24
 991:switcherator.c ****     tempLongString[2] = commandReceived[16];
 11256               		.loc 1 991 0
 11257 40b6 8889      		ldd r24,Y+16
 11258 40b8 8093 0000 		sts tempLongString+2,r24
 992:switcherator.c ****     colorChanges[programNumber][2] = atoi(tempLongString);
 11259               		.loc 1 992 0
 11260 40bc 80E0      		ldi r24,lo8(tempLongString)
 11261 40be 90E0      		ldi r25,hi8(tempLongString)
 11262 40c0 0E94 0000 		call atoi
 11263               	.LVL974:
 11264 40c4 F801      		movw r30,r16
 11265 40c6 8283      		std Z+2,r24
 11266               	/* epilogue start */
 994:switcherator.c **** }
 11267               		.loc 1 994 0
 11268 40c8 DF91      		pop r29
 11269 40ca CF91      		pop r28
 11270               	.LVL975:
 11271 40cc 1F91      		pop r17
 11272 40ce 0F91      		pop r16
 11273 40d0 FF90      		pop r15
 11274 40d2 EF90      		pop r14
 11275               	.LVL976:
 993:switcherator.c ****     ok();
 11276               		.loc 1 993 0
 11277 40d4 0C94 0000 		jmp ok
 11278               	.LVL977:
 11279               	.LFE25:
 11281               	.global	pwmSetup
 11283               	pwmSetup:
 11284               	.LFB20:
 851:switcherator.c **** void pwmSetup(char * commandReceived) {
 11285               		.loc 1 851 0
 11286               	.LVL978:
 11287 40d8 0F93      		push r16
 11288               	.LCFI295:
 11289 40da 1F93      		push r17
 11290               	.LCFI296:
 11291 40dc CF93      		push r28
 11292               	.LCFI297:
 11293 40de DF93      		push r29
 11294               	.LCFI298:
 11295               	/* prologue: function */
 11296               	/* frame size = 0 */
 11297               	/* stack size = 4 */
 11298               	.L__stack_usage = 4
 11299 40e0 EC01      		movw r28,r24
 11300               	.LVL979:
 11301 40e2 E0E0      		ldi r30,lo8(switchStuff)
 11302 40e4 F0E0      		ldi r31,hi8(switchStuff)
 11303               	.LVL980:
 11304               	.L743:
 854:switcherator.c ****         if (switchStuff[x] == 70 || switchStuff[x] == 71 || switchStuff[x] == 74 ||
 11305               		.loc 1 854 0
 11306 40e6 8191      		ld r24,Z+
 11307 40e8 982F      		mov r25,r24
 11308 40ea 9654      		subi r25,lo8(-(-70))
 11309 40ec 9230      		cpi r25,lo8(2)
 11310 40ee 00F0      		brlo .L741
 854:switcherator.c ****         if (switchStuff[x] == 70 || switchStuff[x] == 71 || switchStuff[x] == 74 ||
 11311               		.loc 1 854 0 is_stmt 0 discriminator 1
 11312 40f0 8A34      		cpi r24,lo8(74)
 11313 40f2 01F0      		breq .L741
 11314 40f4 8B34      		cpi r24,lo8(75)
 11315 40f6 01F0      		breq .L741
 855:switcherator.c ****                 switchStuff[x] == 75 || switchStuff[x] == 76 || switchStuff[x] == 77) {
 11316               		.loc 1 855 0 is_stmt 1
 11317 40f8 8C34      		cpi r24,lo8(76)
 11318 40fa 01F0      		breq .L741
 855:switcherator.c ****                 switchStuff[x] == 75 || switchStuff[x] == 76 || switchStuff[x] == 77) {
 11319               		.loc 1 855 0 is_stmt 0 discriminator 1
 11320 40fc 8D34      		cpi r24,lo8(77)
 11321 40fe 01F4      		brne .L742
 11322               	.L741:
 856:switcherator.c ****             fail(6);
 11323               		.loc 1 856 0 is_stmt 1
 11324 4100 86E0      		ldi r24,lo8(6)
 11325 4102 90E0      		ldi r25,0
 11326               	/* epilogue start */
 896:switcherator.c **** }
 11327               		.loc 1 896 0
 11328 4104 DF91      		pop r29
 11329 4106 CF91      		pop r28
 11330               	.LVL981:
 11331 4108 1F91      		pop r17
 11332 410a 0F91      		pop r16
 856:switcherator.c ****             fail(6);
 11333               		.loc 1 856 0
 11334 410c 0C94 0000 		jmp fail
 11335               	.LVL982:
 11336               	.L742:
 853:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 11337               		.loc 1 853 0
 11338 4110 80E0      		ldi r24,hi8(switchStuff+16)
 11339 4112 E030      		cpi r30,lo8(switchStuff+16)
 11340 4114 F807      		cpc r31,r24
 11341 4116 01F4      		brne .L743
 11342               	.LVL983:
 862:switcherator.c ****     tempIntString[0] = commandReceived[5];
 11343               		.loc 1 862 0
 11344 4118 8D81      		ldd r24,Y+5
 11345 411a 8093 0000 		sts tempIntString,r24
 863:switcherator.c ****     tempIntString[1] = commandReceived[6];
 11346               		.loc 1 863 0
 11347 411e 8E81      		ldd r24,Y+6
 11348 4120 8093 0000 		sts tempIntString+1,r24
 864:switcherator.c ****     switchNumber = atoi(tempIntString);
 11349               		.loc 1 864 0
 11350 4124 80E0      		ldi r24,lo8(tempIntString)
 11351 4126 90E0      		ldi r25,hi8(tempIntString)
 11352 4128 0E94 0000 		call atoi
 11353               	.LVL984:
 11354 412c 8C01      		movw r16,r24
 11355               	.LVL985:
 865:switcherator.c ****     clearTheSwitch(switchNumber);
 11356               		.loc 1 865 0
 11357 412e 0E94 0000 		call clearTheSwitch
 11358               	.LVL986:
 867:switcherator.c ****     if (commandReceived[8] == 'H' || commandReceived[8] == 'h' || commandReceived[8] == '1') {
 11359               		.loc 1 867 0
 11360 4132 8885      		ldd r24,Y+8
 11361 4134 8834      		cpi r24,lo8(72)
 11362 4136 01F0      		breq .L744
 867:switcherator.c ****     if (commandReceived[8] == 'H' || commandReceived[8] == 'h' || commandReceived[8] == '1') {
 11363               		.loc 1 867 0 is_stmt 0 discriminator 1
 11364 4138 8836      		cpi r24,lo8(104)
 11365 413a 01F0      		breq .L744
 11366 413c 8133      		cpi r24,lo8(49)
 11367 413e 01F4      		brne .L745
 11368               	.L744:
 868:switcherator.c ****         switchStuff[switchNumber] = 201;
 11369               		.loc 1 868 0 is_stmt 1
 11370 4140 F801      		movw r30,r16
 11371 4142 E050      		subi r30,lo8(-(switchStuff))
 11372 4144 F040      		sbci r31,hi8(-(switchStuff))
 11373 4146 89EC      		ldi r24,lo8(-55)
 11374 4148 00C0      		rjmp .L770
 11375               	.L745:
 11376 414a F801      		movw r30,r16
 11377 414c E050      		subi r30,lo8(-(switchStuff))
 11378 414e F040      		sbci r31,hi8(-(switchStuff))
 869:switcherator.c ****     } else if (commandReceived[8] == 'C' || commandReceived[8] == 'c') {
 11379               		.loc 1 869 0
 11380 4150 8334      		cpi r24,lo8(67)
 11381 4152 01F0      		breq .L747
 869:switcherator.c ****     } else if (commandReceived[8] == 'C' || commandReceived[8] == 'c') {
 11382               		.loc 1 869 0 is_stmt 0 discriminator 1
 11383 4154 8336      		cpi r24,lo8(99)
 11384 4156 01F4      		brne .L748
 11385               	.L747:
 870:switcherator.c ****         switchStuff[switchNumber] = 202;
 11386               		.loc 1 870 0 is_stmt 1
 11387 4158 8AEC      		ldi r24,lo8(-54)
 11388 415a 00C0      		rjmp .L770
 11389               	.L748:
 872:switcherator.c ****         switchStuff[switchNumber] = 200;
 11390               		.loc 1 872 0
 11391 415c 88EC      		ldi r24,lo8(-56)
 11392               	.L770:
 11393 415e 8083      		st Z,r24
 874:switcherator.c ****     DDRD |= (1 << PIND3) | (1 << PIND5) | (1 << PIND6);
 11394               		.loc 1 874 0
 11395 4160 8AB1      		in r24,0xa
 11396 4162 8866      		ori r24,lo8(104)
 11397 4164 8AB9      		out 0xa,r24
 876:switcherator.c ****     Red = 0;
 11398               		.loc 1 876 0
 11399 4166 1092 B400 		sts 180,__zero_reg__
 877:switcherator.c ****     Green = 0;
 11400               		.loc 1 877 0
 11401 416a 18BC      		out 0x28,__zero_reg__
 878:switcherator.c ****     Blue = 0;
 11402               		.loc 1 878 0
 11403 416c 17BC      		out 0x27,__zero_reg__
 881:switcherator.c ****     if (commandReceived[7] == '0') {
 11404               		.loc 1 881 0
 11405 416e 8F81      		ldd r24,Y+7
 11406 4170 8033      		cpi r24,lo8(48)
 11407 4172 01F4      		brne .L749
 882:switcherator.c ****         pwmdir = 0;
 11408               		.loc 1 882 0
 11409 4174 1092 0000 		sts pwmdir,__zero_reg__
 883:switcherator.c ****         TCCR0A = (1 << COM0A0) | (1 << COM0A1) | (1 << COM0B0) | (1 << COM0B1) | (1 << WGM00);
 11410               		.loc 1 883 0
 11411 4178 81EF      		ldi r24,lo8(-15)
 11412 417a 84BD      		out 0x24,r24
 884:switcherator.c ****         TCCR2A = (1 << COM2B0) | (1 << COM2B1) | (1 << WGM20);
 11413               		.loc 1 884 0
 11414 417c 81E3      		ldi r24,lo8(49)
 11415 417e 00C0      		rjmp .L771
 11416               	.L749:
 886:switcherator.c ****         pwmdir = 1;
 11417               		.loc 1 886 0
 11418 4180 81E0      		ldi r24,lo8(1)
 11419 4182 8093 0000 		sts pwmdir,r24
 887:switcherator.c ****         TCCR0A = (1 << COM0A1) | (1 << COM0B1) | (1 << WGM00);
 11420               		.loc 1 887 0
 11421 4186 81EA      		ldi r24,lo8(-95)
 11422 4188 84BD      		out 0x24,r24
 888:switcherator.c ****         TCCR2A = (1 << COM2B1) | (1 << WGM20);
 11423               		.loc 1 888 0
 11424 418a 81E2      		ldi r24,lo8(33)
 11425               	.L771:
 11426 418c 8093 B000 		sts 176,r24
 891:switcherator.c ****     TCCR0B = (1 << CS01) | (1 << CS00);
 11427               		.loc 1 891 0
 11428 4190 83E0      		ldi r24,lo8(3)
 11429 4192 85BD      		out 0x25,r24
 893:switcherator.c ****     TCCR2B = (1 << CS22); // F_CPU/64
 11430               		.loc 1 893 0
 11431 4194 84E0      		ldi r24,lo8(4)
 11432 4196 8093 B100 		sts 177,r24
 11433               	/* epilogue start */
 896:switcherator.c **** }
 11434               		.loc 1 896 0
 11435 419a DF91      		pop r29
 11436 419c CF91      		pop r28
 11437               	.LVL987:
 11438 419e 1F91      		pop r17
 11439 41a0 0F91      		pop r16
 11440               	.LVL988:
 895:switcherator.c ****     ok();
 11441               		.loc 1 895 0
 11442 41a2 0C94 0000 		jmp ok
 11443               	.LVL989:
 11444               	.LFE20:
 11446               	.global	startSwitch
 11448               	startSwitch:
 11449               	.LFB17:
 666:switcherator.c **** void startSwitch(char * commandReceived) {
 11450               		.loc 1 666 0
 11451               	.LVL990:
 11452 41a6 EF92      		push r14
 11453               	.LCFI299:
 11454 41a8 FF92      		push r15
 11455               	.LCFI300:
 11456 41aa 0F93      		push r16
 11457               	.LCFI301:
 11458 41ac 1F93      		push r17
 11459               	.LCFI302:
 11460 41ae CF93      		push r28
 11461               	.LCFI303:
 11462 41b0 DF93      		push r29
 11463               	.LCFI304:
 11464 41b2 00D0      		rcall .
 11465 41b4 00D0      		rcall .
 11466               	.LCFI305:
 11467 41b6 CDB7      		in r28,__SP_L__
 11468 41b8 DEB7      		in r29,__SP_H__
 11469               	.LCFI306:
 11470               	/* prologue: function */
 11471               	/* frame size = 4 */
 11472               	/* stack size = 10 */
 11473               	.L__stack_usage = 10
 11474 41ba 7C01      		movw r14,r24
 11475               	.LVL991:
 670:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 11476               		.loc 1 670 0
 11477 41bc 0E94 0000 		call getSwitchNumber
 11478               	.LVL992:
 11479 41c0 8C01      		movw r16,r24
 11480               	.LVL993:
 671:switcherator.c ****     if ((switchNumber >= NUM_SWITCHES) || (switchStuff[switchNumber] == 255)) {
 11481               		.loc 1 671 0
 11482 41c2 8031      		cpi r24,16
 11483 41c4 9105      		cpc r25,__zero_reg__
 11484 41c6 04F4      		brge .L773
 671:switcherator.c ****     if ((switchNumber >= NUM_SWITCHES) || (switchStuff[switchNumber] == 255)) {
 11485               		.loc 1 671 0 is_stmt 0 discriminator 1
 11486 41c8 FC01      		movw r30,r24
 11487 41ca E050      		subi r30,lo8(-(switchStuff))
 11488 41cc F040      		sbci r31,hi8(-(switchStuff))
 11489 41ce 2081      		ld r18,Z
 11490 41d0 2F3F      		cpi r18,lo8(-1)
 11491 41d2 01F4      		brne .L774
 11492               	.L773:
 672:switcherator.c ****         fail(1);
 11493               		.loc 1 672 0 is_stmt 1
 11494 41d4 81E0      		ldi r24,lo8(1)
 11495 41d6 90E0      		ldi r25,0
 11496 41d8 00C0      		rjmp .L790
 11497               	.L774:
 676:switcherator.c ****     tempHugeString[0] = commandReceived[5];
 11498               		.loc 1 676 0
 11499 41da F701      		movw r30,r14
 11500 41dc 8581      		ldd r24,Z+5
 11501 41de 8093 0000 		sts tempHugeString,r24
 677:switcherator.c ****     tempHugeString[1] = commandReceived[6];
 11502               		.loc 1 677 0
 11503 41e2 8681      		ldd r24,Z+6
 11504 41e4 8093 0000 		sts tempHugeString+1,r24
 678:switcherator.c ****     tempHugeString[2] = commandReceived[7];
 11505               		.loc 1 678 0
 11506 41e8 8781      		ldd r24,Z+7
 11507 41ea 8093 0000 		sts tempHugeString+2,r24
 679:switcherator.c ****     tempHugeString[3] = commandReceived[8];
 11508               		.loc 1 679 0
 11509 41ee 8085      		ldd r24,Z+8
 11510 41f0 8093 0000 		sts tempHugeString+3,r24
 680:switcherator.c ****     tempHugeString[4] = commandReceived[9];
 11511               		.loc 1 680 0
 11512 41f4 8185      		ldd r24,Z+9
 11513 41f6 8093 0000 		sts tempHugeString+4,r24
 681:switcherator.c ****     tempHugeString[5] = commandReceived[10];
 11514               		.loc 1 681 0
 11515 41fa 8285      		ldd r24,Z+10
 11516 41fc 8093 0000 		sts tempHugeString+5,r24
 682:switcherator.c ****     duration = atol(tempHugeString);
 11517               		.loc 1 682 0
 11518 4200 80E0      		ldi r24,lo8(tempHugeString)
 11519 4202 90E0      		ldi r25,hi8(tempHugeString)
 11520 4204 2C83      		std Y+4,r18
 11521 4206 0E94 0000 		call atol
 11522               	.LVL994:
 11523 420a 462F      		mov r20,r22
 11524 420c 572F      		mov r21,r23
 11525 420e BC01      		movw r22,r24
 11526               	.LVL995:
 683:switcherator.c ****     if (duration == 0) {
 11527               		.loc 1 683 0
 11528 4210 2C81      		ldd r18,Y+4
 11529 4212 4115      		cp r20,__zero_reg__
 11530 4214 5105      		cpc r21,__zero_reg__
 11531 4216 6105      		cpc r22,__zero_reg__
 11532 4218 7105      		cpc r23,__zero_reg__
 11533 421a 01F4      		brne .L776
 684:switcherator.c ****         fail(5);
 11534               		.loc 1 684 0
 11535 421c 85E0      		ldi r24,lo8(5)
 11536 421e 90E0      		ldi r25,0
 11537               	.LVL996:
 11538               	.L790:
 11539 4220 0E94 0000 		call fail
 11540               	.LVL997:
 685:switcherator.c ****         return;
 11541               		.loc 1 685 0
 11542 4224 00C0      		rjmp .L772
 11543               	.LVL998:
 11544               	.L776:
 688:switcherator.c ****     if ((weeklySeconds + duration) > switchStatus[switchNumber])
 11545               		.loc 1 688 0
 11546 4226 8091 0000 		lds r24,weeklySeconds
 11547 422a 9091 0000 		lds r25,weeklySeconds+1
 11548 422e A091 0000 		lds r26,weeklySeconds+2
 11549 4232 B091 0000 		lds r27,weeklySeconds+3
 11550 4236 840F      		add r24,r20
 11551 4238 951F      		adc r25,r21
 11552 423a A61F      		adc r26,r22
 11553 423c B71F      		adc r27,r23
 11554 423e F801      		movw r30,r16
 11555 4240 EE0F      		lsl r30
 11556 4242 FF1F      		rol r31
 11557 4244 EE0F      		lsl r30
 11558 4246 FF1F      		rol r31
 11559 4248 E050      		subi r30,lo8(-(switchStatus))
 11560 424a F040      		sbci r31,hi8(-(switchStatus))
 11561 424c 4081      		ld r20,Z
 11562 424e 5181      		ldd r21,Z+1
 11563 4250 6281      		ldd r22,Z+2
 11564 4252 7381      		ldd r23,Z+3
 11565               	.LVL999:
 11566 4254 4817      		cp r20,r24
 11567 4256 5907      		cpc r21,r25
 11568 4258 6A07      		cpc r22,r26
 11569 425a 7B07      		cpc r23,r27
 11570 425c 00F4      		brsh .L777
 689:switcherator.c ****         switchStatus[switchNumber] = (weeklySeconds + duration);
 11571               		.loc 1 689 0
 11572 425e 8083      		st Z,r24
 11573 4260 9183      		std Z+1,r25
 11574 4262 A283      		std Z+2,r26
 11575 4264 B383      		std Z+3,r27
 11576               	.L777:
 692:switcherator.c ****     if (switchStuff[switchNumber] >= 200 && switchStuff[switchNumber] <= 220) {
 11577               		.loc 1 692 0
 11578 4266 822F      		mov r24,r18
 11579 4268 885C      		subi r24,lo8(-(56))
 11580 426a 8531      		cpi r24,lo8(21)
 11581 426c 00F0      		brlo .+2
 11582 426e 00C0      		rjmp .L778
 694:switcherator.c ****         if (switchStuff[switchNumber] == 200) {
 11583               		.loc 1 694 0
 11584 4270 283C      		cpi r18,lo8(-56)
 11585 4272 01F4      		brne .L779
 697:switcherator.c ****             green = pwmValues[1];
 11586               		.loc 1 697 0
 11587 4274 8091 0000 		lds r24,pwmValues+1
 698:switcherator.c ****             blue = pwmValues[2];
 11588               		.loc 1 698 0
 11589 4278 E091 0000 		lds r30,pwmValues+2
 699:switcherator.c ****             red = red * bright / 16;
 11590               		.loc 1 699 0
 11591 427c 6091 0000 		lds r22,bright
 11592 4280 7091 0000 		lds r23,bright+1
 696:switcherator.c ****             red = pwmValues[0];
 11593               		.loc 1 696 0
 11594 4284 9091 0000 		lds r25,pwmValues
 699:switcherator.c ****             red = red * bright / 16;
 11595               		.loc 1 699 0
 11596 4288 969F      		mul r25,r22
 11597 428a A001      		movw r20,r0
 11598 428c 979F      		mul r25,r23
 11599 428e 500D      		add r21,r0
 11600 4290 1124      		clr __zero_reg__
 11601 4292 F4E0      		ldi r31,4
 11602               		1:
 11603 4294 5695      		lsr r21
 11604 4296 4795      		ror r20
 11605 4298 FA95      		dec r31
 11606 429a 01F4      		brne 1b
 11607 429c 5093 0000 		sts red+1,r21
 11608 42a0 4093 0000 		sts red,r20
 700:switcherator.c ****             green = green * bright / 16;
 11609               		.loc 1 700 0
 11610 42a4 869F      		mul r24,r22
 11611 42a6 9001      		movw r18,r0
 11612 42a8 879F      		mul r24,r23
 11613 42aa 300D      		add r19,r0
 11614 42ac 1124      		clr __zero_reg__
 11615 42ae A4E0      		ldi r26,4
 11616               		1:
 11617 42b0 3695      		lsr r19
 11618 42b2 2795      		ror r18
 11619 42b4 AA95      		dec r26
 11620 42b6 01F4      		brne 1b
 11621 42b8 3093 0000 		sts green+1,r19
 11622 42bc 2093 0000 		sts green,r18
 701:switcherator.c ****             blue = blue * bright / 16;
 11623               		.loc 1 701 0
 11624 42c0 E69F      		mul r30,r22
 11625 42c2 C001      		movw r24,r0
 11626 42c4 E79F      		mul r30,r23
 11627 42c6 900D      		add r25,r0
 11628 42c8 1124      		clr __zero_reg__
 11629 42ca B4E0      		ldi r27,4
 11630               		1:
 11631 42cc 9695      		lsr r25
 11632 42ce 8795      		ror r24
 11633 42d0 BA95      		dec r27
 11634 42d2 01F4      		brne 1b
 11635 42d4 9093 0000 		sts blue+1,r25
 11636 42d8 8093 0000 		sts blue,r24
 702:switcherator.c ****             Red = red;
 11637               		.loc 1 702 0
 11638 42dc 4093 B400 		sts 180,r20
 703:switcherator.c ****             Green = green;
 11639               		.loc 1 703 0
 11640 42e0 28BD      		out 0x28,r18
 704:switcherator.c ****             Blue = blue;
 11641               		.loc 1 704 0
 11642 42e2 87BD      		out 0x27,r24
 11643 42e4 00C0      		rjmp .L780
 11644               	.L779:
 705:switcherator.c ****         } else if (switchStuff[switchNumber] == 202) {
 11645               		.loc 1 705 0
 11646 42e6 2A3C      		cpi r18,lo8(-54)
 11647 42e8 01F4      		brne .L781
 706:switcherator.c ****             runColorChanges = 1;
 11648               		.loc 1 706 0
 11649 42ea 81E0      		ldi r24,lo8(1)
 11650 42ec 8093 0000 		sts runColorChanges,r24
 11651 42f0 00C0      		rjmp .L780
 11652               	.L781:
 707:switcherator.c ****         } else if (switchStuff[switchNumber] == 212) {
 11653               		.loc 1 707 0
 11654 42f2 243D      		cpi r18,lo8(-44)
 11655 42f4 01F4      		brne .L782
 708:switcherator.c ****             bright = switchBright[switchNumber];
 11656               		.loc 1 708 0
 11657 42f6 F801      		movw r30,r16
 11658 42f8 E050      		subi r30,lo8(-(switchBright))
 11659 42fa F040      		sbci r31,hi8(-(switchBright))
 11660 42fc 8081      		ld r24,Z
 11661 42fe 8093 0000 		sts bright,r24
 11662 4302 1092 0000 		sts bright+1,__zero_reg__
 11663 4306 00C0      		rjmp .L780
 11664               	.L782:
 710:switcherator.c ****             runHue = 1;
 11665               		.loc 1 710 0
 11666 4308 81E0      		ldi r24,lo8(1)
 11667 430a 8093 0000 		sts runHue,r24
 11668 430e 00C0      		rjmp .L780
 11669               	.L778:
 11670               	.LVL1000:
 11671               	.LBB29:
 721:switcherator.c ****         getPort(switchNumber, port, pin, direction);
 11672               		.loc 1 721 0
 11673 4310 9E01      		movw r18,r28
 11674 4312 2F5F      		subi r18,-1
 11675 4314 3F4F      		sbci r19,-1
 11676 4316 AE01      		movw r20,r28
 11677 4318 4E5F      		subi r20,-2
 11678 431a 5F4F      		sbci r21,-1
 11679 431c BE01      		movw r22,r28
 11680 431e 6D5F      		subi r22,-3
 11681 4320 7F4F      		sbci r23,-1
 11682 4322 C801      		movw r24,r16
 11683 4324 0E94 0000 		call getPort
 11684               	.LVL1001:
 723:switcherator.c ****         realPin = pin[0];
 11685               		.loc 1 723 0
 11686 4328 3A81      		ldd r19,Y+2
 11687               	.LVL1002:
 724:switcherator.c ****         if (port[0] == 'B')
 11688               		.loc 1 724 0
 11689 432a 8B81      		ldd r24,Y+3
 11690 432c 8234      		cpi r24,lo8(66)
 11691 432e 01F0      		breq .L786
 731:switcherator.c ****         else if (port[0] == 'C')
 11692               		.loc 1 731 0
 11693 4330 8334      		cpi r24,lo8(67)
 11694 4332 01F0      		breq .L787
 735:switcherator.c ****         else if (port[0] == 'D')
 11695               		.loc 1 735 0
 11696 4334 8434      		cpi r24,lo8(68)
 11697 4336 01F0      		breq .L788
 720:switcherator.c ****         volatile unsigned char *thisPort = 0;
 11698               		.loc 1 720 0
 11699 4338 E0E0      		ldi r30,0
 11700 433a F0E0      		ldi r31,0
 11701 433c 00C0      		rjmp .L783
 11702               	.L786:
 725:switcherator.c ****             thisPort = &PORTB;
 11703               		.loc 1 725 0
 11704 433e E5E2      		ldi r30,lo8(37)
 11705 4340 F0E0      		ldi r31,0
 11706 4342 00C0      		rjmp .L783
 11707               	.L787:
 732:switcherator.c ****             thisPort = &PORTC;
 11708               		.loc 1 732 0
 11709 4344 E8E2      		ldi r30,lo8(40)
 11710 4346 F0E0      		ldi r31,0
 11711 4348 00C0      		rjmp .L783
 11712               	.L788:
 736:switcherator.c ****             thisPort = &PORTD;
 11713               		.loc 1 736 0
 11714 434a EBE2      		ldi r30,lo8(43)
 11715 434c F0E0      		ldi r31,0
 11716               	.L783:
 11717               	.LVL1003:
 760:switcherator.c ****         if (direction[0] == 0) {
 11718               		.loc 1 760 0
 11719 434e 8981      		ldd r24,Y+1
 761:switcherator.c ****             *thisPort &= ~(1 << realPin);
 11720               		.loc 1 761 0
 11721 4350 2081      		ld r18,Z
 760:switcherator.c ****         if (direction[0] == 0) {
 11722               		.loc 1 760 0
 11723 4352 8111      		cpse r24,__zero_reg__
 11724 4354 00C0      		rjmp .L784
 761:switcherator.c ****             *thisPort &= ~(1 << realPin);
 11725               		.loc 1 761 0
 11726 4356 81E0      		ldi r24,lo8(1)
 11727 4358 90E0      		ldi r25,0
 11728 435a 032E      		mov r0,r19
 11729 435c 00C0      		rjmp 2f
 11730               		1:
 11731 435e 880F      		lsl r24
 11732               		2:
 11733 4360 0A94      		dec r0
 11734 4362 02F4      		brpl 1b
 11735 4364 8095      		com r24
 11736 4366 2823      		and r18,r24
 11737 4368 00C0      		rjmp .L789
 11738               	.L784:
 763:switcherator.c ****             *thisPort |= (1 << realPin);
 11739               		.loc 1 763 0
 11740 436a 81E0      		ldi r24,lo8(1)
 11741 436c 90E0      		ldi r25,0
 11742 436e 00C0      		rjmp 2f
 11743               		1:
 11744 4370 880F      		lsl r24
 11745               		2:
 11746 4372 3A95      		dec r19
 11747 4374 02F4      		brpl 1b
 11748 4376 282B      		or r18,r24
 11749               	.L789:
 11750 4378 2083      		st Z,r18
 11751               	.LVL1004:
 11752               	.L780:
 11753               	.LBE29:
 766:switcherator.c ****     ok();
 11754               		.loc 1 766 0
 11755 437a 0E94 0000 		call ok
 11756               	.LVL1005:
 11757               	.L772:
 11758               	/* epilogue start */
 767:switcherator.c **** }
 11759               		.loc 1 767 0
 11760 437e 0F90      		pop __tmp_reg__
 11761 4380 0F90      		pop __tmp_reg__
 11762 4382 0F90      		pop __tmp_reg__
 11763 4384 0F90      		pop __tmp_reg__
 11764 4386 DF91      		pop r29
 11765 4388 CF91      		pop r28
 11766 438a 1F91      		pop r17
 11767 438c 0F91      		pop r16
 11768               	.LVL1006:
 11769 438e FF90      		pop r15
 11770 4390 EF90      		pop r14
 11771               	.LVL1007:
 11772 4392 0895      		ret
 11773               	.LFE17:
 11775               	.global	setNewSwitch
 11777               	setNewSwitch:
 11778               	.LFB13:
 436:switcherator.c **** void setNewSwitch(char * commandReceived) {
 11779               		.loc 1 436 0
 11780               	.LVL1008:
 11781 4394 AF92      		push r10
 11782               	.LCFI307:
 11783 4396 BF92      		push r11
 11784               	.LCFI308:
 11785 4398 CF92      		push r12
 11786               	.LCFI309:
 11787 439a DF92      		push r13
 11788               	.LCFI310:
 11789 439c EF92      		push r14
 11790               	.LCFI311:
 11791 439e FF92      		push r15
 11792               	.LCFI312:
 11793 43a0 0F93      		push r16
 11794               	.LCFI313:
 11795 43a2 1F93      		push r17
 11796               	.LCFI314:
 11797 43a4 CF93      		push r28
 11798               	.LCFI315:
 11799 43a6 DF93      		push r29
 11800               	.LCFI316:
 11801 43a8 1F92      		push __zero_reg__
 11802               	.LCFI317:
 11803 43aa CDB7      		in r28,__SP_L__
 11804 43ac DEB7      		in r29,__SP_H__
 11805               	.LCFI318:
 11806               	/* prologue: function */
 11807               	/* frame size = 1 */
 11808               	/* stack size = 11 */
 11809               	.L__stack_usage = 11
 11810 43ae 6C01      		movw r12,r24
 11811               	.LVL1009:
 446:switcherator.c ****     tempIntString[0] = '0';
 11812               		.loc 1 446 0
 11813 43b0 80E3      		ldi r24,lo8(48)
 11814               	.LVL1010:
 11815 43b2 8093 0000 		sts tempIntString,r24
 447:switcherator.c ****     tempIntString[1] = commandReceived[6];
 11816               		.loc 1 447 0
 11817 43b6 D601      		movw r26,r12
 11818 43b8 1696      		adiw r26,6
 11819 43ba 8C91      		ld r24,X
 11820 43bc 8093 0000 		sts tempIntString+1,r24
 448:switcherator.c ****     pin = atoi(tempIntString);
 11821               		.loc 1 448 0
 11822 43c0 80E0      		ldi r24,lo8(tempIntString)
 11823 43c2 90E0      		ldi r25,hi8(tempIntString)
 11824 43c4 0E94 0000 		call atoi
 11825               	.LVL1011:
 11826 43c8 F82E      		mov r15,r24
 11827               	.LVL1012:
 450:switcherator.c ****     tempIntString[1] = commandReceived[7];
 11828               		.loc 1 450 0
 11829 43ca F601      		movw r30,r12
 11830 43cc 8781      		ldd r24,Z+7
 11831 43ce 8093 0000 		sts tempIntString+1,r24
 451:switcherator.c ****     direction = atoi(tempIntString);
 11832               		.loc 1 451 0
 11833 43d2 80E0      		ldi r24,lo8(tempIntString)
 11834 43d4 90E0      		ldi r25,hi8(tempIntString)
 11835 43d6 0E94 0000 		call atoi
 11836               	.LVL1013:
 11837 43da E82E      		mov r14,r24
 11838               	.LVL1014:
 452:switcherator.c ****     port = commandReceived[5];
 11839               		.loc 1 452 0
 11840 43dc D601      		movw r26,r12
 11841 43de 1596      		adiw r26,5
 11842 43e0 2C91      		ld r18,X
 11843               	.LVL1015:
 453:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 11844               		.loc 1 453 0
 11845 43e2 C601      		movw r24,r12
 11846 43e4 2983      		std Y+1,r18
 11847 43e6 0E94 0000 		call getSwitchNumber
 11848               	.LVL1016:
 11849 43ea 8C01      		movw r16,r24
 11850               	.LVL1017:
 455:switcherator.c ****     clearTheSwitch(switchNumber);
 11851               		.loc 1 455 0
 11852 43ec 0E94 0000 		call clearTheSwitch
 11853               	.LVL1018:
 457:switcherator.c ****     if (port == 'B' || port == 'b') {
 11854               		.loc 1 457 0
 11855 43f0 2981      		ldd r18,Y+1
 11856 43f2 2234      		cpi r18,lo8(66)
 11857 43f4 01F4      		brne .+2
 11858 43f6 00C0      		rjmp .L802
 457:switcherator.c ****     if (port == 'B' || port == 'b') {
 11859               		.loc 1 457 0 is_stmt 0 discriminator 1
 11860 43f8 2236      		cpi r18,lo8(98)
 11861 43fa 01F4      		brne .+2
 11862 43fc 00C0      		rjmp .L802
 468:switcherator.c ****     } else if (port == 'C' || port == 'c') {
 11863               		.loc 1 468 0 is_stmt 1
 11864 43fe 2334      		cpi r18,lo8(67)
 11865 4400 01F4      		brne .+2
 11866 4402 00C0      		rjmp .L804
 468:switcherator.c ****     } else if (port == 'C' || port == 'c') {
 11867               		.loc 1 468 0 is_stmt 0 discriminator 1
 11868 4404 2336      		cpi r18,lo8(99)
 11869 4406 01F4      		brne .+2
 11870 4408 00C0      		rjmp .L804
 474:switcherator.c ****     } else if (port == 'D' || port == 'd') {
 11871               		.loc 1 474 0 is_stmt 1
 11872 440a 2434      		cpi r18,lo8(68)
 11873 440c 01F4      		brne .+2
 11874 440e 00C0      		rjmp .L806
 474:switcherator.c ****     } else if (port == 'D' || port == 'd') {
 11875               		.loc 1 474 0 is_stmt 0 discriminator 1
 11876 4410 2436      		cpi r18,lo8(100)
 11877 4412 01F0      		breq .+2
 11878 4414 00C0      		rjmp .L816
 11879 4416 00C0      		rjmp .L806
 11880               	.LVL1019:
 11881               	.L817:
 515:switcherator.c ****     } else if ((switchNumber >= NUM_SWITCHES) ||
 11882               		.loc 1 515 0 is_stmt 1 discriminator 1
 11883 4418 0115      		cp r16,__zero_reg__
 11884 441a 1105      		cpc r17,__zero_reg__
 11885 441c 01F4      		brne .L794
 516:switcherator.c ****             ((switchNumber == 0) && (commandReceived[3] != '0') && (commandReceived[4] != 0))) {
 11886               		.loc 1 516 0
 11887 441e D601      		movw r26,r12
 11888 4420 1396      		adiw r26,3
 11889 4422 8C91      		ld r24,X
 11890 4424 1397      		sbiw r26,3
 11891 4426 8033      		cpi r24,lo8(48)
 11892 4428 01F0      		breq .L794
 516:switcherator.c ****             ((switchNumber == 0) && (commandReceived[3] != '0') && (commandReceived[4] != 0))) {
 11893               		.loc 1 516 0 is_stmt 0 discriminator 1
 11894 442a 1496      		adiw r26,4
 11895 442c 8C91      		ld r24,X
 11896 442e 8823      		tst r24
 11897 4430 01F0      		breq .L794
 11898               	.L799:
 517:switcherator.c ****         fail(1);
 11899               		.loc 1 517 0 is_stmt 1
 11900 4432 81E0      		ldi r24,lo8(1)
 11901 4434 90E0      		ldi r25,0
 11902 4436 00C0      		rjmp .L818
 11903               	.L794:
 448:switcherator.c ****     pin = atoi(tempIntString);
 11904               		.loc 1 448 0
 11905 4438 4F2D      		mov r20,r15
 518:switcherator.c ****     } else if ((pin > 7) || ((pin == 0) && (commandReceived[6] != '0'))) {
 11906               		.loc 1 518 0
 11907 443a 4830      		cpi r20,lo8(8)
 11908 443c 00F4      		brsh .L795
 518:switcherator.c ****     } else if ((pin > 7) || ((pin == 0) && (commandReceived[6] != '0'))) {
 11909               		.loc 1 518 0 is_stmt 0 discriminator 1
 11910 443e F110      		cpse r15,__zero_reg__
 11911 4440 00C0      		rjmp .L796
 11912 4442 D601      		movw r26,r12
 11913 4444 1696      		adiw r26,6
 11914 4446 8C91      		ld r24,X
 11915 4448 8033      		cpi r24,lo8(48)
 11916 444a 01F0      		breq .L796
 11917               	.L795:
 519:switcherator.c ****         fail(4);
 11918               		.loc 1 519 0 is_stmt 1
 11919 444c 84E0      		ldi r24,lo8(4)
 11920 444e 90E0      		ldi r25,0
 11921 4450 00C0      		rjmp .L818
 11922               	.L796:
 522:switcherator.c ****         *realDDR |= (1 << originalPin);
 11923               		.loc 1 522 0
 11924 4452 D501      		movw r26,r10
 11925 4454 5C91      		ld r21,X
 11926 4456 21E0      		ldi r18,lo8(1)
 11927 4458 30E0      		ldi r19,0
 11928 445a 0F2C      		mov r0,r15
 11929 445c 00C0      		rjmp 2f
 11930               		1:
 11931 445e 220F      		lsl r18
 11932               		2:
 11933 4460 0A94      		dec r0
 11934 4462 02F4      		brpl 1b
 11935 4464 522B      		or r21,r18
 11936 4466 5C93      		st X,r21
 524:switcherator.c ****         pinMultiplied = pin * 2;
 11937               		.loc 1 524 0
 11938 4468 440F      		lsl r20
 11939               	.LVL1020:
 527:switcherator.c ****         switchStuff[switchNumber] = pin;
 11940               		.loc 1 527 0
 11941 446a D801      		movw r26,r16
 11942 446c A050      		subi r26,lo8(-(switchStuff))
 11943 446e B040      		sbci r27,hi8(-(switchStuff))
 526:switcherator.c ****         pin = pinMultiplied + pinSubtractee;
 11944               		.loc 1 526 0
 11945 4470 490F      		add r20,r25
 11946               	.LVL1021:
 527:switcherator.c ****         switchStuff[switchNumber] = pin;
 11947               		.loc 1 527 0
 11948 4472 4C93      		st X,r20
 531:switcherator.c ****             *realPort |= (1 << originalPin);
 11949               		.loc 1 531 0
 11950 4474 8081      		ld r24,Z
 529:switcherator.c ****         if (direction == 0) {
 11951               		.loc 1 529 0
 11952 4476 E110      		cpse r14,__zero_reg__
 11953 4478 00C0      		rjmp .L797
 531:switcherator.c ****             *realPort |= (1 << originalPin);
 11954               		.loc 1 531 0
 11955 447a 822B      		or r24,r18
 11956 447c 8083      		st Z,r24
 11957 447e 00C0      		rjmp .L798
 11958               	.L797:
 533:switcherator.c ****             *realPort &= ~(1 << originalPin);
 11959               		.loc 1 533 0
 11960 4480 2095      		com r18
 11961 4482 8223      		and r24,r18
 11962 4484 8083      		st Z,r24
 534:switcherator.c ****             switchStuff[switchNumber]++;
 11963               		.loc 1 534 0
 11964 4486 8C91      		ld r24,X
 11965 4488 8F5F      		subi r24,lo8(-(1))
 11966 448a 8C93      		st X,r24
 11967               	.L798:
 11968               	/* epilogue start */
 538:switcherator.c **** }
 11969               		.loc 1 538 0
 11970 448c 0F90      		pop __tmp_reg__
 11971 448e DF91      		pop r29
 11972 4490 CF91      		pop r28
 11973 4492 1F91      		pop r17
 11974 4494 0F91      		pop r16
 11975               	.LVL1022:
 11976 4496 FF90      		pop r15
 11977               	.LVL1023:
 11978 4498 EF90      		pop r14
 11979               	.LVL1024:
 11980 449a DF90      		pop r13
 11981 449c CF90      		pop r12
 11982               	.LVL1025:
 11983 449e BF90      		pop r11
 11984 44a0 AF90      		pop r10
 11985               	.LVL1026:
 536:switcherator.c ****         ok();
 11986               		.loc 1 536 0
 11987 44a2 0C94 0000 		jmp ok
 11988               	.LVL1027:
 11989               	.L816:
 514:switcherator.c ****         fail(2);
 11990               		.loc 1 514 0
 11991 44a6 82E0      		ldi r24,lo8(2)
 11992 44a8 90E0      		ldi r25,0
 11993               	.LVL1028:
 11994               	.L818:
 11995               	/* epilogue start */
 538:switcherator.c **** }
 11996               		.loc 1 538 0
 11997 44aa 0F90      		pop __tmp_reg__
 11998 44ac DF91      		pop r29
 11999 44ae CF91      		pop r28
 12000 44b0 1F91      		pop r17
 12001 44b2 0F91      		pop r16
 12002               	.LVL1029:
 12003 44b4 FF90      		pop r15
 12004               	.LVL1030:
 12005 44b6 EF90      		pop r14
 12006               	.LVL1031:
 12007 44b8 DF90      		pop r13
 12008 44ba CF90      		pop r12
 12009               	.LVL1032:
 12010 44bc BF90      		pop r11
 12011 44be AF90      		pop r10
 514:switcherator.c ****         fail(2);
 12012               		.loc 1 514 0
 12013 44c0 0C94 0000 		jmp fail
 12014               	.LVL1033:
 12015               	.L802:
 459:switcherator.c ****         realDDR = &DDRB;
 12016               		.loc 1 459 0
 12017 44c4 64E2      		ldi r22,lo8(36)
 12018 44c6 A62E      		mov r10,r22
 12019 44c8 B12C      		mov r11,__zero_reg__
 458:switcherator.c ****         realPort = &PORTB;
 12020               		.loc 1 458 0
 12021 44ca E5E2      		ldi r30,lo8(37)
 12022 44cc F0E0      		ldi r31,0
 460:switcherator.c ****         pinSubtractee = 16;
 12023               		.loc 1 460 0
 12024 44ce 90E1      		ldi r25,lo8(16)
 12025 44d0 00C0      		rjmp .L792
 12026               	.L804:
 470:switcherator.c ****         realDDR = &DDRC;
 12027               		.loc 1 470 0
 12028 44d2 57E2      		ldi r21,lo8(39)
 12029 44d4 A52E      		mov r10,r21
 12030 44d6 B12C      		mov r11,__zero_reg__
 469:switcherator.c ****         realPort = &PORTC;
 12031               		.loc 1 469 0
 12032 44d8 E8E2      		ldi r30,lo8(40)
 12033 44da F0E0      		ldi r31,0
 471:switcherator.c ****         pinSubtractee = 32;
 12034               		.loc 1 471 0
 12035 44dc 90E2      		ldi r25,lo8(32)
 12036 44de 00C0      		rjmp .L792
 12037               	.L806:
 476:switcherator.c ****         realDDR = &DDRD;
 12038               		.loc 1 476 0
 12039 44e0 4AE2      		ldi r20,lo8(42)
 12040 44e2 A42E      		mov r10,r20
 12041 44e4 B12C      		mov r11,__zero_reg__
 475:switcherator.c ****         realPort = &PORTD;
 12042               		.loc 1 475 0
 12043 44e6 EBE2      		ldi r30,lo8(43)
 12044 44e8 F0E0      		ldi r31,0
 477:switcherator.c ****         pinSubtractee = 48;
 12045               		.loc 1 477 0
 12046 44ea 90E3      		ldi r25,lo8(48)
 12047               	.L792:
 12048               	.LVL1034:
 515:switcherator.c ****     } else if ((switchNumber >= NUM_SWITCHES) ||
 12049               		.loc 1 515 0
 12050 44ec 0031      		cpi r16,16
 12051 44ee 1105      		cpc r17,__zero_reg__
 12052 44f0 04F4      		brge .+2
 12053 44f2 00C0      		rjmp .L817
 12054 44f4 00C0      		rjmp .L799
 12055               	.LFE13:
 12057               		.section	.rodata.str1.1
 12058               	.LC70:
 12059 015c 5374 6172 		.string	"Start:"
 12059      743A 00
 12060               	.LC71:
 12061 0163 5374 6F70 		.string	"Stop:"
 12061      3A00 
 12062               		.text
 12063               	.global	setTimeLimits
 12065               	setTimeLimits:
 12066               	.LFB59:
2531:switcherator.c **** void setTimeLimits(char * commandReceived) {
 12067               		.loc 1 2531 0
 12068               	.LVL1035:
 12069 44f6 2F92      		push r2
 12070               	.LCFI319:
 12071 44f8 3F92      		push r3
 12072               	.LCFI320:
 12073 44fa 4F92      		push r4
 12074               	.LCFI321:
 12075 44fc 5F92      		push r5
 12076               	.LCFI322:
 12077 44fe 6F92      		push r6
 12078               	.LCFI323:
 12079 4500 7F92      		push r7
 12080               	.LCFI324:
 12081 4502 8F92      		push r8
 12082               	.LCFI325:
 12083 4504 9F92      		push r9
 12084               	.LCFI326:
 12085 4506 AF92      		push r10
 12086               	.LCFI327:
 12087 4508 BF92      		push r11
 12088               	.LCFI328:
 12089 450a CF92      		push r12
 12090               	.LCFI329:
 12091 450c DF92      		push r13
 12092               	.LCFI330:
 12093 450e EF92      		push r14
 12094               	.LCFI331:
 12095 4510 FF92      		push r15
 12096               	.LCFI332:
 12097 4512 0F93      		push r16
 12098               	.LCFI333:
 12099 4514 1F93      		push r17
 12100               	.LCFI334:
 12101 4516 CF93      		push r28
 12102               	.LCFI335:
 12103 4518 DF93      		push r29
 12104               	.LCFI336:
 12105 451a CDB7      		in r28,__SP_L__
 12106 451c DEB7      		in r29,__SP_H__
 12107               	.LCFI337:
 12108 451e 2C97      		sbiw r28,12
 12109               	.LCFI338:
 12110 4520 0FB6      		in __tmp_reg__,__SREG__
 12111 4522 F894      		cli
 12112 4524 DEBF      		out __SP_H__,r29
 12113 4526 0FBE      		out __SREG__,__tmp_reg__
 12114 4528 CDBF      		out __SP_L__,r28
 12115               	/* prologue: function */
 12116               	/* frame size = 12 */
 12117               	/* stack size = 30 */
 12118               	.L__stack_usage = 30
 12119 452a 6C01      		movw r12,r24
2532:switcherator.c ****     char tempReallyLongString[] = "0000000";
 12120               		.loc 1 2532 0
 12121 452c 88E0      		ldi r24,lo8(8)
 12122               	.LVL1036:
 12123 452e E0E0      		ldi r30,lo8(.LC69)
 12124 4530 F0E0      		ldi r31,hi8(.LC69)
 12125 4532 DE01      		movw r26,r28
 12126 4534 1196      		adiw r26,1
 12127               		0:
 12128 4536 0190      		ld r0,Z+
 12129 4538 0D92      		st X+,r0
 12130 453a 8A95      		dec r24
 12131 453c 01F4      		brne 0b
 12132               	.LVL1037:
2538:switcherator.c ****     statusMsg[0] = 0;
 12133               		.loc 1 2538 0
 12134 453e 1092 0000 		sts statusMsg,__zero_reg__
2540:switcherator.c ****     tempIntString[0] = commandReceived[3];
 12135               		.loc 1 2540 0
 12136 4542 F601      		movw r30,r12
 12137 4544 8381      		ldd r24,Z+3
 12138 4546 8093 0000 		sts tempIntString,r24
2541:switcherator.c ****     tempIntString[1] = commandReceived[4];
 12139               		.loc 1 2541 0
 12140 454a 8481      		ldd r24,Z+4
 12141 454c 8093 0000 		sts tempIntString+1,r24
2542:switcherator.c ****     programNumber = atoi(tempIntString);
 12142               		.loc 1 2542 0
 12143 4550 80E0      		ldi r24,lo8(tempIntString)
 12144 4552 90E0      		ldi r25,hi8(tempIntString)
 12145 4554 0E94 0000 		call atoi
 12146               	.LVL1038:
 12147 4558 8C01      		movw r16,r24
 12148               	.LVL1039:
2543:switcherator.c ****     if (programNumber > NUM_LIMITS) {
 12149               		.loc 1 2543 0
 12150 455a 8530      		cpi r24,5
 12151 455c 9105      		cpc r25,__zero_reg__
 12152 455e 04F0      		brlt .L820
2544:switcherator.c ****         fail(0x10);
 12153               		.loc 1 2544 0
 12154 4560 80E1      		ldi r24,lo8(16)
 12155 4562 90E0      		ldi r25,0
 12156 4564 00C0      		rjmp .L831
 12157               	.L820:
2547:switcherator.c ****     if (commandReceived[5] == 'x' || commandReceived[5] == 'x') {
 12158               		.loc 1 2547 0
 12159 4566 F601      		movw r30,r12
 12160 4568 8581      		ldd r24,Z+5
 12161 456a 8837      		cpi r24,lo8(120)
 12162 456c 01F4      		brne .L822
2548:switcherator.c ****         timeLimits[programNumber][2] = 0;
 12163               		.loc 1 2548 0
 12164 456e 8CE0      		ldi r24,lo8(12)
 12165 4570 809F      		mul r24,r16
 12166 4572 F001      		movw r30,r0
 12167 4574 819F      		mul r24,r17
 12168 4576 F00D      		add r31,r0
 12169 4578 1124      		clr __zero_reg__
 12170 457a E050      		subi r30,lo8(-(timeLimits))
 12171 457c F040      		sbci r31,hi8(-(timeLimits))
 12172 457e 1086      		std Z+8,__zero_reg__
 12173 4580 1186      		std Z+9,__zero_reg__
 12174 4582 1286      		std Z+10,__zero_reg__
 12175 4584 1386      		std Z+11,__zero_reg__
 12176 4586 00C0      		rjmp .L832
 12177               	.L822:
2552:switcherator.c ****     if (commandReceived[5] == '?') {
 12178               		.loc 1 2552 0
 12179 4588 8F33      		cpi r24,lo8(63)
 12180 458a 01F0      		breq .+2
 12181 458c 00C0      		rjmp .L823
2554:switcherator.c ****         startTime = timeLimits[programNumber][0];
 12182               		.loc 1 2554 0
 12183 458e 8CE0      		ldi r24,lo8(12)
 12184 4590 809F      		mul r24,r16
 12185 4592 F001      		movw r30,r0
 12186 4594 819F      		mul r24,r17
 12187 4596 F00D      		add r31,r0
 12188 4598 1124      		clr __zero_reg__
 12189 459a E050      		subi r30,lo8(-(timeLimits))
 12190 459c F040      		sbci r31,hi8(-(timeLimits))
 12191 459e 8080      		ld r8,Z
 12192 45a0 9180      		ldd r9,Z+1
 12193 45a2 A280      		ldd r10,Z+2
 12194 45a4 B380      		ldd r11,Z+3
 12195               	.LVL1040:
2556:switcherator.c ****         strcat(statusMsg, "Start:");
 12196               		.loc 1 2556 0
 12197 45a6 60E0      		ldi r22,lo8(.LC70)
 12198 45a8 70E0      		ldi r23,hi8(.LC70)
 12199 45aa 80E0      		ldi r24,lo8(statusMsg)
 12200 45ac 90E0      		ldi r25,hi8(statusMsg)
 12201 45ae 0E94 0000 		call strcat
 12202               	.LVL1041:
2557:switcherator.c ****         startHour = (startTime / 60 / 60);
 12203               		.loc 1 2557 0
 12204 45b2 C501      		movw r24,r10
 12205 45b4 B401      		movw r22,r8
 12206 45b6 20E1      		ldi r18,lo8(16)
 12207 45b8 3EE0      		ldi r19,lo8(14)
 12208 45ba 40E0      		ldi r20,0
 12209 45bc 50E0      		ldi r21,0
 12210 45be 0E94 0000 		call __divmodsi4
 12211 45c2 6901      		movw r12,r18
 12212 45c4 7A01      		movw r14,r20
 12213               	.LVL1042:
2558:switcherator.c ****         returnInt(startHour, tempLongString);
 12214               		.loc 1 2558 0
 12215 45c6 60E0      		ldi r22,lo8(tempLongString)
 12216 45c8 70E0      		ldi r23,hi8(tempLongString)
 12217 45ca C901      		movw r24,r18
 12218 45cc 0E94 0000 		call returnInt
 12219               	.LVL1043:
2559:switcherator.c ****         strcat(statusMsg, tempLongString);
 12220               		.loc 1 2559 0
 12221 45d0 60E0      		ldi r22,lo8(tempLongString)
 12222 45d2 70E0      		ldi r23,hi8(tempLongString)
 12223 45d4 80E0      		ldi r24,lo8(statusMsg)
 12224 45d6 90E0      		ldi r25,hi8(statusMsg)
 12225 45d8 0E94 0000 		call strcat
 12226               	.LVL1044:
2561:switcherator.c ****         strcat(statusMsg, ":");
 12227               		.loc 1 2561 0
 12228 45dc 60E0      		ldi r22,lo8(.LC4)
 12229 45de 70E0      		ldi r23,hi8(.LC4)
 12230 45e0 80E0      		ldi r24,lo8(statusMsg)
 12231 45e2 90E0      		ldi r25,hi8(statusMsg)
 12232 45e4 0E94 0000 		call strcat
 12233               	.LVL1045:
2560:switcherator.c ****         startMinute = ((startTime - (startHour * 60 * 60)) / 60);
 12234               		.loc 1 2560 0
 12235 45e8 20E1      		ldi r18,lo8(16)
 12236 45ea 3EE0      		ldi r19,lo8(14)
 12237 45ec C29E      		mul r12,r18
 12238 45ee C001      		movw r24,r0
 12239 45f0 C39E      		mul r12,r19
 12240 45f2 900D      		add r25,r0
 12241 45f4 D29E      		mul r13,r18
 12242 45f6 900D      		add r25,r0
 12243 45f8 1124      		clr r1
 12244 45fa A501      		movw r20,r10
 12245 45fc 9401      		movw r18,r8
 12246 45fe 281B      		sub r18,r24
 12247 4600 390B      		sbc r19,r25
 12248 4602 4109      		sbc r20,__zero_reg__
 12249 4604 5109      		sbc r21,__zero_reg__
 12250 4606 CA01      		movw r24,r20
 12251 4608 B901      		movw r22,r18
 12252 460a 2CE3      		ldi r18,lo8(60)
 12253 460c 30E0      		ldi r19,0
 12254 460e 40E0      		ldi r20,0
 12255 4610 50E0      		ldi r21,0
 12256 4612 0E94 0000 		call __divmodsi4
2562:switcherator.c ****         returnInt(startMinute, tempLongString);
 12257               		.loc 1 2562 0
 12258 4616 60E0      		ldi r22,lo8(tempLongString)
 12259 4618 70E0      		ldi r23,hi8(tempLongString)
 12260 461a C901      		movw r24,r18
 12261 461c 2987      		std Y+9,r18
 12262 461e 3A87      		std Y+10,r19
 12263 4620 4B87      		std Y+11,r20
 12264 4622 5C87      		std Y+12,r21
 12265 4624 0E94 0000 		call returnInt
 12266               	.LVL1046:
2563:switcherator.c ****         strcat(statusMsg, tempLongString);
 12267               		.loc 1 2563 0
 12268 4628 60E0      		ldi r22,lo8(tempLongString)
 12269 462a 70E0      		ldi r23,hi8(tempLongString)
 12270 462c 80E0      		ldi r24,lo8(statusMsg)
 12271 462e 90E0      		ldi r25,hi8(statusMsg)
 12272 4630 0E94 0000 		call strcat
 12273               	.LVL1047:
2564:switcherator.c ****         strcat(statusMsg, "Stop:");
 12274               		.loc 1 2564 0
 12275 4634 60E0      		ldi r22,lo8(.LC71)
 12276 4636 70E0      		ldi r23,hi8(.LC71)
 12277 4638 80E0      		ldi r24,lo8(statusMsg)
 12278 463a 90E0      		ldi r25,hi8(statusMsg)
 12279 463c 0E94 0000 		call strcat
 12280               	.LVL1048:
2566:switcherator.c ****         returnInt(stopHour, tempLongString);
 12281               		.loc 1 2566 0
 12282 4640 60E0      		ldi r22,lo8(tempLongString)
 12283 4642 70E0      		ldi r23,hi8(tempLongString)
 12284 4644 C601      		movw r24,r12
 12285 4646 0E94 0000 		call returnInt
 12286               	.LVL1049:
2567:switcherator.c ****         strcat(statusMsg, tempLongString);
 12287               		.loc 1 2567 0
 12288 464a 60E0      		ldi r22,lo8(tempLongString)
 12289 464c 70E0      		ldi r23,hi8(tempLongString)
 12290 464e 80E0      		ldi r24,lo8(statusMsg)
 12291 4650 90E0      		ldi r25,hi8(statusMsg)
 12292 4652 0E94 0000 		call strcat
 12293               	.LVL1050:
2569:switcherator.c ****         strcat(statusMsg, ":");
 12294               		.loc 1 2569 0
 12295 4656 60E0      		ldi r22,lo8(.LC4)
 12296 4658 70E0      		ldi r23,hi8(.LC4)
 12297 465a 80E0      		ldi r24,lo8(statusMsg)
 12298 465c 90E0      		ldi r25,hi8(statusMsg)
 12299 465e 0E94 0000 		call strcat
 12300               	.LVL1051:
2570:switcherator.c ****         returnInt(stopMinute, tempLongString);
 12301               		.loc 1 2570 0
 12302 4662 60E0      		ldi r22,lo8(tempLongString)
 12303 4664 70E0      		ldi r23,hi8(tempLongString)
 12304 4666 2985      		ldd r18,Y+9
 12305 4668 3A85      		ldd r19,Y+10
 12306 466a C901      		movw r24,r18
 12307 466c 0E94 0000 		call returnInt
 12308               	.LVL1052:
2571:switcherator.c ****         strcat(statusMsg, tempLongString);
 12309               		.loc 1 2571 0
 12310 4670 60E0      		ldi r22,lo8(tempLongString)
 12311 4672 70E0      		ldi r23,hi8(tempLongString)
 12312 4674 80E0      		ldi r24,lo8(statusMsg)
 12313 4676 90E0      		ldi r25,hi8(statusMsg)
 12314 4678 0E94 0000 		call strcat
 12315               	.LVL1053:
2572:switcherator.c ****         sendMessage(statusMsg);
 12316               		.loc 1 2572 0
 12317 467c 80E0      		ldi r24,lo8(statusMsg)
 12318 467e 90E0      		ldi r25,hi8(statusMsg)
 12319 4680 0E94 0000 		call sendMessage
 12320               	.LVL1054:
 12321 4684 00C0      		rjmp .L819
 12322               	.LVL1055:
 12323               	.L823:
2531:switcherator.c **** void setTimeLimits(char * commandReceived) {
 12324               		.loc 1 2531 0
 12325 4686 D601      		movw r26,r12
 12326 4688 1D96      		adiw r26,13
 12327 468a FE01      		movw r30,r28
 12328 468c 3196      		adiw r30,1
 12329 468e CE01      		movw r24,r28
 12330 4690 0896      		adiw r24,8
 12331               	.LVL1056:
 12332               	.L824:
2576:switcherator.c ****         tempReallyLongString[x] = commandReceived[x + 13];
 12333               		.loc 1 2576 0 discriminator 2
 12334 4692 2D91      		ld r18,X+
 12335 4694 2193      		st Z+,r18
2575:switcherator.c ****     for (x = 0; x < 7; x++) {
 12336               		.loc 1 2575 0 discriminator 2
 12337 4696 E817      		cp r30,r24
 12338 4698 F907      		cpc r31,r25
 12339 469a 01F4      		brne .L824
2578:switcherator.c ****     weekLong = strtol(tempReallyLongString, 0, 2);
 12340               		.loc 1 2578 0
 12341 469c 42E0      		ldi r20,lo8(2)
 12342 469e 50E0      		ldi r21,0
 12343 46a0 60E0      		ldi r22,0
 12344 46a2 70E0      		ldi r23,0
 12345 46a4 CE01      		movw r24,r28
 12346 46a6 0196      		adiw r24,1
 12347 46a8 0E94 0000 		call strtol
 12348               	.LVL1057:
 12349 46ac 2B01      		movw r4,r22
 12350 46ae 3C01      		movw r6,r24
 12351               	.LVL1058:
2579:switcherator.c ****     tempIntString[0] = commandReceived[5];
 12352               		.loc 1 2579 0
 12353 46b0 F601      		movw r30,r12
 12354 46b2 8581      		ldd r24,Z+5
 12355 46b4 8093 0000 		sts tempIntString,r24
2580:switcherator.c ****     tempIntString[1] = commandReceived[6];
 12356               		.loc 1 2580 0
 12357 46b8 8681      		ldd r24,Z+6
 12358 46ba 8093 0000 		sts tempIntString+1,r24
2581:switcherator.c ****     startHour = atoi(tempIntString);
 12359               		.loc 1 2581 0
 12360 46be 80E0      		ldi r24,lo8(tempIntString)
 12361 46c0 90E0      		ldi r25,hi8(tempIntString)
 12362 46c2 0E94 0000 		call atoi
 12363               	.LVL1059:
 12364 46c6 7C01      		movw r14,r24
 12365               	.LVL1060:
2582:switcherator.c ****     tempIntString[0] = commandReceived[7];
 12366               		.loc 1 2582 0
 12367 46c8 F601      		movw r30,r12
 12368 46ca 8781      		ldd r24,Z+7
 12369 46cc 8093 0000 		sts tempIntString,r24
2583:switcherator.c ****     tempIntString[1] = commandReceived[8];
 12370               		.loc 1 2583 0
 12371 46d0 8085      		ldd r24,Z+8
 12372 46d2 8093 0000 		sts tempIntString+1,r24
2584:switcherator.c ****     startMinute = atoi(tempIntString);
 12373               		.loc 1 2584 0
 12374 46d6 80E0      		ldi r24,lo8(tempIntString)
 12375 46d8 90E0      		ldi r25,hi8(tempIntString)
 12376 46da 0E94 0000 		call atoi
 12377               	.LVL1061:
 12378 46de 4C01      		movw r8,r24
 12379               	.LVL1062:
2585:switcherator.c ****     tempIntString[0] = commandReceived[9];
 12380               		.loc 1 2585 0
 12381 46e0 F601      		movw r30,r12
 12382 46e2 8185      		ldd r24,Z+9
 12383 46e4 8093 0000 		sts tempIntString,r24
2586:switcherator.c ****     tempIntString[1] = commandReceived[10];
 12384               		.loc 1 2586 0
 12385 46e8 8285      		ldd r24,Z+10
 12386 46ea 8093 0000 		sts tempIntString+1,r24
2587:switcherator.c ****     stopHour = atoi(tempIntString);
 12387               		.loc 1 2587 0
 12388 46ee 80E0      		ldi r24,lo8(tempIntString)
 12389 46f0 90E0      		ldi r25,hi8(tempIntString)
 12390 46f2 0E94 0000 		call atoi
 12391               	.LVL1063:
 12392 46f6 1C01      		movw r2,r24
 12393               	.LVL1064:
2588:switcherator.c ****     tempIntString[0] = commandReceived[11];
 12394               		.loc 1 2588 0
 12395 46f8 F601      		movw r30,r12
 12396 46fa 8385      		ldd r24,Z+11
 12397 46fc 8093 0000 		sts tempIntString,r24
2589:switcherator.c ****     tempIntString[1] = commandReceived[12];
 12398               		.loc 1 2589 0
 12399 4700 8485      		ldd r24,Z+12
 12400 4702 8093 0000 		sts tempIntString+1,r24
2590:switcherator.c ****     stopMinute = atoi(tempIntString);
 12401               		.loc 1 2590 0
 12402 4706 80E0      		ldi r24,lo8(tempIntString)
 12403 4708 90E0      		ldi r25,hi8(tempIntString)
 12404 470a 0E94 0000 		call atoi
 12405               	.LVL1065:
2591:switcherator.c ****     if (startHour > 23 || stopHour > 23) {
 12406               		.loc 1 2591 0
 12407 470e F8E1      		ldi r31,24
 12408 4710 EF16      		cp r14,r31
 12409 4712 F104      		cpc r15,__zero_reg__
 12410 4714 00F4      		brsh .L825
2591:switcherator.c ****     if (startHour > 23 || stopHour > 23) {
 12411               		.loc 1 2591 0 is_stmt 0 discriminator 1
 12412 4716 28E1      		ldi r18,24
 12413 4718 2216      		cp r2,r18
 12414 471a 3104      		cpc r3,__zero_reg__
 12415 471c 00F0      		brlo .L826
 12416               	.L825:
2592:switcherator.c ****         fail(0x09);
 12417               		.loc 1 2592 0 is_stmt 1
 12418 471e 89E0      		ldi r24,lo8(9)
 12419 4720 90E0      		ldi r25,0
 12420               	.LVL1066:
 12421 4722 00C0      		rjmp .L831
 12422               	.LVL1067:
 12423               	.L826:
2584:switcherator.c ****     startMinute = atoi(tempIntString);
 12424               		.loc 1 2584 0
 12425 4724 F401      		movw r30,r8
2595:switcherator.c ****     if (startMinute > 59 || stopMinute > 59) {
 12426               		.loc 1 2595 0
 12427 4726 EC33      		cpi r30,60
 12428 4728 F105      		cpc r31,__zero_reg__
 12429 472a 00F4      		brsh .L827
2590:switcherator.c ****     stopMinute = atoi(tempIntString);
 12430               		.loc 1 2590 0 discriminator 1
 12431 472c AC01      		movw r20,r24
2595:switcherator.c ****     if (startMinute > 59 || stopMinute > 59) {
 12432               		.loc 1 2595 0 discriminator 1
 12433 472e 8C33      		cpi r24,60
 12434 4730 9105      		cpc r25,__zero_reg__
 12435 4732 00F0      		brlo .L828
 12436               	.L827:
2596:switcherator.c ****         fail(0x0A);
 12437               		.loc 1 2596 0
 12438 4734 8AE0      		ldi r24,lo8(10)
 12439 4736 90E0      		ldi r25,0
 12440               	.LVL1068:
 12441               	.L831:
 12442 4738 0E94 0000 		call fail
 12443               	.LVL1069:
 12444 473c 00C0      		rjmp .L819
 12445               	.LVL1070:
 12446               	.L828:
2600:switcherator.c ****     startTime = startTime * 60 * 60;
 12447               		.loc 1 2600 0
 12448 473e 9701      		movw r18,r14
 12449 4740 A0E1      		ldi r26,lo8(16)
 12450 4742 BEE0      		ldi r27,lo8(14)
 12451 4744 0E94 0000 		call __umulhisi3
 12452 4748 6B01      		movw r12,r22
 12453 474a 7C01      		movw r14,r24
 12454               	.LVL1071:
2603:switcherator.c ****     stopTime = stopTime * 60 * 60;
 12455               		.loc 1 2603 0
 12456 474c 9101      		movw r18,r2
 12457 474e 0E94 0000 		call __umulhisi3
 12458               	.LVL1072:
2605:switcherator.c ****     timeLimits[programNumber][0] = startTime;
 12459               		.loc 1 2605 0
 12460 4752 2CE0      		ldi r18,lo8(12)
 12461 4754 209F      		mul r18,r16
 12462 4756 D001      		movw r26,r0
 12463 4758 219F      		mul r18,r17
 12464 475a B00D      		add r27,r0
 12465 475c 1124      		clr __zero_reg__
 12466 475e A050      		subi r26,lo8(-(timeLimits))
 12467 4760 B040      		sbci r27,hi8(-(timeLimits))
2601:switcherator.c ****     startTime += (startMinute * 60);
 12468               		.loc 1 2601 0
 12469 4762 2CE3      		ldi r18,lo8(60)
 12470 4764 289D      		mul r18,r8
 12471 4766 8001      		movw r16,r0
 12472 4768 299D      		mul r18,r9
 12473 476a 100D      		add r17,r0
 12474 476c 1124      		clr __zero_reg__
 12475               	.LVL1073:
 12476 476e C00E      		add r12,r16
 12477 4770 D11E      		adc r13,r17
 12478 4772 E11C      		adc r14,__zero_reg__
 12479 4774 F11C      		adc r15,__zero_reg__
 12480               	.LVL1074:
2605:switcherator.c ****     timeLimits[programNumber][0] = startTime;
 12481               		.loc 1 2605 0
 12482 4776 CD92      		st X+,r12
 12483 4778 DD92      		st X+,r13
 12484 477a ED92      		st X+,r14
 12485 477c FC92      		st X,r15
 12486 477e 1397      		sbiw r26,3
2604:switcherator.c ****     stopTime += (stopMinute * 60);
 12487               		.loc 1 2604 0
 12488 4780 249F      		mul r18,r20
 12489 4782 F001      		movw r30,r0
 12490 4784 259F      		mul r18,r21
 12491 4786 F00D      		add r31,r0
 12492 4788 1124      		clr __zero_reg__
 12493 478a 6E0F      		add r22,r30
 12494 478c 7F1F      		adc r23,r31
 12495 478e 811D      		adc r24,__zero_reg__
 12496 4790 911D      		adc r25,__zero_reg__
 12497               	.LVL1075:
2606:switcherator.c ****     timeLimits[programNumber][1] = stopTime;
 12498               		.loc 1 2606 0
 12499 4792 1496      		adiw r26,4
 12500 4794 6D93      		st X+,r22
 12501 4796 7D93      		st X+,r23
 12502 4798 8D93      		st X+,r24
 12503 479a 9C93      		st X,r25
 12504 479c 1797      		sbiw r26,4+3
2607:switcherator.c ****     timeLimits[programNumber][2] = weekLong;
 12505               		.loc 1 2607 0
 12506 479e 1896      		adiw r26,8
 12507 47a0 4D92      		st X+,r4
 12508 47a2 5D92      		st X+,r5
 12509 47a4 6D92      		st X+,r6
 12510 47a6 7C92      		st X,r7
 12511 47a8 1B97      		sbiw r26,8+3
 12512               	.LVL1076:
 12513               	.L832:
2608:switcherator.c ****     ok();
 12514               		.loc 1 2608 0
 12515 47aa 0E94 0000 		call ok
 12516               	.LVL1077:
 12517               	.L819:
 12518               	/* epilogue start */
2610:switcherator.c **** }
 12519               		.loc 1 2610 0
 12520 47ae 2C96      		adiw r28,12
 12521 47b0 0FB6      		in __tmp_reg__,__SREG__
 12522 47b2 F894      		cli
 12523 47b4 DEBF      		out __SP_H__,r29
 12524 47b6 0FBE      		out __SREG__,__tmp_reg__
 12525 47b8 CDBF      		out __SP_L__,r28
 12526 47ba DF91      		pop r29
 12527 47bc CF91      		pop r28
 12528 47be 1F91      		pop r17
 12529 47c0 0F91      		pop r16
 12530 47c2 FF90      		pop r15
 12531 47c4 EF90      		pop r14
 12532 47c6 DF90      		pop r13
 12533 47c8 CF90      		pop r12
 12534 47ca BF90      		pop r11
 12535 47cc AF90      		pop r10
 12536 47ce 9F90      		pop r9
 12537 47d0 8F90      		pop r8
 12538 47d2 7F90      		pop r7
 12539 47d4 6F90      		pop r6
 12540 47d6 5F90      		pop r5
 12541 47d8 4F90      		pop r4
 12542 47da 3F90      		pop r3
 12543 47dc 2F90      		pop r2
 12544 47de 0895      		ret
 12545               	.LFE59:
 12547               		.section	.rodata.str1.1
 12548               	.LC72:
 12549 0169 4E65 7720 		.string	"New prog#"
 12549      7072 6F67 
 12549      2300 
 12550               		.text
 12551               	.global	newProgram
 12553               	newProgram:
 12554               	.LFB30:
1197:switcherator.c **** void newProgram(char * commandReceived) {
 12555               		.loc 1 1197 0
 12556               	.LVL1078:
 12557 47e0 AF92      		push r10
 12558               	.LCFI339:
 12559 47e2 BF92      		push r11
 12560               	.LCFI340:
 12561 47e4 CF92      		push r12
 12562               	.LCFI341:
 12563 47e6 DF92      		push r13
 12564               	.LCFI342:
 12565 47e8 EF92      		push r14
 12566               	.LCFI343:
 12567 47ea FF92      		push r15
 12568               	.LCFI344:
 12569 47ec 0F93      		push r16
 12570               	.LCFI345:
 12571 47ee 1F93      		push r17
 12572               	.LCFI346:
 12573 47f0 CF93      		push r28
 12574               	.LCFI347:
 12575 47f2 DF93      		push r29
 12576               	.LCFI348:
 12577               	/* prologue: function */
 12578               	/* frame size = 0 */
 12579               	/* stack size = 10 */
 12580               	.L__stack_usage = 10
 12581 47f4 EC01      		movw r28,r24
 12582               	.LVL1079:
 12583 47f6 E0E0      		ldi r30,lo8(weeklyProgram+1)
 12584 47f8 F0E0      		ldi r31,hi8(weeklyProgram+1)
1205:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 12585               		.loc 1 1205 0
 12586 47fa 00E0      		ldi r16,0
 12587 47fc 10E0      		ldi r17,0
 12588               	.LVL1080:
 12589               	.L836:
1197:switcherator.c **** void newProgram(char * commandReceived) {
 12590               		.loc 1 1197 0
 12591 47fe DF01      		movw r26,r30
 12592 4800 1197      		sbiw r26,1
1207:switcherator.c ****         if (weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) {
 12593               		.loc 1 1207 0
 12594 4802 8C91      		ld r24,X
 12595 4804 8F3F      		cpi r24,lo8(-1)
 12596 4806 01F4      		brne .L834
1207:switcherator.c ****         if (weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) {
 12597               		.loc 1 1207 0 is_stmt 0 discriminator 1
 12598 4808 8081      		ld r24,Z
 12599 480a 8F3F      		cpi r24,lo8(-1)
 12600 480c 01F4      		brne .+2
 12601 480e 00C0      		rjmp .L835
 12602               	.L834:
1205:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 12603               		.loc 1 1205 0 is_stmt 1
 12604 4810 0F5F      		subi r16,-1
 12605 4812 1F4F      		sbci r17,-1
 12606               	.LVL1081:
 12607 4814 3A96      		adiw r30,10
 12608 4816 0A30      		cpi r16,10
 12609 4818 1105      		cpc r17,__zero_reg__
 12610 481a 01F4      		brne .L836
 12611 481c 00C0      		rjmp .L851
 12612               	.LVL1082:
 12613               	.L852:
1230:switcherator.c ****     if (hours >= 24 || (hours == 0 && commandReceived[4] != '0')) {
 12614               		.loc 1 1230 0 discriminator 1
 12615 481e E114      		cp r14,__zero_reg__
 12616 4820 F104      		cpc r15,__zero_reg__
 12617 4822 01F4      		brne .L838
 12618 4824 20E3      		ldi r18,lo8(48)
 12619 4826 A216      		cp r10,r18
 12620 4828 01F0      		breq .L838
 12621               	.L842:
1231:switcherator.c ****         fail(9);
 12622               		.loc 1 1231 0
 12623 482a 89E0      		ldi r24,lo8(9)
 12624 482c 90E0      		ldi r25,0
 12625               	.LVL1083:
 12626 482e 00C0      		rjmp .L853
 12627               	.LVL1084:
 12628               	.L838:
1234:switcherator.c ****     if (minutes >= 60 || (minutes == 0 && commandReceived[6] != '0')) {
 12629               		.loc 1 1234 0
 12630 4830 2CE3      		ldi r18,60
 12631 4832 C216      		cp r12,r18
 12632 4834 D104      		cpc r13,__zero_reg__
 12633 4836 04F4      		brge .L839
1234:switcherator.c ****     if (minutes >= 60 || (minutes == 0 && commandReceived[6] != '0')) {
 12634               		.loc 1 1234 0 is_stmt 0 discriminator 1
 12635 4838 C114      		cp r12,__zero_reg__
 12636 483a D104      		cpc r13,__zero_reg__
 12637 483c 01F4      		brne .L840
 12638 483e 20E3      		ldi r18,lo8(48)
 12639 4840 B216      		cp r11,r18
 12640 4842 01F0      		breq .L840
 12641               	.L839:
1235:switcherator.c ****         fail(0x0a);
 12642               		.loc 1 1235 0 is_stmt 1
 12643 4844 8AE0      		ldi r24,lo8(10)
 12644 4846 90E0      		ldi r25,0
 12645               	.LVL1085:
 12646 4848 00C0      		rjmp .L853
 12647               	.LVL1086:
 12648               	.L840:
1238:switcherator.c ****     if (duration == 0) {
 12649               		.loc 1 1238 0
 12650 484a 0097      		sbiw r24,0
 12651 484c 01F4      		brne .L841
1239:switcherator.c ****         fail(0x0b);
 12652               		.loc 1 1239 0
 12653 484e 8BE0      		ldi r24,lo8(11)
 12654 4850 90E0      		ldi r25,0
 12655               	.LVL1087:
 12656 4852 00C0      		rjmp .L853
 12657               	.LVL1088:
 12658               	.L841:
1242:switcherator.c ****     duration *= 60; // convert to seconds
 12659               		.loc 1 1242 0
 12660 4854 6CE3      		ldi r22,lo8(60)
 12661 4856 689F      		mul r22,r24
 12662 4858 A001      		movw r20,r0
 12663 485a 699F      		mul r22,r25
 12664 485c 500D      		add r21,r0
 12665 485e 1124      		clr __zero_reg__
 12666               	.LVL1089:
1243:switcherator.c ****     startTime = (hours * 60);
 12667               		.loc 1 1243 0
 12668 4860 6E9D      		mul r22,r14
 12669 4862 9001      		movw r18,r0
 12670 4864 6F9D      		mul r22,r15
 12671 4866 300D      		add r19,r0
 12672 4868 1124      		clr __zero_reg__
 12673               	.LVL1090:
1244:switcherator.c ****     startTime += minutes; // stored in minutes
 12674               		.loc 1 1244 0
 12675 486a 2C0D      		add r18,r12
 12676 486c 3D1D      		adc r19,r13
 12677               	.LVL1091:
1247:switcherator.c ****     weeklyProgram[programNumber][1] = temp;
 12678               		.loc 1 1247 0
 12679 486e 8AE0      		ldi r24,lo8(10)
 12680 4870 809F      		mul r24,r16
 12681 4872 F001      		movw r30,r0
 12682 4874 819F      		mul r24,r17
 12683 4876 F00D      		add r31,r0
 12684 4878 1124      		clr __zero_reg__
 12685 487a E050      		subi r30,lo8(-(weeklyProgram))
 12686 487c F040      		sbci r31,hi8(-(weeklyProgram))
 12687 487e 3183      		std Z+1,r19
 12688               	.LVL1092:
1249:switcherator.c ****     weeklyProgram[programNumber][2] = temp;
 12689               		.loc 1 1249 0
 12690 4880 2283      		std Z+2,r18
 12691               	.LVL1093:
1251:switcherator.c ****     weeklyProgram[programNumber][3] = temp;
 12692               		.loc 1 1251 0
 12693 4882 5383      		std Z+3,r21
 12694               	.LVL1094:
1252:switcherator.c ****     temp = (duration & 0xff);
 12695               		.loc 1 1252 0
 12696 4884 5527      		clr r21
 12697               	.LVL1095:
1253:switcherator.c ****     weeklyProgram[programNumber][4] = temp;
 12698               		.loc 1 1253 0
 12699 4886 4483      		std Z+4,r20
1254:switcherator.c ****     statusMsg[0] = 0;
 12700               		.loc 1 1254 0
 12701 4888 1092 0000 		sts statusMsg,__zero_reg__
1255:switcherator.c ****     strcat(statusMsg, "New prog#");
 12702               		.loc 1 1255 0
 12703 488c 60E0      		ldi r22,lo8(.LC72)
 12704 488e 70E0      		ldi r23,hi8(.LC72)
 12705 4890 80E0      		ldi r24,lo8(statusMsg)
 12706 4892 90E0      		ldi r25,hi8(statusMsg)
 12707 4894 0E94 0000 		call strcat
 12708               	.LVL1096:
1256:switcherator.c ****     returnInt(programNumber, tempIntString);
 12709               		.loc 1 1256 0
 12710 4898 60E0      		ldi r22,lo8(tempIntString)
 12711 489a 70E0      		ldi r23,hi8(tempIntString)
 12712 489c C801      		movw r24,r16
 12713 489e 0E94 0000 		call returnInt
 12714               	.LVL1097:
1257:switcherator.c ****     strcat(statusMsg, tempIntString);
 12715               		.loc 1 1257 0
 12716 48a2 60E0      		ldi r22,lo8(tempIntString)
 12717 48a4 70E0      		ldi r23,hi8(tempIntString)
 12718 48a6 80E0      		ldi r24,lo8(statusMsg)
 12719 48a8 90E0      		ldi r25,hi8(statusMsg)
 12720 48aa 0E94 0000 		call strcat
 12721               	.LVL1098:
1258:switcherator.c ****     sendMessage(statusMsg);
 12722               		.loc 1 1258 0
 12723 48ae 80E0      		ldi r24,lo8(statusMsg)
 12724 48b0 90E0      		ldi r25,hi8(statusMsg)
 12725               	/* epilogue start */
1259:switcherator.c **** }
 12726               		.loc 1 1259 0
 12727 48b2 DF91      		pop r29
 12728 48b4 CF91      		pop r28
 12729               	.LVL1099:
 12730 48b6 1F91      		pop r17
 12731 48b8 0F91      		pop r16
 12732               	.LVL1100:
 12733 48ba FF90      		pop r15
 12734 48bc EF90      		pop r14
 12735               	.LVL1101:
 12736 48be DF90      		pop r13
 12737 48c0 CF90      		pop r12
 12738               	.LVL1102:
 12739 48c2 BF90      		pop r11
 12740 48c4 AF90      		pop r10
1258:switcherator.c ****     sendMessage(statusMsg);
 12741               		.loc 1 1258 0
 12742 48c6 0C94 0000 		jmp sendMessage
 12743               	.LVL1103:
 12744               	.L851:
1215:switcherator.c ****         fail(8);
 12745               		.loc 1 1215 0
 12746 48ca 88E0      		ldi r24,lo8(8)
 12747 48cc 90E0      		ldi r25,0
 12748               	.LVL1104:
 12749               	.L853:
 12750               	/* epilogue start */
1259:switcherator.c **** }
 12751               		.loc 1 1259 0
 12752 48ce DF91      		pop r29
 12753 48d0 CF91      		pop r28
 12754               	.LVL1105:
 12755 48d2 1F91      		pop r17
 12756 48d4 0F91      		pop r16
 12757 48d6 FF90      		pop r15
 12758 48d8 EF90      		pop r14
 12759 48da DF90      		pop r13
 12760 48dc CF90      		pop r12
 12761 48de BF90      		pop r11
 12762 48e0 AF90      		pop r10
1215:switcherator.c ****         fail(8);
 12763               		.loc 1 1215 0
 12764 48e2 0C94 0000 		jmp fail
 12765               	.LVL1106:
 12766               	.L835:
1218:switcherator.c ****     clearTheProgram(programNumber);
 12767               		.loc 1 1218 0
 12768 48e6 C801      		movw r24,r16
 12769 48e8 0E94 0000 		call clearTheProgram
 12770               	.LVL1107:
1219:switcherator.c ****     tempIntString[0] = commandReceived[3];
 12771               		.loc 1 1219 0
 12772 48ec 8B81      		ldd r24,Y+3
 12773 48ee 8093 0000 		sts tempIntString,r24
1220:switcherator.c ****     tempIntString[1] = commandReceived[4];
 12774               		.loc 1 1220 0
 12775 48f2 AC80      		ldd r10,Y+4
 12776 48f4 A092 0000 		sts tempIntString+1,r10
1221:switcherator.c ****     hours = atoi(tempIntString);
 12777               		.loc 1 1221 0
 12778 48f8 80E0      		ldi r24,lo8(tempIntString)
 12779 48fa 90E0      		ldi r25,hi8(tempIntString)
 12780 48fc 0E94 0000 		call atoi
 12781               	.LVL1108:
 12782 4900 7C01      		movw r14,r24
 12783               	.LVL1109:
1222:switcherator.c ****     tempIntString[0] = commandReceived[5];
 12784               		.loc 1 1222 0
 12785 4902 8D81      		ldd r24,Y+5
 12786 4904 8093 0000 		sts tempIntString,r24
1223:switcherator.c ****     tempIntString[1] = commandReceived[6];
 12787               		.loc 1 1223 0
 12788 4908 BE80      		ldd r11,Y+6
 12789 490a B092 0000 		sts tempIntString+1,r11
1224:switcherator.c ****     minutes = atoi(tempIntString);
 12790               		.loc 1 1224 0
 12791 490e 80E0      		ldi r24,lo8(tempIntString)
 12792 4910 90E0      		ldi r25,hi8(tempIntString)
 12793 4912 0E94 0000 		call atoi
 12794               	.LVL1110:
 12795 4916 6C01      		movw r12,r24
 12796               	.LVL1111:
1225:switcherator.c ****     tempLongString[0] = commandReceived[7];
 12797               		.loc 1 1225 0
 12798 4918 8F81      		ldd r24,Y+7
 12799 491a 8093 0000 		sts tempLongString,r24
1226:switcherator.c ****     tempLongString[1] = commandReceived[8];
 12800               		.loc 1 1226 0
 12801 491e 8885      		ldd r24,Y+8
 12802 4920 8093 0000 		sts tempLongString+1,r24
1227:switcherator.c ****     tempLongString[2] = commandReceived[9];
 12803               		.loc 1 1227 0
 12804 4924 8985      		ldd r24,Y+9
 12805 4926 8093 0000 		sts tempLongString+2,r24
1228:switcherator.c ****     tempLongString[3] = commandReceived[10];
 12806               		.loc 1 1228 0
 12807 492a 8A85      		ldd r24,Y+10
 12808 492c 8093 0000 		sts tempLongString+3,r24
1229:switcherator.c ****     duration = atoi(tempLongString);
 12809               		.loc 1 1229 0
 12810 4930 80E0      		ldi r24,lo8(tempLongString)
 12811 4932 90E0      		ldi r25,hi8(tempLongString)
 12812 4934 0E94 0000 		call atoi
 12813               	.LVL1112:
1230:switcherator.c ****     if (hours >= 24 || (hours == 0 && commandReceived[4] != '0')) {
 12814               		.loc 1 1230 0
 12815 4938 28E1      		ldi r18,24
 12816 493a E216      		cp r14,r18
 12817 493c F104      		cpc r15,__zero_reg__
 12818 493e 04F4      		brge .+2
 12819 4940 00C0      		rjmp .L852
 12820 4942 00C0      		rjmp .L842
 12821               	.LFE30:
 12823               	.global	switchBrightness
 12825               	switchBrightness:
 12826               	.LFB19:
 812:switcherator.c **** void switchBrightness(char * commandReceived) {
 12827               		.loc 1 812 0
 12828               	.LVL1113:
 12829 4944 FF92      		push r15
 12830               	.LCFI349:
 12831 4946 0F93      		push r16
 12832               	.LCFI350:
 12833 4948 1F93      		push r17
 12834               	.LCFI351:
 12835 494a CF93      		push r28
 12836               	.LCFI352:
 12837 494c DF93      		push r29
 12838               	.LCFI353:
 12839               	/* prologue: function */
 12840               	/* frame size = 0 */
 12841               	/* stack size = 5 */
 12842               	.L__stack_usage = 5
 12843 494e 8C01      		movw r16,r24
 813:switcherator.c ****     int switchNumber = getSwitchNumber(commandReceived);
 12844               		.loc 1 813 0
 12845 4950 0E94 0000 		call getSwitchNumber
 12846               	.LVL1114:
 12847 4954 EC01      		movw r28,r24
 12848               	.LVL1115:
 815:switcherator.c ****     if (switchNumber >= NUM_SWITCHES) {
 12849               		.loc 1 815 0
 12850 4956 8031      		cpi r24,16
 12851 4958 9105      		cpc r25,__zero_reg__
 12852 495a 04F0      		brlt .L855
 816:switcherator.c ****         fail(1);
 12853               		.loc 1 816 0
 12854 495c 81E0      		ldi r24,lo8(1)
 12855 495e 90E0      		ldi r25,0
 12856               	.LVL1116:
 12857               	/* epilogue start */
 838:switcherator.c **** }
 12858               		.loc 1 838 0
 12859 4960 DF91      		pop r29
 12860 4962 CF91      		pop r28
 12861               	.LVL1117:
 12862 4964 1F91      		pop r17
 12863 4966 0F91      		pop r16
 12864               	.LVL1118:
 12865 4968 FF90      		pop r15
 816:switcherator.c ****         fail(1);
 12866               		.loc 1 816 0
 12867 496a 0C94 0000 		jmp fail
 12868               	.LVL1119:
 12869               	.L855:
 819:switcherator.c ****     tempIntString[0] = commandReceived[5];
 12870               		.loc 1 819 0
 12871 496e F801      		movw r30,r16
 12872 4970 8581      		ldd r24,Z+5
 12873               	.LVL1120:
 12874 4972 8093 0000 		sts tempIntString,r24
 820:switcherator.c ****     tempIntString[1] = commandReceived[6];
 12875               		.loc 1 820 0
 12876 4976 8681      		ldd r24,Z+6
 12877 4978 8093 0000 		sts tempIntString+1,r24
 821:switcherator.c ****     char brightValue = atoi(tempIntString);
 12878               		.loc 1 821 0
 12879 497c 80E0      		ldi r24,lo8(tempIntString)
 12880 497e 90E0      		ldi r25,hi8(tempIntString)
 12881 4980 0E94 0000 		call atoi
 12882               	.LVL1121:
 12883 4984 F82E      		mov r15,r24
 12884               	.LVL1122:
 12885 4986 8E01      		movw r16,r28
 12886               	.LVL1123:
 12887 4988 0050      		subi r16,lo8(-(switchBright))
 12888 498a 1040      		sbci r17,hi8(-(switchBright))
 822:switcherator.c ****     if (brightValue == 0) {
 12889               		.loc 1 822 0
 12890 498c 8111      		cpse r24,__zero_reg__
 12891 498e 00C0      		rjmp .L856
 12892               	.LVL1124:
 824:switcherator.c ****         itoa(tempBright, tempIntString, 10);
 12893               		.loc 1 824 0
 12894 4990 4AE0      		ldi r20,lo8(10)
 12895 4992 50E0      		ldi r21,0
 12896 4994 60E0      		ldi r22,lo8(tempIntString)
 12897 4996 70E0      		ldi r23,hi8(tempIntString)
 12898 4998 F801      		movw r30,r16
 12899 499a 8081      		ld r24,Z
 12900 499c 90E0      		ldi r25,0
 12901 499e 0E94 0000 		call itoa
 12902               	.LVL1125:
 825:switcherator.c ****         statusMsg[0] = 0;
 12903               		.loc 1 825 0
 12904 49a2 1092 0000 		sts statusMsg,__zero_reg__
 826:switcherator.c ****         strcat(statusMsg, "Set @");
 12905               		.loc 1 826 0
 12906 49a6 60E0      		ldi r22,lo8(.LC66)
 12907 49a8 70E0      		ldi r23,hi8(.LC66)
 12908 49aa 80E0      		ldi r24,lo8(statusMsg)
 12909 49ac 90E0      		ldi r25,hi8(statusMsg)
 12910 49ae 0E94 0000 		call strcat
 12911               	.LVL1126:
 827:switcherator.c ****         strcat(statusMsg, tempIntString);
 12912               		.loc 1 827 0
 12913 49b2 60E0      		ldi r22,lo8(tempIntString)
 12914 49b4 70E0      		ldi r23,hi8(tempIntString)
 12915 49b6 80E0      		ldi r24,lo8(statusMsg)
 12916 49b8 90E0      		ldi r25,hi8(statusMsg)
 12917 49ba 0E94 0000 		call strcat
 12918               	.LVL1127:
 828:switcherator.c ****         sendMessage(statusMsg);
 12919               		.loc 1 828 0
 12920 49be 80E0      		ldi r24,lo8(statusMsg)
 12921 49c0 90E0      		ldi r25,hi8(statusMsg)
 12922               	/* epilogue start */
 838:switcherator.c **** }
 12923               		.loc 1 838 0
 12924 49c2 DF91      		pop r29
 12925 49c4 CF91      		pop r28
 12926               	.LVL1128:
 12927 49c6 1F91      		pop r17
 12928 49c8 0F91      		pop r16
 12929               	.LVL1129:
 12930 49ca FF90      		pop r15
 12931               	.LVL1130:
 828:switcherator.c ****         sendMessage(statusMsg);
 12932               		.loc 1 828 0
 12933 49cc 0C94 0000 		jmp sendMessage
 12934               	.LVL1131:
 12935               	.L856:
 832:switcherator.c ****         clearTheSwitch(switchNumber);
 12936               		.loc 1 832 0
 12937 49d0 CE01      		movw r24,r28
 12938 49d2 0E94 0000 		call clearTheSwitch
 12939               	.LVL1132:
 834:switcherator.c ****         switchStuff[switchNumber] = 212;
 12940               		.loc 1 834 0
 12941 49d6 C050      		subi r28,lo8(-(switchStuff))
 12942 49d8 D040      		sbci r29,hi8(-(switchStuff))
 12943               	.LVL1133:
 12944 49da 84ED      		ldi r24,lo8(-44)
 12945 49dc 8883      		st Y,r24
 835:switcherator.c ****         switchBright[switchNumber] = brightValue;
 12946               		.loc 1 835 0
 12947 49de 8F2D      		mov r24,r15
 12948 49e0 8131      		cpi r24,lo8(17)
 12949 49e2 00F0      		brlo .L857
 12950 49e4 80E1      		ldi r24,lo8(16)
 12951               	.L857:
 12952 49e6 F801      		movw r30,r16
 12953 49e8 8083      		st Z,r24
 12954               	/* epilogue start */
 838:switcherator.c **** }
 12955               		.loc 1 838 0
 12956 49ea DF91      		pop r29
 12957 49ec CF91      		pop r28
 12958 49ee 1F91      		pop r17
 12959 49f0 0F91      		pop r16
 12960               	.LVL1134:
 12961 49f2 FF90      		pop r15
 12962               	.LVL1135:
 836:switcherator.c ****         ok();
 12963               		.loc 1 836 0
 12964 49f4 0C94 0000 		jmp ok
 12965               	.LVL1136:
 12966               	.LFE19:
 12968               	.global	setClock
 12970               	setClock:
 12971               	.LFB48:
2121:switcherator.c **** void setClock(char * commandReceived) {
 12972               		.loc 1 2121 0
 12973               	.LVL1137:
 12974 49f8 6F92      		push r6
 12975               	.LCFI354:
 12976 49fa 7F92      		push r7
 12977               	.LCFI355:
 12978 49fc 8F92      		push r8
 12979               	.LCFI356:
 12980 49fe 9F92      		push r9
 12981               	.LCFI357:
 12982 4a00 AF92      		push r10
 12983               	.LCFI358:
 12984 4a02 BF92      		push r11
 12985               	.LCFI359:
 12986 4a04 CF92      		push r12
 12987               	.LCFI360:
 12988 4a06 DF92      		push r13
 12989               	.LCFI361:
 12990 4a08 EF92      		push r14
 12991               	.LCFI362:
 12992 4a0a FF92      		push r15
 12993               	.LCFI363:
 12994 4a0c 0F93      		push r16
 12995               	.LCFI364:
 12996 4a0e 1F93      		push r17
 12997               	.LCFI365:
 12998 4a10 CF93      		push r28
 12999               	.LCFI366:
 13000 4a12 DF93      		push r29
 13001               	.LCFI367:
 13002               	/* prologue: function */
 13003               	/* frame size = 0 */
 13004               	/* stack size = 14 */
 13005               	.L__stack_usage = 14
 13006 4a14 EC01      		movw r28,r24
2124:switcherator.c ****     tempLongString[0] = '0';
 13007               		.loc 1 2124 0
 13008 4a16 80E3      		ldi r24,lo8(48)
 13009               	.LVL1138:
 13010 4a18 8093 0000 		sts tempLongString,r24
2125:switcherator.c ****     tempLongString[1] = '0';
 13011               		.loc 1 2125 0
 13012 4a1c 8093 0000 		sts tempLongString+1,r24
2128:switcherator.c ****     tempLongString[2] = commandReceived[3];
 13013               		.loc 1 2128 0
 13014 4a20 8B81      		ldd r24,Y+3
 13015 4a22 8093 0000 		sts tempLongString+2,r24
2129:switcherator.c ****     tempLongString[3] = commandReceived[4];
 13016               		.loc 1 2129 0
 13017 4a26 8C81      		ldd r24,Y+4
 13018 4a28 8093 0000 		sts tempLongString+3,r24
2130:switcherator.c ****     globalMonth = atoi(tempLongString);
 13019               		.loc 1 2130 0
 13020 4a2c 80E0      		ldi r24,lo8(tempLongString)
 13021 4a2e 90E0      		ldi r25,hi8(tempLongString)
 13022 4a30 0E94 0000 		call atoi
 13023               	.LVL1139:
 13024 4a34 6C01      		movw r12,r24
 13025 4a36 9093 0000 		sts globalMonth+1,r25
 13026 4a3a 8093 0000 		sts globalMonth,r24
2132:switcherator.c ****     tempLongString[2] = commandReceived[5];
 13027               		.loc 1 2132 0
 13028 4a3e 8D81      		ldd r24,Y+5
 13029 4a40 8093 0000 		sts tempLongString+2,r24
2133:switcherator.c ****     tempLongString[3] = commandReceived[6];
 13030               		.loc 1 2133 0
 13031 4a44 8E81      		ldd r24,Y+6
 13032 4a46 8093 0000 		sts tempLongString+3,r24
2134:switcherator.c ****     globalDay = atoi(tempLongString);
 13033               		.loc 1 2134 0
 13034 4a4a 80E0      		ldi r24,lo8(tempLongString)
 13035 4a4c 90E0      		ldi r25,hi8(tempLongString)
 13036 4a4e 0E94 0000 		call atoi
 13037               	.LVL1140:
 13038 4a52 8C01      		movw r16,r24
 13039 4a54 9093 0000 		sts globalDay+1,r25
 13040 4a58 8093 0000 		sts globalDay,r24
2136:switcherator.c ****     tempLongString[2] = commandReceived[11];
 13041               		.loc 1 2136 0
 13042 4a5c 8B85      		ldd r24,Y+11
 13043 4a5e 8093 0000 		sts tempLongString+2,r24
2137:switcherator.c ****     tempLongString[3] = commandReceived[12];
 13044               		.loc 1 2137 0
 13045 4a62 8C85      		ldd r24,Y+12
 13046 4a64 8093 0000 		sts tempLongString+3,r24
2138:switcherator.c ****     globalHour = atoi(tempLongString);
 13047               		.loc 1 2138 0
 13048 4a68 80E0      		ldi r24,lo8(tempLongString)
 13049 4a6a 90E0      		ldi r25,hi8(tempLongString)
 13050 4a6c 0E94 0000 		call atoi
 13051               	.LVL1141:
 13052 4a70 4C01      		movw r8,r24
 13053 4a72 8093 0000 		sts globalHour,r24
 13054 4a76 9092 0000 		sts globalHour+1,r9
2140:switcherator.c ****     tempLongString[2] = commandReceived[13];
 13055               		.loc 1 2140 0
 13056 4a7a 8D85      		ldd r24,Y+13
 13057 4a7c 8093 0000 		sts tempLongString+2,r24
2141:switcherator.c ****     tempLongString[3] = commandReceived[14];
 13058               		.loc 1 2141 0
 13059 4a80 8E85      		ldd r24,Y+14
 13060 4a82 8093 0000 		sts tempLongString+3,r24
2142:switcherator.c ****     globalMinute = atoi(tempLongString);
 13061               		.loc 1 2142 0
 13062 4a86 80E0      		ldi r24,lo8(tempLongString)
 13063 4a88 90E0      		ldi r25,hi8(tempLongString)
 13064 4a8a 0E94 0000 		call atoi
 13065               	.LVL1142:
 13066 4a8e 5C01      		movw r10,r24
 13067 4a90 8093 0000 		sts globalMinute,r24
 13068 4a94 B092 0000 		sts globalMinute+1,r11
2144:switcherator.c ****     tempLongString[2] = commandReceived[15];
 13069               		.loc 1 2144 0
 13070 4a98 8F85      		ldd r24,Y+15
 13071 4a9a 8093 0000 		sts tempLongString+2,r24
2145:switcherator.c ****     tempLongString[3] = commandReceived[16];
 13072               		.loc 1 2145 0
 13073 4a9e 8889      		ldd r24,Y+16
 13074 4aa0 8093 0000 		sts tempLongString+3,r24
2146:switcherator.c ****     globalSecond = atoi(tempLongString);
 13075               		.loc 1 2146 0
 13076 4aa4 80E0      		ldi r24,lo8(tempLongString)
 13077 4aa6 90E0      		ldi r25,hi8(tempLongString)
 13078 4aa8 0E94 0000 		call atoi
 13079               	.LVL1143:
 13080 4aac 3C01      		movw r6,r24
 13081 4aae 9093 0000 		sts globalSecond+1,r25
 13082 4ab2 8093 0000 		sts globalSecond,r24
2148:switcherator.c ****     tempLongString[0] = commandReceived[7];
 13083               		.loc 1 2148 0
 13084 4ab6 8F81      		ldd r24,Y+7
 13085 4ab8 8093 0000 		sts tempLongString,r24
2149:switcherator.c ****     tempLongString[1] = commandReceived[8];
 13086               		.loc 1 2149 0
 13087 4abc 8885      		ldd r24,Y+8
 13088 4abe 8093 0000 		sts tempLongString+1,r24
2150:switcherator.c ****     tempLongString[2] = commandReceived[9];
 13089               		.loc 1 2150 0
 13090 4ac2 8985      		ldd r24,Y+9
 13091 4ac4 8093 0000 		sts tempLongString+2,r24
2151:switcherator.c ****     tempLongString[3] = commandReceived[10];
 13092               		.loc 1 2151 0
 13093 4ac8 8A85      		ldd r24,Y+10
 13094 4aca 8093 0000 		sts tempLongString+3,r24
2152:switcherator.c ****     globalYear = atoi(tempLongString);
 13095               		.loc 1 2152 0
 13096 4ace 80E0      		ldi r24,lo8(tempLongString)
 13097 4ad0 90E0      		ldi r25,hi8(tempLongString)
 13098 4ad2 0E94 0000 		call atoi
 13099               	.LVL1144:
 13100 4ad6 9093 0000 		sts globalYear+1,r25
 13101 4ada 8093 0000 		sts globalYear,r24
2153:switcherator.c ****     dow = getWeekday(globalYear, globalMonth, globalDay); // get day of week
 13102               		.loc 1 2153 0
 13103 4ade A801      		movw r20,r16
 13104 4ae0 B601      		movw r22,r12
 13105 4ae2 0E94 0000 		call getWeekday
 13106               	.LVL1145:
 13107 4ae6 DC01      		movw r26,r24
 13108 4ae8 8093 0000 		sts dow,r24
 13109 4aec B093 0000 		sts dow+1,r27
 13110               	.LVL1146:
2155:switcherator.c ****     tempInt = tempInt * 24 * 60 * 60;
 13111               		.loc 1 2155 0
 13112 4af0 20E8      		ldi r18,lo8(-128)
 13113 4af2 31E5      		ldi r19,lo8(81)
 13114 4af4 41E0      		ldi r20,lo8(1)
 13115 4af6 50E0      		ldi r21,0
 13116 4af8 0E94 0000 		call __muluhisi3
 13117 4afc 6B01      		movw r12,r22
 13118 4afe 7C01      		movw r14,r24
2158:switcherator.c ****     tempInt = tempInt * 60 * 60;
 13119               		.loc 1 2158 0
 13120 4b00 9401      		movw r18,r8
 13121 4b02 A0E1      		ldi r26,lo8(16)
 13122 4b04 BEE0      		ldi r27,lo8(14)
 13123 4b06 0E94 0000 		call __umulhisi3
2159:switcherator.c ****     weeklySeconds += tempInt;
 13124               		.loc 1 2159 0
 13125 4b0a C60E      		add r12,r22
 13126 4b0c D71E      		adc r13,r23
 13127 4b0e E81E      		adc r14,r24
 13128 4b10 F91E      		adc r15,r25
2162:switcherator.c ****     weeklySeconds += tempInt;
 13129               		.loc 1 2162 0
 13130 4b12 C60C      		add r12,r6
 13131 4b14 D71C      		adc r13,r7
 13132 4b16 E11C      		adc r14,__zero_reg__
 13133 4b18 F11C      		adc r15,__zero_reg__
2161:switcherator.c ****     tempInt = tempInt * 60;
 13134               		.loc 1 2161 0
 13135 4b1a 9501      		movw r18,r10
 13136 4b1c ACE3      		ldi r26,lo8(60)
 13137 4b1e B0E0      		ldi r27,0
 13138 4b20 0E94 0000 		call __umulhisi3
2163:switcherator.c ****     weeklySeconds += globalSecond;
 13139               		.loc 1 2163 0
 13140 4b24 C60E      		add r12,r22
 13141 4b26 D71E      		adc r13,r23
 13142 4b28 E81E      		adc r14,r24
 13143 4b2a F91E      		adc r15,r25
 13144 4b2c C092 0000 		sts weeklySeconds,r12
 13145 4b30 D092 0000 		sts weeklySeconds+1,r13
 13146 4b34 E092 0000 		sts weeklySeconds+2,r14
 13147 4b38 F092 0000 		sts weeklySeconds+3,r15
2164:switcherator.c ****     clockString();
 13148               		.loc 1 2164 0
 13149 4b3c 0E94 0000 		call clockString
 13150               	.LVL1147:
2165:switcherator.c ****     sendMessage(statusMsg);
 13151               		.loc 1 2165 0
 13152 4b40 80E0      		ldi r24,lo8(statusMsg)
 13153 4b42 90E0      		ldi r25,hi8(statusMsg)
 13154 4b44 0E94 0000 		call sendMessage
 13155               	.LVL1148:
2166:switcherator.c ****     stopClock();
 13156               		.loc 1 2166 0
 13157 4b48 0E94 0000 		call stopClock
 13158               	.LVL1149:
2167:switcherator.c ****     startClock();
 13159               		.loc 1 2167 0
 13160 4b4c 0E94 0000 		call startClock
 13161               	.LVL1150:
2168:switcherator.c ****     panicMyClockIsNotSet = 0;
 13162               		.loc 1 2168 0
 13163 4b50 1092 0000 		sts panicMyClockIsNotSet,__zero_reg__
2169:switcherator.c ****     if(failCondition == 3) {
 13164               		.loc 1 2169 0
 13165 4b54 8091 0000 		lds r24,failCondition
 13166 4b58 8330      		cpi r24,lo8(3)
 13167 4b5a 01F4      		brne .L858
 13168               	/* epilogue start */
2172:switcherator.c **** }
 13169               		.loc 1 2172 0
 13170 4b5c DF91      		pop r29
 13171 4b5e CF91      		pop r28
 13172               	.LVL1151:
 13173 4b60 1F91      		pop r17
 13174 4b62 0F91      		pop r16
 13175 4b64 FF90      		pop r15
 13176 4b66 EF90      		pop r14
 13177 4b68 DF90      		pop r13
 13178 4b6a CF90      		pop r12
 13179 4b6c BF90      		pop r11
 13180               	.LVL1152:
 13181 4b6e AF90      		pop r10
 13182 4b70 9F90      		pop r9
 13183 4b72 8F90      		pop r8
 13184 4b74 7F90      		pop r7
 13185 4b76 6F90      		pop r6
2170:switcherator.c ****         clearFail();      
 13186               		.loc 1 2170 0
 13187 4b78 0C94 0000 		jmp clearFail
 13188               	.LVL1153:
 13189               	.L858:
 13190               	/* epilogue start */
2172:switcherator.c **** }
 13191               		.loc 1 2172 0
 13192 4b7c DF91      		pop r29
 13193 4b7e CF91      		pop r28
 13194               	.LVL1154:
 13195 4b80 1F91      		pop r17
 13196 4b82 0F91      		pop r16
 13197 4b84 FF90      		pop r15
 13198 4b86 EF90      		pop r14
 13199 4b88 DF90      		pop r13
 13200 4b8a CF90      		pop r12
 13201 4b8c BF90      		pop r11
 13202               	.LVL1155:
 13203 4b8e AF90      		pop r10
 13204 4b90 9F90      		pop r9
 13205 4b92 8F90      		pop r8
 13206 4b94 7F90      		pop r7
 13207 4b96 6F90      		pop r6
 13208 4b98 0895      		ret
 13209               	.LFE48:
 13211               	.global	checkCommand
 13213               	checkCommand:
 13214               	.LFB8:
 265:switcherator.c **** void checkCommand(char * commandReceived) {
 13215               		.loc 1 265 0
 13216               	.LVL1156:
 13217               	/* prologue: function */
 13218               	/* frame size = 0 */
 13219               	/* stack size = 0 */
 13220               	.L__stack_usage = 0
 266:switcherator.c ****     if (commandReceived[0] > 0x60)
 13221               		.loc 1 266 0
 13222 4b9a FC01      		movw r30,r24
 13223 4b9c 2081      		ld r18,Z
 13224 4b9e 2136      		cpi r18,lo8(97)
 13225 4ba0 00F0      		brlo .L861
 267:switcherator.c ****         commandReceived[0] -= 0x20;
 13226               		.loc 1 267 0
 13227 4ba2 2052      		subi r18,lo8(-(-32))
 13228 4ba4 2083      		st Z,r18
 13229               	.L861:
 268:switcherator.c ****     if (commandReceived[1] > 0x60)
 13230               		.loc 1 268 0
 13231 4ba6 FC01      		movw r30,r24
 13232 4ba8 2181      		ldd r18,Z+1
 13233 4baa 2136      		cpi r18,lo8(97)
 13234 4bac 00F0      		brlo .L862
 269:switcherator.c ****         commandReceived[1] -= 0x20;
 13235               		.loc 1 269 0
 13236 4bae 2052      		subi r18,lo8(-(-32))
 13237 4bb0 2183      		std Z+1,r18
 13238               	.L862:
 271:switcherator.c ****     switchme <<= 8;
 13239               		.loc 1 271 0
 13240 4bb2 FC01      		movw r30,r24
 13241 4bb4 3081      		ld r19,Z
 13242 4bb6 20E0      		ldi r18,0
 13243               	.LVL1157:
 272:switcherator.c ****     switchme |= commandReceived[1];
 13244               		.loc 1 272 0
 13245 4bb8 4181      		ldd r20,Z+1
 13246 4bba 242B      		or r18,r20
 13247               	.LVL1158:
 273:switcherator.c ****     switch (switchme) {
 13248               		.loc 1 273 0
 13249 4bbc 2434      		cpi r18,68
 13250 4bbe F0E5      		ldi r31,80
 13251 4bc0 3F07      		cpc r19,r31
 13252 4bc2 01F4      		brne .+2
 13253 4bc4 00C0      		rjmp .L879
 13254 4bc6 04F0      		brlt .+2
 13255 4bc8 00C0      		rjmp .L896
 13256 4bca 2435      		cpi r18,84
 13257 4bcc E3E4      		ldi r30,67
 13258 4bce 3E07      		cpc r19,r30
 13259 4bd0 01F4      		brne .+2
 13260 4bd2 00C0      		rjmp .L871
 13261 4bd4 04F4      		brge .L897
 13262 4bd6 2834      		cpi r18,72
 13263 4bd8 43E4      		ldi r20,67
 13264 4bda 3407      		cpc r19,r20
 13265 4bdc 01F4      		brne .+2
 13266 4bde 00C0      		rjmp .L867
 13267 4be0 04F4      		brge .L898
 13268 4be2 2335      		cpi r18,83
 13269 4be4 F2E4      		ldi r31,66
 13270 4be6 3F07      		cpc r19,r31
 13271 4be8 01F4      		brne .+2
 13272 4bea 00C0      		rjmp .L865
 13273 4bec 2334      		cpi r18,67
 13274 4bee 43E4      		ldi r20,67
 13275 4bf0 3407      		cpc r19,r20
 13276 4bf2 01F4      		brne .+2
 13277 4bf4 00C0      		rjmp .L866
 13278 4bf6 2934      		cpi r18,73
 13279 4bf8 3144      		sbci r19,65
 13280 4bfa 01F0      		breq .+2
 13281 4bfc 00C0      		rjmp .L860
 13282 4bfe 00C0      		rjmp .L864
 13283               	.L898:
 13284 4c00 2C34      		cpi r18,76
 13285 4c02 F3E4      		ldi r31,67
 13286 4c04 3F07      		cpc r19,r31
 13287 4c06 01F4      		brne .+2
 13288 4c08 00C0      		rjmp .L869
 13289 4c0a 2035      		cpi r18,80
 13290 4c0c 43E4      		ldi r20,67
 13291 4c0e 3407      		cpc r19,r20
 13292 4c10 01F4      		brne .+2
 13293 4c12 00C0      		rjmp .L870
 13294 4c14 2934      		cpi r18,73
 13295 4c16 3344      		sbci r19,67
 13296 4c18 01F0      		breq .+2
 13297 4c1a 00C0      		rjmp .L860
 13298 4c1c 00C0      		rjmp .L868
 13299               	.L897:
 13300 4c1e 2436      		cpi r18,100
 13301 4c20 F8E4      		ldi r31,72
 13302 4c22 3F07      		cpc r19,r31
 13303 4c24 01F4      		brne .+2
 13304 4c26 00C0      		rjmp .L875
 13305 4c28 04F4      		brge .L899
 13306 4c2a 2335      		cpi r18,83
 13307 4c2c E4E4      		ldi r30,68
 13308 4c2e 3E07      		cpc r19,r30
 13309 4c30 01F4      		brne .+2
 13310 4c32 00C0      		rjmp .L873
 13311 4c34 2335      		cpi r18,83
 13312 4c36 F7E4      		ldi r31,71
 13313 4c38 3F07      		cpc r19,r31
 13314 4c3a 01F4      		brne .+2
 13315 4c3c 00C0      		rjmp .L874
 13316 4c3e 2934      		cpi r18,73
 13317 4c40 3444      		sbci r19,68
 13318 4c42 01F0      		breq .+2
 13319 4c44 00C0      		rjmp .L860
 13320 4c46 00C0      		rjmp .L872
 13321               	.L899:
 13322 4c48 2335      		cpi r18,83
 13323 4c4a EEE4      		ldi r30,78
 13324 4c4c 3E07      		cpc r19,r30
 13325 4c4e 01F4      		brne .+2
 13326 4c50 00C0      		rjmp .L877
 13327 4c52 2134      		cpi r18,65
 13328 4c54 F0E5      		ldi r31,80
 13329 4c56 3F07      		cpc r19,r31
 13330 4c58 01F4      		brne .+2
 13331 4c5a 00C0      		rjmp .L878
 13332 4c5c 2035      		cpi r18,80
 13333 4c5e 3E44      		sbci r19,78
 13334 4c60 01F0      		breq .+2
 13335 4c62 00C0      		rjmp .L860
 13336 4c64 00C0      		rjmp .L876
 13337               	.L896:
 13338 4c66 2134      		cpi r18,65
 13339 4c68 E3E5      		ldi r30,83
 13340 4c6a 3E07      		cpc r19,r30
 13341 4c6c 01F4      		brne .+2
 13342 4c6e 00C0      		rjmp .L887
 13343 4c70 04F4      		brge .L900
 13344 4c72 2635      		cpi r18,86
 13345 4c74 40E5      		ldi r20,80
 13346 4c76 3407      		cpc r19,r20
 13347 4c78 01F4      		brne .+2
 13348 4c7a 00C0      		rjmp .L883
 13349 4c7c 04F4      		brge .L901
 13350 4c7e 2335      		cpi r18,83
 13351 4c80 F0E5      		ldi r31,80
 13352 4c82 3F07      		cpc r19,r31
 13353 4c84 01F4      		brne .+2
 13354 4c86 00C0      		rjmp .L881
 13355 4c88 2435      		cpi r18,84
 13356 4c8a 40E5      		ldi r20,80
 13357 4c8c 3407      		cpc r19,r20
 13358 4c8e 01F4      		brne .+2
 13359 4c90 00C0      		rjmp .L882
 13360 4c92 2934      		cpi r18,73
 13361 4c94 3045      		sbci r19,80
 13362 4c96 01F0      		breq .+2
 13363 4c98 00C0      		rjmp .L860
 13364 4c9a 00C0      		rjmp .L880
 13365               	.L901:
 13366 4c9c 2334      		cpi r18,67
 13367 4c9e F2E5      		ldi r31,82
 13368 4ca0 3F07      		cpc r19,r31
 13369 4ca2 01F4      		brne .+2
 13370 4ca4 00C0      		rjmp .L885
 13371 4ca6 2434      		cpi r18,68
 13372 4ca8 42E5      		ldi r20,82
 13373 4caa 3407      		cpc r19,r20
 13374 4cac 01F4      		brne .+2
 13375 4cae 00C0      		rjmp .L886
 13376 4cb0 2735      		cpi r18,87
 13377 4cb2 3045      		sbci r19,80
 13378               	.LVL1159:
 13379 4cb4 01F0      		breq .+2
 13380 4cb6 00C0      		rjmp .L860
 13381 4cb8 00C0      		rjmp .L884
 13382               	.LVL1160:
 13383               	.L900:
 13384 4cba 2534      		cpi r18,69
 13385 4cbc E3E5      		ldi r30,83
 13386 4cbe 3E07      		cpc r19,r30
 13387 4cc0 01F0      		breq .L891
 13388 4cc2 04F4      		brge .L902
 13389 4cc4 2334      		cpi r18,67
 13390 4cc6 43E5      		ldi r20,83
 13391 4cc8 3407      		cpc r19,r20
 13392 4cca 01F0      		breq .L889
 13393 4ccc 04F4      		brge .L890
 13394 4cce 00C0      		rjmp .L904
 13395               	.L902:
 13396 4cd0 2335      		cpi r18,83
 13397 4cd2 F3E5      		ldi r31,83
 13398 4cd4 3F07      		cpc r19,r31
 13399 4cd6 01F0      		breq .L893
 13400 4cd8 04F4      		brge .L903
 13401 4cda 2035      		cpi r18,80
 13402 4cdc 3345      		sbci r19,83
 13403 4cde 01F0      		breq .+2
 13404 4ce0 00C0      		rjmp .L860
 13405 4ce2 00C0      		rjmp .L892
 13406               	.L903:
 13407 4ce4 2934      		cpi r18,73
 13408 4ce6 F4E5      		ldi r31,84
 13409 4ce8 3F07      		cpc r19,r31
 13410 4cea 01F0      		breq .L894
 13411 4cec 2C34      		cpi r18,76
 13412 4cee 3445      		sbci r19,84
 13413 4cf0 01F0      		breq .+2
 13414 4cf2 00C0      		rjmp .L860
 13415 4cf4 00C0      		rjmp .L895
 13416               	.L894:
 275:switcherator.c ****             setClock(commandReceived);
 13417               		.loc 1 275 0
 13418 4cf6 0C94 0000 		jmp setClock
 13419               	.LVL1161:
 13420               	.L873:
 278:switcherator.c ****             setDaylightSavings(commandReceived);
 13421               		.loc 1 278 0
 13422 4cfa 0C94 0000 		jmp setDaylightSavings
 13423               	.LVL1162:
 13424               	.L895:
 281:switcherator.c ****             setTimeLimits(commandReceived);
 13425               		.loc 1 281 0
 13426 4cfe 0C94 0000 		jmp setTimeLimits
 13427               	.LVL1163:
 13428               	.L877:
 284:switcherator.c ****             setNewSwitch(commandReceived);
 13429               		.loc 1 284 0
 13430 4d02 0C94 0000 		jmp setNewSwitch
 13431               	.LVL1164:
 13432               	.L889:
 287:switcherator.c ****             switchClear(commandReceived);
 13433               		.loc 1 287 0
 13434 4d06 0C94 0000 		jmp switchClear
 13435               	.LVL1165:
 13436               	.L890:
 290:switcherator.c ****             switchDisplay(commandReceived);
 13437               		.loc 1 290 0
 13438 4d0a 0C94 0000 		jmp switchDisplay
 13439               	.LVL1166:
 13440               	.L881:
 293:switcherator.c ****             pwmSetup(commandReceived);
 13441               		.loc 1 293 0
 13442 4d0e 0C94 0000 		jmp pwmSetup
 13443               	.LVL1167:
 13444               	.L867:
 296:switcherator.c ****             cycleHue(commandReceived);
 13445               		.loc 1 296 0
 13446 4d12 0C94 0000 		jmp cycleHue
 13447               	.LVL1168:
 13448               	.L875:
 299:switcherator.c ****             setHueSpeed(commandReceived);
 13449               		.loc 1 299 0
 13450 4d16 0C94 0000 		jmp setHueSpeed
 13451               	.LVL1169:
 13452               	.L883:
 302:switcherator.c ****             pwmValueSet(commandReceived);
 13453               		.loc 1 302 0
 13454 4d1a 0C94 0000 		jmp pwmValueSet
 13455               	.LVL1170:
 13456               	.L876:
 305:switcherator.c ****             newProgram(commandReceived);
 13457               		.loc 1 305 0
 13458 4d1e 0C94 0000 		jmp newProgram
 13459               	.LVL1171:
 13460               	.L870:
 308:switcherator.c ****             clearProgram(commandReceived);
 13461               		.loc 1 308 0
 13462 4d22 0C94 0000 		jmp clearProgram
 13463               	.LVL1172:
 13464               	.L878:
 311:switcherator.c ****             programAddSwitch(commandReceived);
 13465               		.loc 1 311 0
 13466 4d26 0C94 0000 		jmp programAddSwitch
 13467               	.LVL1173:
 13468               	.L879:
 314:switcherator.c ****             programSetDays(commandReceived);
 13469               		.loc 1 314 0
 13470 4d2a 0C94 0000 		jmp programSetDays
 13471               	.LVL1174:
 13472               	.L882:
 317:switcherator.c ****             programSetTime(commandReceived);
 13473               		.loc 1 317 0
 13474 4d2e 0C94 0000 		jmp programSetTime
 13475               	.LVL1175:
 13476               	.L880:
 320:switcherator.c ****             programDisplay(commandReceived);
 13477               		.loc 1 320 0
 13478 4d32 0C94 0000 		jmp programDisplay
 13479               	.LVL1176:
 13480               	.L893:
 323:switcherator.c ****             startSwitch(commandReceived);
 13481               		.loc 1 323 0
 13482 4d36 0C94 0000 		jmp startSwitch
 13483               	.LVL1177:
 13484               	.L892:
 326:switcherator.c ****             startProgram(commandReceived);
 13485               		.loc 1 326 0
 13486 4d3a 0C94 0000 		jmp startProgram
 13487               	.LVL1178:
 13488               	.L891:
 329:switcherator.c ****             serialNumber(commandReceived);
 13489               		.loc 1 329 0
 13490 4d3e 0C94 0000 		jmp serialNumber
 13491               	.LVL1179:
 13492               	.L887:
 332:switcherator.c ****             saveToEEPROM();
 13493               		.loc 1 332 0
 13494 4d42 0C94 0000 		jmp saveToEEPROM
 13495               	.LVL1180:
 13496               	.L869:
 335:switcherator.c ****             clearToEEPROM();
 13497               		.loc 1 335 0
 13498 4d46 0C94 0000 		jmp clearToEEPROM
 13499               	.LVL1181:
 13500               	.L886:
 338:switcherator.c ****             radioDisplayAddress(commandReceived);
 13501               		.loc 1 338 0
 13502 4d4a 0C94 0000 		jmp radioDisplayAddress
 13503               	.LVL1182:
 13504               	.L885:
 341:switcherator.c ****             radioChangeAddress(commandReceived);
 13505               		.loc 1 341 0
 13506 4d4e 0C94 0000 		jmp radioChangeAddress
 13507               	.LVL1183:
 13508               	.L864:
 344:switcherator.c ****             setAnalogInput(commandReceived);
 13509               		.loc 1 344 0
 13510 4d52 0C94 0000 		jmp setAnalogInput
 13511               	.LVL1184:
 13512               	.L872:
 347:switcherator.c ****             setDigitalInput(commandReceived);
 13513               		.loc 1 347 0
 13514 4d56 0C94 0000 		jmp setDigitalInput
 13515               	.LVL1185:
 13516               	.L868:
 350:switcherator.c ****             clearInput(commandReceived);
 13517               		.loc 1 350 0
 13518 4d5a 0C94 0000 		jmp clearInput
 13519               	.LVL1186:
 13520               	.L871:
 353:switcherator.c ****             clockTweak(commandReceived);
 13521               		.loc 1 353 0
 13522 4d5e 0C94 0000 		jmp clockTweak
 13523               	.LVL1187:
 13524               	.L884:
 356:switcherator.c ****             pwmSummary();
 13525               		.loc 1 356 0
 13526 4d62 0C94 0000 		jmp pwmSummary
 13527               	.LVL1188:
 13528               	.L874:
 362:switcherator.c ****             generalStatus(commandReceived);
 13529               		.loc 1 362 0
 13530 4d66 0C94 0000 		jmp generalStatus
 13531               	.LVL1189:
 13532               	.L866:
 368:switcherator.c ****             colorChangeSet(commandReceived);
 13533               		.loc 1 368 0
 13534 4d6a 0C94 0000 		jmp colorChangeSet
 13535               	.LVL1190:
 13536               	.L904:
 371:switcherator.c ****             switchBrightness(commandReceived);
 13537               		.loc 1 371 0
 13538 4d6e 0C94 0000 		jmp switchBrightness
 13539               	.LVL1191:
 13540               	.L865:
 374:switcherator.c ****             brightnessSet(commandReceived);
 13541               		.loc 1 374 0
 13542 4d72 0C94 0000 		jmp brightnessSet
 13543               	.LVL1192:
 13544               	.L860:
 13545 4d76 0895      		ret
 13546               	.LFE8:
 13548               		.section	.rodata.str1.1
 13549               	.LC74:
 13550 0173 6773 7100 		.string	"gsq"
 13551               	.LC75:
 13552 0177 5345 00   		.string	"SE"
 13553               	.LC76:
 13554 017a 7365 00   		.string	"se"
 13555               	.LC73:
 13556 017d 3030 3030 		.string	"000000"
 13556      3030 00
 13557               		.section	.text.startup,"ax",@progbits
 13558               	.global	main
 13560               	main:
 13561               	.LFB7:
 124:switcherator.c **** int main(void) {
 13562               		.loc 1 124 0
 13563 0000 CF93      		push r28
 13564               	.LCFI368:
 13565 0002 DF93      		push r29
 13566               	.LCFI369:
 13567 0004 CDB7      		in r28,__SP_L__
 13568 0006 DEB7      		in r29,__SP_H__
 13569               	.LCFI370:
 13570 0008 A797      		sbiw r28,39
 13571               	.LCFI371:
 13572 000a 0FB6      		in __tmp_reg__,__SREG__
 13573 000c F894      		cli
 13574 000e DEBF      		out __SP_H__,r29
 13575 0010 0FBE      		out __SREG__,__tmp_reg__
 13576 0012 CDBF      		out __SP_L__,r28
 13577               	/* prologue: function */
 13578               	/* frame size = 39 */
 13579               	/* stack size = 41 */
 13580               	.L__stack_usage = 41
 125:switcherator.c ****     receiveBuffer[0] = 0;
 13581               		.loc 1 125 0
 13582 0014 1092 0000 		sts receiveBuffer,__zero_reg__
 126:switcherator.c ****     radioReceiveBuffer[0] = 0;
 13583               		.loc 1 126 0
 13584 0018 1092 0000 		sts radioReceiveBuffer,__zero_reg__
 13585               	.LVL1193:
 129:switcherator.c ****     INDICATOR_DDR |= INDICATOR_PIN;
 13586               		.loc 1 129 0
 13587 001c 529A      		sbi 0xa,2
 13588 001e 84E0      		ldi r24,lo8(4)
 13589 0020 90E0      		ldi r25,0
 13590               	.LVL1194:
 13591               	.L906:
 131:switcherator.c ****         INDICATOR_PORT |= INDICATOR_PIN;
 13592               		.loc 1 131 0 discriminator 2
 13593 0022 5A9A      		sbi 0xb,2
 13594               	.LVL1195:
 13595               	.LBB30:
 13596               	.LBB31:
 164:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 13597               		.loc 2 164 0 discriminator 2
 13598 0024 2FEF      		ldi r18,lo8(159999)
 13599 0026 30E7      		ldi r19,hi8(159999)
 13600 0028 42E0      		ldi r20,hlo8(159999)
 13601 002a 2150      		1: subi r18,1
 13602 002c 3040      		sbci r19,0
 13603 002e 4040      		sbci r20,0
 13604 0030 01F4      		brne 1b
 13605 0032 00C0      		rjmp .
 13606 0034 0000      		nop
 13607               	.LBE31:
 13608               	.LBE30:
 133:switcherator.c ****         INDICATOR_PORT &= ~(INDICATOR_PIN);
 13609               		.loc 1 133 0 discriminator 2
 13610 0036 5A98      		cbi 0xb,2
 13611               	.LVL1196:
 13612               	.LBB32:
 13613               	.LBB33:
 164:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 13614               		.loc 2 164 0 discriminator 2
 13615 0038 5FEF      		ldi r21,lo8(319999)
 13616 003a A1EE      		ldi r26,hi8(319999)
 13617 003c B4E0      		ldi r27,hlo8(319999)
 13618 003e 5150      		1: subi r21,1
 13619 0040 A040      		sbci r26,0
 13620 0042 B040      		sbci r27,0
 13621 0044 01F4      		brne 1b
 13622 0046 00C0      		rjmp .
 13623 0048 0000      		nop
 13624 004a 0197      		sbiw r24,1
 13625               	.LBE33:
 13626               	.LBE32:
 130:switcherator.c ****     for (x = 0; x < 4; x++) {
 13627               		.loc 1 130 0 discriminator 2
 13628 004c 01F4      		brne .L906
 136:switcherator.c ****     INDICATOR_PORT |= INDICATOR_PIN;
 13629               		.loc 1 136 0
 13630 004e 5A9A      		sbi 0xb,2
 13631               	.LVL1197:
 13632 0050 E0E0      		ldi r30,lo8(colorChanges+2)
 13633 0052 F0E0      		ldi r31,hi8(colorChanges+2)
 142:switcherator.c ****         colorChanges[x][1] = 1;
 13634               		.loc 1 142 0
 13635 0054 81E0      		ldi r24,lo8(1)
 13636               	.LVL1198:
 13637               	.L907:
 124:switcherator.c **** int main(void) {
 13638               		.loc 1 124 0 discriminator 2
 13639 0056 DF01      		movw r26,r30
 13640 0058 1297      		sbiw r26,2
 141:switcherator.c ****         colorChanges[x][0] = 0;
 13641               		.loc 1 141 0 discriminator 2
 13642 005a 1C92      		st X,__zero_reg__
 124:switcherator.c **** int main(void) {
 13643               		.loc 1 124 0 discriminator 2
 13644 005c DF01      		movw r26,r30
 13645 005e 1197      		sbiw r26,1
 142:switcherator.c ****         colorChanges[x][1] = 1;
 13646               		.loc 1 142 0 discriminator 2
 13647 0060 8C93      		st X,r24
 143:switcherator.c ****         colorChanges[x][2] = 0;
 13648               		.loc 1 143 0 discriminator 2
 13649 0062 1082      		st Z,__zero_reg__
 13650 0064 3396      		adiw r30,3
 140:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 13651               		.loc 1 140 0 discriminator 2
 13652 0066 20E0      		ldi r18,hi8(colorChanges+20)
 13653 0068 E030      		cpi r30,lo8(colorChanges+20)
 13654 006a F207      		cpc r31,r18
 13655 006c 01F4      		brne .L907
 147:switcherator.c ****     globalYear = globalMonth = globalDay = globalHour = globalMinute = globalSecond = dow = 0;
 13656               		.loc 1 147 0
 13657 006e 1092 0000 		sts dow+1,__zero_reg__
 13658 0072 1092 0000 		sts dow,__zero_reg__
 13659 0076 1092 0000 		sts globalSecond+1,__zero_reg__
 13660 007a 1092 0000 		sts globalSecond,__zero_reg__
 13661 007e 1092 0000 		sts globalMinute+1,__zero_reg__
 13662 0082 1092 0000 		sts globalMinute,__zero_reg__
 13663 0086 1092 0000 		sts globalHour+1,__zero_reg__
 13664 008a 1092 0000 		sts globalHour,__zero_reg__
 13665 008e 1092 0000 		sts globalDay+1,__zero_reg__
 13666 0092 1092 0000 		sts globalDay,__zero_reg__
 13667 0096 1092 0000 		sts globalMonth+1,__zero_reg__
 13668 009a 1092 0000 		sts globalMonth,__zero_reg__
 13669 009e 1092 0000 		sts globalYear+1,__zero_reg__
 13670 00a2 1092 0000 		sts globalYear,__zero_reg__
 13671               	.LVL1199:
 13672 00a6 E0E0      		ldi r30,lo8(switchStatus)
 13673 00a8 F0E0      		ldi r31,hi8(switchStatus)
 13674 00aa 80E0      		ldi r24,lo8(switchStuff)
 13675 00ac 90E0      		ldi r25,hi8(switchStuff)
 13676 00ae 60E0      		ldi r22,lo8(switchBright)
 13677 00b0 70E0      		ldi r23,hi8(switchBright)
 150:switcherator.c ****         switchStuff[x] = 255;
 13678               		.loc 1 150 0
 13679 00b2 4FEF      		ldi r20,lo8(-1)
 151:switcherator.c ****         switchBright[x] = 16;
 13680               		.loc 1 151 0
 13681 00b4 30E1      		ldi r19,lo8(16)
 13682               	.LVL1200:
 13683               	.L908:
 149:switcherator.c ****         switchStatus[x] = 0;
 13684               		.loc 1 149 0 discriminator 2
 13685 00b6 1192      		st Z+,__zero_reg__
 13686 00b8 1192      		st Z+,__zero_reg__
 13687 00ba 1192      		st Z+,__zero_reg__
 13688 00bc 1192      		st Z+,__zero_reg__
 150:switcherator.c ****         switchStuff[x] = 255;
 13689               		.loc 1 150 0 discriminator 2
 13690 00be 2FEF      		ldi r18,lo8(-1)
 13691 00c0 DC01      		movw r26,r24
 13692 00c2 4D93      		st X+,r20
 13693 00c4 CD01      		movw r24,r26
 151:switcherator.c ****         switchBright[x] = 16;
 13694               		.loc 1 151 0 discriminator 2
 13695 00c6 DB01      		movw r26,r22
 13696 00c8 3D93      		st X+,r19
 13697 00ca BD01      		movw r22,r26
 148:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 13698               		.loc 1 148 0 discriminator 2
 13699 00cc B0E0      		ldi r27,hi8(switchStatus+64)
 13700 00ce E030      		cpi r30,lo8(switchStatus+64)
 13701 00d0 FB07      		cpc r31,r27
 13702 00d2 01F4      		brne .L908
 13703               	.LVL1201:
 154:switcherator.c ****         inputs[x][0] = 255;
 13704               		.loc 1 154 0 discriminator 1
 13705 00d4 2093 0000 		sts inputs,r18
 13706               	.LVL1202:
 13707 00d8 2093 0000 		sts inputs+8,r18
 13708               	.LVL1203:
 13709 00dc 2093 0000 		sts inputs+16,r18
 13710               	.LVL1204:
 13711 00e0 2093 0000 		sts inputs+24,r18
 13712               	.LVL1205:
 156:switcherator.c ****     sei();
 13713               		.loc 1 156 0 discriminator 1
 13714               	/* #APP */
 13715               	 ;  156 "switcherator.c" 1
 13716 00e4 7894      		sei
 13717               	 ;  0 "" 2
 13718               	.LVL1206:
 159:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 13719               		.loc 1 159 0 discriminator 1
 13720               	/* #NOAPP */
 13721 00e6 00E0      		ldi r16,0
 13722 00e8 10E0      		ldi r17,0
 13723               	.LVL1207:
 13724               	.L909:
 160:switcherator.c ****         clearTheProgram(x);
 13725               		.loc 1 160 0 discriminator 2
 13726 00ea C801      		movw r24,r16
 13727 00ec 0E94 0000 		call clearTheProgram
 13728               	.LVL1208:
 159:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 13729               		.loc 1 159 0 discriminator 2
 13730 00f0 0F5F      		subi r16,-1
 13731 00f2 1F4F      		sbci r17,-1
 13732               	.LVL1209:
 13733 00f4 0A30      		cpi r16,10
 13734 00f6 1105      		cpc r17,__zero_reg__
 13735 00f8 01F4      		brne .L909
 165:switcherator.c ****     clockInit();
 13736               		.loc 1 165 0
 13737 00fa 0E94 0000 		call clockInit
 13738               	.LVL1210:
 166:switcherator.c ****     radioInit();
 13739               		.loc 1 166 0
 13740 00fe 0E94 0000 		call radioInit
 13741               	.LVL1211:
 167:switcherator.c ****     startRx();
 13742               		.loc 1 167 0
 13743 0102 0E94 0000 		call startRx
 13744               	.LVL1212:
 169:switcherator.c ****     generalInit();
 13745               		.loc 1 169 0
 13746 0106 0E94 0000 		call generalInit
 13747               	.LVL1213:
 170:switcherator.c ****     startClock();
 13748               		.loc 1 170 0
 13749 010a 0E94 0000 		call startClock
 13750               	.LVL1214:
 176:switcherator.c ****     radioCommand[0] = 0;
 13751               		.loc 1 176 0
 13752 010e 1982      		std Y+1,__zero_reg__
 177:switcherator.c ****     char tempRadioSerialIn[] = "000000";
 13753               		.loc 1 177 0
 13754 0110 87E0      		ldi r24,lo8(7)
 13755 0112 E0E0      		ldi r30,lo8(.LC73)
 13756 0114 F0E0      		ldi r31,hi8(.LC73)
 13757 0116 DE01      		movw r26,r28
 13758 0118 9196      		adiw r26,33
 13759               		0:
 13760 011a 0190      		ld r0,Z+
 13761 011c 0D92      		st X+,r0
 13762 011e 8A95      		dec r24
 13763 0120 01F4      		brne 0b
 13764               	.LVL1215:
 13765               	.L951:
 184:switcherator.c ****         if (newSecond == 1) {
 13766               		.loc 1 184 0
 13767 0122 8091 0000 		lds r24,newSecond
 13768 0126 8130      		cpi r24,lo8(1)
 13769 0128 01F4      		brne .L910
 185:switcherator.c ****             newSecond = 0;
 13770               		.loc 1 185 0
 13771 012a 1092 0000 		sts newSecond,__zero_reg__
 186:switcherator.c ****             timerCheck();
 13772               		.loc 1 186 0
 13773 012e 0E94 0000 		call timerCheck
 13774               	.LVL1216:
 187:switcherator.c ****             inputCheck();
 13775               		.loc 1 187 0
 13776 0132 0E94 0000 		call inputCheck
 13777               	.LVL1217:
 13778               	.L910:
 190:switcherator.c ****         if (switchChanged == 1) {
 13779               		.loc 1 190 0
 13780 0136 8091 0000 		lds r24,switchChanged
 13781 013a 8130      		cpi r24,lo8(1)
 13782 013c 01F4      		brne .L911
 191:switcherator.c ****             switchChanged = 0;
 13783               		.loc 1 191 0
 13784 013e 1092 0000 		sts switchChanged,__zero_reg__
 192:switcherator.c ****             switchOnOff();
 13785               		.loc 1 192 0
 13786 0142 0E94 0000 		call switchOnOff
 13787               	.LVL1218:
 13788               	.L911:
 194:switcherator.c ****         if (runHue == 1) {
 13789               		.loc 1 194 0
 13790 0146 8091 0000 		lds r24,runHue
 13791 014a 8130      		cpi r24,lo8(1)
 13792 014c 01F4      		brne .L912
 195:switcherator.c ****             runHueFunction();
 13793               		.loc 1 195 0
 13794 014e 0E94 0000 		call runHueFunction
 13795               	.LVL1219:
 13796               	.L912:
 197:switcherator.c ****         if (runColorChanges == 1) {
 13797               		.loc 1 197 0
 13798 0152 1091 0000 		lds r17,runColorChanges
 13799 0156 1130      		cpi r17,lo8(1)
 13800 0158 01F4      		brne .L913
 198:switcherator.c ****             runColorFunction();
 13801               		.loc 1 198 0
 13802 015a 0E94 0000 		call runColorFunction
 13803               	.LVL1220:
 13804               	.L913:
 200:switcherator.c ****         if (tenthFlag == 1) {
 13805               		.loc 1 200 0
 13806 015e 8091 0000 		lds r24,tenthFlag
 13807 0162 8130      		cpi r24,lo8(1)
 13808 0164 01F4      		brne .L915
 201:switcherator.c ****             tenthFlag = 0;
 13809               		.loc 1 201 0
 13810 0166 1092 0000 		sts tenthFlag,__zero_reg__
 202:switcherator.c ****             inputTenthCheck();
 13811               		.loc 1 202 0
 13812 016a 0E94 0000 		call inputTenthCheck
 13813               	.LVL1221:
 203:switcherator.c ****             if (failCondition > 0) {
 13814               		.loc 1 203 0
 13815 016e 8091 0000 		lds r24,failCondition
 13816 0172 8111      		cpse r24,__zero_reg__
 204:switcherator.c ****                 flashFail();
 13817               		.loc 1 204 0
 13818 0174 0E94 0000 		call flashFail
 13819               	.LVL1222:
 13820               	.L916:
 206:switcherator.c ****             if (runColorChanges == 1) {
 13821               		.loc 1 206 0
 13822 0178 1130      		cpi r17,lo8(1)
 13823 017a 01F4      		brne .L915
 207:switcherator.c ****                 runColorFunction();
 13824               		.loc 1 207 0
 13825 017c 0E94 0000 		call runColorFunction
 13826               	.LVL1223:
 13827               	.L915:
 210:switcherator.c ****         if (newMinute == 1) {
 13828               		.loc 1 210 0
 13829 0180 8091 0000 		lds r24,newMinute
 13830 0184 8130      		cpi r24,lo8(1)
 13831 0186 01F4      		brne .L918
 211:switcherator.c ****             newMinute = 0;
 13832               		.loc 1 211 0
 13833 0188 1092 0000 		sts newMinute,__zero_reg__
 212:switcherator.c ****             if (panicMyClockIsNotSet == 1) {
 13834               		.loc 1 212 0
 13835 018c 8091 0000 		lds r24,panicMyClockIsNotSet
 13836 0190 8130      		cpi r24,lo8(1)
 13837 0192 01F4      		brne .L919
 213:switcherator.c ****                 generalStatus("gsq");
 13838               		.loc 1 213 0
 13839 0194 80E0      		ldi r24,lo8(.LC74)
 13840 0196 90E0      		ldi r25,hi8(.LC74)
 13841 0198 0E94 0000 		call generalStatus
 13842               	.LVL1224:
 13843               	.L919:
 215:switcherator.c ****             radioTest();
 13844               		.loc 1 215 0
 13845 019c 0E94 0000 		call radioTest
 13846               	.LVL1225:
 13847               	.L918:
 218:switcherator.c ****         payloadLength = dynReceive(radioReceiveBuffer);
 13848               		.loc 1 218 0
 13849 01a0 80E0      		ldi r24,lo8(radioReceiveBuffer)
 13850 01a2 90E0      		ldi r25,hi8(radioReceiveBuffer)
 13851 01a4 0E94 0000 		call dynReceive
 13852               	.LVL1226:
 13853 01a8 082F      		mov r16,r24
 13854 01aa 10E0      		ldi r17,0
 13855               	.LVL1227:
 219:switcherator.c ****         if (payloadLength > 2) {
 13856               		.loc 1 219 0
 13857 01ac 0330      		cpi r16,3
 13858 01ae 1105      		cpc r17,__zero_reg__
 13859 01b0 04F4      		brge .+2
 13860 01b2 00C0      		rjmp .L951
 13861               	.LVL1228:
 13862               	.LBB34:
 13863               	.LBB35:
 164:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 13864               		.loc 2 164 0
 13865 01b4 2FEF      		ldi r18,lo8(287999)
 13866 01b6 34E6      		ldi r19,hi8(287999)
 13867 01b8 44E0      		ldi r20,hlo8(287999)
 13868 01ba 2150      		1: subi r18,1
 13869 01bc 3040      		sbci r19,0
 13870 01be 4040      		sbci r20,0
 13871 01c0 01F4      		brne 1b
 13872 01c2 00C0      		rjmp .
 13873 01c4 0000      		nop
 13874               	.LBE35:
 13875               	.LBE34:
 223:switcherator.c ****             if (radioReceiveBuffer[0] == 'z') {
 13876               		.loc 1 223 0
 13877 01c6 8091 0000 		lds r24,radioReceiveBuffer
 13878 01ca 8A37      		cpi r24,lo8(122)
 13879 01cc 01F4      		brne .L921
 13880 01ce E0E0      		ldi r30,lo8(radioReceiveBuffer+1)
 13881 01d0 F0E0      		ldi r31,hi8(radioReceiveBuffer+1)
 13882 01d2 DE01      		movw r26,r28
 13883 01d4 9196      		adiw r26,33
 13884               	.L922:
 226:switcherator.c ****                     tempRadioSerialIn[x] = radioReceiveBuffer[(x + 1)];
 13885               		.loc 1 226 0 discriminator 2
 13886 01d6 8191      		ld r24,Z+
 13887 01d8 8D93      		st X+,r24
 225:switcherator.c ****                 for (x = 0; x < 6; x++) {
 13888               		.loc 1 225 0 discriminator 2
 13889 01da 50E0      		ldi r21,hi8(radioReceiveBuffer+7)
 13890 01dc E030      		cpi r30,lo8(radioReceiveBuffer+7)
 13891 01de F507      		cpc r31,r21
 13892 01e0 01F4      		brne .L922
 229:switcherator.c ****                 if (strcmp(tempRadioSerialIn, stringSerial) == 0) {
 13893               		.loc 1 229 0
 13894 01e2 60E0      		ldi r22,lo8(stringSerial)
 13895 01e4 70E0      		ldi r23,hi8(stringSerial)
 13896 01e6 CE01      		movw r24,r28
 13897 01e8 8196      		adiw r24,33
 13898 01ea 0E94 0000 		call strcmp
 13899               	.LVL1229:
 13900 01ee 0097      		sbiw r24,0
 13901 01f0 01F4      		brne .L924
 13902 01f2 E0E0      		ldi r30,lo8(radioReceiveBuffer+7)
 13903 01f4 F0E0      		ldi r31,hi8(radioReceiveBuffer+7)
 13904 01f6 DE01      		movw r26,r28
 13905 01f8 1196      		adiw r26,1
 13906 01fa 00C0      		rjmp .L925
 13907               	.L926:
 231:switcherator.c ****                         radioCommand[(x - 7)] = radioReceiveBuffer[x];
 13908               		.loc 1 231 0 discriminator 2
 13909 01fc 8191      		ld r24,Z+
 13910 01fe 8D93      		st X+,r24
 13911               	.L925:
 124:switcherator.c **** int main(void) {
 13912               		.loc 1 124 0 discriminator 1
 13913 0200 CF01      		movw r24,r30
 13914 0202 8050      		subi r24,lo8(radioReceiveBuffer)
 13915 0204 9040      		sbci r25,hi8(radioReceiveBuffer)
 230:switcherator.c ****                     for (x = 7; x < payloadLength; x++) {
 13916               		.loc 1 230 0 discriminator 1
 13917 0206 8017      		cp r24,r16
 13918 0208 9107      		cpc r25,r17
 13919 020a 04F0      		brlt .L926
 13920               	.L931:
 234:switcherator.c ****                     checkCommand(radioCommand);
 13921               		.loc 1 234 0
 13922 020c CE01      		movw r24,r28
 13923 020e 0196      		adiw r24,1
 13924 0210 0E94 0000 		call checkCommand
 13925               	.LVL1230:
 13926               	.L924:
 13927 0214 E0E0      		ldi r30,lo8(radioReceiveBuffer)
 13928 0216 F0E0      		ldi r31,hi8(radioReceiveBuffer)
 13929 0218 80E0      		ldi r24,lo8(receiveBuffer)
 13930 021a 90E0      		ldi r25,hi8(receiveBuffer)
 13931 021c AE01      		movw r20,r28
 13932 021e 4F5F      		subi r20,-1
 13933 0220 5F4F      		sbci r21,-1
 13934 0222 00C0      		rjmp .L927
 13935               	.LVL1231:
 13936               	.L921:
 236:switcherator.c ****             } else if (radioReceiveBuffer[0] == 'b') { // radio isn't sending a serial number b=bro
 13937               		.loc 1 236 0
 13938 0224 8236      		cpi r24,lo8(98)
 13939 0226 01F4      		brne .L924
 13940 0228 E0E0      		ldi r30,lo8(radioReceiveBuffer+1)
 13941 022a F0E0      		ldi r31,hi8(radioReceiveBuffer+1)
 13942 022c DE01      		movw r26,r28
 13943 022e 1196      		adiw r26,1
 13944               	.L929:
 238:switcherator.c ****                     radioCommand[(x - 1)] = radioReceiveBuffer[x];
 13945               		.loc 1 238 0 discriminator 2
 13946 0230 8191      		ld r24,Z+
 13947 0232 8D93      		st X+,r24
 124:switcherator.c **** int main(void) {
 13948               		.loc 1 124 0 discriminator 2
 13949 0234 CF01      		movw r24,r30
 13950 0236 8050      		subi r24,lo8(radioReceiveBuffer)
 13951 0238 9040      		sbci r25,hi8(radioReceiveBuffer)
 237:switcherator.c ****                 for (x = 1; x < payloadLength; x++) {
 13952               		.loc 1 237 0 discriminator 2
 13953 023a 8017      		cp r24,r16
 13954 023c 9107      		cpc r25,r17
 13955 023e 04F0      		brlt .L929
 241:switcherator.c ****                 if (strncmp(radioCommand, "SE", 2) == 0 || strncmp(radioCommand, "se", 2) == 0) {
 13956               		.loc 1 241 0
 13957 0240 42E0      		ldi r20,lo8(2)
 13958 0242 50E0      		ldi r21,0
 13959 0244 60E0      		ldi r22,lo8(.LC75)
 13960 0246 70E0      		ldi r23,hi8(.LC75)
 13961 0248 CE01      		movw r24,r28
 13962 024a 0196      		adiw r24,1
 13963 024c 0E94 0000 		call strncmp
 13964               	.LVL1232:
 13965 0250 0097      		sbiw r24,0
 13966 0252 01F0      		breq .L930
 241:switcherator.c ****                 if (strncmp(radioCommand, "SE", 2) == 0 || strncmp(radioCommand, "se", 2) == 0) {
 13967               		.loc 1 241 0 is_stmt 0 discriminator 1
 13968 0254 42E0      		ldi r20,lo8(2)
 13969 0256 50E0      		ldi r21,0
 13970 0258 60E0      		ldi r22,lo8(.LC76)
 13971 025a 70E0      		ldi r23,hi8(.LC76)
 13972 025c CE01      		movw r24,r28
 13973 025e 0196      		adiw r24,1
 13974 0260 0E94 0000 		call strncmp
 13975               	.LVL1233:
 13976 0264 0097      		sbiw r24,0
 13977 0266 01F4      		brne .L931
 13978               	.L930:
 242:switcherator.c ****                     if (serial == 0) {
 13979               		.loc 1 242 0 is_stmt 1
 13980 0268 8091 0000 		lds r24,serial
 13981 026c 9091 0000 		lds r25,serial+1
 13982 0270 A091 0000 		lds r26,serial+2
 13983 0274 B091 0000 		lds r27,serial+3
 13984 0278 892B      		or r24,r25
 13985 027a 8A2B      		or r24,r26
 13986 027c 8B2B      		or r24,r27
 13987 027e 01F4      		brne .L924
 13988 0280 00C0      		rjmp .L931
 13989               	.L927:
 251:switcherator.c ****                 radioReceiveBuffer[x] = 0;
 13990               		.loc 1 251 0 discriminator 2
 13991 0282 1192      		st Z+,__zero_reg__
 252:switcherator.c ****                 receiveBuffer[x] = 0;
 13992               		.loc 1 252 0 discriminator 2
 13993 0284 DC01      		movw r26,r24
 13994 0286 1D92      		st X+,__zero_reg__
 13995 0288 CD01      		movw r24,r26
 253:switcherator.c ****                 radioCommand[x] = 0;
 13996               		.loc 1 253 0 discriminator 2
 13997 028a DA01      		movw r26,r20
 13998 028c 1D92      		st X+,__zero_reg__
 13999 028e AD01      		movw r20,r26
 250:switcherator.c ****             for (x = 0; x < 30; x++) {
 14000               		.loc 1 250 0 discriminator 2
 14001 0290 B0E0      		ldi r27,hi8(radioReceiveBuffer+30)
 14002 0292 E030      		cpi r30,lo8(radioReceiveBuffer+30)
 14003 0294 FB07      		cpc r31,r27
 14004 0296 01F4      		brne .L927
 14005 0298 00C0      		rjmp .L951
 14006               	.LFE7:
 14008               		.text
 14009               	.global	__vector_11
 14011               	__vector_11:
 14012               	.LFB81:
3714:switcherator.c **** }
3715:switcherator.c **** 
3716:switcherator.c **** ISR(TIMER1_COMPA_vect) {
 14013               		.loc 1 3716 0
 14014 4d78 1F92      		push r1
 14015               	.LCFI372:
 14016 4d7a 0F92      		push r0
 14017               	.LCFI373:
 14018 4d7c 0FB6      		in r0,__SREG__
 14019 4d7e 0F92      		push r0
 14020 4d80 1124      		clr __zero_reg__
 14021 4d82 2F93      		push r18
 14022               	.LCFI374:
 14023 4d84 3F93      		push r19
 14024               	.LCFI375:
 14025 4d86 4F93      		push r20
 14026               	.LCFI376:
 14027 4d88 5F93      		push r21
 14028               	.LCFI377:
 14029 4d8a 6F93      		push r22
 14030               	.LCFI378:
 14031 4d8c 7F93      		push r23
 14032               	.LCFI379:
 14033 4d8e 8F93      		push r24
 14034               	.LCFI380:
 14035 4d90 9F93      		push r25
 14036               	.LCFI381:
 14037 4d92 AF93      		push r26
 14038               	.LCFI382:
 14039 4d94 BF93      		push r27
 14040               	.LCFI383:
 14041 4d96 EF93      		push r30
 14042               	.LCFI384:
 14043 4d98 FF93      		push r31
 14044               	.LCFI385:
 14045               	/* prologue: Signal */
 14046               	/* frame size = 0 */
 14047               	/* stack size = 15 */
 14048               	.L__stack_usage = 15
3717:switcherator.c ****     int tenthTicks;
3718:switcherator.c ****     ticks++;
 14049               		.loc 1 3718 0
 14050 4d9a 4091 0000 		lds r20,ticks
 14051 4d9e 5091 0000 		lds r21,ticks+1
 14052 4da2 4F5F      		subi r20,-1
 14053 4da4 5F4F      		sbci r21,-1
 14054 4da6 5093 0000 		sts ticks+1,r21
 14055 4daa 4093 0000 		sts ticks,r20
3719:switcherator.c ****     // if its been a second
3720:switcherator.c ****     if (ticks >= tweakTimer) {
 14056               		.loc 1 3720 0
 14057 4dae 60E0      		ldi r22,0
 14058 4db0 70E0      		ldi r23,0
 14059 4db2 8091 0000 		lds r24,tweakTimer
 14060 4db6 9091 0000 		lds r25,tweakTimer+1
 14061 4dba A091 0000 		lds r26,tweakTimer+2
 14062 4dbe B091 0000 		lds r27,tweakTimer+3
 14063 4dc2 4817      		cp r20,r24
 14064 4dc4 5907      		cpc r21,r25
 14065 4dc6 6A07      		cpc r22,r26
 14066 4dc8 7B07      		cpc r23,r27
 14067 4dca 04F4      		brge .+2
 14068 4dcc 00C0      		rjmp .L954
3721:switcherator.c ****         ticks = 0;
 14069               		.loc 1 3721 0
 14070 4dce 1092 0000 		sts ticks+1,__zero_reg__
 14071 4dd2 1092 0000 		sts ticks,__zero_reg__
3722:switcherator.c ****         globalSecond++;
 14072               		.loc 1 3722 0
 14073 4dd6 2091 0000 		lds r18,globalSecond
 14074 4dda 3091 0000 		lds r19,globalSecond+1
 14075 4dde 2F5F      		subi r18,-1
 14076 4de0 3F4F      		sbci r19,-1
 14077 4de2 3093 0000 		sts globalSecond+1,r19
 14078 4de6 2093 0000 		sts globalSecond,r18
3723:switcherator.c ****         weeklySeconds++;
 14079               		.loc 1 3723 0
 14080 4dea 8091 0000 		lds r24,weeklySeconds
 14081 4dee 9091 0000 		lds r25,weeklySeconds+1
 14082 4df2 A091 0000 		lds r26,weeklySeconds+2
 14083 4df6 B091 0000 		lds r27,weeklySeconds+3
 14084 4dfa 0196      		adiw r24,1
 14085 4dfc A11D      		adc r26,__zero_reg__
 14086 4dfe B11D      		adc r27,__zero_reg__
 14087 4e00 8093 0000 		sts weeklySeconds,r24
 14088 4e04 9093 0000 		sts weeklySeconds+1,r25
 14089 4e08 A093 0000 		sts weeklySeconds+2,r26
 14090 4e0c B093 0000 		sts weeklySeconds+3,r27
3724:switcherator.c ****         newSecond = 1;
 14091               		.loc 1 3724 0
 14092 4e10 41E0      		ldi r20,lo8(1)
 14093 4e12 4093 0000 		sts newSecond,r20
3725:switcherator.c ****         if (globalSecond == 60) {
 14094               		.loc 1 3725 0
 14095 4e16 2C33      		cpi r18,60
 14096 4e18 3105      		cpc r19,__zero_reg__
 14097 4e1a 01F4      		brne .L954
3726:switcherator.c ****             globalMinute++;
 14098               		.loc 1 3726 0
 14099 4e1c 8091 0000 		lds r24,globalMinute
 14100 4e20 9091 0000 		lds r25,globalMinute+1
 14101 4e24 0196      		adiw r24,1
 14102 4e26 9093 0000 		sts globalMinute+1,r25
 14103 4e2a 8093 0000 		sts globalMinute,r24
3727:switcherator.c ****             globalSecond = 0;
 14104               		.loc 1 3727 0
 14105 4e2e 1092 0000 		sts globalSecond+1,__zero_reg__
 14106 4e32 1092 0000 		sts globalSecond,__zero_reg__
3728:switcherator.c ****             newMinute = 1;
 14107               		.loc 1 3728 0
 14108 4e36 4093 0000 		sts newMinute,r20
3729:switcherator.c ****             if (globalMinute == 60) {
 14109               		.loc 1 3729 0
 14110 4e3a CC97      		sbiw r24,60
 14111 4e3c 01F4      		brne .L954
3730:switcherator.c ****                 globalHour++;
 14112               		.loc 1 3730 0
 14113 4e3e 8091 0000 		lds r24,globalHour
 14114 4e42 9091 0000 		lds r25,globalHour+1
 14115 4e46 0196      		adiw r24,1
 14116 4e48 9093 0000 		sts globalHour+1,r25
 14117 4e4c 8093 0000 		sts globalHour,r24
3731:switcherator.c ****                 globalMinute = 0;
 14118               		.loc 1 3731 0
 14119 4e50 1092 0000 		sts globalMinute+1,__zero_reg__
 14120 4e54 1092 0000 		sts globalMinute,__zero_reg__
3732:switcherator.c ****                 // daylight savings is always at 3am
3733:switcherator.c ****                 if (globalHour == 3)
 14121               		.loc 1 3733 0
 14122 4e58 0397      		sbiw r24,3
 14123 4e5a 01F4      		brne .L956
3734:switcherator.c ****                     checkDaylightSavings();
 14124               		.loc 1 3734 0
 14125 4e5c 0E94 0000 		call checkDaylightSavings
 14126               	.LVL1234:
 14127               	.L956:
3735:switcherator.c ****                 if (globalHour == 24) {
 14128               		.loc 1 3735 0
 14129 4e60 8091 0000 		lds r24,globalHour
 14130 4e64 9091 0000 		lds r25,globalHour+1
 14131 4e68 4897      		sbiw r24,24
 14132 4e6a 01F4      		brne .L954
3736:switcherator.c ****                     globalHour = 0;
 14133               		.loc 1 3736 0
 14134 4e6c 1092 0000 		sts globalHour+1,__zero_reg__
 14135 4e70 1092 0000 		sts globalHour,__zero_reg__
3737:switcherator.c ****                     advanceDay();
 14136               		.loc 1 3737 0
 14137 4e74 0E94 0000 		call advanceDay
 14138               	.LVL1235:
 14139               	.L954:
3738:switcherator.c ****                 }
3739:switcherator.c ****             }
3740:switcherator.c ****         }
3741:switcherator.c ****     }
3742:switcherator.c ****     tenthTicks = ticks % TIMER_TENTH;
 14140               		.loc 1 3742 0
 14141 4e78 8091 0000 		lds r24,ticks
 14142 4e7c 9091 0000 		lds r25,ticks+1
 14143 4e80 68E1      		ldi r22,lo8(24)
 14144 4e82 76E0      		ldi r23,lo8(6)
 14145 4e84 0E94 0000 		call __udivmodhi4
 14146               	.LVL1236:
3743:switcherator.c ****     if (tenthTicks == 0) {
 14147               		.loc 1 3743 0
 14148 4e88 892B      		or r24,r25
 14149 4e8a 01F4      		brne .L952
3744:switcherator.c ****         tenthFlag = 1;
 14150               		.loc 1 3744 0
 14151 4e8c 81E0      		ldi r24,lo8(1)
 14152               	.LVL1237:
 14153 4e8e 8093 0000 		sts tenthFlag,r24
 14154               	.L952:
 14155               	/* epilogue start */
3745:switcherator.c ****         // set flags for whatever functions we want to do every 10th of a second here
3746:switcherator.c ****     }
3747:switcherator.c **** }
 14156               		.loc 1 3747 0
 14157 4e92 FF91      		pop r31
 14158 4e94 EF91      		pop r30
 14159 4e96 BF91      		pop r27
 14160 4e98 AF91      		pop r26
 14161 4e9a 9F91      		pop r25
 14162 4e9c 8F91      		pop r24
 14163 4e9e 7F91      		pop r23
 14164 4ea0 6F91      		pop r22
 14165 4ea2 5F91      		pop r21
 14166 4ea4 4F91      		pop r20
 14167 4ea6 3F91      		pop r19
 14168 4ea8 2F91      		pop r18
 14169 4eaa 0F90      		pop r0
 14170 4eac 0FBE      		out __SREG__,r0
 14171 4eae 0F90      		pop r0
 14172 4eb0 1F90      		pop r1
 14173 4eb2 1895      		reti
 14174               	.LFE81:
 14176               		.local	receiveBuffer
 14177               		.comm	receiveBuffer,30,1
 14178               		.local	radioReceiveBuffer
 14179               		.comm	radioReceiveBuffer,30,1
 14180               		.local	colorChanges
 14181               		.comm	colorChanges,18,1
 14182               		.local	dow
 14183               		.comm	dow,2,1
 14184               		.local	globalSecond
 14185               		.comm	globalSecond,2,1
 14186               		.local	globalMinute
 14187               		.comm	globalMinute,2,1
 14188               		.local	globalHour
 14189               		.comm	globalHour,2,1
 14190               		.local	globalDay
 14191               		.comm	globalDay,2,1
 14192               		.local	globalMonth
 14193               		.comm	globalMonth,2,1
 14194               		.local	globalYear
 14195               		.comm	globalYear,2,1
 14196               		.local	switchStatus
 14197               		.comm	switchStatus,64,1
 14198               		.local	switchStuff
 14199               		.comm	switchStuff,16,1
 14200               		.local	switchBright
 14201               		.comm	switchBright,16,1
 14202               		.local	inputs
 14203               		.comm	inputs,32,1
 14204               		.local	newSecond
 14205               		.comm	newSecond,1,1
 14206               		.local	switchChanged
 14207               		.comm	switchChanged,1,1
 14208               		.local	runHue
 14209               		.comm	runHue,1,1
 14210               		.local	runColorChanges
 14211               		.comm	runColorChanges,1,1
 14212               		.local	tenthFlag
 14213               		.comm	tenthFlag,1,1
 14214               		.data
 14217               	failCondition:
 14218 0000 03        		.byte	3
 14219               		.local	newMinute
 14220               		.comm	newMinute,1,1
 14223               	panicMyClockIsNotSet:
 14224 0001 01        		.byte	1
 14227               	stringSerial:
 14228 0002 3030 3030 		.string	"000000"
 14228      3030 00
 14229               		.local	serial
 14230               		.comm	serial,4,1
 14231               		.local	statusMsg
 14232               		.comm	statusMsg,32,1
 14235               	tempIntString:
 14236 0009 3030 00   		.string	"00"
 14239               	tempHugeString:
 14240 000c 3030 3030 		.string	"000000"
 14240      3030 00
 14241               		.local	weeklySeconds
 14242               		.comm	weeklySeconds,4,1
 14243               		.local	pwmValues
 14244               		.comm	pwmValues,3,1
 14245               		.local	red
 14246               		.comm	red,2,1
 14247               		.local	green
 14248               		.comm	green,2,1
 14249               		.local	blue
 14250               		.comm	blue,2,1
 14253               	bright:
 14254 0013 1000      		.word	16
 14255               		.local	pwmdir
 14256               		.comm	pwmdir,1,1
 14259               	oldBright:
 14260 0015 10        		.byte	16
 14263               	tempLongString:
 14264 0016 3030 3030 		.string	"0000"
 14264      00
 14267               	colorChangeSpeed:
 14268 001b 0A00      		.word	10
 14271               	hueSpeed:
 14272 001d 1000      		.word	16
 14273               		.local	colorChangeCount
 14274               		.comm	colorChangeCount,2,1
 14275               		.local	currentColor
 14276               		.comm	currentColor,1,1
 14277               		.local	littleCount
 14278               		.comm	littleCount,1,1
 14279               		.local	hueCount
 14280               		.comm	hueCount,2,1
 14281               		.local	currentHue
 14282               		.comm	currentHue,2,1
 14283               		.local	weeklyProgram
 14284               		.comm	weeklyProgram,100,1
 14285               		.local	tx_addr
 14286               		.comm	tx_addr,8,1
 14287               		.local	rx_addr_p0
 14288               		.comm	rx_addr_p0,8,1
 14289               		.local	rx_addr_p1
 14290               		.comm	rx_addr_p1,8,1
 14291               		.local	rx_addr_p2
 14292               		.comm	rx_addr_p2,8,1
 14293               		.local	rx_addr_p3
 14294               		.comm	rx_addr_p3,8,1
 14295               		.local	rx_addr_p4
 14296               		.comm	rx_addr_p4,8,1
 14297               		.local	rx_addr_p5
 14298               		.comm	rx_addr_p5,8,1
 14301               	tweakTimer:
 14302 001f 09        		.byte	9
 14303 0020 3D        		.byte	61
 14304 0021 00        		.byte	0
 14305 0022 00        		.byte	0
 14306               		.local	daylightSavings
 14307               		.comm	daylightSavings,8,1
 14308               		.local	timeLimits
 14309               		.comm	timeLimits,48,1
 14310               		.local	wasDaylightSavings
 14311               		.comm	wasDaylightSavings,1,1
 14312               		.local	failTimer
 14313               		.comm	failTimer,1,1
 14314               		.local	ticks
 14315               		.comm	ticks,2,1
 17174               	.Letext0:
 17175               		.file 3 "/usr/lib/gcc/avr/4.7.2/include/stddef.h"
 17176               		.file 4 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/stdint.h"
 17177               		.file 5 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/stdlib.h"
 17178               		.file 6 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/eeprom.h"
 17179               		.file 7 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/string.h"
 17180               		.file 8 "../myavrnrflib/nrf.h"
DEFINED SYMBOLS
                            *ABS*:00000000 switcherator.c
     /tmp/ccyXDZPf.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccyXDZPf.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccyXDZPf.s:4      *ABS*:0000003f __SREG__
     /tmp/ccyXDZPf.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccyXDZPf.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccyXDZPf.s:11     .text:00000000 drawInterface
     /tmp/ccyXDZPf.s:24     .text:00000002 getSwitchNumber
     /tmp/ccyXDZPf.s:14235  .data:00000009 tempIntString
     /tmp/ccyXDZPf.s:49     .text:00000018 getPort
     /tmp/ccyXDZPf.s:14197  .bss:0000009c switchStuff
     /tmp/ccyXDZPf.s:208    .text:000000bc pwmClear
     /tmp/ccyXDZPf.s:14259  .data:00000015 oldBright
     /tmp/ccyXDZPf.s:14253  .data:00000013 bright
     /tmp/ccyXDZPf.s:14207  .bss:000000de runHue
     /tmp/ccyXDZPf.s:14209  .bss:000000df runColorChanges
     /tmp/ccyXDZPf.s:257    .text:000000f8 clearTheSwitch
     /tmp/ccyXDZPf.s:413    .text:000001be runColorFunction
     /tmp/ccyXDZPf.s:14256  .bss:00000114 colorChangeCount
     /tmp/ccyXDZPf.s:14267  .data:0000001b colorChangeSpeed
     /tmp/ccyXDZPf.s:14274  .bss:00000116 currentColor
     /tmp/ccyXDZPf.s:14179  .bss:0000003c colorChanges
     /tmp/ccyXDZPf.s:14244  .bss:0000010d red
     /tmp/ccyXDZPf.s:14246  .bss:0000010f green
     /tmp/ccyXDZPf.s:14248  .bss:00000111 blue
     /tmp/ccyXDZPf.s:555    .text:000002ae runHueFunction
     /tmp/ccyXDZPf.s:14276  .bss:00000117 littleCount
     /tmp/ccyXDZPf.s:14278  .bss:00000118 hueCount
     /tmp/ccyXDZPf.s:14271  .data:0000001d hueSpeed
     /tmp/ccyXDZPf.s:14280  .bss:0000011a currentHue
     /tmp/ccyXDZPf.s:792    .text:00000492 clearTheProgram
     /tmp/ccyXDZPf.s:14282  .bss:0000011c weeklyProgram
     /tmp/ccyXDZPf.s:838    .text:000004be findOpenSwitch
     /tmp/ccyXDZPf.s:889    .text:000004f2 programGetSwitches
     /tmp/ccyXDZPf.s:973    .text:00000552 startTheProgram
     /tmp/ccyXDZPf.s:14232  .bss:00000106 weeklySeconds
     /tmp/ccyXDZPf.s:14195  .bss:0000005c switchStatus
     /tmp/ccyXDZPf.s:14205  .bss:000000dd switchChanged
     /tmp/ccyXDZPf.s:1148   .text:0000064e readEEPROM
     /tmp/ccyXDZPf.s:1238   .text:000006aa writeEEPROM
     /tmp/ccyXDZPf.s:1277   .text:000006ca clearEEPROM
     /tmp/ccyXDZPf.s:1294   .text:000006d2 clockInit
     /tmp/ccyXDZPf.s:1317   .text:000006ec startClock
     /tmp/ccyXDZPf.s:1340   .text:00000704 stopClock
     /tmp/ccyXDZPf.s:1358   .text:00000710 getWeekday
     /tmp/ccyXDZPf.s:14193  .bss:0000005a globalYear
     /tmp/ccyXDZPf.s:1469   .text:000007a4 getDayofYear
     /tmp/ccyXDZPf.s:1557   .text:0000080a checkDaylightSavings
     /tmp/ccyXDZPf.s:14309  .bss:000001f0 wasDaylightSavings
     /tmp/ccyXDZPf.s:14191  .bss:00000058 globalMonth
     /tmp/ccyXDZPf.s:14298  .bss:000001b8 daylightSavings
     /tmp/ccyXDZPf.s:14189  .bss:00000056 globalDay
     /tmp/ccyXDZPf.s:14187  .bss:00000054 globalHour
     /tmp/ccyXDZPf.s:1623   .text:0000088e advanceDay
     /tmp/ccyXDZPf.s:14181  .bss:0000004e dow
     /tmp/ccyXDZPf.s:1810   .text:000009da timerCheck
     /tmp/ccyXDZPf.s:2050   .text:00000b42 switchOnOff
     /tmp/ccyXDZPf.s:14242  .bss:0000010a pwmValues
     /tmp/ccyXDZPf.s:14199  .bss:000000ac switchBright
     /tmp/ccyXDZPf.s:2404   .text:00000d40 returnInt
     /tmp/ccyXDZPf.s:14239  .data:0000000c tempHugeString
     /tmp/ccyXDZPf.s:2468   .text:00000d7c clockString
     /tmp/ccyXDZPf.s:14230  .bss:000000e6 statusMsg
     /tmp/ccyXDZPf.s:14185  .bss:00000052 globalMinute
     /tmp/ccyXDZPf.s:14183  .bss:00000050 globalSecond
     /tmp/ccyXDZPf.s:2613   .text:00000e74 returnHex
     /tmp/ccyXDZPf.s:2692   .text:00000ed0 returnHexWithout
     /tmp/ccyXDZPf.s:2755   .text:00000f16 radioTest
     /tmp/ccyXDZPf.s:14286  .bss:00000188 rx_addr_p0
     /tmp/ccyXDZPf.s:14217  .data:00000000 failCondition
     /tmp/ccyXDZPf.s:2824   .text:00000f76 radioInit
     /tmp/ccyXDZPf.s:14284  .bss:00000180 tx_addr
     /tmp/ccyXDZPf.s:14288  .bss:00000190 rx_addr_p1
     /tmp/ccyXDZPf.s:14290  .bss:00000198 rx_addr_p2
     /tmp/ccyXDZPf.s:14292  .bss:000001a0 rx_addr_p3
     /tmp/ccyXDZPf.s:14294  .bss:000001a8 rx_addr_p4
     /tmp/ccyXDZPf.s:14296  .bss:000001b0 rx_addr_p5
     /tmp/ccyXDZPf.s:2986   .text:00001108 formatAddress
     /tmp/ccyXDZPf.s:3046   .text:00001142 generalInit
     /tmp/ccyXDZPf.s:14301  .data:0000001f tweakTimer
     /tmp/ccyXDZPf.s:14220  .bss:000000e2 serial
     /tmp/ccyXDZPf.s:14227  .data:00000002 stringSerial
     /tmp/ccyXDZPf.s:14201  .bss:000000bc inputs
     /tmp/ccyXDZPf.s:14307  .bss:000001c0 timeLimits
     /tmp/ccyXDZPf.s:14250  .bss:00000113 pwmdir
     /tmp/ccyXDZPf.s:3861   .text:000016a4 unformatAddress
     /tmp/ccyXDZPf.s:3909   .text:000016cc getInput
     /tmp/ccyXDZPf.s:4913   .text:00001cbc inputTenthCheck
     /tmp/ccyXDZPf.s:4973   .text:00001cfa inputCheck
     /tmp/ccyXDZPf.s:5052   .text:00001d5c flashFail
     /tmp/ccyXDZPf.s:14311  .bss:000001f1 failTimer
     /tmp/ccyXDZPf.s:5163   .text:00001dda clearFail
     /tmp/ccyXDZPf.s:5181   .text:00001de4 sendMessage
     /tmp/ccyXDZPf.s:5239   .text:00001e1e serialNumber
     /tmp/ccyXDZPf.s:5394   .text:00001edc radioChangeAddress
     /tmp/ccyXDZPf.s:14263  .data:00000016 tempLongString
     /tmp/ccyXDZPf.s:5846   .text:000021ec radioDisplayAddress
     /tmp/ccyXDZPf.s:6124   .text:000023da generalStatus
     /tmp/ccyXDZPf.s:14223  .data:00000001 panicMyClockIsNotSet
     /tmp/ccyXDZPf.s:6812   .text:000027f8 programDisplay
     /tmp/ccyXDZPf.s:7325   .text:00002ace pwmSummary
     /tmp/ccyXDZPf.s:7657   .text:00002ca4 switchDisplay
     /tmp/ccyXDZPf.s:7810   .text:00002d72 ok
     /tmp/ccyXDZPf.s:7826   .text:00002d7a clearInput
     /tmp/ccyXDZPf.s:7935   .text:00002df8 setDaylightSavings
     /tmp/ccyXDZPf.s:8042   .text:00002e8a clearToEEPROM
     /tmp/ccyXDZPf.s:8208   .text:00002f8a saveToEEPROM
     /tmp/ccyXDZPf.s:8896   .text:00003440 pwmValueSet
     /tmp/ccyXDZPf.s:9005   .text:000034d6 setHueSpeed
     /tmp/ccyXDZPf.s:9042   .text:000034fe cycleHue
     /tmp/ccyXDZPf.s:9085   .text:00003532 switchClear
     /tmp/ccyXDZPf.s:9110   .text:0000353e clockTweak
     /tmp/ccyXDZPf.s:9204   .text:000035d0 brightnessSet
     /tmp/ccyXDZPf.s:9309   .text:0000366e fail
     /tmp/ccyXDZPf.s:9360   .text:000036a6 setDigitalInput
     /tmp/ccyXDZPf.s:9760   .text:000038ae setAnalogInput
     /tmp/ccyXDZPf.s:10236  .text:00003b70 startProgram
     /tmp/ccyXDZPf.s:10332  .text:00003bea programSetTime
     /tmp/ccyXDZPf.s:10592  .text:00003d3a programSetDays
     /tmp/ccyXDZPf.s:10777  .text:00003e3c programAddSwitch
     /tmp/ccyXDZPf.s:11083  .text:00003fda clearProgram
     /tmp/ccyXDZPf.s:11161  .text:0000402c colorChangeSet
     /tmp/ccyXDZPf.s:11283  .text:000040d8 pwmSetup
     /tmp/ccyXDZPf.s:11448  .text:000041a6 startSwitch
     /tmp/ccyXDZPf.s:11777  .text:00004394 setNewSwitch
     /tmp/ccyXDZPf.s:12065  .text:000044f6 setTimeLimits
     /tmp/ccyXDZPf.s:12553  .text:000047e0 newProgram
     /tmp/ccyXDZPf.s:12825  .text:00004944 switchBrightness
     /tmp/ccyXDZPf.s:12970  .text:000049f8 setClock
     /tmp/ccyXDZPf.s:13213  .text:00004b9a checkCommand
     /tmp/ccyXDZPf.s:13560  .text.startup:00000000 main
                             .bss:00000000 receiveBuffer
     /tmp/ccyXDZPf.s:14177  .bss:0000001e radioReceiveBuffer
     /tmp/ccyXDZPf.s:14203  .bss:000000dc newSecond
     /tmp/ccyXDZPf.s:14211  .bss:000000e0 tenthFlag
     /tmp/ccyXDZPf.s:14213  .bss:000000e1 newMinute
     /tmp/ccyXDZPf.s:14011  .text:00004d78 __vector_11
     /tmp/ccyXDZPf.s:14313  .bss:000001f2 ticks

UNDEFINED SYMBOLS
atoi
__eerd_word_m328
__eerd_block_m328
__eeupd_block_m328
__eeupd_word_m328
__divmodhi4
__muluhisi3
itoa
strcat
readAddr
__cmpdi2
nrfInit
writeReg
writeAddr
startRadio
__ashldi3
atol
ltoa
__lshrdi3
__mulsi3
__umulhisi3
__divmodsi4
__udivmodsi4
transmit
startRx
strtol
__udivmodhi4
__cmpdi2_s8
__usmulhisi3
dynReceive
strcmp
strncmp
__do_copy_data
__do_clear_bss
