   1               		.file	"switcherator.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               	.global	drawInterface
  11               	drawInterface:
  12               	.LFB9:
  13               		.file 1 "switcherator.c"
   1:switcherator.c **** #ifndef __AVR_ATmega328__
   2:switcherator.c **** #define __AVR_ATmega328__
   3:switcherator.c **** #endif
   4:switcherator.c **** #ifndef F_CPU
   5:switcherator.c **** #define F_CPU 16000000
   6:switcherator.c **** #endif
   7:switcherator.c **** 
   8:switcherator.c **** 
   9:switcherator.c **** #include "switcherator.h"
  10:switcherator.c **** 
  11:switcherator.c **** // Uncomment if you want the print variables command available (costs 1K in program memory)
  12:switcherator.c **** // warning - probably way to big.
  13:switcherator.c **** //#define debug
  14:switcherator.c **** //#define help
  15:switcherator.c **** 
  16:switcherator.c **** // globals and such
  17:switcherator.c **** 
  18:switcherator.c **** // First time we are turned on and we have the wrong time
  19:switcherator.c **** static char panicMyClockIsNotSet = 1;
  20:switcherator.c **** 
  21:switcherator.c **** 
  22:switcherator.c **** // clock related
  23:switcherator.c **** static unsigned int ticks = 0; // ticks for the clock
  24:switcherator.c **** static unsigned int globalYear, globalMonth, globalDay, globalHour, globalMinute, globalSecond, dow
  25:switcherator.c **** // dow - Sunday = 0
  26:switcherator.c **** static unsigned long weeklySeconds = 0;
  27:switcherator.c **** // This is 1 on daylight savings day so I don't do it twice
  28:switcherator.c **** static char wasDaylightSavings = 0;
  29:switcherator.c **** static unsigned int daylightSavings[2][2]; // [0][0] = spring month, [0][1] = spring day, etc...
  30:switcherator.c **** 
  31:switcherator.c **** // flags
  32:switcherator.c **** static char newSecond = 0;
  33:switcherator.c **** static char newMinute = 0;
  34:switcherator.c **** static char switchChanged = 0;
  35:switcherator.c **** static char tenthFlag = 0; // 10th of a second(ish) has passed
  36:switcherator.c **** static char failCondition = 3;
  37:switcherator.c **** static char failTimer = 0;
  38:switcherator.c **** #define INDICATOR_PORT PORTD
  39:switcherator.c **** #define INDICATOR_PIN (1 << PIND2)
  40:switcherator.c **** #define INDICATOR_DDR DDRD
  41:switcherator.c **** 
  42:switcherator.c **** // When the switch will turn off (weekly seconds))
  43:switcherator.c **** static unsigned long switchStatus[NUM_SWITCHES];
  44:switcherator.c **** // Coded information for the switches
  45:switcherator.c **** // value of 255 (default) means nothing programmed
  46:switcherator.c **** // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
  47:switcherator.c **** // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
  48:switcherator.c **** // pin is abs(value/2)-the base - PINB3 = (22-16)/2  PINB3 (22-16)%2 = 0 - low (23-16)%2 = 1 - high
  49:switcherator.c **** // 200 = PWM, 201 = PWM rotating hue. PWM always uses PORTD3,PORTD5,PORTD6 for RGB
  50:switcherator.c **** // 202 = Color changing PWM
  51:switcherator.c **** // future - 202 - PWM with other ports. Can't on 328p since radio overlaps pwm pins
  52:switcherator.c **** static char switchStuff[NUM_SWITCHES];
  53:switcherator.c **** 
  54:switcherator.c **** 
  55:switcherator.c **** // strings
  56:switcherator.c **** static char receiveBuffer[30];
  57:switcherator.c **** static char radioReceiveBuffer[30];
  58:switcherator.c **** static char tempIntString[] = "00";
  59:switcherator.c **** static char tempLongString[] = "0000";
  60:switcherator.c **** static char tempHugeString[] = "000000";
  61:switcherator.c **** static char statusMsg[32];
  62:switcherator.c **** 
  63:switcherator.c **** // HardwarePWM
  64:switcherator.c **** static char runHue = 0;
  65:switcherator.c **** static char runColorChanges = 0;
  66:switcherator.c **** // PD3, PD5, PD6 or red,green,blue
  67:switcherator.c **** static char pwmValues[] = {0, 0, 0};
  68:switcherator.c **** static char colorChanges[NUM_COLOR_CHANGES][3];
  69:switcherator.c **** 
  70:switcherator.c **** 
  71:switcherator.c **** // rotating hue
  72:switcherator.c **** static unsigned int currentHue = 0;
  73:switcherator.c **** static unsigned int hueSpeed = 16;
  74:switcherator.c **** static unsigned int hueCount = 0;
  75:switcherator.c **** static unsigned char littleCount = 0;
  76:switcherator.c **** static unsigned int colorChangeSpeed = 10; // how many 1/10 seconds in each color change
  77:switcherator.c **** static unsigned int colorChangeCount = 0;
  78:switcherator.c **** static unsigned char currentColor = 0;
  79:switcherator.c **** #define Red OCR2B
  80:switcherator.c **** #define Green OCR0B
  81:switcherator.c **** #define Blue OCR0A
  82:switcherator.c **** static unsigned int red = 0;
  83:switcherator.c **** static unsigned int green = 0;
  84:switcherator.c **** static unsigned int blue = 0;
  85:switcherator.c **** static unsigned int bright = 16;
  86:switcherator.c **** static unsigned char oldBright = 16;
  87:switcherator.c **** static char switchBright[NUM_SWITCHES];
  88:switcherator.c **** static unsigned char pwmdir = 0;
  89:switcherator.c **** 
  90:switcherator.c **** 
  91:switcherator.c **** // programs and such kept in EEPROM
  92:switcherator.c **** // 1 byte day of week mask or 0 for everyday
  93:switcherator.c **** // 2 byte start time (seconds in day), 2 bytes duration (seconds), 1 byte additional program
  94:switcherator.c **** // If more than 4 switches are desired it will roll over to an additional program
  95:switcherator.c **** // DssddSSSSP
  96:switcherator.c **** // 0123456789   
  97:switcherator.c **** static unsigned char weeklyProgram[MAX_PROGRAM][10];
  98:switcherator.c **** 
  99:switcherator.c **** // input information
 100:switcherator.c **** // Pp - value of 255 (default) means nothing programmed
 101:switcherator.c **** // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
 102:switcherator.c **** // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
 103:switcherator.c **** // pin is abs(value/2)-the base - PINB3 = (22-16)/2  PINB3 (22-16)%2 = 0 - low (23-16)%2 = 1 - high
 104:switcherator.c **** // pLHsDDPw Pp int pin/port like sw, L%,H% (0,255 - digital), s - 0-127=switch, 128-255 = prog
 105:switcherator.c **** // dur in seconds, poll time in secs or  0 for continuous. w = which rgb (mask);)
 106:switcherator.c **** static unsigned char inputs[NUM_INPUTS][8];
 107:switcherator.c **** 
 108:switcherator.c **** // Times that the PROGRAMS will react to a switch (eg dusk to dawn)
 109:switcherator.c **** // [0]=start,[1]=stop,[2]=days
 110:switcherator.c **** static unsigned long timeLimits[NUM_LIMITS][3];
 111:switcherator.c **** 
 112:switcherator.c **** 
 113:switcherator.c **** // adjust the timer so it can be accurate
 114:switcherator.c **** static long tweakTimer = TIMER_TOTAL;
 115:switcherator.c **** 
 116:switcherator.c **** 
 117:switcherator.c **** 
 118:switcherator.c **** // send receive addresses
 119:switcherator.c **** static uint64_t rx_addr_p0, rx_addr_p1, rx_addr_p2, rx_addr_p3, rx_addr_p4, rx_addr_p5, tx_addr;
 120:switcherator.c **** 
 121:switcherator.c **** int main(void) {
 122:switcherator.c ****     receiveBuffer[0] = 0;
 123:switcherator.c ****     radioReceiveBuffer[0] = 0;
 124:switcherator.c ****     int x = 0;
 125:switcherator.c **** 
 126:switcherator.c ****     INDICATOR_DDR |= INDICATOR_PIN;
 127:switcherator.c ****     for (x = 0; x < 4; x++) {
 128:switcherator.c ****         INDICATOR_PORT |= INDICATOR_PIN;
 129:switcherator.c ****         _delay_ms(50);
 130:switcherator.c ****         INDICATOR_PORT &= ~(INDICATOR_PIN);
 131:switcherator.c ****         _delay_ms(100);
 132:switcherator.c ****     }
 133:switcherator.c ****     INDICATOR_PORT |= INDICATOR_PIN;
 134:switcherator.c **** 
 135:switcherator.c **** 
 136:switcherator.c ****     // set color changes to blank
 137:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 138:switcherator.c ****         colorChanges[x][0] = 0;
 139:switcherator.c ****         colorChanges[x][1] = 1;
 140:switcherator.c ****         colorChanges[x][2] = 0;
 141:switcherator.c ****     }
 142:switcherator.c **** 
 143:switcherator.c ****     // just initializing memory
 144:switcherator.c ****     globalYear = globalMonth = globalDay = globalHour = globalMinute = globalSecond = dow = 0;
 145:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 146:switcherator.c ****         switchStatus[x] = 0;
 147:switcherator.c ****         switchStuff[x] = 255;
 148:switcherator.c ****         switchBright[x] = 16;
 149:switcherator.c ****     }
 150:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 151:switcherator.c ****         inputs[x][0] = 255;
 152:switcherator.c ****     }
 153:switcherator.c ****     sei();
 154:switcherator.c **** 
 155:switcherator.c ****     // initialize programs
 156:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 157:switcherator.c ****         clearTheProgram(x);
 158:switcherator.c ****     }
 159:switcherator.c **** 
 160:switcherator.c **** 
 161:switcherator.c **** 
 162:switcherator.c ****     clockInit();
 163:switcherator.c ****     radioInit();
 164:switcherator.c ****     startRx();
 165:switcherator.c ****     // make sure general init is after radioinit
 166:switcherator.c ****     generalInit();
 167:switcherator.c ****     startClock();
 168:switcherator.c **** 
 169:switcherator.c **** 
 170:switcherator.c **** 
 171:switcherator.c ****     // radio related
 172:switcherator.c ****     int payloadLength = 0;
 173:switcherator.c **** 
 174:switcherator.c ****     
 175:switcherator.c **** 
 176:switcherator.c ****     while (1) {
 177:switcherator.c ****         // what to run every second
 178:switcherator.c ****         if (newSecond == 1) {
 179:switcherator.c ****             newSecond = 0;
 180:switcherator.c ****             timerCheck();
 181:switcherator.c ****             inputCheck();
 182:switcherator.c ****         }
 183:switcherator.c ****         // runs only if a switch changed
 184:switcherator.c ****         if (switchChanged == 1) {
 185:switcherator.c ****             switchChanged = 0;
 186:switcherator.c ****             switchOnOff();
 187:switcherator.c ****         }
 188:switcherator.c ****         if (runHue == 1) {
 189:switcherator.c ****             runHueFunction();
 190:switcherator.c ****         }
 191:switcherator.c ****         if (runColorChanges == 1) {
 192:switcherator.c ****             runColorFunction();
 193:switcherator.c ****         }
 194:switcherator.c ****         if (tenthFlag == 1) {
 195:switcherator.c ****             tenthFlag = 0;
 196:switcherator.c ****             inputTenthCheck();
 197:switcherator.c ****             if (failCondition > 0) {
 198:switcherator.c ****                 flashFail();
 199:switcherator.c ****             }
 200:switcherator.c ****             if (runColorChanges == 1) {
 201:switcherator.c ****                 runColorFunction();
 202:switcherator.c ****             }
 203:switcherator.c ****         }
 204:switcherator.c ****         if (newMinute == 1) {
 205:switcherator.c ****             newMinute = 0;
 206:switcherator.c ****             if (panicMyClockIsNotSet == 1) {
 207:switcherator.c ****                 generalStatus("gsq");
 208:switcherator.c ****             }
 209:switcherator.c ****             radioTest();
 210:switcherator.c ****         }
 211:switcherator.c ****         // check for radio instructions
 212:switcherator.c ****         payloadLength = dynReceive(radioReceiveBuffer);
 213:switcherator.c ****         if (payloadLength > 1) {
 214:switcherator.c ****             // wait so the receiver won't miss our response
 215:switcherator.c ****             _delay_ms(90);
 216:switcherator.c ****             checkCommand(radioReceiveBuffer);
 217:switcherator.c ****             
 218:switcherator.c ****             // clear the buffer
 219:switcherator.c ****             for (x = 0; x < 30; x++) {
 220:switcherator.c ****                 radioReceiveBuffer[x] = 0;
 221:switcherator.c ****                 receiveBuffer[x] = 0;
 222:switcherator.c ****             }
 223:switcherator.c ****         }
 224:switcherator.c ****     }
 225:switcherator.c **** }
 226:switcherator.c **** 
 227:switcherator.c **** /****************************************************************
 228:switcherator.c ****  *
 229:switcherator.c ****  *              All Things Command and Interface Related
 230:switcherator.c ****  *
 231:switcherator.c ****  ****************************************************************/
 232:switcherator.c **** 
 233:switcherator.c **** void checkCommand(char * commandReceived) {
 234:switcherator.c ****     if (commandReceived[0] > 0x60)
 235:switcherator.c ****         commandReceived[0] -= 0x20;
 236:switcherator.c ****     if (commandReceived[1] > 0x60)
 237:switcherator.c ****         commandReceived[1] -= 0x20;
 238:switcherator.c ****     int switchme = commandReceived[0];
 239:switcherator.c ****     switchme <<= 8;
 240:switcherator.c ****     switchme |= commandReceived[1];
 241:switcherator.c ****     switch (switchme) {
 242:switcherator.c ****         case 0x5449: //TI
 243:switcherator.c ****             setClock(commandReceived);
 244:switcherator.c ****             break;
 245:switcherator.c ****         case 0x4453: //DS
 246:switcherator.c ****             setDaylightSavings(commandReceived);
 247:switcherator.c ****             break;
 248:switcherator.c ****         case 0x544C: //TL
 249:switcherator.c ****             setTimeLimits(commandReceived);
 250:switcherator.c ****             break;
 251:switcherator.c ****         case 0x4E53: //NS
 252:switcherator.c ****             setNewSwitch(commandReceived);
 253:switcherator.c ****             break;
 254:switcherator.c ****         case 0x5343: //SC
 255:switcherator.c ****             switchClear(commandReceived);
 256:switcherator.c ****             break;
 257:switcherator.c ****         case 0x5344: //SD
 258:switcherator.c ****             switchDisplay(commandReceived);
 259:switcherator.c ****             break;
 260:switcherator.c ****         case 0x5053: //PS
 261:switcherator.c ****             pwmSetup(commandReceived);
 262:switcherator.c ****             break;
 263:switcherator.c ****         case 0x4348: //CH
 264:switcherator.c ****             cycleHue(commandReceived);
 265:switcherator.c ****             break;
 266:switcherator.c ****         case 0x4864: //HS
 267:switcherator.c ****             setHueSpeed(commandReceived);
 268:switcherator.c ****             break;
 269:switcherator.c ****         case 0x5056: //PV
 270:switcherator.c ****             pwmValueSet(commandReceived);
 271:switcherator.c ****             break;
 272:switcherator.c ****         case 0x4E50: //NP
 273:switcherator.c ****             newProgram(commandReceived);
 274:switcherator.c ****             break;
 275:switcherator.c ****         case 0x4350: //CP
 276:switcherator.c ****             clearProgram(commandReceived);
 277:switcherator.c ****             break;
 278:switcherator.c ****         case 0x5041: //PA
 279:switcherator.c ****             programAddSwitch(commandReceived);
 280:switcherator.c ****             break;
 281:switcherator.c ****         case 0x5044: //PD
 282:switcherator.c ****             programSetDays(commandReceived);
 283:switcherator.c ****             break;
 284:switcherator.c ****         case 0x5054: //PT
 285:switcherator.c ****             programSetTime(commandReceived);
 286:switcherator.c ****             break;
 287:switcherator.c ****         case 0x5049: //PI
 288:switcherator.c ****             programDisplay(commandReceived);
 289:switcherator.c ****             break;
 290:switcherator.c ****         case 0x5353: //SS
 291:switcherator.c ****             startSwitch(commandReceived);
 292:switcherator.c ****             break;
 293:switcherator.c ****         case 0x5350: //SP
 294:switcherator.c ****             startProgram(commandReceived);
 295:switcherator.c ****             break;
 296:switcherator.c ****         case 0x5341: //SA
 297:switcherator.c ****             saveToEEPROM();
 298:switcherator.c ****             break;
 299:switcherator.c ****         case 0x434C: //CL
 300:switcherator.c ****             clearToEEPROM();
 301:switcherator.c ****             break;
 302:switcherator.c ****         case 0x5244: //RD
 303:switcherator.c ****             radioDisplayAddress(commandReceived);
 304:switcherator.c ****             break;
 305:switcherator.c ****         case 0x5243: //RC
 306:switcherator.c ****             radioChangeAddress(commandReceived);
 307:switcherator.c ****             break;
 308:switcherator.c ****         case 0x4149: //AI
 309:switcherator.c ****             setAnalogInput(commandReceived);
 310:switcherator.c ****             break;
 311:switcherator.c ****         case 0x4449: //DI
 312:switcherator.c ****             setDigitalInput(commandReceived);
 313:switcherator.c ****             break;
 314:switcherator.c ****         case 0x4349: //CI
 315:switcherator.c ****             clearInput(commandReceived);
 316:switcherator.c ****             break;
 317:switcherator.c ****         case 0x4354: //CT
 318:switcherator.c ****             clockTweak(commandReceived);
 319:switcherator.c ****             break;
 320:switcherator.c ****         case 0x5057: //PW
 321:switcherator.c ****             pwmSummary();
 322:switcherator.c ****             break;
 323:switcherator.c ****         case 0x4845: //HE
 324:switcherator.c ****             drawInterface();
 325:switcherator.c ****             break;
 326:switcherator.c ****         case 0x4753: //GS
 327:switcherator.c ****             generalStatus(commandReceived);
 328:switcherator.c ****             break;
 329:switcherator.c ****         case 0x5248: //RH
 330:switcherator.c ****             drawInterface();
 331:switcherator.c ****             break;
 332:switcherator.c ****         case 0x4343: //CC
 333:switcherator.c ****             colorChangeSet(commandReceived);
 334:switcherator.c ****             break;
 335:switcherator.c ****         case 0x5342: //sb
 336:switcherator.c ****             switchBrightness(commandReceived);
 337:switcherator.c ****             break;
 338:switcherator.c ****         case 0x4253: //bs
 339:switcherator.c ****             brightnessSet(commandReceived);
 340:switcherator.c ****             break;
 341:switcherator.c ****         case 0x4749: //GI
 342:switcherator.c ****             generalInformation();
 343:switcherator.c ****             break;
 344:switcherator.c ****         case 0x5050: //PP
 345:switcherator.c ****             programsProgrammed();
 346:switcherator.c ****             break;
 347:switcherator.c ****         case 0x5357: //SW
 348:switcherator.c ****             switchesProgrammed();
 349:switcherator.c ****             break;
 350:switcherator.c ****         case 0x4950: //IP
 351:switcherator.c ****             inputsProgrammed();
 352:switcherator.c ****             break;
 353:switcherator.c ****         case 0x534F: //SO
 354:switcherator.c ****             switchesOn();
 355:switcherator.c ****             break;
 356:switcherator.c ****         default:
 357:switcherator.c ****             break;
 358:switcherator.c ****     }
 359:switcherator.c **** }
 360:switcherator.c **** 
 361:switcherator.c **** void drawInterface(void) {
  14               		.loc 1 361 0
  15               	/* prologue: function */
  16               	/* frame size = 0 */
  17               	/* stack size = 0 */
  18               	.L__stack_usage = 0
  19 0000 0895      		ret
  20               	.LFE9:
  22               	.global	getSwitchNumber
  24               	getSwitchNumber:
  25               	.LFB12:
 362:switcherator.c **** #ifdef help
 363:switcherator.c ****     sendMessage("TI:MMDDYYYYHHMMSS");
 364:switcherator.c ****     sendMessage("DS:MMDD MMDD");
 365:switcherator.c ****     sendMessage("TL:##HHMMHHMMdddddd");
 366:switcherator.c ****     sendMessage("NS:S#PpD,SC:S# SD NP:HHMMDur.");
 367:switcherator.c ****     sendMessage("CP:P# PA:P#S# PD:P#SMTWTFS");
 368:switcherator.c ****     sendMessage("PT:P#HHMMDur. PI:P#");
 369:switcherator.c ****     sendMessage("PS:P#S#DH CH:P#vvvv ");
 370:switcherator.c ****     sendMessage("PV:P#,vvv,vvv,vvv PW");
 371:switcherator.c ****     sendMessage("CC:##,vvv,vvv,vvv PW (sum)");
 372:switcherator.c ****     sendMessage("BS:16 SB S#16 HS:16");
 373:switcherator.c ****     sendMessage("SS S#Durat. SP P#Durat.");
 374:switcherator.c ****     sendMessage("SE nnnnnn SA CL CTvvv");
 375:switcherator.c ****     sendMessage("RD:N RC:N 0xnnnnnnnnnn");
 376:switcherator.c ****     sendMessage("AI:##PpLLLHHH?##DuraPO");
 377:switcherator.c ****     sendMessage("DI:##Ppx?##DuraPO  CI xx");
 378:switcherator.c ****     sendMessage("HE RH GS");
 379:switcherator.c **** #endif
 380:switcherator.c **** }
 381:switcherator.c **** 
 382:switcherator.c **** void fail(int failCode) {
 383:switcherator.c ****     statusMsg[0] = 0;
 384:switcherator.c ****     strcat(statusMsg, "fail 0x");
 385:switcherator.c ****     returnHex(failCode, tempIntString);
 386:switcherator.c ****     strcat(statusMsg, tempIntString);
 387:switcherator.c ****     sendMessage(statusMsg);
 388:switcherator.c **** }
 389:switcherator.c **** 
 390:switcherator.c **** void ok(void) {
 391:switcherator.c ****     sendMessage("ok");
 392:switcherator.c **** }
 393:switcherator.c **** 
 394:switcherator.c **** 
 395:switcherator.c **** // Helper function to get the switch number from char 3 and 4 of an array
 396:switcherator.c **** 
 397:switcherator.c **** int getSwitchNumber(char * commandReceived) {
  26               		.loc 1 397 0
  27               	.LVL0:
  28               	/* prologue: function */
  29               	/* frame size = 0 */
  30               	/* stack size = 0 */
  31               	.L__stack_usage = 0
 398:switcherator.c ****     int switchNumber = 0;
 399:switcherator.c ****     // get switch number
 400:switcherator.c ****     tempIntString[0] = commandReceived[3];
  32               		.loc 1 400 0
  33 0002 FC01      		movw r30,r24
  34 0004 2381      		ldd r18,Z+3
  35 0006 2093 0000 		sts tempIntString,r18
 401:switcherator.c ****     tempIntString[1] = commandReceived[4];
  36               		.loc 1 401 0
  37 000a 8481      		ldd r24,Z+4
  38               	.LVL1:
  39 000c 8093 0000 		sts tempIntString+1,r24
 402:switcherator.c ****     switchNumber = atoi(tempIntString);
  40               		.loc 1 402 0
  41 0010 80E0      		ldi r24,lo8(tempIntString)
  42 0012 90E0      		ldi r25,hi8(tempIntString)
  43 0014 0C94 0000 		jmp atoi
  44               	.LVL2:
  45               	.LFE12:
  47               	.global	getPort
  49               	getPort:
  50               	.LFB18:
 403:switcherator.c ****     return switchNumber;
 404:switcherator.c **** }
 405:switcherator.c **** 
 406:switcherator.c **** 
 407:switcherator.c **** /****************************************************************
 408:switcherator.c ****  *
 409:switcherator.c ****  *              All Things Switch Related
 410:switcherator.c ****  *
 411:switcherator.c ****  ****************************************************************/
 412:switcherator.c **** // Setup a new switch
 413:switcherator.c **** // NS:S#PpD
 414:switcherator.c **** // 01234567
 415:switcherator.c **** 
 416:switcherator.c **** void setNewSwitch(char * commandReceived) {
 417:switcherator.c ****     int switchNumber = 0;
 418:switcherator.c ****     char port = 0;
 419:switcherator.c ****     unsigned char pinMultiplied = 0;
 420:switcherator.c ****     unsigned char pinSubtractee = 0;
 421:switcherator.c ****     volatile unsigned char *realPort = 0;
 422:switcherator.c ****     volatile unsigned char *realDDR = 0;
 423:switcherator.c ****     char pin = 0;
 424:switcherator.c ****     char originalPin = 0;
 425:switcherator.c ****     char direction = 0;
 426:switcherator.c ****     tempIntString[0] = '0';
 427:switcherator.c ****     tempIntString[1] = commandReceived[6];
 428:switcherator.c ****     pin = atoi(tempIntString);
 429:switcherator.c ****     originalPin = pin;
 430:switcherator.c ****     tempIntString[1] = commandReceived[7];
 431:switcherator.c ****     direction = atoi(tempIntString);
 432:switcherator.c ****     port = commandReceived[5];
 433:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 434:switcherator.c ****     // make sure it is off before doing a new one.
 435:switcherator.c ****     clearTheSwitch(switchNumber);
 436:switcherator.c ****     // get the pin string ready for below
 437:switcherator.c ****     if (port == 'B' || port == 'b') {
 438:switcherator.c ****         realPort = &PORTB;
 439:switcherator.c ****         realDDR = &DDRB;
 440:switcherator.c ****         pinSubtractee = 16;
 441:switcherator.c **** #ifdef PORTA
 442:switcherator.c ****     } else if (port == 'A' || port == 'a') {
 443:switcherator.c ****         realPort = &PORTA;
 444:switcherator.c ****         realDDR = &DDRA;
 445:switcherator.c ****         pinSubtractee = 0;
 446:switcherator.c **** #endif
 447:switcherator.c **** #ifdef PORTC
 448:switcherator.c ****     } else if (port == 'C' || port == 'c') {
 449:switcherator.c ****         realPort = &PORTC;
 450:switcherator.c ****         realDDR = &DDRC;
 451:switcherator.c ****         pinSubtractee = 32;
 452:switcherator.c **** #endif
 453:switcherator.c **** #ifdef PORTD
 454:switcherator.c ****     } else if (port == 'D' || port == 'd') {
 455:switcherator.c ****         realPort = &PORTD;
 456:switcherator.c ****         realDDR = &DDRD;
 457:switcherator.c ****         pinSubtractee = 48;
 458:switcherator.c **** #endif
 459:switcherator.c **** #ifdef PORTE
 460:switcherator.c ****     } else if (port == 'E' || port == 'e') {
 461:switcherator.c ****         realPort = &PORTE;
 462:switcherator.c ****         realDDR = &DDRE;
 463:switcherator.c ****         pinSubtractee = 64;
 464:switcherator.c **** #endif
 465:switcherator.c **** #ifdef PORTF
 466:switcherator.c ****     } else if (port == 'F' || port == 'f') {
 467:switcherator.c ****         realPort = &PORTF;
 468:switcherator.c ****         realDDR = &DDRF;
 469:switcherator.c ****         pinSubtractee = 80;
 470:switcherator.c **** #endif
 471:switcherator.c **** #ifdef PORTG
 472:switcherator.c ****     } else if (port == 'G' || port == 'g') {
 473:switcherator.c ****         realPort = &PORTG;
 474:switcherator.c ****         realDDR = &DDRG;
 475:switcherator.c ****         pinSubtractee = 96;
 476:switcherator.c **** #endif
 477:switcherator.c **** #ifdef PORTH
 478:switcherator.c ****     } else if (port == 'H' || port == 'h') {
 479:switcherator.c ****         realPort = &PORTH;
 480:switcherator.c ****         realDDR = &DDRH;
 481:switcherator.c ****         pinSubtractee = 112;
 482:switcherator.c **** #endif
 483:switcherator.c **** #ifdef PORTI
 484:switcherator.c ****     } else if (port == 'I' || port == 'i') {
 485:switcherator.c ****         realPort = &PORTI;
 486:switcherator.c ****         realDDR = &DDRI;
 487:switcherator.c ****         pinSubtractee = 128;
 488:switcherator.c **** #endif
 489:switcherator.c **** 
 490:switcherator.c ****     }
 491:switcherator.c **** 
 492:switcherator.c **** 
 493:switcherator.c ****     if (realPort == 0) {
 494:switcherator.c ****         fail(2);
 495:switcherator.c ****     } else if ((switchNumber >= NUM_SWITCHES) ||
 496:switcherator.c ****             ((switchNumber == 0) && (commandReceived[3] != '0') && (commandReceived[4] != 0))) {
 497:switcherator.c ****         fail(1);
 498:switcherator.c ****     } else if ((pin > 7) || ((pin == 0) && (commandReceived[6] != '0'))) {
 499:switcherator.c ****         fail(4);
 500:switcherator.c ****     } else {
 501:switcherator.c ****         // set DDR out
 502:switcherator.c ****         *realDDR |= (1 << originalPin);
 503:switcherator.c ****         // double the pin and add 1 if it is high
 504:switcherator.c ****         pinMultiplied = pin * 2;
 505:switcherator.c ****         // turn switch off
 506:switcherator.c ****         pin = pinMultiplied + pinSubtractee;
 507:switcherator.c ****         switchStuff[switchNumber] = pin;
 508:switcherator.c **** 
 509:switcherator.c ****         if (direction == 0) {
 510:switcherator.c ****             // 0 = low is on  1 = high is on
 511:switcherator.c ****             *realPort |= (1 << originalPin);
 512:switcherator.c ****         } else {
 513:switcherator.c ****             *realPort &= ~(1 << originalPin);
 514:switcherator.c ****             switchStuff[switchNumber]++;
 515:switcherator.c ****         }
 516:switcherator.c ****         ok();
 517:switcherator.c ****     }
 518:switcherator.c **** }
 519:switcherator.c **** 
 520:switcherator.c **** // get rid of a switch and turn it off
 521:switcherator.c **** // SC:S#
 522:switcherator.c **** // 01234
 523:switcherator.c **** 
 524:switcherator.c **** void switchClear(char * commandReceived) {
 525:switcherator.c ****     int switchNumber = 0;
 526:switcherator.c ****     // get switch number
 527:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 528:switcherator.c ****     clearTheSwitch(switchNumber);
 529:switcherator.c ****     ok();
 530:switcherator.c **** }
 531:switcherator.c **** 
 532:switcherator.c **** // actual turning switch off (called with new switch as well)
 533:switcherator.c **** 
 534:switcherator.c **** void clearTheSwitch(int switchNumber) {
 535:switcherator.c ****     char port[] = {0};
 536:switcherator.c ****     char pin[] = {0};
 537:switcherator.c ****     char direction[] = {0};
 538:switcherator.c ****     volatile unsigned char *thisPort = 0;
 539:switcherator.c ****     volatile unsigned char *thisDDR = 0;
 540:switcherator.c ****     int realPin = 0;
 541:switcherator.c ****     // Figure out if it is pwm
 542:switcherator.c ****     if (switchStuff[switchNumber] >= 200 && switchStuff[switchNumber] <= 220) {
 543:switcherator.c ****         // if it is something else
 544:switcherator.c ****         pwmClear(switchNumber);
 545:switcherator.c ****         switchStuff[switchNumber] = 255;
 546:switcherator.c ****         return;
 547:switcherator.c ****     }
 548:switcherator.c ****     getPort(switchNumber, port, pin, direction);
 549:switcherator.c ****     if (port[0] == 'B') {
 550:switcherator.c ****         thisPort = &PORTB;
 551:switcherator.c ****         thisDDR = &DDRB;
 552:switcherator.c **** #ifdef PORTA
 553:switcherator.c ****     } else if (port[0] == 'A') {
 554:switcherator.c ****         thisPort = &PORTA;
 555:switcherator.c ****         thisDDR = &DDRA;
 556:switcherator.c **** #endif        
 557:switcherator.c **** #ifdef PORTC
 558:switcherator.c ****     } else if (port[0] == 'C') {
 559:switcherator.c ****         thisPort = &PORTC;
 560:switcherator.c ****         thisDDR = &DDRC;
 561:switcherator.c **** #endif        
 562:switcherator.c **** #ifdef PORTD
 563:switcherator.c ****     } else if (port[0] == 'D') {
 564:switcherator.c ****         thisPort = &PORTD;
 565:switcherator.c ****         thisDDR = &DDRD;
 566:switcherator.c **** #endif        
 567:switcherator.c **** #ifdef PORTE
 568:switcherator.c ****     } else if (port[0] == 'E') {
 569:switcherator.c ****         thisPort = &PORTE;
 570:switcherator.c ****         thisDDR = &DDRE;
 571:switcherator.c **** #endif        
 572:switcherator.c **** #ifdef PORTF
 573:switcherator.c ****     } else if (port[0] == 'F') {
 574:switcherator.c ****         thisPort = &PORTF;
 575:switcherator.c ****         thisDDR = &DDRF;
 576:switcherator.c **** #endif        
 577:switcherator.c **** #ifdef PORTG
 578:switcherator.c ****     } else if (port[0] == 'G') {
 579:switcherator.c ****         thisPort = &PORTG;
 580:switcherator.c ****         thisDDR = &DDRG;
 581:switcherator.c **** #endif        
 582:switcherator.c **** #ifdef PORTH
 583:switcherator.c ****     } else if (port[0] == 'H') {
 584:switcherator.c ****         thisPort = &PORTH;
 585:switcherator.c ****         thisDDR = &DDRH;
 586:switcherator.c **** #endif        
 587:switcherator.c **** #ifdef PORTI
 588:switcherator.c ****     } else if (port[0] == 'I') {
 589:switcherator.c ****         thisPort = &PORTI;
 590:switcherator.c ****         thisDDR = &DDRI;
 591:switcherator.c **** #endif        
 592:switcherator.c ****     }
 593:switcherator.c ****     realPin = pin[0];
 594:switcherator.c ****     *thisDDR &= ~(1 << realPin);
 595:switcherator.c ****     *thisPort &= ~(1 << realPin);
 596:switcherator.c ****     switchStuff[switchNumber] = 255;
 597:switcherator.c **** }
 598:switcherator.c **** 
 599:switcherator.c **** // show a summary of the switches
 600:switcherator.c **** 
 601:switcherator.c **** void switchDisplay(char * commandReceived) {
 602:switcherator.c ****     char port[] = {0};
 603:switcherator.c ****     char pin[] = {0};
 604:switcherator.c ****     char direction[] = {0};
 605:switcherator.c ****     int switchNumber = 0;
 606:switcherator.c ****     int realPin = 0;
 607:switcherator.c ****     char statusMsg[32];
 608:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 609:switcherator.c ****     statusMsg[0] = 0;
 610:switcherator.c ****     // see if this is a pwm switch
 611:switcherator.c ****     if (switchStuff[switchNumber] >= 200 && switchStuff[switchNumber] <= 220) {
 612:switcherator.c ****         // yes pwm
 613:switcherator.c ****         if (switchStuff[switchNumber] % 2 == 0) {
 614:switcherator.c ****             if (switchStuff[switchNumber] == 202) {
 615:switcherator.c ****                 strcat(statusMsg, "CoC");
 616:switcherator.c ****             } else if (switchStuff[switchNumber] == 212) {
 617:switcherator.c ****                 strcat(statusMsg, "Brt");
 618:switcherator.c ****             } else {
 619:switcherator.c ****                 strcat(statusMsg, "Fix");
 620:switcherator.c ****             }
 621:switcherator.c ****         } else {
 622:switcherator.c ****             strcat(statusMsg, "Hue");
 623:switcherator.c ****         }
 624:switcherator.c ****     } else {
 625:switcherator.c ****         getPort(switchNumber, port, pin, direction);
 626:switcherator.c ****         tempIntString[0] = port[0];
 627:switcherator.c ****         tempIntString[1] = 0;
 628:switcherator.c ****         strcat(statusMsg, tempIntString);
 629:switcherator.c ****         realPin = pin[0];
 630:switcherator.c ****         itoa(realPin, tempIntString, 10);
 631:switcherator.c ****         strcat(statusMsg, tempIntString);
 632:switcherator.c ****         if (direction[0] == 0) {
 633:switcherator.c ****             strcat(statusMsg, "L");
 634:switcherator.c ****         } else {
 635:switcherator.c ****             strcat(statusMsg, "H");
 636:switcherator.c ****         }
 637:switcherator.c ****     }
 638:switcherator.c ****     sendMessage(statusMsg);
 639:switcherator.c **** 
 640:switcherator.c **** }
 641:switcherator.c **** 
 642:switcherator.c **** // takes in a switch number and time and turns on the switch
 643:switcherator.c **** // SS S#Durat.
 644:switcherator.c **** // 01234567890
 645:switcherator.c **** 
 646:switcherator.c **** void startSwitch(char * commandReceived) {
 647:switcherator.c ****     unsigned long duration;
 648:switcherator.c ****     int switchNumber = 0;
 649:switcherator.c ****     // get switch number
 650:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 651:switcherator.c ****     if ((switchNumber >= NUM_SWITCHES) || (switchStuff[switchNumber] == 255)) {
 652:switcherator.c ****         fail(1);
 653:switcherator.c ****         return;
 654:switcherator.c ****     }
 655:switcherator.c ****     // get duration
 656:switcherator.c ****     tempHugeString[0] = commandReceived[5];
 657:switcherator.c ****     tempHugeString[1] = commandReceived[6];
 658:switcherator.c ****     tempHugeString[2] = commandReceived[7];
 659:switcherator.c ****     tempHugeString[3] = commandReceived[8];
 660:switcherator.c ****     tempHugeString[4] = commandReceived[9];
 661:switcherator.c ****     tempHugeString[5] = commandReceived[10];
 662:switcherator.c ****     duration = atol(tempHugeString);
 663:switcherator.c ****     if (duration == 0) {
 664:switcherator.c ****         fail(5);
 665:switcherator.c ****         return;
 666:switcherator.c ****     }
 667:switcherator.c ****     // only update the time if it is longer than what the switch is already turned on to
 668:switcherator.c ****     if ((weeklySeconds + duration) > switchStatus[switchNumber])
 669:switcherator.c ****         switchStatus[switchNumber] = (weeklySeconds + duration);
 670:switcherator.c **** 
 671:switcherator.c ****     // see if it is PWM
 672:switcherator.c ****     if (switchStuff[switchNumber] >= 200 && switchStuff[switchNumber] <= 220) {
 673:switcherator.c ****         // k it is PWM.  See if it is hue
 674:switcherator.c ****         if (switchStuff[switchNumber] == 200) {
 675:switcherator.c ****             // even number so values, not hue
 676:switcherator.c ****             red = pwmValues[0];
 677:switcherator.c ****             green = pwmValues[1];
 678:switcherator.c ****             blue = pwmValues[2];
 679:switcherator.c ****             red = red * bright / 16;
 680:switcherator.c ****             green = green * bright / 16;
 681:switcherator.c ****             blue = blue * bright / 16;
 682:switcherator.c ****             Red = red;
 683:switcherator.c ****             Green = green;
 684:switcherator.c ****             Blue = blue;
 685:switcherator.c ****         } else if (switchStuff[switchNumber] == 202) {
 686:switcherator.c ****             runColorChanges = 1;
 687:switcherator.c ****         } else if (switchStuff[switchNumber] == 212) {
 688:switcherator.c ****             bright = switchBright[switchNumber];
 689:switcherator.c ****         } else {
 690:switcherator.c ****             runHue = 1;
 691:switcherator.c ****         }
 692:switcherator.c **** 
 693:switcherator.c ****     } else {
 694:switcherator.c **** 
 695:switcherator.c ****         // get the port and turn it on
 696:switcherator.c ****         char port[1];
 697:switcherator.c ****         char pin[1];
 698:switcherator.c ****         int realPin = 0;
 699:switcherator.c ****         char direction[1];
 700:switcherator.c ****         volatile unsigned char *thisPort = 0;
 701:switcherator.c ****         getPort(switchNumber, port, pin, direction);
 702:switcherator.c ****         // yeah pointers and casts and whatevers. this fixes it
 703:switcherator.c ****         realPin = pin[0];
 704:switcherator.c ****         if (port[0] == 'B')
 705:switcherator.c ****             thisPort = &PORTB;
 706:switcherator.c **** #ifdef PORTA
 707:switcherator.c ****         else if (port[0] == 'A')
 708:switcherator.c ****             thisPort = &PORTA;
 709:switcherator.c **** #endif
 710:switcherator.c **** #ifdef PORTC
 711:switcherator.c ****         else if (port[0] == 'C')
 712:switcherator.c ****             thisPort = &PORTC;
 713:switcherator.c **** #endif
 714:switcherator.c **** #ifdef PORTD
 715:switcherator.c ****         else if (port[0] == 'D')
 716:switcherator.c ****             thisPort = &PORTD;
 717:switcherator.c **** #endif
 718:switcherator.c **** #ifdef PORTE
 719:switcherator.c ****         else if (port[0] == 'E')
 720:switcherator.c ****             thisPort = &PORTE;
 721:switcherator.c **** #endif
 722:switcherator.c **** #ifdef PORTF
 723:switcherator.c ****         else if (port[0] == 'F')
 724:switcherator.c ****             thisPort = &PORTF;
 725:switcherator.c **** #endif
 726:switcherator.c **** #ifdef PORTG
 727:switcherator.c ****         else if (port[0] == 'G')
 728:switcherator.c ****             thisPort = &PORTG;
 729:switcherator.c **** #endif
 730:switcherator.c **** #ifdef PORTH
 731:switcherator.c ****         else if (port[0] == 'H')
 732:switcherator.c ****             thisPort = &PORTH;
 733:switcherator.c **** #endif
 734:switcherator.c **** #ifdef PORTI
 735:switcherator.c ****         else if (port[0] == 'I')
 736:switcherator.c ****             thisPort = &PORTI;
 737:switcherator.c **** #endif
 738:switcherator.c **** 
 739:switcherator.c ****         // turn it on based on what direction
 740:switcherator.c ****         if (direction[0] == 0) {
 741:switcherator.c ****             *thisPort &= ~(1 << realPin);
 742:switcherator.c ****         } else {
 743:switcherator.c ****             *thisPort |= (1 << realPin);
 744:switcherator.c ****         }
 745:switcherator.c ****     }
 746:switcherator.c ****     ok();
 747:switcherator.c **** }
 748:switcherator.c **** // Takes in a switch number and returns the port (as a letter), pin, direction 0,1, and actual PORT
 749:switcherator.c **** 
 750:switcherator.c **** void getPort(int switchNumber, char * port, char * pin, char * direction) {
  51               		.loc 1 750 0
  52               	.LVL3:
  53               	/* prologue: function */
  54               	/* frame size = 0 */
  55               	/* stack size = 0 */
  56               	.L__stack_usage = 0
  57 0018 FB01      		movw r30,r22
 751:switcherator.c ****     char switchInfo = switchStuff[switchNumber];
  58               		.loc 1 751 0
  59 001a 8050      		subi r24,lo8(-(switchStuff))
  60 001c 9040      		sbci r25,hi8(-(switchStuff))
  61               	.LVL4:
  62 001e DC01      		movw r26,r24
  63 0020 8C91      		ld r24,X
  64               	.LVL5:
 752:switcherator.c ****     if ((switchInfo >= 16 && switchInfo < 32)) {
  65               		.loc 1 752 0
  66 0022 982F      		mov r25,r24
  67 0024 9051      		subi r25,lo8(-(-16))
  68 0026 9031      		cpi r25,lo8(16)
  69 0028 00F4      		brsh .L4
 753:switcherator.c ****         port[0] = 'B';
  70               		.loc 1 753 0
  71 002a 82E4      		ldi r24,lo8(66)
  72               	.LVL6:
  73 002c 8083      		st Z,r24
  74               	.LVL7:
  75 002e 00C0      		rjmp .L5
  76               	.LVL8:
  77               	.L4:
 754:switcherator.c ****         switchInfo -= 16;
 755:switcherator.c ****     } else if (switchInfo < 16) {
  78               		.loc 1 755 0
  79 0030 8031      		cpi r24,lo8(16)
  80 0032 00F4      		brsh .L6
 756:switcherator.c ****         port[0] = 'A';
  81               		.loc 1 756 0
  82 0034 91E4      		ldi r25,lo8(65)
  83 0036 9083      		st Z,r25
  84 0038 982F      		mov r25,r24
  85 003a 00C0      		rjmp .L5
  86               	.L6:
 757:switcherator.c ****         switchInfo -= 0;
 758:switcherator.c ****     } else if (switchInfo < 48) {
  87               		.loc 1 758 0
  88 003c 8033      		cpi r24,lo8(48)
  89 003e 00F4      		brsh .L7
 759:switcherator.c ****         port[0] = 'C';
  90               		.loc 1 759 0
  91 0040 93E4      		ldi r25,lo8(67)
  92 0042 9083      		st Z,r25
 760:switcherator.c ****         switchInfo -= 32;
  93               		.loc 1 760 0
  94 0044 982F      		mov r25,r24
  95 0046 9052      		subi r25,lo8(-(-32))
  96               	.LVL9:
  97 0048 00C0      		rjmp .L5
  98               	.LVL10:
  99               	.L7:
 761:switcherator.c ****     } else if (switchInfo < 64) {
 100               		.loc 1 761 0
 101 004a 8034      		cpi r24,lo8(64)
 102 004c 00F4      		brsh .L8
 762:switcherator.c ****         port[0] = 'D';
 103               		.loc 1 762 0
 104 004e 94E4      		ldi r25,lo8(68)
 105 0050 9083      		st Z,r25
 763:switcherator.c ****         switchInfo -= 48;
 106               		.loc 1 763 0
 107 0052 982F      		mov r25,r24
 108 0054 9053      		subi r25,lo8(-(-48))
 109               	.LVL11:
 110 0056 00C0      		rjmp .L5
 111               	.LVL12:
 112               	.L8:
 764:switcherator.c ****     } else if (switchInfo < 80) {
 113               		.loc 1 764 0
 114 0058 8035      		cpi r24,lo8(80)
 115 005a 00F4      		brsh .L9
 765:switcherator.c ****         port[0] = 'E';
 116               		.loc 1 765 0
 117 005c 95E4      		ldi r25,lo8(69)
 118 005e 9083      		st Z,r25
 766:switcherator.c ****         switchInfo -= 64;
 119               		.loc 1 766 0
 120 0060 982F      		mov r25,r24
 121 0062 9054      		subi r25,lo8(-(-64))
 122               	.LVL13:
 123 0064 00C0      		rjmp .L5
 124               	.LVL14:
 125               	.L9:
 767:switcherator.c ****     } else if (switchInfo < 96) {
 126               		.loc 1 767 0
 127 0066 8036      		cpi r24,lo8(96)
 128 0068 00F4      		brsh .L10
 768:switcherator.c ****         port[0] = 'F';
 129               		.loc 1 768 0
 130 006a 96E4      		ldi r25,lo8(70)
 131 006c 9083      		st Z,r25
 769:switcherator.c ****         switchInfo -= 80;
 132               		.loc 1 769 0
 133 006e 982F      		mov r25,r24
 134 0070 9055      		subi r25,lo8(-(-80))
 135               	.LVL15:
 136 0072 00C0      		rjmp .L5
 137               	.LVL16:
 138               	.L10:
 770:switcherator.c ****     } else if (switchInfo < 112) {
 139               		.loc 1 770 0
 140 0074 8037      		cpi r24,lo8(112)
 141 0076 00F4      		brsh .L11
 771:switcherator.c ****         port[0] = 'G';
 142               		.loc 1 771 0
 143 0078 97E4      		ldi r25,lo8(71)
 144 007a 9083      		st Z,r25
 772:switcherator.c ****         switchInfo -= 96;
 145               		.loc 1 772 0
 146 007c 982F      		mov r25,r24
 147 007e 9056      		subi r25,lo8(-(-96))
 148               	.LVL17:
 149 0080 00C0      		rjmp .L5
 150               	.LVL18:
 151               	.L11:
 773:switcherator.c ****     } else if (switchInfo < 128) {
 152               		.loc 1 773 0
 153 0082 87FD      		sbrc r24,7
 154 0084 00C0      		rjmp .L12
 774:switcherator.c ****         port[0] = 'H';
 155               		.loc 1 774 0
 156 0086 98E4      		ldi r25,lo8(72)
 157 0088 9083      		st Z,r25
 775:switcherator.c ****         switchInfo -= 112;
 158               		.loc 1 775 0
 159 008a 982F      		mov r25,r24
 160 008c 9057      		subi r25,lo8(-(-112))
 161               	.LVL19:
 162 008e 00C0      		rjmp .L5
 163               	.LVL20:
 164               	.L12:
 776:switcherator.c ****     } else if (switchInfo < 144) {
 165               		.loc 1 776 0
 166 0090 8039      		cpi r24,lo8(-112)
 167 0092 00F4      		brsh .L13
 777:switcherator.c ****         port[0] = 'I';
 168               		.loc 1 777 0
 169 0094 99E4      		ldi r25,lo8(73)
 170 0096 9083      		st Z,r25
 778:switcherator.c ****         switchInfo -= 128;
 171               		.loc 1 778 0
 172 0098 982F      		mov r25,r24
 173 009a 9058      		subi r25,lo8(-(-128))
 174               	.LVL21:
 175 009c 00C0      		rjmp .L5
 176               	.LVL22:
 177               	.L13:
 779:switcherator.c ****     } else {
 780:switcherator.c ****         port[0] = '?';
 178               		.loc 1 780 0
 179 009e 8FE3      		ldi r24,lo8(63)
 180               	.LVL23:
 181 00a0 8083      		st Z,r24
 781:switcherator.c ****         pin[0] = 0;
 182               		.loc 1 781 0
 183 00a2 FA01      		movw r30,r20
 184 00a4 1082      		st Z,__zero_reg__
 782:switcherator.c ****         direction[0] = 0;
 185               		.loc 1 782 0
 186 00a6 D901      		movw r26,r18
 187               	.LVL24:
 188 00a8 1C92      		st X,__zero_reg__
 783:switcherator.c ****         return;
 189               		.loc 1 783 0
 190 00aa 0895      		ret
 191               	.LVL25:
 192               	.L5:
 784:switcherator.c ****     }
 785:switcherator.c ****     pin[0] = switchInfo / 2;
 193               		.loc 1 785 0
 194 00ac 892F      		mov r24,r25
 195 00ae 8695      		lsr r24
 196 00b0 FA01      		movw r30,r20
 197 00b2 8083      		st Z,r24
 786:switcherator.c ****     direction[0] = switchInfo % 2;
 198               		.loc 1 786 0
 199 00b4 9170      		andi r25,lo8(1)
 200               	.LVL26:
 201 00b6 D901      		movw r26,r18
 202 00b8 9C93      		st X,r25
 203 00ba 0895      		ret
 204               	.LFE18:
 206               	.global	pwmClear
 208               	pwmClear:
 209               	.LFB21:
 787:switcherator.c **** }
 788:switcherator.c **** 
 789:switcherator.c **** // assign a secondary brightness to a switch
 790:switcherator.c **** // sb s#16
 791:switcherator.c **** 
 792:switcherator.c **** void switchBrightness(char * commandReceived) {
 793:switcherator.c ****     int switchNumber = getSwitchNumber(commandReceived);
 794:switcherator.c ****     char tempBright = 0;
 795:switcherator.c ****     if (switchNumber >= NUM_SWITCHES) {
 796:switcherator.c ****         fail(1);
 797:switcherator.c ****         return;
 798:switcherator.c ****     }
 799:switcherator.c ****     tempIntString[0] = commandReceived[5];
 800:switcherator.c ****     tempIntString[1] = commandReceived[6];
 801:switcherator.c ****     char brightValue = atoi(tempIntString);
 802:switcherator.c ****     if (brightValue == 0) {
 803:switcherator.c ****         tempBright = switchBright[switchNumber];
 804:switcherator.c ****         itoa(tempBright, tempIntString, 10);
 805:switcherator.c ****         statusMsg[0] = 0;
 806:switcherator.c ****         strcat(statusMsg, "Set @");
 807:switcherator.c ****         strcat(statusMsg, tempIntString);
 808:switcherator.c ****         sendMessage(statusMsg);
 809:switcherator.c ****     } else {
 810:switcherator.c ****         if (brightValue > 16)
 811:switcherator.c ****             brightValue = 16;
 812:switcherator.c ****         clearTheSwitch(switchNumber);
 813:switcherator.c ****         // value to indicate this is brightness
 814:switcherator.c ****         switchStuff[switchNumber] = 212;
 815:switcherator.c ****         switchBright[switchNumber] = brightValue;
 816:switcherator.c ****         ok();
 817:switcherator.c ****     }
 818:switcherator.c **** }
 819:switcherator.c **** 
 820:switcherator.c **** /****************************************************************
 821:switcherator.c ****  *
 822:switcherator.c ****  *              All Things PWM Related
 823:switcherator.c ****  *
 824:switcherator.c ****  ****************************************************************/
 825:switcherator.c **** 
 826:switcherator.c **** // PWM setup.  This is initially  geared for the 328p but the framework
 827:switcherator.c **** // exists for other chips
 828:switcherator.c **** // PS:P#S#DH
 829:switcherator.c **** // 012345678
 830:switcherator.c **** 
 831:switcherator.c **** void pwmSetup(char * commandReceived) {
 832:switcherator.c ****     int x = 0;
 833:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 834:switcherator.c ****         if (switchStuff[x] == 70 || switchStuff[x] == 71 || switchStuff[x] == 74 ||
 835:switcherator.c ****                 switchStuff[x] == 75 || switchStuff[x] == 76 || switchStuff[x] == 77) {
 836:switcherator.c ****             fail(6);
 837:switcherator.c ****             return;
 838:switcherator.c ****         }
 839:switcherator.c ****     }
 840:switcherator.c ****     int switchNumber = 0;
 841:switcherator.c ****     // get switch number
 842:switcherator.c ****     tempIntString[0] = commandReceived[5];
 843:switcherator.c ****     tempIntString[1] = commandReceived[6];
 844:switcherator.c ****     switchNumber = atoi(tempIntString);
 845:switcherator.c ****     clearTheSwitch(switchNumber);
 846:switcherator.c ****     // set up a hue pwm
 847:switcherator.c ****     if (commandReceived[8] == 'H' || commandReceived[8] == 'h' || commandReceived[8] == '1') {
 848:switcherator.c ****         switchStuff[switchNumber] = 201;
 849:switcherator.c ****     } else if (commandReceived[8] == 'C' || commandReceived[8] == 'c') {
 850:switcherator.c ****         switchStuff[switchNumber] = 202;
 851:switcherator.c ****     } else {
 852:switcherator.c ****         switchStuff[switchNumber] = 200;
 853:switcherator.c ****     }
 854:switcherator.c ****     DDRD |= (1 << PIND3) | (1 << PIND5) | (1 << PIND6);
 855:switcherator.c ****     // make sure initial values are 0
 856:switcherator.c ****     Red = 0;
 857:switcherator.c ****     Green = 0;
 858:switcherator.c ****     Blue = 0;
 859:switcherator.c ****     // Set output phase correct whatevers
 860:switcherator.c ****     // set it to inverted if the direction is 0
 861:switcherator.c ****     if (commandReceived[7] == '0') {
 862:switcherator.c ****         pwmdir = 0;
 863:switcherator.c ****         TCCR0A = (1 << COM0A0) | (1 << COM0A1) | (1 << COM0B0) | (1 << COM0B1) | (1 << WGM00);
 864:switcherator.c ****         TCCR2A = (1 << COM2B0) | (1 << COM2B1) | (1 << WGM20);
 865:switcherator.c ****     } else {
 866:switcherator.c ****         pwmdir = 1;
 867:switcherator.c ****         TCCR0A = (1 << COM0A1) | (1 << COM0B1) | (1 << WGM00);
 868:switcherator.c ****         TCCR2A = (1 << COM2B1) | (1 << WGM20);
 869:switcherator.c ****     }
 870:switcherator.c ****     // F_CPU/64 timers
 871:switcherator.c ****     TCCR0B = (1 << CS01) | (1 << CS00);
 872:switcherator.c **** 
 873:switcherator.c ****     TCCR2B = (1 << CS22); // F_CPU/64
 874:switcherator.c ****     // pwm to output
 875:switcherator.c ****     ok();
 876:switcherator.c **** }
 877:switcherator.c **** 
 878:switcherator.c **** // Turn off the PWM - called by clearing the switch
 879:switcherator.c **** 
 880:switcherator.c **** void pwmClear(int switchNumber) {
 210               		.loc 1 880 0
 211               	.LVL27:
 212               	/* prologue: function */
 213               	/* frame size = 0 */
 214               	/* stack size = 0 */
 215               	.L__stack_usage = 0
 881:switcherator.c ****     if (switchStuff[switchNumber] == 212) {
 216               		.loc 1 881 0
 217 00bc 8050      		subi r24,lo8(-(switchStuff))
 218 00be 9040      		sbci r25,hi8(-(switchStuff))
 219               	.LVL28:
 220 00c0 FC01      		movw r30,r24
 221 00c2 8081      		ld r24,Z
 222               	.LVL29:
 223 00c4 843D      		cpi r24,lo8(-44)
 224 00c6 01F4      		brne .L16
 882:switcherator.c ****         bright = oldBright;
 225               		.loc 1 882 0
 226 00c8 8091 0000 		lds r24,oldBright
 227 00cc 8093 0000 		sts bright,r24
 228 00d0 1092 0000 		sts bright+1,__zero_reg__
 229 00d4 0895      		ret
 230               	.L16:
 883:switcherator.c ****     } else {
 884:switcherator.c ****         TCCR0A = 0;
 231               		.loc 1 884 0
 232 00d6 14BC      		out 0x24,__zero_reg__
 885:switcherator.c ****         TCCR0B = 0;
 233               		.loc 1 885 0
 234 00d8 15BC      		out 0x25,__zero_reg__
 886:switcherator.c ****         TCCR2A = 0;
 235               		.loc 1 886 0
 236 00da 1092 B000 		sts 176,__zero_reg__
 887:switcherator.c ****         TCCR2B = 0;
 237               		.loc 1 887 0
 238 00de 1092 B100 		sts 177,__zero_reg__
 888:switcherator.c ****         Red = 0;
 239               		.loc 1 888 0
 240 00e2 1092 B400 		sts 180,__zero_reg__
 889:switcherator.c ****         Green = 0;
 241               		.loc 1 889 0
 242 00e6 18BC      		out 0x28,__zero_reg__
 890:switcherator.c ****         Blue = 0;
 243               		.loc 1 890 0
 244 00e8 17BC      		out 0x27,__zero_reg__
 891:switcherator.c ****         DDRD &= ~((1 << PIND3)&(1 << PIND5)&(1 << PIND6));
 245               		.loc 1 891 0
 246 00ea 8AB1      		in r24,0xa
 247 00ec 8AB9      		out 0xa,r24
 892:switcherator.c ****         runHue = 0;
 248               		.loc 1 892 0
 249 00ee 1092 0000 		sts runHue,__zero_reg__
 893:switcherator.c ****         runColorChanges = 0;
 250               		.loc 1 893 0
 251 00f2 1092 0000 		sts runColorChanges,__zero_reg__
 252 00f6 0895      		ret
 253               	.LFE21:
 255               	.global	clearTheSwitch
 257               	clearTheSwitch:
 258               	.LFB15:
 534:switcherator.c **** void clearTheSwitch(int switchNumber) {
 259               		.loc 1 534 0
 260               	.LVL30:
 261 00f8 EF92      		push r14
 262               	.LCFI0:
 263 00fa FF92      		push r15
 264               	.LCFI1:
 265 00fc 0F93      		push r16
 266               	.LCFI2:
 267 00fe 1F93      		push r17
 268               	.LCFI3:
 269 0100 CF93      		push r28
 270               	.LCFI4:
 271 0102 DF93      		push r29
 272               	.LCFI5:
 273 0104 00D0      		rcall .
 274 0106 1F92      		push __zero_reg__
 275               	.LCFI6:
 276 0108 CDB7      		in r28,__SP_L__
 277 010a DEB7      		in r29,__SP_H__
 278               	.LCFI7:
 279               	/* prologue: function */
 280               	/* frame size = 3 */
 281               	/* stack size = 9 */
 282               	.L__stack_usage = 9
 283 010c 8C01      		movw r16,r24
 535:switcherator.c ****     char port[] = {0};
 284               		.loc 1 535 0
 285 010e 1B82      		std Y+3,__zero_reg__
 536:switcherator.c ****     char pin[] = {0};
 286               		.loc 1 536 0
 287 0110 1A82      		std Y+2,__zero_reg__
 537:switcherator.c ****     char direction[] = {0};
 288               		.loc 1 537 0
 289 0112 1982      		std Y+1,__zero_reg__
 290               	.LVL31:
 542:switcherator.c ****     if (switchStuff[switchNumber] >= 200 && switchStuff[switchNumber] <= 220) {
 291               		.loc 1 542 0
 292 0114 80E0      		ldi r24,lo8(switchStuff)
 293 0116 E82E      		mov r14,r24
 294 0118 80E0      		ldi r24,hi8(switchStuff)
 295 011a F82E      		mov r15,r24
 296               	.LVL32:
 297 011c E00E      		add r14,r16
 298 011e F11E      		adc r15,r17
 299 0120 F701      		movw r30,r14
 300 0122 8081      		ld r24,Z
 301 0124 885C      		subi r24,lo8(-(56))
 302 0126 8531      		cpi r24,lo8(21)
 303 0128 00F4      		brsh .L19
 544:switcherator.c ****         pwmClear(switchNumber);
 304               		.loc 1 544 0
 305 012a C801      		movw r24,r16
 306 012c 0E94 0000 		call pwmClear
 307               	.LVL33:
 545:switcherator.c ****         switchStuff[switchNumber] = 255;
 308               		.loc 1 545 0
 309 0130 8FEF      		ldi r24,lo8(-1)
 310 0132 F701      		movw r30,r14
 311 0134 00C0      		rjmp .L25
 312               	.L19:
 548:switcherator.c ****     getPort(switchNumber, port, pin, direction);
 313               		.loc 1 548 0
 314 0136 9E01      		movw r18,r28
 315 0138 2F5F      		subi r18,-1
 316 013a 3F4F      		sbci r19,-1
 317 013c AE01      		movw r20,r28
 318 013e 4E5F      		subi r20,-2
 319 0140 5F4F      		sbci r21,-1
 320 0142 BE01      		movw r22,r28
 321 0144 6D5F      		subi r22,-3
 322 0146 7F4F      		sbci r23,-1
 323 0148 C801      		movw r24,r16
 324 014a 0E94 0000 		call getPort
 325               	.LVL34:
 549:switcherator.c ****     if (port[0] == 'B') {
 326               		.loc 1 549 0
 327 014e 8B81      		ldd r24,Y+3
 328 0150 8234      		cpi r24,lo8(66)
 329 0152 01F0      		breq .L22
 558:switcherator.c ****     } else if (port[0] == 'C') {
 330               		.loc 1 558 0
 331 0154 8334      		cpi r24,lo8(67)
 332 0156 01F0      		breq .L23
 563:switcherator.c ****     } else if (port[0] == 'D') {
 333               		.loc 1 563 0
 334 0158 8434      		cpi r24,lo8(68)
 335 015a 01F0      		breq .L24
 539:switcherator.c ****     volatile unsigned char *thisDDR = 0;
 336               		.loc 1 539 0
 337 015c A0E0      		ldi r26,0
 338 015e B0E0      		ldi r27,0
 538:switcherator.c ****     volatile unsigned char *thisPort = 0;
 339               		.loc 1 538 0
 340 0160 E0E0      		ldi r30,0
 341 0162 F0E0      		ldi r31,0
 342 0164 00C0      		rjmp .L21
 343               	.L22:
 551:switcherator.c ****         thisDDR = &DDRB;
 344               		.loc 1 551 0
 345 0166 A4E2      		ldi r26,lo8(36)
 346 0168 B0E0      		ldi r27,0
 550:switcherator.c ****         thisPort = &PORTB;
 347               		.loc 1 550 0
 348 016a E5E2      		ldi r30,lo8(37)
 349 016c F0E0      		ldi r31,0
 350 016e 00C0      		rjmp .L21
 351               	.L23:
 560:switcherator.c ****         thisDDR = &DDRC;
 352               		.loc 1 560 0
 353 0170 A7E2      		ldi r26,lo8(39)
 354 0172 B0E0      		ldi r27,0
 559:switcherator.c ****         thisPort = &PORTC;
 355               		.loc 1 559 0
 356 0174 E8E2      		ldi r30,lo8(40)
 357 0176 F0E0      		ldi r31,0
 358 0178 00C0      		rjmp .L21
 359               	.L24:
 565:switcherator.c ****         thisDDR = &DDRD;
 360               		.loc 1 565 0
 361 017a AAE2      		ldi r26,lo8(42)
 362 017c B0E0      		ldi r27,0
 564:switcherator.c ****         thisPort = &PORTD;
 363               		.loc 1 564 0
 364 017e EBE2      		ldi r30,lo8(43)
 365 0180 F0E0      		ldi r31,0
 366               	.L21:
 367               	.LVL35:
 594:switcherator.c ****     *thisDDR &= ~(1 << realPin);
 368               		.loc 1 594 0
 369 0182 2C91      		ld r18,X
 370 0184 81E0      		ldi r24,lo8(1)
 371 0186 90E0      		ldi r25,0
 372 0188 0A80      		ldd r0,Y+2
 373 018a 00C0      		rjmp 2f
 374               		1:
 375 018c 880F      		lsl r24
 376 018e 991F      		rol r25
 377               		2:
 378 0190 0A94      		dec r0
 379 0192 02F4      		brpl 1b
 380 0194 8095      		com r24
 381 0196 2823      		and r18,r24
 382 0198 2C93      		st X,r18
 595:switcherator.c ****     *thisPort &= ~(1 << realPin);
 383               		.loc 1 595 0
 384 019a 9081      		ld r25,Z
 385 019c 9823      		and r25,r24
 386 019e 9083      		st Z,r25
 596:switcherator.c ****     switchStuff[switchNumber] = 255;
 387               		.loc 1 596 0
 388 01a0 F801      		movw r30,r16
 389               	.LVL36:
 390 01a2 E050      		subi r30,lo8(-(switchStuff))
 391 01a4 F040      		sbci r31,hi8(-(switchStuff))
 392 01a6 8FEF      		ldi r24,lo8(-1)
 393               	.LVL37:
 394               	.L25:
 395 01a8 8083      		st Z,r24
 396               	/* epilogue start */
 597:switcherator.c **** }
 397               		.loc 1 597 0
 398 01aa 0F90      		pop __tmp_reg__
 399 01ac 0F90      		pop __tmp_reg__
 400 01ae 0F90      		pop __tmp_reg__
 401 01b0 DF91      		pop r29
 402 01b2 CF91      		pop r28
 403 01b4 1F91      		pop r17
 404 01b6 0F91      		pop r16
 405               	.LVL38:
 406 01b8 FF90      		pop r15
 407 01ba EF90      		pop r14
 408 01bc 0895      		ret
 409               	.LFE15:
 411               	.global	runColorFunction
 413               	runColorFunction:
 414               	.LFB27:
 894:switcherator.c ****     }
 895:switcherator.c **** }
 896:switcherator.c **** 
 897:switcherator.c **** // This just sets up the times for the PWM hues
 898:switcherator.c **** // CH:P#TTTTT 
 899:switcherator.c **** // 0123456789
 900:switcherator.c **** 
 901:switcherator.c **** void cycleHue(char * commandReceived) {
 902:switcherator.c ****     // right now we just have 1 pwm but I could add more
 903:switcherator.c ****     tempLongString[0] = commandReceived[5];
 904:switcherator.c ****     tempLongString[1] = commandReceived[6];
 905:switcherator.c ****     tempLongString[2] = commandReceived[7];
 906:switcherator.c ****     tempLongString[3] = commandReceived[8];
 907:switcherator.c ****     int programNumber = 0;
 908:switcherator.c ****     programNumber = atoi(tempLongString);
 909:switcherator.c ****     if (programNumber > 0)
 910:switcherator.c ****         colorChangeSpeed = programNumber;
 911:switcherator.c ****     ok();
 912:switcherator.c **** }
 913:switcherator.c **** 
 914:switcherator.c **** // Changes the hue speed
 915:switcherator.c **** // HS:xx
 916:switcherator.c **** 
 917:switcherator.c **** void setHueSpeed(char * commandReceived) {
 918:switcherator.c ****     tempIntString[0] = commandReceived[3];
 919:switcherator.c ****     tempIntString[1] = commandReceived[4];
 920:switcherator.c ****     int programNumber = 0;
 921:switcherator.c ****     programNumber = atoi(tempIntString);
 922:switcherator.c ****     if (programNumber > 0)
 923:switcherator.c ****         hueSpeed = programNumber;
 924:switcherator.c ****     ok();
 925:switcherator.c **** }
 926:switcherator.c **** 
 927:switcherator.c **** 
 928:switcherator.c **** // set up the values for a solid pwm
 929:switcherator.c **** // PV:P#,vvv,vvv,vvv
 930:switcherator.c **** // 01234567890123456
 931:switcherator.c **** 
 932:switcherator.c **** void pwmValueSet(char * commandReceived) {
 933:switcherator.c ****     tempLongString[3] = 0;
 934:switcherator.c ****     tempLongString[0] = commandReceived[6];
 935:switcherator.c ****     tempLongString[1] = commandReceived[7];
 936:switcherator.c ****     tempLongString[2] = commandReceived[8];
 937:switcherator.c ****     pwmValues[0] = atoi(tempLongString);
 938:switcherator.c ****     tempLongString[0] = commandReceived[10];
 939:switcherator.c ****     tempLongString[1] = commandReceived[11];
 940:switcherator.c ****     tempLongString[2] = commandReceived[12];
 941:switcherator.c ****     pwmValues[1] = atoi(tempLongString);
 942:switcherator.c ****     tempLongString[0] = commandReceived[14];
 943:switcherator.c ****     tempLongString[1] = commandReceived[15];
 944:switcherator.c ****     tempLongString[2] = commandReceived[16];
 945:switcherator.c ****     pwmValues[2] = atoi(tempLongString);
 946:switcherator.c ****     statusMsg[0] = 0;
 947:switcherator.c ****     ok();
 948:switcherator.c **** }
 949:switcherator.c **** 
 950:switcherator.c **** // add a color to the color change
 951:switcherator.c **** // CC:##,vvv,vvv,vvv
 952:switcherator.c **** // 01234567890123456
 953:switcherator.c **** 
 954:switcherator.c **** void colorChangeSet(char * commandReceived) {
 955:switcherator.c ****     int programNumber = getSwitchNumber(commandReceived);
 956:switcherator.c ****     if (programNumber >= NUM_COLOR_CHANGES) {
 957:switcherator.c ****         fail(7);
 958:switcherator.c ****         return;
 959:switcherator.c ****     }
 960:switcherator.c ****     tempLongString[3] = 0;
 961:switcherator.c ****     tempLongString[0] = commandReceived[6];
 962:switcherator.c ****     tempLongString[1] = commandReceived[7];
 963:switcherator.c ****     tempLongString[2] = commandReceived[8];
 964:switcherator.c ****     colorChanges[programNumber][0] = atoi(tempLongString);
 965:switcherator.c ****     tempLongString[0] = commandReceived[10];
 966:switcherator.c ****     tempLongString[1] = commandReceived[11];
 967:switcherator.c ****     tempLongString[2] = commandReceived[12];
 968:switcherator.c ****     colorChanges[programNumber][1] = atoi(tempLongString);
 969:switcherator.c ****     tempLongString[0] = commandReceived[14];
 970:switcherator.c ****     tempLongString[1] = commandReceived[15];
 971:switcherator.c ****     tempLongString[2] = commandReceived[16];
 972:switcherator.c ****     colorChanges[programNumber][2] = atoi(tempLongString);
 973:switcherator.c ****     ok();
 974:switcherator.c **** }
 975:switcherator.c **** 
 976:switcherator.c **** // show the pwm values & color change values
 977:switcherator.c **** 
 978:switcherator.c **** void pwmSummary(void) {
 979:switcherator.c ****     statusMsg[0] = 0;
 980:switcherator.c ****     strcat(statusMsg, "Val 0x");
 981:switcherator.c ****     int x = 0;
 982:switcherator.c ****     for (x = 0; x < 3; x++) {
 983:switcherator.c ****         if (x > 0)
 984:switcherator.c ****             strcat(statusMsg, ",");
 985:switcherator.c ****         returnHexWithout(pwmValues[x], tempLongString);
 986:switcherator.c ****         strcat(statusMsg, tempLongString);
 987:switcherator.c ****     }
 988:switcherator.c ****     strcat(statusMsg, " dir ");
 989:switcherator.c ****     returnInt(pwmdir, tempLongString);
 990:switcherator.c ****     strcat(statusMsg, tempLongString);
 991:switcherator.c ****     sendMessage(statusMsg);
 992:switcherator.c ****     statusMsg[0] = 0;
 993:switcherator.c ****     strcat(statusMsg, "Col Ch");
 994:switcherator.c ****     int y = 0;
 995:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 996:switcherator.c ****         if (x > 0)
 997:switcherator.c ****             strcat(statusMsg, ",");
 998:switcherator.c ****         strcat(statusMsg, "0x");
 999:switcherator.c ****         for (y = 0; y < 3; y++) {
1000:switcherator.c ****             returnHexWithout(colorChanges[x][y], tempLongString);
1001:switcherator.c ****             strcat(statusMsg, tempLongString);
1002:switcherator.c ****         }
1003:switcherator.c ****         if (strlen(statusMsg) > 25 && (x + 1) < NUM_COLOR_CHANGES) {
1004:switcherator.c ****             sendMessage(statusMsg);
1005:switcherator.c ****             statusMsg[6] = 0;
1006:switcherator.c ****         }
1007:switcherator.c ****     }
1008:switcherator.c ****     sendMessage(statusMsg);
1009:switcherator.c ****     statusMsg[0] = 0;
1010:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
1011:switcherator.c ****         if ((switchStuff[x] >= 200) && (switchStuff[x] <= 220)) {
1012:switcherator.c ****             strcat(statusMsg, "PWM ");
1013:switcherator.c ****             if (switchStuff[x] == 200) {
1014:switcherator.c ****                 strcat(statusMsg, "static");
1015:switcherator.c ****             } else if (switchStuff[x] == 202) {
1016:switcherator.c ****                 strcat(statusMsg, "ColCh");
1017:switcherator.c ****             } else {
1018:switcherator.c ****                 strcat(statusMsg, "hue");
1019:switcherator.c ****             }
1020:switcherator.c ****             strcat(statusMsg, "on sw# ");
1021:switcherator.c ****             returnInt(x, tempLongString);
1022:switcherator.c ****             strcat(statusMsg, tempLongString);
1023:switcherator.c ****             sendMessage(statusMsg);
1024:switcherator.c ****             statusMsg[0] = 0;
1025:switcherator.c ****         }
1026:switcherator.c ****     }
1027:switcherator.c **** }
1028:switcherator.c **** // HardwarePWM
1029:switcherator.c **** //static char runHue = 0;
1030:switcherator.c **** // PD3, PD5, PD6 or red,green,blue
1031:switcherator.c **** //static char pwmValues[] = {0 , 0 , 0};
1032:switcherator.c **** 
1033:switcherator.c **** // Run color function
1034:switcherator.c **** // goes through the colors and switches them.
1035:switcherator.c **** 
1036:switcherator.c **** void runColorFunction(void) {
 415               		.loc 1 1036 0
 416               	/* prologue: function */
 417               	/* frame size = 0 */
 418               	/* stack size = 0 */
 419               	.L__stack_usage = 0
1037:switcherator.c ****     // delay
1038:switcherator.c ****     colorChangeCount++;
 420               		.loc 1 1038 0
 421 01be 8091 0000 		lds r24,colorChangeCount
 422 01c2 9091 0000 		lds r25,colorChangeCount+1
 423 01c6 0196      		adiw r24,1
 424 01c8 9093 0000 		sts colorChangeCount+1,r25
 425 01cc 8093 0000 		sts colorChangeCount,r24
1039:switcherator.c ****     if (colorChangeCount < colorChangeSpeed)
 426               		.loc 1 1039 0
 427 01d0 2091 0000 		lds r18,colorChangeSpeed
 428 01d4 3091 0000 		lds r19,colorChangeSpeed+1
 429 01d8 8217      		cp r24,r18
 430 01da 9307      		cpc r25,r19
 431 01dc 00F4      		brsh .+2
 432 01de 00C0      		rjmp .L26
1040:switcherator.c ****         return;
1041:switcherator.c ****     colorChangeCount = 0;
 433               		.loc 1 1041 0
 434 01e0 1092 0000 		sts colorChangeCount+1,__zero_reg__
 435 01e4 1092 0000 		sts colorChangeCount,__zero_reg__
1042:switcherator.c ****     currentColor++;
 436               		.loc 1 1042 0
 437 01e8 8091 0000 		lds r24,currentColor
 438 01ec 8F5F      		subi r24,lo8(-(1))
1043:switcherator.c ****     if (currentColor == NUM_COLOR_CHANGES)
 439               		.loc 1 1043 0
 440 01ee 8630      		cpi r24,lo8(6)
 441 01f0 01F0      		breq .L29
1042:switcherator.c ****     currentColor++;
 442               		.loc 1 1042 0
 443 01f2 8093 0000 		sts currentColor,r24
 444 01f6 00C0      		rjmp .L30
 445               	.L29:
1044:switcherator.c ****         currentColor = 0;
 446               		.loc 1 1044 0
 447 01f8 1092 0000 		sts currentColor,__zero_reg__
 448               	.L30:
1045:switcherator.c ****     if (colorChanges[currentColor][0] == 0 &&
 449               		.loc 1 1045 0
 450 01fc 2091 0000 		lds r18,currentColor
 451 0200 822F      		mov r24,r18
 452 0202 90E0      		ldi r25,0
 453 0204 FC01      		movw r30,r24
 454 0206 EE0F      		lsl r30
 455 0208 FF1F      		rol r31
 456 020a E80F      		add r30,r24
 457 020c F91F      		adc r31,r25
 458 020e E050      		subi r30,lo8(-(colorChanges))
 459 0210 F040      		sbci r31,hi8(-(colorChanges))
 460 0212 8081      		ld r24,Z
 461 0214 8111      		cpse r24,__zero_reg__
 462 0216 00C0      		rjmp .L31
 463               		.loc 1 1045 0 is_stmt 0 discriminator 1
 464 0218 8181      		ldd r24,Z+1
 465 021a 8130      		cpi r24,lo8(1)
 466 021c 01F4      		brne .L31
1046:switcherator.c ****             colorChanges[currentColor][1] == 1 &&
 467               		.loc 1 1046 0 is_stmt 1
 468 021e 8281      		ldd r24,Z+2
 469 0220 8111      		cpse r24,__zero_reg__
 470 0222 00C0      		rjmp .L31
1047:switcherator.c ****             colorChanges[currentColor][2] == 0) {
1048:switcherator.c ****         // this one is blank.
1049:switcherator.c ****         if (currentColor == 0)
 471               		.loc 1 1049 0
 472 0224 2223      		tst r18
 473 0226 01F4      		brne .+2
 474 0228 00C0      		rjmp .L26
1050:switcherator.c ****             return;
1051:switcherator.c ****         currentColor = 0;
 475               		.loc 1 1051 0
 476 022a 1092 0000 		sts currentColor,__zero_reg__
 477               	.L31:
 478               	.LBB16:
 479               	.LBB17:
1052:switcherator.c ****     }
1053:switcherator.c ****     red = colorChanges[currentColor][0];
 480               		.loc 1 1053 0
 481 022e 8091 0000 		lds r24,currentColor
 482 0232 90E0      		ldi r25,0
1054:switcherator.c ****     green = colorChanges[currentColor][1];
 483               		.loc 1 1054 0
 484 0234 FC01      		movw r30,r24
 485 0236 EE0F      		lsl r30
 486 0238 FF1F      		rol r31
 487 023a E80F      		add r30,r24
 488 023c F91F      		adc r31,r25
 489 023e E050      		subi r30,lo8(-(colorChanges))
 490 0240 F040      		sbci r31,hi8(-(colorChanges))
 491 0242 8181      		ldd r24,Z+1
1055:switcherator.c ****     blue = colorChanges[currentColor][2];
 492               		.loc 1 1055 0
 493 0244 A281      		ldd r26,Z+2
1056:switcherator.c ****     red = red * bright / 16;
 494               		.loc 1 1056 0
 495 0246 6091 0000 		lds r22,bright
 496 024a 7091 0000 		lds r23,bright+1
1053:switcherator.c ****     red = colorChanges[currentColor][0];
 497               		.loc 1 1053 0
 498 024e 9081      		ld r25,Z
 499               		.loc 1 1056 0
 500 0250 969F      		mul r25,r22
 501 0252 A001      		movw r20,r0
 502 0254 979F      		mul r25,r23
 503 0256 500D      		add r21,r0
 504 0258 1124      		clr __zero_reg__
 505 025a 34E0      		ldi r19,4
 506               		1:
 507 025c 5695      		lsr r21
 508 025e 4795      		ror r20
 509 0260 3A95      		dec r19
 510 0262 01F4      		brne 1b
 511 0264 5093 0000 		sts red+1,r21
 512 0268 4093 0000 		sts red,r20
1057:switcherator.c ****     green = green * bright / 16;
 513               		.loc 1 1057 0
 514 026c 869F      		mul r24,r22
 515 026e 9001      		movw r18,r0
 516 0270 879F      		mul r24,r23
 517 0272 300D      		add r19,r0
 518 0274 1124      		clr __zero_reg__
 519 0276 54E0      		ldi r21,4
 520               		1:
 521 0278 3695      		lsr r19
 522 027a 2795      		ror r18
 523 027c 5A95      		dec r21
 524 027e 01F4      		brne 1b
 525 0280 3093 0000 		sts green+1,r19
 526 0284 2093 0000 		sts green,r18
1058:switcherator.c ****     blue = blue * bright / 16;
 527               		.loc 1 1058 0
 528 0288 A69F      		mul r26,r22
 529 028a C001      		movw r24,r0
 530 028c A79F      		mul r26,r23
 531 028e 900D      		add r25,r0
 532 0290 1124      		clr __zero_reg__
 533 0292 64E0      		ldi r22,4
 534               		1:
 535 0294 9695      		lsr r25
 536 0296 8795      		ror r24
 537 0298 6A95      		dec r22
 538 029a 01F4      		brne 1b
 539 029c 9093 0000 		sts blue+1,r25
 540 02a0 8093 0000 		sts blue,r24
1059:switcherator.c ****     Red = red;
 541               		.loc 1 1059 0
 542 02a4 4093 B400 		sts 180,r20
1060:switcherator.c ****     Green = green;
 543               		.loc 1 1060 0
 544 02a8 28BD      		out 0x28,r18
1061:switcherator.c ****     Blue = blue;
 545               		.loc 1 1061 0
 546 02aa 87BD      		out 0x27,r24
 547               	.L26:
 548 02ac 0895      		ret
 549               	.LBE17:
 550               	.LBE16:
 551               	.LFE27:
 553               	.global	runHueFunction
 555               	runHueFunction:
 556               	.LFB28:
1062:switcherator.c **** }
1063:switcherator.c **** // rotating hue
1064:switcherator.c **** //static int currentHue = 0;
1065:switcherator.c **** //static int hueSpeed = 0;
1066:switcherator.c **** //static char hueCount = 0;
1067:switcherator.c **** //#define Red OCR2B
1068:switcherator.c **** //#define Green OCR0B
1069:switcherator.c **** //#define Blue OCR0A
1070:switcherator.c **** 
1071:switcherator.c **** // go through and rotate the hue based color rotation
1072:switcherator.c **** // static int currentHue = 0;
1073:switcherator.c **** // static char hueSpeed = 0;
1074:switcherator.c **** // static char hueCount = 0;
1075:switcherator.c **** 
1076:switcherator.c **** void runHueFunction(void) {
 557               		.loc 1 1076 0
 558               	/* prologue: function */
 559               	/* frame size = 0 */
 560               	/* stack size = 0 */
 561               	.L__stack_usage = 0
1077:switcherator.c ****     // extra fixed delay
1078:switcherator.c ****     littleCount++;
 562               		.loc 1 1078 0
 563 02ae 8091 0000 		lds r24,littleCount
 564 02b2 8F5F      		subi r24,lo8(-(1))
 565 02b4 8093 0000 		sts littleCount,r24
1079:switcherator.c ****     if (littleCount != 2)
 566               		.loc 1 1079 0
 567 02b8 8230      		cpi r24,lo8(2)
 568 02ba 01F0      		breq .+2
 569 02bc 00C0      		rjmp .L36
1080:switcherator.c ****         return;
1081:switcherator.c ****     littleCount = 0;
 570               		.loc 1 1081 0
 571 02be 1092 0000 		sts littleCount,__zero_reg__
1082:switcherator.c ****     hueCount++;
 572               		.loc 1 1082 0
 573 02c2 8091 0000 		lds r24,hueCount
 574 02c6 9091 0000 		lds r25,hueCount+1
 575 02ca 0196      		adiw r24,1
 576 02cc 9093 0000 		sts hueCount+1,r25
 577 02d0 8093 0000 		sts hueCount,r24
1083:switcherator.c ****     // only run if the count is higher than the "speed"
1084:switcherator.c ****     if (hueCount < hueSpeed) {
 578               		.loc 1 1084 0
 579 02d4 2091 0000 		lds r18,hueSpeed
 580 02d8 3091 0000 		lds r19,hueSpeed+1
 581 02dc 8217      		cp r24,r18
 582 02de 9307      		cpc r25,r19
 583 02e0 00F4      		brsh .+2
 584 02e2 00C0      		rjmp .L36
1085:switcherator.c ****         return;
1086:switcherator.c ****     }
1087:switcherator.c ****     hueCount = 0;
 585               		.loc 1 1087 0
 586 02e4 1092 0000 		sts hueCount+1,__zero_reg__
 587 02e8 1092 0000 		sts hueCount,__zero_reg__
1088:switcherator.c ****     if (currentHue < 0x00ff) {
 588               		.loc 1 1088 0
 589 02ec 8091 0000 		lds r24,currentHue
 590 02f0 9091 0000 		lds r25,currentHue+1
 591 02f4 8F3F      		cpi r24,-1
 592 02f6 9105      		cpc r25,__zero_reg__
 593 02f8 00F4      		brsh .L40
1089:switcherator.c ****         red = 255;
 594               		.loc 1 1089 0
 595 02fa 2FEF      		ldi r18,lo8(-1)
 596 02fc 30E0      		ldi r19,0
 597 02fe 3093 0000 		sts red+1,r19
 598 0302 2093 0000 		sts red,r18
 599 0306 00C0      		rjmp .L47
 600               	.L40:
1090:switcherator.c ****         green = currentHue;
1091:switcherator.c ****         blue = 0;
1092:switcherator.c ****     } else if (currentHue < 0x01ff) {
 601               		.loc 1 1092 0
 602 0308 8F3F      		cpi r24,-1
 603 030a 21E0      		ldi r18,1
 604 030c 9207      		cpc r25,r18
 605 030e 00F4      		brsh .L42
1093:switcherator.c ****         red = 255 - (currentHue - 0xff);
 606               		.loc 1 1093 0
 607 0310 2EEF      		ldi r18,lo8(-2)
 608 0312 31E0      		ldi r19,lo8(1)
 609 0314 281B      		sub r18,r24
 610 0316 390B      		sbc r19,r25
 611 0318 3093 0000 		sts red+1,r19
 612 031c 2093 0000 		sts red,r18
1094:switcherator.c ****         green = 255;
 613               		.loc 1 1094 0
 614 0320 8FEF      		ldi r24,lo8(-1)
 615 0322 90E0      		ldi r25,0
 616               	.L47:
 617 0324 9093 0000 		sts green+1,r25
 618 0328 8093 0000 		sts green,r24
1095:switcherator.c ****         blue = 0;
 619               		.loc 1 1095 0
 620 032c 1092 0000 		sts blue+1,__zero_reg__
 621 0330 1092 0000 		sts blue,__zero_reg__
 622 0334 00C0      		rjmp .L41
 623               	.L42:
1096:switcherator.c ****     } else if (currentHue < 0x02ff) {
 624               		.loc 1 1096 0
 625 0336 8F3F      		cpi r24,-1
 626 0338 22E0      		ldi r18,2
 627 033a 9207      		cpc r25,r18
 628 033c 00F4      		brsh .L43
1097:switcherator.c ****         red = 0;
 629               		.loc 1 1097 0
 630 033e 1092 0000 		sts red+1,__zero_reg__
 631 0342 1092 0000 		sts red,__zero_reg__
1098:switcherator.c ****         green = 255;
 632               		.loc 1 1098 0
 633 0346 2FEF      		ldi r18,lo8(-1)
 634 0348 30E0      		ldi r19,0
 635 034a 3093 0000 		sts green+1,r19
 636 034e 2093 0000 		sts green,r18
1099:switcherator.c ****         blue = (currentHue - 0x1ff);
 637               		.loc 1 1099 0
 638 0352 8F5F      		subi r24,-1
 639 0354 9140      		sbci r25,1
 640 0356 00C0      		rjmp .L48
 641               	.L43:
1100:switcherator.c ****     } else if (currentHue < 0x03ff) {
 642               		.loc 1 1100 0
 643 0358 8F3F      		cpi r24,-1
 644 035a 23E0      		ldi r18,3
 645 035c 9207      		cpc r25,r18
 646 035e 00F4      		brsh .L44
1101:switcherator.c ****         red = 0;
 647               		.loc 1 1101 0
 648 0360 1092 0000 		sts red+1,__zero_reg__
 649 0364 1092 0000 		sts red,__zero_reg__
1102:switcherator.c ****         green = 255 - (currentHue - 0x2ff);
 650               		.loc 1 1102 0
 651 0368 2EEF      		ldi r18,lo8(-2)
 652 036a 33E0      		ldi r19,lo8(3)
 653 036c 281B      		sub r18,r24
 654 036e 390B      		sbc r19,r25
 655 0370 3093 0000 		sts green+1,r19
 656 0374 2093 0000 		sts green,r18
 657               	.L49:
1103:switcherator.c ****         blue = 255;
 658               		.loc 1 1103 0
 659 0378 8FEF      		ldi r24,lo8(-1)
 660 037a 90E0      		ldi r25,0
 661               	.L48:
 662 037c 9093 0000 		sts blue+1,r25
 663 0380 8093 0000 		sts blue,r24
 664 0384 00C0      		rjmp .L41
 665               	.L44:
1104:switcherator.c ****     } else if (currentHue < 0x04ff) {
 666               		.loc 1 1104 0
 667 0386 8F3F      		cpi r24,-1
 668 0388 24E0      		ldi r18,4
 669 038a 9207      		cpc r25,r18
 670 038c 00F4      		brsh .L45
1105:switcherator.c ****         red = (currentHue - 0x3ff);
 671               		.loc 1 1105 0
 672 038e 8F5F      		subi r24,-1
 673 0390 9340      		sbci r25,3
 674 0392 9093 0000 		sts red+1,r25
 675 0396 8093 0000 		sts red,r24
1106:switcherator.c ****         green = 0;
 676               		.loc 1 1106 0
 677 039a 1092 0000 		sts green+1,__zero_reg__
 678 039e 1092 0000 		sts green,__zero_reg__
 679 03a2 00C0      		rjmp .L49
 680               	.L45:
1107:switcherator.c ****         blue = 255;
1108:switcherator.c ****     } else if (currentHue < 0x05ff) {
 681               		.loc 1 1108 0
 682 03a4 8F3F      		cpi r24,-1
 683 03a6 25E0      		ldi r18,5
 684 03a8 9207      		cpc r25,r18
 685 03aa 00F4      		brsh .L46
1109:switcherator.c ****         red = 255;
 686               		.loc 1 1109 0
 687 03ac 2FEF      		ldi r18,lo8(-1)
 688 03ae 30E0      		ldi r19,0
 689 03b0 3093 0000 		sts red+1,r19
 690 03b4 2093 0000 		sts red,r18
1110:switcherator.c ****         green = 0;
 691               		.loc 1 1110 0
 692 03b8 1092 0000 		sts green+1,__zero_reg__
 693 03bc 1092 0000 		sts green,__zero_reg__
1111:switcherator.c ****         blue = 255 - (currentHue - 0x4ff);
 694               		.loc 1 1111 0
 695 03c0 2EEF      		ldi r18,lo8(-2)
 696 03c2 35E0      		ldi r19,lo8(5)
 697 03c4 281B      		sub r18,r24
 698 03c6 390B      		sbc r19,r25
 699 03c8 3093 0000 		sts blue+1,r19
 700 03cc 2093 0000 		sts blue,r18
 701 03d0 00C0      		rjmp .L41
 702               	.L46:
1112:switcherator.c ****     } else {
1113:switcherator.c ****         red = 255;
 703               		.loc 1 1113 0
 704 03d2 8FEF      		ldi r24,lo8(-1)
 705 03d4 90E0      		ldi r25,0
 706 03d6 9093 0000 		sts red+1,r25
 707 03da 8093 0000 		sts red,r24
1114:switcherator.c ****         green = 0;
 708               		.loc 1 1114 0
 709 03de 1092 0000 		sts green+1,__zero_reg__
 710 03e2 1092 0000 		sts green,__zero_reg__
1115:switcherator.c ****         blue = 0;
 711               		.loc 1 1115 0
 712 03e6 1092 0000 		sts blue+1,__zero_reg__
 713 03ea 1092 0000 		sts blue,__zero_reg__
1116:switcherator.c ****         currentHue = 0;
 714               		.loc 1 1116 0
 715 03ee 1092 0000 		sts currentHue+1,__zero_reg__
 716 03f2 1092 0000 		sts currentHue,__zero_reg__
 717               	.L41:
1117:switcherator.c ****     }
1118:switcherator.c ****     red = red * bright / 16;
 718               		.loc 1 1118 0
 719 03f6 6091 0000 		lds r22,bright
 720 03fa 7091 0000 		lds r23,bright+1
 721 03fe 8091 0000 		lds r24,red
 722 0402 9091 0000 		lds r25,red+1
 723 0406 689F      		mul r22,r24
 724 0408 A001      		movw r20,r0
 725 040a 699F      		mul r22,r25
 726 040c 500D      		add r21,r0
 727 040e 789F      		mul r23,r24
 728 0410 500D      		add r21,r0
 729 0412 1124      		clr r1
 730 0414 E4E0      		ldi r30,4
 731               		1:
 732 0416 5695      		lsr r21
 733 0418 4795      		ror r20
 734 041a EA95      		dec r30
 735 041c 01F4      		brne 1b
 736 041e 5093 0000 		sts red+1,r21
 737 0422 4093 0000 		sts red,r20
1119:switcherator.c ****     green = green * bright / 16;
 738               		.loc 1 1119 0
 739 0426 8091 0000 		lds r24,green
 740 042a 9091 0000 		lds r25,green+1
 741 042e 689F      		mul r22,r24
 742 0430 9001      		movw r18,r0
 743 0432 699F      		mul r22,r25
 744 0434 300D      		add r19,r0
 745 0436 789F      		mul r23,r24
 746 0438 300D      		add r19,r0
 747 043a 1124      		clr r1
 748 043c F4E0      		ldi r31,4
 749               		1:
 750 043e 3695      		lsr r19
 751 0440 2795      		ror r18
 752 0442 FA95      		dec r31
 753 0444 01F4      		brne 1b
 754 0446 3093 0000 		sts green+1,r19
 755 044a 2093 0000 		sts green,r18
1120:switcherator.c ****     blue = blue * bright / 16;
 756               		.loc 1 1120 0
 757 044e E091 0000 		lds r30,blue
 758 0452 F091 0000 		lds r31,blue+1
 759 0456 6E9F      		mul r22,r30
 760 0458 C001      		movw r24,r0
 761 045a 6F9F      		mul r22,r31
 762 045c 900D      		add r25,r0
 763 045e 7E9F      		mul r23,r30
 764 0460 900D      		add r25,r0
 765 0462 1124      		clr r1
 766 0464 A4E0      		ldi r26,4
 767               		1:
 768 0466 9695      		lsr r25
 769 0468 8795      		ror r24
 770 046a AA95      		dec r26
 771 046c 01F4      		brne 1b
 772 046e 9093 0000 		sts blue+1,r25
 773 0472 8093 0000 		sts blue,r24
1121:switcherator.c ****     Red = red;
 774               		.loc 1 1121 0
 775 0476 4093 B400 		sts 180,r20
1122:switcherator.c ****     Green = green;
 776               		.loc 1 1122 0
 777 047a 28BD      		out 0x28,r18
1123:switcherator.c ****     Blue = blue;
 778               		.loc 1 1123 0
 779 047c 87BD      		out 0x27,r24
1124:switcherator.c ****     currentHue++;
 780               		.loc 1 1124 0
 781 047e 8091 0000 		lds r24,currentHue
 782 0482 9091 0000 		lds r25,currentHue+1
 783 0486 0196      		adiw r24,1
 784 0488 9093 0000 		sts currentHue+1,r25
 785 048c 8093 0000 		sts currentHue,r24
 786               	.L36:
 787 0490 0895      		ret
 788               	.LFE28:
 790               	.global	clearTheProgram
 792               	clearTheProgram:
 793               	.LFB32:
1125:switcherator.c **** }
1126:switcherator.c **** 
1127:switcherator.c **** // sets the pwm brightness value
1128:switcherator.c **** // bs 16
1129:switcherator.c **** 
1130:switcherator.c **** void brightnessSet(char * commandReceived) {
1131:switcherator.c ****     int brightValue = getSwitchNumber(commandReceived);
1132:switcherator.c ****     if (brightValue == 0) {
1133:switcherator.c ****         // display the brightness
1134:switcherator.c ****         itoa(oldBright, tempIntString, 10);
1135:switcherator.c ****         statusMsg[0] = 0;
1136:switcherator.c ****         strcat(statusMsg, "Set @");
1137:switcherator.c ****         strcat(statusMsg, tempIntString);
1138:switcherator.c ****         strcat(statusMsg, "B@");
1139:switcherator.c ****         itoa(bright, tempIntString, 10);
1140:switcherator.c ****         strcat(statusMsg, tempIntString);
1141:switcherator.c ****         sendMessage(statusMsg);
1142:switcherator.c ****     } else {
1143:switcherator.c ****         if (brightValue > 16)
1144:switcherator.c ****             brightValue = 16;
1145:switcherator.c ****         if (oldBright == bright) {
1146:switcherator.c ****             // currently not being overridden
1147:switcherator.c ****             bright = brightValue;
1148:switcherator.c ****         }
1149:switcherator.c ****         oldBright = brightValue;
1150:switcherator.c ****         switchChanged = 1;
1151:switcherator.c ****         ok();
1152:switcherator.c ****     }
1153:switcherator.c **** }
1154:switcherator.c **** 
1155:switcherator.c **** 
1156:switcherator.c **** /****************************************************************
1157:switcherator.c ****  *
1158:switcherator.c ****  *              All Things Program Related
1159:switcherator.c ****  *
1160:switcherator.c ****  ****************************************************************/
1161:switcherator.c **** 
1162:switcherator.c **** // programs and such kept in EEPROM
1163:switcherator.c **** // 1 byte day of week mask or 0 for everyday
1164:switcherator.c **** // 2 byte start time (minutes), 2 bytes duration (seconds), 1 byte additional program
1165:switcherator.c **** // If more than 4 switches are desired it will roll over to an additional program
1166:switcherator.c **** // DssddSSSSP
1167:switcherator.c **** // 0123456789   
1168:switcherator.c **** //static unsigned char weeklyProgram[MAX_PROGRAM][10];
1169:switcherator.c **** //uart_puts_P("NewProgram, ClearProg, ProgAddSwitch, ProgDays, ProgTime, ProgDispln PN\r\n");
1170:switcherator.c **** //uart_puts_P("NP:P#HHMMDur. - CP:P# - PA:P#S# PD:P#SMTWTFS-PT:P#HHMMDur. PI:P#\r\n");
1171:switcherator.c **** //uart_puts_P("P#=Prog Num,HH=Hour,MM=Min,Dur.=Duration(min) SMTWTFS=1010000=Sun/Tue\r\n");
1172:switcherator.c **** 
1173:switcherator.c **** // Create a new program
1174:switcherator.c **** // NP:HHMMDur.
1175:switcherator.c **** // 0123456789012
1176:switcherator.c **** 
1177:switcherator.c **** void newProgram(char * commandReceived) {
1178:switcherator.c ****     int programNumber = 255;
1179:switcherator.c ****     int hours = 0;
1180:switcherator.c ****     int minutes = 0;
1181:switcherator.c ****     int startTime = 0;
1182:switcherator.c ****     int duration = 0;
1183:switcherator.c ****     int x = 0;
1184:switcherator.c ****     // find an open program;
1185:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
1186:switcherator.c ****         // dont want it to wrap though 0 is a valid program
1187:switcherator.c ****         if (weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) {
1188:switcherator.c ****             // Use this one
1189:switcherator.c ****             programNumber = x;
1190:switcherator.c ****             // end the loop
1191:switcherator.c ****             break;
1192:switcherator.c ****         }
1193:switcherator.c ****     }
1194:switcherator.c ****     if (programNumber == 255) {
1195:switcherator.c ****         fail(8);
1196:switcherator.c ****         return;
1197:switcherator.c ****     }
1198:switcherator.c ****     clearTheProgram(programNumber);
1199:switcherator.c ****     tempIntString[0] = commandReceived[3];
1200:switcherator.c ****     tempIntString[1] = commandReceived[4];
1201:switcherator.c ****     hours = atoi(tempIntString);
1202:switcherator.c ****     tempIntString[0] = commandReceived[5];
1203:switcherator.c ****     tempIntString[1] = commandReceived[6];
1204:switcherator.c ****     minutes = atoi(tempIntString);
1205:switcherator.c ****     tempLongString[0] = commandReceived[7];
1206:switcherator.c ****     tempLongString[1] = commandReceived[8];
1207:switcherator.c ****     tempLongString[2] = commandReceived[9];
1208:switcherator.c ****     tempLongString[3] = commandReceived[10];
1209:switcherator.c ****     duration = atoi(tempLongString);
1210:switcherator.c ****     if (hours >= 24 || (hours == 0 && commandReceived[4] != '0')) {
1211:switcherator.c ****         fail(9);
1212:switcherator.c ****         return;
1213:switcherator.c ****     }
1214:switcherator.c ****     if (minutes >= 60 || (minutes == 0 && commandReceived[6] != '0')) {
1215:switcherator.c ****         fail(0x0a);
1216:switcherator.c ****         return;
1217:switcherator.c ****     }
1218:switcherator.c ****     if (duration == 0) {
1219:switcherator.c ****         fail(0x0b);
1220:switcherator.c ****         return;
1221:switcherator.c ****     }
1222:switcherator.c ****     duration *= 60; // convert to seconds
1223:switcherator.c ****     startTime = (hours * 60);
1224:switcherator.c ****     startTime += minutes; // stored in minutes
1225:switcherator.c ****     int temp = 0;
1226:switcherator.c ****     temp = (startTime >> 8);
1227:switcherator.c ****     weeklyProgram[programNumber][1] = temp;
1228:switcherator.c ****     temp = (startTime & 0xff);
1229:switcherator.c ****     weeklyProgram[programNumber][2] = temp;
1230:switcherator.c ****     temp = (duration >> 8);
1231:switcherator.c ****     weeklyProgram[programNumber][3] = temp;
1232:switcherator.c ****     temp = (duration & 0xff);
1233:switcherator.c ****     weeklyProgram[programNumber][4] = temp;
1234:switcherator.c ****     statusMsg[0] = 0;
1235:switcherator.c ****     strcat(statusMsg, "New prog#");
1236:switcherator.c ****     returnInt(programNumber, tempIntString);
1237:switcherator.c ****     strcat(statusMsg, tempIntString);
1238:switcherator.c ****     sendMessage(statusMsg);
1239:switcherator.c **** }
1240:switcherator.c **** 
1241:switcherator.c **** // clears an existing program
1242:switcherator.c **** // the clearTheProgram does the work so this is the interface
1243:switcherator.c **** // CP:P#
1244:switcherator.c **** // 01234
1245:switcherator.c **** 
1246:switcherator.c **** void clearProgram(char * commandReceived) {
1247:switcherator.c ****     int programNumber = getSwitchNumber(commandReceived);
1248:switcherator.c ****     if (programNumber >= MAX_PROGRAM || (programNumber == 0 && commandReceived[4] != '0')) {
1249:switcherator.c ****         fail(2);
1250:switcherator.c ****     } else {
1251:switcherator.c ****         itoa(programNumber, tempIntString, 10);
1252:switcherator.c ****         ok();
1253:switcherator.c ****         clearTheProgram(programNumber);
1254:switcherator.c ****     }
1255:switcherator.c **** }
1256:switcherator.c **** 
1257:switcherator.c **** // zeros out the program
1258:switcherator.c **** 
1259:switcherator.c **** void clearTheProgram(int programNumber) {
 794               		.loc 1 1259 0
 795               	.LVL39:
 796               	/* prologue: function */
 797               	/* frame size = 0 */
 798               	/* stack size = 0 */
 799               	.L__stack_usage = 0
 800               		.loc 1 1259 0
 801 0492 2AE0      		ldi r18,lo8(10)
 802 0494 AC01      		movw r20,r24
 803 0496 249F      		mul r18,r20
 804 0498 C001      		movw r24,r0
 805 049a 259F      		mul r18,r21
 806 049c 900D      		add r25,r0
 807 049e 1124      		clr __zero_reg__
 808               	.LVL40:
 809 04a0 8050      		subi r24,lo8(-(weeklyProgram))
 810 04a2 9040      		sbci r25,hi8(-(weeklyProgram))
1260:switcherator.c ****     int x = 0;
1261:switcherator.c ****     // some of these "0" is a valid option so make it 255
1262:switcherator.c ****     for (x = 0; x < 10; x++) {
 811               		.loc 1 1262 0
 812 04a4 20E0      		ldi r18,0
 813 04a6 30E0      		ldi r19,0
1263:switcherator.c ****         weeklyProgram[programNumber][x] = 255;
 814               		.loc 1 1263 0
 815 04a8 4FEF      		ldi r20,lo8(-1)
 816               	.LVL41:
 817               	.L51:
1259:switcherator.c **** void clearTheProgram(int programNumber) {
 818               		.loc 1 1259 0 discriminator 2
 819 04aa FC01      		movw r30,r24
 820 04ac E20F      		add r30,r18
 821 04ae F31F      		adc r31,r19
 822               		.loc 1 1263 0 discriminator 2
 823 04b0 4083      		st Z,r20
1262:switcherator.c ****     for (x = 0; x < 10; x++) {
 824               		.loc 1 1262 0 discriminator 2
 825 04b2 2F5F      		subi r18,-1
 826 04b4 3F4F      		sbci r19,-1
 827               	.LVL42:
 828 04b6 2A30      		cpi r18,10
 829 04b8 3105      		cpc r19,__zero_reg__
 830 04ba 01F4      		brne .L51
 831               	/* epilogue start */
1264:switcherator.c ****     }
1265:switcherator.c **** }
 832               		.loc 1 1265 0
 833 04bc 0895      		ret
 834               	.LFE32:
 836               	.global	findOpenSwitch
 838               	findOpenSwitch:
 839               	.LFB34:
1266:switcherator.c **** 
1267:switcherator.c **** // there are multiple switches per program.  This adds them.
1268:switcherator.c **** // For memory constraints each program natively has up to 4
1269:switcherator.c **** // switches.  For more than that another program will be linked
1270:switcherator.c **** // Program in memory:
1271:switcherator.c **** // DssddSSSSP
1272:switcherator.c **** // 0123456789
1273:switcherator.c **** // PA:P#S#
1274:switcherator.c **** // 0123456
1275:switcherator.c **** 
1276:switcherator.c **** void programAddSwitch(char * commandReceived) {
1277:switcherator.c ****     int programNumber = 0;
1278:switcherator.c ****     int switchNumber = 0;
1279:switcherator.c ****     tempIntString[0] = commandReceived[3];
1280:switcherator.c ****     tempIntString[1] = commandReceived[4];
1281:switcherator.c ****     programNumber = atoi(tempIntString);
1282:switcherator.c ****     tempIntString[0] = commandReceived[5];
1283:switcherator.c ****     tempIntString[1] = commandReceived[6];
1284:switcherator.c ****     switchNumber = atoi(tempIntString);
1285:switcherator.c ****     char switches[NUM_SWITCHES];
1286:switcherator.c ****     switches[0] = 0;
1287:switcherator.c ****     int switchCount = programGetSwitches(programNumber, switches);
1288:switcherator.c ****     int x = 0;
1289:switcherator.c ****     // see if the switch is already there
1290:switcherator.c ****     for (x = 0; x < switchCount; x++) {
1291:switcherator.c ****         if (switches[x] == switchNumber) {
1292:switcherator.c ****             fail(0x0c);
1293:switcherator.c ****             return;
1294:switcherator.c ****         }
1295:switcherator.c ****     }
1296:switcherator.c **** 
1297:switcherator.c ****     // check validity 
1298:switcherator.c ****     if ((programNumber >= MAX_PROGRAM) || (programNumber == 0 && commandReceived[4] != '0')) {
1299:switcherator.c ****         fail(2);
1300:switcherator.c ****         return;
1301:switcherator.c ****     }
1302:switcherator.c ****     if ((switchNumber >= NUM_SWITCHES) || (switchNumber == 0 && commandReceived[6] != '0')) {
1303:switcherator.c ****         fail(1);
1304:switcherator.c ****         return;
1305:switcherator.c ****     }
1306:switcherator.c ****     // check for valid program
1307:switcherator.c ****     // The day mask maxes out at 127 - the high but shouldn't be set if it is valid
1308:switcherator.c ****     // unless it is a overflow program in which case the first switch will be set
1309:switcherator.c ****     // 255 = not set
1310:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
1311:switcherator.c ****         fail(0x0d);
1312:switcherator.c ****         return;
1313:switcherator.c ****     }
1314:switcherator.c ****     int noSwitchYet = 1;
1315:switcherator.c ****     int blankSwitch = 0;
1316:switcherator.c ****     int overflowProgram = 255;
1317:switcherator.c ****     // prepare number string for output later
1318:switcherator.c ****     itoa(programNumber, tempIntString, 10);
1319:switcherator.c ****     // see if our program has a valid switch
1320:switcherator.c ****     blankSwitch = findOpenSwitch(programNumber);
1321:switcherator.c ****     while (noSwitchYet == 1) {
1322:switcherator.c ****         if (blankSwitch == 0) {
1323:switcherator.c ****             // our program is full.  Find or make another one
1324:switcherator.c ****             // first check if we already are overflowing.
1325:switcherator.c ****             overflowProgram = weeklyProgram[programNumber][9];
1326:switcherator.c ****             if (overflowProgram == 255) {
1327:switcherator.c ****                 // no overflow.  Need to create one.
1328:switcherator.c ****                 // find blank program slot
1329:switcherator.c ****                 int possibleBlank = 255;
1330:switcherator.c ****                 // yeah I know but programNumber 0 won't be an overflow so there
1331:switcherator.c ****                 for (x = (MAX_PROGRAM - 1); x > 0; x--) {
1332:switcherator.c ****                     // dont want it to wrap though 0 is a valid program
1333:switcherator.c ****                     if (weeklyProgram[x][0] == 255 && weeklyProgram[x][5] == 255) {
1334:switcherator.c ****                         // this is blank
1335:switcherator.c ****                         possibleBlank = x;
1336:switcherator.c ****                         // end the loop
1337:switcherator.c ****                         x = 0;
1338:switcherator.c ****                     }
1339:switcherator.c ****                 }
1340:switcherator.c ****                 if (possibleBlank == 255) {
1341:switcherator.c ****                     // oh oh, no room
1342:switcherator.c ****                     fail(0x0e);
1343:switcherator.c ****                     return;
1344:switcherator.c ****                 }
1345:switcherator.c ****                 // now record the overflow and move forward
1346:switcherator.c ****                 weeklyProgram[programNumber][9] = possibleBlank;
1347:switcherator.c ****                 programNumber = possibleBlank;
1348:switcherator.c ****                 // and now we loop again...
1349:switcherator.c ****             } else {
1350:switcherator.c ****                 // move to overflow program and try again
1351:switcherator.c ****                 programNumber = overflowProgram;
1352:switcherator.c ****             }
1353:switcherator.c ****         } else { // if(blankSwitch == 0)
1354:switcherator.c ****             // we have a program and a slot.  move on.
1355:switcherator.c ****             noSwitchYet = 0;
1356:switcherator.c ****         }
1357:switcherator.c ****     }
1358:switcherator.c ****     weeklyProgram[programNumber][blankSwitch] = switchNumber;
1359:switcherator.c ****     ok();
1360:switcherator.c **** }
1361:switcherator.c **** 
1362:switcherator.c **** // iterates through a program and returns the index of an open switch or 0 if none
1363:switcherator.c **** 
1364:switcherator.c **** int findOpenSwitch(int programNumber) {
 840               		.loc 1 1364 0
 841               	.LVL43:
 842               	/* prologue: function */
 843               	/* frame size = 0 */
 844               	/* stack size = 0 */
 845               	.L__stack_usage = 0
 846               		.loc 1 1364 0
 847 04be 2AE0      		ldi r18,lo8(10)
 848 04c0 AC01      		movw r20,r24
 849 04c2 249F      		mul r18,r20
 850 04c4 C001      		movw r24,r0
 851 04c6 259F      		mul r18,r21
 852 04c8 900D      		add r25,r0
 853 04ca 1124      		clr __zero_reg__
 854               	.LVL44:
 855 04cc 8050      		subi r24,lo8(-(weeklyProgram))
 856 04ce 9040      		sbci r25,hi8(-(weeklyProgram))
1365:switcherator.c ****     int switchIndex = 0;
1366:switcherator.c ****     int x = 0;
1367:switcherator.c ****     for (x = 5; x < 9; x++) {
 857               		.loc 1 1367 0
 858 04d0 25E0      		ldi r18,lo8(5)
 859 04d2 30E0      		ldi r19,0
 860               	.LVL45:
 861               	.L55:
1364:switcherator.c **** int findOpenSwitch(int programNumber) {
 862               		.loc 1 1364 0
 863 04d4 FC01      		movw r30,r24
 864 04d6 E20F      		add r30,r18
 865 04d8 F31F      		adc r31,r19
1368:switcherator.c ****         if (weeklyProgram[programNumber][x] == 255) {
 866               		.loc 1 1368 0
 867 04da 4081      		ld r20,Z
 868 04dc 4F3F      		cpi r20,lo8(-1)
 869 04de 01F0      		breq .L54
1367:switcherator.c ****     for (x = 5; x < 9; x++) {
 870               		.loc 1 1367 0
 871 04e0 2F5F      		subi r18,-1
 872 04e2 3F4F      		sbci r19,-1
 873               	.LVL46:
 874 04e4 2930      		cpi r18,9
 875 04e6 3105      		cpc r19,__zero_reg__
 876 04e8 01F4      		brne .L55
1369:switcherator.c ****             // blank switch
1370:switcherator.c ****             switchIndex = x;
1371:switcherator.c ****             return switchIndex;
1372:switcherator.c ****         }
1373:switcherator.c ****     }
1374:switcherator.c ****     return 0;
 877               		.loc 1 1374 0
 878 04ea 20E0      		ldi r18,0
 879 04ec 30E0      		ldi r19,0
 880               	.LVL47:
 881               	.L54:
1375:switcherator.c **** }
 882               		.loc 1 1375 0
 883 04ee C901      		movw r24,r18
 884 04f0 0895      		ret
 885               	.LFE34:
 887               	.global	programGetSwitches
 889               	programGetSwitches:
 890               	.LFB38:
1376:switcherator.c **** 
1377:switcherator.c **** // Sets the days a program will run
1378:switcherator.c **** // PD:P#SMTWTFS
1379:switcherator.c **** // 012345678901
1380:switcherator.c **** 
1381:switcherator.c **** void programSetDays(char * commandReceived) {
1382:switcherator.c ****     char tempReallyLongString[] = "0000000";
1383:switcherator.c ****     int programNumber = 0;
1384:switcherator.c ****     long weekLong = 0;
1385:switcherator.c ****     tempIntString[0] = commandReceived[3];
1386:switcherator.c ****     tempIntString[1] = commandReceived[4];
1387:switcherator.c ****     programNumber = atoi(tempIntString);
1388:switcherator.c ****     tempReallyLongString[0] = commandReceived[5];
1389:switcherator.c ****     tempReallyLongString[1] = commandReceived[6];
1390:switcherator.c ****     tempReallyLongString[2] = commandReceived[7];
1391:switcherator.c ****     tempReallyLongString[3] = commandReceived[8];
1392:switcherator.c ****     tempReallyLongString[4] = commandReceived[9];
1393:switcherator.c ****     tempReallyLongString[5] = commandReceived[10];
1394:switcherator.c ****     tempReallyLongString[6] = commandReceived[11];
1395:switcherator.c ****     weekLong = strtol(tempReallyLongString, 0, 2);
1396:switcherator.c ****     if ((programNumber >= MAX_PROGRAM) || (programNumber == 0 && commandReceived[4] != '0')) {
1397:switcherator.c ****         fail(2);
1398:switcherator.c ****         return;
1399:switcherator.c ****     }
1400:switcherator.c ****     // check for valid program
1401:switcherator.c ****     // The day mask maxes out at 127 - the high but shouldn't be set if it is valid
1402:switcherator.c ****     // unless it is a overflow program in which case the first switch will be set
1403:switcherator.c ****     // 255 = not set
1404:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
1405:switcherator.c ****         fail(0x0d);
1406:switcherator.c ****         return;
1407:switcherator.c ****     }
1408:switcherator.c ****     if ((weekLong & 0x7f) == 0) {
1409:switcherator.c ****         fail(0x0f);
1410:switcherator.c ****         return;
1411:switcherator.c ****     }
1412:switcherator.c ****     char weekdays = (weekLong & 0x7f);
1413:switcherator.c ****     weeklyProgram[programNumber][0] = weekdays;
1414:switcherator.c ****     ok();
1415:switcherator.c **** }
1416:switcherator.c **** 
1417:switcherator.c **** // DssddSSSSP
1418:switcherator.c **** // 0123456789   
1419:switcherator.c **** // PT:P#HHMMDur.
1420:switcherator.c **** // 0123456789012
1421:switcherator.c **** 
1422:switcherator.c **** void programSetTime(char * commandReceived) {
1423:switcherator.c ****     int programNumber = 0;
1424:switcherator.c ****     int hours = 0;
1425:switcherator.c ****     int minutes = 0;
1426:switcherator.c ****     int startTime = 0;
1427:switcherator.c ****     int duration = 0;
1428:switcherator.c ****     tempIntString[0] = commandReceived[3];
1429:switcherator.c ****     tempIntString[1] = commandReceived[4];
1430:switcherator.c ****     programNumber = atoi(tempIntString);
1431:switcherator.c ****     if (programNumber >= MAX_PROGRAM || (programNumber == 0 && commandReceived[4] != '0')) {
1432:switcherator.c ****         fail(2);
1433:switcherator.c ****         return;
1434:switcherator.c ****     }
1435:switcherator.c ****     // check for valid program
1436:switcherator.c ****     // The day mask maxes out at 127 - the high but shouldn't be set if it is valid
1437:switcherator.c ****     // unless it is a overflow program in which case the first switch will be set
1438:switcherator.c ****     // 255 = not set
1439:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
1440:switcherator.c ****         fail(0x0d);
1441:switcherator.c ****         return;
1442:switcherator.c ****     }
1443:switcherator.c ****     tempIntString[0] = commandReceived[5];
1444:switcherator.c ****     tempIntString[1] = commandReceived[6];
1445:switcherator.c ****     hours = atoi(tempIntString);
1446:switcherator.c ****     tempIntString[0] = commandReceived[7];
1447:switcherator.c ****     tempIntString[1] = commandReceived[8];
1448:switcherator.c ****     minutes = atoi(tempIntString);
1449:switcherator.c ****     tempLongString[0] = commandReceived[9];
1450:switcherator.c ****     tempLongString[1] = commandReceived[10];
1451:switcherator.c ****     tempLongString[2] = commandReceived[11];
1452:switcherator.c ****     tempLongString[3] = commandReceived[12];
1453:switcherator.c ****     duration = atoi(tempLongString);
1454:switcherator.c ****     if (hours >= 24 || (hours == 0 && commandReceived[6] != '0')) {
1455:switcherator.c ****         fail(9);
1456:switcherator.c ****         return;
1457:switcherator.c ****     }
1458:switcherator.c ****     if (minutes >= 60 || (minutes == 0 && commandReceived[8] != '0')) {
1459:switcherator.c ****         fail(0x0a);
1460:switcherator.c ****         return;
1461:switcherator.c ****     }
1462:switcherator.c ****     if (duration == 0) {
1463:switcherator.c ****         fail(0x0b);
1464:switcherator.c ****         return;
1465:switcherator.c ****     }
1466:switcherator.c ****     duration *= 60; // convert to seconds
1467:switcherator.c ****     startTime = (hours * 60);
1468:switcherator.c ****     startTime += minutes; // stored in minutes
1469:switcherator.c ****     int temp = 0;
1470:switcherator.c ****     temp = (startTime >> 8);
1471:switcherator.c ****     weeklyProgram[programNumber][1] = temp;
1472:switcherator.c ****     temp = (startTime & 0xff);
1473:switcherator.c ****     weeklyProgram[programNumber][2] = temp;
1474:switcherator.c ****     temp = (duration >> 8);
1475:switcherator.c ****     weeklyProgram[programNumber][3] = temp;
1476:switcherator.c ****     temp = (duration & 0xff);
1477:switcherator.c ****     weeklyProgram[programNumber][4] = temp;
1478:switcherator.c ****     ok();
1479:switcherator.c **** }
1480:switcherator.c **** 
1481:switcherator.c **** void programDisplay(char * commandReceived) {
1482:switcherator.c ****     int x = 0;
1483:switcherator.c ****     int programNumber = 0;
1484:switcherator.c ****     tempIntString[0] = commandReceived[3];
1485:switcherator.c ****     tempIntString[1] = commandReceived[4];
1486:switcherator.c ****     programNumber = atoi(tempIntString);
1487:switcherator.c ****     statusMsg[0] = 0;
1488:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
1489:switcherator.c ****         strcat(statusMsg, "P#");
1490:switcherator.c ****         returnInt(programNumber, tempIntString);
1491:switcherator.c ****         strcat(statusMsg, tempIntString);
1492:switcherator.c ****         strcat(statusMsg, "blank.");
1493:switcherator.c ****         sendMessage(statusMsg);
1494:switcherator.c ****         return;
1495:switcherator.c ****     }
1496:switcherator.c ****     char switches[NUM_SWITCHES];
1497:switcherator.c ****     switches[0] = 0;
1498:switcherator.c ****     int switchCount = 0;
1499:switcherator.c ****     switchCount = programGetSwitches(programNumber, switches);
1500:switcherator.c ****     statusMsg[0] = 0;
1501:switcherator.c ****     strcat(statusMsg, "Prog#");
1502:switcherator.c ****     itoa(programNumber, tempIntString, 10);
1503:switcherator.c ****     strcat(statusMsg, tempIntString);
1504:switcherator.c ****     if (switchCount == 0) {
1505:switcherator.c ****         strcat(switches, "S:-");
1506:switcherator.c ****     } else {
1507:switcherator.c ****         int temp = 0;
1508:switcherator.c ****         strcat(statusMsg, "S");
1509:switcherator.c ****         for (x = 0; x < switchCount; x++) {
1510:switcherator.c ****             strcat(statusMsg, ":");
1511:switcherator.c ****             temp = switches[x];
1512:switcherator.c ****             itoa(temp, tempIntString, 10);
1513:switcherator.c ****             strcat(statusMsg, tempIntString);
1514:switcherator.c ****         }
1515:switcherator.c ****     }
1516:switcherator.c ****     sendMessage(statusMsg);
1517:switcherator.c ****     statusMsg[0] = 0;
1518:switcherator.c ****     unsigned int time = 0;
1519:switcherator.c ****     time = weeklyProgram[programNumber][1];
1520:switcherator.c ****     time <<= 8;
1521:switcherator.c ****     time |= weeklyProgram[programNumber][2];
1522:switcherator.c ****     unsigned int hours = (time / 60);
1523:switcherator.c ****     unsigned int minutes = (time - (hours * 60));
1524:switcherator.c ****     time = weeklyProgram[programNumber][3];
1525:switcherator.c ****     time <<= 8;
1526:switcherator.c ****     time |= weeklyProgram[programNumber][4];
1527:switcherator.c ****     int duration = (time / 60);
1528:switcherator.c ****     char weekdays = 0;
1529:switcherator.c ****     weekdays = weeklyProgram[programNumber][0];
1530:switcherator.c ****     strcat(statusMsg, "T:");
1531:switcherator.c ****     itoa(hours, tempIntString, 10);
1532:switcherator.c ****     strcat(statusMsg, tempIntString);
1533:switcherator.c ****     strcat(statusMsg, ":");
1534:switcherator.c ****     itoa(minutes, tempIntString, 10);
1535:switcherator.c ****     strcat(statusMsg, tempIntString);
1536:switcherator.c ****     strcat(statusMsg, " Dur:");
1537:switcherator.c ****     itoa(duration, tempLongString, 10);
1538:switcherator.c ****     strcat(statusMsg, tempLongString);
1539:switcherator.c ****     strcat(statusMsg, "Days:");
1540:switcherator.c ****     if (weekdays == 255) {
1541:switcherator.c ****         strcat(statusMsg, "-------");
1542:switcherator.c ****         sendMessage(statusMsg);
1543:switcherator.c ****         return;
1544:switcherator.c ****     }
1545:switcherator.c ****     if (weekdays & 0x40) {
1546:switcherator.c ****         strcat(statusMsg, "S");
1547:switcherator.c ****     } else {
1548:switcherator.c ****         strcat(statusMsg, "-");
1549:switcherator.c ****     }
1550:switcherator.c ****     if (weekdays & 0x20) {
1551:switcherator.c ****         strcat(statusMsg, "M");
1552:switcherator.c ****     } else {
1553:switcherator.c ****         strcat(statusMsg, "-");
1554:switcherator.c ****     }
1555:switcherator.c ****     if (weekdays & 0x10) {
1556:switcherator.c ****         strcat(statusMsg, "T");
1557:switcherator.c ****     } else {
1558:switcherator.c ****         strcat(statusMsg, "-");
1559:switcherator.c ****     }
1560:switcherator.c ****     if (weekdays & 0x08) {
1561:switcherator.c ****         strcat(statusMsg, "W");
1562:switcherator.c ****     } else {
1563:switcherator.c ****         strcat(statusMsg, "-");
1564:switcherator.c ****     }
1565:switcherator.c ****     if (weekdays & 0x04) {
1566:switcherator.c ****         strcat(statusMsg, "T");
1567:switcherator.c ****     } else {
1568:switcherator.c ****         strcat(statusMsg, "-");
1569:switcherator.c ****     }
1570:switcherator.c ****     if (weekdays & 0x02) {
1571:switcherator.c ****         strcat(statusMsg, "F");
1572:switcherator.c ****     } else {
1573:switcherator.c ****         strcat(statusMsg, "-");
1574:switcherator.c ****     }
1575:switcherator.c ****     if (weekdays & 0x01) {
1576:switcherator.c ****         strcat(statusMsg, "S");
1577:switcherator.c ****     } else {
1578:switcherator.c ****         strcat(statusMsg, "-");
1579:switcherator.c ****     }
1580:switcherator.c **** 
1581:switcherator.c ****     sendMessage(statusMsg);
1582:switcherator.c **** }
1583:switcherator.c **** 
1584:switcherator.c **** // get the switches for a program
1585:switcherator.c **** // char * switches should be set as large as NUM_SWITCHES
1586:switcherator.c **** // so you don't overflow
1587:switcherator.c **** 
1588:switcherator.c **** int programGetSwitches(int programNumber, char * switches) {
 891               		.loc 1 1588 0
 892               	.LVL48:
 893 04f2 CF93      		push r28
 894               	.LCFI8:
 895 04f4 DF93      		push r29
 896               	.LCFI9:
 897               	/* prologue: function */
 898               	/* frame size = 0 */
 899               	/* stack size = 2 */
 900               	.L__stack_usage = 2
 901               	.LVL49:
1589:switcherator.c ****     int element = 0;
 902               		.loc 1 1589 0
 903 04f6 20E0      		ldi r18,0
 904 04f8 30E0      		ldi r19,0
1588:switcherator.c **** int programGetSwitches(int programNumber, char * switches) {
 905               		.loc 1 1588 0
 906 04fa CAE0      		ldi r28,lo8(10)
 907               	.LVL50:
 908               	.L61:
 909 04fc F901      		movw r30,r18
 910 04fe 3496      		adiw r30,4
 911 0500 C89F      		mul r28,r24
 912 0502 A001      		movw r20,r0
 913 0504 C99F      		mul r28,r25
 914 0506 500D      		add r21,r0
 915 0508 1124      		clr __zero_reg__
 916 050a 421B      		sub r20,r18
 917 050c 530B      		sbc r21,r19
 918 050e 4050      		subi r20,lo8(-(weeklyProgram))
 919 0510 5040      		sbci r21,hi8(-(weeklyProgram))
 920               	.LVL51:
 921               	.L60:
 922 0512 DA01      		movw r26,r20
 923 0514 A20F      		add r26,r18
 924 0516 B31F      		adc r27,r19
1590:switcherator.c ****     int x = 0;
1591:switcherator.c ****     // start loading the switch array
1592:switcherator.c ****     while (1) {
1593:switcherator.c ****         for (x = 5; x < 9; x++) {
1594:switcherator.c ****             if (weeklyProgram[programNumber][x] == 255) {
 925               		.loc 1 1594 0
 926 0518 1596      		adiw r26,5
 927 051a DC91      		ld r29,X
 928 051c DF3F      		cpi r29,lo8(-1)
 929 051e 01F0      		breq .L59
1588:switcherator.c **** int programGetSwitches(int programNumber, char * switches) {
 930               		.loc 1 1588 0
 931 0520 DB01      		movw r26,r22
 932 0522 A20F      		add r26,r18
 933 0524 B31F      		adc r27,r19
1595:switcherator.c ****                 // blank switch we are done
1596:switcherator.c ****                 return element;
1597:switcherator.c ****             } else {
1598:switcherator.c ****                 switches[element] = weeklyProgram[programNumber][x];
 934               		.loc 1 1598 0
 935 0526 DC93      		st X,r29
1599:switcherator.c ****                 element++;
 936               		.loc 1 1599 0
 937 0528 2F5F      		subi r18,-1
 938 052a 3F4F      		sbci r19,-1
 939               	.LVL52:
1593:switcherator.c ****         for (x = 5; x < 9; x++) {
 940               		.loc 1 1593 0
 941 052c 2E17      		cp r18,r30
 942 052e 3F07      		cpc r19,r31
 943 0530 01F4      		brne .L60
1600:switcherator.c ****             }
1601:switcherator.c ****         } // for x=5-9
1602:switcherator.c ****         // see if this program iterates around
1603:switcherator.c ****         if (weeklyProgram[programNumber][9] == 255) {
 944               		.loc 1 1603 0
 945 0532 C89F      		mul r28,r24
 946 0534 F001      		movw r30,r0
 947 0536 C99F      		mul r28,r25
 948 0538 F00D      		add r31,r0
 949 053a 1124      		clr __zero_reg__
 950 053c E050      		subi r30,lo8(-(weeklyProgram))
 951 053e F040      		sbci r31,hi8(-(weeklyProgram))
 952 0540 8185      		ldd r24,Z+9
 953               	.LVL53:
 954 0542 8F3F      		cpi r24,lo8(-1)
 955 0544 01F0      		breq .L59
1604:switcherator.c ****             // we are done;
1605:switcherator.c ****             return element;
1606:switcherator.c ****         } else {
1607:switcherator.c ****             // move to the next programNumber and continue
1608:switcherator.c ****             programNumber = weeklyProgram[programNumber][9];
 956               		.loc 1 1608 0
 957 0546 90E0      		ldi r25,0
 958               	.LVL54:
1609:switcherator.c ****         }
1610:switcherator.c ****     }
 959               		.loc 1 1610 0
 960 0548 00C0      		rjmp .L61
 961               	.LVL55:
 962               	.L59:
1611:switcherator.c **** }
 963               		.loc 1 1611 0
 964 054a C901      		movw r24,r18
 965               	/* epilogue start */
 966 054c DF91      		pop r29
 967 054e CF91      		pop r28
 968 0550 0895      		ret
 969               	.LFE38:
 971               	.global	startTheProgram
 973               	startTheProgram:
 974               	.LFB40:
1612:switcherator.c **** 
1613:switcherator.c **** // takes in a program number and time and turns on the program
1614:switcherator.c **** // SP P#Durat.
1615:switcherator.c **** // 01234567890
1616:switcherator.c **** 
1617:switcherator.c **** void startProgram(char * commandReceived) {
1618:switcherator.c ****     unsigned long duration;
1619:switcherator.c ****     int programNumber = 0;
1620:switcherator.c ****     // get switch number
1621:switcherator.c ****     tempIntString[0] = commandReceived[3];
1622:switcherator.c ****     tempIntString[1] = commandReceived[4];
1623:switcherator.c ****     programNumber = atoi(tempIntString);
1624:switcherator.c ****     if (programNumber >= MAX_PROGRAM) {
1625:switcherator.c ****         fail(2);
1626:switcherator.c ****         return;
1627:switcherator.c ****     }
1628:switcherator.c ****     // get duration
1629:switcherator.c ****     tempHugeString[0] = commandReceived[5];
1630:switcherator.c ****     tempHugeString[1] = commandReceived[6];
1631:switcherator.c ****     tempHugeString[2] = commandReceived[7];
1632:switcherator.c ****     tempHugeString[3] = commandReceived[8];
1633:switcherator.c ****     tempHugeString[4] = commandReceived[9];
1634:switcherator.c ****     tempHugeString[5] = commandReceived[10];
1635:switcherator.c ****     duration = atol(tempHugeString);
1636:switcherator.c ****     startTheProgram(programNumber, duration, 0);
1637:switcherator.c ****     ok();
1638:switcherator.c **** }
1639:switcherator.c **** 
1640:switcherator.c **** void startTheProgram(int programNumber, int duration, long time) {
 975               		.loc 1 1640 0
 976               	.LVL56:
 977 0552 8F92      		push r8
 978               	.LCFI10:
 979 0554 9F92      		push r9
 980               	.LCFI11:
 981 0556 AF92      		push r10
 982               	.LCFI12:
 983 0558 BF92      		push r11
 984               	.LCFI13:
 985 055a CF92      		push r12
 986               	.LCFI14:
 987 055c DF92      		push r13
 988               	.LCFI15:
 989 055e EF92      		push r14
 990               	.LCFI16:
 991 0560 FF92      		push r15
 992               	.LCFI17:
 993 0562 1F93      		push r17
 994               	.LCFI18:
 995 0564 CF93      		push r28
 996               	.LCFI19:
 997 0566 DF93      		push r29
 998               	.LCFI20:
 999 0568 CDB7      		in r28,__SP_L__
 1000 056a DEB7      		in r29,__SP_H__
 1001               	.LCFI21:
 1002 056c 6497      		sbiw r28,20
 1003               	.LCFI22:
 1004 056e 0FB6      		in __tmp_reg__,__SREG__
 1005 0570 F894      		cli
 1006 0572 DEBF      		out __SP_H__,r29
 1007 0574 0FBE      		out __SREG__,__tmp_reg__
 1008 0576 CDBF      		out __SP_L__,r28
 1009               	/* prologue: function */
 1010               	/* frame size = 20 */
 1011               	/* stack size = 31 */
 1012               	.L__stack_usage = 31
 1013 0578 4B01      		movw r8,r22
 1014               	.LVL57:
1641:switcherator.c ****     char switches[NUM_SWITCHES];
1642:switcherator.c ****     int switchCount = 0;
1643:switcherator.c ****     int thisSwitch = 0;
1644:switcherator.c ****     int x = 0;
1645:switcherator.c **** 
1646:switcherator.c ****     if (duration == 0) {
 1015               		.loc 1 1646 0
 1016 057a 6115      		cp r22,__zero_reg__
 1017 057c 7105      		cpc r23,__zero_reg__
 1018 057e 01F4      		brne .L70
 1019               	.LVL58:
1647:switcherator.c ****         // get the duration since we weren't fed it
1648:switcherator.c ****         duration = weeklyProgram[programNumber][3];
1649:switcherator.c ****         duration <<= 8;
1650:switcherator.c ****         duration = weeklyProgram[programNumber][4];
 1020               		.loc 1 1650 0
 1021 0580 6AE0      		ldi r22,lo8(10)
 1022 0582 689F      		mul r22,r24
 1023 0584 F001      		movw r30,r0
 1024 0586 699F      		mul r22,r25
 1025 0588 F00D      		add r31,r0
 1026 058a 1124      		clr __zero_reg__
 1027 058c E050      		subi r30,lo8(-(weeklyProgram))
 1028 058e F040      		sbci r31,hi8(-(weeklyProgram))
 1029 0590 8480      		ldd r8,Z+4
 1030 0592 912C      		mov r9,__zero_reg__
 1031               	.LVL59:
 1032               	.L70:
1651:switcherator.c ****     }
1652:switcherator.c ****     switchCount = programGetSwitches(programNumber, switches);
 1033               		.loc 1 1652 0
 1034 0594 BE01      		movw r22,r28
 1035 0596 6F5F      		subi r22,-1
 1036 0598 7F4F      		sbci r23,-1
 1037 059a 298B      		std Y+17,r18
 1038 059c 3A8B      		std Y+18,r19
 1039 059e 4B8B      		std Y+19,r20
 1040 05a0 5C8B      		std Y+20,r21
 1041 05a2 0E94 0000 		call programGetSwitches
 1042               	.LVL60:
 1043 05a6 AA24      		clr r10
 1044 05a8 97FC      		sbrc r9,7
 1045 05aa A094      		com r10
 1046 05ac BA2C      		mov r11,r10
 1047 05ae C090 0000 		lds r12,weeklySeconds
 1048 05b2 D090 0000 		lds r13,weeklySeconds+1
 1049 05b6 E090 0000 		lds r14,weeklySeconds+2
 1050 05ba F090 0000 		lds r15,weeklySeconds+3
1653:switcherator.c ****     // see if we were fed the start time so we don't go too long
1654:switcherator.c ****     // this may run multiple times
1655:switcherator.c ****     if (time == 0) {
 1051               		.loc 1 1655 0
 1052 05be 2989      		ldd r18,Y+17
 1053 05c0 3A89      		ldd r19,Y+18
 1054 05c2 4B89      		ldd r20,Y+19
 1055 05c4 5C89      		ldd r21,Y+20
 1056 05c6 2115      		cp r18,__zero_reg__
 1057 05c8 3105      		cpc r19,__zero_reg__
 1058 05ca 4105      		cpc r20,__zero_reg__
 1059 05cc 5105      		cpc r21,__zero_reg__
 1060 05ce 01F4      		brne .L71
1656:switcherator.c ****         time = weeklySeconds + duration;
 1061               		.loc 1 1656 0
 1062 05d0 A501      		movw r20,r10
 1063 05d2 9401      		movw r18,r8
 1064 05d4 2C0D      		add r18,r12
 1065 05d6 3D1D      		adc r19,r13
 1066 05d8 4E1D      		adc r20,r14
 1067 05da 5F1D      		adc r21,r15
 1068               	.LVL61:
 1069               	.L71:
1657:switcherator.c ****     }
1658:switcherator.c ****     for (x = 0; x < switchCount; x++) {
1659:switcherator.c ****         thisSwitch = switches[x];
1660:switcherator.c ****         // only update the time if it is longer than what the switch is already turned on to
1661:switcherator.c ****         if ((weeklySeconds + duration) > switchStatus[thisSwitch])
 1070               		.loc 1 1661 0
 1071 05dc C80C      		add r12,r8
 1072 05de D91C      		adc r13,r9
 1073 05e0 EA1C      		adc r14,r10
 1074 05e2 FB1C      		adc r15,r11
 1075 05e4 FE01      		movw r30,r28
 1076 05e6 3196      		adiw r30,1
1640:switcherator.c **** void startTheProgram(int programNumber, int duration, long time) {
 1077               		.loc 1 1640 0
 1078 05e8 BF01      		movw r22,r30
1658:switcherator.c ****     for (x = 0; x < switchCount; x++) {
 1079               		.loc 1 1658 0
 1080 05ea 00C0      		rjmp .L77
 1081               	.LVL62:
 1082               	.L74:
1659:switcherator.c ****         thisSwitch = switches[x];
 1083               		.loc 1 1659 0
 1084 05ec A191      		ld r26,Z+
 1085               	.LVL63:
 1086               		.loc 1 1661 0
 1087 05ee 14E0      		ldi r17,lo8(4)
 1088 05f0 A19F      		mul r26,r17
 1089 05f2 D001      		movw r26,r0
 1090 05f4 1124      		clr __zero_reg__
 1091               	.LVL64:
 1092 05f6 A050      		subi r26,lo8(-(switchStatus))
 1093 05f8 B040      		sbci r27,hi8(-(switchStatus))
 1094 05fa 8D90      		ld r8,X+
 1095 05fc 9D90      		ld r9,X+
 1096 05fe AD90      		ld r10,X+
 1097 0600 BC90      		ld r11,X
 1098 0602 1397      		sbiw r26,3
 1099 0604 8C14      		cp r8,r12
 1100 0606 9D04      		cpc r9,r13
 1101 0608 AE04      		cpc r10,r14
 1102 060a BF04      		cpc r11,r15
 1103 060c 00F4      		brsh .L77
1662:switcherator.c ****             switchStatus[thisSwitch] = time;
 1104               		.loc 1 1662 0
 1105 060e 2D93      		st X+,r18
 1106 0610 3D93      		st X+,r19
 1107 0612 4D93      		st X+,r20
 1108 0614 5C93      		st X,r21
 1109 0616 1397      		sbiw r26,3
 1110               	.LVL65:
 1111               	.L77:
1640:switcherator.c **** void startTheProgram(int programNumber, int duration, long time) {
 1112               		.loc 1 1640 0 discriminator 1
 1113 0618 DF01      		movw r26,r30
 1114 061a A61B      		sub r26,r22
 1115 061c B70B      		sbc r27,r23
1658:switcherator.c ****     for (x = 0; x < switchCount; x++) {
 1116               		.loc 1 1658 0 discriminator 1
 1117 061e A817      		cp r26,r24
 1118 0620 B907      		cpc r27,r25
 1119 0622 04F0      		brlt .L74
1663:switcherator.c ****     }
1664:switcherator.c ****     switchChanged = 1;
 1120               		.loc 1 1664 0
 1121 0624 81E0      		ldi r24,lo8(1)
 1122               	.LVL66:
 1123 0626 8093 0000 		sts switchChanged,r24
 1124               	/* epilogue start */
1665:switcherator.c **** }
 1125               		.loc 1 1665 0
 1126 062a 6496      		adiw r28,20
 1127 062c 0FB6      		in __tmp_reg__,__SREG__
 1128 062e F894      		cli
 1129 0630 DEBF      		out __SP_H__,r29
 1130 0632 0FBE      		out __SREG__,__tmp_reg__
 1131 0634 CDBF      		out __SP_L__,r28
 1132 0636 DF91      		pop r29
 1133 0638 CF91      		pop r28
 1134 063a 1F91      		pop r17
 1135 063c FF90      		pop r15
 1136 063e EF90      		pop r14
 1137 0640 DF90      		pop r13
 1138 0642 CF90      		pop r12
 1139 0644 BF90      		pop r11
 1140 0646 AF90      		pop r10
 1141 0648 9F90      		pop r9
 1142 064a 8F90      		pop r8
 1143 064c 0895      		ret
 1144               	.LFE40:
 1146               	.global	readEEPROM
 1148               	readEEPROM:
 1149               	.LFB42:
1666:switcherator.c **** 
1667:switcherator.c **** 
1668:switcherator.c **** /****************************************************************
1669:switcherator.c ****  *
1670:switcherator.c ****  *              All Things EEPROM Related
1671:switcherator.c ****  *
1672:switcherator.c ****  ****************************************************************/
1673:switcherator.c **** 
1674:switcherator.c **** // Get variables out of EEPROM and set things up
1675:switcherator.c **** 
1676:switcherator.c **** void generalInit(void) {
1677:switcherator.c ****     // read the program info
1678:switcherator.c ****     char tempStuff[14];
1679:switcherator.c ****     int x = 0;
1680:switcherator.c ****     // Go through the addresses and assign them if set
1681:switcherator.c ****     // decided later that this is a really bad idea. gets corrupted.  use default
1682:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_TX, RADIO_ADDR_TX_BYTES) == 1) {
1683:switcherator.c ****         tx_addr = formatAddress(tempStuff);
1684:switcherator.c ****         writeAddr(TX_ADDR, tx_addr);
1685:switcherator.c ****     }
1686:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R0, RADIO_ADDR_R0_BYTES) == 1) {
1687:switcherator.c ****         rx_addr_p0 = formatAddress(tempStuff);
1688:switcherator.c ****         writeAddr(RX_ADDR_P0, rx_addr_p0);
1689:switcherator.c ****     }
1690:switcherator.c ****      
1691:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R1, RADIO_ADDR_R1_BYTES) == 1) {
1692:switcherator.c ****         rx_addr_p1 = formatAddress(tempStuff);
1693:switcherator.c ****         writeAddr(RX_ADDR_P1, rx_addr_p1);
1694:switcherator.c ****     }
1695:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R2, RADIO_ADDR_R2_BYTES) == 1) {
1696:switcherator.c ****         rx_addr_p2 = tempStuff[0];
1697:switcherator.c ****         writeAddr(RX_ADDR_P2, rx_addr_p2);
1698:switcherator.c ****     }
1699:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R3, RADIO_ADDR_R3_BYTES) == 1) {
1700:switcherator.c ****         rx_addr_p3 = tempStuff[0];
1701:switcherator.c ****         writeAddr(RX_ADDR_P3, rx_addr_p3);
1702:switcherator.c ****     }
1703:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R4, RADIO_ADDR_R4_BYTES) == 1) {
1704:switcherator.c ****         rx_addr_p4 = tempStuff[0];
1705:switcherator.c ****         writeAddr(RX_ADDR_P4, rx_addr_p4);
1706:switcherator.c ****     }
1707:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R5, RADIO_ADDR_R5_BYTES) == 1) {
1708:switcherator.c ****         rx_addr_p5 = tempStuff[0];
1709:switcherator.c ****         writeAddr(RX_ADDR_P5, rx_addr_p5);
1710:switcherator.c ****     }
1711:switcherator.c ****     if (readEEPROM(tempStuff, TWEAK_TIMER, TWEAK_TIMER_BYTES) == 1) {
1712:switcherator.c ****         tweakTimer = tempStuff[0];
1713:switcherator.c ****         tweakTimer <<= 8;
1714:switcherator.c ****         tweakTimer |= tempStuff[1];
1715:switcherator.c ****     }
1716:switcherator.c **** 
1717:switcherator.c **** 
1718:switcherator.c ****     // process daylight savings
1719:switcherator.c ****     if (readEEPROM(tempStuff, DAYLIGHT_SAVE, DAYLIGHT_SAVE_BYTES) == 1) {
1720:switcherator.c ****         // Spring month
1721:switcherator.c ****         daylightSavings[0][0] = ((tempStuff[0] << 8) | (tempStuff[1]));
1722:switcherator.c ****         // Spring day
1723:switcherator.c ****         daylightSavings[0][1] = ((tempStuff[2] << 8) | (tempStuff[3]));
1724:switcherator.c ****         // Fall month
1725:switcherator.c ****         daylightSavings[1][0] = ((tempStuff[4] << 8) | (tempStuff[5]));
1726:switcherator.c ****         // Fall day
1727:switcherator.c ****         daylightSavings[1][1] = ((tempStuff[6] << 8) | (tempStuff[7]));
1728:switcherator.c ****     }
1729:switcherator.c **** 
1730:switcherator.c **** 
1731:switcherator.c ****     // switches
1732:switcherator.c ****     if (readEEPROM(switchStuff, SWITCH_STUFF, SWITCH_STUFF_BYTES) == 1) {
1733:switcherator.c ****         readEEPROM(switchBright, BRIGHTNESS, BRIGHTNESS_BYTES);
1734:switcherator.c ****         volatile unsigned char *realPort = 0;
1735:switcherator.c ****         volatile unsigned char *realDDR = 0;
1736:switcherator.c ****         char realPin = 0;
1737:switcherator.c ****         char temp = 0;
1738:switcherator.c ****         // Pp - value of 255 (default) means nothing programmed
1739:switcherator.c ****         // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
1740:switcherator.c ****         // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
1741:switcherator.c ****         for (x = 0; x < NUM_SWITCHES; x++) {
1742:switcherator.c ****             temp = switchStuff[x];
1743:switcherator.c ****             if (temp > 15 && temp < 32) {
1744:switcherator.c ****                 realPort = &PORTB;
1745:switcherator.c ****                 realDDR = &DDRB;
1746:switcherator.c ****                 temp -= 16;
1747:switcherator.c **** #ifdef PINA
1748:switcherator.c ****             } else if (temp < 16) {
1749:switcherator.c ****                 realPort = &PORTA;
1750:switcherator.c ****                 realDDR = &DDRA;
1751:switcherator.c ****                 temp -= 0;
1752:switcherator.c **** #endif
1753:switcherator.c **** #ifdef PINC
1754:switcherator.c ****             } else if (temp < 48) {
1755:switcherator.c ****                 realPort = &PORTC;
1756:switcherator.c ****                 realDDR = &DDRC;
1757:switcherator.c ****                 temp -= 32;
1758:switcherator.c **** #endif
1759:switcherator.c **** #ifdef PIND
1760:switcherator.c ****             } else if (temp < 64) {
1761:switcherator.c ****                 realPort = &PORTD;
1762:switcherator.c ****                 realDDR = &DDRD;
1763:switcherator.c ****                 temp -= 48;
1764:switcherator.c **** #endif
1765:switcherator.c **** #ifdef PINE
1766:switcherator.c ****             } else if (temp < 80) {
1767:switcherator.c ****                 realPort = &PORTE;
1768:switcherator.c ****                 realDDR = &DDRE;
1769:switcherator.c ****                 temp -= 64;
1770:switcherator.c **** #endif
1771:switcherator.c **** #ifdef PINF
1772:switcherator.c ****             } else if (temp < 96) {
1773:switcherator.c ****                 realPort = &PORTF;
1774:switcherator.c ****                 realDDR = &DDRF;
1775:switcherator.c ****                 temp -= 80;
1776:switcherator.c **** #endif
1777:switcherator.c **** #ifdef PING
1778:switcherator.c ****             } else if (temp < 112) {
1779:switcherator.c ****                 realPort = &PORTG;
1780:switcherator.c ****                 realDDR = &DDRG;
1781:switcherator.c ****                 temp -= 96;
1782:switcherator.c **** #endif
1783:switcherator.c **** #ifdef PINH
1784:switcherator.c ****             } else if (temp < 128) {
1785:switcherator.c ****                 realPort = &PORTH;
1786:switcherator.c ****                 realDDR = &DDRH;
1787:switcherator.c ****                 temp -= 112;
1788:switcherator.c **** #endif
1789:switcherator.c **** #ifdef PINI
1790:switcherator.c ****             } else if (temp < 144) {
1791:switcherator.c ****                 realPort = &PORTI;
1792:switcherator.c ****                 realDDR = &DDRI;
1793:switcherator.c ****                 temp -= 128;
1794:switcherator.c **** #endif
1795:switcherator.c ****                 // pwm setup
1796:switcherator.c ****             } else {
1797:switcherator.c ****                 continue;
1798:switcherator.c ****             }
1799:switcherator.c ****             realPin = (temp / 2);
1800:switcherator.c ****             *realDDR |= (1 << realPin);
1801:switcherator.c ****             // figure out direction
1802:switcherator.c ****             if (temp % 2 == 0) {
1803:switcherator.c ****                 // 0 = low is on  1 = high is on
1804:switcherator.c ****                 *realPort |= (1 << realPin);
1805:switcherator.c ****             } else {
1806:switcherator.c ****                 *realPort &= ~(1 << realPin);
1807:switcherator.c ****             }
1808:switcherator.c ****         }
1809:switcherator.c ****     } else {
1810:switcherator.c ****         for (x = 0; x < NUM_SWITCHES; x++)
1811:switcherator.c ****             switchStuff[x] = 255;
1812:switcherator.c ****     }
1813:switcherator.c **** 
1814:switcherator.c ****     int memoryMarker = 0;
1815:switcherator.c ****     int y = 0;
1816:switcherator.c ****     // get the programs
1817:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
1818:switcherator.c ****         memoryMarker = (WEEKLY_PROGRAM + (x * WEEKLY_PROGRAM_BYTES));
1819:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, WEEKLY_PROGRAM_BYTES) == 1) {
1820:switcherator.c ****             for (y = 0; y < 10; y++) {
1821:switcherator.c ****                 weeklyProgram[x][y] = tempStuff[y];
1822:switcherator.c ****             }
1823:switcherator.c ****         }
1824:switcherator.c ****     }
1825:switcherator.c ****     // get the inputs
1826:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
1827:switcherator.c ****         memoryMarker = (INPUT + (x * INPUT_BYTES));
1828:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, INPUT_BYTES) == 1) {
1829:switcherator.c ****             for (y = 0; y < 8; y++) {
1830:switcherator.c ****                 inputs[x][y] = tempStuff[y];
1831:switcherator.c ****             }
1832:switcherator.c ****         }
1833:switcherator.c ****     }
1834:switcherator.c ****     // get the time limits
1835:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++) {
1836:switcherator.c ****         memoryMarker = (LIMIT + (x * LIMIT_BYTES));
1837:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, LIMIT_BYTES) == 1) {
1838:switcherator.c ****             for (y = 0; y < 3; y++) {
1839:switcherator.c ****                 timeLimits[x][y] = tempStuff[y];
1840:switcherator.c ****             }
1841:switcherator.c ****         }
1842:switcherator.c ****     }
1843:switcherator.c **** 
1844:switcherator.c ****     if (readEEPROM(tempStuff, PWM_DIR, PWM_DIR_BYTES) == 1) {
1845:switcherator.c ****         DDRD |= (1 << PIND3) | (1 << PIND5) | (1 << PIND6);
1846:switcherator.c ****         // make sure initial values are 0
1847:switcherator.c ****         Red = 0;
1848:switcherator.c ****         Green = 0;
1849:switcherator.c ****         Blue = 0;
1850:switcherator.c ****         // Set output phase correct whatevers
1851:switcherator.c ****         // set it to inverted if the direction is 0
1852:switcherator.c ****         if (tempStuff[0] == 0) {
1853:switcherator.c ****             TCCR0A = (1 << COM0A0) | (1 << COM0A1) | (1 << COM0B0) | (1 << COM0B1) | (1 << WGM00);
1854:switcherator.c ****             TCCR2A = (1 << COM2B0) | (1 << COM2B1) | (1 << WGM20);
1855:switcherator.c ****             pwmdir = 0;
1856:switcherator.c ****         } else {
1857:switcherator.c ****             TCCR0A = (1 << COM0A1) | (1 << COM0B1) | (1 << WGM00);
1858:switcherator.c ****             TCCR2A = (1 << COM2B1) | (1 << WGM20);
1859:switcherator.c ****             pwmdir = 1;
1860:switcherator.c ****         }
1861:switcherator.c ****         // F_CPU/64 timers
1862:switcherator.c ****         TCCR0B = (1 << CS01) | (1 << CS00);
1863:switcherator.c **** 
1864:switcherator.c ****         TCCR2B = (1 << CS22); // F_CPU/64
1865:switcherator.c ****     }
1866:switcherator.c **** 
1867:switcherator.c ****     // get the pwm value bytes
1868:switcherator.c ****     memoryMarker = (PWM_VALUE);
1869:switcherator.c ****     if (readEEPROM(tempStuff, memoryMarker, PWM_VALUE_BYTES) == 1) {
1870:switcherator.c ****         pwmValues[0] = tempStuff[0];
1871:switcherator.c ****         pwmValues[1] = tempStuff[1];
1872:switcherator.c ****         pwmValues[2] = tempStuff[2];
1873:switcherator.c ****     }
1874:switcherator.c ****     // get the color change
1875:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
1876:switcherator.c ****         memoryMarker = (COLOR_CHANGE + (x * COLOR_CHANGE_BYTES));
1877:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, PWM_VALUE_BYTES) == 1) {
1878:switcherator.c ****             for (y = 0; y < 3; y++) {
1879:switcherator.c ****                 colorChanges[x][y] = tempStuff[y];
1880:switcherator.c ****             }
1881:switcherator.c ****         }
1882:switcherator.c ****     }
1883:switcherator.c **** }
1884:switcherator.c **** 
1885:switcherator.c **** int readEEPROM(char * data, int memLocation, int memBytes) {
 1150               		.loc 1 1885 0
 1151               	.LVL67:
 1152 064e EF92      		push r14
 1153               	.LCFI23:
 1154 0650 FF92      		push r15
 1155               	.LCFI24:
 1156 0652 0F93      		push r16
 1157               	.LCFI25:
 1158 0654 1F93      		push r17
 1159               	.LCFI26:
 1160 0656 CF93      		push r28
 1161               	.LCFI27:
 1162 0658 DF93      		push r29
 1163               	.LCFI28:
 1164               	/* prologue: function */
 1165               	/* frame size = 0 */
 1166               	/* stack size = 6 */
 1167               	.L__stack_usage = 6
 1168 065a 7C01      		movw r14,r24
 1169 065c EB01      		movw r28,r22
 1170 065e 8A01      		movw r16,r20
 1171               	.LVL68:
 1172 0660 FC01      		movw r30,r24
1886:switcherator.c ****     uint16_t checkProgram;
1887:switcherator.c ****     int x = 0;
1888:switcherator.c ****     for (x = 0; x < 14; x++) {
 1173               		.loc 1 1888 0
 1174 0662 20E0      		ldi r18,0
 1175 0664 30E0      		ldi r19,0
 1176               	.LVL69:
 1177               	.L79:
1889:switcherator.c ****         data[x] = 0;
 1178               		.loc 1 1889 0 discriminator 2
 1179 0666 1192      		st Z+,__zero_reg__
1888:switcherator.c ****     for (x = 0; x < 14; x++) {
 1180               		.loc 1 1888 0 discriminator 2
 1181 0668 2F5F      		subi r18,-1
 1182 066a 3F4F      		sbci r19,-1
 1183               	.LVL70:
 1184 066c 2E30      		cpi r18,14
 1185 066e 3105      		cpc r19,__zero_reg__
 1186 0670 01F4      		brne .L79
1890:switcherator.c ****     }
1891:switcherator.c ****     // see if it has been programmed
1892:switcherator.c ****     checkProgram = eeprom_read_word((uint16_t*) memLocation);
 1187               		.loc 1 1892 0
 1188 0672 CE01      		movw r24,r28
 1189 0674 0E94 0000 		call __eerd_word_m328
 1190               	.LVL71:
1893:switcherator.c ****     // "DW" = 68,87 = 0x4457
1894:switcherator.c ****     if (checkProgram == 0x4457) {
 1191               		.loc 1 1894 0
 1192 0678 8735      		cpi r24,87
 1193 067a 9444      		sbci r25,68
 1194 067c 01F4      		brne .L81
 1195               	.LVL72:
 1196               	.LBB20:
 1197               	.LBB21:
1895:switcherator.c ****         // we've written here before. now get the data (except marker)
1896:switcherator.c ****         eeprom_read_block((void*) data, (const void*) (memLocation + 2), (memBytes - 2));
 1198               		.loc 1 1896 0
 1199 067e A801      		movw r20,r16
 1200 0680 4250      		subi r20,2
 1201 0682 5109      		sbc r21,__zero_reg__
 1202 0684 BE01      		movw r22,r28
 1203 0686 6E5F      		subi r22,-2
 1204 0688 7F4F      		sbci r23,-1
 1205 068a C701      		movw r24,r14
 1206               	.LVL73:
 1207 068c 0E94 0000 		call __eerd_block_m328
 1208               	.LVL74:
 1209 0690 21E0      		ldi r18,lo8(1)
 1210 0692 30E0      		ldi r19,0
 1211 0694 00C0      		rjmp .L80
 1212               	.LVL75:
 1213               	.L81:
 1214               	.LBE21:
 1215               	.LBE20:
1897:switcherator.c ****         return 1;
1898:switcherator.c ****     } else {
1899:switcherator.c ****         return 0;
 1216               		.loc 1 1899 0
 1217 0696 20E0      		ldi r18,0
 1218 0698 30E0      		ldi r19,0
 1219               	.LVL76:
 1220               	.L80:
1900:switcherator.c ****     }
1901:switcherator.c **** }
 1221               		.loc 1 1901 0
 1222 069a C901      		movw r24,r18
 1223               	/* epilogue start */
 1224 069c DF91      		pop r29
 1225 069e CF91      		pop r28
 1226               	.LVL77:
 1227 06a0 1F91      		pop r17
 1228 06a2 0F91      		pop r16
 1229               	.LVL78:
 1230 06a4 FF90      		pop r15
 1231 06a6 EF90      		pop r14
 1232               	.LVL79:
 1233 06a8 0895      		ret
 1234               	.LFE42:
 1236               	.global	writeEEPROM
 1238               	writeEEPROM:
 1239               	.LFB43:
1902:switcherator.c **** 
1903:switcherator.c **** void writeEEPROM(char * data, int memLocation, int memBytes) {
 1240               		.loc 1 1903 0
 1241               	.LVL80:
 1242 06aa CF93      		push r28
 1243               	.LCFI29:
 1244 06ac DF93      		push r29
 1245               	.LCFI30:
 1246               	/* prologue: function */
 1247               	/* frame size = 0 */
 1248               	/* stack size = 2 */
 1249               	.L__stack_usage = 2
 1250 06ae EB01      		movw r28,r22
 1251               	.LVL81:
1904:switcherator.c ****     uint16_t marker = 0x4457; // "DW" in ascii
1905:switcherator.c ****     eeprom_update_block((const void*) data, (void*) (memLocation + 2), (memBytes - 2));
 1252               		.loc 1 1905 0
 1253 06b0 4250      		subi r20,2
 1254 06b2 5109      		sbc r21,__zero_reg__
 1255               	.LVL82:
 1256 06b4 6E5F      		subi r22,-2
 1257 06b6 7F4F      		sbci r23,-1
 1258               	.LVL83:
 1259 06b8 0E94 0000 		call __eeupd_block_m328
 1260               	.LVL84:
1906:switcherator.c ****     eeprom_update_word((uint16_t*) memLocation, marker);
 1261               		.loc 1 1906 0
 1262 06bc 67E5      		ldi r22,lo8(87)
 1263 06be 74E4      		ldi r23,lo8(68)
 1264 06c0 CE01      		movw r24,r28
 1265               	/* epilogue start */
1907:switcherator.c **** }
 1266               		.loc 1 1907 0
 1267 06c2 DF91      		pop r29
 1268 06c4 CF91      		pop r28
 1269               	.LVL85:
1906:switcherator.c ****     eeprom_update_word((uint16_t*) memLocation, marker);
 1270               		.loc 1 1906 0
 1271 06c6 0C94 0000 		jmp __eeupd_word_m328
 1272               	.LVL86:
 1273               	.LFE43:
 1275               	.global	clearEEPROM
 1277               	clearEEPROM:
 1278               	.LFB44:
1908:switcherator.c **** 
1909:switcherator.c **** void clearEEPROM(int memLocation) {
 1279               		.loc 1 1909 0
 1280               	.LVL87:
 1281               	/* prologue: function */
 1282               	/* frame size = 0 */
 1283               	/* stack size = 0 */
 1284               	.L__stack_usage = 0
1910:switcherator.c ****     uint16_t marker = 0x0000; // blank it out
1911:switcherator.c ****     eeprom_update_word((uint16_t*) memLocation, marker);
 1285               		.loc 1 1911 0
 1286 06ca 60E0      		ldi r22,0
 1287 06cc 70E0      		ldi r23,0
 1288 06ce 0C94 0000 		jmp __eeupd_word_m328
 1289               	.LVL88:
 1290               	.LFE44:
 1292               	.global	clockInit
 1294               	clockInit:
 1295               	.LFB47:
1912:switcherator.c **** }
1913:switcherator.c **** 
1914:switcherator.c **** void saveToEEPROM(void) {
1915:switcherator.c ****     char tempStuff[14];
1916:switcherator.c ****     int x = 0;
1917:switcherator.c ****     // Go through the addresses and assign them if set
1918:switcherator.c ****     if (tx_addr > 0) {
1919:switcherator.c ****         unformatAddress(tx_addr, tempStuff);
1920:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_TX, RADIO_ADDR_TX_BYTES);
1921:switcherator.c ****     }
1922:switcherator.c ****     if (rx_addr_p0 > 0) {
1923:switcherator.c ****         unformatAddress(rx_addr_p0, tempStuff);
1924:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R0, RADIO_ADDR_R0_BYTES);
1925:switcherator.c ****     }
1926:switcherator.c ****     if (rx_addr_p1 > 0) {
1927:switcherator.c ****         unformatAddress(rx_addr_p1, tempStuff);
1928:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R1, RADIO_ADDR_R1_BYTES);
1929:switcherator.c ****     }
1930:switcherator.c ****     if (rx_addr_p2 > 0) {
1931:switcherator.c ****         tempStuff[0] = rx_addr_p2;
1932:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R2, RADIO_ADDR_R2_BYTES);
1933:switcherator.c ****     }
1934:switcherator.c ****     if (rx_addr_p3 > 0) {
1935:switcherator.c ****         tempStuff[0] = rx_addr_p3;
1936:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R3, RADIO_ADDR_R3_BYTES);
1937:switcherator.c ****     }
1938:switcherator.c ****     if (rx_addr_p4 > 0) {
1939:switcherator.c ****         tempStuff[0] = rx_addr_p4;
1940:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R4, RADIO_ADDR_R4_BYTES);
1941:switcherator.c ****     }
1942:switcherator.c ****     if (rx_addr_p5 > 0) {
1943:switcherator.c ****         tempStuff[0] = rx_addr_p5;
1944:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R5, RADIO_ADDR_R5_BYTES);
1945:switcherator.c ****     }
1946:switcherator.c **** 
1947:switcherator.c ****     if (tweakTimer != 0) {
1948:switcherator.c ****         tempStuff[0] = tweakTimer >> 8;
1949:switcherator.c ****         tempStuff[1] = (tweakTimer & 0xff);
1950:switcherator.c ****         writeEEPROM(tempStuff, TWEAK_TIMER, TWEAK_TIMER_BYTES);
1951:switcherator.c ****     }
1952:switcherator.c **** 
1953:switcherator.c **** 
1954:switcherator.c **** 
1955:switcherator.c ****     if (daylightSavings[0][0] > 0) {
1956:switcherator.c ****         tempStuff[0] = (daylightSavings[0][0] >> 8);
1957:switcherator.c ****         tempStuff[1] = (daylightSavings[0][0] & 0xff);
1958:switcherator.c ****         tempStuff[2] = (daylightSavings[0][1] >> 8);
1959:switcherator.c ****         tempStuff[3] = (daylightSavings[0][1] & 0xff);
1960:switcherator.c ****         tempStuff[4] = (daylightSavings[1][0] >> 8);
1961:switcherator.c ****         tempStuff[5] = (daylightSavings[1][0] & 0xff);
1962:switcherator.c ****         tempStuff[6] = (daylightSavings[1][1] >> 8);
1963:switcherator.c ****         tempStuff[7] = (daylightSavings[1][1] & 0xff);
1964:switcherator.c ****         writeEEPROM(tempStuff, DAYLIGHT_SAVE, DAYLIGHT_SAVE_BYTES);
1965:switcherator.c ****     }
1966:switcherator.c ****     char setupaSwitch = 0;
1967:switcherator.c ****     char setupPWM = 0;
1968:switcherator.c **** 
1969:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
1970:switcherator.c ****         if (switchStuff[x] < 255)
1971:switcherator.c ****             setupaSwitch = 1;
1972:switcherator.c ****         if (switchStuff[x] >= 200 && switchStuff[x] <= 230)
1973:switcherator.c ****             setupPWM = 1;
1974:switcherator.c ****     }
1975:switcherator.c ****     if (setupaSwitch == 1) {
1976:switcherator.c ****         writeEEPROM(switchStuff, SWITCH_STUFF, SWITCH_STUFF_BYTES);
1977:switcherator.c ****         writeEEPROM(switchBright, BRIGHTNESS, BRIGHTNESS_BYTES);
1978:switcherator.c ****     }
1979:switcherator.c ****     tempStuff[0] = pwmdir;
1980:switcherator.c ****     if (setupPWM == 1)
1981:switcherator.c ****         writeEEPROM(tempStuff, PWM_DIR, PWM_DIR_BYTES);
1982:switcherator.c **** 
1983:switcherator.c ****     int memoryMarker;
1984:switcherator.c **** 
1985:switcherator.c **** 
1986:switcherator.c **** 
1987:switcherator.c **** 
1988:switcherator.c ****     // save the programs
1989:switcherator.c ****     int y = 0;
1990:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
1991:switcherator.c ****         memoryMarker = (WEEKLY_PROGRAM + (x * WEEKLY_PROGRAM_BYTES));
1992:switcherator.c ****         if (weeklyProgram[x][0] != 255 || weeklyProgram[x][1] != 255) {
1993:switcherator.c ****             for (y = 0; y < 10; y++)
1994:switcherator.c ****                 tempStuff[y] = weeklyProgram[x][y];
1995:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, WEEKLY_PROGRAM_BYTES);
1996:switcherator.c ****         }
1997:switcherator.c ****     }
1998:switcherator.c **** 
1999:switcherator.c ****     // save the inputs
2000:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
2001:switcherator.c ****         memoryMarker = (INPUT + (x * INPUT_BYTES));
2002:switcherator.c ****         if (inputs[x][0] != 255) {
2003:switcherator.c ****             for (y = 0; y < 8; y++) {
2004:switcherator.c ****                 tempStuff[y] = inputs[x][y];
2005:switcherator.c ****             }
2006:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, INPUT_BYTES);
2007:switcherator.c ****         }
2008:switcherator.c ****     }
2009:switcherator.c **** 
2010:switcherator.c ****     // save the time limits
2011:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++) {
2012:switcherator.c ****         memoryMarker = (LIMIT + (x * LIMIT_BYTES));
2013:switcherator.c ****         if (timeLimits[x][2] > 0) {
2014:switcherator.c ****             for (y = 0; y < 3; y++) {
2015:switcherator.c ****                 tempStuff[y] = timeLimits[x][y];
2016:switcherator.c ****             }
2017:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, INPUT_BYTES);
2018:switcherator.c ****         }
2019:switcherator.c ****     }
2020:switcherator.c **** 
2021:switcherator.c **** 
2022:switcherator.c ****     // save the pwm value bytes
2023:switcherator.c ****     memoryMarker = (PWM_VALUE);
2024:switcherator.c ****     if (pwmValues[0] != 0 || pwmValues[1] != 0 || pwmValues[2] != 0) {
2025:switcherator.c ****         for (y = 0; y < 3; y++) {
2026:switcherator.c ****             tempStuff[y] = pwmValues[y];
2027:switcherator.c ****         }
2028:switcherator.c ****         writeEEPROM(tempStuff, memoryMarker, PWM_VALUE_BYTES);
2029:switcherator.c ****     }
2030:switcherator.c **** 
2031:switcherator.c ****     // save the color change
2032:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
2033:switcherator.c ****         memoryMarker = (COLOR_CHANGE + (x * COLOR_CHANGE_BYTES));
2034:switcherator.c ****         if (colorChanges[0][0] != 0 || colorChanges[0][1] != 1 || colorChanges[0][2] != 0) {
2035:switcherator.c ****             for (y = 0; y < 3; y++) {
2036:switcherator.c ****                 tempStuff[y] = inputs[x][y];
2037:switcherator.c ****             }
2038:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, COLOR_CHANGE_BYTES);
2039:switcherator.c ****         }
2040:switcherator.c ****     }
2041:switcherator.c ****     ok();
2042:switcherator.c **** }
2043:switcherator.c **** 
2044:switcherator.c **** void clearToEEPROM(void) {
2045:switcherator.c ****     int x = 0;
2046:switcherator.c ****     clearEEPROM(DAYLIGHT_SAVE);
2047:switcherator.c ****     clearEEPROM(RADIO_ADDR_TX);
2048:switcherator.c ****     clearEEPROM(RADIO_ADDR_R0);
2049:switcherator.c ****     clearEEPROM(RADIO_ADDR_R1);
2050:switcherator.c ****     clearEEPROM(RADIO_ADDR_R2);
2051:switcherator.c ****     clearEEPROM(RADIO_ADDR_R3);
2052:switcherator.c ****     clearEEPROM(RADIO_ADDR_R4);
2053:switcherator.c ****     clearEEPROM(RADIO_ADDR_R5);
2054:switcherator.c ****     clearEEPROM(SWITCH_STUFF);
2055:switcherator.c ****     clearEEPROM(PWM_DIR);
2056:switcherator.c ****     clearEEPROM(BRIGHTNESS);
2057:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++)
2058:switcherator.c ****         clearEEPROM((INPUT + (x * INPUT_BYTES)));
2059:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++)
2060:switcherator.c ****         clearEEPROM((LIMIT + (x * LIMIT_BYTES)));
2061:switcherator.c ****     clearEEPROM(PWM_VALUE);
2062:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++)
2063:switcherator.c ****         clearEEPROM((COLOR_CHANGE + (x * COLOR_CHANGE_BYTES)));
2064:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++)
2065:switcherator.c ****         clearEEPROM((WEEKLY_PROGRAM + (x * WEEKLY_PROGRAM_BYTES)));
2066:switcherator.c ****     clearEEPROM(TWEAK_TIMER);
2067:switcherator.c ****     ok();
2068:switcherator.c **** }
2069:switcherator.c **** 
2070:switcherator.c **** /****************************************************************
2071:switcherator.c ****  *
2072:switcherator.c ****  *              All Things Clock Related
2073:switcherator.c ****  *
2074:switcherator.c ****  ****************************************************************/
2075:switcherator.c **** 
2076:switcherator.c **** 
2077:switcherator.c **** // initialize the clock
2078:switcherator.c **** 
2079:switcherator.c **** void clockInit(void) {
 1296               		.loc 1 2079 0
 1297               	/* prologue: function */
 1298               	/* frame size = 0 */
 1299               	/* stack size = 0 */
 1300               	.L__stack_usage = 0
2080:switcherator.c ****     // Set CTC mode (clear timer on compare)
2081:switcherator.c ****     TCCR1A = 0;
 1301               		.loc 1 2081 0
 1302 06d2 1092 8000 		sts 128,__zero_reg__
2082:switcherator.c ****     TCCR1B = (1 << WGM12);
 1303               		.loc 1 2082 0
 1304 06d6 88E0      		ldi r24,lo8(8)
 1305 06d8 8093 8100 		sts 129,r24
2083:switcherator.c ****     OCR1A = TIMER_RESET;
 1306               		.loc 1 2083 0
 1307 06dc 1092 8900 		sts 136+1,__zero_reg__
 1308 06e0 1092 8800 		sts 136,__zero_reg__
2084:switcherator.c ****     TIMSK1 = (1 << OCIE1A); // set interrupt
 1309               		.loc 1 2084 0
 1310 06e4 82E0      		ldi r24,lo8(2)
 1311 06e6 8093 6F00 		sts 111,r24
 1312 06ea 0895      		ret
 1313               	.LFE47:
 1315               	.global	startClock
 1317               	startClock:
 1318               	.LFB50:
2085:switcherator.c **** }
2086:switcherator.c **** 
2087:switcherator.c **** // we received a time command.  set the clock
2088:switcherator.c **** // Must be this format:
2089:switcherator.c **** // TI:MMDDYYYYHHMMSS
2090:switcherator.c **** // 012345678901234567
2091:switcherator.c **** 
2092:switcherator.c **** void setClock(char * commandReceived) {
2093:switcherator.c ****     long tempInt;
2094:switcherator.c ****     // iterate through and get the times.
2095:switcherator.c ****     tempLongString[0] = '0';
2096:switcherator.c ****     tempLongString[1] = '0';
2097:switcherator.c ****     // Can't see a good loop so just get to it.
2098:switcherator.c ****     // Month
2099:switcherator.c ****     tempLongString[2] = commandReceived[3];
2100:switcherator.c ****     tempLongString[3] = commandReceived[4];
2101:switcherator.c ****     globalMonth = atoi(tempLongString);
2102:switcherator.c ****     // Day
2103:switcherator.c ****     tempLongString[2] = commandReceived[5];
2104:switcherator.c ****     tempLongString[3] = commandReceived[6];
2105:switcherator.c ****     globalDay = atoi(tempLongString);
2106:switcherator.c ****     // hour
2107:switcherator.c ****     tempLongString[2] = commandReceived[11];
2108:switcherator.c ****     tempLongString[3] = commandReceived[12];
2109:switcherator.c ****     globalHour = atoi(tempLongString);
2110:switcherator.c ****     // minute
2111:switcherator.c ****     tempLongString[2] = commandReceived[13];
2112:switcherator.c ****     tempLongString[3] = commandReceived[14];
2113:switcherator.c ****     globalMinute = atoi(tempLongString);
2114:switcherator.c ****     // second
2115:switcherator.c ****     tempLongString[2] = commandReceived[15];
2116:switcherator.c ****     tempLongString[3] = commandReceived[16];
2117:switcherator.c ****     globalSecond = atoi(tempLongString);
2118:switcherator.c ****     // year
2119:switcherator.c ****     tempLongString[0] = commandReceived[7];
2120:switcherator.c ****     tempLongString[1] = commandReceived[8];
2121:switcherator.c ****     tempLongString[2] = commandReceived[9];
2122:switcherator.c ****     tempLongString[3] = commandReceived[10];
2123:switcherator.c ****     globalYear = atoi(tempLongString);
2124:switcherator.c ****     dow = getWeekday(globalYear, globalMonth, globalDay); // get day of week
2125:switcherator.c ****     tempInt = dow;
2126:switcherator.c ****     tempInt = tempInt * 24 * 60 * 60;
2127:switcherator.c ****     weeklySeconds = tempInt;
2128:switcherator.c ****     tempInt = globalHour;
2129:switcherator.c ****     tempInt = tempInt * 60 * 60;
2130:switcherator.c ****     weeklySeconds += tempInt;
2131:switcherator.c ****     tempInt = globalMinute;
2132:switcherator.c ****     tempInt = tempInt * 60;
2133:switcherator.c ****     weeklySeconds += tempInt;
2134:switcherator.c ****     weeklySeconds += globalSecond;
2135:switcherator.c ****     clockString();
2136:switcherator.c ****     sendMessage(statusMsg);
2137:switcherator.c ****     stopClock();
2138:switcherator.c ****     startClock();
2139:switcherator.c ****     panicMyClockIsNotSet = 0;
2140:switcherator.c ****     if(failCondition == 3) {
2141:switcherator.c ****         clearFail();      
2142:switcherator.c ****     }
2143:switcherator.c **** }
2144:switcherator.c **** 
2145:switcherator.c **** 
2146:switcherator.c **** // Change the clock values to a string
2147:switcherator.c **** 
2148:switcherator.c **** void clockString(void) {
2149:switcherator.c ****     statusMsg[0] = 0;
2150:switcherator.c **** 
2151:switcherator.c ****     strcat(statusMsg, " ");
2152:switcherator.c ****     returnInt(globalMonth, tempIntString);
2153:switcherator.c ****     strcat(statusMsg, tempIntString);
2154:switcherator.c ****     strcat(statusMsg, "/");
2155:switcherator.c ****     returnInt(globalDay, tempIntString);
2156:switcherator.c ****     strcat(statusMsg, tempIntString);
2157:switcherator.c ****     strcat(statusMsg, "/");
2158:switcherator.c ****     itoa(globalYear, tempIntString, 10);
2159:switcherator.c ****     strcat(statusMsg, tempIntString);
2160:switcherator.c ****     strcat(statusMsg, " ");
2161:switcherator.c ****     returnInt(globalHour, tempIntString);
2162:switcherator.c ****     strcat(statusMsg, tempIntString);
2163:switcherator.c ****     strcat(statusMsg, ":");
2164:switcherator.c ****     returnInt(globalMinute, tempIntString);
2165:switcherator.c ****     strcat(statusMsg, tempIntString);
2166:switcherator.c ****     strcat(statusMsg, ":");
2167:switcherator.c ****     returnInt(globalSecond, tempIntString);
2168:switcherator.c ****     strcat(statusMsg, tempIntString);
2169:switcherator.c **** }
2170:switcherator.c **** 
2171:switcherator.c **** // start the clock
2172:switcherator.c **** 
2173:switcherator.c **** void startClock(void) {
 1319               		.loc 1 2173 0
 1320               	/* prologue: function */
 1321               	/* frame size = 0 */
 1322               	/* stack size = 0 */
 1323               	.L__stack_usage = 0
2174:switcherator.c ****     TCNT1 = 65535;
 1324               		.loc 1 2174 0
 1325 06ec 8FEF      		ldi r24,lo8(-1)
 1326 06ee 9FEF      		ldi r25,lo8(-1)
 1327 06f0 9093 8500 		sts 132+1,r25
 1328 06f4 8093 8400 		sts 132,r24
2175:switcherator.c ****     TCCR1B |= TIMER_CLOCK_SEL;
 1329               		.loc 1 2175 0
 1330 06f8 E1E8      		ldi r30,lo8(-127)
 1331 06fa F0E0      		ldi r31,0
 1332 06fc 8081      		ld r24,Z
 1333 06fe 8560      		ori r24,lo8(5)
 1334 0700 8083      		st Z,r24
 1335 0702 0895      		ret
 1336               	.LFE50:
 1338               	.global	stopClock
 1340               	stopClock:
 1341               	.LFB51:
2176:switcherator.c **** }
2177:switcherator.c **** 
2178:switcherator.c **** void stopClock(void) {
 1342               		.loc 1 2178 0
 1343               	/* prologue: function */
 1344               	/* frame size = 0 */
 1345               	/* stack size = 0 */
 1346               	.L__stack_usage = 0
2179:switcherator.c ****     TCCR1B &= ~(TIMER_CLOCK_SEL);
 1347               		.loc 1 2179 0
 1348 0704 E1E8      		ldi r30,lo8(-127)
 1349 0706 F0E0      		ldi r31,0
 1350 0708 8081      		ld r24,Z
 1351 070a 8A7F      		andi r24,lo8(-6)
 1352 070c 8083      		st Z,r24
 1353 070e 0895      		ret
 1354               	.LFE51:
 1356               	.global	getWeekday
 1358               	getWeekday:
 1359               	.LFB52:
2180:switcherator.c **** }
2181:switcherator.c **** 
2182:switcherator.c **** // returns the weekday - sunday = 0
2183:switcherator.c **** 
2184:switcherator.c **** int getWeekday(int year, int month, int day) {
 1360               		.loc 1 2184 0
 1361               	.LVL89:
 1362 0710 CF93      		push r28
 1363               	.LCFI31:
 1364 0712 DF93      		push r29
 1365               	.LCFI32:
 1366               	/* prologue: function */
 1367               	/* frame size = 0 */
 1368               	/* stack size = 2 */
 1369               	.L__stack_usage = 2
 1370 0714 FB01      		movw r30,r22
 1371 0716 EA01      		movw r28,r20
2185:switcherator.c ****     int adjustment, mm, yy;
2186:switcherator.c **** 
2187:switcherator.c ****     adjustment = (14 - month) / 12; // Jan is 13, feb is 14 in calculation
 1372               		.loc 1 2187 0
 1373 0718 8EE0      		ldi r24,lo8(14)
 1374 071a 90E0      		ldi r25,0
 1375               	.LVL90:
 1376 071c 861B      		sub r24,r22
 1377 071e 970B      		sbc r25,r23
 1378 0720 6CE0      		ldi r22,lo8(12)
 1379 0722 70E0      		ldi r23,0
 1380               	.LVL91:
 1381 0724 0E94 0000 		call __divmodhi4
 1382               	.LVL92:
2188:switcherator.c ****     mm = month + 12 * adjustment - 2;
2189:switcherator.c ****     yy = globalYear - adjustment;
 1383               		.loc 1 2189 0
 1384 0728 2091 0000 		lds r18,globalYear
 1385 072c 3091 0000 		lds r19,globalYear+1
 1386 0730 261B      		sub r18,r22
 1387 0732 370B      		sbc r19,r23
 1388               	.LVL93:
2188:switcherator.c ****     mm = month + 12 * adjustment - 2;
 1389               		.loc 1 2188 0
 1390 0734 8CE0      		ldi r24,lo8(12)
 1391 0736 869F      		mul r24,r22
 1392 0738 A001      		movw r20,r0
 1393 073a 879F      		mul r24,r23
 1394 073c 500D      		add r21,r0
 1395 073e 1124      		clr __zero_reg__
 1396               	.LVL94:
 1397 0740 4E0F      		add r20,r30
 1398 0742 5F1F      		adc r21,r31
 1399 0744 4250      		subi r20,2
 1400 0746 5109      		sbc r21,__zero_reg__
2190:switcherator.c ****     return ((day + (13 * mm - 1) / 5 + yy + yy / 4 - yy / 100 + yy / 400) % 7);
 1401               		.loc 1 2190 0
 1402 0748 6DE0      		ldi r22,lo8(13)
 1403               	.LVL95:
 1404 074a 649F      		mul r22,r20
 1405 074c C001      		movw r24,r0
 1406 074e 659F      		mul r22,r21
 1407 0750 900D      		add r25,r0
 1408 0752 1124      		clr __zero_reg__
 1409 0754 0197      		sbiw r24,1
 1410 0756 65E0      		ldi r22,lo8(5)
 1411 0758 70E0      		ldi r23,0
 1412 075a 0E94 0000 		call __divmodhi4
 1413 075e C60F      		add r28,r22
 1414 0760 D71F      		adc r29,r23
 1415               	.LVL96:
 1416 0762 C20F      		add r28,r18
 1417 0764 D31F      		adc r29,r19
 1418 0766 F901      		movw r30,r18
 1419               	.LVL97:
 1420 0768 37FD      		sbrc r19,7
 1421 076a 3396      		adiw r30,3
 1422               	.L89:
 1423 076c F595      		asr r31
 1424 076e E795      		ror r30
 1425 0770 F595      		asr r31
 1426 0772 E795      		ror r30
 1427 0774 EC0F      		add r30,r28
 1428 0776 FD1F      		adc r31,r29
 1429 0778 C901      		movw r24,r18
 1430 077a 6CE9      		ldi r22,lo8(-100)
 1431 077c 7FEF      		ldi r23,lo8(-1)
 1432 077e 0E94 0000 		call __divmodhi4
 1433 0782 E60F      		add r30,r22
 1434 0784 F71F      		adc r31,r23
 1435 0786 C901      		movw r24,r18
 1436 0788 60E9      		ldi r22,lo8(-112)
 1437 078a 71E0      		ldi r23,lo8(1)
 1438 078c 0E94 0000 		call __divmodhi4
 1439 0790 E60F      		add r30,r22
 1440 0792 F71F      		adc r31,r23
 1441 0794 CF01      		movw r24,r30
 1442 0796 67E0      		ldi r22,lo8(7)
 1443 0798 70E0      		ldi r23,0
 1444 079a 0E94 0000 		call __divmodhi4
 1445               	/* epilogue start */
2191:switcherator.c **** }
 1446               		.loc 1 2191 0
 1447 079e DF91      		pop r29
 1448 07a0 CF91      		pop r28
 1449 07a2 0895      		ret
 1450               	.LFE52:
 1452               		.section	.rodata
 1453               	.LC0:
 1454 0000 0000      		.word	0
 1455 0002 1F00      		.word	31
 1456 0004 1C00      		.word	28
 1457 0006 1F00      		.word	31
 1458 0008 1E00      		.word	30
 1459 000a 1F00      		.word	31
 1460 000c 1E00      		.word	30
 1461 000e 1F00      		.word	31
 1462 0010 1F00      		.word	31
 1463 0012 1E00      		.word	30
 1464 0014 1F00      		.word	31
 1465 0016 1E00      		.word	30
 1466               		.text
 1467               	.global	getDayofYear
 1469               	getDayofYear:
 1470               	.LFB53:
2192:switcherator.c **** 
2193:switcherator.c **** // returns the day of the year (1 - 365 or 366)
2194:switcherator.c **** 
2195:switcherator.c **** int getDayofYear(int year, int month, int day) {
 1471               		.loc 1 2195 0
 1472               	.LVL98:
 1473 07a4 CF93      		push r28
 1474               	.LCFI33:
 1475 07a6 DF93      		push r29
 1476               	.LCFI34:
 1477 07a8 CDB7      		in r28,__SP_L__
 1478 07aa DEB7      		in r29,__SP_H__
 1479               	.LCFI35:
 1480 07ac 6897      		sbiw r28,24
 1481               	.LCFI36:
 1482 07ae 0FB6      		in __tmp_reg__,__SREG__
 1483 07b0 F894      		cli
 1484 07b2 DEBF      		out __SP_H__,r29
 1485 07b4 0FBE      		out __SREG__,__tmp_reg__
 1486 07b6 CDBF      		out __SP_L__,r28
 1487               	/* prologue: function */
 1488               	/* frame size = 24 */
 1489               	/* stack size = 26 */
 1490               	.L__stack_usage = 26
2196:switcherator.c ****     int months[12] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30};
 1491               		.loc 1 2196 0
 1492 07b8 28E1      		ldi r18,lo8(24)
 1493 07ba E0E0      		ldi r30,lo8(.LC0)
 1494 07bc F0E0      		ldi r31,hi8(.LC0)
 1495 07be DE01      		movw r26,r28
 1496 07c0 1196      		adiw r26,1
 1497               		0:
 1498 07c2 0190      		ld r0,Z+
 1499 07c4 0D92      		st X+,r0
 1500 07c6 2A95      		dec r18
 1501 07c8 01F4      		brne 0b
 1502               	.LVL99:
2197:switcherator.c ****     int x = 0;
2198:switcherator.c ****     // adjust feb for leap year
2199:switcherator.c ****     if ((year % 4) == 0)
 1503               		.loc 1 2199 0
 1504 07ca 8370      		andi r24,3
 1505 07cc 9927      		clr r25
 1506               	.LVL100:
 1507 07ce 892B      		or r24,r25
 1508 07d0 01F4      		brne .L91
2200:switcherator.c ****         months[3] = 29;
 1509               		.loc 1 2200 0
 1510 07d2 8DE1      		ldi r24,lo8(29)
 1511 07d4 90E0      		ldi r25,0
 1512 07d6 9887      		std Y+8,r25
 1513 07d8 8F83      		std Y+7,r24
 1514               	.L91:
 1515               	.LVL101:
 1516 07da FE01      		movw r30,r28
 1517 07dc 3196      		adiw r30,1
2201:switcherator.c ****     // start with the day of the month, then add amounts for each month
2202:switcherator.c ****     int doy = day;
 1518               		.loc 1 2202 0
 1519 07de 9A01      		movw r18,r20
2203:switcherator.c ****     for (x = 0; x < month; x++) {
 1520               		.loc 1 2203 0
 1521 07e0 80E0      		ldi r24,0
 1522 07e2 90E0      		ldi r25,0
 1523 07e4 00C0      		rjmp .L92
 1524               	.LVL102:
 1525               	.L93:
2204:switcherator.c ****         doy += months[x];
 1526               		.loc 1 2204 0 discriminator 2
 1527 07e6 4191      		ld r20,Z+
 1528 07e8 5191      		ld r21,Z+
 1529 07ea 240F      		add r18,r20
 1530 07ec 351F      		adc r19,r21
 1531               	.LVL103:
2203:switcherator.c ****     for (x = 0; x < month; x++) {
 1532               		.loc 1 2203 0 discriminator 2
 1533 07ee 0196      		adiw r24,1
 1534               	.LVL104:
 1535               	.L92:
2203:switcherator.c ****     for (x = 0; x < month; x++) {
 1536               		.loc 1 2203 0 is_stmt 0 discriminator 1
 1537 07f0 8617      		cp r24,r22
 1538 07f2 9707      		cpc r25,r23
 1539 07f4 04F0      		brlt .L93
2205:switcherator.c ****     }
2206:switcherator.c ****     return doy;
2207:switcherator.c **** }
 1540               		.loc 1 2207 0 is_stmt 1
 1541 07f6 C901      		movw r24,r18
 1542               	.LVL105:
 1543               	/* epilogue start */
 1544 07f8 6896      		adiw r28,24
 1545 07fa 0FB6      		in __tmp_reg__,__SREG__
 1546 07fc F894      		cli
 1547 07fe DEBF      		out __SP_H__,r29
 1548 0800 0FBE      		out __SREG__,__tmp_reg__
 1549 0802 CDBF      		out __SP_L__,r28
 1550 0804 DF91      		pop r29
 1551 0806 CF91      		pop r28
 1552 0808 0895      		ret
 1553               	.LFE53:
 1555               	.global	checkDaylightSavings
 1557               	checkDaylightSavings:
 1558               	.LFB55:
2208:switcherator.c **** 
2209:switcherator.c **** // Sets up the days we do daylight savings
2210:switcherator.c **** // DS:MMDD MMDD
2211:switcherator.c **** // 012345678901
2212:switcherator.c **** 
2213:switcherator.c **** void setDaylightSavings(char * commandReceived) {
2214:switcherator.c ****     int dlInt;
2215:switcherator.c ****     tempIntString[0] = commandReceived[3];
2216:switcherator.c ****     tempIntString[1] = commandReceived[4];
2217:switcherator.c ****     dlInt = atoi(tempIntString);
2218:switcherator.c ****     daylightSavings[0][0] = dlInt;
2219:switcherator.c ****     tempIntString[0] = commandReceived[5];
2220:switcherator.c ****     tempIntString[1] = commandReceived[6];
2221:switcherator.c ****     dlInt = atoi(tempIntString);
2222:switcherator.c ****     daylightSavings[0][1] = dlInt;
2223:switcherator.c ****     tempIntString[0] = commandReceived[8];
2224:switcherator.c ****     tempIntString[1] = commandReceived[9];
2225:switcherator.c ****     dlInt = atoi(tempIntString);
2226:switcherator.c ****     daylightSavings[1][0] = dlInt;
2227:switcherator.c ****     tempIntString[0] = commandReceived[10];
2228:switcherator.c ****     tempIntString[1] = commandReceived[11];
2229:switcherator.c ****     dlInt = atoi(tempIntString);
2230:switcherator.c ****     daylightSavings[1][1] = dlInt;
2231:switcherator.c ****     ok();
2232:switcherator.c **** }
2233:switcherator.c **** 
2234:switcherator.c **** // Decide if this 3:00am is daylight savings and adjust accordingly
2235:switcherator.c **** 
2236:switcherator.c **** void checkDaylightSavings(void) {
 1559               		.loc 1 2236 0
 1560               	/* prologue: function */
 1561               	/* frame size = 0 */
 1562               	/* stack size = 0 */
 1563               	.L__stack_usage = 0
2237:switcherator.c ****     // have we adjusted for daylight savings?
2238:switcherator.c ****     if (wasDaylightSavings == 1)
 1564               		.loc 1 2238 0
 1565 080a 8091 0000 		lds r24,wasDaylightSavings
 1566 080e 8130      		cpi r24,lo8(1)
 1567 0810 01F0      		breq .L94
2239:switcherator.c ****         return;
2240:switcherator.c ****     if (globalMonth == daylightSavings[0][0] && globalDay == daylightSavings[0][1]) {
 1568               		.loc 1 2240 0
 1569 0812 8091 0000 		lds r24,globalMonth
 1570 0816 9091 0000 		lds r25,globalMonth+1
 1571 081a 2091 0000 		lds r18,daylightSavings
 1572 081e 3091 0000 		lds r19,daylightSavings+1
 1573 0822 8217      		cp r24,r18
 1574 0824 9307      		cpc r25,r19
 1575 0826 01F4      		brne .L96
 1576               		.loc 1 2240 0 is_stmt 0 discriminator 1
 1577 0828 4091 0000 		lds r20,globalDay
 1578 082c 5091 0000 		lds r21,globalDay+1
 1579 0830 2091 0000 		lds r18,daylightSavings+2
 1580 0834 3091 0000 		lds r19,daylightSavings+2+1
 1581 0838 4217      		cp r20,r18
 1582 083a 5307      		cpc r21,r19
 1583 083c 01F4      		brne .L96
2241:switcherator.c ****         wasDaylightSavings = 1;
 1584               		.loc 1 2241 0 is_stmt 1
 1585 083e 81E0      		ldi r24,lo8(1)
 1586 0840 8093 0000 		sts wasDaylightSavings,r24
2242:switcherator.c ****         globalHour++;
 1587               		.loc 1 2242 0
 1588 0844 8091 0000 		lds r24,globalHour
 1589 0848 9091 0000 		lds r25,globalHour+1
 1590 084c 0196      		adiw r24,1
 1591 084e 00C0      		rjmp .L100
 1592               	.L96:
2243:switcherator.c ****     } else if (globalMonth == daylightSavings[1][0] && globalDay == daylightSavings[1][1]) {
 1593               		.loc 1 2243 0
 1594 0850 2091 0000 		lds r18,daylightSavings+4
 1595 0854 3091 0000 		lds r19,daylightSavings+4+1
 1596 0858 8217      		cp r24,r18
 1597 085a 9307      		cpc r25,r19
 1598 085c 01F4      		brne .L94
 1599               		.loc 1 2243 0 is_stmt 0 discriminator 1
 1600 085e 2091 0000 		lds r18,globalDay
 1601 0862 3091 0000 		lds r19,globalDay+1
 1602 0866 8091 0000 		lds r24,daylightSavings+6
 1603 086a 9091 0000 		lds r25,daylightSavings+6+1
 1604 086e 2817      		cp r18,r24
 1605 0870 3907      		cpc r19,r25
 1606 0872 01F4      		brne .L94
2244:switcherator.c ****         wasDaylightSavings = 1;
 1607               		.loc 1 2244 0 is_stmt 1
 1608 0874 81E0      		ldi r24,lo8(1)
 1609 0876 8093 0000 		sts wasDaylightSavings,r24
2245:switcherator.c ****         globalHour--;
 1610               		.loc 1 2245 0
 1611 087a 8091 0000 		lds r24,globalHour
 1612 087e 9091 0000 		lds r25,globalHour+1
 1613 0882 0197      		sbiw r24,1
 1614               	.L100:
 1615 0884 9093 0000 		sts globalHour+1,r25
 1616 0888 8093 0000 		sts globalHour,r24
 1617               	.L94:
 1618 088c 0895      		ret
 1619               	.LFE55:
 1621               	.global	advanceDay
 1623               	advanceDay:
 1624               	.LFB56:
2246:switcherator.c ****     }
2247:switcherator.c **** }
2248:switcherator.c **** 
2249:switcherator.c **** // Advance a day in the calendar. 
2250:switcherator.c **** 
2251:switcherator.c **** void advanceDay(void) {
 1625               		.loc 1 2251 0
 1626               	/* prologue: function */
 1627               	/* frame size = 0 */
 1628               	/* stack size = 0 */
 1629               	.L__stack_usage = 0
 1630               	.LVL106:
2252:switcherator.c ****     int x = 0;
2253:switcherator.c ****     // Reset the daylight savings for next time
2254:switcherator.c ****     wasDaylightSavings = 0;
 1631               		.loc 1 2254 0
 1632 088e 1092 0000 		sts wasDaylightSavings,__zero_reg__
2255:switcherator.c ****     // start with dow
2256:switcherator.c ****     dow++;
 1633               		.loc 1 2256 0
 1634 0892 8091 0000 		lds r24,dow
 1635 0896 9091 0000 		lds r25,dow+1
 1636 089a 0196      		adiw r24,1
 1637 089c 9093 0000 		sts dow+1,r25
 1638 08a0 8093 0000 		sts dow,r24
2257:switcherator.c ****     if (dow == 7) {
 1639               		.loc 1 2257 0
 1640 08a4 0797      		sbiw r24,7
 1641 08a6 01F0      		breq .L102
 1642               	.LVL107:
 1643               	.L107:
2258:switcherator.c ****         // reset it to Sunday
2259:switcherator.c ****         dow = 0;
2260:switcherator.c ****         weeklySeconds = 0;
2261:switcherator.c ****         // switchStatus might be more than a week (604,800 seconds)
2262:switcherator.c ****         for (x = 0; x < NUM_SWITCHES; x++) {
2263:switcherator.c ****             if (switchStatus[x] >= 604800)
2264:switcherator.c ****                 switchStatus[x] -= 604800;
2265:switcherator.c ****         }
2266:switcherator.c ****     }
2267:switcherator.c ****     // then the day
2268:switcherator.c ****     globalDay++;
 1644               		.loc 1 2268 0
 1645 08a8 2091 0000 		lds r18,globalDay
 1646 08ac 3091 0000 		lds r19,globalDay+1
 1647 08b0 2F5F      		subi r18,-1
 1648 08b2 3F4F      		sbci r19,-1
 1649 08b4 3093 0000 		sts globalDay+1,r19
 1650 08b8 2093 0000 		sts globalDay,r18
2269:switcherator.c ****     // If we aren't advancing a month just move on
2270:switcherator.c ****     if (globalDay <= 28) {
 1651               		.loc 1 2270 0
 1652 08bc 2D31      		cpi r18,29
 1653 08be 3105      		cpc r19,__zero_reg__
 1654 08c0 00F4      		brsh .L140
 1655 08c2 0895      		ret
 1656               	.LVL108:
 1657               	.L102:
2259:switcherator.c ****         dow = 0;
 1658               		.loc 1 2259 0
 1659 08c4 1092 0000 		sts dow+1,__zero_reg__
 1660 08c8 1092 0000 		sts dow,__zero_reg__
2260:switcherator.c ****         weeklySeconds = 0;
 1661               		.loc 1 2260 0
 1662 08cc 1092 0000 		sts weeklySeconds,__zero_reg__
 1663 08d0 1092 0000 		sts weeklySeconds+1,__zero_reg__
 1664 08d4 1092 0000 		sts weeklySeconds+2,__zero_reg__
 1665 08d8 1092 0000 		sts weeklySeconds+3,__zero_reg__
 1666 08dc E0E0      		ldi r30,lo8(switchStatus)
 1667 08de F0E0      		ldi r31,hi8(switchStatus)
 1668               	.LVL109:
 1669               	.L106:
2263:switcherator.c ****             if (switchStatus[x] >= 604800)
 1670               		.loc 1 2263 0
 1671 08e0 8081      		ld r24,Z
 1672 08e2 9181      		ldd r25,Z+1
 1673 08e4 A281      		ldd r26,Z+2
 1674 08e6 B381      		ldd r27,Z+3
 1675 08e8 8038      		cpi r24,-128
 1676 08ea 2AE3      		ldi r18,58
 1677 08ec 9207      		cpc r25,r18
 1678 08ee 29E0      		ldi r18,9
 1679 08f0 A207      		cpc r26,r18
 1680 08f2 B105      		cpc r27,__zero_reg__
 1681 08f4 00F0      		brlo .L105
2264:switcherator.c ****                 switchStatus[x] -= 604800;
 1682               		.loc 1 2264 0
 1683 08f6 8058      		subi r24,-128
 1684 08f8 9A43      		sbci r25,58
 1685 08fa A940      		sbci r26,9
 1686 08fc B109      		sbc r27,__zero_reg__
 1687 08fe 8083      		st Z,r24
 1688 0900 9183      		std Z+1,r25
 1689 0902 A283      		std Z+2,r26
 1690 0904 B383      		std Z+3,r27
 1691               	.L105:
 1692 0906 3496      		adiw r30,4
2262:switcherator.c ****         for (x = 0; x < NUM_SWITCHES; x++) {
 1693               		.loc 1 2262 0
 1694 0908 80E0      		ldi r24,hi8(switchStatus+64)
 1695 090a E030      		cpi r30,lo8(switchStatus+64)
 1696 090c F807      		cpc r31,r24
 1697 090e 01F4      		brne .L106
 1698 0910 00C0      		rjmp .L107
 1699               	.L140:
2271:switcherator.c ****         return;
2272:switcherator.c ****     }
2273:switcherator.c ****     // possibly advancing a month
2274:switcherator.c ****     switch (globalMonth) {
 1700               		.loc 1 2274 0
 1701 0912 8091 0000 		lds r24,globalMonth
 1702 0916 9091 0000 		lds r25,globalMonth+1
 1703 091a 8630      		cpi r24,6
 1704 091c 9105      		cpc r25,__zero_reg__
 1705 091e 01F0      		breq .L110
 1706 0920 00F4      		brsh .L112
 1707 0922 8330      		cpi r24,3
 1708 0924 9105      		cpc r25,__zero_reg__
 1709 0926 01F0      		breq .L108
 1710 0928 00F4      		brsh .L113
 1711 092a 8130      		cpi r24,1
 1712 092c 9105      		cpc r25,__zero_reg__
 1713 092e 01F0      		breq .L108
 1714 0930 0297      		sbiw r24,2
 1715 0932 01F0      		breq .+2
 1716 0934 00C0      		rjmp .L101
 1717 0936 00C0      		rjmp .L109
 1718               	.L113:
 1719 0938 8430      		cpi r24,4
 1720 093a 9105      		cpc r25,__zero_reg__
 1721 093c 01F0      		breq .L110
 1722 093e 8530      		cpi r24,5
 1723 0940 9105      		cpc r25,__zero_reg__
 1724 0942 01F0      		breq .+2
 1725 0944 00C0      		rjmp .L101
 1726 0946 00C0      		rjmp .L108
 1727               	.L112:
 1728 0948 8930      		cpi r24,9
 1729 094a 9105      		cpc r25,__zero_reg__
 1730 094c 01F0      		breq .L110
 1731 094e 00F0      		brlo .L108
 1732 0950 8B30      		cpi r24,11
 1733 0952 9105      		cpc r25,__zero_reg__
 1734 0954 01F0      		breq .L110
 1735 0956 00F0      		brlo .L108
 1736 0958 0C97      		sbiw r24,12
 1737 095a 01F4      		brne .L101
 1738 095c 00C0      		rjmp .L111
 1739               	.L110:
2275:switcherator.c ****             // 30 days have september, april, june and november
2276:switcherator.c ****         case 4:
2277:switcherator.c ****         case 6:
2278:switcherator.c ****         case 9:
2279:switcherator.c ****         case 11:
2280:switcherator.c ****             if (globalDay > 30) {
 1740               		.loc 1 2280 0
 1741 095e 2F31      		cpi r18,31
 1742 0960 3105      		cpc r19,__zero_reg__
 1743 0962 00F0      		brlo .L101
 1744 0964 00C0      		rjmp .L142
 1745               	.L108:
2281:switcherator.c ****                 globalDay = 1;
2282:switcherator.c ****                 globalMonth++;
2283:switcherator.c ****             } else {
2284:switcherator.c ****                 return;
2285:switcherator.c ****             }
2286:switcherator.c ****             break;
2287:switcherator.c ****         case 1:
2288:switcherator.c ****         case 3:
2289:switcherator.c ****         case 5:
2290:switcherator.c ****         case 7:
2291:switcherator.c ****         case 8:
2292:switcherator.c ****         case 10:
2293:switcherator.c ****             if (globalDay > 31) {
 1746               		.loc 1 2293 0
 1747 0966 2032      		cpi r18,32
 1748 0968 3105      		cpc r19,__zero_reg__
 1749 096a 00F0      		brlo .L101
 1750               	.L142:
2294:switcherator.c ****                 globalDay = 1;
 1751               		.loc 1 2294 0
 1752 096c 21E0      		ldi r18,lo8(1)
 1753 096e 30E0      		ldi r19,0
 1754 0970 3093 0000 		sts globalDay+1,r19
 1755 0974 2093 0000 		sts globalDay,r18
2295:switcherator.c ****                 globalMonth++;
 1756               		.loc 1 2295 0
 1757 0978 0196      		adiw r24,1
 1758 097a 00C0      		rjmp .L141
 1759               	.L111:
2296:switcherator.c ****             } else {
2297:switcherator.c ****                 return;
2298:switcherator.c ****             }
2299:switcherator.c ****             break;
2300:switcherator.c ****         case 12:
2301:switcherator.c ****             if (globalDay > 31) {
 1760               		.loc 1 2301 0
 1761 097c 2032      		cpi r18,32
 1762 097e 3105      		cpc r19,__zero_reg__
 1763 0980 00F0      		brlo .L101
2302:switcherator.c ****                 // happy new year
2303:switcherator.c ****                 globalDay = 1;
 1764               		.loc 1 2303 0
 1765 0982 81E0      		ldi r24,lo8(1)
 1766 0984 90E0      		ldi r25,0
 1767 0986 9093 0000 		sts globalDay+1,r25
 1768 098a 8093 0000 		sts globalDay,r24
2304:switcherator.c ****                 globalMonth = 1;
 1769               		.loc 1 2304 0
 1770 098e 9093 0000 		sts globalMonth+1,r25
 1771 0992 8093 0000 		sts globalMonth,r24
2305:switcherator.c ****                 globalYear++;
 1772               		.loc 1 2305 0
 1773 0996 8091 0000 		lds r24,globalYear
 1774 099a 9091 0000 		lds r25,globalYear+1
 1775 099e 0196      		adiw r24,1
 1776 09a0 9093 0000 		sts globalYear+1,r25
 1777 09a4 8093 0000 		sts globalYear,r24
2306:switcherator.c ****             } else {
2307:switcherator.c ****                 return;
2308:switcherator.c ****             }
2309:switcherator.c ****             break;
 1778               		.loc 1 2309 0
 1779 09a8 0895      		ret
 1780               	.L109:
2310:switcherator.c ****         case 2:
2311:switcherator.c ****             // leap year?
2312:switcherator.c ****             if (globalYear % 4 == 0) {
 1781               		.loc 1 2312 0
 1782 09aa 8091 0000 		lds r24,globalYear
 1783 09ae 9091 0000 		lds r25,globalYear+1
 1784 09b2 8370      		andi r24,3
 1785 09b4 9927      		clr r25
 1786 09b6 892B      		or r24,r25
 1787 09b8 01F4      		brne .L114
2313:switcherator.c ****                 // yes
2314:switcherator.c ****                 if (globalDay > 29) {
 1788               		.loc 1 2314 0
 1789 09ba 2D31      		cpi r18,29
 1790 09bc 3105      		cpc r19,__zero_reg__
 1791 09be 01F0      		breq .L101
 1792               	.L114:
2315:switcherator.c ****                     globalDay = 1;
2316:switcherator.c ****                     globalMonth++;
2317:switcherator.c ****                 } else {
2318:switcherator.c ****                     return;
2319:switcherator.c ****                 }
2320:switcherator.c ****             } else {
2321:switcherator.c ****                 if (globalDay > 28) {
2322:switcherator.c ****                     globalDay = 1;
 1793               		.loc 1 2322 0
 1794 09c0 81E0      		ldi r24,lo8(1)
 1795 09c2 90E0      		ldi r25,0
 1796 09c4 9093 0000 		sts globalDay+1,r25
 1797 09c8 8093 0000 		sts globalDay,r24
2323:switcherator.c ****                     globalMonth++;
 1798               		.loc 1 2323 0
 1799 09cc 83E0      		ldi r24,lo8(3)
 1800 09ce 90E0      		ldi r25,0
 1801               	.L141:
 1802 09d0 9093 0000 		sts globalMonth+1,r25
 1803 09d4 8093 0000 		sts globalMonth,r24
 1804               	.L101:
 1805 09d8 0895      		ret
 1806               	.LFE56:
 1808               	.global	timerCheck
 1810               	timerCheck:
 1811               	.LFB57:
2324:switcherator.c ****                 } else {
2325:switcherator.c ****                     return;
2326:switcherator.c ****                 }
2327:switcherator.c ****             }
2328:switcherator.c ****             break;
2329:switcherator.c ****     }
2330:switcherator.c ****     return;
2331:switcherator.c **** }
2332:switcherator.c **** 
2333:switcherator.c **** // runs every second.  Checks to see if we need to turn something on or off
2334:switcherator.c **** 
2335:switcherator.c **** void timerCheck(void) {
 1812               		.loc 1 2335 0
 1813 09da 6F92      		push r6
 1814               	.LCFI37:
 1815 09dc 7F92      		push r7
 1816               	.LCFI38:
 1817 09de 8F92      		push r8
 1818               	.LCFI39:
 1819 09e0 9F92      		push r9
 1820               	.LCFI40:
 1821 09e2 AF92      		push r10
 1822               	.LCFI41:
 1823 09e4 BF92      		push r11
 1824               	.LCFI42:
 1825 09e6 CF92      		push r12
 1826               	.LCFI43:
 1827 09e8 DF92      		push r13
 1828               	.LCFI44:
 1829 09ea EF92      		push r14
 1830               	.LCFI45:
 1831 09ec FF92      		push r15
 1832               	.LCFI46:
 1833 09ee 0F93      		push r16
 1834               	.LCFI47:
 1835 09f0 1F93      		push r17
 1836               	.LCFI48:
 1837 09f2 CF93      		push r28
 1838               	.LCFI49:
 1839 09f4 DF93      		push r29
 1840               	.LCFI50:
 1841               	/* prologue: function */
 1842               	/* frame size = 0 */
 1843               	/* stack size = 14 */
 1844               	.L__stack_usage = 14
 1845               	.LVL110:
2336:switcherator.c ****     int x = 0;
2337:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
2338:switcherator.c ****         // see if something should turn off
2339:switcherator.c ****         if ((switchStatus[x] > 0) && (switchStatus[x] < weeklySeconds)) {
 1846               		.loc 1 2339 0
 1847 09f6 4091 0000 		lds r20,weeklySeconds
 1848 09fa 5091 0000 		lds r21,weeklySeconds+1
 1849 09fe 6091 0000 		lds r22,weeklySeconds+2
 1850 0a02 7091 0000 		lds r23,weeklySeconds+3
 1851 0a06 2091 0000 		lds r18,switchChanged
 1852 0a0a E0E0      		ldi r30,lo8(switchStatus)
 1853 0a0c F0E0      		ldi r31,hi8(switchStatus)
 1854               	.LVL111:
 1855               	.L145:
 1856 0a0e 8081      		ld r24,Z
 1857 0a10 9181      		ldd r25,Z+1
 1858 0a12 A281      		ldd r26,Z+2
 1859 0a14 B381      		ldd r27,Z+3
 1860 0a16 0097      		sbiw r24,0
 1861 0a18 A105      		cpc r26,__zero_reg__
 1862 0a1a B105      		cpc r27,__zero_reg__
 1863 0a1c 01F0      		breq .L144
 1864               		.loc 1 2339 0 is_stmt 0 discriminator 1
 1865 0a1e 8417      		cp r24,r20
 1866 0a20 9507      		cpc r25,r21
 1867 0a22 A607      		cpc r26,r22
 1868 0a24 B707      		cpc r27,r23
 1869 0a26 00F4      		brsh .L144
2340:switcherator.c ****             switchChanged = 1;
2341:switcherator.c ****             switchStatus[x] = 0;
 1870               		.loc 1 2341 0 is_stmt 1
 1871 0a28 1082      		st Z,__zero_reg__
 1872 0a2a 1182      		std Z+1,__zero_reg__
 1873 0a2c 1282      		std Z+2,__zero_reg__
 1874 0a2e 1382      		std Z+3,__zero_reg__
2340:switcherator.c ****             switchChanged = 1;
 1875               		.loc 1 2340 0
 1876 0a30 21E0      		ldi r18,lo8(1)
 1877               	.L144:
 1878 0a32 3496      		adiw r30,4
2337:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 1879               		.loc 1 2337 0
 1880 0a34 80E0      		ldi r24,hi8(switchStatus+64)
 1881 0a36 E030      		cpi r30,lo8(switchStatus+64)
 1882 0a38 F807      		cpc r31,r24
 1883 0a3a 01F4      		brne .L145
 1884 0a3c 2093 0000 		sts switchChanged,r18
 1885 0a40 C0E0      		ldi r28,lo8(weeklyProgram+4)
 1886 0a42 D0E0      		ldi r29,hi8(weeklyProgram+4)
 1887 0a44 00E0      		ldi r16,0
 1888 0a46 10E0      		ldi r17,0
2342:switcherator.c ****         }
2343:switcherator.c ****     }
2344:switcherator.c ****     // see if something should turn on
2345:switcherator.c ****     // weeklyProgram format
2346:switcherator.c ****     // DssddSSSSP
2347:switcherator.c ****     // 0123456789
2348:switcherator.c ****     long time;
2349:switcherator.c ****     int today = 0;
2350:switcherator.c ****     int duration = 0;
2351:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
2352:switcherator.c ****         // check if there is a valid program
2353:switcherator.c ****         if (weeklyProgram[x][0] != 255 && weeklyProgram[x][1] != 255) { // yes
2354:switcherator.c ****             // see if it goes today
2355:switcherator.c ****             // if dow = 0 (sunday) the program stores this as 0x40 then down from there
2356:switcherator.c ****             today = (0x40 >> dow);
 1889               		.loc 1 2356 0
 1890 0a48 30E4      		ldi r19,lo8(64)
 1891 0a4a C32E      		mov r12,r19
 1892 0a4c D12C      		mov r13,__zero_reg__
 1893               	.L147:
2335:switcherator.c **** void timerCheck(void) {
 1894               		.loc 1 2335 0
 1895 0a4e FE01      		movw r30,r28
 1896 0a50 3497      		sbiw r30,4
2353:switcherator.c ****         if (weeklyProgram[x][0] != 255 && weeklyProgram[x][1] != 255) { // yes
 1897               		.loc 1 2353 0
 1898 0a52 8081      		ld r24,Z
 1899 0a54 8F3F      		cpi r24,lo8(-1)
 1900 0a56 01F4      		brne .+2
 1901 0a58 00C0      		rjmp .L146
2335:switcherator.c **** void timerCheck(void) {
 1902               		.loc 1 2335 0 discriminator 1
 1903 0a5a FE01      		movw r30,r28
 1904 0a5c 3397      		sbiw r30,3
2353:switcherator.c ****         if (weeklyProgram[x][0] != 255 && weeklyProgram[x][1] != 255) { // yes
 1905               		.loc 1 2353 0 discriminator 1
 1906 0a5e 2081      		ld r18,Z
 1907 0a60 2F3F      		cpi r18,lo8(-1)
 1908 0a62 01F4      		brne .+2
 1909 0a64 00C0      		rjmp .L146
 1910               		.loc 1 2356 0
 1911 0a66 7090 0000 		lds r7,dow
 1912 0a6a 6090 0000 		lds r6,dow+1
 1913               	.LVL112:
2357:switcherator.c ****             // k is today the day?
2358:switcherator.c ****             if (weeklyProgram[x][0] & today) {
 1914               		.loc 1 2358 0
 1915 0a6e 90E0      		ldi r25,0
2356:switcherator.c ****             today = (0x40 >> dow);
 1916               		.loc 1 2356 0
 1917 0a70 A601      		movw r20,r12
 1918 0a72 072C      		mov r0,r7
 1919 0a74 00C0      		rjmp 2f
 1920               		1:
 1921 0a76 5595      		asr r21
 1922 0a78 4795      		ror r20
 1923               		2:
 1924 0a7a 0A94      		dec r0
 1925 0a7c 02F4      		brpl 1b
 1926               		.loc 1 2358 0
 1927 0a7e 8423      		and r24,r20
 1928 0a80 9523      		and r25,r21
 1929 0a82 892B      		or r24,r25
 1930 0a84 01F4      		brne .+2
 1931 0a86 00C0      		rjmp .L146
2359:switcherator.c **** 
2360:switcherator.c ****                 // yes we run today
2361:switcherator.c ****                 time = weeklyProgram[x][1];
 1932               		.loc 1 2361 0
 1933 0a88 822F      		mov r24,r18
 1934 0a8a 90E0      		ldi r25,0
 1935 0a8c A0E0      		ldi r26,0
 1936 0a8e B0E0      		ldi r27,0
 1937               	.LVL113:
2362:switcherator.c ****                 time <<= 8;
 1938               		.loc 1 2362 0
 1939 0a90 2227      		clr r18
 1940 0a92 382F      		mov r19,r24
 1941 0a94 492F      		mov r20,r25
 1942 0a96 5A2F      		mov r21,r26
 1943               	.LVL114:
2335:switcherator.c **** void timerCheck(void) {
 1944               		.loc 1 2335 0
 1945 0a98 FE01      		movw r30,r28
 1946 0a9a 3297      		sbiw r30,2
2363:switcherator.c ****                 time |= weeklyProgram[x][2];
 1947               		.loc 1 2363 0
 1948 0a9c 8081      		ld r24,Z
 1949 0a9e 282B      		or r18,r24
 1950               	.LVL115:
2364:switcherator.c ****                 // weeklyProgram is stored in minutes
2365:switcherator.c ****                 time *= 60;
 1951               		.loc 1 2365 0
 1952 0aa0 ACE3      		ldi r26,lo8(60)
 1953 0aa2 B0E0      		ldi r27,0
 1954 0aa4 0E94 0000 		call __muluhisi3
 1955 0aa8 4B01      		movw r8,r22
 1956 0aaa 5C01      		movw r10,r24
 1957               	.LVL116:
2335:switcherator.c **** void timerCheck(void) {
 1958               		.loc 1 2335 0
 1959 0aac FE01      		movw r30,r28
 1960 0aae 3197      		sbiw r30,1
2366:switcherator.c ****                 duration = weeklyProgram[x][3];
 1961               		.loc 1 2366 0
 1962 0ab0 F081      		ld r31,Z
 1963               	.LVL117:
2367:switcherator.c ****                 duration <<= 8;
2368:switcherator.c ****                 duration |= weeklyProgram[x][4];
 1964               		.loc 1 2368 0
 1965 0ab2 E881      		ld r30,Y
 1966               	.LVL118:
2369:switcherator.c ****                 time += (dow * 86400); //seconds in day
 1967               		.loc 1 2369 0
 1968 0ab4 A72D      		mov r26,r7
 1969 0ab6 B62D      		mov r27,r6
 1970 0ab8 20E8      		ldi r18,lo8(-128)
 1971 0aba 31E5      		ldi r19,lo8(81)
 1972 0abc 41E0      		ldi r20,lo8(1)
 1973 0abe 50E0      		ldi r21,0
 1974 0ac0 0E94 0000 		call __muluhisi3
 1975 0ac4 860E      		add r8,r22
 1976 0ac6 971E      		adc r9,r23
 1977 0ac8 A81E      		adc r10,r24
 1978 0aca B91E      		adc r11,r25
 1979               	.LVL119:
2370:switcherator.c ****                 // check if we are between start & stop time
2371:switcherator.c ****                 if ((weeklySeconds >= time) && (weeklySeconds < (time + duration))) {
 1980               		.loc 1 2371 0
 1981 0acc 4091 0000 		lds r20,weeklySeconds
 1982 0ad0 5091 0000 		lds r21,weeklySeconds+1
 1983 0ad4 6091 0000 		lds r22,weeklySeconds+2
 1984 0ad8 7091 0000 		lds r23,weeklySeconds+3
 1985 0adc 4815      		cp r20,r8
 1986 0ade 5905      		cpc r21,r9
 1987 0ae0 6A05      		cpc r22,r10
 1988 0ae2 7B05      		cpc r23,r11
 1989 0ae4 00F0      		brlo .L146
2367:switcherator.c ****                 duration <<= 8;
 1990               		.loc 1 2367 0 discriminator 1
 1991 0ae6 FF2E      		mov r15,r31
 1992 0ae8 E12C      		mov r14,__zero_reg__
2368:switcherator.c ****                 duration |= weeklyProgram[x][4];
 1993               		.loc 1 2368 0 discriminator 1
 1994 0aea C701      		movw r24,r14
 1995 0aec 8E2B      		or r24,r30
 1996               		.loc 1 2371 0 discriminator 1
 1997 0aee AA27      		clr r26
 1998 0af0 97FD      		sbrc r25,7
 1999 0af2 A095      		com r26
 2000 0af4 BA2F      		mov r27,r26
 2001 0af6 880D      		add r24,r8
 2002 0af8 991D      		adc r25,r9
 2003 0afa AA1D      		adc r26,r10
 2004 0afc BB1D      		adc r27,r11
 2005 0afe 4817      		cp r20,r24
 2006 0b00 5907      		cpc r21,r25
 2007 0b02 6A07      		cpc r22,r26
 2008 0b04 7B07      		cpc r23,r27
 2009 0b06 00F4      		brsh .L146
2372:switcherator.c ****                     // feed time to it so the end time won't change
2373:switcherator.c ****                     startTheProgram(x, 0, time);
 2010               		.loc 1 2373 0
 2011 0b08 A501      		movw r20,r10
 2012 0b0a 9401      		movw r18,r8
 2013 0b0c 60E0      		ldi r22,0
 2014 0b0e 70E0      		ldi r23,0
 2015 0b10 C801      		movw r24,r16
 2016 0b12 0E94 0000 		call startTheProgram
 2017               	.LVL120:
 2018               	.L146:
2351:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 2019               		.loc 1 2351 0
 2020 0b16 0F5F      		subi r16,-1
 2021 0b18 1F4F      		sbci r17,-1
 2022               	.LVL121:
 2023 0b1a 2A96      		adiw r28,10
 2024 0b1c 0A30      		cpi r16,10
 2025 0b1e 1105      		cpc r17,__zero_reg__
 2026 0b20 01F0      		breq .+2
 2027 0b22 00C0      		rjmp .L147
 2028               	/* epilogue start */
2374:switcherator.c ****                 }
2375:switcherator.c ****             }
2376:switcherator.c ****         }
2377:switcherator.c ****     }
2378:switcherator.c **** }
 2029               		.loc 1 2378 0
 2030 0b24 DF91      		pop r29
 2031 0b26 CF91      		pop r28
 2032 0b28 1F91      		pop r17
 2033 0b2a 0F91      		pop r16
 2034               	.LVL122:
 2035 0b2c FF90      		pop r15
 2036 0b2e EF90      		pop r14
 2037 0b30 DF90      		pop r13
 2038 0b32 CF90      		pop r12
 2039 0b34 BF90      		pop r11
 2040 0b36 AF90      		pop r10
 2041 0b38 9F90      		pop r9
 2042 0b3a 8F90      		pop r8
 2043 0b3c 7F90      		pop r7
 2044 0b3e 6F90      		pop r6
 2045 0b40 0895      		ret
 2046               	.LFE57:
 2048               	.global	switchOnOff
 2050               	switchOnOff:
 2051               	.LFB58:
2379:switcherator.c **** 
2380:switcherator.c **** // iterate through the switches and turn them on or off
2381:switcherator.c **** 
2382:switcherator.c **** void switchOnOff(void) {
 2052               		.loc 1 2382 0
 2053 0b42 7F92      		push r7
 2054               	.LCFI51:
 2055 0b44 8F92      		push r8
 2056               	.LCFI52:
 2057 0b46 9F92      		push r9
 2058               	.LCFI53:
 2059 0b48 AF92      		push r10
 2060               	.LCFI54:
 2061 0b4a BF92      		push r11
 2062               	.LCFI55:
 2063 0b4c CF92      		push r12
 2064               	.LCFI56:
 2065 0b4e DF92      		push r13
 2066               	.LCFI57:
 2067 0b50 EF92      		push r14
 2068               	.LCFI58:
 2069 0b52 FF92      		push r15
 2070               	.LCFI59:
 2071 0b54 0F93      		push r16
 2072               	.LCFI60:
 2073 0b56 1F93      		push r17
 2074               	.LCFI61:
 2075 0b58 CF93      		push r28
 2076               	.LCFI62:
 2077 0b5a DF93      		push r29
 2078               	.LCFI63:
 2079 0b5c 00D0      		rcall .
 2080 0b5e 1F92      		push __zero_reg__
 2081               	.LCFI64:
 2082 0b60 CDB7      		in r28,__SP_L__
 2083 0b62 DEB7      		in r29,__SP_H__
 2084               	.LCFI65:
 2085               	/* prologue: function */
 2086               	/* frame size = 3 */
 2087               	/* stack size = 16 */
 2088               	.L__stack_usage = 16
 2089               	.LVL123:
 2090 0b64 10E0      		ldi r17,lo8(switchStuff)
 2091 0b66 812E      		mov r8,r17
 2092 0b68 10E0      		ldi r17,hi8(switchStuff)
 2093 0b6a 912E      		mov r9,r17
 2094 0b6c 00E0      		ldi r16,lo8(switchStatus)
 2095 0b6e C02E      		mov r12,r16
 2096 0b70 00E0      		ldi r16,hi8(switchStatus)
 2097 0b72 D02E      		mov r13,r16
2383:switcherator.c ****     char port[1];
2384:switcherator.c ****     char pin[1];
2385:switcherator.c ****     int realPin = 0;
2386:switcherator.c ****     int x = 0;
2387:switcherator.c ****     char direction[1];
2388:switcherator.c ****     volatile unsigned char *thisPort = 0;
 2098               		.loc 1 2388 0
 2099 0b74 00E0      		ldi r16,0
 2100 0b76 10E0      		ldi r17,0
2389:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 2101               		.loc 1 2389 0
 2102 0b78 E12C      		mov r14,__zero_reg__
 2103 0b7a F12C      		mov r15,__zero_reg__
2390:switcherator.c ****         // see if a switch is set up
2391:switcherator.c ****         if (switchStuff[x] != 255) {
2392:switcherator.c ****             // find out if this is pwm
2393:switcherator.c ****             if (switchStuff[x] >= 200 && switchStuff[x] <= 220) {
2394:switcherator.c ****                 // are we turning it on or off
2395:switcherator.c ****                 if (switchStatus[x] == 0) {
2396:switcherator.c ****                     // turning it off
2397:switcherator.c ****                     if (switchStuff[x] == 200) {
2398:switcherator.c ****                         Red = 0;
2399:switcherator.c ****                         Green = 0;
2400:switcherator.c ****                         Blue = 0;
2401:switcherator.c ****                     } else if (switchStuff[x] == 201) {
2402:switcherator.c ****                         Red = 0;
2403:switcherator.c ****                         Green = 0;
2404:switcherator.c ****                         Blue = 0;
2405:switcherator.c ****                         runHue = 0;
2406:switcherator.c ****                     } else if (switchStuff[x] == 202) {
2407:switcherator.c ****                         Red = 0;
2408:switcherator.c ****                         Green = 0;
2409:switcherator.c ****                         Blue = 0;
2410:switcherator.c ****                         runColorChanges = 0;
2411:switcherator.c ****                     } else if (switchStuff[x] == 212) {
2412:switcherator.c ****                         bright = oldBright;
2413:switcherator.c ****                     }
2414:switcherator.c ****                 } else {
2415:switcherator.c ****                     // turn it on
2416:switcherator.c ****                     // decide if it is a changing hue or static values
2417:switcherator.c ****                     if (switchStuff[x] == 200) {
2418:switcherator.c ****                         // even numbers are static colors;
2419:switcherator.c ****                         red = pwmValues[0];
2420:switcherator.c ****                         green = pwmValues[1];
2421:switcherator.c ****                         blue = pwmValues[2];
2422:switcherator.c ****                         red = red * bright / 16;
2423:switcherator.c ****                         green = green * bright / 16;
2424:switcherator.c ****                         blue = blue * bright / 16;
2425:switcherator.c ****                         Red = red;
2426:switcherator.c ****                         Green = green;
2427:switcherator.c ****                         Blue = blue;
2428:switcherator.c ****                     } else if (switchStuff[x] == 202) {
2429:switcherator.c ****                         runColorChanges = 1;
2430:switcherator.c ****                     } else if (switchStuff[x] == 212) {
2431:switcherator.c ****                         // change the brightness
2432:switcherator.c ****                         bright = switchBright[x];
2433:switcherator.c ****                     } else {
2434:switcherator.c ****                         // get the hue cycle going
2435:switcherator.c ****                         runHue = 1;
2436:switcherator.c ****                     }
2437:switcherator.c ****                 }
2438:switcherator.c ****                 continue;
2439:switcherator.c ****             }
2440:switcherator.c ****             // switch is set up. Get details
2441:switcherator.c ****             getPort(x, port, pin, direction);
2442:switcherator.c ****             // yeah pointers and casts and whatevers. this fixes it
2443:switcherator.c ****             realPin = pin[0];
2444:switcherator.c ****             if (port[0] == 'B')
2445:switcherator.c ****                 thisPort = &PORTB;
2446:switcherator.c **** #ifdef PORTA
2447:switcherator.c ****             else if (port[0] == 'A')
2448:switcherator.c ****                 thisPort = &PORTA;
2449:switcherator.c **** #endif
2450:switcherator.c **** #ifdef PORTC
2451:switcherator.c ****             else if (port[0] == 'C')
2452:switcherator.c ****                 thisPort = &PORTC;
2453:switcherator.c **** #endif
2454:switcherator.c **** #ifdef PORTD
2455:switcherator.c ****             else if (port[0] == 'D')
2456:switcherator.c ****                 thisPort = &PORTD;
2457:switcherator.c **** #endif
2458:switcherator.c **** #ifdef PORTE
2459:switcherator.c ****             else if (port[0] == 'E')
2460:switcherator.c ****                 thisPort = &PORTE;
2461:switcherator.c **** #endif
2462:switcherator.c **** #ifdef PORTF
2463:switcherator.c ****             else if (port[0] == 'F')
2464:switcherator.c ****                 thisPort = &PORTF;
2465:switcherator.c **** #endif
2466:switcherator.c **** #ifdef PORTG
2467:switcherator.c ****             else if (port[0] == 'G')
2468:switcherator.c ****                 thisPort = &PORTG;
2469:switcherator.c **** #endif
2470:switcherator.c **** #ifdef PORTH
2471:switcherator.c ****             else if (port[0] == 'H')
2472:switcherator.c ****                 thisPort = &PORTH;
2473:switcherator.c **** #endif
2474:switcherator.c **** #ifdef PORTI
2475:switcherator.c ****             else if (port[0] == 'I')
2476:switcherator.c ****                 thisPort = &PORTI;
2477:switcherator.c **** #endif
2478:switcherator.c ****             // k we have the port - now decide if we are turning it on or off and turn it on/off
2479:switcherator.c ****             if (switchStatus[x] == 0) {
2480:switcherator.c ****                 // turning it off
2481:switcherator.c ****                 if (direction[0] == 0) {
2482:switcherator.c ****                     *thisPort |= (1 << realPin);
2483:switcherator.c ****                 } else {
2484:switcherator.c ****                     *thisPort &= ~(1 << realPin);
2485:switcherator.c ****                 }
2486:switcherator.c ****             } else {
2487:switcherator.c ****                 // turning it on
2488:switcherator.c ****                 if (direction[0] == 0) {
2489:switcherator.c ****                     *thisPort &= ~(1 << realPin);
2490:switcherator.c ****                 } else {
2491:switcherator.c ****                     *thisPort |= (1 << realPin);
 2104               		.loc 1 2491 0
 2105 0b7c AA24      		clr r10
 2106 0b7e A394      		inc r10
 2107 0b80 B12C      		mov r11,__zero_reg__
2435:switcherator.c ****                         runHue = 1;
 2108               		.loc 1 2435 0
 2109 0b82 7724      		clr r7
 2110 0b84 7394      		inc r7
 2111               	.LVL124:
 2112               	.L176:
2391:switcherator.c ****         if (switchStuff[x] != 255) {
 2113               		.loc 1 2391 0
 2114 0b86 F401      		movw r30,r8
 2115 0b88 2191      		ld r18,Z+
 2116 0b8a 4F01      		movw r8,r30
 2117 0b8c 2F3F      		cpi r18,lo8(-1)
 2118 0b8e 01F4      		brne .+2
 2119 0b90 00C0      		rjmp .L163
2393:switcherator.c ****             if (switchStuff[x] >= 200 && switchStuff[x] <= 220) {
 2120               		.loc 1 2393 0
 2121 0b92 822F      		mov r24,r18
 2122 0b94 885C      		subi r24,lo8(-(56))
 2123 0b96 8531      		cpi r24,lo8(21)
 2124 0b98 00F0      		brlo .+2
 2125 0b9a 00C0      		rjmp .L164
2395:switcherator.c ****                 if (switchStatus[x] == 0) {
 2126               		.loc 1 2395 0
 2127 0b9c F601      		movw r30,r12
 2128 0b9e 8081      		ld r24,Z
 2129 0ba0 9181      		ldd r25,Z+1
 2130 0ba2 A281      		ldd r26,Z+2
 2131 0ba4 B381      		ldd r27,Z+3
 2132 0ba6 892B      		or r24,r25
 2133 0ba8 8A2B      		or r24,r26
 2134 0baa 8B2B      		or r24,r27
 2135 0bac 01F4      		brne .L165
2397:switcherator.c ****                     if (switchStuff[x] == 200) {
 2136               		.loc 1 2397 0
 2137 0bae 283C      		cpi r18,lo8(-56)
 2138 0bb0 01F4      		brne .L166
2398:switcherator.c ****                         Red = 0;
 2139               		.loc 1 2398 0
 2140 0bb2 1092 B400 		sts 180,__zero_reg__
2399:switcherator.c ****                         Green = 0;
 2141               		.loc 1 2399 0
 2142 0bb6 18BC      		out 0x28,__zero_reg__
2400:switcherator.c ****                         Blue = 0;
 2143               		.loc 1 2400 0
 2144 0bb8 17BC      		out 0x27,__zero_reg__
 2145 0bba 00C0      		rjmp .L163
 2146               	.L166:
2401:switcherator.c ****                     } else if (switchStuff[x] == 201) {
 2147               		.loc 1 2401 0
 2148 0bbc 293C      		cpi r18,lo8(-55)
 2149 0bbe 01F4      		brne .L167
2402:switcherator.c ****                         Red = 0;
 2150               		.loc 1 2402 0
 2151 0bc0 1092 B400 		sts 180,__zero_reg__
2403:switcherator.c ****                         Green = 0;
 2152               		.loc 1 2403 0
 2153 0bc4 18BC      		out 0x28,__zero_reg__
2404:switcherator.c ****                         Blue = 0;
 2154               		.loc 1 2404 0
 2155 0bc6 17BC      		out 0x27,__zero_reg__
2405:switcherator.c ****                         runHue = 0;
 2156               		.loc 1 2405 0
 2157 0bc8 1092 0000 		sts runHue,__zero_reg__
 2158 0bcc 00C0      		rjmp .L163
 2159               	.L167:
2406:switcherator.c ****                     } else if (switchStuff[x] == 202) {
 2160               		.loc 1 2406 0
 2161 0bce 2A3C      		cpi r18,lo8(-54)
 2162 0bd0 01F4      		brne .L168
2407:switcherator.c ****                         Red = 0;
 2163               		.loc 1 2407 0
 2164 0bd2 1092 B400 		sts 180,__zero_reg__
2408:switcherator.c ****                         Green = 0;
 2165               		.loc 1 2408 0
 2166 0bd6 18BC      		out 0x28,__zero_reg__
2409:switcherator.c ****                         Blue = 0;
 2167               		.loc 1 2409 0
 2168 0bd8 17BC      		out 0x27,__zero_reg__
2410:switcherator.c ****                         runColorChanges = 0;
 2169               		.loc 1 2410 0
 2170 0bda 1092 0000 		sts runColorChanges,__zero_reg__
 2171 0bde 00C0      		rjmp .L163
 2172               	.L168:
2411:switcherator.c ****                     } else if (switchStuff[x] == 212) {
 2173               		.loc 1 2411 0
 2174 0be0 243D      		cpi r18,lo8(-44)
 2175 0be2 01F0      		breq .+2
 2176 0be4 00C0      		rjmp .L163
2412:switcherator.c ****                         bright = oldBright;
 2177               		.loc 1 2412 0
 2178 0be6 8091 0000 		lds r24,oldBright
 2179 0bea 00C0      		rjmp .L184
 2180               	.L165:
2417:switcherator.c ****                     if (switchStuff[x] == 200) {
 2181               		.loc 1 2417 0
 2182 0bec 283C      		cpi r18,lo8(-56)
 2183 0bee 01F4      		brne .L169
2420:switcherator.c ****                         green = pwmValues[1];
 2184               		.loc 1 2420 0
 2185 0bf0 8091 0000 		lds r24,pwmValues+1
2421:switcherator.c ****                         blue = pwmValues[2];
 2186               		.loc 1 2421 0
 2187 0bf4 E091 0000 		lds r30,pwmValues+2
2422:switcherator.c ****                         red = red * bright / 16;
 2188               		.loc 1 2422 0
 2189 0bf8 6091 0000 		lds r22,bright
 2190 0bfc 7091 0000 		lds r23,bright+1
2419:switcherator.c ****                         red = pwmValues[0];
 2191               		.loc 1 2419 0
 2192 0c00 9091 0000 		lds r25,pwmValues
2422:switcherator.c ****                         red = red * bright / 16;
 2193               		.loc 1 2422 0
 2194 0c04 969F      		mul r25,r22
 2195 0c06 A001      		movw r20,r0
 2196 0c08 979F      		mul r25,r23
 2197 0c0a 500D      		add r21,r0
 2198 0c0c 1124      		clr __zero_reg__
 2199 0c0e F4E0      		ldi r31,4
 2200               		1:
 2201 0c10 5695      		lsr r21
 2202 0c12 4795      		ror r20
 2203 0c14 FA95      		dec r31
 2204 0c16 01F4      		brne 1b
 2205 0c18 5093 0000 		sts red+1,r21
 2206 0c1c 4093 0000 		sts red,r20
2423:switcherator.c ****                         green = green * bright / 16;
 2207               		.loc 1 2423 0
 2208 0c20 869F      		mul r24,r22
 2209 0c22 9001      		movw r18,r0
 2210 0c24 879F      		mul r24,r23
 2211 0c26 300D      		add r19,r0
 2212 0c28 1124      		clr __zero_reg__
 2213 0c2a A4E0      		ldi r26,4
 2214               		1:
 2215 0c2c 3695      		lsr r19
 2216 0c2e 2795      		ror r18
 2217 0c30 AA95      		dec r26
 2218 0c32 01F4      		brne 1b
 2219 0c34 3093 0000 		sts green+1,r19
 2220 0c38 2093 0000 		sts green,r18
2424:switcherator.c ****                         blue = blue * bright / 16;
 2221               		.loc 1 2424 0
 2222 0c3c E69F      		mul r30,r22
 2223 0c3e C001      		movw r24,r0
 2224 0c40 E79F      		mul r30,r23
 2225 0c42 900D      		add r25,r0
 2226 0c44 1124      		clr __zero_reg__
 2227 0c46 B4E0      		ldi r27,4
 2228               		1:
 2229 0c48 9695      		lsr r25
 2230 0c4a 8795      		ror r24
 2231 0c4c BA95      		dec r27
 2232 0c4e 01F4      		brne 1b
 2233 0c50 9093 0000 		sts blue+1,r25
 2234 0c54 8093 0000 		sts blue,r24
2425:switcherator.c ****                         Red = red;
 2235               		.loc 1 2425 0
 2236 0c58 4093 B400 		sts 180,r20
2426:switcherator.c ****                         Green = green;
 2237               		.loc 1 2426 0
 2238 0c5c 28BD      		out 0x28,r18
2427:switcherator.c ****                         Blue = blue;
 2239               		.loc 1 2427 0
 2240 0c5e 87BD      		out 0x27,r24
 2241 0c60 00C0      		rjmp .L163
 2242               	.L169:
2428:switcherator.c ****                     } else if (switchStuff[x] == 202) {
 2243               		.loc 1 2428 0
 2244 0c62 2A3C      		cpi r18,lo8(-54)
 2245 0c64 01F4      		brne .L170
2429:switcherator.c ****                         runColorChanges = 1;
 2246               		.loc 1 2429 0
 2247 0c66 7092 0000 		sts runColorChanges,r7
 2248 0c6a 00C0      		rjmp .L163
 2249               	.L170:
2430:switcherator.c ****                     } else if (switchStuff[x] == 212) {
 2250               		.loc 1 2430 0
 2251 0c6c 243D      		cpi r18,lo8(-44)
 2252 0c6e 01F4      		brne .L171
2382:switcherator.c **** void switchOnOff(void) {
 2253               		.loc 1 2382 0
 2254 0c70 F701      		movw r30,r14
 2255 0c72 E050      		subi r30,lo8(-(switchBright))
 2256 0c74 F040      		sbci r31,hi8(-(switchBright))
2432:switcherator.c ****                         bright = switchBright[x];
 2257               		.loc 1 2432 0
 2258 0c76 8081      		ld r24,Z
 2259               	.L184:
 2260 0c78 8093 0000 		sts bright,r24
 2261 0c7c 1092 0000 		sts bright+1,__zero_reg__
 2262 0c80 00C0      		rjmp .L163
 2263               	.L171:
2435:switcherator.c ****                         runHue = 1;
 2264               		.loc 1 2435 0
 2265 0c82 7092 0000 		sts runHue,r7
 2266 0c86 00C0      		rjmp .L163
 2267               	.L164:
2441:switcherator.c ****             getPort(x, port, pin, direction);
 2268               		.loc 1 2441 0
 2269 0c88 9E01      		movw r18,r28
 2270 0c8a 2F5F      		subi r18,-1
 2271 0c8c 3F4F      		sbci r19,-1
 2272 0c8e AE01      		movw r20,r28
 2273 0c90 4E5F      		subi r20,-2
 2274 0c92 5F4F      		sbci r21,-1
 2275 0c94 BE01      		movw r22,r28
 2276 0c96 6D5F      		subi r22,-3
 2277 0c98 7F4F      		sbci r23,-1
 2278 0c9a C701      		movw r24,r14
 2279 0c9c 0E94 0000 		call getPort
 2280               	.LVL125:
2443:switcherator.c ****             realPin = pin[0];
 2281               		.loc 1 2443 0
 2282 0ca0 2A81      		ldd r18,Y+2
2444:switcherator.c ****             if (port[0] == 'B')
 2283               		.loc 1 2444 0
 2284 0ca2 8B81      		ldd r24,Y+3
 2285 0ca4 8234      		cpi r24,lo8(66)
 2286 0ca6 01F0      		breq .L177
2451:switcherator.c ****             else if (port[0] == 'C')
 2287               		.loc 1 2451 0
 2288 0ca8 8334      		cpi r24,lo8(67)
 2289 0caa 01F0      		breq .L178
2455:switcherator.c ****             else if (port[0] == 'D')
 2290               		.loc 1 2455 0
 2291 0cac 8434      		cpi r24,lo8(68)
 2292 0cae 01F4      		brne .L172
 2293 0cb0 00C0      		rjmp .L179
 2294               	.L177:
2445:switcherator.c ****                 thisPort = &PORTB;
 2295               		.loc 1 2445 0
 2296 0cb2 05E2      		ldi r16,lo8(37)
 2297 0cb4 10E0      		ldi r17,0
 2298 0cb6 00C0      		rjmp .L172
 2299               	.L178:
2452:switcherator.c ****                 thisPort = &PORTC;
 2300               		.loc 1 2452 0
 2301 0cb8 08E2      		ldi r16,lo8(40)
 2302 0cba 10E0      		ldi r17,0
 2303 0cbc 00C0      		rjmp .L172
 2304               	.L179:
2456:switcherator.c ****                 thisPort = &PORTD;
 2305               		.loc 1 2456 0
 2306 0cbe 0BE2      		ldi r16,lo8(43)
 2307 0cc0 10E0      		ldi r17,0
 2308               	.L172:
 2309               	.LVL126:
2479:switcherator.c ****             if (switchStatus[x] == 0) {
 2310               		.loc 1 2479 0
 2311 0cc2 F601      		movw r30,r12
 2312 0cc4 8081      		ld r24,Z
 2313 0cc6 9181      		ldd r25,Z+1
 2314 0cc8 A281      		ldd r26,Z+2
 2315 0cca B381      		ldd r27,Z+3
 2316 0ccc 3981      		ldd r19,Y+1
2482:switcherator.c ****                     *thisPort |= (1 << realPin);
 2317               		.loc 1 2482 0
 2318 0cce F801      		movw r30,r16
2479:switcherator.c ****             if (switchStatus[x] == 0) {
 2319               		.loc 1 2479 0
 2320 0cd0 892B      		or r24,r25
 2321 0cd2 8A2B      		or r24,r26
 2322 0cd4 8B2B      		or r24,r27
 2323 0cd6 01F4      		brne .L173
2481:switcherator.c ****                 if (direction[0] == 0) {
 2324               		.loc 1 2481 0
 2325 0cd8 3111      		cpse r19,__zero_reg__
 2326 0cda 00C0      		rjmp .L186
 2327 0cdc 00C0      		rjmp .L175
 2328               	.L173:
2488:switcherator.c ****                 if (direction[0] == 0) {
 2329               		.loc 1 2488 0
 2330 0cde 3111      		cpse r19,__zero_reg__
 2331 0ce0 00C0      		rjmp .L175
 2332               	.L186:
2489:switcherator.c ****                     *thisPort &= ~(1 << realPin);
 2333               		.loc 1 2489 0
 2334 0ce2 3081      		ld r19,Z
 2335 0ce4 C501      		movw r24,r10
 2336 0ce6 022E      		mov r0,r18
 2337 0ce8 00C0      		rjmp 2f
 2338               		1:
 2339 0cea 880F      		lsl r24
 2340               		2:
 2341 0cec 0A94      		dec r0
 2342 0cee 02F4      		brpl 1b
 2343 0cf0 8095      		com r24
 2344 0cf2 3823      		and r19,r24
 2345 0cf4 00C0      		rjmp .L185
 2346               	.L175:
 2347               		.loc 1 2491 0
 2348 0cf6 3081      		ld r19,Z
 2349 0cf8 C501      		movw r24,r10
 2350 0cfa 022E      		mov r0,r18
 2351 0cfc 00C0      		rjmp 2f
 2352               		1:
 2353 0cfe 880F      		lsl r24
 2354               		2:
 2355 0d00 0A94      		dec r0
 2356 0d02 02F4      		brpl 1b
 2357 0d04 382B      		or r19,r24
 2358               	.L185:
 2359 0d06 3083      		st Z,r19
 2360               	.LVL127:
 2361               	.L163:
2389:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 2362               		.loc 1 2389 0
 2363 0d08 FFEF      		ldi r31,-1
 2364 0d0a EF1A      		sub r14,r31
 2365 0d0c FF0A      		sbc r15,r31
 2366               	.LVL128:
 2367 0d0e 84E0      		ldi r24,4
 2368 0d10 C80E      		add r12,r24
 2369 0d12 D11C      		adc r13,__zero_reg__
 2370 0d14 E0E1      		ldi r30,16
 2371 0d16 EE16      		cp r14,r30
 2372 0d18 F104      		cpc r15,__zero_reg__
 2373 0d1a 01F0      		breq .+2
 2374 0d1c 00C0      		rjmp .L176
 2375               	/* epilogue start */
2492:switcherator.c ****                 }
2493:switcherator.c ****             }
2494:switcherator.c ****         }
2495:switcherator.c ****     }
2496:switcherator.c **** }
 2376               		.loc 1 2496 0
 2377 0d1e 0F90      		pop __tmp_reg__
 2378 0d20 0F90      		pop __tmp_reg__
 2379 0d22 0F90      		pop __tmp_reg__
 2380 0d24 DF91      		pop r29
 2381 0d26 CF91      		pop r28
 2382 0d28 1F91      		pop r17
 2383 0d2a 0F91      		pop r16
 2384               	.LVL129:
 2385 0d2c FF90      		pop r15
 2386 0d2e EF90      		pop r14
 2387               	.LVL130:
 2388 0d30 DF90      		pop r13
 2389 0d32 CF90      		pop r12
 2390 0d34 BF90      		pop r11
 2391 0d36 AF90      		pop r10
 2392 0d38 9F90      		pop r9
 2393 0d3a 8F90      		pop r8
 2394 0d3c 7F90      		pop r7
 2395 0d3e 0895      		ret
 2396               	.LFE58:
 2398               		.section	.rodata.str1.1,"aMS",@progbits,1
 2399               	.LC1:
 2400 0000 3000      		.string	"0"
 2401               		.text
 2402               	.global	returnInt
 2404               	returnInt:
 2405               	.LFB67:
2497:switcherator.c **** 
2498:switcherator.c **** // sets the time limits for switches to affect progams
2499:switcherator.c **** // TL:##HHMMHHMMddddddd
2500:switcherator.c **** // 01234567890123456789
2501:switcherator.c **** 
2502:switcherator.c **** void setTimeLimits(char * commandReceived) {
2503:switcherator.c ****     char tempReallyLongString[] = "0000000";
2504:switcherator.c ****     int programNumber = 0;
2505:switcherator.c ****     long weekLong = 0;
2506:switcherator.c ****     long startTime = 0;
2507:switcherator.c ****     long stopTime = 0;
2508:switcherator.c ****     int x = 0;
2509:switcherator.c ****     statusMsg[0] = 0;
2510:switcherator.c ****     unsigned int startHour, startMinute, stopHour, stopMinute;
2511:switcherator.c ****     tempIntString[0] = commandReceived[3];
2512:switcherator.c ****     tempIntString[1] = commandReceived[4];
2513:switcherator.c ****     programNumber = atoi(tempIntString);
2514:switcherator.c ****     if (programNumber > NUM_LIMITS) {
2515:switcherator.c ****         fail(0x10);
2516:switcherator.c ****         return;
2517:switcherator.c ****     }
2518:switcherator.c ****     if (commandReceived[5] == 'x' || commandReceived[5] == 'x') {
2519:switcherator.c ****         timeLimits[programNumber][2] = 0;
2520:switcherator.c ****         ok();
2521:switcherator.c ****         return;
2522:switcherator.c ****     }
2523:switcherator.c ****     if (commandReceived[5] == '?') {
2524:switcherator.c ****         // show the limit.
2525:switcherator.c ****         startTime = timeLimits[programNumber][0];
2526:switcherator.c ****         stopTime = timeLimits[programNumber][1];
2527:switcherator.c ****         strcat(statusMsg, "Start:");
2528:switcherator.c ****         startHour = (startTime / 60 / 60);
2529:switcherator.c ****         returnInt(startHour, tempLongString);
2530:switcherator.c ****         strcat(statusMsg, tempLongString);
2531:switcherator.c ****         startMinute = ((startTime - (startHour * 60 * 60)) / 60);
2532:switcherator.c ****         strcat(statusMsg, ":");
2533:switcherator.c ****         returnInt(startMinute, tempLongString);
2534:switcherator.c ****         strcat(statusMsg, tempLongString);
2535:switcherator.c ****         strcat(statusMsg, "Stop:");
2536:switcherator.c ****         stopHour = (startTime / 60 / 60);
2537:switcherator.c ****         returnInt(stopHour, tempLongString);
2538:switcherator.c ****         strcat(statusMsg, tempLongString);
2539:switcherator.c ****         stopMinute = ((startTime - (stopHour * 60 * 60)) / 60);
2540:switcherator.c ****         strcat(statusMsg, ":");
2541:switcherator.c ****         returnInt(stopMinute, tempLongString);
2542:switcherator.c ****         strcat(statusMsg, tempLongString);
2543:switcherator.c ****         sendMessage(statusMsg);
2544:switcherator.c ****         return;
2545:switcherator.c ****     }
2546:switcherator.c ****     for (x = 0; x < 7; x++) {
2547:switcherator.c ****         tempReallyLongString[x] = commandReceived[x + 13];
2548:switcherator.c ****     }
2549:switcherator.c ****     weekLong = strtol(tempReallyLongString, 0, 2);
2550:switcherator.c ****     tempIntString[0] = commandReceived[5];
2551:switcherator.c ****     tempIntString[1] = commandReceived[6];
2552:switcherator.c ****     startHour = atoi(tempIntString);
2553:switcherator.c ****     tempIntString[0] = commandReceived[7];
2554:switcherator.c ****     tempIntString[1] = commandReceived[8];
2555:switcherator.c ****     startMinute = atoi(tempIntString);
2556:switcherator.c ****     tempIntString[0] = commandReceived[9];
2557:switcherator.c ****     tempIntString[1] = commandReceived[10];
2558:switcherator.c ****     stopHour = atoi(tempIntString);
2559:switcherator.c ****     tempIntString[0] = commandReceived[11];
2560:switcherator.c ****     tempIntString[1] = commandReceived[12];
2561:switcherator.c ****     stopMinute = atoi(tempIntString);
2562:switcherator.c ****     if (startHour > 23 || stopHour > 23) {
2563:switcherator.c ****         fail(0x09);
2564:switcherator.c ****         return;
2565:switcherator.c ****     }
2566:switcherator.c ****     if (startMinute > 59 || stopMinute > 59) {
2567:switcherator.c ****         fail(0x0A);
2568:switcherator.c ****         return;
2569:switcherator.c ****     }
2570:switcherator.c ****     startTime = startHour;
2571:switcherator.c ****     startTime = startTime * 60 * 60;
2572:switcherator.c ****     startTime += (startMinute * 60);
2573:switcherator.c ****     stopTime = stopHour;
2574:switcherator.c ****     stopTime = stopTime * 60 * 60;
2575:switcherator.c ****     stopTime += (stopMinute * 60);
2576:switcherator.c ****     timeLimits[programNumber][0] = startTime;
2577:switcherator.c ****     timeLimits[programNumber][1] = stopTime;
2578:switcherator.c ****     timeLimits[programNumber][2] = weekLong;
2579:switcherator.c ****     ok();
2580:switcherator.c **** 
2581:switcherator.c **** }
2582:switcherator.c **** 
2583:switcherator.c **** // take in 3 digits to tweak the clock time
2584:switcherator.c **** // CT xxxx
2585:switcherator.c **** 
2586:switcherator.c **** void clockTweak(char * commandReceived) {
2587:switcherator.c ****     int x = 0;
2588:switcherator.c ****     for (x = 0; x < 4; x++) {
2589:switcherator.c ****         tempLongString[x] = commandReceived[(x + 3)];
2590:switcherator.c ****     }
2591:switcherator.c ****     int adjustment = atoi(tempLongString);
2592:switcherator.c ****     if (adjustment == 0) {
2593:switcherator.c ****         itoa(tweakTimer, tempLongString, 10);
2594:switcherator.c ****         statusMsg[0] = 0;
2595:switcherator.c ****         strcat(statusMsg, "Curr Tweak:");
2596:switcherator.c ****         strcat(statusMsg, tempLongString);
2597:switcherator.c ****         sendMessage(statusMsg);
2598:switcherator.c ****         return;
2599:switcherator.c ****     }
2600:switcherator.c ****     tweakTimer += adjustment;
2601:switcherator.c ****     ok();
2602:switcherator.c **** }
2603:switcherator.c **** 
2604:switcherator.c **** /****************************************************************
2605:switcherator.c ****  *
2606:switcherator.c ****  *              All Things debug and output Related
2607:switcherator.c ****  *
2608:switcherator.c ****  ****************************************************************/
2609:switcherator.c **** 
2610:switcherator.c **** 
2611:switcherator.c **** 
2612:switcherator.c **** 
2613:switcherator.c **** 
2614:switcherator.c **** 
2615:switcherator.c **** // sends a general status
2616:switcherator.c **** // basically an overview of the system
2617:switcherator.c **** 
2618:switcherator.c **** void generalStatus(char * commandReceived) {
2619:switcherator.c ****     statusMsg[0] = 0;
2620:switcherator.c ****     tempIntString[0] = commandReceived[2];
2621:switcherator.c ****     tempIntString[1] = commandReceived[3];
2622:switcherator.c **** 
2623:switcherator.c **** 
2624:switcherator.c ****     if (panicMyClockIsNotSet == 1) {
2625:switcherator.c ****         strcat(statusMsg, " T:xx/xx/xxxx xx:xx:xx");
2626:switcherator.c ****     } else {
2627:switcherator.c ****         strcat(statusMsg, " T:");
2628:switcherator.c ****         returnInt(globalMonth, tempLongString);
2629:switcherator.c ****         strcat(statusMsg, tempLongString);
2630:switcherator.c ****         strcat(statusMsg, "/");
2631:switcherator.c ****         returnInt(globalDay, tempLongString);
2632:switcherator.c ****         strcat(statusMsg, tempLongString);
2633:switcherator.c ****         strcat(statusMsg, "/");
2634:switcherator.c ****         returnInt(globalYear, tempLongString);
2635:switcherator.c ****         strcat(statusMsg, tempLongString);
2636:switcherator.c ****         strcat(statusMsg, " ");
2637:switcherator.c ****         returnInt(globalHour, tempLongString);
2638:switcherator.c ****         strcat(statusMsg, tempLongString);
2639:switcherator.c ****         strcat(statusMsg, ":");
2640:switcherator.c ****         returnInt(globalMinute, tempLongString);
2641:switcherator.c ****         strcat(statusMsg, tempLongString);
2642:switcherator.c ****         strcat(statusMsg, ":");
2643:switcherator.c ****         returnInt(globalSecond, tempLongString);
2644:switcherator.c ****         strcat(statusMsg, tempLongString);
2645:switcherator.c ****     }
2646:switcherator.c ****     sendMessage(statusMsg);
2647:switcherator.c ****     statusMsg[0] = 0;
2648:switcherator.c ****     if (commandReceived[2] == 'q')
2649:switcherator.c ****         return;
2650:switcherator.c **** 
2651:switcherator.c ****     programsProgrammed();
2652:switcherator.c ****     switchesProgrammed();
2653:switcherator.c ****     inputsProgrammed();
2654:switcherator.c ****     switchesOn();
2655:switcherator.c **** }
2656:switcherator.c **** 
2657:switcherator.c **** // returns a basic view of the capabilities
2658:switcherator.c **** void generalInformation(void) {
2659:switcherator.c ****     statusMsg[0] = 0;
2660:switcherator.c ****     strcat(statusMsg,"Pr,");
2661:switcherator.c ****     int count = 0;
2662:switcherator.c ****     int x;
2663:switcherator.c ****     for(x=0;x<MAX_PROGRAM;x++) {
2664:switcherator.c ****         if(weeklyProgram[x][0] < 255 || weeklyProgram[x][1] < 255) 
2665:switcherator.c ****             count++;
2666:switcherator.c ****     }
2667:switcherator.c ****     returnInt(count,tempLongString);
2668:switcherator.c ****     strcat(statusMsg,tempLongString);
2669:switcherator.c ****     strcat(statusMsg,"/");
2670:switcherator.c ****     returnInt(MAX_PROGRAM,tempLongString);
2671:switcherator.c ****     strcat(statusMsg,tempLongString);
2672:switcherator.c ****     strcat(statusMsg,",Sw,");
2673:switcherator.c ****     count = 0;
2674:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
2675:switcherator.c ****         if (switchStuff[x] < 255)
2676:switcherator.c ****             count ++;
2677:switcherator.c ****     }
2678:switcherator.c ****     returnInt(count,tempLongString);
2679:switcherator.c ****     strcat(statusMsg,tempLongString);
2680:switcherator.c ****     strcat(statusMsg,"/");
2681:switcherator.c ****     returnInt(NUM_SWITCHES,tempLongString);
2682:switcherator.c ****     strcat(statusMsg,tempLongString);
2683:switcherator.c ****     sendMessage(statusMsg);
2684:switcherator.c ****     statusMsg[0] = 0;
2685:switcherator.c ****     strcat(statusMsg,",In,");
2686:switcherator.c ****     count = 0;
2687:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
2688:switcherator.c ****         if (inputs[x][0] < 255)
2689:switcherator.c ****             count ++;
2690:switcherator.c ****     }
2691:switcherator.c ****     returnInt(count,tempLongString);
2692:switcherator.c ****     strcat(statusMsg,tempLongString);
2693:switcherator.c ****     strcat(statusMsg,"/");
2694:switcherator.c ****     returnInt(NUM_INPUTS,tempLongString);
2695:switcherator.c ****     strcat(statusMsg,tempLongString);
2696:switcherator.c ****     strcat(statusMsg,",Li,");
2697:switcherator.c ****     count = 0;
2698:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++) {
2699:switcherator.c ****         if (inputs[x][2] > 0)
2700:switcherator.c ****             count ++;
2701:switcherator.c ****     }
2702:switcherator.c ****     returnInt(count,tempLongString);
2703:switcherator.c ****     strcat(statusMsg,tempLongString);
2704:switcherator.c ****     strcat(statusMsg,"/");
2705:switcherator.c ****     returnInt(NUM_LIMITS,tempLongString);
2706:switcherator.c ****     strcat(statusMsg,tempLongString);
2707:switcherator.c ****     strcat(statusMsg,",CC,");
2708:switcherator.c ****     count = 0;
2709:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
2710:switcherator.c ****         if (colorChanges[x][0] != 0 || colorChanges[x][1] != 1 || colorChanges[x][2] != 0)
2711:switcherator.c ****             count ++;
2712:switcherator.c ****     }
2713:switcherator.c ****     returnInt(count,tempLongString);
2714:switcherator.c ****     strcat(statusMsg,tempLongString);
2715:switcherator.c ****     strcat(statusMsg,"/");
2716:switcherator.c ****     returnInt(NUM_COLOR_CHANGES,tempLongString);
2717:switcherator.c ****     strcat(statusMsg,tempLongString);
2718:switcherator.c ****     sendMessage(statusMsg);
2719:switcherator.c **** }
2720:switcherator.c **** 
2721:switcherator.c **** // transmits Y or N for which programs have been programmed
2722:switcherator.c **** void programsProgrammed(void) {
2723:switcherator.c ****     strcat(statusMsg, "Progs");
2724:switcherator.c ****     int x;
2725:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
2726:switcherator.c ****         if (weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) {
2727:switcherator.c ****             strcat(statusMsg, "n");
2728:switcherator.c ****         } else {
2729:switcherator.c ****             strcat(statusMsg, "y");
2730:switcherator.c ****         }
2731:switcherator.c ****         // can only send 32 bytes at a time
2732:switcherator.c ****         if (strlen(statusMsg) > 30) {
2733:switcherator.c ****             sendMessage(statusMsg);
2734:switcherator.c ****             statusMsg[5] = 0;
2735:switcherator.c ****         }
2736:switcherator.c ****     }
2737:switcherator.c ****     sendMessage(statusMsg);    
2738:switcherator.c **** }
2739:switcherator.c **** // transmits Y or N for which switches have been programmed
2740:switcherator.c **** void switchesProgrammed(void) {
2741:switcherator.c ****     statusMsg[0] = 0;
2742:switcherator.c ****     strcat(statusMsg, "Swi");
2743:switcherator.c ****     int x;
2744:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
2745:switcherator.c **** 
2746:switcherator.c ****         if (switchStuff[x] == 255) {
2747:switcherator.c ****             strcat(statusMsg, "n");
2748:switcherator.c ****         } else {
2749:switcherator.c ****             strcat(statusMsg, "y");
2750:switcherator.c ****         }
2751:switcherator.c ****         // can only send 32 bytes at a time
2752:switcherator.c ****         if (strlen(statusMsg) > 30) {
2753:switcherator.c ****             sendMessage(statusMsg);
2754:switcherator.c ****             statusMsg[3] = 0;
2755:switcherator.c ****         }
2756:switcherator.c ****     }
2757:switcherator.c ****     sendMessage(statusMsg);
2758:switcherator.c **** }
2759:switcherator.c **** 
2760:switcherator.c **** // transmits Y or N for which inputs have been programmed
2761:switcherator.c **** void inputsProgrammed(void) {
2762:switcherator.c ****     statusMsg[0] = 0;
2763:switcherator.c ****     strcat(statusMsg, "In");
2764:switcherator.c ****     int x;
2765:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
2766:switcherator.c ****         if (inputs[x][0] == 255) {
2767:switcherator.c ****             strcat(statusMsg, "n");
2768:switcherator.c ****         } else {
2769:switcherator.c ****             strcat(statusMsg, "y");
2770:switcherator.c ****         }
2771:switcherator.c ****         // can only send 32 bytes at a time
2772:switcherator.c ****         if (strlen(statusMsg) > 30) {
2773:switcherator.c ****             sendMessage(statusMsg);
2774:switcherator.c ****             statusMsg[2] = 0;
2775:switcherator.c ****         }
2776:switcherator.c ****     }
2777:switcherator.c ****     sendMessage(statusMsg);
2778:switcherator.c **** }
2779:switcherator.c **** 
2780:switcherator.c **** // transmits Y or N for which switches are currently turned on
2781:switcherator.c **** void switchesOn(void) {
2782:switcherator.c ****     statusMsg[0] = 0;
2783:switcherator.c ****     strcat(statusMsg, "SwOn");
2784:switcherator.c ****     int x;
2785:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
2786:switcherator.c ****         if (switchStatus[x] > 0) {
2787:switcherator.c ****             strcat(statusMsg, "y");
2788:switcherator.c ****         } else {
2789:switcherator.c ****             strcat(statusMsg, "n");
2790:switcherator.c ****         }
2791:switcherator.c ****         if (strlen(statusMsg) > 30) {
2792:switcherator.c ****             sendMessage(statusMsg);
2793:switcherator.c ****             statusMsg[4] = 0;
2794:switcherator.c ****         }
2795:switcherator.c ****     }
2796:switcherator.c ****     sendMessage(statusMsg);
2797:switcherator.c **** }
2798:switcherator.c **** 
2799:switcherator.c **** void returnInt(int number, char * thisString) {
 2406               		.loc 1 2799 0
 2407               	.LVL131:
 2408 0d40 CF93      		push r28
 2409               	.LCFI66:
 2410 0d42 DF93      		push r29
 2411               	.LCFI67:
 2412               	/* prologue: function */
 2413               	/* frame size = 0 */
 2414               	/* stack size = 2 */
 2415               	.L__stack_usage = 2
 2416 0d44 EB01      		movw r28,r22
2800:switcherator.c ****     thisString[0] = 0;
 2417               		.loc 1 2800 0
 2418 0d46 1882      		st Y,__zero_reg__
2801:switcherator.c ****     itoa(number, tempHugeString, 10);
 2419               		.loc 1 2801 0
 2420 0d48 4AE0      		ldi r20,lo8(10)
 2421 0d4a 50E0      		ldi r21,0
 2422 0d4c 60E0      		ldi r22,lo8(tempHugeString)
 2423 0d4e 70E0      		ldi r23,hi8(tempHugeString)
 2424               	.LVL132:
 2425 0d50 0E94 0000 		call itoa
 2426               	.LVL133:
2802:switcherator.c ****     if (strlen(tempHugeString) == 1)
 2427               		.loc 1 2802 0
 2428 0d54 E0E0      		ldi r30,lo8(tempHugeString)
 2429 0d56 F0E0      		ldi r31,hi8(tempHugeString)
 2430               		0:
 2431 0d58 0190      		ld __tmp_reg__,Z+
 2432 0d5a 0020      		tst __tmp_reg__
 2433 0d5c 01F4      		brne 0b
 2434 0d5e E050      		subi r30,lo8(tempHugeString+2)
 2435 0d60 F040      		sbci r31,hi8(tempHugeString+2)
 2436 0d62 01F4      		brne .L188
2803:switcherator.c ****         strcat(thisString, "0");
 2437               		.loc 1 2803 0
 2438 0d64 60E0      		ldi r22,lo8(.LC1)
 2439 0d66 70E0      		ldi r23,hi8(.LC1)
 2440 0d68 CE01      		movw r24,r28
 2441 0d6a 0E94 0000 		call strcat
 2442               	.LVL134:
 2443               	.L188:
2804:switcherator.c ****     strcat(thisString, tempHugeString);
 2444               		.loc 1 2804 0
 2445 0d6e 60E0      		ldi r22,lo8(tempHugeString)
 2446 0d70 70E0      		ldi r23,hi8(tempHugeString)
 2447 0d72 CE01      		movw r24,r28
 2448               	/* epilogue start */
2805:switcherator.c **** }
 2449               		.loc 1 2805 0
 2450 0d74 DF91      		pop r29
 2451 0d76 CF91      		pop r28
 2452               	.LVL135:
2804:switcherator.c ****     strcat(thisString, tempHugeString);
 2453               		.loc 1 2804 0
 2454 0d78 0C94 0000 		jmp strcat
 2455               	.LVL136:
 2456               	.LFE67:
 2458               		.section	.rodata.str1.1
 2459               	.LC2:
 2460 0002 2000      		.string	" "
 2461               	.LC3:
 2462 0004 2F00      		.string	"/"
 2463               	.LC4:
 2464 0006 3A00      		.string	":"
 2465               		.text
 2466               	.global	clockString
 2468               	clockString:
 2469               	.LFB49:
2148:switcherator.c **** void clockString(void) {
 2470               		.loc 1 2148 0
 2471               	/* prologue: function */
 2472               	/* frame size = 0 */
 2473               	/* stack size = 0 */
 2474               	.L__stack_usage = 0
2149:switcherator.c ****     statusMsg[0] = 0;
 2475               		.loc 1 2149 0
 2476 0d7c 1092 0000 		sts statusMsg,__zero_reg__
2151:switcherator.c ****     strcat(statusMsg, " ");
 2477               		.loc 1 2151 0
 2478 0d80 60E0      		ldi r22,lo8(.LC2)
 2479 0d82 70E0      		ldi r23,hi8(.LC2)
 2480 0d84 80E0      		ldi r24,lo8(statusMsg)
 2481 0d86 90E0      		ldi r25,hi8(statusMsg)
 2482 0d88 0E94 0000 		call strcat
 2483               	.LVL137:
2152:switcherator.c ****     returnInt(globalMonth, tempIntString);
 2484               		.loc 1 2152 0
 2485 0d8c 60E0      		ldi r22,lo8(tempIntString)
 2486 0d8e 70E0      		ldi r23,hi8(tempIntString)
 2487 0d90 8091 0000 		lds r24,globalMonth
 2488 0d94 9091 0000 		lds r25,globalMonth+1
 2489 0d98 0E94 0000 		call returnInt
 2490               	.LVL138:
2153:switcherator.c ****     strcat(statusMsg, tempIntString);
 2491               		.loc 1 2153 0
 2492 0d9c 60E0      		ldi r22,lo8(tempIntString)
 2493 0d9e 70E0      		ldi r23,hi8(tempIntString)
 2494 0da0 80E0      		ldi r24,lo8(statusMsg)
 2495 0da2 90E0      		ldi r25,hi8(statusMsg)
 2496 0da4 0E94 0000 		call strcat
 2497               	.LVL139:
2154:switcherator.c ****     strcat(statusMsg, "/");
 2498               		.loc 1 2154 0
 2499 0da8 60E0      		ldi r22,lo8(.LC3)
 2500 0daa 70E0      		ldi r23,hi8(.LC3)
 2501 0dac 80E0      		ldi r24,lo8(statusMsg)
 2502 0dae 90E0      		ldi r25,hi8(statusMsg)
 2503 0db0 0E94 0000 		call strcat
 2504               	.LVL140:
2155:switcherator.c ****     returnInt(globalDay, tempIntString);
 2505               		.loc 1 2155 0
 2506 0db4 60E0      		ldi r22,lo8(tempIntString)
 2507 0db6 70E0      		ldi r23,hi8(tempIntString)
 2508 0db8 8091 0000 		lds r24,globalDay
 2509 0dbc 9091 0000 		lds r25,globalDay+1
 2510 0dc0 0E94 0000 		call returnInt
 2511               	.LVL141:
2156:switcherator.c ****     strcat(statusMsg, tempIntString);
 2512               		.loc 1 2156 0
 2513 0dc4 60E0      		ldi r22,lo8(tempIntString)
 2514 0dc6 70E0      		ldi r23,hi8(tempIntString)
 2515 0dc8 80E0      		ldi r24,lo8(statusMsg)
 2516 0dca 90E0      		ldi r25,hi8(statusMsg)
 2517 0dcc 0E94 0000 		call strcat
 2518               	.LVL142:
2157:switcherator.c ****     strcat(statusMsg, "/");
 2519               		.loc 1 2157 0
 2520 0dd0 60E0      		ldi r22,lo8(.LC3)
 2521 0dd2 70E0      		ldi r23,hi8(.LC3)
 2522 0dd4 80E0      		ldi r24,lo8(statusMsg)
 2523 0dd6 90E0      		ldi r25,hi8(statusMsg)
 2524 0dd8 0E94 0000 		call strcat
 2525               	.LVL143:
2158:switcherator.c ****     itoa(globalYear, tempIntString, 10);
 2526               		.loc 1 2158 0
 2527 0ddc 4AE0      		ldi r20,lo8(10)
 2528 0dde 50E0      		ldi r21,0
 2529 0de0 60E0      		ldi r22,lo8(tempIntString)
 2530 0de2 70E0      		ldi r23,hi8(tempIntString)
 2531 0de4 8091 0000 		lds r24,globalYear
 2532 0de8 9091 0000 		lds r25,globalYear+1
 2533 0dec 0E94 0000 		call itoa
 2534               	.LVL144:
2159:switcherator.c ****     strcat(statusMsg, tempIntString);
 2535               		.loc 1 2159 0
 2536 0df0 60E0      		ldi r22,lo8(tempIntString)
 2537 0df2 70E0      		ldi r23,hi8(tempIntString)
 2538 0df4 80E0      		ldi r24,lo8(statusMsg)
 2539 0df6 90E0      		ldi r25,hi8(statusMsg)
 2540 0df8 0E94 0000 		call strcat
 2541               	.LVL145:
2160:switcherator.c ****     strcat(statusMsg, " ");
 2542               		.loc 1 2160 0
 2543 0dfc 60E0      		ldi r22,lo8(.LC2)
 2544 0dfe 70E0      		ldi r23,hi8(.LC2)
 2545 0e00 80E0      		ldi r24,lo8(statusMsg)
 2546 0e02 90E0      		ldi r25,hi8(statusMsg)
 2547 0e04 0E94 0000 		call strcat
 2548               	.LVL146:
2161:switcherator.c ****     returnInt(globalHour, tempIntString);
 2549               		.loc 1 2161 0
 2550 0e08 60E0      		ldi r22,lo8(tempIntString)
 2551 0e0a 70E0      		ldi r23,hi8(tempIntString)
 2552 0e0c 8091 0000 		lds r24,globalHour
 2553 0e10 9091 0000 		lds r25,globalHour+1
 2554 0e14 0E94 0000 		call returnInt
 2555               	.LVL147:
2162:switcherator.c ****     strcat(statusMsg, tempIntString);
 2556               		.loc 1 2162 0
 2557 0e18 60E0      		ldi r22,lo8(tempIntString)
 2558 0e1a 70E0      		ldi r23,hi8(tempIntString)
 2559 0e1c 80E0      		ldi r24,lo8(statusMsg)
 2560 0e1e 90E0      		ldi r25,hi8(statusMsg)
 2561 0e20 0E94 0000 		call strcat
 2562               	.LVL148:
2163:switcherator.c ****     strcat(statusMsg, ":");
 2563               		.loc 1 2163 0
 2564 0e24 60E0      		ldi r22,lo8(.LC4)
 2565 0e26 70E0      		ldi r23,hi8(.LC4)
 2566 0e28 80E0      		ldi r24,lo8(statusMsg)
 2567 0e2a 90E0      		ldi r25,hi8(statusMsg)
 2568 0e2c 0E94 0000 		call strcat
 2569               	.LVL149:
2164:switcherator.c ****     returnInt(globalMinute, tempIntString);
 2570               		.loc 1 2164 0
 2571 0e30 60E0      		ldi r22,lo8(tempIntString)
 2572 0e32 70E0      		ldi r23,hi8(tempIntString)
 2573 0e34 8091 0000 		lds r24,globalMinute
 2574 0e38 9091 0000 		lds r25,globalMinute+1
 2575 0e3c 0E94 0000 		call returnInt
 2576               	.LVL150:
2165:switcherator.c ****     strcat(statusMsg, tempIntString);
 2577               		.loc 1 2165 0
 2578 0e40 60E0      		ldi r22,lo8(tempIntString)
 2579 0e42 70E0      		ldi r23,hi8(tempIntString)
 2580 0e44 80E0      		ldi r24,lo8(statusMsg)
 2581 0e46 90E0      		ldi r25,hi8(statusMsg)
 2582 0e48 0E94 0000 		call strcat
 2583               	.LVL151:
2166:switcherator.c ****     strcat(statusMsg, ":");
 2584               		.loc 1 2166 0
 2585 0e4c 60E0      		ldi r22,lo8(.LC4)
 2586 0e4e 70E0      		ldi r23,hi8(.LC4)
 2587 0e50 80E0      		ldi r24,lo8(statusMsg)
 2588 0e52 90E0      		ldi r25,hi8(statusMsg)
 2589 0e54 0E94 0000 		call strcat
 2590               	.LVL152:
2167:switcherator.c ****     returnInt(globalSecond, tempIntString);
 2591               		.loc 1 2167 0
 2592 0e58 60E0      		ldi r22,lo8(tempIntString)
 2593 0e5a 70E0      		ldi r23,hi8(tempIntString)
 2594 0e5c 8091 0000 		lds r24,globalSecond
 2595 0e60 9091 0000 		lds r25,globalSecond+1
 2596 0e64 0E94 0000 		call returnInt
 2597               	.LVL153:
2168:switcherator.c ****     strcat(statusMsg, tempIntString);
 2598               		.loc 1 2168 0
 2599 0e68 60E0      		ldi r22,lo8(tempIntString)
 2600 0e6a 70E0      		ldi r23,hi8(tempIntString)
 2601 0e6c 80E0      		ldi r24,lo8(statusMsg)
 2602 0e6e 90E0      		ldi r25,hi8(statusMsg)
 2603 0e70 0C94 0000 		jmp strcat
 2604               	.LVL154:
 2605               	.LFE49:
 2607               		.section	.rodata.str1.1
 2608               	.LC5:
 2609 0008 3078 00   		.string	"0x"
 2610               		.text
 2611               	.global	returnHex
 2613               	returnHex:
 2614               	.LFB68:
2806:switcherator.c **** 
2807:switcherator.c **** void returnHex(unsigned int number, char * thisString) {
 2615               		.loc 1 2807 0
 2616               	.LVL155:
 2617 0e74 0F93      		push r16
 2618               	.LCFI68:
 2619 0e76 1F93      		push r17
 2620               	.LCFI69:
 2621 0e78 CF93      		push r28
 2622               	.LCFI70:
 2623 0e7a DF93      		push r29
 2624               	.LCFI71:
 2625               	/* prologue: function */
 2626               	/* frame size = 0 */
 2627               	/* stack size = 4 */
 2628               	.L__stack_usage = 4
 2629 0e7c 8C01      		movw r16,r24
 2630 0e7e EB01      		movw r28,r22
2808:switcherator.c ****     thisString[0] = 0;
 2631               		.loc 1 2808 0
 2632 0e80 1882      		st Y,__zero_reg__
2809:switcherator.c ****     strcat(thisString, "0x");
 2633               		.loc 1 2809 0
 2634 0e82 60E0      		ldi r22,lo8(.LC5)
 2635 0e84 70E0      		ldi r23,hi8(.LC5)
 2636               	.LVL156:
 2637 0e86 CE01      		movw r24,r28
 2638               	.LVL157:
 2639 0e88 0E94 0000 		call strcat
 2640               	.LVL158:
2810:switcherator.c ****     itoa(number, tempHugeString, 16);
 2641               		.loc 1 2810 0
 2642 0e8c 40E1      		ldi r20,lo8(16)
 2643 0e8e 50E0      		ldi r21,0
 2644 0e90 60E0      		ldi r22,lo8(tempHugeString)
 2645 0e92 70E0      		ldi r23,hi8(tempHugeString)
 2646 0e94 C801      		movw r24,r16
 2647 0e96 0E94 0000 		call itoa
 2648               	.LVL159:
2811:switcherator.c ****     if (strlen(tempHugeString) == 1 || strlen(tempHugeString) == 3)
 2649               		.loc 1 2811 0
 2650 0e9a E0E0      		ldi r30,lo8(tempHugeString)
 2651 0e9c F0E0      		ldi r31,hi8(tempHugeString)
 2652               		0:
 2653 0e9e 0190      		ld __tmp_reg__,Z+
 2654 0ea0 0020      		tst __tmp_reg__
 2655 0ea2 01F4      		brne 0b
 2656 0ea4 3197      		sbiw r30,1
 2657 0ea6 E050      		subi r30,lo8(tempHugeString)
 2658 0ea8 F040      		sbci r31,hi8(tempHugeString)
 2659 0eaa E130      		cpi r30,1
 2660 0eac F105      		cpc r31,__zero_reg__
 2661 0eae 01F0      		breq .L191
 2662               		.loc 1 2811 0 is_stmt 0 discriminator 1
 2663 0eb0 3397      		sbiw r30,3
 2664 0eb2 01F4      		brne .L192
 2665               	.L191:
2812:switcherator.c ****         strcat(thisString, "0");
 2666               		.loc 1 2812 0 is_stmt 1
 2667 0eb4 60E0      		ldi r22,lo8(.LC1)
 2668 0eb6 70E0      		ldi r23,hi8(.LC1)
 2669 0eb8 CE01      		movw r24,r28
 2670 0eba 0E94 0000 		call strcat
 2671               	.LVL160:
 2672               	.L192:
2813:switcherator.c ****     strcat(thisString, tempHugeString);
 2673               		.loc 1 2813 0
 2674 0ebe 60E0      		ldi r22,lo8(tempHugeString)
 2675 0ec0 70E0      		ldi r23,hi8(tempHugeString)
 2676 0ec2 CE01      		movw r24,r28
 2677               	/* epilogue start */
2814:switcherator.c **** }
 2678               		.loc 1 2814 0
 2679 0ec4 DF91      		pop r29
 2680 0ec6 CF91      		pop r28
 2681               	.LVL161:
 2682 0ec8 1F91      		pop r17
 2683 0eca 0F91      		pop r16
 2684               	.LVL162:
2813:switcherator.c ****     strcat(thisString, tempHugeString);
 2685               		.loc 1 2813 0
 2686 0ecc 0C94 0000 		jmp strcat
 2687               	.LVL163:
 2688               	.LFE68:
 2690               	.global	returnHexWithout
 2692               	returnHexWithout:
 2693               	.LFB69:
2815:switcherator.c **** 
2816:switcherator.c **** 
2817:switcherator.c **** 
2818:switcherator.c **** // print hex without 0x
2819:switcherator.c **** 
2820:switcherator.c **** void returnHexWithout(unsigned int number, char * tempMe) {
 2694               		.loc 1 2820 0
 2695               	.LVL164:
 2696 0ed0 CF93      		push r28
 2697               	.LCFI72:
 2698 0ed2 DF93      		push r29
 2699               	.LCFI73:
 2700               	/* prologue: function */
 2701               	/* frame size = 0 */
 2702               	/* stack size = 2 */
 2703               	.L__stack_usage = 2
 2704 0ed4 EB01      		movw r28,r22
2821:switcherator.c ****     tempMe[0] = 0;
 2705               		.loc 1 2821 0
 2706 0ed6 1882      		st Y,__zero_reg__
2822:switcherator.c ****     itoa(number, tempHugeString, 16);
 2707               		.loc 1 2822 0
 2708 0ed8 40E1      		ldi r20,lo8(16)
 2709 0eda 50E0      		ldi r21,0
 2710 0edc 60E0      		ldi r22,lo8(tempHugeString)
 2711 0ede 70E0      		ldi r23,hi8(tempHugeString)
 2712               	.LVL165:
 2713 0ee0 0E94 0000 		call itoa
 2714               	.LVL166:
2823:switcherator.c ****     if (strlen(tempHugeString) == 1 || strlen(tempHugeString) == 3)
 2715               		.loc 1 2823 0
 2716 0ee4 E0E0      		ldi r30,lo8(tempHugeString)
 2717 0ee6 F0E0      		ldi r31,hi8(tempHugeString)
 2718               		0:
 2719 0ee8 0190      		ld __tmp_reg__,Z+
 2720 0eea 0020      		tst __tmp_reg__
 2721 0eec 01F4      		brne 0b
 2722 0eee 3197      		sbiw r30,1
 2723 0ef0 E050      		subi r30,lo8(tempHugeString)
 2724 0ef2 F040      		sbci r31,hi8(tempHugeString)
 2725 0ef4 E130      		cpi r30,1
 2726 0ef6 F105      		cpc r31,__zero_reg__
 2727 0ef8 01F0      		breq .L197
 2728               		.loc 1 2823 0 is_stmt 0 discriminator 1
 2729 0efa 3397      		sbiw r30,3
 2730 0efc 01F4      		brne .L198
 2731               	.L197:
2824:switcherator.c ****         strcat(tempMe, "0");
 2732               		.loc 1 2824 0 is_stmt 1
 2733 0efe 60E0      		ldi r22,lo8(.LC1)
 2734 0f00 70E0      		ldi r23,hi8(.LC1)
 2735 0f02 CE01      		movw r24,r28
 2736 0f04 0E94 0000 		call strcat
 2737               	.LVL167:
 2738               	.L198:
2825:switcherator.c ****     strcat(tempMe, tempHugeString);
 2739               		.loc 1 2825 0
 2740 0f08 60E0      		ldi r22,lo8(tempHugeString)
 2741 0f0a 70E0      		ldi r23,hi8(tempHugeString)
 2742 0f0c CE01      		movw r24,r28
 2743               	/* epilogue start */
2826:switcherator.c **** }
 2744               		.loc 1 2826 0
 2745 0f0e DF91      		pop r29
 2746 0f10 CF91      		pop r28
 2747               	.LVL168:
2825:switcherator.c ****     strcat(tempMe, tempHugeString);
 2748               		.loc 1 2825 0
 2749 0f12 0C94 0000 		jmp strcat
 2750               	.LVL169:
 2751               	.LFE69:
 2753               	.global	formatAddress
 2755               	formatAddress:
 2756               	.LFB72:
2827:switcherator.c **** 
2828:switcherator.c **** // Clock interrupt - fires when the compare is off
2829:switcherator.c **** 
2830:switcherator.c **** /****************************************************************
2831:switcherator.c ****  *
2832:switcherator.c ****  *              All Things Radio Related
2833:switcherator.c ****  *
2834:switcherator.c ****  ****************************************************************/
2835:switcherator.c **** 
2836:switcherator.c **** // initialize the radio
2837:switcherator.c **** 
2838:switcherator.c **** void radioInit(void) {
2839:switcherator.c ****     nrfInit();
2840:switcherator.c ****     rx_addr_p0 = SET_RX_ADDR_P0;
2841:switcherator.c ****     tx_addr = SET_TX_ADDR;
2842:switcherator.c ****     // use defaults the radio has
2843:switcherator.c ****     rx_addr_p1 = readAddr(RX_ADDR_P1);
2844:switcherator.c ****     rx_addr_p2 = readAddr(RX_ADDR_P2);
2845:switcherator.c ****     rx_addr_p3 = readAddr(RX_ADDR_P3);
2846:switcherator.c ****     rx_addr_p4 = readAddr(RX_ADDR_P4);
2847:switcherator.c ****     rx_addr_p5 = readAddr(RX_ADDR_P5);
2848:switcherator.c **** 
2849:switcherator.c ****     writeReg(RF_SETUP, SET_RF_SETUP);
2850:switcherator.c ****     writeAddr(RX_ADDR_P0, rx_addr_p0);
2851:switcherator.c ****     writeAddr(TX_ADDR, tx_addr);
2852:switcherator.c ****     writeReg(DYNPD, SET_DYNPD);
2853:switcherator.c ****     writeReg(FEATURE, SET_FEATURE);
2854:switcherator.c ****     writeReg(RF_CH, SET_RF_CH);
2855:switcherator.c ****     writeReg(CONFIG, SET_CONFIG);
2856:switcherator.c ****     writeReg(SETUP_RETR, SET_SETUP_RETR);
2857:switcherator.c **** 
2858:switcherator.c ****     // We've written the address - now see if we get the same result
2859:switcherator.c ****     radioTest();
2860:switcherator.c ****     
2861:switcherator.c ****     startRadio();
2862:switcherator.c **** 
2863:switcherator.c **** }
2864:switcherator.c **** 
2865:switcherator.c **** // radio test - just make sure it is still working
2866:switcherator.c **** int radioTest(void) {
2867:switcherator.c ****     uint64_t test_addr;
2868:switcherator.c ****     test_addr = readAddr(RX_ADDR_P0);    
2869:switcherator.c ****     if (test_addr != rx_addr_p0) {
2870:switcherator.c ****         // nope.  broken
2871:switcherator.c ****         failCondition = 1;
2872:switcherator.c ****         return -1;
2873:switcherator.c ****     }
2874:switcherator.c ****     if(failCondition == 1 || failCondition == 2)
2875:switcherator.c ****         clearFail();
2876:switcherator.c ****     return 1;
2877:switcherator.c **** }
2878:switcherator.c **** 
2879:switcherator.c **** // Take in an address and return a long long with the number
2880:switcherator.c **** 
2881:switcherator.c **** uint64_t formatAddress(char * address) {
 2757               		.loc 1 2881 0
 2758               	.LVL170:
 2759 0f16 0F93      		push r16
 2760               	.LCFI74:
 2761 0f18 CF93      		push r28
 2762               	.LCFI75:
 2763               	/* prologue: function */
 2764               	/* frame size = 0 */
 2765               	/* stack size = 2 */
 2766               	.L__stack_usage = 2
 2767               	.LVL171:
 2768 0f1a DC01      		movw r26,r24
2882:switcherator.c ****     int x = 0;
2883:switcherator.c ****     uint64_t newAddress = 0;
 2769               		.loc 1 2883 0
 2770 0f1c 20E0      		ldi r18,0
 2771 0f1e 30E0      		ldi r19,0
 2772 0f20 40E0      		ldi r20,0
 2773 0f22 50E0      		ldi r21,0
 2774 0f24 60E0      		ldi r22,0
 2775 0f26 70E0      		ldi r23,0
 2776 0f28 80E0      		ldi r24,0
 2777               	.LVL172:
 2778 0f2a 90E0      		ldi r25,0
2884:switcherator.c ****     int tempInt;
2885:switcherator.c ****     for (x = 0; x < 5; x++) {
 2779               		.loc 1 2885 0
 2780 0f2c E0E0      		ldi r30,0
 2781 0f2e F0E0      		ldi r31,0
 2782               	.LVL173:
 2783               	.L205:
2886:switcherator.c ****         tempInt = address[x];
 2784               		.loc 1 2886 0
 2785 0f30 CD91      		ld r28,X+
 2786               	.LVL174:
 2787 0f32 C22B      		or r28,r18
 2788               	.LVL175:
2887:switcherator.c ****         if (x < 4) {
2888:switcherator.c ****             newAddress |= (tempInt);
2889:switcherator.c ****             newAddress <<= 8;
 2789               		.loc 1 2889 0
 2790 0f34 2C2F      		mov r18,r28
2887:switcherator.c ****         if (x < 4) {
 2791               		.loc 1 2887 0
 2792 0f36 E430      		cpi r30,4
 2793 0f38 F105      		cpc r31,__zero_reg__
 2794 0f3a 01F0      		breq .L204
 2795               		.loc 1 2889 0
 2796 0f3c 08E0      		ldi r16,lo8(8)
 2797 0f3e 0E94 0000 		call __ashldi3
 2798               	.LVL176:
 2799               	.L204:
2885:switcherator.c ****     for (x = 0; x < 5; x++) {
 2800               		.loc 1 2885 0
 2801 0f42 3196      		adiw r30,1
 2802               	.LVL177:
 2803 0f44 E530      		cpi r30,5
 2804 0f46 F105      		cpc r31,__zero_reg__
 2805 0f48 01F4      		brne .L205
 2806               	/* epilogue start */
2890:switcherator.c ****         } else
2891:switcherator.c ****             newAddress |= tempInt;
2892:switcherator.c ****     }
2893:switcherator.c ****     return newAddress;
2894:switcherator.c **** }
 2807               		.loc 1 2894 0
 2808 0f4a CF91      		pop r28
 2809 0f4c 0F91      		pop r16
 2810 0f4e 0895      		ret
 2811               	.LFE72:
 2813               	.global	generalInit
 2815               	generalInit:
 2816               	.LFB41:
1676:switcherator.c **** void generalInit(void) {
 2817               		.loc 1 1676 0
 2818 0f50 EF92      		push r14
 2819               	.LCFI76:
 2820 0f52 FF92      		push r15
 2821               	.LCFI77:
 2822 0f54 0F93      		push r16
 2823               	.LCFI78:
 2824 0f56 1F93      		push r17
 2825               	.LCFI79:
 2826 0f58 CF93      		push r28
 2827               	.LCFI80:
 2828 0f5a DF93      		push r29
 2829               	.LCFI81:
 2830 0f5c CDB7      		in r28,__SP_L__
 2831 0f5e DEB7      		in r29,__SP_H__
 2832               	.LCFI82:
 2833 0f60 2E97      		sbiw r28,14
 2834               	.LCFI83:
 2835 0f62 0FB6      		in __tmp_reg__,__SREG__
 2836 0f64 F894      		cli
 2837 0f66 DEBF      		out __SP_H__,r29
 2838 0f68 0FBE      		out __SREG__,__tmp_reg__
 2839 0f6a CDBF      		out __SP_L__,r28
 2840               	/* prologue: function */
 2841               	/* frame size = 14 */
 2842               	/* stack size = 20 */
 2843               	.L__stack_usage = 20
 2844               	.LVL178:
1682:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_TX, RADIO_ADDR_TX_BYTES) == 1) {
 2845               		.loc 1 1682 0
 2846 0f6c 47E0      		ldi r20,lo8(7)
 2847 0f6e 50E0      		ldi r21,0
 2848 0f70 6EE0      		ldi r22,lo8(14)
 2849 0f72 70E0      		ldi r23,0
 2850 0f74 CE01      		movw r24,r28
 2851 0f76 0196      		adiw r24,1
 2852 0f78 0E94 0000 		call readEEPROM
 2853               	.LVL179:
 2854 0f7c 0197      		sbiw r24,1
 2855 0f7e 01F4      		brne .L208
1683:switcherator.c ****         tx_addr = formatAddress(tempStuff);
 2856               		.loc 1 1683 0
 2857 0f80 CE01      		movw r24,r28
 2858 0f82 0196      		adiw r24,1
 2859 0f84 0E94 0000 		call formatAddress
 2860               	.LVL180:
 2861 0f88 2093 0000 		sts tx_addr,r18
 2862 0f8c 3093 0000 		sts tx_addr+1,r19
 2863 0f90 4093 0000 		sts tx_addr+2,r20
 2864 0f94 5093 0000 		sts tx_addr+3,r21
 2865 0f98 6093 0000 		sts tx_addr+4,r22
 2866 0f9c 7093 0000 		sts tx_addr+5,r23
 2867 0fa0 8093 0000 		sts tx_addr+6,r24
 2868 0fa4 9093 0000 		sts tx_addr+7,r25
1684:switcherator.c ****         writeAddr(TX_ADDR, tx_addr);
 2869               		.loc 1 1684 0
 2870 0fa8 8901      		movw r16,r18
 2871 0faa 9A01      		movw r18,r20
 2872 0fac AB01      		movw r20,r22
 2873 0fae BC01      		movw r22,r24
 2874 0fb0 80E1      		ldi r24,lo8(16)
 2875 0fb2 0E94 0000 		call writeAddr
 2876               	.LVL181:
 2877               	.L208:
1686:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R0, RADIO_ADDR_R0_BYTES) == 1) {
 2878               		.loc 1 1686 0
 2879 0fb6 47E0      		ldi r20,lo8(7)
 2880 0fb8 50E0      		ldi r21,0
 2881 0fba 65E1      		ldi r22,lo8(21)
 2882 0fbc 70E0      		ldi r23,0
 2883 0fbe CE01      		movw r24,r28
 2884 0fc0 0196      		adiw r24,1
 2885 0fc2 0E94 0000 		call readEEPROM
 2886               	.LVL182:
 2887 0fc6 0197      		sbiw r24,1
 2888 0fc8 01F4      		brne .L209
1687:switcherator.c ****         rx_addr_p0 = formatAddress(tempStuff);
 2889               		.loc 1 1687 0
 2890 0fca CE01      		movw r24,r28
 2891 0fcc 0196      		adiw r24,1
 2892 0fce 0E94 0000 		call formatAddress
 2893               	.LVL183:
 2894 0fd2 2093 0000 		sts rx_addr_p0,r18
 2895 0fd6 3093 0000 		sts rx_addr_p0+1,r19
 2896 0fda 4093 0000 		sts rx_addr_p0+2,r20
 2897 0fde 5093 0000 		sts rx_addr_p0+3,r21
 2898 0fe2 6093 0000 		sts rx_addr_p0+4,r22
 2899 0fe6 7093 0000 		sts rx_addr_p0+5,r23
 2900 0fea 8093 0000 		sts rx_addr_p0+6,r24
 2901 0fee 9093 0000 		sts rx_addr_p0+7,r25
1688:switcherator.c ****         writeAddr(RX_ADDR_P0, rx_addr_p0);
 2902               		.loc 1 1688 0
 2903 0ff2 8901      		movw r16,r18
 2904 0ff4 9A01      		movw r18,r20
 2905 0ff6 AB01      		movw r20,r22
 2906 0ff8 BC01      		movw r22,r24
 2907 0ffa 8AE0      		ldi r24,lo8(10)
 2908 0ffc 0E94 0000 		call writeAddr
 2909               	.LVL184:
 2910               	.L209:
1691:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R1, RADIO_ADDR_R1_BYTES) == 1) {
 2911               		.loc 1 1691 0
 2912 1000 47E0      		ldi r20,lo8(7)
 2913 1002 50E0      		ldi r21,0
 2914 1004 6CE1      		ldi r22,lo8(28)
 2915 1006 70E0      		ldi r23,0
 2916 1008 CE01      		movw r24,r28
 2917 100a 0196      		adiw r24,1
 2918 100c 0E94 0000 		call readEEPROM
 2919               	.LVL185:
 2920 1010 0197      		sbiw r24,1
 2921 1012 01F4      		brne .L210
1692:switcherator.c ****         rx_addr_p1 = formatAddress(tempStuff);
 2922               		.loc 1 1692 0
 2923 1014 CE01      		movw r24,r28
 2924 1016 0196      		adiw r24,1
 2925 1018 0E94 0000 		call formatAddress
 2926               	.LVL186:
 2927 101c 2093 0000 		sts rx_addr_p1,r18
 2928 1020 3093 0000 		sts rx_addr_p1+1,r19
 2929 1024 4093 0000 		sts rx_addr_p1+2,r20
 2930 1028 5093 0000 		sts rx_addr_p1+3,r21
 2931 102c 6093 0000 		sts rx_addr_p1+4,r22
 2932 1030 7093 0000 		sts rx_addr_p1+5,r23
 2933 1034 8093 0000 		sts rx_addr_p1+6,r24
 2934 1038 9093 0000 		sts rx_addr_p1+7,r25
1693:switcherator.c ****         writeAddr(RX_ADDR_P1, rx_addr_p1);
 2935               		.loc 1 1693 0
 2936 103c 8901      		movw r16,r18
 2937 103e 9A01      		movw r18,r20
 2938 1040 AB01      		movw r20,r22
 2939 1042 BC01      		movw r22,r24
 2940 1044 8BE0      		ldi r24,lo8(11)
 2941 1046 0E94 0000 		call writeAddr
 2942               	.LVL187:
 2943               	.L210:
1695:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R2, RADIO_ADDR_R2_BYTES) == 1) {
 2944               		.loc 1 1695 0
 2945 104a 43E0      		ldi r20,lo8(3)
 2946 104c 50E0      		ldi r21,0
 2947 104e 63E2      		ldi r22,lo8(35)
 2948 1050 70E0      		ldi r23,0
 2949 1052 CE01      		movw r24,r28
 2950 1054 0196      		adiw r24,1
 2951 1056 0E94 0000 		call readEEPROM
 2952               	.LVL188:
 2953 105a 0197      		sbiw r24,1
 2954 105c 01F4      		brne .L211
1696:switcherator.c ****         rx_addr_p2 = tempStuff[0];
 2955               		.loc 1 1696 0
 2956 105e 0981      		ldd r16,Y+1
 2957 1060 0093 0000 		sts rx_addr_p2,r16
 2958 1064 1092 0000 		sts rx_addr_p2+1,__zero_reg__
 2959 1068 1092 0000 		sts rx_addr_p2+2,__zero_reg__
 2960 106c 1092 0000 		sts rx_addr_p2+3,__zero_reg__
 2961 1070 1092 0000 		sts rx_addr_p2+4,__zero_reg__
 2962 1074 1092 0000 		sts rx_addr_p2+5,__zero_reg__
 2963 1078 1092 0000 		sts rx_addr_p2+6,__zero_reg__
 2964 107c 1092 0000 		sts rx_addr_p2+7,__zero_reg__
1697:switcherator.c ****         writeAddr(RX_ADDR_P2, rx_addr_p2);
 2965               		.loc 1 1697 0
 2966 1080 10E0      		ldi r17,0
 2967 1082 20E0      		ldi r18,0
 2968 1084 30E0      		ldi r19,0
 2969 1086 40E0      		ldi r20,0
 2970 1088 50E0      		ldi r21,0
 2971 108a 60E0      		ldi r22,0
 2972 108c 70E0      		ldi r23,0
 2973 108e 8CE0      		ldi r24,lo8(12)
 2974 1090 0E94 0000 		call writeAddr
 2975               	.LVL189:
 2976               	.L211:
1699:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R3, RADIO_ADDR_R3_BYTES) == 1) {
 2977               		.loc 1 1699 0
 2978 1094 43E0      		ldi r20,lo8(3)
 2979 1096 50E0      		ldi r21,0
 2980 1098 66E2      		ldi r22,lo8(38)
 2981 109a 70E0      		ldi r23,0
 2982 109c CE01      		movw r24,r28
 2983 109e 0196      		adiw r24,1
 2984 10a0 0E94 0000 		call readEEPROM
 2985               	.LVL190:
 2986 10a4 0197      		sbiw r24,1
 2987 10a6 01F4      		brne .L212
1700:switcherator.c ****         rx_addr_p3 = tempStuff[0];
 2988               		.loc 1 1700 0
 2989 10a8 0981      		ldd r16,Y+1
 2990 10aa 0093 0000 		sts rx_addr_p3,r16
 2991 10ae 1092 0000 		sts rx_addr_p3+1,__zero_reg__
 2992 10b2 1092 0000 		sts rx_addr_p3+2,__zero_reg__
 2993 10b6 1092 0000 		sts rx_addr_p3+3,__zero_reg__
 2994 10ba 1092 0000 		sts rx_addr_p3+4,__zero_reg__
 2995 10be 1092 0000 		sts rx_addr_p3+5,__zero_reg__
 2996 10c2 1092 0000 		sts rx_addr_p3+6,__zero_reg__
 2997 10c6 1092 0000 		sts rx_addr_p3+7,__zero_reg__
1701:switcherator.c ****         writeAddr(RX_ADDR_P3, rx_addr_p3);
 2998               		.loc 1 1701 0
 2999 10ca 10E0      		ldi r17,0
 3000 10cc 20E0      		ldi r18,0
 3001 10ce 30E0      		ldi r19,0
 3002 10d0 40E0      		ldi r20,0
 3003 10d2 50E0      		ldi r21,0
 3004 10d4 60E0      		ldi r22,0
 3005 10d6 70E0      		ldi r23,0
 3006 10d8 8DE0      		ldi r24,lo8(13)
 3007 10da 0E94 0000 		call writeAddr
 3008               	.LVL191:
 3009               	.L212:
1703:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R4, RADIO_ADDR_R4_BYTES) == 1) {
 3010               		.loc 1 1703 0
 3011 10de 43E0      		ldi r20,lo8(3)
 3012 10e0 50E0      		ldi r21,0
 3013 10e2 69E2      		ldi r22,lo8(41)
 3014 10e4 70E0      		ldi r23,0
 3015 10e6 CE01      		movw r24,r28
 3016 10e8 0196      		adiw r24,1
 3017 10ea 0E94 0000 		call readEEPROM
 3018               	.LVL192:
 3019 10ee 0197      		sbiw r24,1
 3020 10f0 01F4      		brne .L213
1704:switcherator.c ****         rx_addr_p4 = tempStuff[0];
 3021               		.loc 1 1704 0
 3022 10f2 0981      		ldd r16,Y+1
 3023 10f4 0093 0000 		sts rx_addr_p4,r16
 3024 10f8 1092 0000 		sts rx_addr_p4+1,__zero_reg__
 3025 10fc 1092 0000 		sts rx_addr_p4+2,__zero_reg__
 3026 1100 1092 0000 		sts rx_addr_p4+3,__zero_reg__
 3027 1104 1092 0000 		sts rx_addr_p4+4,__zero_reg__
 3028 1108 1092 0000 		sts rx_addr_p4+5,__zero_reg__
 3029 110c 1092 0000 		sts rx_addr_p4+6,__zero_reg__
 3030 1110 1092 0000 		sts rx_addr_p4+7,__zero_reg__
1705:switcherator.c ****         writeAddr(RX_ADDR_P4, rx_addr_p4);
 3031               		.loc 1 1705 0
 3032 1114 10E0      		ldi r17,0
 3033 1116 20E0      		ldi r18,0
 3034 1118 30E0      		ldi r19,0
 3035 111a 40E0      		ldi r20,0
 3036 111c 50E0      		ldi r21,0
 3037 111e 60E0      		ldi r22,0
 3038 1120 70E0      		ldi r23,0
 3039 1122 8EE0      		ldi r24,lo8(14)
 3040 1124 0E94 0000 		call writeAddr
 3041               	.LVL193:
 3042               	.L213:
1707:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R5, RADIO_ADDR_R5_BYTES) == 1) {
 3043               		.loc 1 1707 0
 3044 1128 43E0      		ldi r20,lo8(3)
 3045 112a 50E0      		ldi r21,0
 3046 112c 6CE2      		ldi r22,lo8(44)
 3047 112e 70E0      		ldi r23,0
 3048 1130 CE01      		movw r24,r28
 3049 1132 0196      		adiw r24,1
 3050 1134 0E94 0000 		call readEEPROM
 3051               	.LVL194:
 3052 1138 0197      		sbiw r24,1
 3053 113a 01F4      		brne .L214
1708:switcherator.c ****         rx_addr_p5 = tempStuff[0];
 3054               		.loc 1 1708 0
 3055 113c 0981      		ldd r16,Y+1
 3056 113e 0093 0000 		sts rx_addr_p5,r16
 3057 1142 1092 0000 		sts rx_addr_p5+1,__zero_reg__
 3058 1146 1092 0000 		sts rx_addr_p5+2,__zero_reg__
 3059 114a 1092 0000 		sts rx_addr_p5+3,__zero_reg__
 3060 114e 1092 0000 		sts rx_addr_p5+4,__zero_reg__
 3061 1152 1092 0000 		sts rx_addr_p5+5,__zero_reg__
 3062 1156 1092 0000 		sts rx_addr_p5+6,__zero_reg__
 3063 115a 1092 0000 		sts rx_addr_p5+7,__zero_reg__
1709:switcherator.c ****         writeAddr(RX_ADDR_P5, rx_addr_p5);
 3064               		.loc 1 1709 0
 3065 115e 10E0      		ldi r17,0
 3066 1160 20E0      		ldi r18,0
 3067 1162 30E0      		ldi r19,0
 3068 1164 40E0      		ldi r20,0
 3069 1166 50E0      		ldi r21,0
 3070 1168 60E0      		ldi r22,0
 3071 116a 70E0      		ldi r23,0
 3072 116c 8FE0      		ldi r24,lo8(15)
 3073 116e 0E94 0000 		call writeAddr
 3074               	.LVL195:
 3075               	.L214:
1711:switcherator.c ****     if (readEEPROM(tempStuff, TWEAK_TIMER, TWEAK_TIMER_BYTES) == 1) {
 3076               		.loc 1 1711 0
 3077 1172 44E0      		ldi r20,lo8(4)
 3078 1174 50E0      		ldi r21,0
 3079 1176 69E1      		ldi r22,lo8(25)
 3080 1178 71E0      		ldi r23,lo8(1)
 3081 117a CE01      		movw r24,r28
 3082 117c 0196      		adiw r24,1
 3083 117e 0E94 0000 		call readEEPROM
 3084               	.LVL196:
 3085 1182 0197      		sbiw r24,1
 3086 1184 01F4      		brne .L215
1712:switcherator.c ****         tweakTimer = tempStuff[0];
 3087               		.loc 1 1712 0
 3088 1186 8981      		ldd r24,Y+1
 3089 1188 90E0      		ldi r25,0
 3090 118a A0E0      		ldi r26,0
 3091 118c B0E0      		ldi r27,0
1713:switcherator.c ****         tweakTimer <<= 8;
 3092               		.loc 1 1713 0
 3093 118e BA2F      		mov r27,r26
 3094 1190 A92F      		mov r26,r25
 3095 1192 982F      		mov r25,r24
 3096 1194 8827      		clr r24
1714:switcherator.c ****         tweakTimer |= tempStuff[1];
 3097               		.loc 1 1714 0
 3098 1196 2A81      		ldd r18,Y+2
 3099 1198 822B      		or r24,r18
 3100 119a 8093 0000 		sts tweakTimer,r24
 3101 119e 9093 0000 		sts tweakTimer+1,r25
 3102 11a2 A093 0000 		sts tweakTimer+2,r26
 3103 11a6 B093 0000 		sts tweakTimer+3,r27
 3104               	.L215:
1719:switcherator.c ****     if (readEEPROM(tempStuff, DAYLIGHT_SAVE, DAYLIGHT_SAVE_BYTES) == 1) {
 3105               		.loc 1 1719 0
 3106 11aa 4AE0      		ldi r20,lo8(10)
 3107 11ac 50E0      		ldi r21,0
 3108 11ae 66E0      		ldi r22,lo8(6)
 3109 11b0 70E0      		ldi r23,0
 3110 11b2 CE01      		movw r24,r28
 3111 11b4 0196      		adiw r24,1
 3112 11b6 0E94 0000 		call readEEPROM
 3113               	.LVL197:
 3114 11ba 0197      		sbiw r24,1
 3115 11bc 01F4      		brne .L216
1721:switcherator.c ****         daylightSavings[0][0] = ((tempStuff[0] << 8) | (tempStuff[1]));
 3116               		.loc 1 1721 0
 3117 11be 9981      		ldd r25,Y+1
 3118 11c0 80E0      		ldi r24,0
 3119 11c2 2A81      		ldd r18,Y+2
 3120 11c4 822B      		or r24,r18
 3121 11c6 9093 0000 		sts daylightSavings+1,r25
 3122 11ca 8093 0000 		sts daylightSavings,r24
1723:switcherator.c ****         daylightSavings[0][1] = ((tempStuff[2] << 8) | (tempStuff[3]));
 3123               		.loc 1 1723 0
 3124 11ce 9B81      		ldd r25,Y+3
 3125 11d0 80E0      		ldi r24,0
 3126 11d2 2C81      		ldd r18,Y+4
 3127 11d4 822B      		or r24,r18
 3128 11d6 9093 0000 		sts daylightSavings+2+1,r25
 3129 11da 8093 0000 		sts daylightSavings+2,r24
1725:switcherator.c ****         daylightSavings[1][0] = ((tempStuff[4] << 8) | (tempStuff[5]));
 3130               		.loc 1 1725 0
 3131 11de 9D81      		ldd r25,Y+5
 3132 11e0 80E0      		ldi r24,0
 3133 11e2 2E81      		ldd r18,Y+6
 3134 11e4 822B      		or r24,r18
 3135 11e6 9093 0000 		sts daylightSavings+4+1,r25
 3136 11ea 8093 0000 		sts daylightSavings+4,r24
1727:switcherator.c ****         daylightSavings[1][1] = ((tempStuff[6] << 8) | (tempStuff[7]));
 3137               		.loc 1 1727 0
 3138 11ee 9F81      		ldd r25,Y+7
 3139 11f0 80E0      		ldi r24,0
 3140 11f2 2885      		ldd r18,Y+8
 3141 11f4 822B      		or r24,r18
 3142 11f6 9093 0000 		sts daylightSavings+6+1,r25
 3143 11fa 8093 0000 		sts daylightSavings+6,r24
 3144               	.L216:
1732:switcherator.c ****     if (readEEPROM(switchStuff, SWITCH_STUFF, SWITCH_STUFF_BYTES) == 1) {
 3145               		.loc 1 1732 0
 3146 11fe 42E1      		ldi r20,lo8(18)
 3147 1200 50E0      		ldi r21,0
 3148 1202 60E3      		ldi r22,lo8(48)
 3149 1204 70E0      		ldi r23,0
 3150 1206 80E0      		ldi r24,lo8(switchStuff)
 3151 1208 90E0      		ldi r25,hi8(switchStuff)
 3152 120a 0E94 0000 		call readEEPROM
 3153               	.LVL198:
 3154 120e 0197      		sbiw r24,1
 3155 1210 01F0      		breq .+2
 3156 1212 00C0      		rjmp .L217
 3157               	.LBB22:
1733:switcherator.c ****         readEEPROM(switchBright, BRIGHTNESS, BRIGHTNESS_BYTES);
 3158               		.loc 1 1733 0
 3159 1214 42E1      		ldi r20,lo8(18)
 3160 1216 50E0      		ldi r21,0
 3161 1218 60E2      		ldi r22,lo8(32)
 3162 121a 71E0      		ldi r23,lo8(1)
 3163 121c 80E0      		ldi r24,lo8(switchBright)
 3164 121e 90E0      		ldi r25,hi8(switchBright)
 3165 1220 0E94 0000 		call readEEPROM
 3166               	.LVL199:
 3167 1224 80E0      		ldi r24,lo8(switchStuff)
 3168 1226 90E0      		ldi r25,hi8(switchStuff)
1800:switcherator.c ****             *realDDR |= (1 << realPin);
 3169               		.loc 1 1800 0
 3170 1228 41E0      		ldi r20,lo8(1)
 3171 122a 50E0      		ldi r21,0
 3172               	.LVL200:
 3173               	.L222:
1742:switcherator.c ****             temp = switchStuff[x];
 3174               		.loc 1 1742 0
 3175 122c FC01      		movw r30,r24
 3176 122e 2191      		ld r18,Z+
 3177 1230 CF01      		movw r24,r30
 3178               	.LVL201:
1743:switcherator.c ****             if (temp > 15 && temp < 32) {
 3179               		.loc 1 1743 0
 3180 1232 622F      		mov r22,r18
 3181 1234 6051      		subi r22,lo8(-(-16))
 3182 1236 6031      		cpi r22,lo8(16)
 3183 1238 00F0      		brlo .L243
1754:switcherator.c ****             } else if (temp < 48) {
 3184               		.loc 1 1754 0
 3185 123a 2033      		cpi r18,lo8(48)
 3186 123c 00F4      		brsh .L219
 3187               	.LVL202:
1757:switcherator.c ****                 temp -= 32;
 3188               		.loc 1 1757 0
 3189 123e 6051      		subi r22,lo8(-(-16))
 3190               	.LVL203:
1756:switcherator.c ****                 realDDR = &DDRC;
 3191               		.loc 1 1756 0
 3192 1240 A7E2      		ldi r26,lo8(39)
 3193 1242 B0E0      		ldi r27,0
1755:switcherator.c ****                 realPort = &PORTC;
 3194               		.loc 1 1755 0
 3195 1244 E8E2      		ldi r30,lo8(40)
 3196 1246 F0E0      		ldi r31,0
 3197 1248 00C0      		rjmp .L218
 3198               	.LVL204:
 3199               	.L219:
1760:switcherator.c ****             } else if (temp < 64) {
 3200               		.loc 1 1760 0
 3201 124a 2034      		cpi r18,lo8(64)
 3202 124c 00F4      		brsh .L220
 3203               	.LVL205:
1763:switcherator.c ****                 temp -= 48;
 3204               		.loc 1 1763 0
 3205 124e 622F      		mov r22,r18
 3206 1250 6053      		subi r22,lo8(-(-48))
 3207               	.LVL206:
1762:switcherator.c ****                 realDDR = &DDRD;
 3208               		.loc 1 1762 0
 3209 1252 AAE2      		ldi r26,lo8(42)
 3210 1254 B0E0      		ldi r27,0
1761:switcherator.c ****                 realPort = &PORTD;
 3211               		.loc 1 1761 0
 3212 1256 EBE2      		ldi r30,lo8(43)
 3213 1258 F0E0      		ldi r31,0
 3214 125a 00C0      		rjmp .L218
 3215               	.LVL207:
 3216               	.L243:
1745:switcherator.c ****                 realDDR = &DDRB;
 3217               		.loc 1 1745 0
 3218 125c A4E2      		ldi r26,lo8(36)
 3219 125e B0E0      		ldi r27,0
1744:switcherator.c ****                 realPort = &PORTB;
 3220               		.loc 1 1744 0
 3221 1260 E5E2      		ldi r30,lo8(37)
 3222 1262 F0E0      		ldi r31,0
 3223               	.LVL208:
 3224               	.L218:
1800:switcherator.c ****             *realDDR |= (1 << realPin);
 3225               		.loc 1 1800 0
 3226 1264 7C91      		ld r23,X
1799:switcherator.c ****             realPin = (temp / 2);
 3227               		.loc 1 1799 0
 3228 1266 262F      		mov r18,r22
 3229 1268 2695      		lsr r18
 3230               	.LVL209:
1800:switcherator.c ****             *realDDR |= (1 << realPin);
 3231               		.loc 1 1800 0
 3232 126a 8A01      		movw r16,r20
 3233 126c 00C0      		rjmp 2f
 3234               		1:
 3235 126e 000F      		lsl r16
 3236 1270 111F      		rol r17
 3237               		2:
 3238 1272 2A95      		dec r18
 3239 1274 02F4      		brpl 1b
 3240 1276 9801      		movw r18,r16
 3241               	.LVL210:
 3242 1278 702B      		or r23,r16
 3243 127a 7C93      		st X,r23
1802:switcherator.c ****             if (temp % 2 == 0) {
 3244               		.loc 1 1802 0
 3245 127c 60FD      		sbrc r22,0
 3246 127e 00C0      		rjmp .L221
1804:switcherator.c ****                 *realPort |= (1 << realPin);
 3247               		.loc 1 1804 0
 3248 1280 2081      		ld r18,Z
 3249 1282 202B      		or r18,r16
 3250 1284 00C0      		rjmp .L254
 3251               	.L221:
1806:switcherator.c ****                 *realPort &= ~(1 << realPin);
 3252               		.loc 1 1806 0
 3253 1286 3081      		ld r19,Z
 3254 1288 2095      		com r18
 3255 128a 2323      		and r18,r19
 3256               	.L254:
 3257 128c 2083      		st Z,r18
 3258               	.LVL211:
 3259               	.L220:
1741:switcherator.c ****         for (x = 0; x < NUM_SWITCHES; x++) {
 3260               		.loc 1 1741 0
 3261 128e 10E0      		ldi r17,hi8(switchStuff+16)
 3262 1290 8030      		cpi r24,lo8(switchStuff+16)
 3263 1292 9107      		cpc r25,r17
 3264 1294 01F4      		brne .L222
 3265               	.L225:
 3266               	.LVL212:
 3267 1296 40E0      		ldi r20,lo8(weeklyProgram)
 3268 1298 E42E      		mov r14,r20
 3269 129a 40E0      		ldi r20,hi8(weeklyProgram)
 3270 129c F42E      		mov r15,r20
1761:switcherator.c ****                 realPort = &PORTD;
 3271               		.loc 1 1761 0
 3272 129e 01EA      		ldi r16,lo8(-95)
 3273 12a0 10E0      		ldi r17,0
 3274 12a2 00C0      		rjmp .L223
 3275               	.L217:
 3276 12a4 E0E0      		ldi r30,lo8(switchStuff)
 3277 12a6 F0E0      		ldi r31,hi8(switchStuff)
 3278               	.LBE22:
1811:switcherator.c ****             switchStuff[x] = 255;
 3279               		.loc 1 1811 0
 3280 12a8 8FEF      		ldi r24,lo8(-1)
 3281               	.LVL213:
 3282               	.L224:
1811:switcherator.c ****             switchStuff[x] = 255;
 3283               		.loc 1 1811 0 is_stmt 0 discriminator 2
 3284 12aa 8193      		st Z+,r24
1810:switcherator.c ****         for (x = 0; x < NUM_SWITCHES; x++)
 3285               		.loc 1 1810 0 is_stmt 1 discriminator 2
 3286 12ac 20E0      		ldi r18,hi8(switchStuff+16)
 3287 12ae E030      		cpi r30,lo8(switchStuff+16)
 3288 12b0 F207      		cpc r31,r18
 3289 12b2 01F4      		brne .L224
 3290 12b4 00C0      		rjmp .L225
 3291               	.L223:
 3292               	.LVL214:
1819:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, WEEKLY_PROGRAM_BYTES) == 1) {
 3293               		.loc 1 1819 0
 3294 12b6 4CE0      		ldi r20,lo8(12)
 3295 12b8 50E0      		ldi r21,0
 3296 12ba B801      		movw r22,r16
 3297 12bc CE01      		movw r24,r28
 3298 12be 0196      		adiw r24,1
 3299 12c0 0E94 0000 		call readEEPROM
 3300               	.LVL215:
 3301 12c4 0197      		sbiw r24,1
 3302 12c6 01F0      		breq .L226
 3303               	.L229:
 3304 12c8 045F      		subi r16,-12
 3305 12ca 1F4F      		sbci r17,-1
 3306               	.LVL216:
 3307 12cc 8AE0      		ldi r24,10
 3308 12ce E80E      		add r14,r24
 3309 12d0 F11C      		adc r15,__zero_reg__
1817:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 3310               		.loc 1 1817 0
 3311 12d2 0931      		cpi r16,25
 3312 12d4 91E0      		ldi r25,1
 3313 12d6 1907      		cpc r17,r25
 3314 12d8 01F4      		brne .L223
 3315 12da 00C0      		rjmp .L252
 3316               	.LVL217:
 3317               	.L226:
 3318 12dc FE01      		movw r30,r28
 3319 12de 3196      		adiw r30,1
1819:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, WEEKLY_PROGRAM_BYTES) == 1) {
 3320               		.loc 1 1819 0
 3321 12e0 80E0      		ldi r24,0
 3322 12e2 90E0      		ldi r25,0
 3323               	.L228:
1821:switcherator.c ****                 weeklyProgram[x][y] = tempStuff[y];
 3324               		.loc 1 1821 0 discriminator 2
 3325 12e4 2191      		ld r18,Z+
1676:switcherator.c **** void generalInit(void) {
 3326               		.loc 1 1676 0 discriminator 2
 3327 12e6 D701      		movw r26,r14
 3328 12e8 A80F      		add r26,r24
 3329 12ea B91F      		adc r27,r25
1821:switcherator.c ****                 weeklyProgram[x][y] = tempStuff[y];
 3330               		.loc 1 1821 0 discriminator 2
 3331 12ec 2C93      		st X,r18
1820:switcherator.c ****             for (y = 0; y < 10; y++) {
 3332               		.loc 1 1820 0 discriminator 2
 3333 12ee 0196      		adiw r24,1
 3334               	.LVL218:
 3335 12f0 8A30      		cpi r24,10
 3336 12f2 9105      		cpc r25,__zero_reg__
 3337 12f4 01F4      		brne .L228
 3338 12f6 00C0      		rjmp .L229
 3339               	.LVL219:
 3340               	.L252:
 3341 12f8 30E0      		ldi r19,lo8(inputs)
 3342 12fa E32E      		mov r14,r19
 3343 12fc 30E0      		ldi r19,hi8(inputs)
 3344 12fe F32E      		mov r15,r19
1817:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 3345               		.loc 1 1817 0
 3346 1300 02E4      		ldi r16,lo8(66)
 3347 1302 10E0      		ldi r17,0
 3348               	.LVL220:
 3349               	.L231:
1828:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, INPUT_BYTES) == 1) {
 3350               		.loc 1 1828 0
 3351 1304 4AE0      		ldi r20,lo8(10)
 3352 1306 50E0      		ldi r21,0
 3353 1308 B801      		movw r22,r16
 3354 130a CE01      		movw r24,r28
 3355 130c 0196      		adiw r24,1
 3356 130e 0E94 0000 		call readEEPROM
 3357               	.LVL221:
 3358 1312 0197      		sbiw r24,1
 3359 1314 01F0      		breq .L230
 3360               	.L234:
 3361 1316 065F      		subi r16,-10
 3362 1318 1F4F      		sbci r17,-1
 3363               	.LVL222:
 3364 131a E8E0      		ldi r30,8
 3365 131c EE0E      		add r14,r30
 3366 131e F11C      		adc r15,__zero_reg__
1826:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 3367               		.loc 1 1826 0
 3368 1320 0A36      		cpi r16,106
 3369 1322 1105      		cpc r17,__zero_reg__
 3370 1324 01F4      		brne .L231
 3371 1326 00C0      		rjmp .L253
 3372               	.LVL223:
 3373               	.L230:
 3374 1328 FE01      		movw r30,r28
 3375 132a 3196      		adiw r30,1
1828:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, INPUT_BYTES) == 1) {
 3376               		.loc 1 1828 0
 3377 132c 80E0      		ldi r24,0
 3378 132e 90E0      		ldi r25,0
 3379               	.L233:
1830:switcherator.c ****                 inputs[x][y] = tempStuff[y];
 3380               		.loc 1 1830 0 discriminator 2
 3381 1330 2191      		ld r18,Z+
1676:switcherator.c **** void generalInit(void) {
 3382               		.loc 1 1676 0 discriminator 2
 3383 1332 D701      		movw r26,r14
 3384 1334 A80F      		add r26,r24
 3385 1336 B91F      		adc r27,r25
1830:switcherator.c ****                 inputs[x][y] = tempStuff[y];
 3386               		.loc 1 1830 0 discriminator 2
 3387 1338 2C93      		st X,r18
1829:switcherator.c ****             for (y = 0; y < 8; y++) {
 3388               		.loc 1 1829 0 discriminator 2
 3389 133a 0196      		adiw r24,1
 3390               	.LVL224:
 3391 133c 8830      		cpi r24,8
 3392 133e 9105      		cpc r25,__zero_reg__
 3393 1340 01F4      		brne .L233
 3394 1342 00C0      		rjmp .L234
 3395               	.LVL225:
 3396               	.L253:
 3397 1344 00E0      		ldi r16,lo8(timeLimits)
 3398 1346 10E0      		ldi r17,hi8(timeLimits)
 3399               	.LVL226:
1826:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 3400               		.loc 1 1826 0
 3401 1348 2AE6      		ldi r18,lo8(106)
 3402 134a E22E      		mov r14,r18
 3403 134c F12C      		mov r15,__zero_reg__
 3404               	.L236:
 3405               	.LVL227:
1837:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, LIMIT_BYTES) == 1) {
 3406               		.loc 1 1837 0
 3407 134e 45E0      		ldi r20,lo8(5)
 3408 1350 50E0      		ldi r21,0
 3409 1352 B701      		movw r22,r14
 3410 1354 CE01      		movw r24,r28
 3411 1356 0196      		adiw r24,1
 3412 1358 0E94 0000 		call readEEPROM
 3413               	.LVL228:
 3414 135c 0197      		sbiw r24,1
 3415 135e 01F4      		brne .L235
 3416               	.LVL229:
1839:switcherator.c ****                 timeLimits[x][y] = tempStuff[y];
 3417               		.loc 1 1839 0 discriminator 1
 3418 1360 8981      		ldd r24,Y+1
 3419 1362 90E0      		ldi r25,0
 3420 1364 A0E0      		ldi r26,0
 3421 1366 B0E0      		ldi r27,0
 3422 1368 F801      		movw r30,r16
 3423 136a 8083      		st Z,r24
 3424 136c 9183      		std Z+1,r25
 3425 136e A283      		std Z+2,r26
 3426 1370 B383      		std Z+3,r27
 3427               	.LVL230:
 3428 1372 8A81      		ldd r24,Y+2
 3429 1374 90E0      		ldi r25,0
 3430 1376 A0E0      		ldi r26,0
 3431 1378 B0E0      		ldi r27,0
 3432 137a 8483      		std Z+4,r24
 3433 137c 9583      		std Z+5,r25
 3434 137e A683      		std Z+6,r26
 3435 1380 B783      		std Z+7,r27
 3436               	.LVL231:
 3437 1382 8B81      		ldd r24,Y+3
 3438 1384 90E0      		ldi r25,0
 3439 1386 A0E0      		ldi r26,0
 3440 1388 B0E0      		ldi r27,0
 3441 138a 8087      		std Z+8,r24
 3442 138c 9187      		std Z+9,r25
 3443 138e A287      		std Z+10,r26
 3444 1390 B387      		std Z+11,r27
 3445               	.LVL232:
 3446               	.L235:
 3447 1392 F5E0      		ldi r31,5
 3448 1394 EF0E      		add r14,r31
 3449 1396 F11C      		adc r15,__zero_reg__
 3450               	.LVL233:
 3451 1398 045F      		subi r16,-12
 3452 139a 1F4F      		sbci r17,-1
1835:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++) {
 3453               		.loc 1 1835 0
 3454 139c 2EE7      		ldi r18,126
 3455 139e E216      		cp r14,r18
 3456 13a0 F104      		cpc r15,__zero_reg__
 3457 13a2 01F4      		brne .L236
1844:switcherator.c ****     if (readEEPROM(tempStuff, PWM_DIR, PWM_DIR_BYTES) == 1) {
 3458               		.loc 1 1844 0
 3459 13a4 43E0      		ldi r20,lo8(3)
 3460 13a6 50E0      		ldi r21,0
 3461 13a8 6DE1      		ldi r22,lo8(29)
 3462 13aa 71E0      		ldi r23,lo8(1)
 3463 13ac CE01      		movw r24,r28
 3464 13ae 0196      		adiw r24,1
 3465 13b0 0E94 0000 		call readEEPROM
 3466               	.LVL234:
 3467 13b4 0197      		sbiw r24,1
 3468 13b6 01F4      		brne .L237
1845:switcherator.c ****         DDRD |= (1 << PIND3) | (1 << PIND5) | (1 << PIND6);
 3469               		.loc 1 1845 0
 3470 13b8 8AB1      		in r24,0xa
 3471 13ba 8866      		ori r24,lo8(104)
 3472 13bc 8AB9      		out 0xa,r24
1847:switcherator.c ****         Red = 0;
 3473               		.loc 1 1847 0
 3474 13be 1092 B400 		sts 180,__zero_reg__
1848:switcherator.c ****         Green = 0;
 3475               		.loc 1 1848 0
 3476 13c2 18BC      		out 0x28,__zero_reg__
1849:switcherator.c ****         Blue = 0;
 3477               		.loc 1 1849 0
 3478 13c4 17BC      		out 0x27,__zero_reg__
1852:switcherator.c ****         if (tempStuff[0] == 0) {
 3479               		.loc 1 1852 0
 3480 13c6 8981      		ldd r24,Y+1
 3481 13c8 8111      		cpse r24,__zero_reg__
 3482 13ca 00C0      		rjmp .L238
1853:switcherator.c ****             TCCR0A = (1 << COM0A0) | (1 << COM0A1) | (1 << COM0B0) | (1 << COM0B1) | (1 << WGM00);
 3483               		.loc 1 1853 0
 3484 13cc 81EF      		ldi r24,lo8(-15)
 3485 13ce 84BD      		out 0x24,r24
1854:switcherator.c ****             TCCR2A = (1 << COM2B0) | (1 << COM2B1) | (1 << WGM20);
 3486               		.loc 1 1854 0
 3487 13d0 81E3      		ldi r24,lo8(49)
 3488 13d2 8093 B000 		sts 176,r24
1855:switcherator.c ****             pwmdir = 0;
 3489               		.loc 1 1855 0
 3490 13d6 1092 0000 		sts pwmdir,__zero_reg__
 3491 13da 00C0      		rjmp .L239
 3492               	.L238:
1857:switcherator.c ****             TCCR0A = (1 << COM0A1) | (1 << COM0B1) | (1 << WGM00);
 3493               		.loc 1 1857 0
 3494 13dc 81EA      		ldi r24,lo8(-95)
 3495 13de 84BD      		out 0x24,r24
1858:switcherator.c ****             TCCR2A = (1 << COM2B1) | (1 << WGM20);
 3496               		.loc 1 1858 0
 3497 13e0 81E2      		ldi r24,lo8(33)
 3498 13e2 8093 B000 		sts 176,r24
1859:switcherator.c ****             pwmdir = 1;
 3499               		.loc 1 1859 0
 3500 13e6 81E0      		ldi r24,lo8(1)
 3501 13e8 8093 0000 		sts pwmdir,r24
 3502               	.L239:
1862:switcherator.c ****         TCCR0B = (1 << CS01) | (1 << CS00);
 3503               		.loc 1 1862 0
 3504 13ec 83E0      		ldi r24,lo8(3)
 3505 13ee 85BD      		out 0x25,r24
1864:switcherator.c ****         TCCR2B = (1 << CS22); // F_CPU/64
 3506               		.loc 1 1864 0
 3507 13f0 84E0      		ldi r24,lo8(4)
 3508 13f2 8093 B100 		sts 177,r24
 3509               	.L237:
 3510               	.LVL235:
1869:switcherator.c ****     if (readEEPROM(tempStuff, memoryMarker, PWM_VALUE_BYTES) == 1) {
 3511               		.loc 1 1869 0
 3512 13f6 45E0      		ldi r20,lo8(5)
 3513 13f8 50E0      		ldi r21,0
 3514 13fa 6EE7      		ldi r22,lo8(126)
 3515 13fc 70E0      		ldi r23,0
 3516 13fe CE01      		movw r24,r28
 3517 1400 0196      		adiw r24,1
 3518 1402 0E94 0000 		call readEEPROM
 3519               	.LVL236:
 3520 1406 0197      		sbiw r24,1
 3521 1408 01F4      		brne .L240
1870:switcherator.c ****         pwmValues[0] = tempStuff[0];
 3522               		.loc 1 1870 0
 3523 140a 8981      		ldd r24,Y+1
 3524 140c 8093 0000 		sts pwmValues,r24
1871:switcherator.c ****         pwmValues[1] = tempStuff[1];
 3525               		.loc 1 1871 0
 3526 1410 8A81      		ldd r24,Y+2
 3527 1412 8093 0000 		sts pwmValues+1,r24
1872:switcherator.c ****         pwmValues[2] = tempStuff[2];
 3528               		.loc 1 1872 0
 3529 1416 8B81      		ldd r24,Y+3
 3530 1418 8093 0000 		sts pwmValues+2,r24
 3531               	.L240:
 3532               	.LVL237:
 3533 141c 00E0      		ldi r16,lo8(colorChanges+2)
 3534 141e 10E0      		ldi r17,hi8(colorChanges+2)
1826:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 3535               		.loc 1 1826 0 discriminator 1
 3536 1420 93E8      		ldi r25,lo8(-125)
 3537 1422 E92E      		mov r14,r25
 3538 1424 F12C      		mov r15,__zero_reg__
 3539               	.LVL238:
 3540               	.L242:
1877:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, PWM_VALUE_BYTES) == 1) {
 3541               		.loc 1 1877 0
 3542 1426 45E0      		ldi r20,lo8(5)
 3543 1428 50E0      		ldi r21,0
 3544 142a B701      		movw r22,r14
 3545 142c CE01      		movw r24,r28
 3546 142e 0196      		adiw r24,1
 3547 1430 0E94 0000 		call readEEPROM
 3548               	.LVL239:
 3549 1434 0197      		sbiw r24,1
 3550 1436 01F4      		brne .L241
 3551               	.LVL240:
1676:switcherator.c **** void generalInit(void) {
 3552               		.loc 1 1676 0 discriminator 1
 3553 1438 F801      		movw r30,r16
 3554 143a 3297      		sbiw r30,2
1879:switcherator.c ****                 colorChanges[x][y] = tempStuff[y];
 3555               		.loc 1 1879 0 discriminator 1
 3556 143c 8981      		ldd r24,Y+1
 3557 143e 8083      		st Z,r24
 3558               	.LVL241:
1676:switcherator.c **** void generalInit(void) {
 3559               		.loc 1 1676 0 discriminator 1
 3560 1440 F801      		movw r30,r16
 3561 1442 3197      		sbiw r30,1
1879:switcherator.c ****                 colorChanges[x][y] = tempStuff[y];
 3562               		.loc 1 1879 0 discriminator 1
 3563 1444 8A81      		ldd r24,Y+2
 3564 1446 8083      		st Z,r24
 3565               	.LVL242:
 3566 1448 8B81      		ldd r24,Y+3
 3567 144a F801      		movw r30,r16
 3568 144c 8083      		st Z,r24
 3569               	.LVL243:
 3570               	.L241:
 3571 144e F5E0      		ldi r31,5
 3572 1450 EF0E      		add r14,r31
 3573 1452 F11C      		adc r15,__zero_reg__
 3574               	.LVL244:
 3575 1454 0D5F      		subi r16,-3
 3576 1456 1F4F      		sbci r17,-1
1875:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 3577               		.loc 1 1875 0
 3578 1458 21EA      		ldi r18,-95
 3579 145a E216      		cp r14,r18
 3580 145c F104      		cpc r15,__zero_reg__
 3581 145e 01F4      		brne .L242
 3582               	/* epilogue start */
1883:switcherator.c **** }
 3583               		.loc 1 1883 0
 3584 1460 2E96      		adiw r28,14
 3585 1462 0FB6      		in __tmp_reg__,__SREG__
 3586 1464 F894      		cli
 3587 1466 DEBF      		out __SP_H__,r29
 3588 1468 0FBE      		out __SREG__,__tmp_reg__
 3589 146a CDBF      		out __SP_L__,r28
 3590 146c DF91      		pop r29
 3591 146e CF91      		pop r28
 3592 1470 1F91      		pop r17
 3593 1472 0F91      		pop r16
 3594 1474 FF90      		pop r15
 3595 1476 EF90      		pop r14
 3596               	.LVL245:
 3597 1478 0895      		ret
 3598               	.LFE41:
 3600               	.global	unformatAddress
 3602               	unformatAddress:
 3603               	.LFB75:
2895:switcherator.c **** 
2896:switcherator.c **** // send receive addresses
2897:switcherator.c **** //static uint64_t rx_addr_p0, rx_addr_p1, rx_addr_p2, rx_addr_p3, rx_addr_p4, rx_addr_p5, tx_addr;
2898:switcherator.c **** 
2899:switcherator.c **** // display's a given address
2900:switcherator.c **** //RD:N RC:N 0xnnnnnnnnnn
2901:switcherator.c **** //0123
2902:switcherator.c **** 
2903:switcherator.c **** void radioDisplayAddress(char * commandReceived) {
2904:switcherator.c ****     int x = 0;
2905:switcherator.c ****     char tempRadioString[6];
2906:switcherator.c ****     statusMsg[0] = 0;
2907:switcherator.c ****     if(commandReceived[3] == '1') {
2908:switcherator.c ****             unformatAddress(rx_addr_p1, tempRadioString);
2909:switcherator.c ****             strcat(statusMsg, "r1-0x");
2910:switcherator.c ****     } else if(commandReceived[3] == '2') {
2911:switcherator.c ****             unformatAddress(rx_addr_p2, tempRadioString);
2912:switcherator.c ****             strcat(statusMsg, "r2-0x");
2913:switcherator.c ****     } else if(commandReceived[3] == '3') {
2914:switcherator.c ****             unformatAddress(rx_addr_p3, tempRadioString);
2915:switcherator.c ****             strcat(statusMsg, "r3-0x");
2916:switcherator.c ****     } else if(commandReceived[3] == '4') {
2917:switcherator.c ****             unformatAddress(rx_addr_p4, tempRadioString);
2918:switcherator.c ****             strcat(statusMsg, "r4-0x");
2919:switcherator.c ****     } else if (commandReceived[3] == '5') {
2920:switcherator.c ****             unformatAddress(rx_addr_p5, tempRadioString);
2921:switcherator.c ****             strcat(statusMsg, "r5-0x");
2922:switcherator.c ****     } else if (commandReceived[3] == 'T') {
2923:switcherator.c ****             unformatAddress(tx_addr, tempRadioString);
2924:switcherator.c ****             strcat(statusMsg, "t-0x");
2925:switcherator.c ****     } else {
2926:switcherator.c ****             unformatAddress(rx_addr_p0, tempRadioString);
2927:switcherator.c ****             strcat(statusMsg, "r0-0x");
2928:switcherator.c ****     }
2929:switcherator.c ****     for (x = 0; x < 5; x++) {
2930:switcherator.c ****         returnHexWithout(tempRadioString[x], tempLongString);
2931:switcherator.c ****         strcat(statusMsg, tempLongString);
2932:switcherator.c ****     }
2933:switcherator.c ****     sendMessage(statusMsg);
2934:switcherator.c **** }
2935:switcherator.c **** 
2936:switcherator.c **** // change the radio address
2937:switcherator.c **** // send receive addresses
2938:switcherator.c **** //static uint64_t rx_addr_p0, rx_addr_p1, rx_addr_p2, rx_addr_p3, rx_addr_p4, rx_addr_p5, tx_addr;
2939:switcherator.c **** 
2940:switcherator.c **** //RD:N RC:N 0xnnnnnnnnnn
2941:switcherator.c **** //     01234567890123456
2942:switcherator.c **** 
2943:switcherator.c **** void radioChangeAddress(char * commandReceived) {
2944:switcherator.c ****     int x = 0;
2945:switcherator.c ****     statusMsg[0] = 0;
2946:switcherator.c ****     int tempInt = 0;
2947:switcherator.c ****     uint64_t newAddress = 0;
2948:switcherator.c ****     char tempString[] = "0x00";
2949:switcherator.c ****     char tempRadioString[] = "00000";
2950:switcherator.c ****     for (x = 0; x < 5; x++) {
2951:switcherator.c ****         tempString[2] = commandReceived[((x * 2) + 7)];
2952:switcherator.c ****         tempString[3] = commandReceived[((x * 2) + 8)];
2953:switcherator.c ****         tempInt = strtol(tempString, 0, 0);
2954:switcherator.c ****         newAddress |= tempInt;
2955:switcherator.c ****         if (x < 4)
2956:switcherator.c ****             newAddress <<= 8;
2957:switcherator.c ****     }
2958:switcherator.c ****     switch (commandReceived[3]) {
2959:switcherator.c ****         case '0':
2960:switcherator.c ****             rx_addr_p0 = newAddress;
2961:switcherator.c ****             strcat(statusMsg, "r0 0x");
2962:switcherator.c ****             writeAddr(RX_ADDR_P0, newAddress);
2963:switcherator.c ****             break;
2964:switcherator.c ****         case '1':
2965:switcherator.c ****             rx_addr_p1 = newAddress;
2966:switcherator.c ****             strcat(statusMsg, "r1 0x");
2967:switcherator.c ****             writeAddr(RX_ADDR_P1, newAddress);
2968:switcherator.c ****             break;
2969:switcherator.c ****         case '2':
2970:switcherator.c ****             rx_addr_p2 = newAddress;
2971:switcherator.c ****             strcat(statusMsg, "r2 0x");
2972:switcherator.c ****             writeAddr(RX_ADDR_P2, newAddress);
2973:switcherator.c ****             break;
2974:switcherator.c ****         case '3':
2975:switcherator.c ****             rx_addr_p3 = newAddress;
2976:switcherator.c ****             strcat(statusMsg, "r3 0x");
2977:switcherator.c ****             writeAddr(RX_ADDR_P3, newAddress);
2978:switcherator.c ****             break;
2979:switcherator.c ****         case '4':
2980:switcherator.c ****             rx_addr_p4 = newAddress;
2981:switcherator.c ****             strcat(statusMsg, "r4 0x");
2982:switcherator.c ****             writeAddr(RX_ADDR_P4, newAddress);
2983:switcherator.c ****             break;
2984:switcherator.c ****         case '5':
2985:switcherator.c ****             rx_addr_p5 = newAddress;
2986:switcherator.c ****             strcat(statusMsg, "r5 0x");
2987:switcherator.c ****             writeAddr(RX_ADDR_P5, newAddress);
2988:switcherator.c ****             break;
2989:switcherator.c ****         case 'T':
2990:switcherator.c ****             tx_addr = newAddress;
2991:switcherator.c ****             strcat(statusMsg, "t 0x");
2992:switcherator.c ****             writeAddr(TX_ADDR, newAddress);
2993:switcherator.c ****             break;
2994:switcherator.c ****     }
2995:switcherator.c ****     unformatAddress(newAddress, tempRadioString);
2996:switcherator.c ****     for (x = 0; x < 5; x++) {
2997:switcherator.c ****         returnHexWithout(tempRadioString[x], tempLongString);
2998:switcherator.c ****         strcat(statusMsg, tempLongString);
2999:switcherator.c ****     }
3000:switcherator.c ****     sendMessage(statusMsg);
3001:switcherator.c **** }
3002:switcherator.c **** 
3003:switcherator.c **** 
3004:switcherator.c **** // take the int and return the array
3005:switcherator.c **** 
3006:switcherator.c **** void unformatAddress(uint64_t oldAddress, char * formattedAddress) {
 3604               		.loc 1 3006 0
 3605               	.LVL246:
 3606 147a 0F93      		push r16
 3607               	.LCFI84:
 3608 147c 1F93      		push r17
 3609               	.LCFI85:
 3610               	/* prologue: function */
 3611               	/* frame size = 0 */
 3612               	/* stack size = 2 */
 3613               	.L__stack_usage = 2
 3614 147e F801      		movw r30,r16
 3615               	.LVL247:
3007:switcherator.c ****     uint64_t tempInt = oldAddress;
3008:switcherator.c ****     formattedAddress[4] = (tempInt & 0xff);
 3616               		.loc 1 3008 0
 3617 1480 2483      		std Z+4,r18
3009:switcherator.c ****     tempInt >>= 8;
 3618               		.loc 1 3009 0
 3619 1482 08E0      		ldi r16,lo8(8)
 3620               	.LVL248:
 3621 1484 0E94 0000 		call __lshrdi3
 3622               	.LVL249:
3010:switcherator.c ****     formattedAddress[3] = (tempInt & 0xff);
 3623               		.loc 1 3010 0
 3624 1488 2383      		std Z+3,r18
3011:switcherator.c ****     tempInt >>= 8;
 3625               		.loc 1 3011 0
 3626 148a 0E94 0000 		call __lshrdi3
 3627               	.LVL250:
3012:switcherator.c ****     formattedAddress[2] = (tempInt & 0xff);
 3628               		.loc 1 3012 0
 3629 148e 2283      		std Z+2,r18
3013:switcherator.c ****     tempInt >>= 8;
 3630               		.loc 1 3013 0
 3631 1490 0E94 0000 		call __lshrdi3
 3632               	.LVL251:
3014:switcherator.c ****     formattedAddress[1] = (tempInt & 0xff);
 3633               		.loc 1 3014 0
 3634 1494 2183      		std Z+1,r18
 3635               	.LVL252:
3015:switcherator.c ****     tempInt >>= 8;
 3636               		.loc 1 3015 0
 3637 1496 0E94 0000 		call __lshrdi3
 3638               	.LVL253:
3016:switcherator.c ****     formattedAddress[0] = (tempInt & 0xff);
 3639               		.loc 1 3016 0
 3640 149a 2083      		st Z,r18
 3641               	/* epilogue start */
3017:switcherator.c **** }
 3642               		.loc 1 3017 0
 3643 149c 1F91      		pop r17
 3644 149e 0F91      		pop r16
 3645 14a0 0895      		ret
 3646               	.LFE75:
 3648               	.global	getInput
 3650               	getInput:
 3651               	.LFB81:
3018:switcherator.c **** 
3019:switcherator.c **** void sendMessage(char * myResponse) {
3020:switcherator.c ****     stopRx();
3021:switcherator.c ****     _delay_us(100);
3022:switcherator.c ****     int transmitLength = strlen(myResponse);
3023:switcherator.c ****     if(!transmit(myResponse, transmitLength)) {
3024:switcherator.c ****         failCondition = 2;
3025:switcherator.c ****     } else {
3026:switcherator.c ****         failCondition = 0;
3027:switcherator.c ****         clearFail();
3028:switcherator.c ****     }
3029:switcherator.c ****     startRx();
3030:switcherator.c **** }
3031:switcherator.c **** 
3032:switcherator.c **** 
3033:switcherator.c **** /****************************************************************
3034:switcherator.c ****  *
3035:switcherator.c ****  *              All Things Input Related
3036:switcherator.c ****  *
3037:switcherator.c ****  ****************************************************************/
3038:switcherator.c **** 
3039:switcherator.c **** // sets up an input on one of the analog pins
3040:switcherator.c **** // DI:##Ppx?##DuraPO
3041:switcherator.c **** // AI:##PpLLLHHH?##DuraPOw
3042:switcherator.c **** // 0123456789012345678901234
3043:switcherator.c **** // int Port/pin like switches, low%,high%, switch/program, dur, poll time
3044:switcherator.c **** // inputs[NUM_INPUTS]
3045:switcherator.c **** 
3046:switcherator.c **** void setAnalogInput(char * commandReceived) {
3047:switcherator.c ****     int x = 0;
3048:switcherator.c ****     int inputNumber, lowPercent, highPercent, pollTime, outputNum, duration;
3049:switcherator.c ****     char pin = 0;
3050:switcherator.c ****     inputNumber = lowPercent = highPercent = pollTime = outputNum = duration = 0;
3051:switcherator.c ****     int switchNumber = 0;
3052:switcherator.c ****     long temp = 0;
3053:switcherator.c ****     char whichRGB = 0;
3054:switcherator.c ****     tempIntString[0] = commandReceived[3];
3055:switcherator.c ****     tempIntString[1] = commandReceived[4];
3056:switcherator.c ****     inputNumber = atoi(tempIntString);
3057:switcherator.c ****     if (inputNumber >= NUM_INPUTS) {
3058:switcherator.c ****         fail(0x11);
3059:switcherator.c ****         return;
3060:switcherator.c ****     }
3061:switcherator.c ****     tempIntString[0] = '0';
3062:switcherator.c ****     tempIntString[1] = commandReceived[6];
3063:switcherator.c ****     pin = atoi(tempIntString);
3064:switcherator.c ****     if (pin > 7) {
3065:switcherator.c ****         fail(0x04);
3066:switcherator.c ****         return;
3067:switcherator.c ****     }
3068:switcherator.c **** 
3069:switcherator.c ****     tempIntString[0] = commandReceived[14];
3070:switcherator.c ****     tempIntString[1] = commandReceived[15];
3071:switcherator.c ****     switchNumber = atoi(tempIntString);
3072:switcherator.c **** 
3073:switcherator.c ****     tempIntString[0] = commandReceived[20];
3074:switcherator.c ****     tempIntString[1] = commandReceived[21];
3075:switcherator.c ****     pollTime = atoi(tempIntString);
3076:switcherator.c **** 
3077:switcherator.c ****     tempIntString[0] = '0';
3078:switcherator.c ****     tempIntString[1] = commandReceived[22];
3079:switcherator.c ****     whichRGB = atoi(tempIntString);
3080:switcherator.c **** 
3081:switcherator.c ****     tempLongString[0] = '0';
3082:switcherator.c ****     tempLongString[1] = commandReceived[7];
3083:switcherator.c ****     tempLongString[2] = commandReceived[8];
3084:switcherator.c ****     tempLongString[3] = commandReceived[9];
3085:switcherator.c ****     lowPercent = atoi(tempLongString);
3086:switcherator.c ****     tempLongString[1] = commandReceived[10];
3087:switcherator.c ****     tempLongString[2] = commandReceived[11];
3088:switcherator.c ****     tempLongString[3] = commandReceived[12];
3089:switcherator.c ****     highPercent = atoi(tempLongString);
3090:switcherator.c **** 
3091:switcherator.c ****     tempLongString[0] = commandReceived[16];
3092:switcherator.c ****     tempLongString[1] = commandReceived[17];
3093:switcherator.c ****     tempLongString[2] = commandReceived[18];
3094:switcherator.c ****     tempLongString[3] = commandReceived[19];
3095:switcherator.c ****     duration = atoi(tempLongString);
3096:switcherator.c **** 
3097:switcherator.c ****     // pLHsDDP p int pin/port like sw, L%,H% (0,255 - digital), s - 0-127=switch, 128-255 = prog
3098:switcherator.c ****     // 0123456
3099:switcherator.c ****     // dur in seconds, poll time in secs or  0 for continuous. 
3100:switcherator.c ****     // #= analogIn num, p=pin, LLL=low%, HHH=High%,? = 'P'rog or 'S', ## = num
3101:switcherator.c ****     // Durat. = duration in seconds, POLL = poll time in seconds or 0 for 1/10
3102:switcherator.c ****     if (commandReceived[5] != 'C' && commandReceived[5] != 'c') {
3103:switcherator.c ****         fail(0x03);
3104:switcherator.c ****         return;
3105:switcherator.c ****     }
3106:switcherator.c ****     // Port / Pin
3107:switcherator.c ****     // value of 255 (default) means nothing programmed
3108:switcherator.c ****     // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
3109:switcherator.c ****     // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
3110:switcherator.c ****     // pin is abs(value/2)-the base - PINB3 = (22-16)/2  PINB3 (22-16)%2 = 0 - low (23-16)%2 = 1 - 
3111:switcherator.c ****     // port is C.  This is analog in so its not normal but need to set the DDR anyway
3112:switcherator.c ****     // get the pin
3113:switcherator.c ****     temp = pin * 2;
3114:switcherator.c ****     // add # for port C
3115:switcherator.c ****     temp += 32;
3116:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
3117:switcherator.c ****         if (switchStuff[x] == temp) {
3118:switcherator.c **** 
3119:switcherator.c ****             fail(0x12);
3120:switcherator.c ****             return;
3121:switcherator.c ****         }
3122:switcherator.c ****     }
3123:switcherator.c ****     inputs[inputNumber][0] = temp;
3124:switcherator.c ****     DDRC &= ~(1 << pin);
3125:switcherator.c ****     temp = lowPercent;
3126:switcherator.c ****     temp = temp * 255;
3127:switcherator.c ****     temp = temp / 100;
3128:switcherator.c ****     inputs[inputNumber][1] = temp;
3129:switcherator.c ****     temp = highPercent;
3130:switcherator.c ****     temp = temp * 255;
3131:switcherator.c ****     temp = temp / 100;
3132:switcherator.c ****     if (temp == 255) // if the top is 255 we need it to be 254 so its not digital
3133:switcherator.c ****         temp = 254;
3134:switcherator.c **** 
3135:switcherator.c ****     inputs[inputNumber][2] = temp;
3136:switcherator.c ****     // 128 switches and 128 programs possible
3137:switcherator.c ****     if (commandReceived[13] == 'P' || commandReceived[13] == 'p') {
3138:switcherator.c ****         switchNumber += 128;
3139:switcherator.c ****     }
3140:switcherator.c ****     inputs[inputNumber][3] = switchNumber;
3141:switcherator.c ****     temp = duration >> 8;
3142:switcherator.c ****     inputs[inputNumber][4] = temp;
3143:switcherator.c ****     temp = duration & 0xff;
3144:switcherator.c ****     inputs[inputNumber][5] = temp;
3145:switcherator.c **** 
3146:switcherator.c **** 
3147:switcherator.c ****     if (pollTime > 255)
3148:switcherator.c ****         pollTime = 255;
3149:switcherator.c ****     inputs[inputNumber][6] = pollTime;
3150:switcherator.c **** 
3151:switcherator.c ****     // if we are using a RGB switch then which ones do we activate (mask)
3152:switcherator.c ****     if (whichRGB > 7)
3153:switcherator.c ****         whichRGB = 7;
3154:switcherator.c ****     inputs[inputNumber][7] = whichRGB;
3155:switcherator.c **** 
3156:switcherator.c **** 
3157:switcherator.c ****     // set ADMUX when we do a conversion
3158:switcherator.c ****     // Set prescaler 1/32. why not... ;-)
3159:switcherator.c ****     ADCSRA |= (1 << ADPS2) || (1 << ADPS0);
3160:switcherator.c **** 
3161:switcherator.c **** 
3162:switcherator.c ****     ok();
3163:switcherator.c **** }
3164:switcherator.c **** 
3165:switcherator.c **** // set up an input on a regular pin
3166:switcherator.c **** // DI:##Ppx?##DuraPO
3167:switcherator.c **** // 012345678901234567890
3168:switcherator.c **** // #=digital in num, P=Port,p=pin, x=High or Low, ?='P'rog or 'S'witch,
3169:switcherator.c **** // ## = prog/switch num, Durat.=duration in seconds, POLL=poll time in sec or 0 for 1/10
3170:switcherator.c **** 
3171:switcherator.c **** void setDigitalInput(char * commandReceived) {
3172:switcherator.c ****     int x = 0;
3173:switcherator.c ****     int inputNumber, pollTime, outputNum, duration;
3174:switcherator.c ****     volatile unsigned char *realDDR = 0;
3175:switcherator.c ****     volatile unsigned char *realPort = 0;
3176:switcherator.c ****     char pin = 0;
3177:switcherator.c ****     inputNumber = pollTime = outputNum = duration = 0;
3178:switcherator.c ****     int switchNumber = 0;
3179:switcherator.c ****     int temp = 0;
3180:switcherator.c ****     tempIntString[0] = commandReceived[3];
3181:switcherator.c ****     tempIntString[1] = commandReceived[4];
3182:switcherator.c ****     inputNumber = atoi(tempIntString);
3183:switcherator.c ****     if (inputNumber >= NUM_INPUTS) {
3184:switcherator.c ****         fail(0x11);
3185:switcherator.c ****         return;
3186:switcherator.c ****     }
3187:switcherator.c ****     tempIntString[0] = '0';
3188:switcherator.c ****     tempIntString[1] = commandReceived[6];
3189:switcherator.c ****     pin = atoi(tempIntString);
3190:switcherator.c ****     if (pin > 7) {
3191:switcherator.c ****         fail(0x04);
3192:switcherator.c ****         return;
3193:switcherator.c ****     }
3194:switcherator.c **** 
3195:switcherator.c ****     tempIntString[0] = commandReceived[9];
3196:switcherator.c ****     tempIntString[1] = commandReceived[10];
3197:switcherator.c ****     switchNumber = atoi(tempIntString);
3198:switcherator.c **** 
3199:switcherator.c ****     tempIntString[0] = commandReceived[15];
3200:switcherator.c ****     tempIntString[1] = commandReceived[16];
3201:switcherator.c ****     pollTime = atoi(tempIntString);
3202:switcherator.c **** 
3203:switcherator.c ****     tempLongString[0] = commandReceived[11];
3204:switcherator.c ****     tempLongString[1] = commandReceived[12];
3205:switcherator.c ****     tempLongString[2] = commandReceived[13];
3206:switcherator.c ****     tempLongString[3] = commandReceived[14];
3207:switcherator.c ****     duration = atoi(tempLongString);
3208:switcherator.c ****     // if we are activating a program
3209:switcherator.c ****     if (commandReceived[8] == 'P' || commandReceived[8] == 'p') {
3210:switcherator.c ****         switchNumber += 128;
3211:switcherator.c ****     }
3212:switcherator.c ****     temp = pin * 2;
3213:switcherator.c ****     if (commandReceived[5] == 'B' || commandReceived[5] == 'b') {
3214:switcherator.c ****         realDDR = &DDRB;
3215:switcherator.c ****         realPort = &PORTB;
3216:switcherator.c ****         temp += 16;
3217:switcherator.c **** #ifdef PORTA
3218:switcherator.c ****     } else if (commandReceived[5] == 'A' || commandReceived[5] == 'a') {
3219:switcherator.c ****         realDDR = &DDRA;
3220:switcherator.c ****         realPort = &PORTA;
3221:switcherator.c ****         temp += 0;
3222:switcherator.c **** #endif        
3223:switcherator.c **** #ifdef PORTC
3224:switcherator.c ****     } else if (commandReceived[5] == 'C' || commandReceived[5] == 'c') {
3225:switcherator.c ****         realDDR = &DDRC;
3226:switcherator.c ****         realPort = &PORTC;
3227:switcherator.c ****         temp += 32;
3228:switcherator.c **** #endif        
3229:switcherator.c **** #ifdef PORTD
3230:switcherator.c ****     } else if (commandReceived[5] == 'D' || commandReceived[5] == 'd') {
3231:switcherator.c ****         realDDR = &DDRD;
3232:switcherator.c ****         realPort = &PORTD;
3233:switcherator.c ****         temp += 48;
3234:switcherator.c **** #endif        
3235:switcherator.c **** #ifdef PORTE
3236:switcherator.c ****     } else if (commandReceived[5] == 'E' || commandReceived[5] == 'e') {
3237:switcherator.c ****         realDDR = &DDRE;
3238:switcherator.c ****         realPort = &PORTE;
3239:switcherator.c ****         temp += 64;
3240:switcherator.c **** #endif        
3241:switcherator.c **** #ifdef PORTF
3242:switcherator.c ****     } else if (commandReceived[5] == 'F' || commandReceived[5] == 'f') {
3243:switcherator.c ****         realDDR = &DDRF;
3244:switcherator.c ****         realPort = &PORTF;
3245:switcherator.c ****         temp += 80;
3246:switcherator.c **** #endif        
3247:switcherator.c **** #ifdef PORTG
3248:switcherator.c ****     } else if (commandReceived[5] == 'G' || commandReceived[5] == 'g') {
3249:switcherator.c ****         realDDR = &DDRG;
3250:switcherator.c ****         realPort = &PORTG;
3251:switcherator.c ****         temp += 96;
3252:switcherator.c **** #endif        
3253:switcherator.c **** #ifdef PORTH
3254:switcherator.c ****     } else if (commandReceived[5] == 'H' || commandReceived[5] == 'h') {
3255:switcherator.c ****         realDDR = &DDRH;
3256:switcherator.c ****         realPort = &PORTH;
3257:switcherator.c ****         temp += 112;
3258:switcherator.c **** #endif        
3259:switcherator.c **** #ifdef PORTI
3260:switcherator.c ****     } else if (commandReceived[5] == 'I' || commandReceived[5] == 'i') {
3261:switcherator.c ****         realDDR = &DDRI;
3262:switcherator.c ****         realPort = &PORTI;
3263:switcherator.c ****         temp += 128;
3264:switcherator.c **** #endif        
3265:switcherator.c ****     }
3266:switcherator.c ****     // value of 255 (default) means nothing programmed
3267:switcherator.c ****     // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
3268:switcherator.c ****     // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
3269:switcherator.c ****     // pin is abs(value/2)-the base - PINB3 = (22-16)/2  PINB3 (22-16)%2 = 0 - low (23-16)%2 = 1 - 
3270:switcherator.c ****     // port is C.  This is analog in so its not normal but need to set the DDR anyway
3271:switcherator.c ****     // get the pin
3272:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
3273:switcherator.c ****         if (switchStuff[x] == temp || switchStuff[x] == (temp + 1)) {
3274:switcherator.c ****             fail(0x12);
3275:switcherator.c ****             return;
3276:switcherator.c ****         }
3277:switcherator.c ****     }
3278:switcherator.c **** 
3279:switcherator.c ****     inputs[inputNumber][0] = temp;
3280:switcherator.c **** 
3281:switcherator.c ****     if (commandReceived[7] == 'H' || commandReceived[7] == 'h' ||
3282:switcherator.c ****             commandReceived[7] == '1') {
3283:switcherator.c ****         inputs[inputNumber][1] = 0;
3284:switcherator.c ****         inputs[inputNumber][2] = 255;
3285:switcherator.c ****     } else {
3286:switcherator.c ****         inputs[inputNumber][1] = 255;
3287:switcherator.c ****         inputs[inputNumber][2] = 0;
3288:switcherator.c ****     }
3289:switcherator.c ****     inputs[inputNumber][3] = switchNumber;
3290:switcherator.c ****     temp = duration >> 8;
3291:switcherator.c ****     inputs[inputNumber][4] = temp;
3292:switcherator.c ****     temp = duration & 0xff;
3293:switcherator.c ****     inputs[inputNumber][5] = temp;
3294:switcherator.c **** 
3295:switcherator.c ****     if (pollTime > 255)
3296:switcherator.c ****         pollTime = 255;
3297:switcherator.c ****     inputs[inputNumber][6] = pollTime;
3298:switcherator.c **** 
3299:switcherator.c ****     *realDDR &= ~(1 << pin);
3300:switcherator.c ****     *realPort |= (1 << pin);
3301:switcherator.c **** 
3302:switcherator.c ****     ok();
3303:switcherator.c ****     // DI:##Ppx?##DuraPO
3304:switcherator.c ****     // 012345678901234567890
3305:switcherator.c **** }
3306:switcherator.c **** 
3307:switcherator.c **** // inputs[NUM_INPUTS] - is the following
3308:switcherator.c **** // pLHsDDP p int pin/port like sw, L%,H% (0,255 - digital), s - 0-127=switch, 128-255 = prog
3309:switcherator.c **** // 0123456
3310:switcherator.c **** // Port / Pin
3311:switcherator.c **** // value of 255 (default) means nothing programmed
3312:switcherator.c **** // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
3313:switcherator.c **** // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
3314:switcherator.c **** 
3315:switcherator.c **** // see if we check any inputs this second
3316:switcherator.c **** 
3317:switcherator.c **** void inputCheck(void) {
3318:switcherator.c ****     int x = 0;
3319:switcherator.c ****     int pollTime = 0;
3320:switcherator.c ****     // figure out if we care about our inputs
3321:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
3322:switcherator.c ****         // see if it is a valid input
3323:switcherator.c ****         if (inputs[x][0] == 255)
3324:switcherator.c ****             continue; // not valid. Skip
3325:switcherator.c ****         pollTime = inputs[x][6];
3326:switcherator.c ****         // see if it is one we check continuously or every second
3327:switcherator.c ****         if (pollTime == 0 || pollTime == 1) {
3328:switcherator.c ****             getInput(x);
3329:switcherator.c ****             // see if we it is the right second otherwise
3330:switcherator.c ****         } else if (weeklySeconds % pollTime == 0) {
3331:switcherator.c ****             getInput(x);
3332:switcherator.c ****         }
3333:switcherator.c ****     }
3334:switcherator.c **** }
3335:switcherator.c **** 
3336:switcherator.c **** // see if we check inputs continuously (every 10th)
3337:switcherator.c **** 
3338:switcherator.c **** void inputTenthCheck(void) {
3339:switcherator.c ****     int x = 0;
3340:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
3341:switcherator.c ****         // see if it is valid and marked continuously
3342:switcherator.c ****         if (inputs[x][0] != 255 && inputs[x][6] == 0)
3343:switcherator.c ****             getInput(x);
3344:switcherator.c ****     }
3345:switcherator.c **** }
3346:switcherator.c **** 
3347:switcherator.c **** // inputs[NUM_INPUTS] - is the following
3348:switcherator.c **** // pLHsDDPw p int pin/port like sw, L%,H% (0,255 - digital), s - 0-127=switch, 128-255 = prog
3349:switcherator.c **** // 01234567 - w= which analog out if needed
3350:switcherator.c **** // Port / Pin
3351:switcherator.c **** // value of 255 (default) means nothing programmed
3352:switcherator.c **** // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
3353:switcherator.c **** // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
3354:switcherator.c **** 
3355:switcherator.c **** 
3356:switcherator.c **** // actually check the input and do something based on that
3357:switcherator.c **** 
3358:switcherator.c **** void getInput(int inputNumber) {
 3652               		.loc 1 3358 0
 3653               	.LVL254:
 3654 14a2 2F92      		push r2
 3655               	.LCFI86:
 3656 14a4 3F92      		push r3
 3657               	.LCFI87:
 3658 14a6 4F92      		push r4
 3659               	.LCFI88:
 3660 14a8 5F92      		push r5
 3661               	.LCFI89:
 3662 14aa 6F92      		push r6
 3663               	.LCFI90:
 3664 14ac 7F92      		push r7
 3665               	.LCFI91:
 3666 14ae 8F92      		push r8
 3667               	.LCFI92:
 3668 14b0 9F92      		push r9
 3669               	.LCFI93:
 3670 14b2 AF92      		push r10
 3671               	.LCFI94:
 3672 14b4 BF92      		push r11
 3673               	.LCFI95:
 3674 14b6 CF92      		push r12
 3675               	.LCFI96:
 3676 14b8 DF92      		push r13
 3677               	.LCFI97:
 3678 14ba EF92      		push r14
 3679               	.LCFI98:
 3680 14bc FF92      		push r15
 3681               	.LCFI99:
 3682 14be 0F93      		push r16
 3683               	.LCFI100:
 3684 14c0 1F93      		push r17
 3685               	.LCFI101:
 3686 14c2 CF93      		push r28
 3687               	.LCFI102:
 3688 14c4 DF93      		push r29
 3689               	.LCFI103:
 3690 14c6 CDB7      		in r28,__SP_L__
 3691 14c8 DEB7      		in r29,__SP_H__
 3692               	.LCFI104:
 3693 14ca 2C97      		sbiw r28,12
 3694               	.LCFI105:
 3695 14cc 0FB6      		in __tmp_reg__,__SREG__
 3696 14ce F894      		cli
 3697 14d0 DEBF      		out __SP_H__,r29
 3698 14d2 0FBE      		out __SREG__,__tmp_reg__
 3699 14d4 CDBF      		out __SP_L__,r28
 3700               	/* prologue: function */
 3701               	/* frame size = 12 */
 3702               	/* stack size = 30 */
 3703               	.L__stack_usage = 30
 3704 14d6 FC01      		movw r30,r24
 3705               	.LVL255:
3359:switcherator.c ****     int x = 0;
3360:switcherator.c ****     unsigned int outputNum, duration, low, high, switchNumber;
3361:switcherator.c ****     volatile unsigned char *thisPin = 0;
3362:switcherator.c ****     long temp = 0;
3363:switcherator.c ****     char test = 0;
3364:switcherator.c ****     char pwmValue = 0;
3365:switcherator.c ****     char whichRGB = 0;
3366:switcherator.c ****     // set up how many seconds are at the beginning of today
3367:switcherator.c ****     long daySeconds = (dow * 86400);
 3706               		.loc 1 3367 0
 3707 14d8 2090 0000 		lds r2,dow
 3708 14dc 3090 0000 		lds r3,dow+1
 3709 14e0 2101      		movw r4,r2
 3710 14e2 612C      		mov r6,__zero_reg__
 3711 14e4 712C      		mov r7,__zero_reg__
 3712 14e6 A301      		movw r20,r6
 3713 14e8 9201      		movw r18,r4
 3714 14ea 60E8      		ldi r22,lo8(-128)
 3715 14ec 71E5      		ldi r23,lo8(81)
 3716 14ee 81E0      		ldi r24,lo8(1)
 3717 14f0 90E0      		ldi r25,0
 3718 14f2 0E94 0000 		call __mulsi3
 3719 14f6 4B01      		movw r8,r22
 3720 14f8 5C01      		movw r10,r24
 3721               	.LVL256:
3368:switcherator.c ****     long startTime, stopTime;
3369:switcherator.c ****     startTime = stopTime = 0;
3370:switcherator.c ****     outputNum = duration = low = high = switchNumber = 0;
3371:switcherator.c ****     outputNum = inputs[inputNumber][0];
 3722               		.loc 1 3371 0
 3723 14fa 43E0      		ldi r20,3
 3724               		1:
 3725 14fc EE0F      		lsl r30
 3726 14fe FF1F      		rol r31
 3727 1500 4A95      		dec r20
 3728 1502 01F4      		brne 1b
 3729 1504 E050      		subi r30,lo8(-(inputs))
 3730 1506 F040      		sbci r31,hi8(-(inputs))
 3731 1508 6081      		ld r22,Z
 3732               	.LVL257:
3372:switcherator.c ****     low = inputs[inputNumber][1];
 3733               		.loc 1 3372 0
 3734 150a C180      		ldd r12,Z+1
 3735 150c EC2C      		mov r14,r12
 3736 150e F12C      		mov r15,__zero_reg__
 3737               	.LVL258:
3373:switcherator.c ****     high = inputs[inputNumber][2];
 3738               		.loc 1 3373 0
 3739 1510 0281      		ldd r16,Z+2
 3740 1512 0983      		std Y+1,r16
 3741               	.LVL259:
3374:switcherator.c ****     switchNumber = inputs[inputNumber][3];
 3742               		.loc 1 3374 0
 3743 1514 0381      		ldd r16,Z+3
 3744               	.LVL260:
 3745 1516 10E0      		ldi r17,0
 3746               	.LVL261:
3375:switcherator.c ****     temp = inputs[inputNumber][4];
3376:switcherator.c ****     duration = (temp << 8);
 3747               		.loc 1 3376 0
 3748 1518 3481      		ldd r19,Z+4
 3749 151a 20E0      		ldi r18,0
3377:switcherator.c ****     temp = inputs[inputNumber][5];
3378:switcherator.c ****     duration |= temp;
 3750               		.loc 1 3378 0
 3751 151c 8581      		ldd r24,Z+5
 3752               	.LVL262:
 3753 151e A901      		movw r20,r18
 3754 1520 482B      		or r20,r24
 3755 1522 5C87      		std Y+12,r21
 3756 1524 4B87      		std Y+11,r20
 3757               	.LVL263:
3379:switcherator.c ****     whichRGB = inputs[inputNumber][7];
 3758               		.loc 1 3379 0
 3759 1526 D780      		ldd r13,Z+7
 3760               	.LVL264:
3380:switcherator.c ****     // if this is an analog input than both the low% or the high% will not be 255
3381:switcherator.c ****     if (low != 255 && high != 255) {
 3761               		.loc 1 3381 0
 3762 1528 5FEF      		ldi r21,-1
 3763 152a E516      		cp r14,r21
 3764 152c F104      		cpc r15,__zero_reg__
 3765 152e 01F4      		brne .+2
 3766 1530 00C0      		rjmp .L257
3373:switcherator.c ****     high = inputs[inputNumber][2];
 3767               		.loc 1 3373 0 discriminator 1
 3768 1532 F981      		ldd r31,Y+1
 3769 1534 EF2F      		mov r30,r31
 3770               	.LVL265:
 3771 1536 F0E0      		ldi r31,0
 3772 1538 FA87      		std Y+10,r31
 3773 153a E987      		std Y+9,r30
 3774               		.loc 1 3381 0 discriminator 1
 3775 153c EF3F      		cpi r30,-1
 3776 153e F105      		cpc r31,__zero_reg__
 3777 1540 01F4      		brne .+2
 3778 1542 00C0      		rjmp .L257
3371:switcherator.c ****     outputNum = inputs[inputNumber][0];
 3779               		.loc 1 3371 0
 3780 1544 70E0      		ldi r23,0
3382:switcherator.c ****         // this is an analog input
3383:switcherator.c ****         // currently only port C is supported for analog inputs
3384:switcherator.c ****         temp = outputNum - 32;
 3781               		.loc 1 3384 0
 3782 1546 6052      		subi r22,32
 3783 1548 7109      		sbc r23,__zero_reg__
 3784               	.LVL266:
 3785 154a CB01      		movw r24,r22
 3786 154c A0E0      		ldi r26,0
 3787 154e B0E0      		ldi r27,0
 3788               	.LVL267:
3385:switcherator.c ****         temp = temp / 2;
 3789               		.loc 1 3385 0
 3790 1550 B595      		asr r27
 3791 1552 A795      		ror r26
 3792 1554 9795      		ror r25
 3793 1556 8795      		ror r24
 3794               	.LVL268:
3386:switcherator.c ****         if (temp > 7) // if things got goofed up somehow 
 3795               		.loc 1 3386 0
 3796 1558 8830      		cpi r24,8
 3797 155a 9105      		cpc r25,__zero_reg__
 3798 155c A105      		cpc r26,__zero_reg__
 3799 155e B105      		cpc r27,__zero_reg__
 3800 1560 04F0      		brlt .+2
 3801 1562 00C0      		rjmp .L256
3387:switcherator.c ****             return;
3388:switcherator.c ****         ADMUX = temp; // which pin to check
 3802               		.loc 1 3388 0
 3803 1564 8093 7C00 		sts 124,r24
3389:switcherator.c ****         ADCSRA |= (1 << ADEN) | (1 << ADSC); // turn on ADC and start a conversion
 3804               		.loc 1 3389 0
 3805 1568 8091 7A00 		lds r24,122
 3806               	.LVL269:
 3807 156c 806C      		ori r24,lo8(-64)
 3808 156e 8093 7A00 		sts 122,r24
 3809               	.L260:
3390:switcherator.c ****         loop_until_bit_is_set(ADCSRA, ADIF);
 3810               		.loc 1 3390 0 discriminator 1
 3811 1572 8091 7A00 		lds r24,122
 3812 1576 84FF      		sbrs r24,4
 3813 1578 00C0      		rjmp .L260
3391:switcherator.c ****         temp = ADC;
 3814               		.loc 1 3391 0
 3815 157a 2091 7800 		lds r18,120
 3816 157e 3091 7900 		lds r19,120+1
 3817               	.LVL270:
3392:switcherator.c ****         temp = temp * 255;
 3818               		.loc 1 3392 0
 3819 1582 AFEF      		ldi r26,lo8(-1)
 3820 1584 B0E0      		ldi r27,0
 3821 1586 0E94 0000 		call __umulhisi3
 3822               	.LVL271:
3393:switcherator.c ****         temp = temp / 1024; // now its a number between 0 and 255;
 3823               		.loc 1 3393 0
 3824 158a 2AE0      		ldi r18,10
 3825               		1:
 3826 158c 9595      		asr r25
 3827 158e 8795      		ror r24
 3828 1590 7795      		ror r23
 3829 1592 6795      		ror r22
 3830 1594 2A95      		dec r18
 3831 1596 01F4      		brne 1b
 3832               	.LVL272:
3394:switcherator.c ****         ADCSRA |= (1 << ADIF); // clear the ADC
 3833               		.loc 1 3394 0
 3834 1598 2091 7A00 		lds r18,122
 3835 159c 2061      		ori r18,lo8(16)
 3836 159e 2093 7A00 		sts 122,r18
3395:switcherator.c ****         // see if we are turning on the switch
3396:switcherator.c ****         if (temp > low && temp < (high + 1)) {
 3837               		.loc 1 3396 0
 3838 15a2 4C2C      		mov r4,r12
 3839 15a4 512C      		mov r5,__zero_reg__
 3840 15a6 612C      		mov r6,__zero_reg__
 3841 15a8 712C      		mov r7,__zero_reg__
 3842 15aa 4616      		cp r4,r22
 3843 15ac 5706      		cpc r5,r23
 3844 15ae 6806      		cpc r6,r24
 3845 15b0 7906      		cpc r7,r25
 3846 15b2 04F0      		brlt .+2
 3847 15b4 00C0      		rjmp .L256
 3848               		.loc 1 3396 0 is_stmt 0 discriminator 1
 3849 15b6 A985      		ldd r26,Y+9
 3850 15b8 BA85      		ldd r27,Y+10
 3851 15ba 1196      		adiw r26,1
 3852 15bc 9D01      		movw r18,r26
 3853 15be 40E0      		ldi r20,0
 3854 15c0 50E0      		ldi r21,0
 3855               	.LVL273:
 3856 15c2 6217      		cp r22,r18
 3857 15c4 7307      		cpc r23,r19
 3858 15c6 8407      		cpc r24,r20
 3859 15c8 9507      		cpc r25,r21
 3860 15ca 04F0      		brlt .+2
 3861 15cc 00C0      		rjmp .L256
3397:switcherator.c ****             // see if it is a PWM switch (not a program)
3398:switcherator.c ****             if (switchNumber < 128 && switchStuff[switchNumber] == 200) {
 3862               		.loc 1 3398 0 is_stmt 1
 3863 15ce 0038      		cpi r16,-128
 3864 15d0 1105      		cpc r17,__zero_reg__
 3865 15d2 00F4      		brsh .L262
 3866               		.loc 1 3398 0 is_stmt 0 discriminator 1
 3867 15d4 F801      		movw r30,r16
 3868               	.LVL274:
 3869 15d6 E050      		subi r30,lo8(-(switchStuff))
 3870 15d8 F040      		sbci r31,hi8(-(switchStuff))
 3871 15da 2081      		ld r18,Z
 3872 15dc 283C      		cpi r18,lo8(-56)
 3873 15de 01F0      		breq .+2
 3874 15e0 00C0      		rjmp .L293
3399:switcherator.c ****                 // this is a PWM so we're doing it based on the relative ADC value
3400:switcherator.c ****                 // see if we are using the whole range.
3401:switcherator.c ****                 if ((high - low) > 250) {
 3875               		.loc 1 3401 0 is_stmt 1
 3876 15e2 4985      		ldd r20,Y+9
 3877 15e4 5A85      		ldd r21,Y+10
 3878 15e6 4E19      		sub r20,r14
 3879 15e8 5F09      		sbc r21,r15
 3880 15ea 4B3F      		cpi r20,-5
 3881 15ec 5105      		cpc r21,__zero_reg__
 3882 15ee 00F0      		brlo .+2
 3883 15f0 00C0      		rjmp .L293
 3884               	.LVL275:
 3885               	.LBB23:
3402:switcherator.c ****                     pwmValue = temp;
3403:switcherator.c ****                 } else {
3404:switcherator.c ****                     // figure out what percentage between the values we are
3405:switcherator.c ****                     char range = high - low;
3406:switcherator.c ****                     temp = temp - low;
 3886               		.loc 1 3406 0
 3887 15f2 9B01      		movw r18,r22
 3888 15f4 AC01      		movw r20,r24
 3889 15f6 2419      		sub r18,r4
 3890 15f8 3509      		sbc r19,r5
 3891 15fa 4609      		sbc r20,r6
 3892 15fc 5709      		sbc r21,r7
 3893               	.LVL276:
3407:switcherator.c ****                     temp = temp * 255;
 3894               		.loc 1 3407 0
 3895 15fe AFEF      		ldi r26,lo8(-1)
 3896 1600 B0E0      		ldi r27,0
 3897 1602 0E94 0000 		call __muluhisi3
 3898               	.LVL277:
3405:switcherator.c ****                     char range = high - low;
 3899               		.loc 1 3405 0
 3900 1606 2981      		ldd r18,Y+1
 3901 1608 2C19      		sub r18,r12
 3902               	.LVL278:
3408:switcherator.c ****                     temp = temp / range; // now we have a relative value between 0&255
 3903               		.loc 1 3408 0
 3904 160a 30E0      		ldi r19,0
 3905 160c 40E0      		ldi r20,0
 3906 160e 50E0      		ldi r21,0
 3907 1610 0E94 0000 		call __divmodsi4
 3908               	.LVL279:
3409:switcherator.c ****                     pwmValue = temp;
 3909               		.loc 1 3409 0
 3910 1614 822F      		mov r24,r18
 3911               	.LVL280:
3410:switcherator.c ****                     // see if we are changing RGB
3411:switcherator.c ****                     if (whichRGB & 4)
 3912               		.loc 1 3411 0
 3913 1616 D2FC      		sbrc r13,2
3412:switcherator.c ****                         pwmValues[0] = pwmValue;
 3914               		.loc 1 3412 0
 3915 1618 2093 0000 		sts pwmValues,r18
 3916               	.L264:
3413:switcherator.c ****                     if (whichRGB & 2)
 3917               		.loc 1 3413 0
 3918 161c D1FC      		sbrc r13,1
3414:switcherator.c ****                         pwmValues[1] = pwmValue;
 3919               		.loc 1 3414 0
 3920 161e 8093 0000 		sts pwmValues+1,r24
 3921               	.L265:
3415:switcherator.c ****                     if (whichRGB & 1)
 3922               		.loc 1 3415 0
 3923 1622 D0FC      		sbrc r13,0
3416:switcherator.c ****                         pwmValues[2] = pwmValue;
 3924               		.loc 1 3416 0
 3925 1624 8093 0000 		sts pwmValues+2,r24
 3926               	.L266:
3417:switcherator.c ****                     if (whichRGB & 7) // if anything changed
 3927               		.loc 1 3417 0
 3928 1628 8D2D      		mov r24,r13
 3929 162a 8770      		andi r24,lo8(7)
 3930 162c 01F4      		brne .+2
 3931 162e 00C0      		rjmp .L293
3418:switcherator.c ****                         switchChanged = 1;
 3932               		.loc 1 3418 0
 3933 1630 81E0      		ldi r24,lo8(1)
 3934 1632 8093 0000 		sts switchChanged,r24
 3935 1636 00C0      		rjmp .L293
 3936               	.LVL281:
 3937               	.L262:
 3938 1638 E0E0      		ldi r30,lo8(timeLimits+8)
 3939 163a F0E0      		ldi r31,hi8(timeLimits+8)
 3940               	.LVL282:
 3941               	.LBE23:
3358:switcherator.c **** void getInput(int inputNumber) {
 3942               		.loc 1 3358 0
 3943 163c 20E0      		ldi r18,0
 3944               	.LVL283:
 3945               	.L269:
3419:switcherator.c ****                 }
3420:switcherator.c ****             }
3421:switcherator.c ****             // k we set up PWM now make it so it switches on
3422:switcherator.c ****             if (switchNumber < 128) { // its a switch
3423:switcherator.c ****                 if (switchStatus[switchNumber] == 0) // the switch is off
3424:switcherator.c ****                     switchChanged = 1;
3425:switcherator.c ****                 if (switchStatus[switchNumber] < (weeklySeconds + duration))
3426:switcherator.c ****                     switchStatus[switchNumber] = (weeklySeconds + duration);
3427:switcherator.c ****             } else { // its a program;
3428:switcherator.c ****                 test = 0;
3429:switcherator.c ****                 // check and make sure we are within the time limits (eg dusk to dawn)
3430:switcherator.c ****                 // first if no time limits set up then ignore it
3431:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
3432:switcherator.c ****                     if (timeLimits[x][2] > 0)
 3946               		.loc 1 3432 0
 3947 163e 8081      		ld r24,Z
 3948 1640 9181      		ldd r25,Z+1
 3949 1642 A281      		ldd r26,Z+2
 3950 1644 B381      		ldd r27,Z+3
 3951 1646 892B      		or r24,r25
 3952 1648 8A2B      		or r24,r26
 3953 164a 8B2B      		or r24,r27
 3954 164c 01F0      		breq .L268
3433:switcherator.c ****                         test = 1;
 3955               		.loc 1 3433 0
 3956 164e 21E0      		ldi r18,lo8(1)
 3957               	.L268:
 3958               	.LVL284:
 3959 1650 3C96      		adiw r30,12
3431:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
 3960               		.loc 1 3431 0
 3961 1652 30E0      		ldi r19,hi8(timeLimits+56)
 3962 1654 E030      		cpi r30,lo8(timeLimits+56)
 3963 1656 F307      		cpc r31,r19
 3964 1658 01F4      		brne .L269
3434:switcherator.c ****                 }
3435:switcherator.c ****                 // no limits set up
3436:switcherator.c ****                 if (test == 0)
 3965               		.loc 1 3436 0
 3966 165a 2111      		cpse r18,__zero_reg__
 3967 165c 00C0      		rjmp .L270
3437:switcherator.c ****                     startTheProgram((switchNumber - 128), duration, 0);
 3968               		.loc 1 3437 0
 3969 165e 20E0      		ldi r18,0
 3970 1660 30E0      		ldi r19,0
 3971 1662 A901      		movw r20,r18
 3972               	.LVL285:
 3973 1664 6B85      		ldd r22,Y+11
 3974 1666 7C85      		ldd r23,Y+12
 3975               	.LVL286:
 3976 1668 C801      		movw r24,r16
 3977 166a 8058      		subi r24,-128
 3978 166c 9109      		sbc r25,__zero_reg__
 3979 166e 0E94 0000 		call startTheProgram
 3980               	.LVL287:
 3981               	.L270:
 3982 1672 80E0      		ldi r24,lo8(timeLimits)
 3983 1674 E82E      		mov r14,r24
 3984 1676 80E0      		ldi r24,hi8(timeLimits)
 3985 1678 F82E      		mov r15,r24
 3986               	.LVL288:
3438:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
3439:switcherator.c ****                     startTime = timeLimits[x][0];
3440:switcherator.c ****                     stopTime = timeLimits[x][1];
3441:switcherator.c ****                     // deal with nights that cross midnight
3442:switcherator.c ****                     if (stopTime < startTime) {
3443:switcherator.c ****                         temp = dow;
3444:switcherator.c ****                         // weekly seconds resets at the end of the week. so do lots of 9
3445:switcherator.c ****                         if (weeklySeconds <= (stopTime + daySeconds)) {
3446:switcherator.c ****                             // k this is dow + 1
3447:switcherator.c ****                             if (temp == 0)
3448:switcherator.c ****                                 temp = 6;
3449:switcherator.c ****                             else
3450:switcherator.c ****                                 temp--;
3451:switcherator.c ****                             if (timeLimits[x][2] & (1 << temp))
3452:switcherator.c ****                                 startTheProgram((switchNumber - 128), duration, 0);
3453:switcherator.c ****                         } else if (weeklySeconds >= (startTime + daySeconds)) {
3454:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
3455:switcherator.c ****                                 startTheProgram((switchNumber - 128), duration, 0);
3456:switcherator.c ****                         }
3457:switcherator.c ****                     } else {
3458:switcherator.c ****                         if (weeklySeconds >= (startTime + daySeconds) &&
3459:switcherator.c ****                                 weeklySeconds <= (stopTime + daySeconds)) {
3460:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
 3987               		.loc 1 3460 0 discriminator 1
 3988 167a CC24      		clr r12
 3989 167c C394      		inc r12
 3990 167e D12C      		mov r13,__zero_reg__
3461:switcherator.c ****                                 startTheProgram((switchNumber - 128), duration, 0);
 3991               		.loc 1 3461 0 discriminator 1
 3992 1680 0058      		subi r16,-128
 3993 1682 1109      		sbc r17,__zero_reg__
 3994               	.LVL289:
 3995               	.L275:
3439:switcherator.c ****                     startTime = timeLimits[x][0];
 3996               		.loc 1 3439 0
 3997 1684 D701      		movw r26,r14
 3998 1686 4D90      		ld r4,X+
 3999 1688 5D90      		ld r5,X+
 4000 168a 6D90      		ld r6,X+
 4001 168c 7C90      		ld r7,X
 4002 168e 1397      		sbiw r26,3
 4003               	.LVL290:
3440:switcherator.c ****                     stopTime = timeLimits[x][1];
 4004               		.loc 1 3440 0
 4005 1690 1496      		adiw r26,4
 4006 1692 4D91      		ld r20,X+
 4007 1694 5D91      		ld r21,X+
 4008 1696 6D91      		ld r22,X+
 4009 1698 7C91      		ld r23,X
 4010 169a 1797      		sbiw r26,4+3
 4011               	.LVL291:
 4012 169c 8091 0000 		lds r24,weeklySeconds
 4013 16a0 9091 0000 		lds r25,weeklySeconds+1
 4014 16a4 A091 0000 		lds r26,weeklySeconds+2
 4015 16a8 B091 0000 		lds r27,weeklySeconds+3
3442:switcherator.c ****                     if (stopTime < startTime) {
 4016               		.loc 1 3442 0
 4017 16ac 4415      		cp r20,r4
 4018 16ae 5505      		cpc r21,r5
 4019 16b0 6605      		cpc r22,r6
 4020 16b2 7705      		cpc r23,r7
 4021 16b4 04F0      		brlt .+2
 4022 16b6 00C0      		rjmp .L271
3443:switcherator.c ****                         temp = dow;
 4023               		.loc 1 3443 0
 4024 16b8 2091 0000 		lds r18,dow
 4025 16bc 3091 0000 		lds r19,dow+1
 4026               	.LVL292:
3445:switcherator.c ****                         if (weeklySeconds <= (stopTime + daySeconds)) {
 4027               		.loc 1 3445 0
 4028 16c0 480D      		add r20,r8
 4029 16c2 591D      		adc r21,r9
 4030 16c4 6A1D      		adc r22,r10
 4031 16c6 7B1D      		adc r23,r11
 4032               	.LVL293:
 4033 16c8 4817      		cp r20,r24
 4034 16ca 5907      		cpc r21,r25
 4035 16cc 6A07      		cpc r22,r26
 4036 16ce 7B07      		cpc r23,r27
 4037 16d0 00F0      		brlo .L272
3443:switcherator.c ****                         temp = dow;
 4038               		.loc 1 3443 0
 4039 16d2 C901      		movw r24,r18
 4040 16d4 A0E0      		ldi r26,0
 4041 16d6 B0E0      		ldi r27,0
3447:switcherator.c ****                             if (temp == 0)
 4042               		.loc 1 3447 0
 4043 16d8 0097      		sbiw r24,0
 4044 16da A105      		cpc r26,__zero_reg__
 4045 16dc B105      		cpc r27,__zero_reg__
 4046 16de 01F0      		breq .L295
3450:switcherator.c ****                                 temp--;
 4047               		.loc 1 3450 0
 4048 16e0 0197      		sbiw r24,1
 4049 16e2 A109      		sbc r26,__zero_reg__
 4050 16e4 B109      		sbc r27,__zero_reg__
 4051               	.LVL294:
 4052 16e6 00C0      		rjmp .L273
 4053               	.LVL295:
 4054               	.L295:
3448:switcherator.c ****                                 temp = 6;
 4055               		.loc 1 3448 0
 4056 16e8 86E0      		ldi r24,lo8(6)
 4057 16ea 90E0      		ldi r25,0
 4058 16ec A0E0      		ldi r26,0
 4059 16ee B0E0      		ldi r27,0
 4060               	.LVL296:
 4061               	.L273:
3451:switcherator.c ****                             if (timeLimits[x][2] & (1 << temp))
 4062               		.loc 1 3451 0
 4063 16f0 9601      		movw r18,r12
 4064 16f2 00C0      		rjmp 2f
 4065               		1:
 4066 16f4 220F      		lsl r18
 4067 16f6 331F      		rol r19
 4068               		2:
 4069 16f8 8A95      		dec r24
 4070 16fa 02F4      		brpl 1b
 4071 16fc A901      		movw r20,r18
 4072 16fe 6627      		clr r22
 4073 1700 57FD      		sbrc r21,7
 4074 1702 6095      		com r22
 4075 1704 762F      		mov r23,r22
 4076 1706 F701      		movw r30,r14
 4077 1708 8085      		ldd r24,Z+8
 4078 170a 9185      		ldd r25,Z+9
 4079 170c A285      		ldd r26,Z+10
 4080 170e B385      		ldd r27,Z+11
 4081 1710 4823      		and r20,r24
 4082 1712 5923      		and r21,r25
 4083 1714 6A23      		and r22,r26
 4084 1716 7B23      		and r23,r27
 4085 1718 452B      		or r20,r21
 4086 171a 462B      		or r20,r22
 4087 171c 472B      		or r20,r23
 4088 171e 01F4      		brne .+2
 4089 1720 00C0      		rjmp .L274
 4090 1722 00C0      		rjmp .L347
 4091               	.LVL297:
 4092               	.L272:
3453:switcherator.c ****                         } else if (weeklySeconds >= (startTime + daySeconds)) {
 4093               		.loc 1 3453 0
 4094 1724 480C      		add r4,r8
 4095 1726 591C      		adc r5,r9
 4096 1728 6A1C      		adc r6,r10
 4097 172a 7B1C      		adc r7,r11
 4098               	.LVL298:
 4099 172c 8415      		cp r24,r4
 4100 172e 9505      		cpc r25,r5
 4101 1730 A605      		cpc r26,r6
 4102 1732 B705      		cpc r27,r7
 4103 1734 00F0      		brlo .L274
3454:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
 4104               		.loc 1 3454 0
 4105 1736 C601      		movw r24,r12
 4106 1738 00C0      		rjmp 2f
 4107               		1:
 4108 173a 880F      		lsl r24
 4109 173c 991F      		rol r25
 4110               		2:
 4111 173e 2A95      		dec r18
 4112 1740 02F4      		brpl 1b
 4113 1742 00C0      		rjmp .L351
 4114               	.LVL299:
 4115               	.L271:
3458:switcherator.c ****                         if (weeklySeconds >= (startTime + daySeconds) &&
 4116               		.loc 1 3458 0
 4117 1744 480C      		add r4,r8
 4118 1746 591C      		adc r5,r9
 4119 1748 6A1C      		adc r6,r10
 4120 174a 7B1C      		adc r7,r11
 4121               	.LVL300:
 4122 174c 8415      		cp r24,r4
 4123 174e 9505      		cpc r25,r5
 4124 1750 A605      		cpc r26,r6
 4125 1752 B705      		cpc r27,r7
 4126 1754 00F0      		brlo .L274
3459:switcherator.c ****                                 weeklySeconds <= (stopTime + daySeconds)) {
 4127               		.loc 1 3459 0 discriminator 1
 4128 1756 480D      		add r20,r8
 4129 1758 591D      		adc r21,r9
 4130 175a 6A1D      		adc r22,r10
 4131 175c 7B1D      		adc r23,r11
 4132               	.LVL301:
3458:switcherator.c ****                         if (weeklySeconds >= (startTime + daySeconds) &&
 4133               		.loc 1 3458 0 discriminator 1
 4134 175e 4817      		cp r20,r24
 4135 1760 5907      		cpc r21,r25
 4136 1762 6A07      		cpc r22,r26
 4137 1764 7B07      		cpc r23,r27
 4138 1766 00F0      		brlo .L274
3460:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
 4139               		.loc 1 3460 0
 4140 1768 C601      		movw r24,r12
 4141 176a 0090 0000 		lds r0,dow
 4142 176e 00C0      		rjmp 2f
 4143               		1:
 4144 1770 880F      		lsl r24
 4145 1772 991F      		rol r25
 4146               		2:
 4147 1774 0A94      		dec r0
 4148 1776 02F4      		brpl 1b
 4149               	.L351:
 4150 1778 AA27      		clr r26
 4151 177a 97FD      		sbrc r25,7
 4152 177c A095      		com r26
 4153 177e BA2F      		mov r27,r26
 4154 1780 F701      		movw r30,r14
 4155 1782 4085      		ldd r20,Z+8
 4156 1784 5185      		ldd r21,Z+9
 4157 1786 6285      		ldd r22,Z+10
 4158 1788 7385      		ldd r23,Z+11
 4159 178a 8423      		and r24,r20
 4160 178c 9523      		and r25,r21
 4161 178e A623      		and r26,r22
 4162 1790 B723      		and r27,r23
 4163 1792 892B      		or r24,r25
 4164 1794 8A2B      		or r24,r26
 4165 1796 8B2B      		or r24,r27
 4166 1798 01F0      		breq .L274
 4167               	.L347:
 4168               		.loc 1 3461 0
 4169 179a 20E0      		ldi r18,0
 4170 179c 30E0      		ldi r19,0
 4171 179e A901      		movw r20,r18
 4172 17a0 6B85      		ldd r22,Y+11
 4173 17a2 7C85      		ldd r23,Y+12
 4174 17a4 C801      		movw r24,r16
 4175 17a6 0E94 0000 		call startTheProgram
 4176               	.LVL302:
 4177               	.L274:
 4178 17aa FCE0      		ldi r31,12
 4179 17ac EF0E      		add r14,r31
 4180 17ae F11C      		adc r15,__zero_reg__
3438:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
 4181               		.loc 1 3438 0
 4182 17b0 20E0      		ldi r18,lo8(timeLimits+48)
 4183 17b2 E216      		cp r14,r18
 4184 17b4 20E0      		ldi r18,hi8(timeLimits+48)
 4185 17b6 F206      		cpc r15,r18
 4186 17b8 01F0      		breq .+2
 4187 17ba 00C0      		rjmp .L275
 4188 17bc 00C0      		rjmp .L256
 4189               	.LVL303:
 4190               	.L257:
 4191               	.LBB24:
3462:switcherator.c ****                         }
3463:switcherator.c ****                     }
3464:switcherator.c ****                 } // end of the for
3465:switcherator.c ****             }
3466:switcherator.c ****         }
3467:switcherator.c **** 
3468:switcherator.c ****     } else {
3469:switcherator.c ****         // this is a digital input
3470:switcherator.c ****         // value of 255 (default) means nothing programmed
3471:switcherator.c ****         // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
3472:switcherator.c ****         // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG        
3473:switcherator.c ****         // figure out what we are dealing with and check it.
3474:switcherator.c ****         temp = outputNum;
 4192               		.loc 1 3474 0
 4193 17be 862F      		mov r24,r22
 4194 17c0 90E0      		ldi r25,0
 4195 17c2 A0E0      		ldi r26,0
 4196 17c4 B0E0      		ldi r27,0
 4197               	.LVL304:
3475:switcherator.c ****         if (temp > 15 && temp < 32) {
 4198               		.loc 1 3475 0
 4199 17c6 AC01      		movw r20,r24
 4200 17c8 BD01      		movw r22,r26
 4201               	.LVL305:
 4202 17ca 4051      		subi r20,16
 4203 17cc 5109      		sbc r21,__zero_reg__
 4204 17ce 6109      		sbc r22,__zero_reg__
 4205 17d0 7109      		sbc r23,__zero_reg__
 4206 17d2 4031      		cpi r20,16
 4207 17d4 5105      		cpc r21,__zero_reg__
 4208 17d6 6105      		cpc r22,__zero_reg__
 4209 17d8 7105      		cpc r23,__zero_reg__
 4210 17da 00F4      		brsh .L276
 4211               	.LVL306:
3476:switcherator.c ****             thisPin = &PINB;
3477:switcherator.c ****             temp -= 16;
 4212               		.loc 1 3477 0
 4213 17dc CB01      		movw r24,r22
 4214 17de BA01      		movw r22,r20
 4215               	.LVL307:
3476:switcherator.c ****             thisPin = &PINB;
 4216               		.loc 1 3476 0
 4217 17e0 B3E2      		ldi r27,lo8(35)
 4218 17e2 CB2E      		mov r12,r27
 4219 17e4 D12C      		mov r13,__zero_reg__
 4220 17e6 00C0      		rjmp .L277
 4221               	.LVL308:
 4222               	.L276:
3478:switcherator.c **** #ifdef PINA
3479:switcherator.c ****         } else if (temp < 16) {
3480:switcherator.c ****             thisPin = &PINA;
3481:switcherator.c ****             temp -= 0;
3482:switcherator.c **** #endif
3483:switcherator.c **** #ifdef PINC
3484:switcherator.c ****         } else if (temp < 48) {
 4223               		.loc 1 3484 0
 4224 17e8 8033      		cpi r24,48
 4225 17ea 9105      		cpc r25,__zero_reg__
 4226 17ec A105      		cpc r26,__zero_reg__
 4227 17ee B105      		cpc r27,__zero_reg__
 4228 17f0 04F4      		brge .L278
 4229               	.LVL309:
3485:switcherator.c ****             thisPin = &PINC;
3486:switcherator.c ****             temp -= 32;
 4230               		.loc 1 3486 0
 4231 17f2 BC01      		movw r22,r24
 4232 17f4 CD01      		movw r24,r26
 4233               	.LVL310:
 4234 17f6 6052      		subi r22,32
 4235 17f8 7109      		sbc r23,__zero_reg__
 4236 17fa 8109      		sbc r24,__zero_reg__
 4237 17fc 9109      		sbc r25,__zero_reg__
 4238               	.LVL311:
3485:switcherator.c ****             thisPin = &PINC;
 4239               		.loc 1 3485 0
 4240 17fe A6E2      		ldi r26,lo8(38)
 4241 1800 CA2E      		mov r12,r26
 4242 1802 D12C      		mov r13,__zero_reg__
 4243 1804 00C0      		rjmp .L277
 4244               	.LVL312:
 4245               	.L278:
3487:switcherator.c **** #endif
3488:switcherator.c **** #ifdef PIND
3489:switcherator.c ****         } else if (temp < 64) {
 4246               		.loc 1 3489 0
 4247 1806 8034      		cpi r24,64
 4248 1808 9105      		cpc r25,__zero_reg__
 4249 180a A105      		cpc r26,__zero_reg__
 4250 180c B105      		cpc r27,__zero_reg__
 4251 180e 04F0      		brlt .+2
 4252 1810 00C0      		rjmp .L256
 4253               	.LVL313:
3490:switcherator.c ****             thisPin = &PIND;
3491:switcherator.c ****             temp -= 48;
 4254               		.loc 1 3491 0
 4255 1812 BC01      		movw r22,r24
 4256 1814 CD01      		movw r24,r26
 4257               	.LVL314:
 4258 1816 6053      		subi r22,48
 4259 1818 7109      		sbc r23,__zero_reg__
 4260 181a 8109      		sbc r24,__zero_reg__
 4261 181c 9109      		sbc r25,__zero_reg__
 4262               	.LVL315:
3490:switcherator.c ****             thisPin = &PIND;
 4263               		.loc 1 3490 0
 4264 181e F9E2      		ldi r31,lo8(41)
 4265 1820 CF2E      		mov r12,r31
 4266 1822 D12C      		mov r13,__zero_reg__
 4267               	.LVL316:
 4268               	.L277:
3492:switcherator.c **** #endif
3493:switcherator.c **** #ifdef PINE
3494:switcherator.c ****         } else if (temp < 80) {
3495:switcherator.c ****             thisPin = &PINE;
3496:switcherator.c ****             temp -= 64;
3497:switcherator.c **** #endif
3498:switcherator.c **** #ifdef PINF
3499:switcherator.c ****         } else if (temp < 96) {
3500:switcherator.c ****             thisPin = &PINF;
3501:switcherator.c ****             temp -= 80;
3502:switcherator.c **** #endif
3503:switcherator.c **** #ifdef PING
3504:switcherator.c ****         } else if (temp < 112) {
3505:switcherator.c ****             thisPin = &PING;
3506:switcherator.c ****             temp -= 96;
3507:switcherator.c **** #endif
3508:switcherator.c **** #ifdef PINH
3509:switcherator.c ****         } else if (temp < 128) {
3510:switcherator.c ****             thisPin = &PINH;
3511:switcherator.c ****             temp -= 112;
3512:switcherator.c **** #endif
3513:switcherator.c **** #ifdef PINI
3514:switcherator.c ****         } else if (temp < 144) {
3515:switcherator.c ****             thisPin = &PINI;
3516:switcherator.c ****             temp -= 128;
3517:switcherator.c **** #endif
3518:switcherator.c ****         } else {
3519:switcherator.c ****             // something went wrong.  Who cares.
3520:switcherator.c ****             return;
3521:switcherator.c ****         }
3522:switcherator.c ****         // if we want the input to be high then low = 0.  If we want it to be 
3523:switcherator.c ****         // low to be on then low = 255;
3524:switcherator.c ****         temp = temp / 2;
 4269               		.loc 1 3524 0
 4270 1824 22E0      		ldi r18,lo8(2)
 4271 1826 30E0      		ldi r19,0
 4272 1828 40E0      		ldi r20,0
 4273 182a 50E0      		ldi r21,0
 4274 182c 0E94 0000 		call __divmodsi4
 4275               	.LVL317:
3525:switcherator.c ****         if (temp > 7) {
 4276               		.loc 1 3525 0
 4277 1830 2830      		cpi r18,8
 4278 1832 3105      		cpc r19,__zero_reg__
 4279 1834 4105      		cpc r20,__zero_reg__
 4280 1836 5105      		cpc r21,__zero_reg__
 4281 1838 04F0      		brlt .+2
 4282 183a 00C0      		rjmp .L256
3526:switcherator.c ****             return; // something wrong again
3527:switcherator.c ****         }
3528:switcherator.c ****         int pinsOn = *thisPin;
 4283               		.loc 1 3528 0
 4284 183c D601      		movw r26,r12
 4285 183e 8C91      		ld r24,X
 4286               	.LVL318:
 4287 1840 90E0      		ldi r25,0
3529:switcherator.c ****         char yeaOurInputIsOn = 0;
3530:switcherator.c ****         if (pinsOn & (1 << temp)) {
 4288               		.loc 1 3530 0
 4289 1842 00C0      		rjmp 2f
 4290               		1:
 4291 1844 9595      		asr r25
 4292 1846 8795      		ror r24
 4293               		2:
 4294 1848 2A95      		dec r18
 4295 184a 02F4      		brpl 1b
 4296               	.LVL319:
 4297 184c 80FF      		sbrs r24,0
 4298 184e 00C0      		rjmp .L279
3531:switcherator.c ****             // pin is high
3532:switcherator.c ****             if (low == 0)
 4299               		.loc 1 3532 0
 4300 1850 EF28      		or r14,r15
 4301 1852 01F4      		brne .+2
 4302 1854 00C0      		rjmp .L280
 4303 1856 00C0      		rjmp .L256
 4304               	.L279:
3533:switcherator.c ****                 yeaOurInputIsOn = 1;
3534:switcherator.c ****         } else {
3535:switcherator.c ****             // pin is low
3536:switcherator.c ****             if (low == 255)
 4305               		.loc 1 3536 0
 4306 1858 BFEF      		ldi r27,-1
 4307 185a EB16      		cp r14,r27
 4308 185c F104      		cpc r15,__zero_reg__
 4309 185e 01F0      		breq .+2
 4310 1860 00C0      		rjmp .L256
 4311 1862 00C0      		rjmp .L280
 4312               	.LVL320:
 4313               	.L293:
3537:switcherator.c ****                 yeaOurInputIsOn = 1;
3538:switcherator.c ****         }
3539:switcherator.c ****         if (yeaOurInputIsOn == 1) {
3540:switcherator.c ****             if (switchNumber < 128) { // this is a switch
3541:switcherator.c ****                 if (switchStatus[switchNumber] == 0) // the switch is off
 4314               		.loc 1 3541 0
 4315 1864 000F      		lsl r16
 4316 1866 111F      		rol r17
 4317 1868 000F      		lsl r16
 4318 186a 111F      		rol r17
 4319               	.LVL321:
 4320 186c F801      		movw r30,r16
 4321 186e E050      		subi r30,lo8(-(switchStatus))
 4322 1870 F040      		sbci r31,hi8(-(switchStatus))
 4323 1872 4081      		ld r20,Z
 4324 1874 5181      		ldd r21,Z+1
 4325 1876 6281      		ldd r22,Z+2
 4326 1878 7381      		ldd r23,Z+3
 4327 187a 4115      		cp r20,__zero_reg__
 4328 187c 5105      		cpc r21,__zero_reg__
 4329 187e 6105      		cpc r22,__zero_reg__
 4330 1880 7105      		cpc r23,__zero_reg__
 4331 1882 01F4      		brne .L281
3542:switcherator.c ****                     switchChanged = 1;
 4332               		.loc 1 3542 0
 4333 1884 81E0      		ldi r24,lo8(1)
 4334 1886 8093 0000 		sts switchChanged,r24
 4335               	.L281:
3543:switcherator.c ****                 if ((switchStatus[switchNumber]) < (weeklySeconds + duration))
 4336               		.loc 1 3543 0
 4337 188a 8091 0000 		lds r24,weeklySeconds
 4338 188e 9091 0000 		lds r25,weeklySeconds+1
 4339 1892 A091 0000 		lds r26,weeklySeconds+2
 4340 1896 B091 0000 		lds r27,weeklySeconds+3
 4341 189a EB85      		ldd r30,Y+11
 4342 189c FC85      		ldd r31,Y+12
 4343 189e 8E0F      		add r24,r30
 4344 18a0 9F1F      		adc r25,r31
 4345 18a2 A11D      		adc r26,__zero_reg__
 4346 18a4 B11D      		adc r27,__zero_reg__
 4347 18a6 4817      		cp r20,r24
 4348 18a8 5907      		cpc r21,r25
 4349 18aa 6A07      		cpc r22,r26
 4350 18ac 7B07      		cpc r23,r27
 4351 18ae 00F0      		brlo .+2
 4352 18b0 00C0      		rjmp .L256
3544:switcherator.c ****                     switchStatus[switchNumber] = (weeklySeconds + duration);
 4353               		.loc 1 3544 0
 4354 18b2 F801      		movw r30,r16
 4355 18b4 E050      		subi r30,lo8(-(switchStatus))
 4356 18b6 F040      		sbci r31,hi8(-(switchStatus))
 4357 18b8 8083      		st Z,r24
 4358 18ba 9183      		std Z+1,r25
 4359 18bc A283      		std Z+2,r26
 4360 18be B383      		std Z+3,r27
 4361 18c0 00C0      		rjmp .L256
 4362               	.LVL322:
 4363               	.L283:
3545:switcherator.c ****             } else { // its a program;
3546:switcherator.c ****                 test = 0;
3547:switcherator.c ****                 // check and make sure we are within the time limits (eg dusk to dawn)
3548:switcherator.c ****                 // first if no time limits set up then ignore it
3549:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
3550:switcherator.c ****                     if (timeLimits[x][2] > 0)
 4364               		.loc 1 3550 0
 4365 18c2 8081      		ld r24,Z
 4366 18c4 9181      		ldd r25,Z+1
 4367 18c6 A281      		ldd r26,Z+2
 4368 18c8 B381      		ldd r27,Z+3
 4369 18ca 892B      		or r24,r25
 4370 18cc 8A2B      		or r24,r26
 4371 18ce 8B2B      		or r24,r27
 4372 18d0 01F0      		breq .L282
3551:switcherator.c ****                         test = 1;
 4373               		.loc 1 3551 0
 4374 18d2 21E0      		ldi r18,lo8(1)
 4375               	.L282:
 4376               	.LVL323:
 4377 18d4 3C96      		adiw r30,12
3549:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
 4378               		.loc 1 3549 0
 4379 18d6 30E0      		ldi r19,hi8(timeLimits+56)
 4380 18d8 E030      		cpi r30,lo8(timeLimits+56)
 4381 18da F307      		cpc r31,r19
 4382 18dc 01F4      		brne .L283
3552:switcherator.c ****                 }
3553:switcherator.c ****                 // no limits set up
3554:switcherator.c ****                 if (test == 0)
 4383               		.loc 1 3554 0
 4384 18de 2111      		cpse r18,__zero_reg__
 4385 18e0 00C0      		rjmp .L284
3555:switcherator.c ****                     startTheProgram((switchNumber - 128), duration, 0);
 4386               		.loc 1 3555 0
 4387 18e2 20E0      		ldi r18,0
 4388 18e4 30E0      		ldi r19,0
 4389 18e6 A901      		movw r20,r18
 4390               	.LVL324:
 4391 18e8 6B85      		ldd r22,Y+11
 4392 18ea 7C85      		ldd r23,Y+12
 4393 18ec C801      		movw r24,r16
 4394 18ee 8058      		subi r24,-128
 4395 18f0 9109      		sbc r25,__zero_reg__
 4396 18f2 0E94 0000 		call startTheProgram
 4397               	.LVL325:
 4398               	.L284:
3556:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
3557:switcherator.c ****                     startTime = timeLimits[x][0];
3558:switcherator.c ****                     stopTime = timeLimits[x][1];
3559:switcherator.c ****                     // deal with nights that cross midnight
3560:switcherator.c ****                     if (stopTime < startTime) {
3561:switcherator.c ****                         temp = dow;
3562:switcherator.c ****                         // weekly seconds resets at the end of the week. so do lots of 9
3563:switcherator.c ****                         if (weeklySeconds <= (stopTime + daySeconds)) {
3564:switcherator.c ****                             // k this is dow + 1
3565:switcherator.c ****                             if (temp == 0)
3566:switcherator.c ****                                 temp = 6;
3567:switcherator.c ****                             else
3568:switcherator.c ****                                 temp--;
 4399               		.loc 1 3568 0 discriminator 1
 4400 18f6 D301      		movw r26,r6
 4401 18f8 C201      		movw r24,r4
 4402 18fa 0197      		sbiw r24,1
 4403 18fc A109      		sbc r26,__zero_reg__
 4404 18fe B109      		sbc r27,__zero_reg__
3569:switcherator.c ****                             if (timeLimits[x][2] & (1 << temp))
 4405               		.loc 1 3569 0 discriminator 1
 4406 1900 4528      		or r4,r5
 4407 1902 4628      		or r4,r6
 4408 1904 4728      		or r4,r7
 4409 1906 01F4      		brne .L285
 4410 1908 76E0      		ldi r23,lo8(6)
 4411 190a 472E      		mov r4,r23
 4412 190c 512C      		mov r5,__zero_reg__
 4413 190e 612C      		mov r6,__zero_reg__
 4414 1910 712C      		mov r7,__zero_reg__
 4415 1912 00C0      		rjmp .L286
 4416               	.L285:
 4417 1914 2C01      		movw r4,r24
 4418 1916 3D01      		movw r6,r26
 4419               	.L286:
 4420 1918 81E0      		ldi r24,lo8(1)
 4421 191a 90E0      		ldi r25,0
 4422 191c AC01      		movw r20,r24
 4423 191e 00C0      		rjmp 2f
 4424               		1:
 4425 1920 440F      		lsl r20
 4426 1922 551F      		rol r21
 4427               		2:
 4428 1924 4A94      		dec r4
 4429 1926 02F4      		brpl 1b
 4430 1928 9A01      		movw r18,r20
 4431 192a 4427      		clr r20
 4432 192c 37FD      		sbrc r19,7
 4433 192e 4095      		com r20
 4434 1930 542F      		mov r21,r20
 4435 1932 2983      		std Y+1,r18
 4436 1934 3A83      		std Y+2,r19
 4437 1936 4B83      		std Y+3,r20
 4438 1938 5C83      		std Y+4,r21
3570:switcherator.c ****                                 startTheProgram((switchNumber - 128), duration, 0);
3571:switcherator.c ****                         } else if (weeklySeconds >= (startTime + daySeconds)) {
3572:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
 4439               		.loc 1 3572 0 discriminator 1
 4440 193a 2C01      		movw r4,r24
 4441 193c 00C0      		rjmp 2f
 4442               		1:
 4443 193e 440C      		lsl r4
 4444 1940 551C      		rol r5
 4445               		2:
 4446 1942 2A94      		dec r2
 4447 1944 02F4      		brpl 1b
 4448 1946 6624      		clr r6
 4449 1948 57FC      		sbrc r5,7
 4450 194a 6094      		com r6
 4451 194c 762C      		mov r7,r6
 4452 194e 60E0      		ldi r22,lo8(timeLimits)
 4453 1950 E62E      		mov r14,r22
 4454 1952 60E0      		ldi r22,hi8(timeLimits)
 4455 1954 F62E      		mov r15,r22
 4456               	.LVL326:
3573:switcherator.c ****                                 startTheProgram((switchNumber - 128), duration, 0);
3574:switcherator.c ****                         }
3575:switcherator.c ****                     } else {
3576:switcherator.c ****                         if (weeklySeconds >= (startTime + daySeconds) &&
3577:switcherator.c ****                                 weeklySeconds <= (stopTime + daySeconds)) {
3578:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
3579:switcherator.c ****                                 startTheProgram((switchNumber - 128), duration, 0);
 4457               		.loc 1 3579 0 discriminator 1
 4458 1956 6801      		movw r12,r16
 4459               	.LVL327:
 4460 1958 30E8      		ldi r19,-128
 4461 195a C31A      		sub r12,r19
 4462 195c D108      		sbc r13,__zero_reg__
 4463               	.LVL328:
 4464               	.L290:
3557:switcherator.c ****                     startTime = timeLimits[x][0];
 4465               		.loc 1 3557 0
 4466 195e D701      		movw r26,r14
 4467 1960 8D91      		ld r24,X+
 4468 1962 9D91      		ld r25,X+
 4469 1964 0D90      		ld __tmp_reg__,X+
 4470 1966 BC91      		ld r27,X
 4471 1968 A02D      		mov r26,__tmp_reg__
 4472 196a 8D83      		std Y+5,r24
 4473 196c 9E83      		std Y+6,r25
 4474 196e AF83      		std Y+7,r26
 4475 1970 B887      		std Y+8,r27
 4476               	.LVL329:
3558:switcherator.c ****                     stopTime = timeLimits[x][1];
 4477               		.loc 1 3558 0
 4478 1972 F701      		movw r30,r14
 4479 1974 4481      		ldd r20,Z+4
 4480 1976 5581      		ldd r21,Z+5
 4481 1978 6681      		ldd r22,Z+6
 4482 197a 7781      		ldd r23,Z+7
 4483               	.LVL330:
 4484 197c 8091 0000 		lds r24,weeklySeconds
 4485 1980 9091 0000 		lds r25,weeklySeconds+1
 4486 1984 A091 0000 		lds r26,weeklySeconds+2
 4487 1988 B091 0000 		lds r27,weeklySeconds+3
 4488               	.LVL331:
3560:switcherator.c ****                     if (stopTime < startTime) {
 4489               		.loc 1 3560 0
 4490 198c 0D81      		ldd r16,Y+5
 4491 198e 1E81      		ldd r17,Y+6
 4492 1990 2F81      		ldd r18,Y+7
 4493 1992 3885      		ldd r19,Y+8
 4494 1994 4017      		cp r20,r16
 4495 1996 5107      		cpc r21,r17
 4496 1998 6207      		cpc r22,r18
 4497 199a 7307      		cpc r23,r19
 4498 199c 04F4      		brge .L287
3563:switcherator.c ****                         if (weeklySeconds <= (stopTime + daySeconds)) {
 4499               		.loc 1 3563 0
 4500 199e 480D      		add r20,r8
 4501 19a0 591D      		adc r21,r9
 4502 19a2 6A1D      		adc r22,r10
 4503 19a4 7B1D      		adc r23,r11
 4504               	.LVL332:
 4505 19a6 4817      		cp r20,r24
 4506 19a8 5907      		cpc r21,r25
 4507 19aa 6A07      		cpc r22,r26
 4508 19ac 7B07      		cpc r23,r27
 4509 19ae 00F0      		brlo .L288
3569:switcherator.c ****                             if (timeLimits[x][2] & (1 << temp))
 4510               		.loc 1 3569 0
 4511 19b0 8085      		ldd r24,Z+8
 4512 19b2 9185      		ldd r25,Z+9
 4513 19b4 A285      		ldd r26,Z+10
 4514 19b6 B385      		ldd r27,Z+11
 4515 19b8 2981      		ldd r18,Y+1
 4516 19ba 3A81      		ldd r19,Y+2
 4517 19bc 4B81      		ldd r20,Y+3
 4518 19be 5C81      		ldd r21,Y+4
 4519 19c0 8223      		and r24,r18
 4520 19c2 9323      		and r25,r19
 4521 19c4 A423      		and r26,r20
 4522 19c6 B523      		and r27,r21
 4523 19c8 00C0      		rjmp .L354
 4524               	.L288:
3571:switcherator.c ****                         } else if (weeklySeconds >= (startTime + daySeconds)) {
 4525               		.loc 1 3571 0
 4526 19ca 4D81      		ldd r20,Y+5
 4527 19cc 5E81      		ldd r21,Y+6
 4528 19ce 6F81      		ldd r22,Y+7
 4529 19d0 7885      		ldd r23,Y+8
 4530 19d2 480D      		add r20,r8
 4531 19d4 591D      		adc r21,r9
 4532 19d6 6A1D      		adc r22,r10
 4533 19d8 7B1D      		adc r23,r11
 4534 19da 8417      		cp r24,r20
 4535 19dc 9507      		cpc r25,r21
 4536 19de A607      		cpc r26,r22
 4537 19e0 B707      		cpc r27,r23
 4538 19e2 00F0      		brlo .L289
 4539 19e4 00C0      		rjmp .L356
 4540               	.LVL333:
 4541               	.L287:
3576:switcherator.c ****                         if (weeklySeconds >= (startTime + daySeconds) &&
 4542               		.loc 1 3576 0
 4543 19e6 0D81      		ldd r16,Y+5
 4544 19e8 1E81      		ldd r17,Y+6
 4545 19ea 2F81      		ldd r18,Y+7
 4546 19ec 3885      		ldd r19,Y+8
 4547 19ee 080D      		add r16,r8
 4548 19f0 191D      		adc r17,r9
 4549 19f2 2A1D      		adc r18,r10
 4550 19f4 3B1D      		adc r19,r11
 4551 19f6 8017      		cp r24,r16
 4552 19f8 9107      		cpc r25,r17
 4553 19fa A207      		cpc r26,r18
 4554 19fc B307      		cpc r27,r19
 4555 19fe 00F0      		brlo .L289
3577:switcherator.c ****                                 weeklySeconds <= (stopTime + daySeconds)) {
 4556               		.loc 1 3577 0 discriminator 1
 4557 1a00 480D      		add r20,r8
 4558 1a02 591D      		adc r21,r9
 4559 1a04 6A1D      		adc r22,r10
 4560 1a06 7B1D      		adc r23,r11
 4561               	.LVL334:
3576:switcherator.c ****                         if (weeklySeconds >= (startTime + daySeconds) &&
 4562               		.loc 1 3576 0 discriminator 1
 4563 1a08 4817      		cp r20,r24
 4564 1a0a 5907      		cpc r21,r25
 4565 1a0c 6A07      		cpc r22,r26
 4566 1a0e 7B07      		cpc r23,r27
 4567 1a10 00F0      		brlo .L289
 4568               	.L356:
3578:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
 4569               		.loc 1 3578 0
 4570 1a12 F701      		movw r30,r14
 4571 1a14 8085      		ldd r24,Z+8
 4572 1a16 9185      		ldd r25,Z+9
 4573 1a18 A285      		ldd r26,Z+10
 4574 1a1a B385      		ldd r27,Z+11
 4575 1a1c 8421      		and r24,r4
 4576 1a1e 9521      		and r25,r5
 4577 1a20 A621      		and r26,r6
 4578 1a22 B721      		and r27,r7
 4579               	.L354:
 4580 1a24 892B      		or r24,r25
 4581 1a26 8A2B      		or r24,r26
 4582 1a28 8B2B      		or r24,r27
 4583 1a2a 01F0      		breq .L289
 4584               		.loc 1 3579 0
 4585 1a2c 20E0      		ldi r18,0
 4586 1a2e 30E0      		ldi r19,0
 4587 1a30 A901      		movw r20,r18
 4588 1a32 6B85      		ldd r22,Y+11
 4589 1a34 7C85      		ldd r23,Y+12
 4590 1a36 C601      		movw r24,r12
 4591 1a38 0E94 0000 		call startTheProgram
 4592               	.LVL335:
 4593               	.L289:
 4594 1a3c FCE0      		ldi r31,12
 4595 1a3e EF0E      		add r14,r31
 4596 1a40 F11C      		adc r15,__zero_reg__
3556:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
 4597               		.loc 1 3556 0
 4598 1a42 00E0      		ldi r16,lo8(timeLimits+48)
 4599 1a44 E016      		cp r14,r16
 4600 1a46 00E0      		ldi r16,hi8(timeLimits+48)
 4601 1a48 F006      		cpc r15,r16
 4602 1a4a 01F0      		breq .+2
 4603 1a4c 00C0      		rjmp .L290
 4604 1a4e 00C0      		rjmp .L256
 4605               	.LVL336:
 4606               	.L280:
3540:switcherator.c ****             if (switchNumber < 128) { // this is a switch
 4607               		.loc 1 3540 0
 4608 1a50 0038      		cpi r16,-128
 4609 1a52 1105      		cpc r17,__zero_reg__
 4610 1a54 00F4      		brsh .+2
 4611 1a56 00C0      		rjmp .L293
 4612 1a58 E0E0      		ldi r30,lo8(timeLimits+8)
 4613 1a5a F0E0      		ldi r31,hi8(timeLimits+8)
3358:switcherator.c **** void getInput(int inputNumber) {
 4614               		.loc 1 3358 0
 4615 1a5c 20E0      		ldi r18,0
 4616               	.LVL337:
 4617 1a5e 00C0      		rjmp .L283
 4618               	.LVL338:
 4619               	.L256:
 4620               	/* epilogue start */
 4621               	.LBE24:
3580:switcherator.c ****                         }
3581:switcherator.c ****                     }
3582:switcherator.c ****                 } // end of the for
3583:switcherator.c ****             }
3584:switcherator.c ****         }
3585:switcherator.c ****     }
3586:switcherator.c **** }
 4622               		.loc 1 3586 0
 4623 1a60 2C96      		adiw r28,12
 4624 1a62 0FB6      		in __tmp_reg__,__SREG__
 4625 1a64 F894      		cli
 4626 1a66 DEBF      		out __SP_H__,r29
 4627 1a68 0FBE      		out __SREG__,__tmp_reg__
 4628 1a6a CDBF      		out __SP_L__,r28
 4629 1a6c DF91      		pop r29
 4630 1a6e CF91      		pop r28
 4631 1a70 1F91      		pop r17
 4632 1a72 0F91      		pop r16
 4633 1a74 FF90      		pop r15
 4634 1a76 EF90      		pop r14
 4635 1a78 DF90      		pop r13
 4636               	.LVL339:
 4637 1a7a CF90      		pop r12
 4638 1a7c BF90      		pop r11
 4639 1a7e AF90      		pop r10
 4640 1a80 9F90      		pop r9
 4641 1a82 8F90      		pop r8
 4642               	.LVL340:
 4643 1a84 7F90      		pop r7
 4644 1a86 6F90      		pop r6
 4645 1a88 5F90      		pop r5
 4646 1a8a 4F90      		pop r4
 4647 1a8c 3F90      		pop r3
 4648 1a8e 2F90      		pop r2
 4649 1a90 0895      		ret
 4650               	.LFE81:
 4652               	.global	inputTenthCheck
 4654               	inputTenthCheck:
 4655               	.LFB80:
3338:switcherator.c **** void inputTenthCheck(void) {
 4656               		.loc 1 3338 0
 4657 1a92 0F93      		push r16
 4658               	.LCFI106:
 4659 1a94 1F93      		push r17
 4660               	.LCFI107:
 4661 1a96 CF93      		push r28
 4662               	.LCFI108:
 4663 1a98 DF93      		push r29
 4664               	.LCFI109:
 4665               	/* prologue: function */
 4666               	/* frame size = 0 */
 4667               	/* stack size = 4 */
 4668               	.L__stack_usage = 4
 4669               	.LVL341:
 4670 1a9a 00E0      		ldi r16,lo8(inputs+6)
 4671 1a9c 10E0      		ldi r17,hi8(inputs+6)
3340:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 4672               		.loc 1 3340 0
 4673 1a9e C0E0      		ldi r28,0
 4674 1aa0 D0E0      		ldi r29,0
 4675               	.LVL342:
 4676               	.L360:
3338:switcherator.c **** void inputTenthCheck(void) {
 4677               		.loc 1 3338 0
 4678 1aa2 F801      		movw r30,r16
 4679 1aa4 3697      		sbiw r30,6
3342:switcherator.c ****         if (inputs[x][0] != 255 && inputs[x][6] == 0)
 4680               		.loc 1 3342 0
 4681 1aa6 8081      		ld r24,Z
 4682 1aa8 8F3F      		cpi r24,lo8(-1)
 4683 1aaa 01F0      		breq .L359
3342:switcherator.c ****         if (inputs[x][0] != 255 && inputs[x][6] == 0)
 4684               		.loc 1 3342 0 is_stmt 0 discriminator 1
 4685 1aac F801      		movw r30,r16
 4686 1aae 8081      		ld r24,Z
 4687 1ab0 8111      		cpse r24,__zero_reg__
 4688 1ab2 00C0      		rjmp .L359
3343:switcherator.c ****             getInput(x);
 4689               		.loc 1 3343 0 is_stmt 1
 4690 1ab4 CE01      		movw r24,r28
 4691 1ab6 0E94 0000 		call getInput
 4692               	.LVL343:
 4693               	.L359:
3340:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 4694               		.loc 1 3340 0
 4695 1aba 2196      		adiw r28,1
 4696               	.LVL344:
 4697 1abc 085F      		subi r16,-8
 4698 1abe 1F4F      		sbci r17,-1
 4699 1ac0 C430      		cpi r28,4
 4700 1ac2 D105      		cpc r29,__zero_reg__
 4701 1ac4 01F4      		brne .L360
 4702               	/* epilogue start */
3345:switcherator.c **** }
 4703               		.loc 1 3345 0
 4704 1ac6 DF91      		pop r29
 4705 1ac8 CF91      		pop r28
 4706               	.LVL345:
 4707 1aca 1F91      		pop r17
 4708 1acc 0F91      		pop r16
 4709 1ace 0895      		ret
 4710               	.LFE80:
 4712               	.global	inputCheck
 4714               	inputCheck:
 4715               	.LFB79:
3317:switcherator.c **** void inputCheck(void) {
 4716               		.loc 1 3317 0
 4717 1ad0 0F93      		push r16
 4718               	.LCFI110:
 4719 1ad2 1F93      		push r17
 4720               	.LCFI111:
 4721 1ad4 CF93      		push r28
 4722               	.LCFI112:
 4723 1ad6 DF93      		push r29
 4724               	.LCFI113:
 4725               	/* prologue: function */
 4726               	/* frame size = 0 */
 4727               	/* stack size = 4 */
 4728               	.L__stack_usage = 4
 4729               	.LVL346:
 4730 1ad8 00E0      		ldi r16,lo8(inputs+6)
 4731 1ada 10E0      		ldi r17,hi8(inputs+6)
3321:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 4732               		.loc 1 3321 0
 4733 1adc C0E0      		ldi r28,0
 4734 1ade D0E0      		ldi r29,0
 4735               	.LVL347:
 4736               	.L368:
3317:switcherator.c **** void inputCheck(void) {
 4737               		.loc 1 3317 0
 4738 1ae0 F801      		movw r30,r16
 4739 1ae2 3697      		sbiw r30,6
3323:switcherator.c ****         if (inputs[x][0] == 255)
 4740               		.loc 1 3323 0
 4741 1ae4 8081      		ld r24,Z
 4742 1ae6 8F3F      		cpi r24,lo8(-1)
 4743 1ae8 01F0      		breq .L366
3325:switcherator.c ****         pollTime = inputs[x][6];
 4744               		.loc 1 3325 0
 4745 1aea F801      		movw r30,r16
 4746 1aec 2081      		ld r18,Z
 4747               	.LVL348:
3327:switcherator.c ****         if (pollTime == 0 || pollTime == 1) {
 4748               		.loc 1 3327 0
 4749 1aee 2230      		cpi r18,lo8(2)
 4750 1af0 00F4      		brsh .L367
 4751 1af2 00C0      		rjmp .L373
 4752               	.L367:
3330:switcherator.c ****         } else if (weeklySeconds % pollTime == 0) {
 4753               		.loc 1 3330 0
 4754 1af4 30E0      		ldi r19,0
 4755 1af6 40E0      		ldi r20,0
 4756 1af8 50E0      		ldi r21,0
 4757 1afa 6091 0000 		lds r22,weeklySeconds
 4758 1afe 7091 0000 		lds r23,weeklySeconds+1
 4759 1b02 8091 0000 		lds r24,weeklySeconds+2
 4760 1b06 9091 0000 		lds r25,weeklySeconds+3
 4761 1b0a 0E94 0000 		call __udivmodsi4
 4762               	.LVL349:
 4763 1b0e 672B      		or r22,r23
 4764 1b10 682B      		or r22,r24
 4765 1b12 692B      		or r22,r25
 4766 1b14 01F4      		brne .L366
 4767               	.L373:
3331:switcherator.c ****             getInput(x);
 4768               		.loc 1 3331 0
 4769 1b16 CE01      		movw r24,r28
 4770 1b18 0E94 0000 		call getInput
 4771               	.LVL350:
 4772               	.L366:
3321:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 4773               		.loc 1 3321 0
 4774 1b1c 2196      		adiw r28,1
 4775               	.LVL351:
 4776 1b1e 085F      		subi r16,-8
 4777 1b20 1F4F      		sbci r17,-1
 4778 1b22 C430      		cpi r28,4
 4779 1b24 D105      		cpc r29,__zero_reg__
 4780 1b26 01F4      		brne .L368
 4781               	/* epilogue start */
3334:switcherator.c **** }
 4782               		.loc 1 3334 0
 4783 1b28 DF91      		pop r29
 4784 1b2a CF91      		pop r28
 4785               	.LVL352:
 4786 1b2c 1F91      		pop r17
 4787 1b2e 0F91      		pop r16
 4788 1b30 0895      		ret
 4789               	.LFE79:
 4791               	.global	flashFail
 4793               	flashFail:
 4794               	.LFB83:
3587:switcherator.c **** 
3588:switcherator.c **** // clears an input
3589:switcherator.c **** // CI nn = input number
3590:switcherator.c **** 
3591:switcherator.c **** void clearInput(char * commandReceived) {
3592:switcherator.c ****     int inputNumber = 0;
3593:switcherator.c ****     volatile unsigned char *thisPort = 0;
3594:switcherator.c ****     tempIntString[0] = commandReceived[3];
3595:switcherator.c ****     tempIntString[1] = commandReceived[4];
3596:switcherator.c ****     inputNumber = atoi(tempIntString);
3597:switcherator.c ****     int temp = inputs[inputNumber][0];
3598:switcherator.c ****     if (temp > 15 && temp < 32) {
3599:switcherator.c ****         thisPort = &PINB;
3600:switcherator.c ****         temp -= 16;
3601:switcherator.c **** #ifdef PINA
3602:switcherator.c ****     } else if (temp < 16) {
3603:switcherator.c ****         thisPort = &PINA;
3604:switcherator.c ****         temp -= 0;
3605:switcherator.c **** #endif
3606:switcherator.c **** #ifdef PINC
3607:switcherator.c ****     } else if (temp < 48) {
3608:switcherator.c ****         thisPort = &PINC;
3609:switcherator.c ****         temp -= 32;
3610:switcherator.c **** #endif
3611:switcherator.c **** #ifdef PIND
3612:switcherator.c ****     } else if (temp < 64) {
3613:switcherator.c ****         thisPort = &PIND;
3614:switcherator.c ****         temp -= 48;
3615:switcherator.c **** #endif
3616:switcherator.c **** #ifdef PINE
3617:switcherator.c ****     } else if (temp < 80) {
3618:switcherator.c ****         thisPort = &PINE;
3619:switcherator.c ****         temp -= 64;
3620:switcherator.c **** #endif
3621:switcherator.c **** #ifdef PINF
3622:switcherator.c ****     } else if (temp < 96) {
3623:switcherator.c ****         thisPort = &PINF;
3624:switcherator.c ****         temp -= 80;
3625:switcherator.c **** #endif
3626:switcherator.c **** #ifdef PING
3627:switcherator.c ****     } else if (temp < 112) {
3628:switcherator.c ****         thisPort = &PING;
3629:switcherator.c ****         temp -= 96;
3630:switcherator.c **** #endif
3631:switcherator.c **** #ifdef PINH
3632:switcherator.c ****     } else if (temp < 128) {
3633:switcherator.c ****         thisPort = &PINH;
3634:switcherator.c ****         temp -= 112;
3635:switcherator.c **** #endif
3636:switcherator.c **** #ifdef PINI
3637:switcherator.c ****     } else if (temp < 144) {
3638:switcherator.c ****         thisPort = &PINI;
3639:switcherator.c ****         temp -= 128;
3640:switcherator.c **** #endif
3641:switcherator.c ****     } else {
3642:switcherator.c ****         ok();
3643:switcherator.c ****         return;
3644:switcherator.c ****     }
3645:switcherator.c ****     // zero out the port
3646:switcherator.c ****     *thisPort &= ~(1 << temp);
3647:switcherator.c ****     inputs[inputNumber][0] = 255;
3648:switcherator.c ****     ok();
3649:switcherator.c **** }
3650:switcherator.c **** 
3651:switcherator.c **** /****************************************************************
3652:switcherator.c ****  *
3653:switcherator.c ****  *              All Things Interrupt and on offish Related
3654:switcherator.c ****  *
3655:switcherator.c ****  ****************************************************************/
3656:switcherator.c **** 
3657:switcherator.c **** 
3658:switcherator.c **** // Flashes the indicator pin to determine problems
3659:switcherator.c **** 
3660:switcherator.c **** void flashFail(void) {
 4795               		.loc 1 3660 0
 4796               	/* prologue: function */
 4797               	/* frame size = 0 */
 4798               	/* stack size = 0 */
 4799               	.L__stack_usage = 0
3661:switcherator.c ****     failTimer++;
 4800               		.loc 1 3661 0
 4801 1b32 8091 0000 		lds r24,failTimer
 4802 1b36 8F5F      		subi r24,lo8(-(1))
 4803 1b38 8093 0000 		sts failTimer,r24
3662:switcherator.c ****     INDICATOR_DDR |= INDICATOR_PIN;
 4804               		.loc 1 3662 0
 4805 1b3c 529A      		sbi 0xa,2
3663:switcherator.c ****     // different timings for different fails
3664:switcherator.c ****     if (failCondition == 1) {
 4806               		.loc 1 3664 0
 4807 1b3e 9091 0000 		lds r25,failCondition
 4808 1b42 9130      		cpi r25,lo8(1)
 4809 1b44 01F4      		brne .L375
3665:switcherator.c ****         if (failTimer == 2) {
 4810               		.loc 1 3665 0
 4811 1b46 8230      		cpi r24,lo8(2)
 4812 1b48 01F4      		brne .L376
 4813 1b4a 00C0      		rjmp .L393
 4814               	.L376:
3666:switcherator.c ****             INDICATOR_PORT |= INDICATOR_PIN;
3667:switcherator.c ****         } else if (failTimer == 4) {
 4815               		.loc 1 3667 0
 4816 1b4c 8430      		cpi r24,lo8(4)
 4817 1b4e 01F4      		brne .L378
 4818 1b50 00C0      		rjmp .L391
 4819               	.L378:
3668:switcherator.c ****             INDICATOR_PORT &= ~(INDICATOR_PIN);
3669:switcherator.c ****         } else if (failTimer == 24)
 4820               		.loc 1 3669 0
 4821 1b52 8831      		cpi r24,lo8(24)
 4822 1b54 01F4      		brne .L374
 4823 1b56 00C0      		rjmp .L392
 4824               	.L375:
3670:switcherator.c ****             failTimer = 0;
3671:switcherator.c ****     } else if (failCondition == 2) {
 4825               		.loc 1 3671 0
 4826 1b58 9230      		cpi r25,lo8(2)
 4827 1b5a 01F4      		brne .L379
3672:switcherator.c ****         if (failTimer == 2) {
 4828               		.loc 1 3672 0
 4829 1b5c 8230      		cpi r24,lo8(2)
 4830 1b5e 01F4      		brne .L380
 4831 1b60 00C0      		rjmp .L393
 4832               	.L380:
3673:switcherator.c ****             INDICATOR_PORT |= INDICATOR_PIN;
3674:switcherator.c ****         } else if (failTimer == 4) {
 4833               		.loc 1 3674 0
 4834 1b62 8430      		cpi r24,lo8(4)
 4835 1b64 01F4      		brne .L381
 4836 1b66 00C0      		rjmp .L391
 4837               	.L381:
3675:switcherator.c ****             INDICATOR_PORT &= ~(INDICATOR_PIN);
3676:switcherator.c ****         } else if (failTimer == 8) {
 4838               		.loc 1 3676 0
 4839 1b68 8830      		cpi r24,lo8(8)
 4840 1b6a 01F4      		brne .L382
 4841 1b6c 00C0      		rjmp .L393
 4842               	.L382:
3677:switcherator.c ****             INDICATOR_PORT |= INDICATOR_PIN;
3678:switcherator.c ****         } else if (failTimer == 10) {
 4843               		.loc 1 3678 0
 4844 1b6e 8A30      		cpi r24,lo8(10)
 4845 1b70 01F4      		brne .L383
 4846 1b72 00C0      		rjmp .L391
 4847               	.L383:
3679:switcherator.c ****             INDICATOR_PORT &= ~(INDICATOR_PIN);
3680:switcherator.c ****         } else if (failTimer == 30)
 4848               		.loc 1 3680 0
 4849 1b74 8E31      		cpi r24,lo8(30)
 4850 1b76 01F4      		brne .L374
 4851 1b78 00C0      		rjmp .L392
 4852               	.L379:
3681:switcherator.c ****             failTimer = 0;
3682:switcherator.c ****     } else if (failCondition == 3) {
 4853               		.loc 1 3682 0
 4854 1b7a 9330      		cpi r25,lo8(3)
 4855 1b7c 01F4      		brne .L374
3683:switcherator.c ****         if (failTimer == 2) {
 4856               		.loc 1 3683 0
 4857 1b7e 8230      		cpi r24,lo8(2)
 4858 1b80 01F4      		brne .L384
 4859 1b82 00C0      		rjmp .L393
 4860               	.L384:
3684:switcherator.c ****             INDICATOR_PORT |= INDICATOR_PIN;
3685:switcherator.c ****         } else if (failTimer == 4) {
 4861               		.loc 1 3685 0
 4862 1b84 8430      		cpi r24,lo8(4)
 4863 1b86 01F4      		brne .L385
 4864 1b88 00C0      		rjmp .L391
 4865               	.L385:
3686:switcherator.c ****             INDICATOR_PORT &= ~(INDICATOR_PIN);
3687:switcherator.c ****         } else if (failTimer == 8) {
 4866               		.loc 1 3687 0
 4867 1b8a 8830      		cpi r24,lo8(8)
 4868 1b8c 01F4      		brne .L386
 4869 1b8e 00C0      		rjmp .L393
 4870               	.L386:
3688:switcherator.c ****             INDICATOR_PORT |= INDICATOR_PIN;
3689:switcherator.c ****         } else if (failTimer == 10) {
 4871               		.loc 1 3689 0
 4872 1b90 8A30      		cpi r24,lo8(10)
 4873 1b92 01F4      		brne .L387
 4874 1b94 00C0      		rjmp .L391
 4875               	.L387:
3690:switcherator.c ****             INDICATOR_PORT &= ~(INDICATOR_PIN);
3691:switcherator.c ****         } else if (failTimer == 14) {
 4876               		.loc 1 3691 0
 4877 1b96 8E30      		cpi r24,lo8(14)
 4878 1b98 01F4      		brne .L388
 4879               	.L393:
3692:switcherator.c ****             INDICATOR_PORT |= INDICATOR_PIN;
 4880               		.loc 1 3692 0
 4881 1b9a 5A9A      		sbi 0xb,2
 4882 1b9c 0895      		ret
 4883               	.L388:
3693:switcherator.c ****         } else if (failTimer == 16) {
 4884               		.loc 1 3693 0
 4885 1b9e 8031      		cpi r24,lo8(16)
 4886 1ba0 01F4      		brne .L389
 4887               	.L391:
3694:switcherator.c ****             INDICATOR_PORT &= ~(INDICATOR_PIN);
 4888               		.loc 1 3694 0
 4889 1ba2 5A98      		cbi 0xb,2
 4890 1ba4 0895      		ret
 4891               	.L389:
3695:switcherator.c ****         } else if (failTimer == 36)
 4892               		.loc 1 3695 0
 4893 1ba6 8432      		cpi r24,lo8(36)
 4894 1ba8 01F4      		brne .L374
 4895               	.L392:
3696:switcherator.c ****             failTimer = 0;
 4896               		.loc 1 3696 0
 4897 1baa 1092 0000 		sts failTimer,__zero_reg__
 4898               	.L374:
 4899 1bae 0895      		ret
 4900               	.LFE83:
 4902               	.global	clearFail
 4904               	clearFail:
 4905               	.LFB84:
3697:switcherator.c ****         }
3698:switcherator.c **** }
3699:switcherator.c **** 
3700:switcherator.c **** // turns off the indicator pin
3701:switcherator.c **** void clearFail(void) {
 4906               		.loc 1 3701 0
 4907               	/* prologue: function */
 4908               	/* frame size = 0 */
 4909               	/* stack size = 0 */
 4910               	.L__stack_usage = 0
3702:switcherator.c ****     failTimer = 0;
 4911               		.loc 1 3702 0
 4912 1bb0 1092 0000 		sts failTimer,__zero_reg__
3703:switcherator.c ****     INDICATOR_PORT |= (INDICATOR_PIN);
 4913               		.loc 1 3703 0
 4914 1bb4 5A9A      		sbi 0xb,2
3704:switcherator.c ****     INDICATOR_DDR |= (INDICATOR_PIN);
 4915               		.loc 1 3704 0
 4916 1bb6 529A      		sbi 0xa,2
 4917 1bb8 0895      		ret
 4918               	.LFE84:
 4920               	.global	sendMessage
 4922               	sendMessage:
 4923               	.LFB76:
3019:switcherator.c **** void sendMessage(char * myResponse) {
 4924               		.loc 1 3019 0
 4925               	.LVL353:
 4926 1bba CF93      		push r28
 4927               	.LCFI114:
 4928 1bbc DF93      		push r29
 4929               	.LCFI115:
 4930 1bbe 00D0      		rcall .
 4931               	.LCFI116:
 4932 1bc0 CDB7      		in r28,__SP_L__
 4933 1bc2 DEB7      		in r29,__SP_H__
 4934               	.LCFI117:
 4935               	/* prologue: function */
 4936               	/* frame size = 2 */
 4937               	/* stack size = 4 */
 4938               	.L__stack_usage = 4
3020:switcherator.c ****     stopRx();
 4939               		.loc 1 3020 0
 4940 1bc4 8983      		std Y+1,r24
 4941 1bc6 9A83      		std Y+2,r25
 4942 1bc8 0E94 0000 		call stopRx
 4943               	.LVL354:
 4944               	.LBB25:
 4945               	.LBB26:
 4946               		.file 2 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h"
   1:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
   6:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
   9:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  12:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  17:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  21:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  33:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  35:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  38:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  41:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  42:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  46:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /** \file */
  47:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \code
  49:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \endcode
  53:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  54:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     used.
  58:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  59:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  68:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  77:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  81:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** */
  82:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  83:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  87:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  88:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  93:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  94:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  97:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  98:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
 103:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 104:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /**
 105:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 107:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 109:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 112:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 114:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 120:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 125:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 129:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 132:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 140:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****  */
 141:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** void
 142:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** {
 144:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 153:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 156:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 159:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#else
 160:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#endif
 163:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 164:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 165:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 166:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #else
 167:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	{
 172:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		{
 176:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		}
 180:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		return;
 181:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	}
 182:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	else
 183:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
 186:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** }
 187:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 188:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /**
 189:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 191:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 193:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 196:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 198:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 202:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   
 207:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 211:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****  
 214:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 222:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****  */
 223:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** void
 224:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** {
 226:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 235:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 238:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 241:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#else
 242:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		//round up by default
 243:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#endif
 245:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 246:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 4947               		.loc 2 246 0
 4948 1bcc AFE8      		ldi r26,lo8(399)
 4949 1bce B1E0      		ldi r27,hi8(399)
 4950 1bd0 1197      		1: sbiw r26,1
 4951 1bd2 01F4      		brne 1b
 4952 1bd4 00C0      		rjmp .
 4953 1bd6 0000      		nop
 4954               	.LBE26:
 4955               	.LBE25:
3022:switcherator.c ****     int transmitLength = strlen(myResponse);
 4956               		.loc 1 3022 0
 4957 1bd8 8981      		ldd r24,Y+1
 4958 1bda E82F      		mov r30,r24
 4959 1bdc 9A81      		ldd r25,Y+2
 4960 1bde F92F      		mov r31,r25
 4961 1be0 DF01      		movw r26,r30
 4962               		0:
 4963 1be2 0D90      		ld __tmp_reg__,X+
 4964 1be4 0020      		tst __tmp_reg__
 4965 1be6 01F4      		brne 0b
 4966 1be8 BD01      		movw r22,r26
 4967 1bea 6150      		subi r22,1
 4968 1bec 7109      		sbc r23,__zero_reg__
 4969 1bee 6E1B      		sub r22,r30
 4970 1bf0 7F0B      		sbc r23,r31
3023:switcherator.c ****     if(!transmit(myResponse, transmitLength)) {
 4971               		.loc 1 3023 0
 4972 1bf2 0E94 0000 		call transmit
 4973               	.LVL355:
 4974 1bf6 8111      		cpse r24,__zero_reg__
 4975 1bf8 00C0      		rjmp .L396
3024:switcherator.c ****         failCondition = 2;
 4976               		.loc 1 3024 0
 4977 1bfa 82E0      		ldi r24,lo8(2)
 4978 1bfc 8093 0000 		sts failCondition,r24
 4979 1c00 00C0      		rjmp .L397
 4980               	.L396:
3026:switcherator.c ****         failCondition = 0;
 4981               		.loc 1 3026 0
 4982 1c02 1092 0000 		sts failCondition,__zero_reg__
3027:switcherator.c ****         clearFail();
 4983               		.loc 1 3027 0
 4984 1c06 0E94 0000 		call clearFail
 4985               	.LVL356:
 4986               	.L397:
 4987               	/* epilogue start */
3030:switcherator.c **** }
 4988               		.loc 1 3030 0
 4989 1c0a 0F90      		pop __tmp_reg__
 4990 1c0c 0F90      		pop __tmp_reg__
 4991 1c0e DF91      		pop r29
 4992 1c10 CF91      		pop r28
3029:switcherator.c ****     startRx();
 4993               		.loc 1 3029 0
 4994 1c12 0C94 0000 		jmp startRx
 4995               	.LVL357:
 4996               	.LFE76:
 4998               		.section	.rodata.str1.1
 4999               	.LC8:
 5000 000b 7230 2030 		.string	"r0 0x"
 5000      7800 
 5001               	.LC9:
 5002 0011 7231 2030 		.string	"r1 0x"
 5002      7800 
 5003               	.LC10:
 5004 0017 7232 2030 		.string	"r2 0x"
 5004      7800 
 5005               	.LC11:
 5006 001d 7233 2030 		.string	"r3 0x"
 5006      7800 
 5007               	.LC12:
 5008 0023 7234 2030 		.string	"r4 0x"
 5008      7800 
 5009               	.LC13:
 5010 0029 7235 2030 		.string	"r5 0x"
 5010      7800 
 5011               	.LC14:
 5012 002f 7420 3078 		.string	"t 0x"
 5012      00
 5013               	.LC6:
 5014 0034 3078 3030 		.string	"0x00"
 5014      00
 5015               	.LC7:
 5016 0039 3030 3030 		.string	"00000"
 5016      3000 
 5017               		.text
 5018               	.global	radioChangeAddress
 5020               	radioChangeAddress:
 5021               	.LFB74:
2943:switcherator.c **** void radioChangeAddress(char * commandReceived) {
 5022               		.loc 1 2943 0
 5023               	.LVL358:
 5024 1c16 2F92      		push r2
 5025               	.LCFI118:
 5026 1c18 3F92      		push r3
 5027               	.LCFI119:
 5028 1c1a 4F92      		push r4
 5029               	.LCFI120:
 5030 1c1c 5F92      		push r5
 5031               	.LCFI121:
 5032 1c1e 6F92      		push r6
 5033               	.LCFI122:
 5034 1c20 7F92      		push r7
 5035               	.LCFI123:
 5036 1c22 8F92      		push r8
 5037               	.LCFI124:
 5038 1c24 9F92      		push r9
 5039               	.LCFI125:
 5040 1c26 AF92      		push r10
 5041               	.LCFI126:
 5042 1c28 BF92      		push r11
 5043               	.LCFI127:
 5044 1c2a CF92      		push r12
 5045               	.LCFI128:
 5046 1c2c DF92      		push r13
 5047               	.LCFI129:
 5048 1c2e EF92      		push r14
 5049               	.LCFI130:
 5050 1c30 FF92      		push r15
 5051               	.LCFI131:
 5052 1c32 0F93      		push r16
 5053               	.LCFI132:
 5054 1c34 1F93      		push r17
 5055               	.LCFI133:
 5056 1c36 CF93      		push r28
 5057               	.LCFI134:
 5058 1c38 DF93      		push r29
 5059               	.LCFI135:
 5060 1c3a CDB7      		in r28,__SP_L__
 5061 1c3c DEB7      		in r29,__SP_H__
 5062               	.LCFI136:
 5063 1c3e 2B97      		sbiw r28,11
 5064               	.LCFI137:
 5065 1c40 0FB6      		in __tmp_reg__,__SREG__
 5066 1c42 F894      		cli
 5067 1c44 DEBF      		out __SP_H__,r29
 5068 1c46 0FBE      		out __SREG__,__tmp_reg__
 5069 1c48 CDBF      		out __SP_L__,r28
 5070               	/* prologue: function */
 5071               	/* frame size = 11 */
 5072               	/* stack size = 29 */
 5073               	.L__stack_usage = 29
 5074 1c4a 5C01      		movw r10,r24
 5075               	.LVL359:
2945:switcherator.c ****     statusMsg[0] = 0;
 5076               		.loc 1 2945 0
 5077 1c4c 1092 0000 		sts statusMsg,__zero_reg__
 5078               	.LVL360:
2948:switcherator.c ****     char tempString[] = "0x00";
 5079               		.loc 1 2948 0
 5080 1c50 85E0      		ldi r24,lo8(5)
 5081               	.LVL361:
 5082 1c52 E0E0      		ldi r30,lo8(.LC6)
 5083 1c54 F0E0      		ldi r31,hi8(.LC6)
 5084 1c56 DE01      		movw r26,r28
 5085 1c58 1796      		adiw r26,7
 5086               		0:
 5087 1c5a 0190      		ld r0,Z+
 5088 1c5c 0D92      		st X+,r0
 5089 1c5e 8A95      		dec r24
 5090 1c60 01F4      		brne 0b
2949:switcherator.c ****     char tempRadioString[] = "00000";
 5091               		.loc 1 2949 0
 5092 1c62 86E0      		ldi r24,lo8(6)
 5093 1c64 E0E0      		ldi r30,lo8(.LC7)
 5094 1c66 F0E0      		ldi r31,hi8(.LC7)
 5095 1c68 DE01      		movw r26,r28
 5096 1c6a 1196      		adiw r26,1
 5097               		0:
 5098 1c6c 0190      		ld r0,Z+
 5099 1c6e 0D92      		st X+,r0
 5100 1c70 8A95      		dec r24
 5101 1c72 01F4      		brne 0b
2943:switcherator.c **** void radioChangeAddress(char * commandReceived) {
 5102               		.loc 1 2943 0
 5103 1c74 6501      		movw r12,r10
 5104 1c76 88E0      		ldi r24,8
 5105 1c78 C80E      		add r12,r24
 5106 1c7a D11C      		adc r13,__zero_reg__
2947:switcherator.c ****     uint64_t newAddress = 0;
 5107               		.loc 1 2947 0
 5108 1c7c 212C      		mov r2,__zero_reg__
 5109 1c7e 312C      		mov r3,__zero_reg__
 5110 1c80 412C      		mov r4,__zero_reg__
 5111 1c82 512C      		mov r5,__zero_reg__
 5112 1c84 612C      		mov r6,__zero_reg__
 5113 1c86 712C      		mov r7,__zero_reg__
 5114 1c88 812C      		mov r8,__zero_reg__
 5115 1c8a 912C      		mov r9,__zero_reg__
2950:switcherator.c ****     for (x = 0; x < 5; x++) {
 5116               		.loc 1 2950 0
 5117 1c8c E12C      		mov r14,__zero_reg__
 5118 1c8e F12C      		mov r15,__zero_reg__
 5119               	.LVL362:
 5120               	.L400:
2943:switcherator.c **** void radioChangeAddress(char * commandReceived) {
 5121               		.loc 1 2943 0
 5122 1c90 F601      		movw r30,r12
 5123 1c92 3197      		sbiw r30,1
2951:switcherator.c ****         tempString[2] = commandReceived[((x * 2) + 7)];
 5124               		.loc 1 2951 0
 5125 1c94 8081      		ld r24,Z
 5126 1c96 8987      		std Y+9,r24
2952:switcherator.c ****         tempString[3] = commandReceived[((x * 2) + 8)];
 5127               		.loc 1 2952 0
 5128 1c98 F601      		movw r30,r12
 5129 1c9a 8081      		ld r24,Z
 5130 1c9c 8A87      		std Y+10,r24
2953:switcherator.c ****         tempInt = strtol(tempString, 0, 0);
 5131               		.loc 1 2953 0
 5132 1c9e 40E0      		ldi r20,0
 5133 1ca0 50E0      		ldi r21,0
 5134 1ca2 60E0      		ldi r22,0
 5135 1ca4 70E0      		ldi r23,0
 5136 1ca6 CE01      		movw r24,r28
 5137 1ca8 0796      		adiw r24,7
 5138 1caa 0E94 0000 		call strtol
 5139               	.LVL363:
2954:switcherator.c ****         newAddress |= tempInt;
 5140               		.loc 1 2954 0
 5141 1cae 872F      		mov r24,r23
 5142 1cb0 880F      		lsl r24
 5143 1cb2 880B      		sbc r24,r24
 5144 1cb4 262A      		or r2,r22
 5145 1cb6 372A      		or r3,r23
 5146 1cb8 482A      		or r4,r24
 5147 1cba 582A      		or r5,r24
 5148 1cbc 682A      		or r6,r24
 5149 1cbe 782A      		or r7,r24
 5150 1cc0 882A      		or r8,r24
 5151 1cc2 982A      		or r9,r24
 5152               	.LVL364:
2955:switcherator.c ****         if (x < 4)
 5153               		.loc 1 2955 0
 5154 1cc4 F4E0      		ldi r31,4
 5155 1cc6 EF16      		cp r14,r31
 5156 1cc8 F104      		cpc r15,__zero_reg__
 5157 1cca 01F0      		breq .L399
2956:switcherator.c ****             newAddress <<= 8;
 5158               		.loc 1 2956 0
 5159 1ccc 9101      		movw r18,r2
 5160 1cce A201      		movw r20,r4
 5161 1cd0 B301      		movw r22,r6
 5162 1cd2 C401      		movw r24,r8
 5163 1cd4 08E0      		ldi r16,lo8(8)
 5164 1cd6 0E94 0000 		call __ashldi3
 5165 1cda 1901      		movw r2,r18
 5166               	.LVL365:
 5167 1cdc 2A01      		movw r4,r20
 5168 1cde 3B01      		movw r6,r22
 5169 1ce0 4C01      		movw r8,r24
 5170               	.LVL366:
 5171               	.L399:
2950:switcherator.c ****     for (x = 0; x < 5; x++) {
 5172               		.loc 1 2950 0
 5173 1ce2 8FEF      		ldi r24,-1
 5174 1ce4 E81A      		sub r14,r24
 5175 1ce6 F80A      		sbc r15,r24
 5176               	.LVL367:
 5177 1ce8 E2E0      		ldi r30,2
 5178 1cea CE0E      		add r12,r30
 5179 1cec D11C      		adc r13,__zero_reg__
 5180 1cee F5E0      		ldi r31,5
 5181 1cf0 EF16      		cp r14,r31
 5182 1cf2 F104      		cpc r15,__zero_reg__
 5183 1cf4 01F4      		brne .L400
2958:switcherator.c ****     switch (commandReceived[3]) {
 5184               		.loc 1 2958 0
 5185 1cf6 F501      		movw r30,r10
 5186 1cf8 8381      		ldd r24,Z+3
 5187 1cfa 8333      		cpi r24,lo8(51)
 5188 1cfc 01F4      		brne .+2
 5189 1cfe 00C0      		rjmp .L405
 5190 1d00 00F4      		brsh .L409
 5191 1d02 8133      		cpi r24,lo8(49)
 5192 1d04 01F0      		breq .L403
 5193 1d06 00F0      		brlo .+2
 5194 1d08 00C0      		rjmp .L404
 5195 1d0a 8033      		cpi r24,lo8(48)
 5196 1d0c 01F0      		breq .+2
 5197 1d0e 00C0      		rjmp .L401
 5198 1d10 00C0      		rjmp .L402
 5199               	.L409:
 5200 1d12 8533      		cpi r24,lo8(53)
 5201 1d14 01F4      		brne .+2
 5202 1d16 00C0      		rjmp .L407
 5203 1d18 00F4      		brsh .+2
 5204 1d1a 00C0      		rjmp .L406
 5205 1d1c 8435      		cpi r24,lo8(84)
 5206 1d1e 01F0      		breq .+2
 5207 1d20 00C0      		rjmp .L401
 5208 1d22 00C0      		rjmp .L408
 5209               	.L402:
2960:switcherator.c ****             rx_addr_p0 = newAddress;
 5210               		.loc 1 2960 0
 5211 1d24 2092 0000 		sts rx_addr_p0,r2
 5212 1d28 3092 0000 		sts rx_addr_p0+1,r3
 5213 1d2c 4092 0000 		sts rx_addr_p0+2,r4
 5214 1d30 5092 0000 		sts rx_addr_p0+3,r5
 5215 1d34 6092 0000 		sts rx_addr_p0+4,r6
 5216 1d38 7092 0000 		sts rx_addr_p0+5,r7
 5217 1d3c 8092 0000 		sts rx_addr_p0+6,r8
 5218 1d40 9092 0000 		sts rx_addr_p0+7,r9
2961:switcherator.c ****             strcat(statusMsg, "r0 0x");
 5219               		.loc 1 2961 0
 5220 1d44 60E0      		ldi r22,lo8(.LC8)
 5221 1d46 70E0      		ldi r23,hi8(.LC8)
 5222 1d48 80E0      		ldi r24,lo8(statusMsg)
 5223 1d4a 90E0      		ldi r25,hi8(statusMsg)
 5224 1d4c 0E94 0000 		call strcat
 5225               	.LVL368:
2962:switcherator.c ****             writeAddr(RX_ADDR_P0, newAddress);
 5226               		.loc 1 2962 0
 5227 1d50 8101      		movw r16,r2
 5228 1d52 9201      		movw r18,r4
 5229 1d54 A301      		movw r20,r6
 5230 1d56 B401      		movw r22,r8
 5231 1d58 8AE0      		ldi r24,lo8(10)
 5232 1d5a 00C0      		rjmp .L416
 5233               	.L403:
2965:switcherator.c ****             rx_addr_p1 = newAddress;
 5234               		.loc 1 2965 0
 5235 1d5c 2092 0000 		sts rx_addr_p1,r2
 5236 1d60 3092 0000 		sts rx_addr_p1+1,r3
 5237 1d64 4092 0000 		sts rx_addr_p1+2,r4
 5238 1d68 5092 0000 		sts rx_addr_p1+3,r5
 5239 1d6c 6092 0000 		sts rx_addr_p1+4,r6
 5240 1d70 7092 0000 		sts rx_addr_p1+5,r7
 5241 1d74 8092 0000 		sts rx_addr_p1+6,r8
 5242 1d78 9092 0000 		sts rx_addr_p1+7,r9
2966:switcherator.c ****             strcat(statusMsg, "r1 0x");
 5243               		.loc 1 2966 0
 5244 1d7c 60E0      		ldi r22,lo8(.LC9)
 5245 1d7e 70E0      		ldi r23,hi8(.LC9)
 5246 1d80 80E0      		ldi r24,lo8(statusMsg)
 5247 1d82 90E0      		ldi r25,hi8(statusMsg)
 5248 1d84 0E94 0000 		call strcat
 5249               	.LVL369:
2967:switcherator.c ****             writeAddr(RX_ADDR_P1, newAddress);
 5250               		.loc 1 2967 0
 5251 1d88 8101      		movw r16,r2
 5252 1d8a 9201      		movw r18,r4
 5253 1d8c A301      		movw r20,r6
 5254 1d8e B401      		movw r22,r8
 5255 1d90 8BE0      		ldi r24,lo8(11)
 5256 1d92 00C0      		rjmp .L416
 5257               	.L404:
2970:switcherator.c ****             rx_addr_p2 = newAddress;
 5258               		.loc 1 2970 0
 5259 1d94 2092 0000 		sts rx_addr_p2,r2
 5260 1d98 3092 0000 		sts rx_addr_p2+1,r3
 5261 1d9c 4092 0000 		sts rx_addr_p2+2,r4
 5262 1da0 5092 0000 		sts rx_addr_p2+3,r5
 5263 1da4 6092 0000 		sts rx_addr_p2+4,r6
 5264 1da8 7092 0000 		sts rx_addr_p2+5,r7
 5265 1dac 8092 0000 		sts rx_addr_p2+6,r8
 5266 1db0 9092 0000 		sts rx_addr_p2+7,r9
2971:switcherator.c ****             strcat(statusMsg, "r2 0x");
 5267               		.loc 1 2971 0
 5268 1db4 60E0      		ldi r22,lo8(.LC10)
 5269 1db6 70E0      		ldi r23,hi8(.LC10)
 5270 1db8 80E0      		ldi r24,lo8(statusMsg)
 5271 1dba 90E0      		ldi r25,hi8(statusMsg)
 5272 1dbc 0E94 0000 		call strcat
 5273               	.LVL370:
2972:switcherator.c ****             writeAddr(RX_ADDR_P2, newAddress);
 5274               		.loc 1 2972 0
 5275 1dc0 8101      		movw r16,r2
 5276 1dc2 9201      		movw r18,r4
 5277 1dc4 A301      		movw r20,r6
 5278 1dc6 B401      		movw r22,r8
 5279 1dc8 8CE0      		ldi r24,lo8(12)
 5280 1dca 00C0      		rjmp .L416
 5281               	.L405:
2975:switcherator.c ****             rx_addr_p3 = newAddress;
 5282               		.loc 1 2975 0
 5283 1dcc 2092 0000 		sts rx_addr_p3,r2
 5284 1dd0 3092 0000 		sts rx_addr_p3+1,r3
 5285 1dd4 4092 0000 		sts rx_addr_p3+2,r4
 5286 1dd8 5092 0000 		sts rx_addr_p3+3,r5
 5287 1ddc 6092 0000 		sts rx_addr_p3+4,r6
 5288 1de0 7092 0000 		sts rx_addr_p3+5,r7
 5289 1de4 8092 0000 		sts rx_addr_p3+6,r8
 5290 1de8 9092 0000 		sts rx_addr_p3+7,r9
2976:switcherator.c ****             strcat(statusMsg, "r3 0x");
 5291               		.loc 1 2976 0
 5292 1dec 60E0      		ldi r22,lo8(.LC11)
 5293 1dee 70E0      		ldi r23,hi8(.LC11)
 5294 1df0 80E0      		ldi r24,lo8(statusMsg)
 5295 1df2 90E0      		ldi r25,hi8(statusMsg)
 5296 1df4 0E94 0000 		call strcat
 5297               	.LVL371:
2977:switcherator.c ****             writeAddr(RX_ADDR_P3, newAddress);
 5298               		.loc 1 2977 0
 5299 1df8 8101      		movw r16,r2
 5300 1dfa 9201      		movw r18,r4
 5301 1dfc A301      		movw r20,r6
 5302 1dfe B401      		movw r22,r8
 5303 1e00 8DE0      		ldi r24,lo8(13)
 5304 1e02 00C0      		rjmp .L416
 5305               	.L406:
2980:switcherator.c ****             rx_addr_p4 = newAddress;
 5306               		.loc 1 2980 0
 5307 1e04 2092 0000 		sts rx_addr_p4,r2
 5308 1e08 3092 0000 		sts rx_addr_p4+1,r3
 5309 1e0c 4092 0000 		sts rx_addr_p4+2,r4
 5310 1e10 5092 0000 		sts rx_addr_p4+3,r5
 5311 1e14 6092 0000 		sts rx_addr_p4+4,r6
 5312 1e18 7092 0000 		sts rx_addr_p4+5,r7
 5313 1e1c 8092 0000 		sts rx_addr_p4+6,r8
 5314 1e20 9092 0000 		sts rx_addr_p4+7,r9
2981:switcherator.c ****             strcat(statusMsg, "r4 0x");
 5315               		.loc 1 2981 0
 5316 1e24 60E0      		ldi r22,lo8(.LC12)
 5317 1e26 70E0      		ldi r23,hi8(.LC12)
 5318 1e28 80E0      		ldi r24,lo8(statusMsg)
 5319 1e2a 90E0      		ldi r25,hi8(statusMsg)
 5320 1e2c 0E94 0000 		call strcat
 5321               	.LVL372:
2982:switcherator.c ****             writeAddr(RX_ADDR_P4, newAddress);
 5322               		.loc 1 2982 0
 5323 1e30 8101      		movw r16,r2
 5324 1e32 9201      		movw r18,r4
 5325 1e34 A301      		movw r20,r6
 5326 1e36 B401      		movw r22,r8
 5327 1e38 8EE0      		ldi r24,lo8(14)
 5328 1e3a 00C0      		rjmp .L416
 5329               	.L407:
2985:switcherator.c ****             rx_addr_p5 = newAddress;
 5330               		.loc 1 2985 0
 5331 1e3c 2092 0000 		sts rx_addr_p5,r2
 5332 1e40 3092 0000 		sts rx_addr_p5+1,r3
 5333 1e44 4092 0000 		sts rx_addr_p5+2,r4
 5334 1e48 5092 0000 		sts rx_addr_p5+3,r5
 5335 1e4c 6092 0000 		sts rx_addr_p5+4,r6
 5336 1e50 7092 0000 		sts rx_addr_p5+5,r7
 5337 1e54 8092 0000 		sts rx_addr_p5+6,r8
 5338 1e58 9092 0000 		sts rx_addr_p5+7,r9
2986:switcherator.c ****             strcat(statusMsg, "r5 0x");
 5339               		.loc 1 2986 0
 5340 1e5c 60E0      		ldi r22,lo8(.LC13)
 5341 1e5e 70E0      		ldi r23,hi8(.LC13)
 5342 1e60 80E0      		ldi r24,lo8(statusMsg)
 5343 1e62 90E0      		ldi r25,hi8(statusMsg)
 5344 1e64 0E94 0000 		call strcat
 5345               	.LVL373:
2987:switcherator.c ****             writeAddr(RX_ADDR_P5, newAddress);
 5346               		.loc 1 2987 0
 5347 1e68 8101      		movw r16,r2
 5348 1e6a 9201      		movw r18,r4
 5349 1e6c A301      		movw r20,r6
 5350 1e6e B401      		movw r22,r8
 5351 1e70 8FE0      		ldi r24,lo8(15)
 5352 1e72 00C0      		rjmp .L416
 5353               	.L408:
2990:switcherator.c ****             tx_addr = newAddress;
 5354               		.loc 1 2990 0
 5355 1e74 2092 0000 		sts tx_addr,r2
 5356 1e78 3092 0000 		sts tx_addr+1,r3
 5357 1e7c 4092 0000 		sts tx_addr+2,r4
 5358 1e80 5092 0000 		sts tx_addr+3,r5
 5359 1e84 6092 0000 		sts tx_addr+4,r6
 5360 1e88 7092 0000 		sts tx_addr+5,r7
 5361 1e8c 8092 0000 		sts tx_addr+6,r8
 5362 1e90 9092 0000 		sts tx_addr+7,r9
2991:switcherator.c ****             strcat(statusMsg, "t 0x");
 5363               		.loc 1 2991 0
 5364 1e94 60E0      		ldi r22,lo8(.LC14)
 5365 1e96 70E0      		ldi r23,hi8(.LC14)
 5366 1e98 80E0      		ldi r24,lo8(statusMsg)
 5367 1e9a 90E0      		ldi r25,hi8(statusMsg)
 5368 1e9c 0E94 0000 		call strcat
 5369               	.LVL374:
2992:switcherator.c ****             writeAddr(TX_ADDR, newAddress);
 5370               		.loc 1 2992 0
 5371 1ea0 8101      		movw r16,r2
 5372 1ea2 9201      		movw r18,r4
 5373 1ea4 A301      		movw r20,r6
 5374 1ea6 B401      		movw r22,r8
 5375 1ea8 80E1      		ldi r24,lo8(16)
 5376               	.L416:
 5377 1eaa 0E94 0000 		call writeAddr
 5378               	.LVL375:
 5379               	.L401:
2995:switcherator.c ****     unformatAddress(newAddress, tempRadioString);
 5380               		.loc 1 2995 0
 5381 1eae 8E01      		movw r16,r28
 5382 1eb0 0F5F      		subi r16,-1
 5383 1eb2 1F4F      		sbci r17,-1
 5384 1eb4 9101      		movw r18,r2
 5385 1eb6 A201      		movw r20,r4
 5386 1eb8 B301      		movw r22,r6
 5387 1eba C401      		movw r24,r8
 5388 1ebc 0E94 0000 		call unformatAddress
 5389               	.LVL376:
 5390 1ec0 7801      		movw r14,r16
2943:switcherator.c **** void radioChangeAddress(char * commandReceived) {
 5391               		.loc 1 2943 0
 5392 1ec2 6E01      		movw r12,r28
 5393 1ec4 F6E0      		ldi r31,6
 5394 1ec6 CF0E      		add r12,r31
 5395 1ec8 D11C      		adc r13,__zero_reg__
 5396               	.LVL377:
 5397               	.L410:
2997:switcherator.c ****         returnHexWithout(tempRadioString[x], tempLongString);
 5398               		.loc 1 2997 0 discriminator 2
 5399 1eca 60E0      		ldi r22,lo8(tempLongString)
 5400 1ecc 70E0      		ldi r23,hi8(tempLongString)
 5401 1ece F701      		movw r30,r14
 5402 1ed0 8191      		ld r24,Z+
 5403 1ed2 7F01      		movw r14,r30
 5404 1ed4 90E0      		ldi r25,0
 5405 1ed6 0E94 0000 		call returnHexWithout
 5406               	.LVL378:
2998:switcherator.c ****         strcat(statusMsg, tempLongString);
 5407               		.loc 1 2998 0 discriminator 2
 5408 1eda 60E0      		ldi r22,lo8(tempLongString)
 5409 1edc 70E0      		ldi r23,hi8(tempLongString)
 5410 1ede 80E0      		ldi r24,lo8(statusMsg)
 5411 1ee0 90E0      		ldi r25,hi8(statusMsg)
 5412 1ee2 0E94 0000 		call strcat
 5413               	.LVL379:
2996:switcherator.c ****     for (x = 0; x < 5; x++) {
 5414               		.loc 1 2996 0 discriminator 2
 5415 1ee6 EC14      		cp r14,r12
 5416 1ee8 FD04      		cpc r15,r13
 5417 1eea 01F4      		brne .L410
3000:switcherator.c ****     sendMessage(statusMsg);
 5418               		.loc 1 3000 0
 5419 1eec 80E0      		ldi r24,lo8(statusMsg)
 5420 1eee 90E0      		ldi r25,hi8(statusMsg)
 5421 1ef0 0E94 0000 		call sendMessage
 5422               	.LVL380:
 5423               	/* epilogue start */
3001:switcherator.c **** }
 5424               		.loc 1 3001 0
 5425 1ef4 2B96      		adiw r28,11
 5426 1ef6 0FB6      		in __tmp_reg__,__SREG__
 5427 1ef8 F894      		cli
 5428 1efa DEBF      		out __SP_H__,r29
 5429 1efc 0FBE      		out __SREG__,__tmp_reg__
 5430 1efe CDBF      		out __SP_L__,r28
 5431 1f00 DF91      		pop r29
 5432 1f02 CF91      		pop r28
 5433 1f04 1F91      		pop r17
 5434 1f06 0F91      		pop r16
 5435 1f08 FF90      		pop r15
 5436 1f0a EF90      		pop r14
 5437 1f0c DF90      		pop r13
 5438 1f0e CF90      		pop r12
 5439 1f10 BF90      		pop r11
 5440 1f12 AF90      		pop r10
 5441               	.LVL381:
 5442 1f14 9F90      		pop r9
 5443               	.LVL382:
 5444 1f16 8F90      		pop r8
 5445 1f18 7F90      		pop r7
 5446 1f1a 6F90      		pop r6
 5447 1f1c 5F90      		pop r5
 5448 1f1e 4F90      		pop r4
 5449 1f20 3F90      		pop r3
 5450 1f22 2F90      		pop r2
 5451 1f24 0895      		ret
 5452               	.LFE74:
 5454               		.section	.rodata.str1.1
 5455               	.LC15:
 5456 003f 7231 2D30 		.string	"r1-0x"
 5456      7800 
 5457               	.LC16:
 5458 0045 7232 2D30 		.string	"r2-0x"
 5458      7800 
 5459               	.LC17:
 5460 004b 7233 2D30 		.string	"r3-0x"
 5460      7800 
 5461               	.LC18:
 5462 0051 7234 2D30 		.string	"r4-0x"
 5462      7800 
 5463               	.LC19:
 5464 0057 7235 2D30 		.string	"r5-0x"
 5464      7800 
 5465               	.LC20:
 5466 005d 742D 3078 		.string	"t-0x"
 5466      00
 5467               	.LC21:
 5468 0062 7230 2D30 		.string	"r0-0x"
 5468      7800 
 5469               		.text
 5470               	.global	radioDisplayAddress
 5472               	radioDisplayAddress:
 5473               	.LFB73:
2903:switcherator.c **** void radioDisplayAddress(char * commandReceived) {
 5474               		.loc 1 2903 0
 5475               	.LVL383:
 5476 1f26 EF92      		push r14
 5477               	.LCFI138:
 5478 1f28 FF92      		push r15
 5479               	.LCFI139:
 5480 1f2a 0F93      		push r16
 5481               	.LCFI140:
 5482 1f2c 1F93      		push r17
 5483               	.LCFI141:
 5484 1f2e CF93      		push r28
 5485               	.LCFI142:
 5486 1f30 DF93      		push r29
 5487               	.LCFI143:
 5488 1f32 00D0      		rcall .
 5489 1f34 00D0      		rcall .
 5490 1f36 00D0      		rcall .
 5491               	.LCFI144:
 5492 1f38 CDB7      		in r28,__SP_L__
 5493 1f3a DEB7      		in r29,__SP_H__
 5494               	.LCFI145:
 5495               	/* prologue: function */
 5496               	/* frame size = 6 */
 5497               	/* stack size = 12 */
 5498               	.L__stack_usage = 12
 5499               	.LVL384:
2906:switcherator.c ****     statusMsg[0] = 0;
 5500               		.loc 1 2906 0
 5501 1f3c 1092 0000 		sts statusMsg,__zero_reg__
2907:switcherator.c ****     if(commandReceived[3] == '1') {
 5502               		.loc 1 2907 0
 5503 1f40 FC01      		movw r30,r24
 5504 1f42 8381      		ldd r24,Z+3
 5505               	.LVL385:
 5506 1f44 8133      		cpi r24,lo8(49)
 5507 1f46 01F4      		brne .L418
2908:switcherator.c ****             unformatAddress(rx_addr_p1, tempRadioString);
 5508               		.loc 1 2908 0
 5509 1f48 2091 0000 		lds r18,rx_addr_p1
 5510 1f4c 3091 0000 		lds r19,rx_addr_p1+1
 5511 1f50 4091 0000 		lds r20,rx_addr_p1+2
 5512 1f54 5091 0000 		lds r21,rx_addr_p1+3
 5513 1f58 6091 0000 		lds r22,rx_addr_p1+4
 5514 1f5c 7091 0000 		lds r23,rx_addr_p1+5
 5515 1f60 8E01      		movw r16,r28
 5516 1f62 0F5F      		subi r16,-1
 5517 1f64 1F4F      		sbci r17,-1
 5518 1f66 8091 0000 		lds r24,rx_addr_p1+6
 5519 1f6a 9091 0000 		lds r25,rx_addr_p1+7
 5520 1f6e 0E94 0000 		call unformatAddress
 5521               	.LVL386:
2909:switcherator.c ****             strcat(statusMsg, "r1-0x");
 5522               		.loc 1 2909 0
 5523 1f72 60E0      		ldi r22,lo8(.LC15)
 5524 1f74 70E0      		ldi r23,hi8(.LC15)
 5525               	.L427:
 5526 1f76 80E0      		ldi r24,lo8(statusMsg)
 5527 1f78 90E0      		ldi r25,hi8(statusMsg)
 5528 1f7a 0E94 0000 		call strcat
 5529               	.LVL387:
 5530 1f7e 8E01      		movw r16,r28
 5531 1f80 0F5F      		subi r16,-1
 5532 1f82 1F4F      		sbci r17,-1
2903:switcherator.c **** void radioDisplayAddress(char * commandReceived) {
 5533               		.loc 1 2903 0
 5534 1f84 7E01      		movw r14,r28
 5535 1f86 F6E0      		ldi r31,6
 5536 1f88 EF0E      		add r14,r31
 5537 1f8a F11C      		adc r15,__zero_reg__
 5538 1f8c 00C0      		rjmp .L419
 5539               	.LVL388:
 5540               	.L418:
2910:switcherator.c ****     } else if(commandReceived[3] == '2') {
 5541               		.loc 1 2910 0
 5542 1f8e 8233      		cpi r24,lo8(50)
 5543 1f90 01F4      		brne .L420
2911:switcherator.c ****             unformatAddress(rx_addr_p2, tempRadioString);
 5544               		.loc 1 2911 0
 5545 1f92 2091 0000 		lds r18,rx_addr_p2
 5546 1f96 3091 0000 		lds r19,rx_addr_p2+1
 5547 1f9a 4091 0000 		lds r20,rx_addr_p2+2
 5548 1f9e 5091 0000 		lds r21,rx_addr_p2+3
 5549 1fa2 6091 0000 		lds r22,rx_addr_p2+4
 5550 1fa6 7091 0000 		lds r23,rx_addr_p2+5
 5551 1faa 8E01      		movw r16,r28
 5552 1fac 0F5F      		subi r16,-1
 5553 1fae 1F4F      		sbci r17,-1
 5554 1fb0 8091 0000 		lds r24,rx_addr_p2+6
 5555 1fb4 9091 0000 		lds r25,rx_addr_p2+7
 5556 1fb8 0E94 0000 		call unformatAddress
 5557               	.LVL389:
2912:switcherator.c ****             strcat(statusMsg, "r2-0x");
 5558               		.loc 1 2912 0
 5559 1fbc 60E0      		ldi r22,lo8(.LC16)
 5560 1fbe 70E0      		ldi r23,hi8(.LC16)
 5561 1fc0 00C0      		rjmp .L427
 5562               	.LVL390:
 5563               	.L420:
2913:switcherator.c ****     } else if(commandReceived[3] == '3') {
 5564               		.loc 1 2913 0
 5565 1fc2 8333      		cpi r24,lo8(51)
 5566 1fc4 01F4      		brne .L422
2914:switcherator.c ****             unformatAddress(rx_addr_p3, tempRadioString);
 5567               		.loc 1 2914 0
 5568 1fc6 2091 0000 		lds r18,rx_addr_p3
 5569 1fca 3091 0000 		lds r19,rx_addr_p3+1
 5570 1fce 4091 0000 		lds r20,rx_addr_p3+2
 5571 1fd2 5091 0000 		lds r21,rx_addr_p3+3
 5572 1fd6 6091 0000 		lds r22,rx_addr_p3+4
 5573 1fda 7091 0000 		lds r23,rx_addr_p3+5
 5574 1fde 8E01      		movw r16,r28
 5575 1fe0 0F5F      		subi r16,-1
 5576 1fe2 1F4F      		sbci r17,-1
 5577 1fe4 8091 0000 		lds r24,rx_addr_p3+6
 5578 1fe8 9091 0000 		lds r25,rx_addr_p3+7
 5579 1fec 0E94 0000 		call unformatAddress
 5580               	.LVL391:
2915:switcherator.c ****             strcat(statusMsg, "r3-0x");
 5581               		.loc 1 2915 0
 5582 1ff0 60E0      		ldi r22,lo8(.LC17)
 5583 1ff2 70E0      		ldi r23,hi8(.LC17)
 5584 1ff4 00C0      		rjmp .L427
 5585               	.LVL392:
 5586               	.L422:
2916:switcherator.c ****     } else if(commandReceived[3] == '4') {
 5587               		.loc 1 2916 0
 5588 1ff6 8433      		cpi r24,lo8(52)
 5589 1ff8 01F4      		brne .L423
2917:switcherator.c ****             unformatAddress(rx_addr_p4, tempRadioString);
 5590               		.loc 1 2917 0
 5591 1ffa 2091 0000 		lds r18,rx_addr_p4
 5592 1ffe 3091 0000 		lds r19,rx_addr_p4+1
 5593 2002 4091 0000 		lds r20,rx_addr_p4+2
 5594 2006 5091 0000 		lds r21,rx_addr_p4+3
 5595 200a 6091 0000 		lds r22,rx_addr_p4+4
 5596 200e 7091 0000 		lds r23,rx_addr_p4+5
 5597 2012 8E01      		movw r16,r28
 5598 2014 0F5F      		subi r16,-1
 5599 2016 1F4F      		sbci r17,-1
 5600 2018 8091 0000 		lds r24,rx_addr_p4+6
 5601 201c 9091 0000 		lds r25,rx_addr_p4+7
 5602 2020 0E94 0000 		call unformatAddress
 5603               	.LVL393:
2918:switcherator.c ****             strcat(statusMsg, "r4-0x");
 5604               		.loc 1 2918 0
 5605 2024 60E0      		ldi r22,lo8(.LC18)
 5606 2026 70E0      		ldi r23,hi8(.LC18)
 5607 2028 00C0      		rjmp .L427
 5608               	.LVL394:
 5609               	.L423:
2919:switcherator.c ****     } else if (commandReceived[3] == '5') {
 5610               		.loc 1 2919 0
 5611 202a 8533      		cpi r24,lo8(53)
 5612 202c 01F4      		brne .L424
2920:switcherator.c ****             unformatAddress(rx_addr_p5, tempRadioString);
 5613               		.loc 1 2920 0
 5614 202e 2091 0000 		lds r18,rx_addr_p5
 5615 2032 3091 0000 		lds r19,rx_addr_p5+1
 5616 2036 4091 0000 		lds r20,rx_addr_p5+2
 5617 203a 5091 0000 		lds r21,rx_addr_p5+3
 5618 203e 6091 0000 		lds r22,rx_addr_p5+4
 5619 2042 7091 0000 		lds r23,rx_addr_p5+5
 5620 2046 8E01      		movw r16,r28
 5621 2048 0F5F      		subi r16,-1
 5622 204a 1F4F      		sbci r17,-1
 5623 204c 8091 0000 		lds r24,rx_addr_p5+6
 5624 2050 9091 0000 		lds r25,rx_addr_p5+7
 5625 2054 0E94 0000 		call unformatAddress
 5626               	.LVL395:
2921:switcherator.c ****             strcat(statusMsg, "r5-0x");
 5627               		.loc 1 2921 0
 5628 2058 60E0      		ldi r22,lo8(.LC19)
 5629 205a 70E0      		ldi r23,hi8(.LC19)
 5630 205c 00C0      		rjmp .L427
 5631               	.LVL396:
 5632               	.L424:
2922:switcherator.c ****     } else if (commandReceived[3] == 'T') {
 5633               		.loc 1 2922 0
 5634 205e 8435      		cpi r24,lo8(84)
 5635 2060 01F4      		brne .L425
2923:switcherator.c ****             unformatAddress(tx_addr, tempRadioString);
 5636               		.loc 1 2923 0
 5637 2062 2091 0000 		lds r18,tx_addr
 5638 2066 3091 0000 		lds r19,tx_addr+1
 5639 206a 4091 0000 		lds r20,tx_addr+2
 5640 206e 5091 0000 		lds r21,tx_addr+3
 5641 2072 6091 0000 		lds r22,tx_addr+4
 5642 2076 7091 0000 		lds r23,tx_addr+5
 5643 207a 8E01      		movw r16,r28
 5644 207c 0F5F      		subi r16,-1
 5645 207e 1F4F      		sbci r17,-1
 5646 2080 8091 0000 		lds r24,tx_addr+6
 5647 2084 9091 0000 		lds r25,tx_addr+7
 5648 2088 0E94 0000 		call unformatAddress
 5649               	.LVL397:
2924:switcherator.c ****             strcat(statusMsg, "t-0x");
 5650               		.loc 1 2924 0
 5651 208c 60E0      		ldi r22,lo8(.LC20)
 5652 208e 70E0      		ldi r23,hi8(.LC20)
 5653 2090 00C0      		rjmp .L427
 5654               	.LVL398:
 5655               	.L425:
2926:switcherator.c ****             unformatAddress(rx_addr_p0, tempRadioString);
 5656               		.loc 1 2926 0
 5657 2092 2091 0000 		lds r18,rx_addr_p0
 5658 2096 3091 0000 		lds r19,rx_addr_p0+1
 5659 209a 4091 0000 		lds r20,rx_addr_p0+2
 5660 209e 5091 0000 		lds r21,rx_addr_p0+3
 5661 20a2 6091 0000 		lds r22,rx_addr_p0+4
 5662 20a6 7091 0000 		lds r23,rx_addr_p0+5
 5663 20aa 8E01      		movw r16,r28
 5664 20ac 0F5F      		subi r16,-1
 5665 20ae 1F4F      		sbci r17,-1
 5666 20b0 8091 0000 		lds r24,rx_addr_p0+6
 5667 20b4 9091 0000 		lds r25,rx_addr_p0+7
 5668 20b8 0E94 0000 		call unformatAddress
 5669               	.LVL399:
2927:switcherator.c ****             strcat(statusMsg, "r0-0x");
 5670               		.loc 1 2927 0
 5671 20bc 60E0      		ldi r22,lo8(.LC21)
 5672 20be 70E0      		ldi r23,hi8(.LC21)
 5673 20c0 00C0      		rjmp .L427
 5674               	.LVL400:
 5675               	.L419:
2930:switcherator.c ****         returnHexWithout(tempRadioString[x], tempLongString);
 5676               		.loc 1 2930 0 discriminator 2
 5677 20c2 60E0      		ldi r22,lo8(tempLongString)
 5678 20c4 70E0      		ldi r23,hi8(tempLongString)
 5679 20c6 F801      		movw r30,r16
 5680 20c8 8191      		ld r24,Z+
 5681 20ca 8F01      		movw r16,r30
 5682 20cc 90E0      		ldi r25,0
 5683 20ce 0E94 0000 		call returnHexWithout
 5684               	.LVL401:
2931:switcherator.c ****         strcat(statusMsg, tempLongString);
 5685               		.loc 1 2931 0 discriminator 2
 5686 20d2 60E0      		ldi r22,lo8(tempLongString)
 5687 20d4 70E0      		ldi r23,hi8(tempLongString)
 5688 20d6 80E0      		ldi r24,lo8(statusMsg)
 5689 20d8 90E0      		ldi r25,hi8(statusMsg)
 5690 20da 0E94 0000 		call strcat
 5691               	.LVL402:
2929:switcherator.c ****     for (x = 0; x < 5; x++) {
 5692               		.loc 1 2929 0 discriminator 2
 5693 20de 0E15      		cp r16,r14
 5694 20e0 1F05      		cpc r17,r15
 5695 20e2 01F4      		brne .L419
2933:switcherator.c ****     sendMessage(statusMsg);
 5696               		.loc 1 2933 0
 5697 20e4 80E0      		ldi r24,lo8(statusMsg)
 5698 20e6 90E0      		ldi r25,hi8(statusMsg)
 5699 20e8 0E94 0000 		call sendMessage
 5700               	.LVL403:
 5701               	/* epilogue start */
2934:switcherator.c **** }
 5702               		.loc 1 2934 0
 5703 20ec 2696      		adiw r28,6
 5704 20ee 0FB6      		in __tmp_reg__,__SREG__
 5705 20f0 F894      		cli
 5706 20f2 DEBF      		out __SP_H__,r29
 5707 20f4 0FBE      		out __SREG__,__tmp_reg__
 5708 20f6 CDBF      		out __SP_L__,r28
 5709 20f8 DF91      		pop r29
 5710 20fa CF91      		pop r28
 5711 20fc 1F91      		pop r17
 5712 20fe 0F91      		pop r16
 5713 2100 FF90      		pop r15
 5714 2102 EF90      		pop r14
 5715 2104 0895      		ret
 5716               	.LFE73:
 5718               		.section	.rodata.str1.1
 5719               	.LC22:
 5720 0068 5377 4F6E 		.string	"SwOn"
 5720      00
 5721               	.LC23:
 5722 006d 7900      		.string	"y"
 5723               	.LC24:
 5724 006f 6E00      		.string	"n"
 5725               		.text
 5726               	.global	switchesOn
 5728               	switchesOn:
 5729               	.LFB66:
2781:switcherator.c **** void switchesOn(void) {
 5730               		.loc 1 2781 0
 5731 2106 CF93      		push r28
 5732               	.LCFI146:
 5733 2108 DF93      		push r29
 5734               	.LCFI147:
 5735               	/* prologue: function */
 5736               	/* frame size = 0 */
 5737               	/* stack size = 2 */
 5738               	.L__stack_usage = 2
2782:switcherator.c ****     statusMsg[0] = 0;
 5739               		.loc 1 2782 0
 5740 210a 1092 0000 		sts statusMsg,__zero_reg__
2783:switcherator.c ****     strcat(statusMsg, "SwOn");
 5741               		.loc 1 2783 0
 5742 210e 60E0      		ldi r22,lo8(.LC22)
 5743 2110 70E0      		ldi r23,hi8(.LC22)
 5744 2112 80E0      		ldi r24,lo8(statusMsg)
 5745 2114 90E0      		ldi r25,hi8(statusMsg)
 5746 2116 0E94 0000 		call strcat
 5747               	.LVL404:
 5748 211a C0E0      		ldi r28,lo8(switchStatus)
 5749 211c D0E0      		ldi r29,hi8(switchStatus)
 5750               	.LVL405:
 5751               	.L432:
2786:switcherator.c ****         if (switchStatus[x] > 0) {
 5752               		.loc 1 2786 0
 5753 211e 8991      		ld r24,Y+
 5754 2120 9991      		ld r25,Y+
 5755 2122 A991      		ld r26,Y+
 5756 2124 B991      		ld r27,Y+
 5757 2126 892B      		or r24,r25
 5758 2128 8A2B      		or r24,r26
 5759 212a 8B2B      		or r24,r27
 5760 212c 01F0      		breq .L429
2787:switcherator.c ****             strcat(statusMsg, "y");
 5761               		.loc 1 2787 0
 5762 212e 60E0      		ldi r22,lo8(.LC23)
 5763 2130 70E0      		ldi r23,hi8(.LC23)
 5764 2132 00C0      		rjmp .L434
 5765               	.L429:
2789:switcherator.c ****             strcat(statusMsg, "n");
 5766               		.loc 1 2789 0
 5767 2134 60E0      		ldi r22,lo8(.LC24)
 5768 2136 70E0      		ldi r23,hi8(.LC24)
 5769               	.L434:
 5770 2138 80E0      		ldi r24,lo8(statusMsg)
 5771 213a 90E0      		ldi r25,hi8(statusMsg)
 5772 213c 0E94 0000 		call strcat
 5773               	.LVL406:
2791:switcherator.c ****         if (strlen(statusMsg) > 30) {
 5774               		.loc 1 2791 0
 5775 2140 E0E0      		ldi r30,lo8(statusMsg)
 5776 2142 F0E0      		ldi r31,hi8(statusMsg)
 5777               		0:
 5778 2144 0190      		ld __tmp_reg__,Z+
 5779 2146 0020      		tst __tmp_reg__
 5780 2148 01F4      		brne 0b
 5781 214a 3197      		sbiw r30,1
 5782 214c E050      		subi r30,lo8(statusMsg)
 5783 214e F040      		sbci r31,hi8(statusMsg)
 5784 2150 7F97      		sbiw r30,31
 5785 2152 00F0      		brlo .L431
2792:switcherator.c ****             sendMessage(statusMsg);
 5786               		.loc 1 2792 0
 5787 2154 80E0      		ldi r24,lo8(statusMsg)
 5788 2156 90E0      		ldi r25,hi8(statusMsg)
 5789 2158 0E94 0000 		call sendMessage
 5790               	.LVL407:
2793:switcherator.c ****             statusMsg[4] = 0;
 5791               		.loc 1 2793 0
 5792 215c 1092 0000 		sts statusMsg+4,__zero_reg__
 5793               	.L431:
2785:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 5794               		.loc 1 2785 0
 5795 2160 80E0      		ldi r24,hi8(switchStatus+64)
 5796 2162 C030      		cpi r28,lo8(switchStatus+64)
 5797 2164 D807      		cpc r29,r24
 5798 2166 01F4      		brne .L432
2796:switcherator.c ****     sendMessage(statusMsg);
 5799               		.loc 1 2796 0
 5800 2168 80E0      		ldi r24,lo8(statusMsg)
 5801 216a 90E0      		ldi r25,hi8(statusMsg)
 5802               	/* epilogue start */
2797:switcherator.c **** }
 5803               		.loc 1 2797 0
 5804 216c DF91      		pop r29
 5805 216e CF91      		pop r28
2796:switcherator.c ****     sendMessage(statusMsg);
 5806               		.loc 1 2796 0
 5807 2170 0C94 0000 		jmp sendMessage
 5808               	.LVL408:
 5809               	.LFE66:
 5811               		.section	.rodata.str1.1
 5812               	.LC25:
 5813 0071 496E 00   		.string	"In"
 5814               		.text
 5815               	.global	inputsProgrammed
 5817               	inputsProgrammed:
 5818               	.LFB65:
2761:switcherator.c **** void inputsProgrammed(void) {
 5819               		.loc 1 2761 0
 5820 2174 CF93      		push r28
 5821               	.LCFI148:
 5822 2176 DF93      		push r29
 5823               	.LCFI149:
 5824               	/* prologue: function */
 5825               	/* frame size = 0 */
 5826               	/* stack size = 2 */
 5827               	.L__stack_usage = 2
2762:switcherator.c ****     statusMsg[0] = 0;
 5828               		.loc 1 2762 0
 5829 2178 1092 0000 		sts statusMsg,__zero_reg__
2763:switcherator.c ****     strcat(statusMsg, "In");
 5830               		.loc 1 2763 0
 5831 217c 60E0      		ldi r22,lo8(.LC25)
 5832 217e 70E0      		ldi r23,hi8(.LC25)
 5833 2180 80E0      		ldi r24,lo8(statusMsg)
 5834 2182 90E0      		ldi r25,hi8(statusMsg)
 5835 2184 0E94 0000 		call strcat
 5836               	.LVL409:
 5837 2188 C0E0      		ldi r28,lo8(inputs)
 5838 218a D0E0      		ldi r29,hi8(inputs)
 5839               	.LVL410:
 5840               	.L439:
2766:switcherator.c ****         if (inputs[x][0] == 255) {
 5841               		.loc 1 2766 0
 5842 218c 8881      		ld r24,Y
 5843 218e 8F3F      		cpi r24,lo8(-1)
 5844 2190 01F4      		brne .L436
2767:switcherator.c ****             strcat(statusMsg, "n");
 5845               		.loc 1 2767 0
 5846 2192 60E0      		ldi r22,lo8(.LC24)
 5847 2194 70E0      		ldi r23,hi8(.LC24)
 5848 2196 00C0      		rjmp .L441
 5849               	.L436:
2769:switcherator.c ****             strcat(statusMsg, "y");
 5850               		.loc 1 2769 0
 5851 2198 60E0      		ldi r22,lo8(.LC23)
 5852 219a 70E0      		ldi r23,hi8(.LC23)
 5853               	.L441:
 5854 219c 80E0      		ldi r24,lo8(statusMsg)
 5855 219e 90E0      		ldi r25,hi8(statusMsg)
 5856 21a0 0E94 0000 		call strcat
 5857               	.LVL411:
2772:switcherator.c ****         if (strlen(statusMsg) > 30) {
 5858               		.loc 1 2772 0
 5859 21a4 E0E0      		ldi r30,lo8(statusMsg)
 5860 21a6 F0E0      		ldi r31,hi8(statusMsg)
 5861               		0:
 5862 21a8 0190      		ld __tmp_reg__,Z+
 5863 21aa 0020      		tst __tmp_reg__
 5864 21ac 01F4      		brne 0b
 5865 21ae 3197      		sbiw r30,1
 5866 21b0 E050      		subi r30,lo8(statusMsg)
 5867 21b2 F040      		sbci r31,hi8(statusMsg)
 5868 21b4 7F97      		sbiw r30,31
 5869 21b6 00F0      		brlo .L438
2773:switcherator.c ****             sendMessage(statusMsg);
 5870               		.loc 1 2773 0
 5871 21b8 80E0      		ldi r24,lo8(statusMsg)
 5872 21ba 90E0      		ldi r25,hi8(statusMsg)
 5873 21bc 0E94 0000 		call sendMessage
 5874               	.LVL412:
2774:switcherator.c ****             statusMsg[2] = 0;
 5875               		.loc 1 2774 0
 5876 21c0 1092 0000 		sts statusMsg+2,__zero_reg__
 5877               	.L438:
 5878 21c4 2896      		adiw r28,8
2765:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 5879               		.loc 1 2765 0
 5880 21c6 80E0      		ldi r24,hi8(inputs+32)
 5881 21c8 C030      		cpi r28,lo8(inputs+32)
 5882 21ca D807      		cpc r29,r24
 5883 21cc 01F4      		brne .L439
2777:switcherator.c ****     sendMessage(statusMsg);
 5884               		.loc 1 2777 0
 5885 21ce 80E0      		ldi r24,lo8(statusMsg)
 5886 21d0 90E0      		ldi r25,hi8(statusMsg)
 5887               	/* epilogue start */
2778:switcherator.c **** }
 5888               		.loc 1 2778 0
 5889 21d2 DF91      		pop r29
 5890 21d4 CF91      		pop r28
2777:switcherator.c ****     sendMessage(statusMsg);
 5891               		.loc 1 2777 0
 5892 21d6 0C94 0000 		jmp sendMessage
 5893               	.LVL413:
 5894               	.LFE65:
 5896               		.section	.rodata.str1.1
 5897               	.LC26:
 5898 0074 5377 6900 		.string	"Swi"
 5899               		.text
 5900               	.global	switchesProgrammed
 5902               	switchesProgrammed:
 5903               	.LFB64:
2740:switcherator.c **** void switchesProgrammed(void) {
 5904               		.loc 1 2740 0
 5905 21da CF93      		push r28
 5906               	.LCFI150:
 5907 21dc DF93      		push r29
 5908               	.LCFI151:
 5909               	/* prologue: function */
 5910               	/* frame size = 0 */
 5911               	/* stack size = 2 */
 5912               	.L__stack_usage = 2
2741:switcherator.c ****     statusMsg[0] = 0;
 5913               		.loc 1 2741 0
 5914 21de 1092 0000 		sts statusMsg,__zero_reg__
2742:switcherator.c ****     strcat(statusMsg, "Swi");
 5915               		.loc 1 2742 0
 5916 21e2 60E0      		ldi r22,lo8(.LC26)
 5917 21e4 70E0      		ldi r23,hi8(.LC26)
 5918 21e6 80E0      		ldi r24,lo8(statusMsg)
 5919 21e8 90E0      		ldi r25,hi8(statusMsg)
 5920 21ea 0E94 0000 		call strcat
 5921               	.LVL414:
 5922 21ee C0E0      		ldi r28,lo8(switchStuff)
 5923 21f0 D0E0      		ldi r29,hi8(switchStuff)
 5924               	.LVL415:
 5925               	.L446:
2746:switcherator.c ****         if (switchStuff[x] == 255) {
 5926               		.loc 1 2746 0
 5927 21f2 8991      		ld r24,Y+
 5928 21f4 8F3F      		cpi r24,lo8(-1)
 5929 21f6 01F4      		brne .L443
2747:switcherator.c ****             strcat(statusMsg, "n");
 5930               		.loc 1 2747 0
 5931 21f8 60E0      		ldi r22,lo8(.LC24)
 5932 21fa 70E0      		ldi r23,hi8(.LC24)
 5933 21fc 00C0      		rjmp .L448
 5934               	.L443:
2749:switcherator.c ****             strcat(statusMsg, "y");
 5935               		.loc 1 2749 0
 5936 21fe 60E0      		ldi r22,lo8(.LC23)
 5937 2200 70E0      		ldi r23,hi8(.LC23)
 5938               	.L448:
 5939 2202 80E0      		ldi r24,lo8(statusMsg)
 5940 2204 90E0      		ldi r25,hi8(statusMsg)
 5941 2206 0E94 0000 		call strcat
 5942               	.LVL416:
2752:switcherator.c ****         if (strlen(statusMsg) > 30) {
 5943               		.loc 1 2752 0
 5944 220a E0E0      		ldi r30,lo8(statusMsg)
 5945 220c F0E0      		ldi r31,hi8(statusMsg)
 5946               		0:
 5947 220e 0190      		ld __tmp_reg__,Z+
 5948 2210 0020      		tst __tmp_reg__
 5949 2212 01F4      		brne 0b
 5950 2214 3197      		sbiw r30,1
 5951 2216 E050      		subi r30,lo8(statusMsg)
 5952 2218 F040      		sbci r31,hi8(statusMsg)
 5953 221a 7F97      		sbiw r30,31
 5954 221c 00F0      		brlo .L445
2753:switcherator.c ****             sendMessage(statusMsg);
 5955               		.loc 1 2753 0
 5956 221e 80E0      		ldi r24,lo8(statusMsg)
 5957 2220 90E0      		ldi r25,hi8(statusMsg)
 5958 2222 0E94 0000 		call sendMessage
 5959               	.LVL417:
2754:switcherator.c ****             statusMsg[3] = 0;
 5960               		.loc 1 2754 0
 5961 2226 1092 0000 		sts statusMsg+3,__zero_reg__
 5962               	.L445:
2744:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 5963               		.loc 1 2744 0
 5964 222a 80E0      		ldi r24,hi8(switchStuff+16)
 5965 222c C030      		cpi r28,lo8(switchStuff+16)
 5966 222e D807      		cpc r29,r24
 5967 2230 01F4      		brne .L446
2757:switcherator.c ****     sendMessage(statusMsg);
 5968               		.loc 1 2757 0
 5969 2232 80E0      		ldi r24,lo8(statusMsg)
 5970 2234 90E0      		ldi r25,hi8(statusMsg)
 5971               	/* epilogue start */
2758:switcherator.c **** }
 5972               		.loc 1 2758 0
 5973 2236 DF91      		pop r29
 5974 2238 CF91      		pop r28
2757:switcherator.c ****     sendMessage(statusMsg);
 5975               		.loc 1 2757 0
 5976 223a 0C94 0000 		jmp sendMessage
 5977               	.LVL418:
 5978               	.LFE64:
 5980               		.section	.rodata.str1.1
 5981               	.LC27:
 5982 0078 5072 6F67 		.string	"Progs"
 5982      7300 
 5983               		.text
 5984               	.global	programsProgrammed
 5986               	programsProgrammed:
 5987               	.LFB63:
2722:switcherator.c **** void programsProgrammed(void) {
 5988               		.loc 1 2722 0
 5989 223e CF93      		push r28
 5990               	.LCFI152:
 5991 2240 DF93      		push r29
 5992               	.LCFI153:
 5993               	/* prologue: function */
 5994               	/* frame size = 0 */
 5995               	/* stack size = 2 */
 5996               	.L__stack_usage = 2
2723:switcherator.c ****     strcat(statusMsg, "Progs");
 5997               		.loc 1 2723 0
 5998 2242 60E0      		ldi r22,lo8(.LC27)
 5999 2244 70E0      		ldi r23,hi8(.LC27)
 6000 2246 80E0      		ldi r24,lo8(statusMsg)
 6001 2248 90E0      		ldi r25,hi8(statusMsg)
 6002 224a 0E94 0000 		call strcat
 6003               	.LVL419:
 6004 224e C0E0      		ldi r28,lo8(weeklyProgram+1)
 6005 2250 D0E0      		ldi r29,hi8(weeklyProgram+1)
 6006               	.LVL420:
 6007               	.L453:
2722:switcherator.c **** void programsProgrammed(void) {
 6008               		.loc 1 2722 0
 6009 2252 FE01      		movw r30,r28
 6010 2254 3197      		sbiw r30,1
2726:switcherator.c ****         if (weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) {
 6011               		.loc 1 2726 0
 6012 2256 8081      		ld r24,Z
 6013 2258 8F3F      		cpi r24,lo8(-1)
 6014 225a 01F4      		brne .L450
2726:switcherator.c ****         if (weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) {
 6015               		.loc 1 2726 0 is_stmt 0 discriminator 1
 6016 225c 8881      		ld r24,Y
 6017 225e 8F3F      		cpi r24,lo8(-1)
 6018 2260 01F4      		brne .L450
2727:switcherator.c ****             strcat(statusMsg, "n");
 6019               		.loc 1 2727 0 is_stmt 1
 6020 2262 60E0      		ldi r22,lo8(.LC24)
 6021 2264 70E0      		ldi r23,hi8(.LC24)
 6022 2266 00C0      		rjmp .L455
 6023               	.L450:
2729:switcherator.c ****             strcat(statusMsg, "y");
 6024               		.loc 1 2729 0
 6025 2268 60E0      		ldi r22,lo8(.LC23)
 6026 226a 70E0      		ldi r23,hi8(.LC23)
 6027               	.L455:
 6028 226c 80E0      		ldi r24,lo8(statusMsg)
 6029 226e 90E0      		ldi r25,hi8(statusMsg)
 6030 2270 0E94 0000 		call strcat
 6031               	.LVL421:
2732:switcherator.c ****         if (strlen(statusMsg) > 30) {
 6032               		.loc 1 2732 0
 6033 2274 E0E0      		ldi r30,lo8(statusMsg)
 6034 2276 F0E0      		ldi r31,hi8(statusMsg)
 6035               		0:
 6036 2278 0190      		ld __tmp_reg__,Z+
 6037 227a 0020      		tst __tmp_reg__
 6038 227c 01F4      		brne 0b
 6039 227e 3197      		sbiw r30,1
 6040 2280 E050      		subi r30,lo8(statusMsg)
 6041 2282 F040      		sbci r31,hi8(statusMsg)
 6042 2284 7F97      		sbiw r30,31
 6043 2286 00F0      		brlo .L452
2733:switcherator.c ****             sendMessage(statusMsg);
 6044               		.loc 1 2733 0
 6045 2288 80E0      		ldi r24,lo8(statusMsg)
 6046 228a 90E0      		ldi r25,hi8(statusMsg)
 6047 228c 0E94 0000 		call sendMessage
 6048               	.LVL422:
2734:switcherator.c ****             statusMsg[5] = 0;
 6049               		.loc 1 2734 0
 6050 2290 1092 0000 		sts statusMsg+5,__zero_reg__
 6051               	.L452:
 6052 2294 2A96      		adiw r28,10
2725:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 6053               		.loc 1 2725 0
 6054 2296 80E0      		ldi r24,hi8(weeklyProgram+101)
 6055 2298 C030      		cpi r28,lo8(weeklyProgram+101)
 6056 229a D807      		cpc r29,r24
 6057 229c 01F4      		brne .L453
2737:switcherator.c ****     sendMessage(statusMsg);    
 6058               		.loc 1 2737 0
 6059 229e 80E0      		ldi r24,lo8(statusMsg)
 6060 22a0 90E0      		ldi r25,hi8(statusMsg)
 6061               	/* epilogue start */
2738:switcherator.c **** }
 6062               		.loc 1 2738 0
 6063 22a2 DF91      		pop r29
 6064 22a4 CF91      		pop r28
2737:switcherator.c ****     sendMessage(statusMsg);    
 6065               		.loc 1 2737 0
 6066 22a6 0C94 0000 		jmp sendMessage
 6067               	.LVL423:
 6068               	.LFE63:
 6070               		.section	.rodata.str1.1
 6071               	.LC28:
 6072 007e 5072 2C00 		.string	"Pr,"
 6073               	.LC29:
 6074 0082 2C53 772C 		.string	",Sw,"
 6074      00
 6075               	.LC30:
 6076 0087 2C49 6E2C 		.string	",In,"
 6076      00
 6077               	.LC31:
 6078 008c 2C4C 692C 		.string	",Li,"
 6078      00
 6079               	.LC32:
 6080 0091 2C43 432C 		.string	",CC,"
 6080      00
 6081               		.text
 6082               	.global	generalInformation
 6084               	generalInformation:
 6085               	.LFB62:
2658:switcherator.c **** void generalInformation(void) {
 6086               		.loc 1 2658 0
 6087               	/* prologue: function */
 6088               	/* frame size = 0 */
 6089               	/* stack size = 0 */
 6090               	.L__stack_usage = 0
2659:switcherator.c ****     statusMsg[0] = 0;
 6091               		.loc 1 2659 0
 6092 22aa 1092 0000 		sts statusMsg,__zero_reg__
2660:switcherator.c ****     strcat(statusMsg,"Pr,");
 6093               		.loc 1 2660 0
 6094 22ae 60E0      		ldi r22,lo8(.LC28)
 6095 22b0 70E0      		ldi r23,hi8(.LC28)
 6096 22b2 80E0      		ldi r24,lo8(statusMsg)
 6097 22b4 90E0      		ldi r25,hi8(statusMsg)
 6098 22b6 0E94 0000 		call strcat
 6099               	.LVL424:
 6100 22ba E0E0      		ldi r30,lo8(weeklyProgram+1)
 6101 22bc F0E0      		ldi r31,hi8(weeklyProgram+1)
2661:switcherator.c ****     int count = 0;
 6102               		.loc 1 2661 0
 6103 22be 80E0      		ldi r24,0
 6104 22c0 90E0      		ldi r25,0
 6105               	.LVL425:
 6106               	.L459:
2658:switcherator.c **** void generalInformation(void) {
 6107               		.loc 1 2658 0
 6108 22c2 DF01      		movw r26,r30
 6109 22c4 1197      		sbiw r26,1
2664:switcherator.c ****         if(weeklyProgram[x][0] < 255 || weeklyProgram[x][1] < 255) 
 6110               		.loc 1 2664 0
 6111 22c6 2C91      		ld r18,X
 6112 22c8 2F3F      		cpi r18,lo8(-1)
 6113 22ca 01F4      		brne .L457
2664:switcherator.c ****         if(weeklyProgram[x][0] < 255 || weeklyProgram[x][1] < 255) 
 6114               		.loc 1 2664 0 is_stmt 0 discriminator 1
 6115 22cc 2081      		ld r18,Z
 6116 22ce 2F3F      		cpi r18,lo8(-1)
 6117 22d0 01F0      		breq .L458
 6118               	.L457:
2665:switcherator.c ****             count++;
 6119               		.loc 1 2665 0 is_stmt 1
 6120 22d2 0196      		adiw r24,1
 6121               	.LVL426:
 6122               	.L458:
 6123 22d4 3A96      		adiw r30,10
2663:switcherator.c ****     for(x=0;x<MAX_PROGRAM;x++) {
 6124               		.loc 1 2663 0
 6125 22d6 20E0      		ldi r18,hi8(weeklyProgram+101)
 6126 22d8 E030      		cpi r30,lo8(weeklyProgram+101)
 6127 22da F207      		cpc r31,r18
 6128 22dc 01F4      		brne .L459
2667:switcherator.c ****     returnInt(count,tempLongString);
 6129               		.loc 1 2667 0
 6130 22de 60E0      		ldi r22,lo8(tempLongString)
 6131 22e0 70E0      		ldi r23,hi8(tempLongString)
 6132 22e2 0E94 0000 		call returnInt
 6133               	.LVL427:
2668:switcherator.c ****     strcat(statusMsg,tempLongString);
 6134               		.loc 1 2668 0
 6135 22e6 60E0      		ldi r22,lo8(tempLongString)
 6136 22e8 70E0      		ldi r23,hi8(tempLongString)
 6137 22ea 80E0      		ldi r24,lo8(statusMsg)
 6138 22ec 90E0      		ldi r25,hi8(statusMsg)
 6139 22ee 0E94 0000 		call strcat
 6140               	.LVL428:
2669:switcherator.c ****     strcat(statusMsg,"/");
 6141               		.loc 1 2669 0
 6142 22f2 60E0      		ldi r22,lo8(.LC3)
 6143 22f4 70E0      		ldi r23,hi8(.LC3)
 6144 22f6 80E0      		ldi r24,lo8(statusMsg)
 6145 22f8 90E0      		ldi r25,hi8(statusMsg)
 6146 22fa 0E94 0000 		call strcat
 6147               	.LVL429:
2670:switcherator.c ****     returnInt(MAX_PROGRAM,tempLongString);
 6148               		.loc 1 2670 0
 6149 22fe 60E0      		ldi r22,lo8(tempLongString)
 6150 2300 70E0      		ldi r23,hi8(tempLongString)
 6151 2302 8AE0      		ldi r24,lo8(10)
 6152 2304 90E0      		ldi r25,0
 6153 2306 0E94 0000 		call returnInt
 6154               	.LVL430:
2671:switcherator.c ****     strcat(statusMsg,tempLongString);
 6155               		.loc 1 2671 0
 6156 230a 60E0      		ldi r22,lo8(tempLongString)
 6157 230c 70E0      		ldi r23,hi8(tempLongString)
 6158 230e 80E0      		ldi r24,lo8(statusMsg)
 6159 2310 90E0      		ldi r25,hi8(statusMsg)
 6160 2312 0E94 0000 		call strcat
 6161               	.LVL431:
2672:switcherator.c ****     strcat(statusMsg,",Sw,");
 6162               		.loc 1 2672 0
 6163 2316 60E0      		ldi r22,lo8(.LC29)
 6164 2318 70E0      		ldi r23,hi8(.LC29)
 6165 231a 80E0      		ldi r24,lo8(statusMsg)
 6166 231c 90E0      		ldi r25,hi8(statusMsg)
 6167 231e 0E94 0000 		call strcat
 6168               	.LVL432:
 6169 2322 E0E0      		ldi r30,lo8(switchStuff)
 6170 2324 F0E0      		ldi r31,hi8(switchStuff)
2673:switcherator.c ****     count = 0;
 6171               		.loc 1 2673 0
 6172 2326 80E0      		ldi r24,0
 6173 2328 90E0      		ldi r25,0
 6174               	.LVL433:
 6175               	.L461:
2675:switcherator.c ****         if (switchStuff[x] < 255)
 6176               		.loc 1 2675 0
 6177 232a 2191      		ld r18,Z+
 6178 232c 2F3F      		cpi r18,lo8(-1)
 6179 232e 01F0      		breq .L460
2676:switcherator.c ****             count ++;
 6180               		.loc 1 2676 0
 6181 2330 0196      		adiw r24,1
 6182               	.LVL434:
 6183               	.L460:
2674:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 6184               		.loc 1 2674 0
 6185 2332 20E0      		ldi r18,hi8(switchStuff+16)
 6186 2334 E030      		cpi r30,lo8(switchStuff+16)
 6187 2336 F207      		cpc r31,r18
 6188 2338 01F4      		brne .L461
2678:switcherator.c ****     returnInt(count,tempLongString);
 6189               		.loc 1 2678 0
 6190 233a 60E0      		ldi r22,lo8(tempLongString)
 6191 233c 70E0      		ldi r23,hi8(tempLongString)
 6192 233e 0E94 0000 		call returnInt
 6193               	.LVL435:
2679:switcherator.c ****     strcat(statusMsg,tempLongString);
 6194               		.loc 1 2679 0
 6195 2342 60E0      		ldi r22,lo8(tempLongString)
 6196 2344 70E0      		ldi r23,hi8(tempLongString)
 6197 2346 80E0      		ldi r24,lo8(statusMsg)
 6198 2348 90E0      		ldi r25,hi8(statusMsg)
 6199 234a 0E94 0000 		call strcat
 6200               	.LVL436:
2680:switcherator.c ****     strcat(statusMsg,"/");
 6201               		.loc 1 2680 0
 6202 234e 60E0      		ldi r22,lo8(.LC3)
 6203 2350 70E0      		ldi r23,hi8(.LC3)
 6204 2352 80E0      		ldi r24,lo8(statusMsg)
 6205 2354 90E0      		ldi r25,hi8(statusMsg)
 6206 2356 0E94 0000 		call strcat
 6207               	.LVL437:
2681:switcherator.c ****     returnInt(NUM_SWITCHES,tempLongString);
 6208               		.loc 1 2681 0
 6209 235a 60E0      		ldi r22,lo8(tempLongString)
 6210 235c 70E0      		ldi r23,hi8(tempLongString)
 6211 235e 80E1      		ldi r24,lo8(16)
 6212 2360 90E0      		ldi r25,0
 6213 2362 0E94 0000 		call returnInt
 6214               	.LVL438:
2682:switcherator.c ****     strcat(statusMsg,tempLongString);
 6215               		.loc 1 2682 0
 6216 2366 60E0      		ldi r22,lo8(tempLongString)
 6217 2368 70E0      		ldi r23,hi8(tempLongString)
 6218 236a 80E0      		ldi r24,lo8(statusMsg)
 6219 236c 90E0      		ldi r25,hi8(statusMsg)
 6220 236e 0E94 0000 		call strcat
 6221               	.LVL439:
2683:switcherator.c ****     sendMessage(statusMsg);
 6222               		.loc 1 2683 0
 6223 2372 80E0      		ldi r24,lo8(statusMsg)
 6224 2374 90E0      		ldi r25,hi8(statusMsg)
 6225 2376 0E94 0000 		call sendMessage
 6226               	.LVL440:
2684:switcherator.c ****     statusMsg[0] = 0;
 6227               		.loc 1 2684 0
 6228 237a 1092 0000 		sts statusMsg,__zero_reg__
2685:switcherator.c ****     strcat(statusMsg,",In,");
 6229               		.loc 1 2685 0
 6230 237e 60E0      		ldi r22,lo8(.LC30)
 6231 2380 70E0      		ldi r23,hi8(.LC30)
 6232 2382 80E0      		ldi r24,lo8(statusMsg)
 6233 2384 90E0      		ldi r25,hi8(statusMsg)
 6234 2386 0E94 0000 		call strcat
 6235               	.LVL441:
 6236 238a E0E0      		ldi r30,lo8(inputs)
 6237 238c F0E0      		ldi r31,hi8(inputs)
2686:switcherator.c ****     count = 0;
 6238               		.loc 1 2686 0
 6239 238e 80E0      		ldi r24,0
 6240 2390 90E0      		ldi r25,0
 6241               	.LVL442:
 6242               	.L463:
2688:switcherator.c ****         if (inputs[x][0] < 255)
 6243               		.loc 1 2688 0
 6244 2392 2081      		ld r18,Z
 6245 2394 2F3F      		cpi r18,lo8(-1)
 6246 2396 01F0      		breq .L462
2689:switcherator.c ****             count ++;
 6247               		.loc 1 2689 0
 6248 2398 0196      		adiw r24,1
 6249               	.LVL443:
 6250               	.L462:
 6251 239a 3896      		adiw r30,8
2687:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 6252               		.loc 1 2687 0
 6253 239c 20E0      		ldi r18,hi8(inputs+32)
 6254 239e E030      		cpi r30,lo8(inputs+32)
 6255 23a0 F207      		cpc r31,r18
 6256 23a2 01F4      		brne .L463
2691:switcherator.c ****     returnInt(count,tempLongString);
 6257               		.loc 1 2691 0
 6258 23a4 60E0      		ldi r22,lo8(tempLongString)
 6259 23a6 70E0      		ldi r23,hi8(tempLongString)
 6260 23a8 0E94 0000 		call returnInt
 6261               	.LVL444:
2692:switcherator.c ****     strcat(statusMsg,tempLongString);
 6262               		.loc 1 2692 0
 6263 23ac 60E0      		ldi r22,lo8(tempLongString)
 6264 23ae 70E0      		ldi r23,hi8(tempLongString)
 6265 23b0 80E0      		ldi r24,lo8(statusMsg)
 6266 23b2 90E0      		ldi r25,hi8(statusMsg)
 6267 23b4 0E94 0000 		call strcat
 6268               	.LVL445:
2693:switcherator.c ****     strcat(statusMsg,"/");
 6269               		.loc 1 2693 0
 6270 23b8 60E0      		ldi r22,lo8(.LC3)
 6271 23ba 70E0      		ldi r23,hi8(.LC3)
 6272 23bc 80E0      		ldi r24,lo8(statusMsg)
 6273 23be 90E0      		ldi r25,hi8(statusMsg)
 6274 23c0 0E94 0000 		call strcat
 6275               	.LVL446:
2694:switcherator.c ****     returnInt(NUM_INPUTS,tempLongString);
 6276               		.loc 1 2694 0
 6277 23c4 60E0      		ldi r22,lo8(tempLongString)
 6278 23c6 70E0      		ldi r23,hi8(tempLongString)
 6279 23c8 84E0      		ldi r24,lo8(4)
 6280 23ca 90E0      		ldi r25,0
 6281 23cc 0E94 0000 		call returnInt
 6282               	.LVL447:
2695:switcherator.c ****     strcat(statusMsg,tempLongString);
 6283               		.loc 1 2695 0
 6284 23d0 60E0      		ldi r22,lo8(tempLongString)
 6285 23d2 70E0      		ldi r23,hi8(tempLongString)
 6286 23d4 80E0      		ldi r24,lo8(statusMsg)
 6287 23d6 90E0      		ldi r25,hi8(statusMsg)
 6288 23d8 0E94 0000 		call strcat
 6289               	.LVL448:
2696:switcherator.c ****     strcat(statusMsg,",Li,");
 6290               		.loc 1 2696 0
 6291 23dc 60E0      		ldi r22,lo8(.LC31)
 6292 23de 70E0      		ldi r23,hi8(.LC31)
 6293 23e0 80E0      		ldi r24,lo8(statusMsg)
 6294 23e2 90E0      		ldi r25,hi8(statusMsg)
 6295 23e4 0E94 0000 		call strcat
 6296               	.LVL449:
 6297 23e8 E0E0      		ldi r30,lo8(inputs+2)
 6298 23ea F0E0      		ldi r31,hi8(inputs+2)
2697:switcherator.c ****     count = 0;
 6299               		.loc 1 2697 0
 6300 23ec 80E0      		ldi r24,0
 6301 23ee 90E0      		ldi r25,0
 6302               	.LVL450:
 6303               	.L465:
2699:switcherator.c ****         if (inputs[x][2] > 0)
 6304               		.loc 1 2699 0
 6305 23f0 2081      		ld r18,Z
 6306 23f2 2111      		cpse r18,__zero_reg__
2700:switcherator.c ****             count ++;
 6307               		.loc 1 2700 0
 6308 23f4 0196      		adiw r24,1
 6309               	.LVL451:
 6310               	.L464:
 6311 23f6 3896      		adiw r30,8
2698:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++) {
 6312               		.loc 1 2698 0
 6313 23f8 20E0      		ldi r18,hi8(inputs+34)
 6314 23fa E030      		cpi r30,lo8(inputs+34)
 6315 23fc F207      		cpc r31,r18
 6316 23fe 01F4      		brne .L465
2702:switcherator.c ****     returnInt(count,tempLongString);
 6317               		.loc 1 2702 0
 6318 2400 60E0      		ldi r22,lo8(tempLongString)
 6319 2402 70E0      		ldi r23,hi8(tempLongString)
 6320 2404 0E94 0000 		call returnInt
 6321               	.LVL452:
2703:switcherator.c ****     strcat(statusMsg,tempLongString);
 6322               		.loc 1 2703 0
 6323 2408 60E0      		ldi r22,lo8(tempLongString)
 6324 240a 70E0      		ldi r23,hi8(tempLongString)
 6325 240c 80E0      		ldi r24,lo8(statusMsg)
 6326 240e 90E0      		ldi r25,hi8(statusMsg)
 6327 2410 0E94 0000 		call strcat
 6328               	.LVL453:
2704:switcherator.c ****     strcat(statusMsg,"/");
 6329               		.loc 1 2704 0
 6330 2414 60E0      		ldi r22,lo8(.LC3)
 6331 2416 70E0      		ldi r23,hi8(.LC3)
 6332 2418 80E0      		ldi r24,lo8(statusMsg)
 6333 241a 90E0      		ldi r25,hi8(statusMsg)
 6334 241c 0E94 0000 		call strcat
 6335               	.LVL454:
2705:switcherator.c ****     returnInt(NUM_LIMITS,tempLongString);
 6336               		.loc 1 2705 0
 6337 2420 60E0      		ldi r22,lo8(tempLongString)
 6338 2422 70E0      		ldi r23,hi8(tempLongString)
 6339 2424 84E0      		ldi r24,lo8(4)
 6340 2426 90E0      		ldi r25,0
 6341 2428 0E94 0000 		call returnInt
 6342               	.LVL455:
2706:switcherator.c ****     strcat(statusMsg,tempLongString);
 6343               		.loc 1 2706 0
 6344 242c 60E0      		ldi r22,lo8(tempLongString)
 6345 242e 70E0      		ldi r23,hi8(tempLongString)
 6346 2430 80E0      		ldi r24,lo8(statusMsg)
 6347 2432 90E0      		ldi r25,hi8(statusMsg)
 6348 2434 0E94 0000 		call strcat
 6349               	.LVL456:
2707:switcherator.c ****     strcat(statusMsg,",CC,");
 6350               		.loc 1 2707 0
 6351 2438 60E0      		ldi r22,lo8(.LC32)
 6352 243a 70E0      		ldi r23,hi8(.LC32)
 6353 243c 80E0      		ldi r24,lo8(statusMsg)
 6354 243e 90E0      		ldi r25,hi8(statusMsg)
 6355 2440 0E94 0000 		call strcat
 6356               	.LVL457:
 6357 2444 E0E0      		ldi r30,lo8(colorChanges+2)
 6358 2446 F0E0      		ldi r31,hi8(colorChanges+2)
2708:switcherator.c ****     count = 0;
 6359               		.loc 1 2708 0
 6360 2448 80E0      		ldi r24,0
 6361 244a 90E0      		ldi r25,0
 6362               	.LVL458:
 6363               	.L468:
2658:switcherator.c **** void generalInformation(void) {
 6364               		.loc 1 2658 0
 6365 244c DF01      		movw r26,r30
 6366 244e 1297      		sbiw r26,2
2710:switcherator.c ****         if (colorChanges[x][0] != 0 || colorChanges[x][1] != 1 || colorChanges[x][2] != 0)
 6367               		.loc 1 2710 0
 6368 2450 2C91      		ld r18,X
 6369 2452 2111      		cpse r18,__zero_reg__
 6370 2454 00C0      		rjmp .L466
2658:switcherator.c **** void generalInformation(void) {
 6371               		.loc 1 2658 0 discriminator 1
 6372 2456 DF01      		movw r26,r30
 6373 2458 1197      		sbiw r26,1
2710:switcherator.c ****         if (colorChanges[x][0] != 0 || colorChanges[x][1] != 1 || colorChanges[x][2] != 0)
 6374               		.loc 1 2710 0 discriminator 1
 6375 245a 2C91      		ld r18,X
 6376 245c 2130      		cpi r18,lo8(1)
 6377 245e 01F4      		brne .L466
 6378 2460 2081      		ld r18,Z
 6379 2462 2111      		cpse r18,__zero_reg__
 6380               	.L466:
2711:switcherator.c ****             count ++;
 6381               		.loc 1 2711 0
 6382 2464 0196      		adiw r24,1
 6383               	.LVL459:
 6384               	.L467:
 6385 2466 3396      		adiw r30,3
2709:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 6386               		.loc 1 2709 0
 6387 2468 20E0      		ldi r18,hi8(colorChanges+20)
 6388 246a E030      		cpi r30,lo8(colorChanges+20)
 6389 246c F207      		cpc r31,r18
 6390 246e 01F4      		brne .L468
2713:switcherator.c ****     returnInt(count,tempLongString);
 6391               		.loc 1 2713 0
 6392 2470 60E0      		ldi r22,lo8(tempLongString)
 6393 2472 70E0      		ldi r23,hi8(tempLongString)
 6394 2474 0E94 0000 		call returnInt
 6395               	.LVL460:
2714:switcherator.c ****     strcat(statusMsg,tempLongString);
 6396               		.loc 1 2714 0
 6397 2478 60E0      		ldi r22,lo8(tempLongString)
 6398 247a 70E0      		ldi r23,hi8(tempLongString)
 6399 247c 80E0      		ldi r24,lo8(statusMsg)
 6400 247e 90E0      		ldi r25,hi8(statusMsg)
 6401 2480 0E94 0000 		call strcat
 6402               	.LVL461:
2715:switcherator.c ****     strcat(statusMsg,"/");
 6403               		.loc 1 2715 0
 6404 2484 60E0      		ldi r22,lo8(.LC3)
 6405 2486 70E0      		ldi r23,hi8(.LC3)
 6406 2488 80E0      		ldi r24,lo8(statusMsg)
 6407 248a 90E0      		ldi r25,hi8(statusMsg)
 6408 248c 0E94 0000 		call strcat
 6409               	.LVL462:
2716:switcherator.c ****     returnInt(NUM_COLOR_CHANGES,tempLongString);
 6410               		.loc 1 2716 0
 6411 2490 60E0      		ldi r22,lo8(tempLongString)
 6412 2492 70E0      		ldi r23,hi8(tempLongString)
 6413 2494 86E0      		ldi r24,lo8(6)
 6414 2496 90E0      		ldi r25,0
 6415 2498 0E94 0000 		call returnInt
 6416               	.LVL463:
2717:switcherator.c ****     strcat(statusMsg,tempLongString);
 6417               		.loc 1 2717 0
 6418 249c 60E0      		ldi r22,lo8(tempLongString)
 6419 249e 70E0      		ldi r23,hi8(tempLongString)
 6420 24a0 80E0      		ldi r24,lo8(statusMsg)
 6421 24a2 90E0      		ldi r25,hi8(statusMsg)
 6422 24a4 0E94 0000 		call strcat
 6423               	.LVL464:
2718:switcherator.c ****     sendMessage(statusMsg);
 6424               		.loc 1 2718 0
 6425 24a8 80E0      		ldi r24,lo8(statusMsg)
 6426 24aa 90E0      		ldi r25,hi8(statusMsg)
 6427 24ac 0C94 0000 		jmp sendMessage
 6428               	.LVL465:
 6429               	.LFE62:
 6431               		.section	.rodata.str1.1
 6432               	.LC33:
 6433 0096 2054 3A78 		.string	" T:xx/xx/xxxx xx:xx:xx"
 6433      782F 7878 
 6433      2F78 7878 
 6433      7820 7878 
 6433      3A78 783A 
 6434               	.LC34:
 6435 00ad 2054 3A00 		.string	" T:"
 6436               		.text
 6437               	.global	generalStatus
 6439               	generalStatus:
 6440               	.LFB61:
2618:switcherator.c **** void generalStatus(char * commandReceived) {
 6441               		.loc 1 2618 0
 6442               	.LVL466:
 6443 24b0 CF93      		push r28
 6444               	.LCFI154:
 6445 24b2 DF93      		push r29
 6446               	.LCFI155:
 6447               	/* prologue: function */
 6448               	/* frame size = 0 */
 6449               	/* stack size = 2 */
 6450               	.L__stack_usage = 2
 6451 24b4 EC01      		movw r28,r24
2619:switcherator.c ****     statusMsg[0] = 0;
 6452               		.loc 1 2619 0
 6453 24b6 1092 0000 		sts statusMsg,__zero_reg__
2620:switcherator.c ****     tempIntString[0] = commandReceived[2];
 6454               		.loc 1 2620 0
 6455 24ba 8A81      		ldd r24,Y+2
 6456               	.LVL467:
 6457 24bc 8093 0000 		sts tempIntString,r24
2621:switcherator.c ****     tempIntString[1] = commandReceived[3];
 6458               		.loc 1 2621 0
 6459 24c0 8B81      		ldd r24,Y+3
 6460 24c2 8093 0000 		sts tempIntString+1,r24
2624:switcherator.c ****     if (panicMyClockIsNotSet == 1) {
 6461               		.loc 1 2624 0
 6462 24c6 8091 0000 		lds r24,panicMyClockIsNotSet
 6463 24ca 8130      		cpi r24,lo8(1)
 6464 24cc 01F4      		brne .L490
2625:switcherator.c ****         strcat(statusMsg, " T:xx/xx/xxxx xx:xx:xx");
 6465               		.loc 1 2625 0
 6466 24ce 60E0      		ldi r22,lo8(.LC33)
 6467 24d0 70E0      		ldi r23,hi8(.LC33)
 6468 24d2 00C0      		rjmp .L493
 6469               	.L490:
2627:switcherator.c ****         strcat(statusMsg, " T:");
 6470               		.loc 1 2627 0
 6471 24d4 60E0      		ldi r22,lo8(.LC34)
 6472 24d6 70E0      		ldi r23,hi8(.LC34)
 6473 24d8 80E0      		ldi r24,lo8(statusMsg)
 6474 24da 90E0      		ldi r25,hi8(statusMsg)
 6475 24dc 0E94 0000 		call strcat
 6476               	.LVL468:
2628:switcherator.c ****         returnInt(globalMonth, tempLongString);
 6477               		.loc 1 2628 0
 6478 24e0 60E0      		ldi r22,lo8(tempLongString)
 6479 24e2 70E0      		ldi r23,hi8(tempLongString)
 6480 24e4 8091 0000 		lds r24,globalMonth
 6481 24e8 9091 0000 		lds r25,globalMonth+1
 6482 24ec 0E94 0000 		call returnInt
 6483               	.LVL469:
2629:switcherator.c ****         strcat(statusMsg, tempLongString);
 6484               		.loc 1 2629 0
 6485 24f0 60E0      		ldi r22,lo8(tempLongString)
 6486 24f2 70E0      		ldi r23,hi8(tempLongString)
 6487 24f4 80E0      		ldi r24,lo8(statusMsg)
 6488 24f6 90E0      		ldi r25,hi8(statusMsg)
 6489 24f8 0E94 0000 		call strcat
 6490               	.LVL470:
2630:switcherator.c ****         strcat(statusMsg, "/");
 6491               		.loc 1 2630 0
 6492 24fc 60E0      		ldi r22,lo8(.LC3)
 6493 24fe 70E0      		ldi r23,hi8(.LC3)
 6494 2500 80E0      		ldi r24,lo8(statusMsg)
 6495 2502 90E0      		ldi r25,hi8(statusMsg)
 6496 2504 0E94 0000 		call strcat
 6497               	.LVL471:
2631:switcherator.c ****         returnInt(globalDay, tempLongString);
 6498               		.loc 1 2631 0
 6499 2508 60E0      		ldi r22,lo8(tempLongString)
 6500 250a 70E0      		ldi r23,hi8(tempLongString)
 6501 250c 8091 0000 		lds r24,globalDay
 6502 2510 9091 0000 		lds r25,globalDay+1
 6503 2514 0E94 0000 		call returnInt
 6504               	.LVL472:
2632:switcherator.c ****         strcat(statusMsg, tempLongString);
 6505               		.loc 1 2632 0
 6506 2518 60E0      		ldi r22,lo8(tempLongString)
 6507 251a 70E0      		ldi r23,hi8(tempLongString)
 6508 251c 80E0      		ldi r24,lo8(statusMsg)
 6509 251e 90E0      		ldi r25,hi8(statusMsg)
 6510 2520 0E94 0000 		call strcat
 6511               	.LVL473:
2633:switcherator.c ****         strcat(statusMsg, "/");
 6512               		.loc 1 2633 0
 6513 2524 60E0      		ldi r22,lo8(.LC3)
 6514 2526 70E0      		ldi r23,hi8(.LC3)
 6515 2528 80E0      		ldi r24,lo8(statusMsg)
 6516 252a 90E0      		ldi r25,hi8(statusMsg)
 6517 252c 0E94 0000 		call strcat
 6518               	.LVL474:
2634:switcherator.c ****         returnInt(globalYear, tempLongString);
 6519               		.loc 1 2634 0
 6520 2530 60E0      		ldi r22,lo8(tempLongString)
 6521 2532 70E0      		ldi r23,hi8(tempLongString)
 6522 2534 8091 0000 		lds r24,globalYear
 6523 2538 9091 0000 		lds r25,globalYear+1
 6524 253c 0E94 0000 		call returnInt
 6525               	.LVL475:
2635:switcherator.c ****         strcat(statusMsg, tempLongString);
 6526               		.loc 1 2635 0
 6527 2540 60E0      		ldi r22,lo8(tempLongString)
 6528 2542 70E0      		ldi r23,hi8(tempLongString)
 6529 2544 80E0      		ldi r24,lo8(statusMsg)
 6530 2546 90E0      		ldi r25,hi8(statusMsg)
 6531 2548 0E94 0000 		call strcat
 6532               	.LVL476:
2636:switcherator.c ****         strcat(statusMsg, " ");
 6533               		.loc 1 2636 0
 6534 254c 60E0      		ldi r22,lo8(.LC2)
 6535 254e 70E0      		ldi r23,hi8(.LC2)
 6536 2550 80E0      		ldi r24,lo8(statusMsg)
 6537 2552 90E0      		ldi r25,hi8(statusMsg)
 6538 2554 0E94 0000 		call strcat
 6539               	.LVL477:
2637:switcherator.c ****         returnInt(globalHour, tempLongString);
 6540               		.loc 1 2637 0
 6541 2558 60E0      		ldi r22,lo8(tempLongString)
 6542 255a 70E0      		ldi r23,hi8(tempLongString)
 6543 255c 8091 0000 		lds r24,globalHour
 6544 2560 9091 0000 		lds r25,globalHour+1
 6545 2564 0E94 0000 		call returnInt
 6546               	.LVL478:
2638:switcherator.c ****         strcat(statusMsg, tempLongString);
 6547               		.loc 1 2638 0
 6548 2568 60E0      		ldi r22,lo8(tempLongString)
 6549 256a 70E0      		ldi r23,hi8(tempLongString)
 6550 256c 80E0      		ldi r24,lo8(statusMsg)
 6551 256e 90E0      		ldi r25,hi8(statusMsg)
 6552 2570 0E94 0000 		call strcat
 6553               	.LVL479:
2639:switcherator.c ****         strcat(statusMsg, ":");
 6554               		.loc 1 2639 0
 6555 2574 60E0      		ldi r22,lo8(.LC4)
 6556 2576 70E0      		ldi r23,hi8(.LC4)
 6557 2578 80E0      		ldi r24,lo8(statusMsg)
 6558 257a 90E0      		ldi r25,hi8(statusMsg)
 6559 257c 0E94 0000 		call strcat
 6560               	.LVL480:
2640:switcherator.c ****         returnInt(globalMinute, tempLongString);
 6561               		.loc 1 2640 0
 6562 2580 60E0      		ldi r22,lo8(tempLongString)
 6563 2582 70E0      		ldi r23,hi8(tempLongString)
 6564 2584 8091 0000 		lds r24,globalMinute
 6565 2588 9091 0000 		lds r25,globalMinute+1
 6566 258c 0E94 0000 		call returnInt
 6567               	.LVL481:
2641:switcherator.c ****         strcat(statusMsg, tempLongString);
 6568               		.loc 1 2641 0
 6569 2590 60E0      		ldi r22,lo8(tempLongString)
 6570 2592 70E0      		ldi r23,hi8(tempLongString)
 6571 2594 80E0      		ldi r24,lo8(statusMsg)
 6572 2596 90E0      		ldi r25,hi8(statusMsg)
 6573 2598 0E94 0000 		call strcat
 6574               	.LVL482:
2642:switcherator.c ****         strcat(statusMsg, ":");
 6575               		.loc 1 2642 0
 6576 259c 60E0      		ldi r22,lo8(.LC4)
 6577 259e 70E0      		ldi r23,hi8(.LC4)
 6578 25a0 80E0      		ldi r24,lo8(statusMsg)
 6579 25a2 90E0      		ldi r25,hi8(statusMsg)
 6580 25a4 0E94 0000 		call strcat
 6581               	.LVL483:
2643:switcherator.c ****         returnInt(globalSecond, tempLongString);
 6582               		.loc 1 2643 0
 6583 25a8 60E0      		ldi r22,lo8(tempLongString)
 6584 25aa 70E0      		ldi r23,hi8(tempLongString)
 6585 25ac 8091 0000 		lds r24,globalSecond
 6586 25b0 9091 0000 		lds r25,globalSecond+1
 6587 25b4 0E94 0000 		call returnInt
 6588               	.LVL484:
2644:switcherator.c ****         strcat(statusMsg, tempLongString);
 6589               		.loc 1 2644 0
 6590 25b8 60E0      		ldi r22,lo8(tempLongString)
 6591 25ba 70E0      		ldi r23,hi8(tempLongString)
 6592               	.L493:
 6593 25bc 80E0      		ldi r24,lo8(statusMsg)
 6594 25be 90E0      		ldi r25,hi8(statusMsg)
 6595 25c0 0E94 0000 		call strcat
 6596               	.LVL485:
2646:switcherator.c ****     sendMessage(statusMsg);
 6597               		.loc 1 2646 0
 6598 25c4 80E0      		ldi r24,lo8(statusMsg)
 6599 25c6 90E0      		ldi r25,hi8(statusMsg)
 6600 25c8 0E94 0000 		call sendMessage
 6601               	.LVL486:
2647:switcherator.c ****     statusMsg[0] = 0;
 6602               		.loc 1 2647 0
 6603 25cc 1092 0000 		sts statusMsg,__zero_reg__
2648:switcherator.c ****     if (commandReceived[2] == 'q')
 6604               		.loc 1 2648 0
 6605 25d0 8A81      		ldd r24,Y+2
 6606 25d2 8137      		cpi r24,lo8(113)
 6607 25d4 01F0      		breq .L489
2651:switcherator.c ****     programsProgrammed();
 6608               		.loc 1 2651 0
 6609 25d6 0E94 0000 		call programsProgrammed
 6610               	.LVL487:
2652:switcherator.c ****     switchesProgrammed();
 6611               		.loc 1 2652 0
 6612 25da 0E94 0000 		call switchesProgrammed
 6613               	.LVL488:
2653:switcherator.c ****     inputsProgrammed();
 6614               		.loc 1 2653 0
 6615 25de 0E94 0000 		call inputsProgrammed
 6616               	.LVL489:
 6617               	/* epilogue start */
2655:switcherator.c **** }
 6618               		.loc 1 2655 0
 6619 25e2 DF91      		pop r29
 6620 25e4 CF91      		pop r28
 6621               	.LVL490:
2654:switcherator.c ****     switchesOn();
 6622               		.loc 1 2654 0
 6623 25e6 0C94 0000 		jmp switchesOn
 6624               	.LVL491:
 6625               	.L489:
 6626               	/* epilogue start */
2655:switcherator.c **** }
 6627               		.loc 1 2655 0
 6628 25ea DF91      		pop r29
 6629 25ec CF91      		pop r28
 6630               	.LVL492:
 6631 25ee 0895      		ret
 6632               	.LFE61:
 6634               		.section	.rodata.str1.1
 6635               	.LC35:
 6636 00b1 5023 00   		.string	"P#"
 6637               	.LC36:
 6638 00b4 626C 616E 		.string	"blank."
 6638      6B2E 00
 6639               	.LC37:
 6640 00bb 5072 6F67 		.string	"Prog#"
 6640      2300 
 6641               	.LC38:
 6642 00c1 533A 2D00 		.string	"S:-"
 6643               	.LC39:
 6644 00c5 5300      		.string	"S"
 6645               	.LC40:
 6646 00c7 543A 00   		.string	"T:"
 6647               	.LC41:
 6648 00ca 2044 7572 		.string	" Dur:"
 6648      3A00 
 6649               	.LC42:
 6650 00d0 4461 7973 		.string	"Days:"
 6650      3A00 
 6651               	.LC43:
 6652 00d6 2D2D 2D2D 		.string	"-------"
 6652      2D2D 2D00 
 6653               	.LC44:
 6654 00de 2D00      		.string	"-"
 6655               	.LC45:
 6656 00e0 4D00      		.string	"M"
 6657               	.LC46:
 6658 00e2 5400      		.string	"T"
 6659               	.LC47:
 6660 00e4 5700      		.string	"W"
 6661               	.LC48:
 6662 00e6 4600      		.string	"F"
 6663               		.text
 6664               	.global	programDisplay
 6666               	programDisplay:
 6667               	.LFB37:
1481:switcherator.c **** void programDisplay(char * commandReceived) {
 6668               		.loc 1 1481 0
 6669               	.LVL493:
 6670 25f0 AF92      		push r10
 6671               	.LCFI156:
 6672 25f2 BF92      		push r11
 6673               	.LCFI157:
 6674 25f4 CF92      		push r12
 6675               	.LCFI158:
 6676 25f6 DF92      		push r13
 6677               	.LCFI159:
 6678 25f8 EF92      		push r14
 6679               	.LCFI160:
 6680 25fa FF92      		push r15
 6681               	.LCFI161:
 6682 25fc 0F93      		push r16
 6683               	.LCFI162:
 6684 25fe 1F93      		push r17
 6685               	.LCFI163:
 6686 2600 CF93      		push r28
 6687               	.LCFI164:
 6688 2602 DF93      		push r29
 6689               	.LCFI165:
 6690 2604 CDB7      		in r28,__SP_L__
 6691 2606 DEB7      		in r29,__SP_H__
 6692               	.LCFI166:
 6693 2608 6097      		sbiw r28,16
 6694               	.LCFI167:
 6695 260a 0FB6      		in __tmp_reg__,__SREG__
 6696 260c F894      		cli
 6697 260e DEBF      		out __SP_H__,r29
 6698 2610 0FBE      		out __SREG__,__tmp_reg__
 6699 2612 CDBF      		out __SP_L__,r28
 6700               	/* prologue: function */
 6701               	/* frame size = 16 */
 6702               	/* stack size = 26 */
 6703               	.L__stack_usage = 26
 6704               	.LVL494:
1484:switcherator.c ****     tempIntString[0] = commandReceived[3];
 6705               		.loc 1 1484 0
 6706 2614 FC01      		movw r30,r24
 6707 2616 2381      		ldd r18,Z+3
 6708 2618 2093 0000 		sts tempIntString,r18
1485:switcherator.c ****     tempIntString[1] = commandReceived[4];
 6709               		.loc 1 1485 0
 6710 261c 8481      		ldd r24,Z+4
 6711               	.LVL495:
 6712 261e 8093 0000 		sts tempIntString+1,r24
1486:switcherator.c ****     programNumber = atoi(tempIntString);
 6713               		.loc 1 1486 0
 6714 2622 80E0      		ldi r24,lo8(tempIntString)
 6715 2624 90E0      		ldi r25,hi8(tempIntString)
 6716 2626 0E94 0000 		call atoi
 6717               	.LVL496:
 6718 262a 8C01      		movw r16,r24
 6719               	.LVL497:
1487:switcherator.c ****     statusMsg[0] = 0;
 6720               		.loc 1 1487 0
 6721 262c 1092 0000 		sts statusMsg,__zero_reg__
1488:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 6722               		.loc 1 1488 0
 6723 2630 8AE0      		ldi r24,lo8(10)
 6724 2632 809F      		mul r24,r16
 6725 2634 F001      		movw r30,r0
 6726 2636 819F      		mul r24,r17
 6727 2638 F00D      		add r31,r0
 6728 263a 1124      		clr __zero_reg__
 6729 263c E050      		subi r30,lo8(-(weeklyProgram))
 6730 263e F040      		sbci r31,hi8(-(weeklyProgram))
 6731 2640 8081      		ld r24,Z
 6732 2642 8F3F      		cpi r24,lo8(-1)
 6733 2644 01F4      		brne .L495
1488:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 6734               		.loc 1 1488 0 is_stmt 0 discriminator 1
 6735 2646 8181      		ldd r24,Z+1
 6736 2648 8F3F      		cpi r24,lo8(-1)
 6737 264a 01F4      		brne .L495
1489:switcherator.c ****         strcat(statusMsg, "P#");
 6738               		.loc 1 1489 0 is_stmt 1
 6739 264c 60E0      		ldi r22,lo8(.LC35)
 6740 264e 70E0      		ldi r23,hi8(.LC35)
 6741 2650 80E0      		ldi r24,lo8(statusMsg)
 6742 2652 90E0      		ldi r25,hi8(statusMsg)
 6743 2654 0E94 0000 		call strcat
 6744               	.LVL498:
1490:switcherator.c ****         returnInt(programNumber, tempIntString);
 6745               		.loc 1 1490 0
 6746 2658 60E0      		ldi r22,lo8(tempIntString)
 6747 265a 70E0      		ldi r23,hi8(tempIntString)
 6748 265c C801      		movw r24,r16
 6749 265e 0E94 0000 		call returnInt
 6750               	.LVL499:
1491:switcherator.c ****         strcat(statusMsg, tempIntString);
 6751               		.loc 1 1491 0
 6752 2662 60E0      		ldi r22,lo8(tempIntString)
 6753 2664 70E0      		ldi r23,hi8(tempIntString)
 6754 2666 80E0      		ldi r24,lo8(statusMsg)
 6755 2668 90E0      		ldi r25,hi8(statusMsg)
 6756 266a 0E94 0000 		call strcat
 6757               	.LVL500:
1492:switcherator.c ****         strcat(statusMsg, "blank.");
 6758               		.loc 1 1492 0
 6759 266e 60E0      		ldi r22,lo8(.LC36)
 6760 2670 70E0      		ldi r23,hi8(.LC36)
 6761 2672 00C0      		rjmp .L523
 6762               	.L495:
1497:switcherator.c ****     switches[0] = 0;
 6763               		.loc 1 1497 0
 6764 2674 1982      		std Y+1,__zero_reg__
 6765               	.LVL501:
1499:switcherator.c ****     switchCount = programGetSwitches(programNumber, switches);
 6766               		.loc 1 1499 0
 6767 2676 BE01      		movw r22,r28
 6768 2678 6F5F      		subi r22,-1
 6769 267a 7F4F      		sbci r23,-1
 6770 267c C801      		movw r24,r16
 6771 267e 0E94 0000 		call programGetSwitches
 6772               	.LVL502:
 6773 2682 6C01      		movw r12,r24
 6774               	.LVL503:
1500:switcherator.c ****     statusMsg[0] = 0;
 6775               		.loc 1 1500 0
 6776 2684 1092 0000 		sts statusMsg,__zero_reg__
1501:switcherator.c ****     strcat(statusMsg, "Prog#");
 6777               		.loc 1 1501 0
 6778 2688 60E0      		ldi r22,lo8(.LC37)
 6779 268a 70E0      		ldi r23,hi8(.LC37)
 6780 268c 80E0      		ldi r24,lo8(statusMsg)
 6781 268e 90E0      		ldi r25,hi8(statusMsg)
 6782 2690 0E94 0000 		call strcat
 6783               	.LVL504:
1502:switcherator.c ****     itoa(programNumber, tempIntString, 10);
 6784               		.loc 1 1502 0
 6785 2694 4AE0      		ldi r20,lo8(10)
 6786 2696 50E0      		ldi r21,0
 6787 2698 60E0      		ldi r22,lo8(tempIntString)
 6788 269a 70E0      		ldi r23,hi8(tempIntString)
 6789 269c C801      		movw r24,r16
 6790 269e 0E94 0000 		call itoa
 6791               	.LVL505:
1503:switcherator.c ****     strcat(statusMsg, tempIntString);
 6792               		.loc 1 1503 0
 6793 26a2 60E0      		ldi r22,lo8(tempIntString)
 6794 26a4 70E0      		ldi r23,hi8(tempIntString)
 6795 26a6 80E0      		ldi r24,lo8(statusMsg)
 6796 26a8 90E0      		ldi r25,hi8(statusMsg)
 6797 26aa 0E94 0000 		call strcat
 6798               	.LVL506:
1504:switcherator.c ****     if (switchCount == 0) {
 6799               		.loc 1 1504 0
 6800 26ae C114      		cp r12,__zero_reg__
 6801 26b0 D104      		cpc r13,__zero_reg__
 6802 26b2 01F4      		brne .L497
1505:switcherator.c ****         strcat(switches, "S:-");
 6803               		.loc 1 1505 0
 6804 26b4 60E0      		ldi r22,lo8(.LC38)
 6805 26b6 70E0      		ldi r23,hi8(.LC38)
 6806 26b8 CE01      		movw r24,r28
 6807 26ba 0196      		adiw r24,1
 6808 26bc 0E94 0000 		call strcat
 6809               	.LVL507:
 6810 26c0 00C0      		rjmp .L498
 6811               	.L497:
 6812               	.LVL508:
 6813               	.LBB27:
1508:switcherator.c ****         strcat(statusMsg, "S");
 6814               		.loc 1 1508 0
 6815 26c2 60E0      		ldi r22,lo8(.LC39)
 6816 26c4 70E0      		ldi r23,hi8(.LC39)
 6817 26c6 80E0      		ldi r24,lo8(statusMsg)
 6818 26c8 90E0      		ldi r25,hi8(statusMsg)
 6819 26ca 0E94 0000 		call strcat
 6820               	.LVL509:
 6821 26ce EE24      		clr r14
 6822 26d0 E394      		inc r14
 6823 26d2 F12C      		mov r15,__zero_reg__
 6824 26d4 EC0E      		add r14,r28
 6825 26d6 FD1E      		adc r15,r29
1481:switcherator.c **** void programDisplay(char * commandReceived) {
 6826               		.loc 1 1481 0
 6827 26d8 5701      		movw r10,r14
1509:switcherator.c ****         for (x = 0; x < switchCount; x++) {
 6828               		.loc 1 1509 0
 6829 26da 00C0      		rjmp .L499
 6830               	.LVL510:
 6831               	.L500:
1510:switcherator.c ****             strcat(statusMsg, ":");
 6832               		.loc 1 1510 0 discriminator 2
 6833 26dc 60E0      		ldi r22,lo8(.LC4)
 6834 26de 70E0      		ldi r23,hi8(.LC4)
 6835 26e0 80E0      		ldi r24,lo8(statusMsg)
 6836 26e2 90E0      		ldi r25,hi8(statusMsg)
 6837 26e4 0E94 0000 		call strcat
 6838               	.LVL511:
1512:switcherator.c ****             itoa(temp, tempIntString, 10);
 6839               		.loc 1 1512 0 discriminator 2
 6840 26e8 4AE0      		ldi r20,lo8(10)
 6841 26ea 50E0      		ldi r21,0
 6842 26ec 60E0      		ldi r22,lo8(tempIntString)
 6843 26ee 70E0      		ldi r23,hi8(tempIntString)
 6844 26f0 F701      		movw r30,r14
 6845 26f2 8191      		ld r24,Z+
 6846 26f4 7F01      		movw r14,r30
 6847               	.LVL512:
 6848 26f6 90E0      		ldi r25,0
 6849 26f8 0E94 0000 		call itoa
 6850               	.LVL513:
1513:switcherator.c ****             strcat(statusMsg, tempIntString);
 6851               		.loc 1 1513 0 discriminator 2
 6852 26fc 60E0      		ldi r22,lo8(tempIntString)
 6853 26fe 70E0      		ldi r23,hi8(tempIntString)
 6854 2700 80E0      		ldi r24,lo8(statusMsg)
 6855 2702 90E0      		ldi r25,hi8(statusMsg)
 6856 2704 0E94 0000 		call strcat
 6857               	.LVL514:
 6858               	.L499:
1481:switcherator.c **** void programDisplay(char * commandReceived) {
 6859               		.loc 1 1481 0 discriminator 1
 6860 2708 C701      		movw r24,r14
 6861 270a 8A19      		sub r24,r10
 6862 270c 9B09      		sbc r25,r11
1509:switcherator.c ****         for (x = 0; x < switchCount; x++) {
 6863               		.loc 1 1509 0 discriminator 1
 6864 270e 8C15      		cp r24,r12
 6865 2710 9D05      		cpc r25,r13
 6866 2712 04F0      		brlt .L500
 6867               	.L498:
 6868               	.LBE27:
1516:switcherator.c ****     sendMessage(statusMsg);
 6869               		.loc 1 1516 0
 6870 2714 80E0      		ldi r24,lo8(statusMsg)
 6871 2716 90E0      		ldi r25,hi8(statusMsg)
 6872 2718 0E94 0000 		call sendMessage
 6873               	.LVL515:
1517:switcherator.c ****     statusMsg[0] = 0;
 6874               		.loc 1 1517 0
 6875 271c 1092 0000 		sts statusMsg,__zero_reg__
 6876               	.LVL516:
1519:switcherator.c ****     time = weeklyProgram[programNumber][1];
 6877               		.loc 1 1519 0
 6878 2720 8AE0      		ldi r24,lo8(10)
 6879 2722 809F      		mul r24,r16
 6880 2724 F001      		movw r30,r0
 6881 2726 819F      		mul r24,r17
 6882 2728 F00D      		add r31,r0
 6883 272a 1124      		clr __zero_reg__
 6884 272c E050      		subi r30,lo8(-(weeklyProgram))
 6885 272e F040      		sbci r31,hi8(-(weeklyProgram))
 6886               	.LVL517:
1520:switcherator.c ****     time <<= 8;
 6887               		.loc 1 1520 0
 6888 2730 9181      		ldd r25,Z+1
 6889 2732 80E0      		ldi r24,0
 6890               	.LVL518:
1521:switcherator.c ****     time |= weeklyProgram[programNumber][2];
 6891               		.loc 1 1521 0
 6892 2734 2281      		ldd r18,Z+2
 6893 2736 AC01      		movw r20,r24
 6894 2738 422B      		or r20,r18
 6895 273a 9A01      		movw r18,r20
 6896               	.LVL519:
1522:switcherator.c ****     unsigned int hours = (time / 60);
 6897               		.loc 1 1522 0
 6898 273c 5CE3      		ldi r21,lo8(60)
 6899 273e E52E      		mov r14,r21
 6900 2740 F12C      		mov r15,__zero_reg__
 6901 2742 C901      		movw r24,r18
 6902 2744 B701      		movw r22,r14
 6903 2746 0E94 0000 		call __udivmodhi4
 6904 274a 8B01      		movw r16,r22
 6905               	.LVL520:
1523:switcherator.c ****     unsigned int minutes = (time - (hours * 60));
 6906               		.loc 1 1523 0
 6907 274c 4CE3      		ldi r20,lo8(60)
 6908 274e 469F      		mul r20,r22
 6909 2750 C001      		movw r24,r0
 6910 2752 479F      		mul r20,r23
 6911 2754 900D      		add r25,r0
 6912 2756 1124      		clr __zero_reg__
 6913 2758 6901      		movw r12,r18
 6914               	.LVL521:
 6915 275a C81A      		sub r12,r24
 6916 275c D90A      		sbc r13,r25
 6917               	.LVL522:
1525:switcherator.c ****     time <<= 8;
 6918               		.loc 1 1525 0
 6919 275e 3381      		ldd r19,Z+3
 6920 2760 20E0      		ldi r18,0
1526:switcherator.c ****     time |= weeklyProgram[programNumber][4];
 6921               		.loc 1 1526 0
 6922 2762 8481      		ldd r24,Z+4
 6923 2764 A901      		movw r20,r18
 6924 2766 482B      		or r20,r24
 6925 2768 CA01      		movw r24,r20
1527:switcherator.c ****     int duration = (time / 60);
 6926               		.loc 1 1527 0
 6927 276a B701      		movw r22,r14
 6928 276c 0E94 0000 		call __udivmodhi4
 6929 2770 B62E      		mov r11,r22
 6930 2772 E72E      		mov r14,r23
 6931               	.LVL523:
1529:switcherator.c ****     weekdays = weeklyProgram[programNumber][0];
 6932               		.loc 1 1529 0
 6933 2774 F080      		ld r15,Z
 6934               	.LVL524:
1530:switcherator.c ****     strcat(statusMsg, "T:");
 6935               		.loc 1 1530 0
 6936 2776 60E0      		ldi r22,lo8(.LC40)
 6937 2778 70E0      		ldi r23,hi8(.LC40)
 6938 277a 80E0      		ldi r24,lo8(statusMsg)
 6939 277c 90E0      		ldi r25,hi8(statusMsg)
 6940 277e 0E94 0000 		call strcat
 6941               	.LVL525:
1531:switcherator.c ****     itoa(hours, tempIntString, 10);
 6942               		.loc 1 1531 0
 6943 2782 4AE0      		ldi r20,lo8(10)
 6944 2784 50E0      		ldi r21,0
 6945 2786 60E0      		ldi r22,lo8(tempIntString)
 6946 2788 70E0      		ldi r23,hi8(tempIntString)
 6947 278a C801      		movw r24,r16
 6948 278c 0E94 0000 		call itoa
 6949               	.LVL526:
1532:switcherator.c ****     strcat(statusMsg, tempIntString);
 6950               		.loc 1 1532 0
 6951 2790 60E0      		ldi r22,lo8(tempIntString)
 6952 2792 70E0      		ldi r23,hi8(tempIntString)
 6953 2794 80E0      		ldi r24,lo8(statusMsg)
 6954 2796 90E0      		ldi r25,hi8(statusMsg)
 6955 2798 0E94 0000 		call strcat
 6956               	.LVL527:
1533:switcherator.c ****     strcat(statusMsg, ":");
 6957               		.loc 1 1533 0
 6958 279c 60E0      		ldi r22,lo8(.LC4)
 6959 279e 70E0      		ldi r23,hi8(.LC4)
 6960 27a0 80E0      		ldi r24,lo8(statusMsg)
 6961 27a2 90E0      		ldi r25,hi8(statusMsg)
 6962 27a4 0E94 0000 		call strcat
 6963               	.LVL528:
1534:switcherator.c ****     itoa(minutes, tempIntString, 10);
 6964               		.loc 1 1534 0
 6965 27a8 4AE0      		ldi r20,lo8(10)
 6966 27aa 50E0      		ldi r21,0
 6967 27ac 60E0      		ldi r22,lo8(tempIntString)
 6968 27ae 70E0      		ldi r23,hi8(tempIntString)
 6969 27b0 C601      		movw r24,r12
 6970 27b2 0E94 0000 		call itoa
 6971               	.LVL529:
1535:switcherator.c ****     strcat(statusMsg, tempIntString);
 6972               		.loc 1 1535 0
 6973 27b6 60E0      		ldi r22,lo8(tempIntString)
 6974 27b8 70E0      		ldi r23,hi8(tempIntString)
 6975 27ba 80E0      		ldi r24,lo8(statusMsg)
 6976 27bc 90E0      		ldi r25,hi8(statusMsg)
 6977 27be 0E94 0000 		call strcat
 6978               	.LVL530:
1536:switcherator.c ****     strcat(statusMsg, " Dur:");
 6979               		.loc 1 1536 0
 6980 27c2 60E0      		ldi r22,lo8(.LC41)
 6981 27c4 70E0      		ldi r23,hi8(.LC41)
 6982 27c6 80E0      		ldi r24,lo8(statusMsg)
 6983 27c8 90E0      		ldi r25,hi8(statusMsg)
 6984 27ca 0E94 0000 		call strcat
 6985               	.LVL531:
1537:switcherator.c ****     itoa(duration, tempLongString, 10);
 6986               		.loc 1 1537 0
 6987 27ce 4AE0      		ldi r20,lo8(10)
 6988 27d0 50E0      		ldi r21,0
 6989 27d2 60E0      		ldi r22,lo8(tempLongString)
 6990 27d4 70E0      		ldi r23,hi8(tempLongString)
 6991 27d6 8B2D      		mov r24,r11
 6992 27d8 9E2D      		mov r25,r14
 6993 27da 0E94 0000 		call itoa
 6994               	.LVL532:
1538:switcherator.c ****     strcat(statusMsg, tempLongString);
 6995               		.loc 1 1538 0
 6996 27de 60E0      		ldi r22,lo8(tempLongString)
 6997 27e0 70E0      		ldi r23,hi8(tempLongString)
 6998 27e2 80E0      		ldi r24,lo8(statusMsg)
 6999 27e4 90E0      		ldi r25,hi8(statusMsg)
 7000 27e6 0E94 0000 		call strcat
 7001               	.LVL533:
1539:switcherator.c ****     strcat(statusMsg, "Days:");
 7002               		.loc 1 1539 0
 7003 27ea 60E0      		ldi r22,lo8(.LC42)
 7004 27ec 70E0      		ldi r23,hi8(.LC42)
 7005 27ee 80E0      		ldi r24,lo8(statusMsg)
 7006 27f0 90E0      		ldi r25,hi8(statusMsg)
 7007 27f2 0E94 0000 		call strcat
 7008               	.LVL534:
1540:switcherator.c ****     if (weekdays == 255) {
 7009               		.loc 1 1540 0
 7010 27f6 5FEF      		ldi r21,lo8(-1)
 7011 27f8 F512      		cpse r15,r21
 7012 27fa 00C0      		rjmp .L501
1541:switcherator.c ****         strcat(statusMsg, "-------");
 7013               		.loc 1 1541 0
 7014 27fc 60E0      		ldi r22,lo8(.LC43)
 7015 27fe 70E0      		ldi r23,hi8(.LC43)
 7016 2800 00C0      		rjmp .L523
 7017               	.L501:
1545:switcherator.c ****     if (weekdays & 0x40) {
 7018               		.loc 1 1545 0
 7019 2802 F6FE      		sbrs r15,6
 7020 2804 00C0      		rjmp .L502
1546:switcherator.c ****         strcat(statusMsg, "S");
 7021               		.loc 1 1546 0
 7022 2806 60E0      		ldi r22,lo8(.LC39)
 7023 2808 70E0      		ldi r23,hi8(.LC39)
 7024 280a 00C0      		rjmp .L517
 7025               	.L502:
1548:switcherator.c ****         strcat(statusMsg, "-");
 7026               		.loc 1 1548 0
 7027 280c 60E0      		ldi r22,lo8(.LC44)
 7028 280e 70E0      		ldi r23,hi8(.LC44)
 7029               	.L517:
 7030 2810 80E0      		ldi r24,lo8(statusMsg)
 7031 2812 90E0      		ldi r25,hi8(statusMsg)
 7032 2814 0E94 0000 		call strcat
 7033               	.LVL535:
1550:switcherator.c ****     if (weekdays & 0x20) {
 7034               		.loc 1 1550 0
 7035 2818 F5FE      		sbrs r15,5
 7036 281a 00C0      		rjmp .L504
1551:switcherator.c ****         strcat(statusMsg, "M");
 7037               		.loc 1 1551 0
 7038 281c 60E0      		ldi r22,lo8(.LC45)
 7039 281e 70E0      		ldi r23,hi8(.LC45)
 7040 2820 00C0      		rjmp .L518
 7041               	.L504:
1553:switcherator.c ****         strcat(statusMsg, "-");
 7042               		.loc 1 1553 0
 7043 2822 60E0      		ldi r22,lo8(.LC44)
 7044 2824 70E0      		ldi r23,hi8(.LC44)
 7045               	.L518:
 7046 2826 80E0      		ldi r24,lo8(statusMsg)
 7047 2828 90E0      		ldi r25,hi8(statusMsg)
 7048 282a 0E94 0000 		call strcat
 7049               	.LVL536:
1555:switcherator.c ****     if (weekdays & 0x10) {
 7050               		.loc 1 1555 0
 7051 282e F4FE      		sbrs r15,4
 7052 2830 00C0      		rjmp .L506
1556:switcherator.c ****         strcat(statusMsg, "T");
 7053               		.loc 1 1556 0
 7054 2832 60E0      		ldi r22,lo8(.LC46)
 7055 2834 70E0      		ldi r23,hi8(.LC46)
 7056 2836 00C0      		rjmp .L519
 7057               	.L506:
1558:switcherator.c ****         strcat(statusMsg, "-");
 7058               		.loc 1 1558 0
 7059 2838 60E0      		ldi r22,lo8(.LC44)
 7060 283a 70E0      		ldi r23,hi8(.LC44)
 7061               	.L519:
 7062 283c 80E0      		ldi r24,lo8(statusMsg)
 7063 283e 90E0      		ldi r25,hi8(statusMsg)
 7064 2840 0E94 0000 		call strcat
 7065               	.LVL537:
1560:switcherator.c ****     if (weekdays & 0x08) {
 7066               		.loc 1 1560 0
 7067 2844 F3FE      		sbrs r15,3
 7068 2846 00C0      		rjmp .L508
1561:switcherator.c ****         strcat(statusMsg, "W");
 7069               		.loc 1 1561 0
 7070 2848 60E0      		ldi r22,lo8(.LC47)
 7071 284a 70E0      		ldi r23,hi8(.LC47)
 7072 284c 00C0      		rjmp .L520
 7073               	.L508:
1563:switcherator.c ****         strcat(statusMsg, "-");
 7074               		.loc 1 1563 0
 7075 284e 60E0      		ldi r22,lo8(.LC44)
 7076 2850 70E0      		ldi r23,hi8(.LC44)
 7077               	.L520:
 7078 2852 80E0      		ldi r24,lo8(statusMsg)
 7079 2854 90E0      		ldi r25,hi8(statusMsg)
 7080 2856 0E94 0000 		call strcat
 7081               	.LVL538:
1565:switcherator.c ****     if (weekdays & 0x04) {
 7082               		.loc 1 1565 0
 7083 285a F2FE      		sbrs r15,2
 7084 285c 00C0      		rjmp .L510
1566:switcherator.c ****         strcat(statusMsg, "T");
 7085               		.loc 1 1566 0
 7086 285e 60E0      		ldi r22,lo8(.LC46)
 7087 2860 70E0      		ldi r23,hi8(.LC46)
 7088 2862 00C0      		rjmp .L521
 7089               	.L510:
1568:switcherator.c ****         strcat(statusMsg, "-");
 7090               		.loc 1 1568 0
 7091 2864 60E0      		ldi r22,lo8(.LC44)
 7092 2866 70E0      		ldi r23,hi8(.LC44)
 7093               	.L521:
 7094 2868 80E0      		ldi r24,lo8(statusMsg)
 7095 286a 90E0      		ldi r25,hi8(statusMsg)
 7096 286c 0E94 0000 		call strcat
 7097               	.LVL539:
1570:switcherator.c ****     if (weekdays & 0x02) {
 7098               		.loc 1 1570 0
 7099 2870 F1FE      		sbrs r15,1
 7100 2872 00C0      		rjmp .L512
1571:switcherator.c ****         strcat(statusMsg, "F");
 7101               		.loc 1 1571 0
 7102 2874 60E0      		ldi r22,lo8(.LC48)
 7103 2876 70E0      		ldi r23,hi8(.LC48)
 7104 2878 00C0      		rjmp .L522
 7105               	.L512:
1573:switcherator.c ****         strcat(statusMsg, "-");
 7106               		.loc 1 1573 0
 7107 287a 60E0      		ldi r22,lo8(.LC44)
 7108 287c 70E0      		ldi r23,hi8(.LC44)
 7109               	.L522:
 7110 287e 80E0      		ldi r24,lo8(statusMsg)
 7111 2880 90E0      		ldi r25,hi8(statusMsg)
 7112 2882 0E94 0000 		call strcat
 7113               	.LVL540:
1575:switcherator.c ****     if (weekdays & 0x01) {
 7114               		.loc 1 1575 0
 7115 2886 F0FE      		sbrs r15,0
 7116 2888 00C0      		rjmp .L514
1576:switcherator.c ****         strcat(statusMsg, "S");
 7117               		.loc 1 1576 0
 7118 288a 60E0      		ldi r22,lo8(.LC39)
 7119 288c 70E0      		ldi r23,hi8(.LC39)
 7120 288e 00C0      		rjmp .L523
 7121               	.L514:
1578:switcherator.c ****         strcat(statusMsg, "-");
 7122               		.loc 1 1578 0
 7123 2890 60E0      		ldi r22,lo8(.LC44)
 7124 2892 70E0      		ldi r23,hi8(.LC44)
 7125               	.LVL541:
 7126               	.L523:
 7127 2894 80E0      		ldi r24,lo8(statusMsg)
 7128 2896 90E0      		ldi r25,hi8(statusMsg)
 7129 2898 0E94 0000 		call strcat
 7130               	.LVL542:
1581:switcherator.c ****     sendMessage(statusMsg);
 7131               		.loc 1 1581 0
 7132 289c 80E0      		ldi r24,lo8(statusMsg)
 7133 289e 90E0      		ldi r25,hi8(statusMsg)
 7134 28a0 0E94 0000 		call sendMessage
 7135               	.LVL543:
 7136               	/* epilogue start */
1582:switcherator.c **** }
 7137               		.loc 1 1582 0
 7138 28a4 6096      		adiw r28,16
 7139 28a6 0FB6      		in __tmp_reg__,__SREG__
 7140 28a8 F894      		cli
 7141 28aa DEBF      		out __SP_H__,r29
 7142 28ac 0FBE      		out __SREG__,__tmp_reg__
 7143 28ae CDBF      		out __SP_L__,r28
 7144 28b0 DF91      		pop r29
 7145 28b2 CF91      		pop r28
 7146 28b4 1F91      		pop r17
 7147 28b6 0F91      		pop r16
 7148 28b8 FF90      		pop r15
 7149 28ba EF90      		pop r14
 7150 28bc DF90      		pop r13
 7151 28be CF90      		pop r12
 7152 28c0 BF90      		pop r11
 7153 28c2 AF90      		pop r10
 7154 28c4 0895      		ret
 7155               	.LFE37:
 7157               		.section	.rodata.str1.1
 7158               	.LC49:
 7159 00e8 5661 6C20 		.string	"Val 0x"
 7159      3078 00
 7160               	.LC50:
 7161 00ef 2C00      		.string	","
 7162               	.LC51:
 7163 00f1 2064 6972 		.string	" dir "
 7163      2000 
 7164               	.LC52:
 7165 00f7 436F 6C20 		.string	"Col Ch"
 7165      4368 00
 7166               	.LC53:
 7167 00fe 5057 4D20 		.string	"PWM "
 7167      00
 7168               	.LC54:
 7169 0103 7374 6174 		.string	"static"
 7169      6963 00
 7170               	.LC55:
 7171 010a 436F 6C43 		.string	"ColCh"
 7171      6800 
 7172               	.LC56:
 7173 0110 6875 6500 		.string	"hue"
 7174               	.LC57:
 7175 0114 6F6E 2073 		.string	"on sw# "
 7175      7723 2000 
 7176               		.text
 7177               	.global	pwmSummary
 7179               	pwmSummary:
 7180               	.LFB26:
 978:switcherator.c **** void pwmSummary(void) {
 7181               		.loc 1 978 0
 7182 28c6 CF92      		push r12
 7183               	.LCFI168:
 7184 28c8 DF92      		push r13
 7185               	.LCFI169:
 7186 28ca EF92      		push r14
 7187               	.LCFI170:
 7188 28cc FF92      		push r15
 7189               	.LCFI171:
 7190 28ce 0F93      		push r16
 7191               	.LCFI172:
 7192 28d0 1F93      		push r17
 7193               	.LCFI173:
 7194 28d2 CF93      		push r28
 7195               	.LCFI174:
 7196 28d4 DF93      		push r29
 7197               	.LCFI175:
 7198 28d6 1F92      		push __zero_reg__
 7199               	.LCFI176:
 7200 28d8 CDB7      		in r28,__SP_L__
 7201 28da DEB7      		in r29,__SP_H__
 7202               	.LCFI177:
 7203               	/* prologue: function */
 7204               	/* frame size = 1 */
 7205               	/* stack size = 9 */
 7206               	.L__stack_usage = 9
 979:switcherator.c ****     statusMsg[0] = 0;
 7207               		.loc 1 979 0
 7208 28dc 1092 0000 		sts statusMsg,__zero_reg__
 980:switcherator.c ****     strcat(statusMsg, "Val 0x");
 7209               		.loc 1 980 0
 7210 28e0 60E0      		ldi r22,lo8(.LC49)
 7211 28e2 70E0      		ldi r23,hi8(.LC49)
 7212 28e4 80E0      		ldi r24,lo8(statusMsg)
 7213 28e6 90E0      		ldi r25,hi8(statusMsg)
 7214 28e8 0E94 0000 		call strcat
 7215               	.LVL544:
 7216 28ec 00E0      		ldi r16,lo8(pwmValues)
 7217 28ee 10E0      		ldi r17,hi8(pwmValues)
 982:switcherator.c ****     for (x = 0; x < 3; x++) {
 7218               		.loc 1 982 0
 7219 28f0 E12C      		mov r14,__zero_reg__
 7220 28f2 F12C      		mov r15,__zero_reg__
 7221 28f4 00C0      		rjmp .L525
 7222               	.LVL545:
 7223               	.L526:
 984:switcherator.c ****             strcat(statusMsg, ",");
 7224               		.loc 1 984 0
 7225 28f6 60E0      		ldi r22,lo8(.LC50)
 7226 28f8 70E0      		ldi r23,hi8(.LC50)
 7227 28fa 80E0      		ldi r24,lo8(statusMsg)
 7228 28fc 90E0      		ldi r25,hi8(statusMsg)
 7229 28fe 0E94 0000 		call strcat
 7230               	.LVL546:
 7231               	.L525:
 985:switcherator.c ****         returnHexWithout(pwmValues[x], tempLongString);
 7232               		.loc 1 985 0
 7233 2902 60E0      		ldi r22,lo8(tempLongString)
 7234 2904 70E0      		ldi r23,hi8(tempLongString)
 7235 2906 F801      		movw r30,r16
 7236 2908 8191      		ld r24,Z+
 7237 290a 8F01      		movw r16,r30
 7238 290c 90E0      		ldi r25,0
 7239 290e 0E94 0000 		call returnHexWithout
 7240               	.LVL547:
 986:switcherator.c ****         strcat(statusMsg, tempLongString);
 7241               		.loc 1 986 0
 7242 2912 60E0      		ldi r22,lo8(tempLongString)
 7243 2914 70E0      		ldi r23,hi8(tempLongString)
 7244 2916 80E0      		ldi r24,lo8(statusMsg)
 7245 2918 90E0      		ldi r25,hi8(statusMsg)
 7246 291a 0E94 0000 		call strcat
 7247               	.LVL548:
 982:switcherator.c ****     for (x = 0; x < 3; x++) {
 7248               		.loc 1 982 0
 7249 291e FFEF      		ldi r31,-1
 7250 2920 EF1A      		sub r14,r31
 7251 2922 FF0A      		sbc r15,r31
 7252               	.LVL549:
 7253 2924 83E0      		ldi r24,3
 7254 2926 E816      		cp r14,r24
 7255 2928 F104      		cpc r15,__zero_reg__
 7256 292a 01F4      		brne .L526
 988:switcherator.c ****     strcat(statusMsg, " dir ");
 7257               		.loc 1 988 0
 7258 292c 60E0      		ldi r22,lo8(.LC51)
 7259 292e 70E0      		ldi r23,hi8(.LC51)
 7260 2930 80E0      		ldi r24,lo8(statusMsg)
 7261 2932 90E0      		ldi r25,hi8(statusMsg)
 7262 2934 0E94 0000 		call strcat
 7263               	.LVL550:
 989:switcherator.c ****     returnInt(pwmdir, tempLongString);
 7264               		.loc 1 989 0
 7265 2938 60E0      		ldi r22,lo8(tempLongString)
 7266 293a 70E0      		ldi r23,hi8(tempLongString)
 7267 293c 8091 0000 		lds r24,pwmdir
 7268 2940 90E0      		ldi r25,0
 7269 2942 0E94 0000 		call returnInt
 7270               	.LVL551:
 990:switcherator.c ****     strcat(statusMsg, tempLongString);
 7271               		.loc 1 990 0
 7272 2946 60E0      		ldi r22,lo8(tempLongString)
 7273 2948 70E0      		ldi r23,hi8(tempLongString)
 7274 294a 80E0      		ldi r24,lo8(statusMsg)
 7275 294c 90E0      		ldi r25,hi8(statusMsg)
 7276 294e 0E94 0000 		call strcat
 7277               	.LVL552:
 991:switcherator.c ****     sendMessage(statusMsg);
 7278               		.loc 1 991 0
 7279 2952 80E0      		ldi r24,lo8(statusMsg)
 7280 2954 90E0      		ldi r25,hi8(statusMsg)
 7281 2956 0E94 0000 		call sendMessage
 7282               	.LVL553:
 992:switcherator.c ****     statusMsg[0] = 0;
 7283               		.loc 1 992 0
 7284 295a 1092 0000 		sts statusMsg,__zero_reg__
 993:switcherator.c ****     strcat(statusMsg, "Col Ch");
 7285               		.loc 1 993 0
 7286 295e 60E0      		ldi r22,lo8(.LC52)
 7287 2960 70E0      		ldi r23,hi8(.LC52)
 7288 2962 80E0      		ldi r24,lo8(statusMsg)
 7289 2964 90E0      		ldi r25,hi8(statusMsg)
 7290 2966 0E94 0000 		call strcat
 7291               	.LVL554:
 7292 296a 70E0      		ldi r23,lo8(colorChanges)
 7293 296c E72E      		mov r14,r23
 7294 296e 70E0      		ldi r23,hi8(colorChanges)
 7295 2970 F72E      		mov r15,r23
 995:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 7296               		.loc 1 995 0
 7297 2972 C12C      		mov r12,__zero_reg__
 7298 2974 D12C      		mov r13,__zero_reg__
 7299 2976 00C0      		rjmp .L527
 7300               	.LVL555:
 7301               	.L530:
 997:switcherator.c ****             strcat(statusMsg, ",");
 7302               		.loc 1 997 0
 7303 2978 60E0      		ldi r22,lo8(.LC50)
 7304 297a 70E0      		ldi r23,hi8(.LC50)
 7305 297c 80E0      		ldi r24,lo8(statusMsg)
 7306 297e 90E0      		ldi r25,hi8(statusMsg)
 7307 2980 0E94 0000 		call strcat
 7308               	.LVL556:
 7309 2984 E3E0      		ldi r30,3
 7310 2986 EE0E      		add r14,r30
 7311 2988 F11C      		adc r15,__zero_reg__
 7312               	.LVL557:
 7313               	.L527:
 998:switcherator.c ****         strcat(statusMsg, "0x");
 7314               		.loc 1 998 0
 7315 298a 60E0      		ldi r22,lo8(.LC5)
 7316 298c 70E0      		ldi r23,hi8(.LC5)
 7317 298e 80E0      		ldi r24,lo8(statusMsg)
 7318 2990 90E0      		ldi r25,hi8(statusMsg)
 7319 2992 0E94 0000 		call strcat
 7320               	.LVL558:
 999:switcherator.c ****         for (y = 0; y < 3; y++) {
 7321               		.loc 1 999 0
 7322 2996 00E0      		ldi r16,0
 7323 2998 10E0      		ldi r17,0
 7324               	.LVL559:
 7325               	.L528:
 978:switcherator.c **** void pwmSummary(void) {
 7326               		.loc 1 978 0 discriminator 2
 7327 299a F701      		movw r30,r14
 7328 299c E00F      		add r30,r16
 7329 299e F11F      		adc r31,r17
1000:switcherator.c ****             returnHexWithout(colorChanges[x][y], tempLongString);
 7330               		.loc 1 1000 0 discriminator 2
 7331 29a0 60E0      		ldi r22,lo8(tempLongString)
 7332 29a2 70E0      		ldi r23,hi8(tempLongString)
 7333 29a4 8081      		ld r24,Z
 7334 29a6 90E0      		ldi r25,0
 7335 29a8 0E94 0000 		call returnHexWithout
 7336               	.LVL560:
1001:switcherator.c ****             strcat(statusMsg, tempLongString);
 7337               		.loc 1 1001 0 discriminator 2
 7338 29ac 60E0      		ldi r22,lo8(tempLongString)
 7339 29ae 70E0      		ldi r23,hi8(tempLongString)
 7340 29b0 80E0      		ldi r24,lo8(statusMsg)
 7341 29b2 90E0      		ldi r25,hi8(statusMsg)
 7342 29b4 0E94 0000 		call strcat
 7343               	.LVL561:
 999:switcherator.c ****         for (y = 0; y < 3; y++) {
 7344               		.loc 1 999 0 discriminator 2
 7345 29b8 0F5F      		subi r16,-1
 7346 29ba 1F4F      		sbci r17,-1
 7347               	.LVL562:
 7348 29bc 0330      		cpi r16,3
 7349 29be 1105      		cpc r17,__zero_reg__
 7350 29c0 01F4      		brne .L528
1003:switcherator.c ****         if (strlen(statusMsg) > 25 && (x + 1) < NUM_COLOR_CHANGES) {
 7351               		.loc 1 1003 0
 7352 29c2 E0E0      		ldi r30,lo8(statusMsg)
 7353 29c4 F0E0      		ldi r31,hi8(statusMsg)
 7354               		0:
 7355 29c6 0190      		ld __tmp_reg__,Z+
 7356 29c8 0020      		tst __tmp_reg__
 7357 29ca 01F4      		brne 0b
 7358 29cc 3197      		sbiw r30,1
 7359 29ce E050      		subi r30,lo8(statusMsg)
 7360 29d0 F040      		sbci r31,hi8(statusMsg)
 7361 29d2 7A97      		sbiw r30,26
 7362 29d4 00F0      		brlo .L529
1003:switcherator.c ****         if (strlen(statusMsg) > 25 && (x + 1) < NUM_COLOR_CHANGES) {
 7363               		.loc 1 1003 0 is_stmt 0 discriminator 1
 7364 29d6 F5E0      		ldi r31,5
 7365 29d8 CF16      		cp r12,r31
 7366 29da D104      		cpc r13,__zero_reg__
 7367 29dc 01F0      		breq .L529
1004:switcherator.c ****             sendMessage(statusMsg);
 7368               		.loc 1 1004 0 is_stmt 1
 7369 29de 80E0      		ldi r24,lo8(statusMsg)
 7370 29e0 90E0      		ldi r25,hi8(statusMsg)
 7371 29e2 0E94 0000 		call sendMessage
 7372               	.LVL563:
1005:switcherator.c ****             statusMsg[6] = 0;
 7373               		.loc 1 1005 0
 7374 29e6 1092 0000 		sts statusMsg+6,__zero_reg__
 7375               	.L529:
 995:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 7376               		.loc 1 995 0
 7377 29ea 8FEF      		ldi r24,-1
 7378 29ec C81A      		sub r12,r24
 7379 29ee D80A      		sbc r13,r24
 7380               	.LVL564:
 7381 29f0 E6E0      		ldi r30,6
 7382 29f2 CE16      		cp r12,r30
 7383 29f4 D104      		cpc r13,__zero_reg__
 7384 29f6 01F0      		breq .+2
 7385 29f8 00C0      		rjmp .L530
1008:switcherator.c ****     sendMessage(statusMsg);
 7386               		.loc 1 1008 0
 7387 29fa 80E0      		ldi r24,lo8(statusMsg)
 7388 29fc 90E0      		ldi r25,hi8(statusMsg)
 7389 29fe 0E94 0000 		call sendMessage
 7390               	.LVL565:
1009:switcherator.c ****     statusMsg[0] = 0;
 7391               		.loc 1 1009 0
 7392 2a02 1092 0000 		sts statusMsg,__zero_reg__
 7393               	.LVL566:
 7394 2a06 00E0      		ldi r16,lo8(switchStuff)
 7395 2a08 10E0      		ldi r17,hi8(switchStuff)
 7396               	.LVL567:
1010:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 7397               		.loc 1 1010 0
 7398 2a0a E12C      		mov r14,__zero_reg__
 7399 2a0c F12C      		mov r15,__zero_reg__
 7400               	.LVL568:
 7401               	.L535:
1011:switcherator.c ****         if ((switchStuff[x] >= 200) && (switchStuff[x] <= 220)) {
 7402               		.loc 1 1011 0
 7403 2a0e F801      		movw r30,r16
 7404 2a10 2191      		ld r18,Z+
 7405 2a12 8F01      		movw r16,r30
 7406 2a14 822F      		mov r24,r18
 7407 2a16 885C      		subi r24,lo8(-(56))
 7408 2a18 8531      		cpi r24,lo8(21)
 7409 2a1a 00F4      		brsh .L531
1012:switcherator.c ****             strcat(statusMsg, "PWM ");
 7410               		.loc 1 1012 0
 7411 2a1c 60E0      		ldi r22,lo8(.LC53)
 7412 2a1e 70E0      		ldi r23,hi8(.LC53)
 7413 2a20 80E0      		ldi r24,lo8(statusMsg)
 7414 2a22 90E0      		ldi r25,hi8(statusMsg)
 7415 2a24 2983      		std Y+1,r18
 7416 2a26 0E94 0000 		call strcat
 7417               	.LVL569:
1013:switcherator.c ****             if (switchStuff[x] == 200) {
 7418               		.loc 1 1013 0
 7419 2a2a 2981      		ldd r18,Y+1
 7420 2a2c 283C      		cpi r18,lo8(-56)
 7421 2a2e 01F4      		brne .L532
1014:switcherator.c ****                 strcat(statusMsg, "static");
 7422               		.loc 1 1014 0
 7423 2a30 60E0      		ldi r22,lo8(.LC54)
 7424 2a32 70E0      		ldi r23,hi8(.LC54)
 7425 2a34 00C0      		rjmp .L541
 7426               	.L532:
1015:switcherator.c ****             } else if (switchStuff[x] == 202) {
 7427               		.loc 1 1015 0
 7428 2a36 2A3C      		cpi r18,lo8(-54)
 7429 2a38 01F4      		brne .L534
1016:switcherator.c ****                 strcat(statusMsg, "ColCh");
 7430               		.loc 1 1016 0
 7431 2a3a 60E0      		ldi r22,lo8(.LC55)
 7432 2a3c 70E0      		ldi r23,hi8(.LC55)
 7433 2a3e 00C0      		rjmp .L541
 7434               	.L534:
1018:switcherator.c ****                 strcat(statusMsg, "hue");
 7435               		.loc 1 1018 0
 7436 2a40 60E0      		ldi r22,lo8(.LC56)
 7437 2a42 70E0      		ldi r23,hi8(.LC56)
 7438               	.L541:
 7439 2a44 80E0      		ldi r24,lo8(statusMsg)
 7440 2a46 90E0      		ldi r25,hi8(statusMsg)
 7441 2a48 0E94 0000 		call strcat
 7442               	.LVL570:
1020:switcherator.c ****             strcat(statusMsg, "on sw# ");
 7443               		.loc 1 1020 0
 7444 2a4c 60E0      		ldi r22,lo8(.LC57)
 7445 2a4e 70E0      		ldi r23,hi8(.LC57)
 7446 2a50 80E0      		ldi r24,lo8(statusMsg)
 7447 2a52 90E0      		ldi r25,hi8(statusMsg)
 7448 2a54 0E94 0000 		call strcat
 7449               	.LVL571:
1021:switcherator.c ****             returnInt(x, tempLongString);
 7450               		.loc 1 1021 0
 7451 2a58 60E0      		ldi r22,lo8(tempLongString)
 7452 2a5a 70E0      		ldi r23,hi8(tempLongString)
 7453 2a5c C701      		movw r24,r14
 7454 2a5e 0E94 0000 		call returnInt
 7455               	.LVL572:
1022:switcherator.c ****             strcat(statusMsg, tempLongString);
 7456               		.loc 1 1022 0
 7457 2a62 60E0      		ldi r22,lo8(tempLongString)
 7458 2a64 70E0      		ldi r23,hi8(tempLongString)
 7459 2a66 80E0      		ldi r24,lo8(statusMsg)
 7460 2a68 90E0      		ldi r25,hi8(statusMsg)
 7461 2a6a 0E94 0000 		call strcat
 7462               	.LVL573:
1023:switcherator.c ****             sendMessage(statusMsg);
 7463               		.loc 1 1023 0
 7464 2a6e 80E0      		ldi r24,lo8(statusMsg)
 7465 2a70 90E0      		ldi r25,hi8(statusMsg)
 7466 2a72 0E94 0000 		call sendMessage
 7467               	.LVL574:
1024:switcherator.c ****             statusMsg[0] = 0;
 7468               		.loc 1 1024 0
 7469 2a76 1092 0000 		sts statusMsg,__zero_reg__
 7470               	.L531:
1010:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 7471               		.loc 1 1010 0
 7472 2a7a FFEF      		ldi r31,-1
 7473 2a7c EF1A      		sub r14,r31
 7474 2a7e FF0A      		sbc r15,r31
 7475               	.LVL575:
 7476 2a80 80E1      		ldi r24,16
 7477 2a82 E816      		cp r14,r24
 7478 2a84 F104      		cpc r15,__zero_reg__
 7479 2a86 01F4      		brne .L535
 7480               	/* epilogue start */
1027:switcherator.c **** }
 7481               		.loc 1 1027 0
 7482 2a88 0F90      		pop __tmp_reg__
 7483 2a8a DF91      		pop r29
 7484 2a8c CF91      		pop r28
 7485 2a8e 1F91      		pop r17
 7486 2a90 0F91      		pop r16
 7487 2a92 FF90      		pop r15
 7488 2a94 EF90      		pop r14
 7489               	.LVL576:
 7490 2a96 DF90      		pop r13
 7491 2a98 CF90      		pop r12
 7492 2a9a 0895      		ret
 7493               	.LFE26:
 7495               		.section	.rodata.str1.1
 7496               	.LC58:
 7497 011c 436F 4300 		.string	"CoC"
 7498               	.LC59:
 7499 0120 4272 7400 		.string	"Brt"
 7500               	.LC60:
 7501 0124 4669 7800 		.string	"Fix"
 7502               	.LC61:
 7503 0128 4875 6500 		.string	"Hue"
 7504               	.LC62:
 7505 012c 4C00      		.string	"L"
 7506               	.LC63:
 7507 012e 4800      		.string	"H"
 7508               		.text
 7509               	.global	switchDisplay
 7511               	switchDisplay:
 7512               	.LFB16:
 601:switcherator.c **** void switchDisplay(char * commandReceived) {
 7513               		.loc 1 601 0
 7514               	.LVL577:
 7515 2a9c CF93      		push r28
 7516               	.LCFI178:
 7517 2a9e DF93      		push r29
 7518               	.LCFI179:
 7519 2aa0 CDB7      		in r28,__SP_L__
 7520 2aa2 DEB7      		in r29,__SP_H__
 7521               	.LCFI180:
 7522 2aa4 A397      		sbiw r28,35
 7523               	.LCFI181:
 7524 2aa6 0FB6      		in __tmp_reg__,__SREG__
 7525 2aa8 F894      		cli
 7526 2aaa DEBF      		out __SP_H__,r29
 7527 2aac 0FBE      		out __SREG__,__tmp_reg__
 7528 2aae CDBF      		out __SP_L__,r28
 7529               	/* prologue: function */
 7530               	/* frame size = 35 */
 7531               	/* stack size = 37 */
 7532               	.L__stack_usage = 37
 602:switcherator.c ****     char port[] = {0};
 7533               		.loc 1 602 0
 7534 2ab0 1BA2      		std Y+35,__zero_reg__
 603:switcherator.c ****     char pin[] = {0};
 7535               		.loc 1 603 0
 7536 2ab2 1AA2      		std Y+34,__zero_reg__
 604:switcherator.c ****     char direction[] = {0};
 7537               		.loc 1 604 0
 7538 2ab4 19A2      		std Y+33,__zero_reg__
 7539               	.LVL578:
 608:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 7540               		.loc 1 608 0
 7541 2ab6 0E94 0000 		call getSwitchNumber
 7542               	.LVL579:
 609:switcherator.c ****     statusMsg[0] = 0;
 7543               		.loc 1 609 0
 7544 2aba 1982      		std Y+1,__zero_reg__
 611:switcherator.c ****     if (switchStuff[switchNumber] >= 200 && switchStuff[switchNumber] <= 220) {
 7545               		.loc 1 611 0
 7546 2abc FC01      		movw r30,r24
 7547 2abe E050      		subi r30,lo8(-(switchStuff))
 7548 2ac0 F040      		sbci r31,hi8(-(switchStuff))
 7549 2ac2 2081      		ld r18,Z
 7550 2ac4 322F      		mov r19,r18
 7551 2ac6 385C      		subi r19,lo8(-(56))
 7552 2ac8 3531      		cpi r19,lo8(21)
 7553 2aca 00F4      		brsh .L543
 613:switcherator.c ****         if (switchStuff[switchNumber] % 2 == 0) {
 7554               		.loc 1 613 0
 7555 2acc 20FD      		sbrc r18,0
 7556 2ace 00C0      		rjmp .L544
 614:switcherator.c ****             if (switchStuff[switchNumber] == 202) {
 7557               		.loc 1 614 0
 7558 2ad0 2A3C      		cpi r18,lo8(-54)
 7559 2ad2 01F4      		brne .L545
 615:switcherator.c ****                 strcat(statusMsg, "CoC");
 7560               		.loc 1 615 0
 7561 2ad4 60E0      		ldi r22,lo8(.LC58)
 7562 2ad6 70E0      		ldi r23,hi8(.LC58)
 7563 2ad8 00C0      		rjmp .L549
 7564               	.L545:
 616:switcherator.c ****             } else if (switchStuff[switchNumber] == 212) {
 7565               		.loc 1 616 0
 7566 2ada 243D      		cpi r18,lo8(-44)
 7567 2adc 01F4      		brne .L547
 617:switcherator.c ****                 strcat(statusMsg, "Brt");
 7568               		.loc 1 617 0
 7569 2ade 60E0      		ldi r22,lo8(.LC59)
 7570 2ae0 70E0      		ldi r23,hi8(.LC59)
 7571 2ae2 00C0      		rjmp .L549
 7572               	.L547:
 619:switcherator.c ****                 strcat(statusMsg, "Fix");
 7573               		.loc 1 619 0
 7574 2ae4 60E0      		ldi r22,lo8(.LC60)
 7575 2ae6 70E0      		ldi r23,hi8(.LC60)
 7576 2ae8 00C0      		rjmp .L549
 7577               	.L544:
 622:switcherator.c ****             strcat(statusMsg, "Hue");
 7578               		.loc 1 622 0
 7579 2aea 60E0      		ldi r22,lo8(.LC61)
 7580 2aec 70E0      		ldi r23,hi8(.LC61)
 7581 2aee 00C0      		rjmp .L549
 7582               	.L543:
 625:switcherator.c ****         getPort(switchNumber, port, pin, direction);
 7583               		.loc 1 625 0
 7584 2af0 9E01      		movw r18,r28
 7585 2af2 2F5D      		subi r18,-33
 7586 2af4 3F4F      		sbci r19,-1
 7587 2af6 AE01      		movw r20,r28
 7588 2af8 4E5D      		subi r20,-34
 7589 2afa 5F4F      		sbci r21,-1
 7590 2afc BE01      		movw r22,r28
 7591 2afe 6D5D      		subi r22,-35
 7592 2b00 7F4F      		sbci r23,-1
 7593 2b02 0E94 0000 		call getPort
 7594               	.LVL580:
 626:switcherator.c ****         tempIntString[0] = port[0];
 7595               		.loc 1 626 0
 7596 2b06 8BA1      		ldd r24,Y+35
 7597 2b08 8093 0000 		sts tempIntString,r24
 627:switcherator.c ****         tempIntString[1] = 0;
 7598               		.loc 1 627 0
 7599 2b0c 1092 0000 		sts tempIntString+1,__zero_reg__
 628:switcherator.c ****         strcat(statusMsg, tempIntString);
 7600               		.loc 1 628 0
 7601 2b10 60E0      		ldi r22,lo8(tempIntString)
 7602 2b12 70E0      		ldi r23,hi8(tempIntString)
 7603 2b14 CE01      		movw r24,r28
 7604 2b16 0196      		adiw r24,1
 7605 2b18 0E94 0000 		call strcat
 7606               	.LVL581:
 630:switcherator.c ****         itoa(realPin, tempIntString, 10);
 7607               		.loc 1 630 0
 7608 2b1c 4AE0      		ldi r20,lo8(10)
 7609 2b1e 50E0      		ldi r21,0
 7610 2b20 60E0      		ldi r22,lo8(tempIntString)
 7611 2b22 70E0      		ldi r23,hi8(tempIntString)
 7612 2b24 8AA1      		ldd r24,Y+34
 7613 2b26 90E0      		ldi r25,0
 7614 2b28 0E94 0000 		call itoa
 7615               	.LVL582:
 631:switcherator.c ****         strcat(statusMsg, tempIntString);
 7616               		.loc 1 631 0
 7617 2b2c 60E0      		ldi r22,lo8(tempIntString)
 7618 2b2e 70E0      		ldi r23,hi8(tempIntString)
 7619 2b30 CE01      		movw r24,r28
 7620 2b32 0196      		adiw r24,1
 7621 2b34 0E94 0000 		call strcat
 7622               	.LVL583:
 632:switcherator.c ****         if (direction[0] == 0) {
 7623               		.loc 1 632 0
 7624 2b38 89A1      		ldd r24,Y+33
 7625 2b3a 8111      		cpse r24,__zero_reg__
 7626 2b3c 00C0      		rjmp .L548
 633:switcherator.c ****             strcat(statusMsg, "L");
 7627               		.loc 1 633 0
 7628 2b3e 60E0      		ldi r22,lo8(.LC62)
 7629 2b40 70E0      		ldi r23,hi8(.LC62)
 7630 2b42 00C0      		rjmp .L549
 7631               	.L548:
 635:switcherator.c ****             strcat(statusMsg, "H");
 7632               		.loc 1 635 0
 7633 2b44 60E0      		ldi r22,lo8(.LC63)
 7634 2b46 70E0      		ldi r23,hi8(.LC63)
 7635               	.L549:
 7636 2b48 CE01      		movw r24,r28
 7637 2b4a 0196      		adiw r24,1
 7638 2b4c 0E94 0000 		call strcat
 7639               	.LVL584:
 638:switcherator.c ****     sendMessage(statusMsg);
 7640               		.loc 1 638 0
 7641 2b50 CE01      		movw r24,r28
 7642 2b52 0196      		adiw r24,1
 7643 2b54 0E94 0000 		call sendMessage
 7644               	.LVL585:
 7645               	/* epilogue start */
 640:switcherator.c **** }
 7646               		.loc 1 640 0
 7647 2b58 A396      		adiw r28,35
 7648 2b5a 0FB6      		in __tmp_reg__,__SREG__
 7649 2b5c F894      		cli
 7650 2b5e DEBF      		out __SP_H__,r29
 7651 2b60 0FBE      		out __SREG__,__tmp_reg__
 7652 2b62 CDBF      		out __SP_L__,r28
 7653 2b64 DF91      		pop r29
 7654 2b66 CF91      		pop r28
 7655 2b68 0895      		ret
 7656               	.LFE16:
 7658               		.section	.rodata.str1.1
 7659               	.LC64:
 7660 0130 6F6B 00   		.string	"ok"
 7661               		.text
 7662               	.global	ok
 7664               	ok:
 7665               	.LFB11:
 390:switcherator.c **** void ok(void) {
 7666               		.loc 1 390 0
 7667               	/* prologue: function */
 7668               	/* frame size = 0 */
 7669               	/* stack size = 0 */
 7670               	.L__stack_usage = 0
 391:switcherator.c ****     sendMessage("ok");
 7671               		.loc 1 391 0
 7672 2b6a 80E0      		ldi r24,lo8(.LC64)
 7673 2b6c 90E0      		ldi r25,hi8(.LC64)
 7674 2b6e 0C94 0000 		jmp sendMessage
 7675               	.LVL586:
 7676               	.LFE11:
 7678               	.global	clearInput
 7680               	clearInput:
 7681               	.LFB82:
3591:switcherator.c **** void clearInput(char * commandReceived) {
 7682               		.loc 1 3591 0
 7683               	.LVL587:
 7684               	/* prologue: function */
 7685               	/* frame size = 0 */
 7686               	/* stack size = 0 */
 7687               	.L__stack_usage = 0
3594:switcherator.c ****     tempIntString[0] = commandReceived[3];
 7688               		.loc 1 3594 0
 7689 2b72 FC01      		movw r30,r24
 7690 2b74 2381      		ldd r18,Z+3
 7691 2b76 2093 0000 		sts tempIntString,r18
3595:switcherator.c ****     tempIntString[1] = commandReceived[4];
 7692               		.loc 1 3595 0
 7693 2b7a 8481      		ldd r24,Z+4
 7694               	.LVL588:
 7695 2b7c 8093 0000 		sts tempIntString+1,r24
3596:switcherator.c ****     inputNumber = atoi(tempIntString);
 7696               		.loc 1 3596 0
 7697 2b80 80E0      		ldi r24,lo8(tempIntString)
 7698 2b82 90E0      		ldi r25,hi8(tempIntString)
 7699 2b84 0E94 0000 		call atoi
 7700               	.LVL589:
3597:switcherator.c ****     int temp = inputs[inputNumber][0];
 7701               		.loc 1 3597 0
 7702 2b88 E3E0      		ldi r30,3
 7703               		1:
 7704 2b8a 880F      		lsl r24
 7705 2b8c 991F      		rol r25
 7706 2b8e EA95      		dec r30
 7707 2b90 01F4      		brne 1b
 7708               	.LVL590:
 7709 2b92 FC01      		movw r30,r24
 7710 2b94 E050      		subi r30,lo8(-(inputs))
 7711 2b96 F040      		sbci r31,hi8(-(inputs))
 7712 2b98 2081      		ld r18,Z
 7713 2b9a 30E0      		ldi r19,0
 7714               	.LVL591:
3598:switcherator.c ****     if (temp > 15 && temp < 32) {
 7715               		.loc 1 3598 0
 7716 2b9c A901      		movw r20,r18
 7717 2b9e 4051      		subi r20,16
 7718 2ba0 5109      		sbc r21,__zero_reg__
 7719 2ba2 4031      		cpi r20,16
 7720 2ba4 5105      		cpc r21,__zero_reg__
 7721 2ba6 00F4      		brsh .L552
 7722               	.LVL592:
3600:switcherator.c ****         temp -= 16;
 7723               		.loc 1 3600 0
 7724 2ba8 9A01      		movw r18,r20
 7725               	.LVL593:
3599:switcherator.c ****         thisPort = &PINB;
 7726               		.loc 1 3599 0
 7727 2baa E3E2      		ldi r30,lo8(35)
 7728 2bac F0E0      		ldi r31,0
 7729 2bae 00C0      		rjmp .L553
 7730               	.LVL594:
 7731               	.L552:
3607:switcherator.c ****     } else if (temp < 48) {
 7732               		.loc 1 3607 0
 7733 2bb0 2033      		cpi r18,48
 7734 2bb2 3105      		cpc r19,__zero_reg__
 7735 2bb4 04F4      		brge .L554
 7736               	.LVL595:
3609:switcherator.c ****         temp -= 32;
 7737               		.loc 1 3609 0
 7738 2bb6 2052      		subi r18,32
 7739 2bb8 3109      		sbc r19,__zero_reg__
 7740               	.LVL596:
3608:switcherator.c ****         thisPort = &PINC;
 7741               		.loc 1 3608 0
 7742 2bba E6E2      		ldi r30,lo8(38)
 7743 2bbc F0E0      		ldi r31,0
 7744 2bbe 00C0      		rjmp .L553
 7745               	.LVL597:
 7746               	.L554:
3612:switcherator.c ****     } else if (temp < 64) {
 7747               		.loc 1 3612 0
 7748 2bc0 2034      		cpi r18,64
 7749 2bc2 3105      		cpc r19,__zero_reg__
 7750 2bc4 04F4      		brge .L556
 7751               	.LVL598:
3614:switcherator.c ****         temp -= 48;
 7752               		.loc 1 3614 0
 7753 2bc6 2053      		subi r18,48
 7754 2bc8 3109      		sbc r19,__zero_reg__
 7755               	.LVL599:
3613:switcherator.c ****         thisPort = &PIND;
 7756               		.loc 1 3613 0
 7757 2bca E9E2      		ldi r30,lo8(41)
 7758 2bcc F0E0      		ldi r31,0
 7759               	.LVL600:
 7760               	.L553:
3646:switcherator.c ****     *thisPort &= ~(1 << temp);
 7761               		.loc 1 3646 0
 7762 2bce 3081      		ld r19,Z
 7763 2bd0 41E0      		ldi r20,lo8(1)
 7764 2bd2 50E0      		ldi r21,0
 7765 2bd4 00C0      		rjmp 2f
 7766               		1:
 7767 2bd6 440F      		lsl r20
 7768               		2:
 7769 2bd8 2A95      		dec r18
 7770 2bda 02F4      		brpl 1b
 7771 2bdc 4095      		com r20
 7772 2bde 4323      		and r20,r19
 7773 2be0 4083      		st Z,r20
3647:switcherator.c ****     inputs[inputNumber][0] = 255;
 7774               		.loc 1 3647 0
 7775 2be2 FC01      		movw r30,r24
 7776               	.LVL601:
 7777 2be4 E050      		subi r30,lo8(-(inputs))
 7778 2be6 F040      		sbci r31,hi8(-(inputs))
 7779 2be8 2FEF      		ldi r18,lo8(-1)
 7780 2bea 2083      		st Z,r18
 7781               	.L556:
3648:switcherator.c ****     ok();
 7782               		.loc 1 3648 0
 7783 2bec 0C94 0000 		jmp ok
 7784               	.LVL602:
 7785               	.LFE82:
 7787               	.global	setDaylightSavings
 7789               	setDaylightSavings:
 7790               	.LFB54:
2213:switcherator.c **** void setDaylightSavings(char * commandReceived) {
 7791               		.loc 1 2213 0
 7792               	.LVL603:
 7793 2bf0 EF92      		push r14
 7794               	.LCFI182:
 7795 2bf2 FF92      		push r15
 7796               	.LCFI183:
 7797 2bf4 0F93      		push r16
 7798               	.LCFI184:
 7799 2bf6 1F93      		push r17
 7800               	.LCFI185:
 7801 2bf8 CF93      		push r28
 7802               	.LCFI186:
 7803 2bfa DF93      		push r29
 7804               	.LCFI187:
 7805               	/* prologue: function */
 7806               	/* frame size = 0 */
 7807               	/* stack size = 6 */
 7808               	.L__stack_usage = 6
 7809 2bfc EC01      		movw r28,r24
2215:switcherator.c ****     tempIntString[0] = commandReceived[3];
 7810               		.loc 1 2215 0
 7811 2bfe F0E0      		ldi r31,lo8(tempIntString)
 7812 2c00 EF2E      		mov r14,r31
 7813 2c02 F0E0      		ldi r31,hi8(tempIntString)
 7814 2c04 FF2E      		mov r15,r31
 7815 2c06 8B81      		ldd r24,Y+3
 7816               	.LVL604:
 7817 2c08 F701      		movw r30,r14
 7818 2c0a 8083      		st Z,r24
2216:switcherator.c ****     tempIntString[1] = commandReceived[4];
 7819               		.loc 1 2216 0
 7820 2c0c 00E0      		ldi r16,lo8(tempIntString+1)
 7821 2c0e 10E0      		ldi r17,hi8(tempIntString+1)
 7822 2c10 8C81      		ldd r24,Y+4
 7823 2c12 F801      		movw r30,r16
 7824 2c14 8083      		st Z,r24
2217:switcherator.c ****     dlInt = atoi(tempIntString);
 7825               		.loc 1 2217 0
 7826 2c16 C701      		movw r24,r14
 7827 2c18 0E94 0000 		call atoi
 7828               	.LVL605:
2218:switcherator.c ****     daylightSavings[0][0] = dlInt;
 7829               		.loc 1 2218 0
 7830 2c1c 9093 0000 		sts daylightSavings+1,r25
 7831 2c20 8093 0000 		sts daylightSavings,r24
2219:switcherator.c ****     tempIntString[0] = commandReceived[5];
 7832               		.loc 1 2219 0
 7833 2c24 8D81      		ldd r24,Y+5
 7834               	.LVL606:
 7835 2c26 F701      		movw r30,r14
 7836 2c28 8083      		st Z,r24
2220:switcherator.c ****     tempIntString[1] = commandReceived[6];
 7837               		.loc 1 2220 0
 7838 2c2a 8E81      		ldd r24,Y+6
 7839 2c2c F801      		movw r30,r16
 7840 2c2e 8083      		st Z,r24
2221:switcherator.c ****     dlInt = atoi(tempIntString);
 7841               		.loc 1 2221 0
 7842 2c30 C701      		movw r24,r14
 7843 2c32 0E94 0000 		call atoi
 7844               	.LVL607:
2222:switcherator.c ****     daylightSavings[0][1] = dlInt;
 7845               		.loc 1 2222 0
 7846 2c36 9093 0000 		sts daylightSavings+2+1,r25
 7847 2c3a 8093 0000 		sts daylightSavings+2,r24
2223:switcherator.c ****     tempIntString[0] = commandReceived[8];
 7848               		.loc 1 2223 0
 7849 2c3e 8885      		ldd r24,Y+8
 7850               	.LVL608:
 7851 2c40 F701      		movw r30,r14
 7852 2c42 8083      		st Z,r24
2224:switcherator.c ****     tempIntString[1] = commandReceived[9];
 7853               		.loc 1 2224 0
 7854 2c44 8985      		ldd r24,Y+9
 7855 2c46 F801      		movw r30,r16
 7856 2c48 8083      		st Z,r24
2225:switcherator.c ****     dlInt = atoi(tempIntString);
 7857               		.loc 1 2225 0
 7858 2c4a C701      		movw r24,r14
 7859 2c4c 0E94 0000 		call atoi
 7860               	.LVL609:
2226:switcherator.c ****     daylightSavings[1][0] = dlInt;
 7861               		.loc 1 2226 0
 7862 2c50 9093 0000 		sts daylightSavings+4+1,r25
 7863 2c54 8093 0000 		sts daylightSavings+4,r24
2227:switcherator.c ****     tempIntString[0] = commandReceived[10];
 7864               		.loc 1 2227 0
 7865 2c58 8A85      		ldd r24,Y+10
 7866               	.LVL610:
 7867 2c5a F701      		movw r30,r14
 7868 2c5c 8083      		st Z,r24
2228:switcherator.c ****     tempIntString[1] = commandReceived[11];
 7869               		.loc 1 2228 0
 7870 2c5e 8B85      		ldd r24,Y+11
 7871 2c60 F801      		movw r30,r16
 7872 2c62 8083      		st Z,r24
2229:switcherator.c ****     dlInt = atoi(tempIntString);
 7873               		.loc 1 2229 0
 7874 2c64 C701      		movw r24,r14
 7875 2c66 0E94 0000 		call atoi
 7876               	.LVL611:
2230:switcherator.c ****     daylightSavings[1][1] = dlInt;
 7877               		.loc 1 2230 0
 7878 2c6a 9093 0000 		sts daylightSavings+6+1,r25
 7879 2c6e 8093 0000 		sts daylightSavings+6,r24
 7880               	/* epilogue start */
2232:switcherator.c **** }
 7881               		.loc 1 2232 0
 7882 2c72 DF91      		pop r29
 7883 2c74 CF91      		pop r28
 7884               	.LVL612:
 7885 2c76 1F91      		pop r17
 7886 2c78 0F91      		pop r16
 7887 2c7a FF90      		pop r15
 7888 2c7c EF90      		pop r14
2231:switcherator.c ****     ok();
 7889               		.loc 1 2231 0
 7890 2c7e 0C94 0000 		jmp ok
 7891               	.LVL613:
 7892               	.LFE54:
 7894               	.global	clearToEEPROM
 7896               	clearToEEPROM:
 7897               	.LFB46:
2044:switcherator.c **** void clearToEEPROM(void) {
 7898               		.loc 1 2044 0
 7899 2c82 CF93      		push r28
 7900               	.LCFI188:
 7901 2c84 DF93      		push r29
 7902               	.LCFI189:
 7903               	/* prologue: function */
 7904               	/* frame size = 0 */
 7905               	/* stack size = 2 */
 7906               	.L__stack_usage = 2
 7907               	.LVL614:
2046:switcherator.c ****     clearEEPROM(DAYLIGHT_SAVE);
 7908               		.loc 1 2046 0
 7909 2c86 86E0      		ldi r24,lo8(6)
 7910 2c88 90E0      		ldi r25,0
 7911 2c8a 0E94 0000 		call clearEEPROM
 7912               	.LVL615:
2047:switcherator.c ****     clearEEPROM(RADIO_ADDR_TX);
 7913               		.loc 1 2047 0
 7914 2c8e 8EE0      		ldi r24,lo8(14)
 7915 2c90 90E0      		ldi r25,0
 7916 2c92 0E94 0000 		call clearEEPROM
 7917               	.LVL616:
2048:switcherator.c ****     clearEEPROM(RADIO_ADDR_R0);
 7918               		.loc 1 2048 0
 7919 2c96 85E1      		ldi r24,lo8(21)
 7920 2c98 90E0      		ldi r25,0
 7921 2c9a 0E94 0000 		call clearEEPROM
 7922               	.LVL617:
2049:switcherator.c ****     clearEEPROM(RADIO_ADDR_R1);
 7923               		.loc 1 2049 0
 7924 2c9e 8CE1      		ldi r24,lo8(28)
 7925 2ca0 90E0      		ldi r25,0
 7926 2ca2 0E94 0000 		call clearEEPROM
 7927               	.LVL618:
2050:switcherator.c ****     clearEEPROM(RADIO_ADDR_R2);
 7928               		.loc 1 2050 0
 7929 2ca6 83E2      		ldi r24,lo8(35)
 7930 2ca8 90E0      		ldi r25,0
 7931 2caa 0E94 0000 		call clearEEPROM
 7932               	.LVL619:
2051:switcherator.c ****     clearEEPROM(RADIO_ADDR_R3);
 7933               		.loc 1 2051 0
 7934 2cae 86E2      		ldi r24,lo8(38)
 7935 2cb0 90E0      		ldi r25,0
 7936 2cb2 0E94 0000 		call clearEEPROM
 7937               	.LVL620:
2052:switcherator.c ****     clearEEPROM(RADIO_ADDR_R4);
 7938               		.loc 1 2052 0
 7939 2cb6 89E2      		ldi r24,lo8(41)
 7940 2cb8 90E0      		ldi r25,0
 7941 2cba 0E94 0000 		call clearEEPROM
 7942               	.LVL621:
2053:switcherator.c ****     clearEEPROM(RADIO_ADDR_R5);
 7943               		.loc 1 2053 0
 7944 2cbe 8CE2      		ldi r24,lo8(44)
 7945 2cc0 90E0      		ldi r25,0
 7946 2cc2 0E94 0000 		call clearEEPROM
 7947               	.LVL622:
2054:switcherator.c ****     clearEEPROM(SWITCH_STUFF);
 7948               		.loc 1 2054 0
 7949 2cc6 80E3      		ldi r24,lo8(48)
 7950 2cc8 90E0      		ldi r25,0
 7951 2cca 0E94 0000 		call clearEEPROM
 7952               	.LVL623:
2055:switcherator.c ****     clearEEPROM(PWM_DIR);
 7953               		.loc 1 2055 0
 7954 2cce 8DE1      		ldi r24,lo8(29)
 7955 2cd0 91E0      		ldi r25,lo8(1)
 7956 2cd2 0E94 0000 		call clearEEPROM
 7957               	.LVL624:
2056:switcherator.c ****     clearEEPROM(BRIGHTNESS);
 7958               		.loc 1 2056 0
 7959 2cd6 80E2      		ldi r24,lo8(32)
 7960 2cd8 91E0      		ldi r25,lo8(1)
 7961 2cda 0E94 0000 		call clearEEPROM
 7962               	.LVL625:
2058:switcherator.c ****         clearEEPROM((INPUT + (x * INPUT_BYTES)));
 7963               		.loc 1 2058 0
 7964 2cde 82E4      		ldi r24,lo8(66)
 7965 2ce0 90E0      		ldi r25,0
 7966 2ce2 0E94 0000 		call clearEEPROM
 7967               	.LVL626:
 7968 2ce6 8CE4      		ldi r24,lo8(76)
 7969 2ce8 90E0      		ldi r25,0
 7970 2cea 0E94 0000 		call clearEEPROM
 7971               	.LVL627:
 7972 2cee 86E5      		ldi r24,lo8(86)
 7973 2cf0 90E0      		ldi r25,0
 7974 2cf2 0E94 0000 		call clearEEPROM
 7975               	.LVL628:
 7976 2cf6 80E6      		ldi r24,lo8(96)
 7977 2cf8 90E0      		ldi r25,0
 7978 2cfa 0E94 0000 		call clearEEPROM
 7979               	.LVL629:
2060:switcherator.c ****         clearEEPROM((LIMIT + (x * LIMIT_BYTES)));
 7980               		.loc 1 2060 0
 7981 2cfe 8AE6      		ldi r24,lo8(106)
 7982 2d00 90E0      		ldi r25,0
 7983 2d02 0E94 0000 		call clearEEPROM
 7984               	.LVL630:
 7985 2d06 8FE6      		ldi r24,lo8(111)
 7986 2d08 90E0      		ldi r25,0
 7987 2d0a 0E94 0000 		call clearEEPROM
 7988               	.LVL631:
 7989 2d0e 84E7      		ldi r24,lo8(116)
 7990 2d10 90E0      		ldi r25,0
 7991 2d12 0E94 0000 		call clearEEPROM
 7992               	.LVL632:
 7993 2d16 89E7      		ldi r24,lo8(121)
 7994 2d18 90E0      		ldi r25,0
 7995 2d1a 0E94 0000 		call clearEEPROM
 7996               	.LVL633:
2061:switcherator.c ****     clearEEPROM(PWM_VALUE);
 7997               		.loc 1 2061 0
 7998 2d1e 8EE7      		ldi r24,lo8(126)
 7999 2d20 90E0      		ldi r25,0
 8000 2d22 0E94 0000 		call clearEEPROM
 8001               	.LVL634:
2063:switcherator.c ****         clearEEPROM((COLOR_CHANGE + (x * COLOR_CHANGE_BYTES)));
 8002               		.loc 1 2063 0
 8003 2d26 83E8      		ldi r24,lo8(-125)
 8004 2d28 90E0      		ldi r25,0
 8005 2d2a 0E94 0000 		call clearEEPROM
 8006               	.LVL635:
 8007 2d2e 88E8      		ldi r24,lo8(-120)
 8008 2d30 90E0      		ldi r25,0
 8009 2d32 0E94 0000 		call clearEEPROM
 8010               	.LVL636:
 8011 2d36 8DE8      		ldi r24,lo8(-115)
 8012 2d38 90E0      		ldi r25,0
 8013 2d3a 0E94 0000 		call clearEEPROM
 8014               	.LVL637:
 8015 2d3e 82E9      		ldi r24,lo8(-110)
 8016 2d40 90E0      		ldi r25,0
 8017 2d42 0E94 0000 		call clearEEPROM
 8018               	.LVL638:
 8019 2d46 87E9      		ldi r24,lo8(-105)
 8020 2d48 90E0      		ldi r25,0
 8021 2d4a 0E94 0000 		call clearEEPROM
 8022               	.LVL639:
 8023 2d4e 8CE9      		ldi r24,lo8(-100)
 8024 2d50 90E0      		ldi r25,0
 8025 2d52 0E94 0000 		call clearEEPROM
 8026               	.LVL640:
 8027 2d56 C1EA      		ldi r28,lo8(-95)
 8028 2d58 D0E0      		ldi r29,0
 8029               	.LVL641:
 8030               	.L559:
2065:switcherator.c ****         clearEEPROM((WEEKLY_PROGRAM + (x * WEEKLY_PROGRAM_BYTES)));
 8031               		.loc 1 2065 0 discriminator 2
 8032 2d5a CE01      		movw r24,r28
 8033 2d5c 0E94 0000 		call clearEEPROM
 8034               	.LVL642:
 8035 2d60 2C96      		adiw r28,12
2064:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++)
 8036               		.loc 1 2064 0 discriminator 2
 8037 2d62 C931      		cpi r28,25
 8038 2d64 81E0      		ldi r24,1
 8039 2d66 D807      		cpc r29,r24
 8040 2d68 01F4      		brne .L559
2066:switcherator.c ****     clearEEPROM(TWEAK_TIMER);
 8041               		.loc 1 2066 0
 8042 2d6a 89E1      		ldi r24,lo8(25)
 8043 2d6c 91E0      		ldi r25,lo8(1)
 8044 2d6e 0E94 0000 		call clearEEPROM
 8045               	.LVL643:
 8046               	/* epilogue start */
2068:switcherator.c **** }
 8047               		.loc 1 2068 0
 8048 2d72 DF91      		pop r29
 8049 2d74 CF91      		pop r28
2067:switcherator.c ****     ok();
 8050               		.loc 1 2067 0
 8051 2d76 0C94 0000 		jmp ok
 8052               	.LVL644:
 8053               	.LFE46:
 8055               	.global	saveToEEPROM
 8057               	saveToEEPROM:
 8058               	.LFB45:
1914:switcherator.c **** void saveToEEPROM(void) {
 8059               		.loc 1 1914 0
 8060 2d7a BF92      		push r11
 8061               	.LCFI190:
 8062 2d7c CF92      		push r12
 8063               	.LCFI191:
 8064 2d7e DF92      		push r13
 8065               	.LCFI192:
 8066 2d80 EF92      		push r14
 8067               	.LCFI193:
 8068 2d82 FF92      		push r15
 8069               	.LCFI194:
 8070 2d84 0F93      		push r16
 8071               	.LCFI195:
 8072 2d86 1F93      		push r17
 8073               	.LCFI196:
 8074 2d88 CF93      		push r28
 8075               	.LCFI197:
 8076 2d8a DF93      		push r29
 8077               	.LCFI198:
 8078 2d8c CDB7      		in r28,__SP_L__
 8079 2d8e DEB7      		in r29,__SP_H__
 8080               	.LCFI199:
 8081 2d90 2E97      		sbiw r28,14
 8082               	.LCFI200:
 8083 2d92 0FB6      		in __tmp_reg__,__SREG__
 8084 2d94 F894      		cli
 8085 2d96 DEBF      		out __SP_H__,r29
 8086 2d98 0FBE      		out __SREG__,__tmp_reg__
 8087 2d9a CDBF      		out __SP_L__,r28
 8088               	/* prologue: function */
 8089               	/* frame size = 14 */
 8090               	/* stack size = 23 */
 8091               	.L__stack_usage = 23
 8092               	.LVL645:
1918:switcherator.c ****     if (tx_addr > 0) {
 8093               		.loc 1 1918 0
 8094 2d9c B090 0000 		lds r11,tx_addr
 8095 2da0 C090 0000 		lds r12,tx_addr+1
 8096 2da4 D090 0000 		lds r13,tx_addr+2
 8097 2da8 E090 0000 		lds r14,tx_addr+3
 8098 2dac F090 0000 		lds r15,tx_addr+4
 8099 2db0 B091 0000 		lds r27,tx_addr+5
 8100 2db4 F091 0000 		lds r31,tx_addr+6
 8101 2db8 E091 0000 		lds r30,tx_addr+7
 8102 2dbc 2B2D      		mov r18,r11
 8103 2dbe 3C2D      		mov r19,r12
 8104 2dc0 4D2D      		mov r20,r13
 8105 2dc2 5E2D      		mov r21,r14
 8106 2dc4 6F2D      		mov r22,r15
 8107 2dc6 7B2F      		mov r23,r27
 8108 2dc8 8F2F      		mov r24,r31
 8109 2dca 9E2F      		mov r25,r30
 8110 2dcc A0E0      		ldi r26,0
 8111 2dce 0E94 0000 		call __cmpdi2_s8
 8112 2dd2 01F0      		breq .L562
1919:switcherator.c ****         unformatAddress(tx_addr, tempStuff);
 8113               		.loc 1 1919 0
 8114 2dd4 8E01      		movw r16,r28
 8115 2dd6 0F5F      		subi r16,-1
 8116 2dd8 1F4F      		sbci r17,-1
 8117 2dda 0E94 0000 		call unformatAddress
 8118               	.LVL646:
1920:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_TX, RADIO_ADDR_TX_BYTES);
 8119               		.loc 1 1920 0
 8120 2dde 47E0      		ldi r20,lo8(7)
 8121 2de0 50E0      		ldi r21,0
 8122 2de2 6EE0      		ldi r22,lo8(14)
 8123 2de4 70E0      		ldi r23,0
 8124 2de6 C801      		movw r24,r16
 8125 2de8 0E94 0000 		call writeEEPROM
 8126               	.LVL647:
 8127               	.L562:
1922:switcherator.c ****     if (rx_addr_p0 > 0) {
 8128               		.loc 1 1922 0
 8129 2dec B090 0000 		lds r11,rx_addr_p0
 8130 2df0 C090 0000 		lds r12,rx_addr_p0+1
 8131 2df4 D090 0000 		lds r13,rx_addr_p0+2
 8132 2df8 E090 0000 		lds r14,rx_addr_p0+3
 8133 2dfc F090 0000 		lds r15,rx_addr_p0+4
 8134 2e00 B091 0000 		lds r27,rx_addr_p0+5
 8135 2e04 F091 0000 		lds r31,rx_addr_p0+6
 8136 2e08 E091 0000 		lds r30,rx_addr_p0+7
 8137 2e0c 2B2D      		mov r18,r11
 8138 2e0e 3C2D      		mov r19,r12
 8139 2e10 4D2D      		mov r20,r13
 8140 2e12 5E2D      		mov r21,r14
 8141 2e14 6F2D      		mov r22,r15
 8142 2e16 7B2F      		mov r23,r27
 8143 2e18 8F2F      		mov r24,r31
 8144 2e1a 9E2F      		mov r25,r30
 8145 2e1c A0E0      		ldi r26,0
 8146 2e1e 0E94 0000 		call __cmpdi2_s8
 8147 2e22 01F0      		breq .L563
1923:switcherator.c ****         unformatAddress(rx_addr_p0, tempStuff);
 8148               		.loc 1 1923 0
 8149 2e24 8E01      		movw r16,r28
 8150 2e26 0F5F      		subi r16,-1
 8151 2e28 1F4F      		sbci r17,-1
 8152 2e2a 0E94 0000 		call unformatAddress
 8153               	.LVL648:
1924:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R0, RADIO_ADDR_R0_BYTES);
 8154               		.loc 1 1924 0
 8155 2e2e 47E0      		ldi r20,lo8(7)
 8156 2e30 50E0      		ldi r21,0
 8157 2e32 65E1      		ldi r22,lo8(21)
 8158 2e34 70E0      		ldi r23,0
 8159 2e36 C801      		movw r24,r16
 8160 2e38 0E94 0000 		call writeEEPROM
 8161               	.LVL649:
 8162               	.L563:
1926:switcherator.c ****     if (rx_addr_p1 > 0) {
 8163               		.loc 1 1926 0
 8164 2e3c B090 0000 		lds r11,rx_addr_p1
 8165 2e40 C090 0000 		lds r12,rx_addr_p1+1
 8166 2e44 D090 0000 		lds r13,rx_addr_p1+2
 8167 2e48 E090 0000 		lds r14,rx_addr_p1+3
 8168 2e4c F090 0000 		lds r15,rx_addr_p1+4
 8169 2e50 B091 0000 		lds r27,rx_addr_p1+5
 8170 2e54 F091 0000 		lds r31,rx_addr_p1+6
 8171 2e58 E091 0000 		lds r30,rx_addr_p1+7
 8172 2e5c 2B2D      		mov r18,r11
 8173 2e5e 3C2D      		mov r19,r12
 8174 2e60 4D2D      		mov r20,r13
 8175 2e62 5E2D      		mov r21,r14
 8176 2e64 6F2D      		mov r22,r15
 8177 2e66 7B2F      		mov r23,r27
 8178 2e68 8F2F      		mov r24,r31
 8179 2e6a 9E2F      		mov r25,r30
 8180 2e6c A0E0      		ldi r26,0
 8181 2e6e 0E94 0000 		call __cmpdi2_s8
 8182 2e72 01F0      		breq .L564
1927:switcherator.c ****         unformatAddress(rx_addr_p1, tempStuff);
 8183               		.loc 1 1927 0
 8184 2e74 8E01      		movw r16,r28
 8185 2e76 0F5F      		subi r16,-1
 8186 2e78 1F4F      		sbci r17,-1
 8187 2e7a 0E94 0000 		call unformatAddress
 8188               	.LVL650:
1928:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R1, RADIO_ADDR_R1_BYTES);
 8189               		.loc 1 1928 0
 8190 2e7e 47E0      		ldi r20,lo8(7)
 8191 2e80 50E0      		ldi r21,0
 8192 2e82 6CE1      		ldi r22,lo8(28)
 8193 2e84 70E0      		ldi r23,0
 8194 2e86 C801      		movw r24,r16
 8195 2e88 0E94 0000 		call writeEEPROM
 8196               	.LVL651:
 8197               	.L564:
1930:switcherator.c ****     if (rx_addr_p2 > 0) {
 8198               		.loc 1 1930 0
 8199 2e8c E091 0000 		lds r30,rx_addr_p2
 8200 2e90 3091 0000 		lds r19,rx_addr_p2+1
 8201 2e94 4091 0000 		lds r20,rx_addr_p2+2
 8202 2e98 5091 0000 		lds r21,rx_addr_p2+3
 8203 2e9c 6091 0000 		lds r22,rx_addr_p2+4
 8204 2ea0 7091 0000 		lds r23,rx_addr_p2+5
 8205 2ea4 2E2F      		mov r18,r30
 8206 2ea6 8091 0000 		lds r24,rx_addr_p2+6
 8207 2eaa 9091 0000 		lds r25,rx_addr_p2+7
 8208 2eae A0E0      		ldi r26,0
 8209 2eb0 0E94 0000 		call __cmpdi2_s8
 8210 2eb4 01F0      		breq .L565
1931:switcherator.c ****         tempStuff[0] = rx_addr_p2;
 8211               		.loc 1 1931 0
 8212 2eb6 E983      		std Y+1,r30
1932:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R2, RADIO_ADDR_R2_BYTES);
 8213               		.loc 1 1932 0
 8214 2eb8 43E0      		ldi r20,lo8(3)
 8215 2eba 50E0      		ldi r21,0
 8216 2ebc 63E2      		ldi r22,lo8(35)
 8217 2ebe 70E0      		ldi r23,0
 8218 2ec0 CE01      		movw r24,r28
 8219 2ec2 0196      		adiw r24,1
 8220 2ec4 0E94 0000 		call writeEEPROM
 8221               	.LVL652:
 8222               	.L565:
1934:switcherator.c ****     if (rx_addr_p3 > 0) {
 8223               		.loc 1 1934 0
 8224 2ec8 E091 0000 		lds r30,rx_addr_p3
 8225 2ecc 3091 0000 		lds r19,rx_addr_p3+1
 8226 2ed0 4091 0000 		lds r20,rx_addr_p3+2
 8227 2ed4 5091 0000 		lds r21,rx_addr_p3+3
 8228 2ed8 6091 0000 		lds r22,rx_addr_p3+4
 8229 2edc 7091 0000 		lds r23,rx_addr_p3+5
 8230 2ee0 2E2F      		mov r18,r30
 8231 2ee2 8091 0000 		lds r24,rx_addr_p3+6
 8232 2ee6 9091 0000 		lds r25,rx_addr_p3+7
 8233 2eea A0E0      		ldi r26,0
 8234 2eec 0E94 0000 		call __cmpdi2_s8
 8235 2ef0 01F0      		breq .L566
1935:switcherator.c ****         tempStuff[0] = rx_addr_p3;
 8236               		.loc 1 1935 0
 8237 2ef2 E983      		std Y+1,r30
1936:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R3, RADIO_ADDR_R3_BYTES);
 8238               		.loc 1 1936 0
 8239 2ef4 43E0      		ldi r20,lo8(3)
 8240 2ef6 50E0      		ldi r21,0
 8241 2ef8 66E2      		ldi r22,lo8(38)
 8242 2efa 70E0      		ldi r23,0
 8243 2efc CE01      		movw r24,r28
 8244 2efe 0196      		adiw r24,1
 8245 2f00 0E94 0000 		call writeEEPROM
 8246               	.LVL653:
 8247               	.L566:
1938:switcherator.c ****     if (rx_addr_p4 > 0) {
 8248               		.loc 1 1938 0
 8249 2f04 E091 0000 		lds r30,rx_addr_p4
 8250 2f08 3091 0000 		lds r19,rx_addr_p4+1
 8251 2f0c 4091 0000 		lds r20,rx_addr_p4+2
 8252 2f10 5091 0000 		lds r21,rx_addr_p4+3
 8253 2f14 6091 0000 		lds r22,rx_addr_p4+4
 8254 2f18 7091 0000 		lds r23,rx_addr_p4+5
 8255 2f1c 2E2F      		mov r18,r30
 8256 2f1e 8091 0000 		lds r24,rx_addr_p4+6
 8257 2f22 9091 0000 		lds r25,rx_addr_p4+7
 8258 2f26 A0E0      		ldi r26,0
 8259 2f28 0E94 0000 		call __cmpdi2_s8
 8260 2f2c 01F0      		breq .L567
1939:switcherator.c ****         tempStuff[0] = rx_addr_p4;
 8261               		.loc 1 1939 0
 8262 2f2e E983      		std Y+1,r30
1940:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R4, RADIO_ADDR_R4_BYTES);
 8263               		.loc 1 1940 0
 8264 2f30 43E0      		ldi r20,lo8(3)
 8265 2f32 50E0      		ldi r21,0
 8266 2f34 69E2      		ldi r22,lo8(41)
 8267 2f36 70E0      		ldi r23,0
 8268 2f38 CE01      		movw r24,r28
 8269 2f3a 0196      		adiw r24,1
 8270 2f3c 0E94 0000 		call writeEEPROM
 8271               	.LVL654:
 8272               	.L567:
1942:switcherator.c ****     if (rx_addr_p5 > 0) {
 8273               		.loc 1 1942 0
 8274 2f40 E091 0000 		lds r30,rx_addr_p5
 8275 2f44 3091 0000 		lds r19,rx_addr_p5+1
 8276 2f48 4091 0000 		lds r20,rx_addr_p5+2
 8277 2f4c 5091 0000 		lds r21,rx_addr_p5+3
 8278 2f50 6091 0000 		lds r22,rx_addr_p5+4
 8279 2f54 7091 0000 		lds r23,rx_addr_p5+5
 8280 2f58 2E2F      		mov r18,r30
 8281 2f5a 8091 0000 		lds r24,rx_addr_p5+6
 8282 2f5e 9091 0000 		lds r25,rx_addr_p5+7
 8283 2f62 A0E0      		ldi r26,0
 8284 2f64 0E94 0000 		call __cmpdi2_s8
 8285 2f68 01F0      		breq .L568
1943:switcherator.c ****         tempStuff[0] = rx_addr_p5;
 8286               		.loc 1 1943 0
 8287 2f6a E983      		std Y+1,r30
1944:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R5, RADIO_ADDR_R5_BYTES);
 8288               		.loc 1 1944 0
 8289 2f6c 43E0      		ldi r20,lo8(3)
 8290 2f6e 50E0      		ldi r21,0
 8291 2f70 6CE2      		ldi r22,lo8(44)
 8292 2f72 70E0      		ldi r23,0
 8293 2f74 CE01      		movw r24,r28
 8294 2f76 0196      		adiw r24,1
 8295 2f78 0E94 0000 		call writeEEPROM
 8296               	.LVL655:
 8297               	.L568:
1947:switcherator.c ****     if (tweakTimer != 0) {
 8298               		.loc 1 1947 0
 8299 2f7c 8091 0000 		lds r24,tweakTimer
 8300 2f80 9091 0000 		lds r25,tweakTimer+1
 8301 2f84 A091 0000 		lds r26,tweakTimer+2
 8302 2f88 B091 0000 		lds r27,tweakTimer+3
 8303 2f8c 0097      		sbiw r24,0
 8304 2f8e A105      		cpc r26,__zero_reg__
 8305 2f90 B105      		cpc r27,__zero_reg__
 8306 2f92 01F0      		breq .L569
1948:switcherator.c ****         tempStuff[0] = tweakTimer >> 8;
 8307               		.loc 1 1948 0
 8308 2f94 9983      		std Y+1,r25
1949:switcherator.c ****         tempStuff[1] = (tweakTimer & 0xff);
 8309               		.loc 1 1949 0
 8310 2f96 8A83      		std Y+2,r24
1950:switcherator.c ****         writeEEPROM(tempStuff, TWEAK_TIMER, TWEAK_TIMER_BYTES);
 8311               		.loc 1 1950 0
 8312 2f98 44E0      		ldi r20,lo8(4)
 8313 2f9a 50E0      		ldi r21,0
 8314 2f9c 69E1      		ldi r22,lo8(25)
 8315 2f9e 71E0      		ldi r23,lo8(1)
 8316 2fa0 CE01      		movw r24,r28
 8317 2fa2 0196      		adiw r24,1
 8318 2fa4 0E94 0000 		call writeEEPROM
 8319               	.LVL656:
 8320               	.L569:
1955:switcherator.c ****     if (daylightSavings[0][0] > 0) {
 8321               		.loc 1 1955 0
 8322 2fa8 8091 0000 		lds r24,daylightSavings
 8323 2fac 9091 0000 		lds r25,daylightSavings+1
 8324 2fb0 0097      		sbiw r24,0
 8325 2fb2 01F0      		breq .L570
1956:switcherator.c ****         tempStuff[0] = (daylightSavings[0][0] >> 8);
 8326               		.loc 1 1956 0
 8327 2fb4 9983      		std Y+1,r25
1957:switcherator.c ****         tempStuff[1] = (daylightSavings[0][0] & 0xff);
 8328               		.loc 1 1957 0
 8329 2fb6 8A83      		std Y+2,r24
1958:switcherator.c ****         tempStuff[2] = (daylightSavings[0][1] >> 8);
 8330               		.loc 1 1958 0
 8331 2fb8 8091 0000 		lds r24,daylightSavings+2
 8332 2fbc 9091 0000 		lds r25,daylightSavings+3
 8333 2fc0 9B83      		std Y+3,r25
1959:switcherator.c ****         tempStuff[3] = (daylightSavings[0][1] & 0xff);
 8334               		.loc 1 1959 0
 8335 2fc2 8C83      		std Y+4,r24
1960:switcherator.c ****         tempStuff[4] = (daylightSavings[1][0] >> 8);
 8336               		.loc 1 1960 0
 8337 2fc4 8091 0000 		lds r24,daylightSavings+4
 8338 2fc8 9091 0000 		lds r25,daylightSavings+5
 8339 2fcc 9D83      		std Y+5,r25
1961:switcherator.c ****         tempStuff[5] = (daylightSavings[1][0] & 0xff);
 8340               		.loc 1 1961 0
 8341 2fce 8E83      		std Y+6,r24
1962:switcherator.c ****         tempStuff[6] = (daylightSavings[1][1] >> 8);
 8342               		.loc 1 1962 0
 8343 2fd0 8091 0000 		lds r24,daylightSavings+6
 8344 2fd4 9091 0000 		lds r25,daylightSavings+7
 8345 2fd8 9F83      		std Y+7,r25
1963:switcherator.c ****         tempStuff[7] = (daylightSavings[1][1] & 0xff);
 8346               		.loc 1 1963 0
 8347 2fda 8887      		std Y+8,r24
1964:switcherator.c ****         writeEEPROM(tempStuff, DAYLIGHT_SAVE, DAYLIGHT_SAVE_BYTES);
 8348               		.loc 1 1964 0
 8349 2fdc 4AE0      		ldi r20,lo8(10)
 8350 2fde 50E0      		ldi r21,0
 8351 2fe0 66E0      		ldi r22,lo8(6)
 8352 2fe2 70E0      		ldi r23,0
 8353 2fe4 CE01      		movw r24,r28
 8354 2fe6 0196      		adiw r24,1
 8355 2fe8 0E94 0000 		call writeEEPROM
 8356               	.LVL657:
 8357               	.L570:
 8358 2fec E0E0      		ldi r30,lo8(switchStuff)
 8359 2fee F0E0      		ldi r31,hi8(switchStuff)
1967:switcherator.c ****     char setupPWM = 0;
 8360               		.loc 1 1967 0
 8361 2ff0 10E0      		ldi r17,0
1966:switcherator.c ****     char setupaSwitch = 0;
 8362               		.loc 1 1966 0
 8363 2ff2 80E0      		ldi r24,0
 8364               	.LVL658:
 8365               	.L573:
1970:switcherator.c ****         if (switchStuff[x] < 255)
 8366               		.loc 1 1970 0
 8367 2ff4 9191      		ld r25,Z+
 8368 2ff6 9F3F      		cpi r25,lo8(-1)
 8369 2ff8 01F0      		breq .L571
1971:switcherator.c ****             setupaSwitch = 1;
 8370               		.loc 1 1971 0
 8371 2ffa 81E0      		ldi r24,lo8(1)
 8372               	.L571:
 8373               	.LVL659:
1972:switcherator.c ****         if (switchStuff[x] >= 200 && switchStuff[x] <= 230)
 8374               		.loc 1 1972 0
 8375 2ffc 985C      		subi r25,lo8(-(56))
 8376 2ffe 9F31      		cpi r25,lo8(31)
 8377 3000 00F4      		brsh .L572
1973:switcherator.c ****             setupPWM = 1;
 8378               		.loc 1 1973 0
 8379 3002 11E0      		ldi r17,lo8(1)
 8380               	.L572:
 8381               	.LVL660:
1969:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 8382               		.loc 1 1969 0
 8383 3004 90E0      		ldi r25,hi8(switchStuff+16)
 8384 3006 E030      		cpi r30,lo8(switchStuff+16)
 8385 3008 F907      		cpc r31,r25
 8386 300a 01F4      		brne .L573
1975:switcherator.c ****     if (setupaSwitch == 1) {
 8387               		.loc 1 1975 0
 8388 300c 8130      		cpi r24,lo8(1)
 8389 300e 01F4      		brne .L574
1976:switcherator.c ****         writeEEPROM(switchStuff, SWITCH_STUFF, SWITCH_STUFF_BYTES);
 8390               		.loc 1 1976 0
 8391 3010 42E1      		ldi r20,lo8(18)
 8392 3012 50E0      		ldi r21,0
 8393 3014 60E3      		ldi r22,lo8(48)
 8394 3016 70E0      		ldi r23,0
 8395 3018 80E0      		ldi r24,lo8(switchStuff)
 8396 301a 90E0      		ldi r25,hi8(switchStuff)
 8397               	.LVL661:
 8398 301c 0E94 0000 		call writeEEPROM
 8399               	.LVL662:
1977:switcherator.c ****         writeEEPROM(switchBright, BRIGHTNESS, BRIGHTNESS_BYTES);
 8400               		.loc 1 1977 0
 8401 3020 42E1      		ldi r20,lo8(18)
 8402 3022 50E0      		ldi r21,0
 8403 3024 60E2      		ldi r22,lo8(32)
 8404 3026 71E0      		ldi r23,lo8(1)
 8405 3028 80E0      		ldi r24,lo8(switchBright)
 8406 302a 90E0      		ldi r25,hi8(switchBright)
 8407 302c 0E94 0000 		call writeEEPROM
 8408               	.LVL663:
 8409               	.L574:
1979:switcherator.c ****     tempStuff[0] = pwmdir;
 8410               		.loc 1 1979 0
 8411 3030 8091 0000 		lds r24,pwmdir
 8412 3034 8983      		std Y+1,r24
1980:switcherator.c ****     if (setupPWM == 1)
 8413               		.loc 1 1980 0
 8414 3036 1130      		cpi r17,lo8(1)
 8415 3038 01F4      		brne .L575
1981:switcherator.c ****         writeEEPROM(tempStuff, PWM_DIR, PWM_DIR_BYTES);
 8416               		.loc 1 1981 0
 8417 303a 43E0      		ldi r20,lo8(3)
 8418 303c 50E0      		ldi r21,0
 8419 303e 6DE1      		ldi r22,lo8(29)
 8420 3040 71E0      		ldi r23,lo8(1)
 8421 3042 CE01      		movw r24,r28
 8422 3044 0196      		adiw r24,1
 8423 3046 0E94 0000 		call writeEEPROM
 8424               	.LVL664:
 8425               	.L575:
 8426 304a 00E0      		ldi r16,lo8(weeklyProgram)
 8427 304c E02E      		mov r14,r16
 8428 304e 00E0      		ldi r16,hi8(weeklyProgram)
 8429 3050 F02E      		mov r15,r16
 8430 3052 80E0      		ldi r24,lo8(weeklyProgram+1)
 8431 3054 C82E      		mov r12,r24
 8432 3056 80E0      		ldi r24,hi8(weeklyProgram+1)
 8433 3058 D82E      		mov r13,r24
1973:switcherator.c ****             setupPWM = 1;
 8434               		.loc 1 1973 0 discriminator 1
 8435 305a 01EA      		ldi r16,lo8(-95)
 8436 305c 10E0      		ldi r17,0
 8437               	.LVL665:
 8438               	.L579:
1991:switcherator.c ****         memoryMarker = (WEEKLY_PROGRAM + (x * WEEKLY_PROGRAM_BYTES));
 8439               		.loc 1 1991 0
 8440 305e B801      		movw r22,r16
 8441               	.LVL666:
1992:switcherator.c ****         if (weeklyProgram[x][0] != 255 || weeklyProgram[x][1] != 255) {
 8442               		.loc 1 1992 0
 8443 3060 F701      		movw r30,r14
 8444 3062 8081      		ld r24,Z
 8445 3064 8F3F      		cpi r24,lo8(-1)
 8446 3066 01F4      		brne .L576
1992:switcherator.c ****         if (weeklyProgram[x][0] != 255 || weeklyProgram[x][1] != 255) {
 8447               		.loc 1 1992 0 is_stmt 0 discriminator 1
 8448 3068 F601      		movw r30,r12
 8449 306a 8081      		ld r24,Z
 8450 306c 8F3F      		cpi r24,lo8(-1)
 8451 306e 01F0      		breq .L577
 8452               	.L576:
 8453 3070 FE01      		movw r30,r28
 8454 3072 3196      		adiw r30,1
1973:switcherator.c ****             setupPWM = 1;
 8455               		.loc 1 1973 0 is_stmt 1 discriminator 2
 8456 3074 80E0      		ldi r24,0
 8457 3076 90E0      		ldi r25,0
 8458               	.L578:
1914:switcherator.c **** void saveToEEPROM(void) {
 8459               		.loc 1 1914 0 discriminator 2
 8460 3078 D701      		movw r26,r14
 8461 307a A80F      		add r26,r24
 8462 307c B91F      		adc r27,r25
1994:switcherator.c ****                 tempStuff[y] = weeklyProgram[x][y];
 8463               		.loc 1 1994 0 discriminator 2
 8464 307e 2C91      		ld r18,X
 8465 3080 2193      		st Z+,r18
1993:switcherator.c ****             for (y = 0; y < 10; y++)
 8466               		.loc 1 1993 0 discriminator 2
 8467 3082 0196      		adiw r24,1
 8468               	.LVL667:
 8469 3084 8A30      		cpi r24,10
 8470 3086 9105      		cpc r25,__zero_reg__
 8471 3088 01F4      		brne .L578
1995:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, WEEKLY_PROGRAM_BYTES);
 8472               		.loc 1 1995 0
 8473 308a 4CE0      		ldi r20,lo8(12)
 8474 308c 50E0      		ldi r21,0
 8475 308e CE01      		movw r24,r28
 8476               	.LVL668:
 8477 3090 0196      		adiw r24,1
 8478 3092 0E94 0000 		call writeEEPROM
 8479               	.LVL669:
 8480               	.L577:
 8481 3096 FAE0      		ldi r31,10
 8482 3098 EF0E      		add r14,r31
 8483 309a F11C      		adc r15,__zero_reg__
 8484 309c 8AE0      		ldi r24,10
 8485 309e C80E      		add r12,r24
 8486 30a0 D11C      		adc r13,__zero_reg__
 8487 30a2 045F      		subi r16,-12
 8488 30a4 1F4F      		sbci r17,-1
1990:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 8489               		.loc 1 1990 0
 8490 30a6 0931      		cpi r16,25
 8491 30a8 91E0      		ldi r25,1
 8492 30aa 1907      		cpc r17,r25
 8493 30ac 01F4      		brne .L579
 8494 30ae 10E0      		ldi r17,lo8(inputs)
 8495 30b0 E12E      		mov r14,r17
 8496 30b2 10E0      		ldi r17,hi8(inputs)
 8497 30b4 F12E      		mov r15,r17
 8498               	.LVL670:
 8499 30b6 02E4      		ldi r16,lo8(66)
 8500 30b8 10E0      		ldi r17,0
 8501               	.L582:
2002:switcherator.c ****         if (inputs[x][0] != 255) {
 8502               		.loc 1 2002 0
 8503 30ba F701      		movw r30,r14
 8504 30bc 8081      		ld r24,Z
 8505 30be 8F3F      		cpi r24,lo8(-1)
 8506 30c0 01F0      		breq .L580
 8507 30c2 FE01      		movw r30,r28
 8508 30c4 3196      		adiw r30,1
 8509 30c6 80E0      		ldi r24,0
 8510 30c8 90E0      		ldi r25,0
 8511               	.L581:
1914:switcherator.c **** void saveToEEPROM(void) {
 8512               		.loc 1 1914 0 discriminator 2
 8513 30ca D701      		movw r26,r14
 8514 30cc A80F      		add r26,r24
 8515 30ce B91F      		adc r27,r25
2004:switcherator.c ****                 tempStuff[y] = inputs[x][y];
 8516               		.loc 1 2004 0 discriminator 2
 8517 30d0 2C91      		ld r18,X
 8518 30d2 2193      		st Z+,r18
2003:switcherator.c ****             for (y = 0; y < 8; y++) {
 8519               		.loc 1 2003 0 discriminator 2
 8520 30d4 0196      		adiw r24,1
 8521               	.LVL671:
 8522 30d6 8830      		cpi r24,8
 8523 30d8 9105      		cpc r25,__zero_reg__
 8524 30da 01F4      		brne .L581
2006:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, INPUT_BYTES);
 8525               		.loc 1 2006 0
 8526 30dc 4AE0      		ldi r20,lo8(10)
 8527 30de 50E0      		ldi r21,0
 8528 30e0 B801      		movw r22,r16
 8529 30e2 CE01      		movw r24,r28
 8530               	.LVL672:
 8531 30e4 0196      		adiw r24,1
 8532 30e6 0E94 0000 		call writeEEPROM
 8533               	.LVL673:
 8534               	.L580:
 8535 30ea F8E0      		ldi r31,8
 8536 30ec EF0E      		add r14,r31
 8537 30ee F11C      		adc r15,__zero_reg__
 8538 30f0 065F      		subi r16,-10
 8539 30f2 1F4F      		sbci r17,-1
2000:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 8540               		.loc 1 2000 0
 8541 30f4 0A36      		cpi r16,106
 8542 30f6 1105      		cpc r17,__zero_reg__
 8543 30f8 01F4      		brne .L582
 8544 30fa 00E0      		ldi r16,lo8(timeLimits)
 8545 30fc 10E0      		ldi r17,hi8(timeLimits)
 8546 30fe BAE6      		ldi r27,lo8(106)
 8547 3100 EB2E      		mov r14,r27
 8548 3102 F12C      		mov r15,__zero_reg__
 8549               	.L584:
2013:switcherator.c ****         if (timeLimits[x][2] > 0) {
 8550               		.loc 1 2013 0
 8551 3104 F801      		movw r30,r16
 8552 3106 8085      		ldd r24,Z+8
 8553 3108 9185      		ldd r25,Z+9
 8554 310a A285      		ldd r26,Z+10
 8555 310c B385      		ldd r27,Z+11
 8556 310e 0097      		sbiw r24,0
 8557 3110 A105      		cpc r26,__zero_reg__
 8558 3112 B105      		cpc r27,__zero_reg__
 8559 3114 01F0      		breq .L583
 8560               	.LVL674:
2015:switcherator.c ****                 tempStuff[y] = timeLimits[x][y];
 8561               		.loc 1 2015 0 discriminator 1
 8562 3116 2081      		ld r18,Z
 8563 3118 2983      		std Y+1,r18
 8564               	.LVL675:
 8565 311a 2481      		ldd r18,Z+4
 8566 311c 2A83      		std Y+2,r18
 8567               	.LVL676:
 8568 311e 8B83      		std Y+3,r24
 8569               	.LVL677:
2017:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, INPUT_BYTES);
 8570               		.loc 1 2017 0 discriminator 1
 8571 3120 4AE0      		ldi r20,lo8(10)
 8572 3122 50E0      		ldi r21,0
 8573 3124 B701      		movw r22,r14
 8574 3126 CE01      		movw r24,r28
 8575 3128 0196      		adiw r24,1
 8576 312a 0E94 0000 		call writeEEPROM
 8577               	.LVL678:
 8578               	.L583:
 8579 312e 045F      		subi r16,-12
 8580 3130 1F4F      		sbci r17,-1
 8581 3132 F5E0      		ldi r31,5
 8582 3134 EF0E      		add r14,r31
 8583 3136 F11C      		adc r15,__zero_reg__
2011:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++) {
 8584               		.loc 1 2011 0
 8585 3138 8EE7      		ldi r24,126
 8586 313a E816      		cp r14,r24
 8587 313c F104      		cpc r15,__zero_reg__
 8588 313e 01F4      		brne .L584
 8589               	.LVL679:
2024:switcherator.c ****     if (pwmValues[0] != 0 || pwmValues[1] != 0 || pwmValues[2] != 0) {
 8590               		.loc 1 2024 0
 8591 3140 8091 0000 		lds r24,pwmValues
 8592 3144 8111      		cpse r24,__zero_reg__
 8593 3146 00C0      		rjmp .L585
2024:switcherator.c ****     if (pwmValues[0] != 0 || pwmValues[1] != 0 || pwmValues[2] != 0) {
 8594               		.loc 1 2024 0 is_stmt 0 discriminator 1
 8595 3148 9091 0000 		lds r25,pwmValues+1
 8596 314c 9923      		tst r25
 8597 314e 01F0      		breq .L586
 8598               	.L585:
 8599               	.LVL680:
2026:switcherator.c ****             tempStuff[y] = pwmValues[y];
 8600               		.loc 1 2026 0 is_stmt 1 discriminator 1
 8601 3150 8983      		std Y+1,r24
 8602               	.LVL681:
 8603 3152 8091 0000 		lds r24,pwmValues+1
 8604 3156 8A83      		std Y+2,r24
 8605               	.LVL682:
 8606 3158 8091 0000 		lds r24,pwmValues+2
 8607 315c 8B83      		std Y+3,r24
 8608               	.LVL683:
2028:switcherator.c ****         writeEEPROM(tempStuff, memoryMarker, PWM_VALUE_BYTES);
 8609               		.loc 1 2028 0 discriminator 1
 8610 315e 45E0      		ldi r20,lo8(5)
 8611 3160 50E0      		ldi r21,0
 8612 3162 6EE7      		ldi r22,lo8(126)
 8613 3164 70E0      		ldi r23,0
 8614 3166 CE01      		movw r24,r28
 8615 3168 0196      		adiw r24,1
 8616 316a 0E94 0000 		call writeEEPROM
 8617               	.LVL684:
 8618               	.L588:
 8619 316e A0E0      		ldi r26,lo8(inputs+2)
 8620 3170 EA2E      		mov r14,r26
 8621 3172 A0E0      		ldi r26,hi8(inputs+2)
 8622 3174 FA2E      		mov r15,r26
2000:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 8623               		.loc 1 2000 0 discriminator 1
 8624 3176 03E8      		ldi r16,lo8(-125)
 8625 3178 10E0      		ldi r17,0
 8626 317a 00C0      		rjmp .L587
 8627               	.LVL685:
 8628               	.L586:
2024:switcherator.c ****     if (pwmValues[0] != 0 || pwmValues[1] != 0 || pwmValues[2] != 0) {
 8629               		.loc 1 2024 0 discriminator 1
 8630 317c 9091 0000 		lds r25,pwmValues+2
 8631 3180 9111      		cpse r25,__zero_reg__
 8632 3182 00C0      		rjmp .L585
 8633 3184 00C0      		rjmp .L588
 8634               	.LVL686:
 8635               	.L587:
2033:switcherator.c ****         memoryMarker = (COLOR_CHANGE + (x * COLOR_CHANGE_BYTES));
 8636               		.loc 1 2033 0
 8637 3186 B801      		movw r22,r16
 8638               	.LVL687:
2034:switcherator.c ****         if (colorChanges[0][0] != 0 || colorChanges[0][1] != 1 || colorChanges[0][2] != 0) {
 8639               		.loc 1 2034 0
 8640 3188 8091 0000 		lds r24,colorChanges
 8641 318c 8111      		cpse r24,__zero_reg__
 8642 318e 00C0      		rjmp .L589
2034:switcherator.c ****         if (colorChanges[0][0] != 0 || colorChanges[0][1] != 1 || colorChanges[0][2] != 0) {
 8643               		.loc 1 2034 0 is_stmt 0 discriminator 1
 8644 3190 8091 0000 		lds r24,colorChanges+1
 8645 3194 8130      		cpi r24,lo8(1)
 8646 3196 01F0      		breq .L590
 8647               	.L589:
 8648               	.LVL688:
1914:switcherator.c **** void saveToEEPROM(void) {
 8649               		.loc 1 1914 0 is_stmt 1 discriminator 1
 8650 3198 F701      		movw r30,r14
 8651 319a 3297      		sbiw r30,2
2036:switcherator.c ****                 tempStuff[y] = inputs[x][y];
 8652               		.loc 1 2036 0 discriminator 1
 8653 319c 8081      		ld r24,Z
 8654 319e 8983      		std Y+1,r24
 8655               	.LVL689:
1914:switcherator.c **** void saveToEEPROM(void) {
 8656               		.loc 1 1914 0 discriminator 1
 8657 31a0 F701      		movw r30,r14
 8658 31a2 3197      		sbiw r30,1
2036:switcherator.c ****                 tempStuff[y] = inputs[x][y];
 8659               		.loc 1 2036 0 discriminator 1
 8660 31a4 8081      		ld r24,Z
 8661 31a6 8A83      		std Y+2,r24
 8662               	.LVL690:
 8663 31a8 F701      		movw r30,r14
 8664 31aa 8081      		ld r24,Z
 8665 31ac 8B83      		std Y+3,r24
 8666               	.LVL691:
2038:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, COLOR_CHANGE_BYTES);
 8667               		.loc 1 2038 0 discriminator 1
 8668 31ae 45E0      		ldi r20,lo8(5)
 8669 31b0 50E0      		ldi r21,0
 8670 31b2 CE01      		movw r24,r28
 8671 31b4 0196      		adiw r24,1
 8672 31b6 0E94 0000 		call writeEEPROM
 8673               	.LVL692:
 8674 31ba 00C0      		rjmp .L591
 8675               	.LVL693:
 8676               	.L590:
2034:switcherator.c ****         if (colorChanges[0][0] != 0 || colorChanges[0][1] != 1 || colorChanges[0][2] != 0) {
 8677               		.loc 1 2034 0 discriminator 1
 8678 31bc 8091 0000 		lds r24,colorChanges+2
 8679 31c0 8111      		cpse r24,__zero_reg__
 8680 31c2 00C0      		rjmp .L589
 8681               	.LVL694:
 8682               	.L591:
 8683 31c4 F8E0      		ldi r31,8
 8684 31c6 EF0E      		add r14,r31
 8685 31c8 F11C      		adc r15,__zero_reg__
 8686 31ca 0B5F      		subi r16,-5
 8687 31cc 1F4F      		sbci r17,-1
2032:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 8688               		.loc 1 2032 0
 8689 31ce 013A      		cpi r16,-95
 8690 31d0 1105      		cpc r17,__zero_reg__
 8691 31d2 01F4      		brne .L587
2041:switcherator.c ****     ok();
 8692               		.loc 1 2041 0
 8693 31d4 0E94 0000 		call ok
 8694               	.LVL695:
 8695               	/* epilogue start */
2042:switcherator.c **** }
 8696               		.loc 1 2042 0
 8697 31d8 2E96      		adiw r28,14
 8698 31da 0FB6      		in __tmp_reg__,__SREG__
 8699 31dc F894      		cli
 8700 31de DEBF      		out __SP_H__,r29
 8701 31e0 0FBE      		out __SREG__,__tmp_reg__
 8702 31e2 CDBF      		out __SP_L__,r28
 8703 31e4 DF91      		pop r29
 8704 31e6 CF91      		pop r28
 8705 31e8 1F91      		pop r17
 8706 31ea 0F91      		pop r16
 8707 31ec FF90      		pop r15
 8708 31ee EF90      		pop r14
 8709 31f0 DF90      		pop r13
 8710 31f2 CF90      		pop r12
 8711 31f4 BF90      		pop r11
 8712 31f6 0895      		ret
 8713               	.LFE45:
 8715               	.global	pwmValueSet
 8717               	pwmValueSet:
 8718               	.LFB24:
 932:switcherator.c **** void pwmValueSet(char * commandReceived) {
 8719               		.loc 1 932 0
 8720               	.LVL696:
 8721 31f8 CF92      		push r12
 8722               	.LCFI201:
 8723 31fa DF92      		push r13
 8724               	.LCFI202:
 8725 31fc EF92      		push r14
 8726               	.LCFI203:
 8727 31fe FF92      		push r15
 8728               	.LCFI204:
 8729 3200 0F93      		push r16
 8730               	.LCFI205:
 8731 3202 1F93      		push r17
 8732               	.LCFI206:
 8733 3204 CF93      		push r28
 8734               	.LCFI207:
 8735 3206 DF93      		push r29
 8736               	.LCFI208:
 8737               	/* prologue: function */
 8738               	/* frame size = 0 */
 8739               	/* stack size = 8 */
 8740               	.L__stack_usage = 8
 8741 3208 EC01      		movw r28,r24
 933:switcherator.c ****     tempLongString[3] = 0;
 8742               		.loc 1 933 0
 8743 320a 1092 0000 		sts tempLongString+3,__zero_reg__
 934:switcherator.c ****     tempLongString[0] = commandReceived[6];
 8744               		.loc 1 934 0
 8745 320e 90E0      		ldi r25,lo8(tempLongString)
 8746 3210 C92E      		mov r12,r25
 8747 3212 90E0      		ldi r25,hi8(tempLongString)
 8748 3214 D92E      		mov r13,r25
 8749 3216 8E81      		ldd r24,Y+6
 8750               	.LVL697:
 8751 3218 F601      		movw r30,r12
 8752 321a 8083      		st Z,r24
 935:switcherator.c ****     tempLongString[1] = commandReceived[7];
 8753               		.loc 1 935 0
 8754 321c 20E0      		ldi r18,lo8(tempLongString+1)
 8755 321e E22E      		mov r14,r18
 8756 3220 20E0      		ldi r18,hi8(tempLongString+1)
 8757 3222 F22E      		mov r15,r18
 8758 3224 8F81      		ldd r24,Y+7
 8759 3226 F701      		movw r30,r14
 8760 3228 8083      		st Z,r24
 936:switcherator.c ****     tempLongString[2] = commandReceived[8];
 8761               		.loc 1 936 0
 8762 322a 00E0      		ldi r16,lo8(tempLongString+2)
 8763 322c 10E0      		ldi r17,hi8(tempLongString+2)
 8764 322e 8885      		ldd r24,Y+8
 8765 3230 F801      		movw r30,r16
 8766 3232 8083      		st Z,r24
 937:switcherator.c ****     pwmValues[0] = atoi(tempLongString);
 8767               		.loc 1 937 0
 8768 3234 C601      		movw r24,r12
 8769 3236 0E94 0000 		call atoi
 8770               	.LVL698:
 8771 323a 8093 0000 		sts pwmValues,r24
 938:switcherator.c ****     tempLongString[0] = commandReceived[10];
 8772               		.loc 1 938 0
 8773 323e 8A85      		ldd r24,Y+10
 8774 3240 F601      		movw r30,r12
 8775 3242 8083      		st Z,r24
 939:switcherator.c ****     tempLongString[1] = commandReceived[11];
 8776               		.loc 1 939 0
 8777 3244 8B85      		ldd r24,Y+11
 8778 3246 F701      		movw r30,r14
 8779 3248 8083      		st Z,r24
 940:switcherator.c ****     tempLongString[2] = commandReceived[12];
 8780               		.loc 1 940 0
 8781 324a 8C85      		ldd r24,Y+12
 8782 324c F801      		movw r30,r16
 8783 324e 8083      		st Z,r24
 941:switcherator.c ****     pwmValues[1] = atoi(tempLongString);
 8784               		.loc 1 941 0
 8785 3250 C601      		movw r24,r12
 8786 3252 0E94 0000 		call atoi
 8787               	.LVL699:
 8788 3256 8093 0000 		sts pwmValues+1,r24
 942:switcherator.c ****     tempLongString[0] = commandReceived[14];
 8789               		.loc 1 942 0
 8790 325a 8E85      		ldd r24,Y+14
 8791 325c F601      		movw r30,r12
 8792 325e 8083      		st Z,r24
 943:switcherator.c ****     tempLongString[1] = commandReceived[15];
 8793               		.loc 1 943 0
 8794 3260 8F85      		ldd r24,Y+15
 8795 3262 F701      		movw r30,r14
 8796 3264 8083      		st Z,r24
 944:switcherator.c ****     tempLongString[2] = commandReceived[16];
 8797               		.loc 1 944 0
 8798 3266 8889      		ldd r24,Y+16
 8799 3268 F801      		movw r30,r16
 8800 326a 8083      		st Z,r24
 945:switcherator.c ****     pwmValues[2] = atoi(tempLongString);
 8801               		.loc 1 945 0
 8802 326c C601      		movw r24,r12
 8803 326e 0E94 0000 		call atoi
 8804               	.LVL700:
 8805 3272 8093 0000 		sts pwmValues+2,r24
 946:switcherator.c ****     statusMsg[0] = 0;
 8806               		.loc 1 946 0
 8807 3276 1092 0000 		sts statusMsg,__zero_reg__
 8808               	/* epilogue start */
 948:switcherator.c **** }
 8809               		.loc 1 948 0
 8810 327a DF91      		pop r29
 8811 327c CF91      		pop r28
 8812               	.LVL701:
 8813 327e 1F91      		pop r17
 8814 3280 0F91      		pop r16
 8815 3282 FF90      		pop r15
 8816 3284 EF90      		pop r14
 8817 3286 DF90      		pop r13
 8818 3288 CF90      		pop r12
 947:switcherator.c ****     ok();
 8819               		.loc 1 947 0
 8820 328a 0C94 0000 		jmp ok
 8821               	.LVL702:
 8822               	.LFE24:
 8824               	.global	setHueSpeed
 8826               	setHueSpeed:
 8827               	.LFB23:
 917:switcherator.c **** void setHueSpeed(char * commandReceived) {
 8828               		.loc 1 917 0
 8829               	.LVL703:
 8830               	/* prologue: function */
 8831               	/* frame size = 0 */
 8832               	/* stack size = 0 */
 8833               	.L__stack_usage = 0
 918:switcherator.c ****     tempIntString[0] = commandReceived[3];
 8834               		.loc 1 918 0
 8835 328e FC01      		movw r30,r24
 8836 3290 2381      		ldd r18,Z+3
 8837 3292 2093 0000 		sts tempIntString,r18
 919:switcherator.c ****     tempIntString[1] = commandReceived[4];
 8838               		.loc 1 919 0
 8839 3296 8481      		ldd r24,Z+4
 8840               	.LVL704:
 8841 3298 8093 0000 		sts tempIntString+1,r24
 8842               	.LVL705:
 921:switcherator.c ****     programNumber = atoi(tempIntString);
 8843               		.loc 1 921 0
 8844 329c 80E0      		ldi r24,lo8(tempIntString)
 8845 329e 90E0      		ldi r25,hi8(tempIntString)
 8846 32a0 0E94 0000 		call atoi
 8847               	.LVL706:
 922:switcherator.c ****     if (programNumber > 0)
 8848               		.loc 1 922 0
 8849 32a4 1816      		cp __zero_reg__,r24
 8850 32a6 1906      		cpc __zero_reg__,r25
 8851 32a8 04F4      		brge .L618
 923:switcherator.c ****         hueSpeed = programNumber;
 8852               		.loc 1 923 0
 8853 32aa 9093 0000 		sts hueSpeed+1,r25
 8854 32ae 8093 0000 		sts hueSpeed,r24
 8855               	.L618:
 924:switcherator.c ****     ok();
 8856               		.loc 1 924 0
 8857 32b2 0C94 0000 		jmp ok
 8858               	.LVL707:
 8859               	.LFE23:
 8861               	.global	cycleHue
 8863               	cycleHue:
 8864               	.LFB22:
 901:switcherator.c **** void cycleHue(char * commandReceived) {
 8865               		.loc 1 901 0
 8866               	.LVL708:
 8867               	/* prologue: function */
 8868               	/* frame size = 0 */
 8869               	/* stack size = 0 */
 8870               	.L__stack_usage = 0
 8871 32b6 FC01      		movw r30,r24
 903:switcherator.c ****     tempLongString[0] = commandReceived[5];
 8872               		.loc 1 903 0
 8873 32b8 8581      		ldd r24,Z+5
 8874               	.LVL709:
 8875 32ba 8093 0000 		sts tempLongString,r24
 904:switcherator.c ****     tempLongString[1] = commandReceived[6];
 8876               		.loc 1 904 0
 8877 32be 8681      		ldd r24,Z+6
 8878 32c0 8093 0000 		sts tempLongString+1,r24
 905:switcherator.c ****     tempLongString[2] = commandReceived[7];
 8879               		.loc 1 905 0
 8880 32c4 8781      		ldd r24,Z+7
 8881 32c6 8093 0000 		sts tempLongString+2,r24
 906:switcherator.c ****     tempLongString[3] = commandReceived[8];
 8882               		.loc 1 906 0
 8883 32ca 8085      		ldd r24,Z+8
 8884 32cc 8093 0000 		sts tempLongString+3,r24
 8885               	.LVL710:
 908:switcherator.c ****     programNumber = atoi(tempLongString);
 8886               		.loc 1 908 0
 8887 32d0 80E0      		ldi r24,lo8(tempLongString)
 8888 32d2 90E0      		ldi r25,hi8(tempLongString)
 8889 32d4 0E94 0000 		call atoi
 8890               	.LVL711:
 909:switcherator.c ****     if (programNumber > 0)
 8891               		.loc 1 909 0
 8892 32d8 1816      		cp __zero_reg__,r24
 8893 32da 1906      		cpc __zero_reg__,r25
 8894 32dc 04F4      		brge .L620
 910:switcherator.c ****         colorChangeSpeed = programNumber;
 8895               		.loc 1 910 0
 8896 32de 9093 0000 		sts colorChangeSpeed+1,r25
 8897 32e2 8093 0000 		sts colorChangeSpeed,r24
 8898               	.L620:
 911:switcherator.c ****     ok();
 8899               		.loc 1 911 0
 8900 32e6 0C94 0000 		jmp ok
 8901               	.LVL712:
 8902               	.LFE22:
 8904               	.global	switchClear
 8906               	switchClear:
 8907               	.LFB14:
 524:switcherator.c **** void switchClear(char * commandReceived) {
 8908               		.loc 1 524 0
 8909               	.LVL713:
 8910               	/* prologue: function */
 8911               	/* frame size = 0 */
 8912               	/* stack size = 0 */
 8913               	.L__stack_usage = 0
 527:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 8914               		.loc 1 527 0
 8915 32ea 0E94 0000 		call getSwitchNumber
 8916               	.LVL714:
 528:switcherator.c ****     clearTheSwitch(switchNumber);
 8917               		.loc 1 528 0
 8918 32ee 0E94 0000 		call clearTheSwitch
 8919               	.LVL715:
 529:switcherator.c ****     ok();
 8920               		.loc 1 529 0
 8921 32f2 0C94 0000 		jmp ok
 8922               	.LVL716:
 8923               	.LFE14:
 8925               		.section	.rodata.str1.1
 8926               	.LC65:
 8927 0133 4375 7272 		.string	"Curr Tweak:"
 8927      2054 7765 
 8927      616B 3A00 
 8928               		.text
 8929               	.global	clockTweak
 8931               	clockTweak:
 8932               	.LFB60:
2586:switcherator.c **** void clockTweak(char * commandReceived) {
 8933               		.loc 1 2586 0
 8934               	.LVL717:
 8935               	/* prologue: function */
 8936               	/* frame size = 0 */
 8937               	/* stack size = 0 */
 8938               	.L__stack_usage = 0
 8939 32f6 FC01      		movw r30,r24
 8940               	.LVL718:
2589:switcherator.c ****         tempLongString[x] = commandReceived[(x + 3)];
 8941               		.loc 1 2589 0
 8942 32f8 8381      		ldd r24,Z+3
 8943               	.LVL719:
 8944 32fa 8093 0000 		sts tempLongString,r24
 8945               	.LVL720:
 8946 32fe 8481      		ldd r24,Z+4
 8947 3300 8093 0000 		sts tempLongString+1,r24
 8948               	.LVL721:
 8949 3304 8581      		ldd r24,Z+5
 8950 3306 8093 0000 		sts tempLongString+2,r24
 8951               	.LVL722:
 8952 330a 8681      		ldd r24,Z+6
 8953 330c 8093 0000 		sts tempLongString+3,r24
 8954               	.LVL723:
2591:switcherator.c ****     int adjustment = atoi(tempLongString);
 8955               		.loc 1 2591 0
 8956 3310 80E0      		ldi r24,lo8(tempLongString)
 8957 3312 90E0      		ldi r25,hi8(tempLongString)
 8958 3314 0E94 0000 		call atoi
 8959               	.LVL724:
2592:switcherator.c ****     if (adjustment == 0) {
 8960               		.loc 1 2592 0
 8961 3318 0097      		sbiw r24,0
 8962 331a 01F4      		brne .L623
2593:switcherator.c ****         itoa(tweakTimer, tempLongString, 10);
 8963               		.loc 1 2593 0
 8964 331c 4AE0      		ldi r20,lo8(10)
 8965 331e 50E0      		ldi r21,0
 8966 3320 60E0      		ldi r22,lo8(tempLongString)
 8967 3322 70E0      		ldi r23,hi8(tempLongString)
 8968 3324 8091 0000 		lds r24,tweakTimer
 8969 3328 9091 0000 		lds r25,tweakTimer+1
 8970               	.LVL725:
 8971 332c 0E94 0000 		call itoa
 8972               	.LVL726:
2594:switcherator.c ****         statusMsg[0] = 0;
 8973               		.loc 1 2594 0
 8974 3330 1092 0000 		sts statusMsg,__zero_reg__
2595:switcherator.c ****         strcat(statusMsg, "Curr Tweak:");
 8975               		.loc 1 2595 0
 8976 3334 60E0      		ldi r22,lo8(.LC65)
 8977 3336 70E0      		ldi r23,hi8(.LC65)
 8978 3338 80E0      		ldi r24,lo8(statusMsg)
 8979 333a 90E0      		ldi r25,hi8(statusMsg)
 8980 333c 0E94 0000 		call strcat
 8981               	.LVL727:
2596:switcherator.c ****         strcat(statusMsg, tempLongString);
 8982               		.loc 1 2596 0
 8983 3340 60E0      		ldi r22,lo8(tempLongString)
 8984 3342 70E0      		ldi r23,hi8(tempLongString)
 8985 3344 80E0      		ldi r24,lo8(statusMsg)
 8986 3346 90E0      		ldi r25,hi8(statusMsg)
 8987 3348 0E94 0000 		call strcat
 8988               	.LVL728:
2597:switcherator.c ****         sendMessage(statusMsg);
 8989               		.loc 1 2597 0
 8990 334c 80E0      		ldi r24,lo8(statusMsg)
 8991 334e 90E0      		ldi r25,hi8(statusMsg)
 8992 3350 0C94 0000 		jmp sendMessage
 8993               	.LVL729:
 8994               	.L623:
2600:switcherator.c ****     tweakTimer += adjustment;
 8995               		.loc 1 2600 0
 8996 3354 AA27      		clr r26
 8997 3356 97FD      		sbrc r25,7
 8998 3358 A095      		com r26
 8999 335a BA2F      		mov r27,r26
 9000 335c 4091 0000 		lds r20,tweakTimer
 9001 3360 5091 0000 		lds r21,tweakTimer+1
 9002 3364 6091 0000 		lds r22,tweakTimer+2
 9003 3368 7091 0000 		lds r23,tweakTimer+3
 9004 336c 480F      		add r20,r24
 9005 336e 591F      		adc r21,r25
 9006 3370 6A1F      		adc r22,r26
 9007 3372 7B1F      		adc r23,r27
 9008 3374 4093 0000 		sts tweakTimer,r20
 9009 3378 5093 0000 		sts tweakTimer+1,r21
 9010 337c 6093 0000 		sts tweakTimer+2,r22
 9011 3380 7093 0000 		sts tweakTimer+3,r23
2601:switcherator.c ****     ok();
 9012               		.loc 1 2601 0
 9013 3384 0C94 0000 		jmp ok
 9014               	.LVL730:
 9015               	.LFE60:
 9017               		.section	.rodata.str1.1
 9018               	.LC66:
 9019 013f 5365 7420 		.string	"Set @"
 9019      4000 
 9020               	.LC67:
 9021 0145 4240 00   		.string	"B@"
 9022               		.text
 9023               	.global	brightnessSet
 9025               	brightnessSet:
 9026               	.LFB29:
1130:switcherator.c **** void brightnessSet(char * commandReceived) {
 9027               		.loc 1 1130 0
 9028               	.LVL731:
 9029               	/* prologue: function */
 9030               	/* frame size = 0 */
 9031               	/* stack size = 0 */
 9032               	.L__stack_usage = 0
1131:switcherator.c ****     int brightValue = getSwitchNumber(commandReceived);
 9033               		.loc 1 1131 0
 9034 3388 0E94 0000 		call getSwitchNumber
 9035               	.LVL732:
 9036 338c 9C01      		movw r18,r24
 9037               	.LVL733:
 9038 338e 8091 0000 		lds r24,oldBright
1132:switcherator.c ****     if (brightValue == 0) {
 9039               		.loc 1 1132 0
 9040 3392 2115      		cp r18,__zero_reg__
 9041 3394 3105      		cpc r19,__zero_reg__
 9042 3396 01F4      		brne .L625
1134:switcherator.c ****         itoa(oldBright, tempIntString, 10);
 9043               		.loc 1 1134 0
 9044 3398 4AE0      		ldi r20,lo8(10)
 9045 339a 50E0      		ldi r21,0
 9046 339c 60E0      		ldi r22,lo8(tempIntString)
 9047 339e 70E0      		ldi r23,hi8(tempIntString)
 9048 33a0 90E0      		ldi r25,0
 9049 33a2 0E94 0000 		call itoa
 9050               	.LVL734:
1135:switcherator.c ****         statusMsg[0] = 0;
 9051               		.loc 1 1135 0
 9052 33a6 1092 0000 		sts statusMsg,__zero_reg__
1136:switcherator.c ****         strcat(statusMsg, "Set @");
 9053               		.loc 1 1136 0
 9054 33aa 60E0      		ldi r22,lo8(.LC66)
 9055 33ac 70E0      		ldi r23,hi8(.LC66)
 9056 33ae 80E0      		ldi r24,lo8(statusMsg)
 9057 33b0 90E0      		ldi r25,hi8(statusMsg)
 9058 33b2 0E94 0000 		call strcat
 9059               	.LVL735:
1137:switcherator.c ****         strcat(statusMsg, tempIntString);
 9060               		.loc 1 1137 0
 9061 33b6 60E0      		ldi r22,lo8(tempIntString)
 9062 33b8 70E0      		ldi r23,hi8(tempIntString)
 9063 33ba 80E0      		ldi r24,lo8(statusMsg)
 9064 33bc 90E0      		ldi r25,hi8(statusMsg)
 9065 33be 0E94 0000 		call strcat
 9066               	.LVL736:
1138:switcherator.c ****         strcat(statusMsg, "B@");
 9067               		.loc 1 1138 0
 9068 33c2 60E0      		ldi r22,lo8(.LC67)
 9069 33c4 70E0      		ldi r23,hi8(.LC67)
 9070 33c6 80E0      		ldi r24,lo8(statusMsg)
 9071 33c8 90E0      		ldi r25,hi8(statusMsg)
 9072 33ca 0E94 0000 		call strcat
 9073               	.LVL737:
1139:switcherator.c ****         itoa(bright, tempIntString, 10);
 9074               		.loc 1 1139 0
 9075 33ce 4AE0      		ldi r20,lo8(10)
 9076 33d0 50E0      		ldi r21,0
 9077 33d2 60E0      		ldi r22,lo8(tempIntString)
 9078 33d4 70E0      		ldi r23,hi8(tempIntString)
 9079 33d6 8091 0000 		lds r24,bright
 9080 33da 9091 0000 		lds r25,bright+1
 9081 33de 0E94 0000 		call itoa
 9082               	.LVL738:
1140:switcherator.c ****         strcat(statusMsg, tempIntString);
 9083               		.loc 1 1140 0
 9084 33e2 60E0      		ldi r22,lo8(tempIntString)
 9085 33e4 70E0      		ldi r23,hi8(tempIntString)
 9086 33e6 80E0      		ldi r24,lo8(statusMsg)
 9087 33e8 90E0      		ldi r25,hi8(statusMsg)
 9088 33ea 0E94 0000 		call strcat
 9089               	.LVL739:
1141:switcherator.c ****         sendMessage(statusMsg);
 9090               		.loc 1 1141 0
 9091 33ee 80E0      		ldi r24,lo8(statusMsg)
 9092 33f0 90E0      		ldi r25,hi8(statusMsg)
 9093 33f2 0C94 0000 		jmp sendMessage
 9094               	.LVL740:
 9095               	.L625:
 9096 33f6 2131      		cpi r18,17
 9097 33f8 3105      		cpc r19,__zero_reg__
 9098 33fa 04F0      		brlt .L626
 9099 33fc 20E1      		ldi r18,lo8(16)
 9100 33fe 30E0      		ldi r19,0
 9101               	.LVL741:
 9102               	.L626:
1145:switcherator.c ****         if (oldBright == bright) {
 9103               		.loc 1 1145 0
 9104 3400 90E0      		ldi r25,0
 9105 3402 4091 0000 		lds r20,bright
 9106 3406 5091 0000 		lds r21,bright+1
 9107 340a 8417      		cp r24,r20
 9108 340c 9507      		cpc r25,r21
 9109 340e 01F4      		brne .L627
1147:switcherator.c ****             bright = brightValue;
 9110               		.loc 1 1147 0
 9111 3410 3093 0000 		sts bright+1,r19
 9112 3414 2093 0000 		sts bright,r18
 9113               	.L627:
1149:switcherator.c ****         oldBright = brightValue;
 9114               		.loc 1 1149 0
 9115 3418 2093 0000 		sts oldBright,r18
1150:switcherator.c ****         switchChanged = 1;
 9116               		.loc 1 1150 0
 9117 341c 81E0      		ldi r24,lo8(1)
 9118 341e 8093 0000 		sts switchChanged,r24
1151:switcherator.c ****         ok();
 9119               		.loc 1 1151 0
 9120 3422 0C94 0000 		jmp ok
 9121               	.LVL742:
 9122               	.LFE29:
 9124               		.section	.rodata.str1.1
 9125               	.LC68:
 9126 0148 6661 696C 		.string	"fail 0x"
 9126      2030 7800 
 9127               		.text
 9128               	.global	fail
 9130               	fail:
 9131               	.LFB10:
 382:switcherator.c **** void fail(int failCode) {
 9132               		.loc 1 382 0
 9133               	.LVL743:
 9134 3426 CF93      		push r28
 9135               	.LCFI209:
 9136 3428 DF93      		push r29
 9137               	.LCFI210:
 9138               	/* prologue: function */
 9139               	/* frame size = 0 */
 9140               	/* stack size = 2 */
 9141               	.L__stack_usage = 2
 9142 342a EC01      		movw r28,r24
 383:switcherator.c ****     statusMsg[0] = 0;
 9143               		.loc 1 383 0
 9144 342c 1092 0000 		sts statusMsg,__zero_reg__
 384:switcherator.c ****     strcat(statusMsg, "fail 0x");
 9145               		.loc 1 384 0
 9146 3430 60E0      		ldi r22,lo8(.LC68)
 9147 3432 70E0      		ldi r23,hi8(.LC68)
 9148 3434 80E0      		ldi r24,lo8(statusMsg)
 9149 3436 90E0      		ldi r25,hi8(statusMsg)
 9150               	.LVL744:
 9151 3438 0E94 0000 		call strcat
 9152               	.LVL745:
 385:switcherator.c ****     returnHex(failCode, tempIntString);
 9153               		.loc 1 385 0
 9154 343c 60E0      		ldi r22,lo8(tempIntString)
 9155 343e 70E0      		ldi r23,hi8(tempIntString)
 9156 3440 CE01      		movw r24,r28
 9157 3442 0E94 0000 		call returnHex
 9158               	.LVL746:
 386:switcherator.c ****     strcat(statusMsg, tempIntString);
 9159               		.loc 1 386 0
 9160 3446 60E0      		ldi r22,lo8(tempIntString)
 9161 3448 70E0      		ldi r23,hi8(tempIntString)
 9162 344a 80E0      		ldi r24,lo8(statusMsg)
 9163 344c 90E0      		ldi r25,hi8(statusMsg)
 9164 344e 0E94 0000 		call strcat
 9165               	.LVL747:
 387:switcherator.c ****     sendMessage(statusMsg);
 9166               		.loc 1 387 0
 9167 3452 80E0      		ldi r24,lo8(statusMsg)
 9168 3454 90E0      		ldi r25,hi8(statusMsg)
 9169               	/* epilogue start */
 388:switcherator.c **** }
 9170               		.loc 1 388 0
 9171 3456 DF91      		pop r29
 9172 3458 CF91      		pop r28
 9173               	.LVL748:
 387:switcherator.c ****     sendMessage(statusMsg);
 9174               		.loc 1 387 0
 9175 345a 0C94 0000 		jmp sendMessage
 9176               	.LVL749:
 9177               	.LFE10:
 9179               	.global	setDigitalInput
 9181               	setDigitalInput:
 9182               	.LFB78:
3171:switcherator.c **** void setDigitalInput(char * commandReceived) {
 9183               		.loc 1 3171 0
 9184               	.LVL750:
 9185 345e 5F92      		push r5
 9186               	.LCFI211:
 9187 3460 6F92      		push r6
 9188               	.LCFI212:
 9189 3462 7F92      		push r7
 9190               	.LCFI213:
 9191 3464 8F92      		push r8
 9192               	.LCFI214:
 9193 3466 9F92      		push r9
 9194               	.LCFI215:
 9195 3468 AF92      		push r10
 9196               	.LCFI216:
 9197 346a BF92      		push r11
 9198               	.LCFI217:
 9199 346c CF92      		push r12
 9200               	.LCFI218:
 9201 346e DF92      		push r13
 9202               	.LCFI219:
 9203 3470 EF92      		push r14
 9204               	.LCFI220:
 9205 3472 FF92      		push r15
 9206               	.LCFI221:
 9207 3474 0F93      		push r16
 9208               	.LCFI222:
 9209 3476 1F93      		push r17
 9210               	.LCFI223:
 9211 3478 CF93      		push r28
 9212               	.LCFI224:
 9213 347a DF93      		push r29
 9214               	.LCFI225:
 9215               	/* prologue: function */
 9216               	/* frame size = 0 */
 9217               	/* stack size = 15 */
 9218               	.L__stack_usage = 15
 9219 347c EC01      		movw r28,r24
 9220               	.LVL751:
3180:switcherator.c ****     tempIntString[0] = commandReceived[3];
 9221               		.loc 1 3180 0
 9222 347e 8B81      		ldd r24,Y+3
 9223               	.LVL752:
 9224 3480 8093 0000 		sts tempIntString,r24
3181:switcherator.c ****     tempIntString[1] = commandReceived[4];
 9225               		.loc 1 3181 0
 9226 3484 8C81      		ldd r24,Y+4
 9227 3486 8093 0000 		sts tempIntString+1,r24
3182:switcherator.c ****     inputNumber = atoi(tempIntString);
 9228               		.loc 1 3182 0
 9229 348a 80E0      		ldi r24,lo8(tempIntString)
 9230 348c 90E0      		ldi r25,hi8(tempIntString)
 9231 348e 0E94 0000 		call atoi
 9232               	.LVL753:
 9233 3492 7C01      		movw r14,r24
 9234               	.LVL754:
3183:switcherator.c ****     if (inputNumber >= NUM_INPUTS) {
 9235               		.loc 1 3183 0
 9236 3494 84E0      		ldi r24,4
 9237 3496 E816      		cp r14,r24
 9238 3498 F104      		cpc r15,__zero_reg__
 9239 349a 04F0      		brlt .L630
3184:switcherator.c ****         fail(0x11);
 9240               		.loc 1 3184 0
 9241 349c 81E1      		ldi r24,lo8(17)
 9242 349e 90E0      		ldi r25,0
 9243 34a0 00C0      		rjmp .L667
 9244               	.L630:
3187:switcherator.c ****     tempIntString[0] = '0';
 9245               		.loc 1 3187 0
 9246 34a2 80E3      		ldi r24,lo8(48)
 9247 34a4 8093 0000 		sts tempIntString,r24
3188:switcherator.c ****     tempIntString[1] = commandReceived[6];
 9248               		.loc 1 3188 0
 9249 34a8 8E81      		ldd r24,Y+6
 9250 34aa 8093 0000 		sts tempIntString+1,r24
3189:switcherator.c ****     pin = atoi(tempIntString);
 9251               		.loc 1 3189 0
 9252 34ae 80E0      		ldi r24,lo8(tempIntString)
 9253 34b0 90E0      		ldi r25,hi8(tempIntString)
 9254 34b2 0E94 0000 		call atoi
 9255               	.LVL755:
 9256 34b6 6C01      		movw r12,r24
 9257               	.LVL756:
3190:switcherator.c ****     if (pin > 7) {
 9258               		.loc 1 3190 0
 9259 34b8 E7E0      		ldi r30,lo8(7)
 9260 34ba E817      		cp r30,r24
 9261 34bc 00F4      		brsh .L631
3191:switcherator.c ****         fail(0x04);
 9262               		.loc 1 3191 0
 9263 34be 84E0      		ldi r24,lo8(4)
 9264 34c0 90E0      		ldi r25,0
 9265               	.LVL757:
 9266               	.L667:
 9267               	/* epilogue start */
3305:switcherator.c **** }
 9268               		.loc 1 3305 0
 9269 34c2 DF91      		pop r29
 9270 34c4 CF91      		pop r28
 9271               	.LVL758:
 9272 34c6 1F91      		pop r17
 9273 34c8 0F91      		pop r16
 9274 34ca FF90      		pop r15
 9275 34cc EF90      		pop r14
 9276               	.LVL759:
 9277 34ce DF90      		pop r13
 9278 34d0 CF90      		pop r12
 9279 34d2 BF90      		pop r11
 9280 34d4 AF90      		pop r10
 9281 34d6 9F90      		pop r9
 9282 34d8 8F90      		pop r8
 9283 34da 7F90      		pop r7
 9284 34dc 6F90      		pop r6
 9285 34de 5F90      		pop r5
3191:switcherator.c ****         fail(0x04);
 9286               		.loc 1 3191 0
 9287 34e0 0C94 0000 		jmp fail
 9288               	.LVL760:
 9289               	.L631:
3195:switcherator.c ****     tempIntString[0] = commandReceived[9];
 9290               		.loc 1 3195 0
 9291 34e4 8985      		ldd r24,Y+9
 9292 34e6 8093 0000 		sts tempIntString,r24
3196:switcherator.c ****     tempIntString[1] = commandReceived[10];
 9293               		.loc 1 3196 0
 9294 34ea 8A85      		ldd r24,Y+10
 9295 34ec 8093 0000 		sts tempIntString+1,r24
3197:switcherator.c ****     switchNumber = atoi(tempIntString);
 9296               		.loc 1 3197 0
 9297 34f0 80E0      		ldi r24,lo8(tempIntString)
 9298 34f2 90E0      		ldi r25,hi8(tempIntString)
 9299 34f4 0E94 0000 		call atoi
 9300               	.LVL761:
 9301 34f8 8C01      		movw r16,r24
 9302               	.LVL762:
3199:switcherator.c ****     tempIntString[0] = commandReceived[15];
 9303               		.loc 1 3199 0
 9304 34fa 8F85      		ldd r24,Y+15
 9305 34fc 8093 0000 		sts tempIntString,r24
3200:switcherator.c ****     tempIntString[1] = commandReceived[16];
 9306               		.loc 1 3200 0
 9307 3500 8889      		ldd r24,Y+16
 9308 3502 8093 0000 		sts tempIntString+1,r24
3201:switcherator.c ****     pollTime = atoi(tempIntString);
 9309               		.loc 1 3201 0
 9310 3506 80E0      		ldi r24,lo8(tempIntString)
 9311 3508 90E0      		ldi r25,hi8(tempIntString)
 9312 350a 0E94 0000 		call atoi
 9313               	.LVL763:
 9314 350e 4C01      		movw r8,r24
 9315               	.LVL764:
3203:switcherator.c ****     tempLongString[0] = commandReceived[11];
 9316               		.loc 1 3203 0
 9317 3510 8B85      		ldd r24,Y+11
 9318 3512 8093 0000 		sts tempLongString,r24
3204:switcherator.c ****     tempLongString[1] = commandReceived[12];
 9319               		.loc 1 3204 0
 9320 3516 8C85      		ldd r24,Y+12
 9321 3518 8093 0000 		sts tempLongString+1,r24
3205:switcherator.c ****     tempLongString[2] = commandReceived[13];
 9322               		.loc 1 3205 0
 9323 351c 8D85      		ldd r24,Y+13
 9324 351e 8093 0000 		sts tempLongString+2,r24
3206:switcherator.c ****     tempLongString[3] = commandReceived[14];
 9325               		.loc 1 3206 0
 9326 3522 8E85      		ldd r24,Y+14
 9327 3524 8093 0000 		sts tempLongString+3,r24
3207:switcherator.c ****     duration = atoi(tempLongString);
 9328               		.loc 1 3207 0
 9329 3528 80E0      		ldi r24,lo8(tempLongString)
 9330 352a 90E0      		ldi r25,hi8(tempLongString)
 9331 352c 0E94 0000 		call atoi
 9332               	.LVL765:
 9333 3530 582E      		mov r5,r24
 9334               	.LVL766:
3209:switcherator.c ****     if (commandReceived[8] == 'P' || commandReceived[8] == 'p') {
 9335               		.loc 1 3209 0
 9336 3532 2885      		ldd r18,Y+8
 9337 3534 2035      		cpi r18,lo8(80)
 9338 3536 01F0      		breq .L632
3209:switcherator.c ****     if (commandReceived[8] == 'P' || commandReceived[8] == 'p') {
 9339               		.loc 1 3209 0 is_stmt 0 discriminator 1
 9340 3538 2037      		cpi r18,lo8(112)
 9341 353a 01F4      		brne .L633
 9342               	.L632:
3210:switcherator.c ****         switchNumber += 128;
 9343               		.loc 1 3210 0 is_stmt 1
 9344 353c 0058      		subi r16,-128
 9345 353e 1F4F      		sbci r17,-1
 9346               	.LVL767:
 9347               	.L633:
3212:switcherator.c ****     temp = pin * 2;
 9348               		.loc 1 3212 0
 9349 3540 B601      		movw r22,r12
 9350 3542 7727      		clr r23
 9351 3544 9B01      		movw r18,r22
 9352 3546 220F      		lsl r18
 9353 3548 331F      		rol r19
 9354               	.LVL768:
3213:switcherator.c ****     if (commandReceived[5] == 'B' || commandReceived[5] == 'b') {
 9355               		.loc 1 3213 0
 9356 354a 4D81      		ldd r20,Y+5
 9357 354c 4234      		cpi r20,lo8(66)
 9358 354e 01F0      		breq .L634
3213:switcherator.c ****     if (commandReceived[5] == 'B' || commandReceived[5] == 'b') {
 9359               		.loc 1 3213 0 is_stmt 0 discriminator 1
 9360 3550 4236      		cpi r20,lo8(98)
 9361 3552 01F4      		brne .L635
 9362               	.L634:
 9363               	.LVL769:
3216:switcherator.c ****         temp += 16;
 9364               		.loc 1 3216 0 is_stmt 1
 9365 3554 205F      		subi r18,-16
 9366 3556 3F4F      		sbci r19,-1
 9367               	.LVL770:
3215:switcherator.c ****         realPort = &PORTB;
 9368               		.loc 1 3215 0
 9369 3558 A5E2      		ldi r26,lo8(37)
 9370 355a 6A2E      		mov r6,r26
 9371 355c 712C      		mov r7,__zero_reg__
3214:switcherator.c ****         realDDR = &DDRB;
 9372               		.loc 1 3214 0
 9373 355e A4E2      		ldi r26,lo8(36)
 9374 3560 B0E0      		ldi r27,0
3216:switcherator.c ****         temp += 16;
 9375               		.loc 1 3216 0
 9376 3562 00C0      		rjmp .L636
 9377               	.LVL771:
 9378               	.L635:
3224:switcherator.c ****     } else if (commandReceived[5] == 'C' || commandReceived[5] == 'c') {
 9379               		.loc 1 3224 0
 9380 3564 4334      		cpi r20,lo8(67)
 9381 3566 01F0      		breq .L637
3224:switcherator.c ****     } else if (commandReceived[5] == 'C' || commandReceived[5] == 'c') {
 9382               		.loc 1 3224 0 is_stmt 0 discriminator 1
 9383 3568 4336      		cpi r20,lo8(99)
 9384 356a 01F4      		brne .L638
 9385               	.L637:
 9386               	.LVL772:
3227:switcherator.c ****         temp += 32;
 9387               		.loc 1 3227 0 is_stmt 1
 9388 356c 205E      		subi r18,-32
 9389 356e 3F4F      		sbci r19,-1
 9390               	.LVL773:
3226:switcherator.c ****         realPort = &PORTC;
 9391               		.loc 1 3226 0
 9392 3570 F8E2      		ldi r31,lo8(40)
 9393 3572 6F2E      		mov r6,r31
 9394 3574 712C      		mov r7,__zero_reg__
3225:switcherator.c ****         realDDR = &DDRC;
 9395               		.loc 1 3225 0
 9396 3576 A7E2      		ldi r26,lo8(39)
 9397 3578 B0E0      		ldi r27,0
3227:switcherator.c ****         temp += 32;
 9398               		.loc 1 3227 0
 9399 357a 00C0      		rjmp .L636
 9400               	.LVL774:
 9401               	.L638:
3230:switcherator.c ****     } else if (commandReceived[5] == 'D' || commandReceived[5] == 'd') {
 9402               		.loc 1 3230 0
 9403 357c 4434      		cpi r20,lo8(68)
 9404 357e 01F0      		breq .L639
3230:switcherator.c ****     } else if (commandReceived[5] == 'D' || commandReceived[5] == 'd') {
 9405               		.loc 1 3230 0 is_stmt 0 discriminator 1
 9406 3580 4436      		cpi r20,lo8(100)
 9407 3582 01F4      		brne .L647
 9408               	.L639:
 9409               	.LVL775:
3233:switcherator.c ****         temp += 48;
 9410               		.loc 1 3233 0 is_stmt 1
 9411 3584 205D      		subi r18,-48
 9412 3586 3F4F      		sbci r19,-1
 9413               	.LVL776:
3232:switcherator.c ****         realPort = &PORTD;
 9414               		.loc 1 3232 0
 9415 3588 EBE2      		ldi r30,lo8(43)
 9416 358a 6E2E      		mov r6,r30
 9417 358c 712C      		mov r7,__zero_reg__
3231:switcherator.c ****         realDDR = &DDRD;
 9418               		.loc 1 3231 0
 9419 358e AAE2      		ldi r26,lo8(42)
 9420 3590 B0E0      		ldi r27,0
 9421 3592 00C0      		rjmp .L636
 9422               	.LVL777:
 9423               	.L647:
3175:switcherator.c ****     volatile unsigned char *realPort = 0;
 9424               		.loc 1 3175 0
 9425 3594 612C      		mov r6,__zero_reg__
 9426 3596 712C      		mov r7,__zero_reg__
3174:switcherator.c ****     volatile unsigned char *realDDR = 0;
 9427               		.loc 1 3174 0
 9428 3598 A0E0      		ldi r26,0
 9429 359a B0E0      		ldi r27,0
 9430               	.LVL778:
 9431               	.L636:
 9432 359c 40E0      		ldi r20,lo8(switchStuff)
 9433 359e 50E0      		ldi r21,hi8(switchStuff)
3273:switcherator.c ****         if (switchStuff[x] == temp || switchStuff[x] == (temp + 1)) {
 9434               		.loc 1 3273 0
 9435 35a0 5901      		movw r10,r18
 9436 35a2 FFEF      		ldi r31,-1
 9437 35a4 AF1A      		sub r10,r31
 9438 35a6 BF0A      		sbc r11,r31
 9439               	.LVL779:
 9440               	.L642:
 9441 35a8 FA01      		movw r30,r20
 9442 35aa C190      		ld r12,Z+
 9443 35ac AF01      		movw r20,r30
 9444 35ae D12C      		mov r13,__zero_reg__
 9445 35b0 C216      		cp r12,r18
 9446 35b2 D306      		cpc r13,r19
 9447 35b4 01F0      		breq .L640
3273:switcherator.c ****         if (switchStuff[x] == temp || switchStuff[x] == (temp + 1)) {
 9448               		.loc 1 3273 0 is_stmt 0 discriminator 1
 9449 35b6 CA14      		cp r12,r10
 9450 35b8 DB04      		cpc r13,r11
 9451 35ba 01F4      		brne .L641
 9452               	.L640:
3274:switcherator.c ****             fail(0x12);
 9453               		.loc 1 3274 0 is_stmt 1
 9454 35bc 82E1      		ldi r24,lo8(18)
 9455 35be 90E0      		ldi r25,0
 9456 35c0 00C0      		rjmp .L667
 9457               	.L641:
3272:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 9458               		.loc 1 3272 0
 9459 35c2 F0E0      		ldi r31,hi8(switchStuff+16)
 9460 35c4 4030      		cpi r20,lo8(switchStuff+16)
 9461 35c6 5F07      		cpc r21,r31
 9462 35c8 01F4      		brne .L642
3279:switcherator.c ****     inputs[inputNumber][0] = temp;
 9463               		.loc 1 3279 0
 9464 35ca A701      		movw r20,r14
 9465 35cc 33E0      		ldi r19,3
 9466               		1:
 9467 35ce 440F      		lsl r20
 9468 35d0 551F      		rol r21
 9469 35d2 3A95      		dec r19
 9470 35d4 01F4      		brne 1b
 9471 35d6 70E0      		ldi r23,lo8(inputs)
 9472 35d8 E72E      		mov r14,r23
 9473 35da 70E0      		ldi r23,hi8(inputs)
 9474 35dc F72E      		mov r15,r23
 9475               	.LVL780:
 9476 35de E40E      		add r14,r20
 9477 35e0 F51E      		adc r15,r21
 9478 35e2 F701      		movw r30,r14
 9479 35e4 2083      		st Z,r18
3281:switcherator.c ****     if (commandReceived[7] == 'H' || commandReceived[7] == 'h' ||
 9480               		.loc 1 3281 0
 9481 35e6 2F81      		ldd r18,Y+7
 9482               	.LVL781:
 9483 35e8 2834      		cpi r18,lo8(72)
 9484 35ea 01F0      		breq .L643
3281:switcherator.c ****     if (commandReceived[7] == 'H' || commandReceived[7] == 'h' ||
 9485               		.loc 1 3281 0 is_stmt 0 discriminator 1
 9486 35ec 2836      		cpi r18,lo8(104)
 9487 35ee 01F0      		breq .L643
 9488 35f0 2133      		cpi r18,lo8(49)
 9489 35f2 01F4      		brne .L644
 9490               	.L643:
3283:switcherator.c ****         inputs[inputNumber][1] = 0;
 9491               		.loc 1 3283 0 is_stmt 1
 9492 35f4 EA01      		movw r28,r20
 9493               	.LVL782:
 9494 35f6 C050      		subi r28,lo8(-(inputs))
 9495 35f8 D040      		sbci r29,hi8(-(inputs))
 9496 35fa 1982      		std Y+1,__zero_reg__
3284:switcherator.c ****         inputs[inputNumber][2] = 255;
 9497               		.loc 1 3284 0
 9498 35fc 2FEF      		ldi r18,lo8(-1)
 9499 35fe 2A83      		std Y+2,r18
 9500 3600 00C0      		rjmp .L645
 9501               	.LVL783:
 9502               	.L644:
3286:switcherator.c ****         inputs[inputNumber][1] = 255;
 9503               		.loc 1 3286 0
 9504 3602 2FEF      		ldi r18,lo8(-1)
 9505 3604 F701      		movw r30,r14
 9506 3606 2183      		std Z+1,r18
3287:switcherator.c ****         inputs[inputNumber][2] = 0;
 9507               		.loc 1 3287 0
 9508 3608 1282      		std Z+2,__zero_reg__
 9509               	.LVL784:
 9510               	.L645:
3289:switcherator.c ****     inputs[inputNumber][3] = switchNumber;
 9511               		.loc 1 3289 0
 9512 360a EA01      		movw r28,r20
 9513 360c C050      		subi r28,lo8(-(inputs))
 9514 360e D040      		sbci r29,hi8(-(inputs))
 9515 3610 0B83      		std Y+3,r16
 9516               	.LVL785:
3291:switcherator.c ****     inputs[inputNumber][4] = temp;
 9517               		.loc 1 3291 0
 9518 3612 9C83      		std Y+4,r25
 9519               	.LVL786:
3293:switcherator.c ****     inputs[inputNumber][5] = temp;
 9520               		.loc 1 3293 0
 9521 3614 5D82      		std Y+5,r5
 9522               	.LVL787:
3297:switcherator.c ****     inputs[inputNumber][6] = pollTime;
 9523               		.loc 1 3297 0
 9524 3616 9401      		movw r18,r8
 9525 3618 2F3F      		cpi r18,-1
 9526 361a 3105      		cpc r19,__zero_reg__
 9527 361c 01F0      		breq .L646
 9528 361e 04F0      		brlt .L646
 9529 3620 2FEF      		ldi r18,lo8(-1)
 9530 3622 30E0      		ldi r19,0
 9531               	.L646:
 9532 3624 2E83      		std Y+6,r18
3299:switcherator.c ****     *realDDR &= ~(1 << pin);
 9533               		.loc 1 3299 0
 9534 3626 8C91      		ld r24,X
 9535 3628 21E0      		ldi r18,lo8(1)
 9536 362a 30E0      		ldi r19,0
 9537 362c 00C0      		rjmp 2f
 9538               		1:
 9539 362e 220F      		lsl r18
 9540               		2:
 9541 3630 6A95      		dec r22
 9542 3632 02F4      		brpl 1b
 9543 3634 922F      		mov r25,r18
 9544               	.LVL788:
 9545 3636 9095      		com r25
 9546 3638 8923      		and r24,r25
 9547 363a 8C93      		st X,r24
3300:switcherator.c ****     *realPort |= (1 << pin);
 9548               		.loc 1 3300 0
 9549 363c F301      		movw r30,r6
 9550 363e 8081      		ld r24,Z
 9551 3640 822B      		or r24,r18
 9552 3642 8083      		st Z,r24
 9553               	/* epilogue start */
3305:switcherator.c **** }
 9554               		.loc 1 3305 0
 9555 3644 DF91      		pop r29
 9556 3646 CF91      		pop r28
 9557               	.LVL789:
 9558 3648 1F91      		pop r17
 9559 364a 0F91      		pop r16
 9560 364c FF90      		pop r15
 9561 364e EF90      		pop r14
 9562 3650 DF90      		pop r13
 9563 3652 CF90      		pop r12
 9564 3654 BF90      		pop r11
 9565 3656 AF90      		pop r10
 9566 3658 9F90      		pop r9
 9567               	.LVL790:
 9568 365a 8F90      		pop r8
 9569 365c 7F90      		pop r7
 9570 365e 6F90      		pop r6
 9571               	.LVL791:
 9572 3660 5F90      		pop r5
 9573               	.LVL792:
3302:switcherator.c ****     ok();
 9574               		.loc 1 3302 0
 9575 3662 0C94 0000 		jmp ok
 9576               	.LVL793:
 9577               	.LFE78:
 9579               	.global	setAnalogInput
 9581               	setAnalogInput:
 9582               	.LFB77:
3046:switcherator.c **** void setAnalogInput(char * commandReceived) {
 9583               		.loc 1 3046 0
 9584               	.LVL794:
 9585 3666 2F92      		push r2
 9586               	.LCFI226:
 9587 3668 3F92      		push r3
 9588               	.LCFI227:
 9589 366a 4F92      		push r4
 9590               	.LCFI228:
 9591 366c 5F92      		push r5
 9592               	.LCFI229:
 9593 366e 6F92      		push r6
 9594               	.LCFI230:
 9595 3670 7F92      		push r7
 9596               	.LCFI231:
 9597 3672 8F92      		push r8
 9598               	.LCFI232:
 9599 3674 9F92      		push r9
 9600               	.LCFI233:
 9601 3676 AF92      		push r10
 9602               	.LCFI234:
 9603 3678 BF92      		push r11
 9604               	.LCFI235:
 9605 367a CF92      		push r12
 9606               	.LCFI236:
 9607 367c DF92      		push r13
 9608               	.LCFI237:
 9609 367e EF92      		push r14
 9610               	.LCFI238:
 9611 3680 FF92      		push r15
 9612               	.LCFI239:
 9613 3682 0F93      		push r16
 9614               	.LCFI240:
 9615 3684 1F93      		push r17
 9616               	.LCFI241:
 9617 3686 CF93      		push r28
 9618               	.LCFI242:
 9619 3688 DF93      		push r29
 9620               	.LCFI243:
 9621 368a 00D0      		rcall .
 9622 368c 1F92      		push __zero_reg__
 9623               	.LCFI244:
 9624 368e CDB7      		in r28,__SP_L__
 9625 3690 DEB7      		in r29,__SP_H__
 9626               	.LCFI245:
 9627               	/* prologue: function */
 9628               	/* frame size = 3 */
 9629               	/* stack size = 21 */
 9630               	.L__stack_usage = 21
 9631 3692 9B83      		std Y+3,r25
 9632 3694 8A83      		std Y+2,r24
 9633               	.LVL795:
3054:switcherator.c ****     tempIntString[0] = commandReceived[3];
 9634               		.loc 1 3054 0
 9635 3696 DC01      		movw r26,r24
 9636 3698 1396      		adiw r26,3
 9637 369a 8C91      		ld r24,X
 9638 369c 1397      		sbiw r26,3
 9639               	.LVL796:
 9640 369e 8093 0000 		sts tempIntString,r24
3055:switcherator.c ****     tempIntString[1] = commandReceived[4];
 9641               		.loc 1 3055 0
 9642 36a2 1496      		adiw r26,4
 9643 36a4 8C91      		ld r24,X
 9644 36a6 8093 0000 		sts tempIntString+1,r24
3056:switcherator.c ****     inputNumber = atoi(tempIntString);
 9645               		.loc 1 3056 0
 9646 36aa 80E0      		ldi r24,lo8(tempIntString)
 9647 36ac 90E0      		ldi r25,hi8(tempIntString)
 9648 36ae 0E94 0000 		call atoi
 9649               	.LVL797:
 9650 36b2 8C01      		movw r16,r24
 9651               	.LVL798:
3057:switcherator.c ****     if (inputNumber >= NUM_INPUTS) {
 9652               		.loc 1 3057 0
 9653 36b4 8430      		cpi r24,4
 9654 36b6 9105      		cpc r25,__zero_reg__
 9655 36b8 04F0      		brlt .L669
3058:switcherator.c ****         fail(0x11);
 9656               		.loc 1 3058 0
 9657 36ba 81E1      		ldi r24,lo8(17)
 9658 36bc 90E0      		ldi r25,0
 9659 36be 00C0      		rjmp .L690
 9660               	.L669:
3061:switcherator.c ****     tempIntString[0] = '0';
 9661               		.loc 1 3061 0
 9662 36c0 50E3      		ldi r21,lo8(48)
 9663 36c2 B52E      		mov r11,r21
 9664 36c4 B092 0000 		sts tempIntString,r11
3062:switcherator.c ****     tempIntString[1] = commandReceived[6];
 9665               		.loc 1 3062 0
 9666 36c8 EA81      		ldd r30,Y+2
 9667 36ca FB81      		ldd r31,Y+3
 9668 36cc 8681      		ldd r24,Z+6
 9669 36ce 8093 0000 		sts tempIntString+1,r24
3063:switcherator.c ****     pin = atoi(tempIntString);
 9670               		.loc 1 3063 0
 9671 36d2 80E0      		ldi r24,lo8(tempIntString)
 9672 36d4 90E0      		ldi r25,hi8(tempIntString)
 9673 36d6 0E94 0000 		call atoi
 9674               	.LVL799:
 9675 36da 6C01      		movw r12,r24
 9676               	.LVL800:
3064:switcherator.c ****     if (pin > 7) {
 9677               		.loc 1 3064 0
 9678 36dc F7E0      		ldi r31,lo8(7)
 9679 36de F817      		cp r31,r24
 9680 36e0 00F4      		brsh .L670
3065:switcherator.c ****         fail(0x04);
 9681               		.loc 1 3065 0
 9682 36e2 84E0      		ldi r24,lo8(4)
 9683 36e4 90E0      		ldi r25,0
 9684               	.LVL801:
 9685               	.L690:
 9686               	/* epilogue start */
3163:switcherator.c **** }
 9687               		.loc 1 3163 0
 9688 36e6 0F90      		pop __tmp_reg__
 9689 36e8 0F90      		pop __tmp_reg__
 9690 36ea 0F90      		pop __tmp_reg__
 9691 36ec DF91      		pop r29
 9692 36ee CF91      		pop r28
 9693 36f0 1F91      		pop r17
 9694 36f2 0F91      		pop r16
 9695               	.LVL802:
 9696 36f4 FF90      		pop r15
 9697 36f6 EF90      		pop r14
 9698 36f8 DF90      		pop r13
 9699 36fa CF90      		pop r12
 9700 36fc BF90      		pop r11
 9701 36fe AF90      		pop r10
 9702 3700 9F90      		pop r9
 9703 3702 8F90      		pop r8
 9704 3704 7F90      		pop r7
 9705 3706 6F90      		pop r6
 9706 3708 5F90      		pop r5
 9707 370a 4F90      		pop r4
 9708 370c 3F90      		pop r3
 9709 370e 2F90      		pop r2
3065:switcherator.c ****         fail(0x04);
 9710               		.loc 1 3065 0
 9711 3710 0C94 0000 		jmp fail
 9712               	.LVL803:
 9713               	.L670:
3069:switcherator.c ****     tempIntString[0] = commandReceived[14];
 9714               		.loc 1 3069 0
 9715 3714 AA81      		ldd r26,Y+2
 9716 3716 BB81      		ldd r27,Y+3
 9717 3718 1E96      		adiw r26,14
 9718 371a 8C91      		ld r24,X
 9719 371c 1E97      		sbiw r26,14
 9720 371e 8093 0000 		sts tempIntString,r24
3070:switcherator.c ****     tempIntString[1] = commandReceived[15];
 9721               		.loc 1 3070 0
 9722 3722 1F96      		adiw r26,15
 9723 3724 8C91      		ld r24,X
 9724 3726 8093 0000 		sts tempIntString+1,r24
3071:switcherator.c ****     switchNumber = atoi(tempIntString);
 9725               		.loc 1 3071 0
 9726 372a 80E0      		ldi r24,lo8(tempIntString)
 9727 372c 90E0      		ldi r25,hi8(tempIntString)
 9728 372e 0E94 0000 		call atoi
 9729               	.LVL804:
 9730 3732 7C01      		movw r14,r24
 9731               	.LVL805:
3073:switcherator.c ****     tempIntString[0] = commandReceived[20];
 9732               		.loc 1 3073 0
 9733 3734 EA81      		ldd r30,Y+2
 9734 3736 FB81      		ldd r31,Y+3
 9735 3738 8489      		ldd r24,Z+20
 9736 373a 8093 0000 		sts tempIntString,r24
3074:switcherator.c ****     tempIntString[1] = commandReceived[21];
 9737               		.loc 1 3074 0
 9738 373e 8589      		ldd r24,Z+21
 9739 3740 8093 0000 		sts tempIntString+1,r24
3075:switcherator.c ****     pollTime = atoi(tempIntString);
 9740               		.loc 1 3075 0
 9741 3744 80E0      		ldi r24,lo8(tempIntString)
 9742 3746 90E0      		ldi r25,hi8(tempIntString)
 9743 3748 0E94 0000 		call atoi
 9744               	.LVL806:
 9745 374c 782E      		mov r7,r24
 9746 374e 892E      		mov r8,r25
 9747               	.LVL807:
3077:switcherator.c ****     tempIntString[0] = '0';
 9748               		.loc 1 3077 0
 9749 3750 B092 0000 		sts tempIntString,r11
3078:switcherator.c ****     tempIntString[1] = commandReceived[22];
 9750               		.loc 1 3078 0
 9751 3754 AA81      		ldd r26,Y+2
 9752 3756 BB81      		ldd r27,Y+3
 9753 3758 5696      		adiw r26,22
 9754 375a 8C91      		ld r24,X
 9755 375c 8093 0000 		sts tempIntString+1,r24
3079:switcherator.c ****     whichRGB = atoi(tempIntString);
 9756               		.loc 1 3079 0
 9757 3760 80E0      		ldi r24,lo8(tempIntString)
 9758 3762 90E0      		ldi r25,hi8(tempIntString)
 9759 3764 0E94 0000 		call atoi
 9760               	.LVL808:
 9761 3768 982E      		mov r9,r24
 9762               	.LVL809:
3081:switcherator.c ****     tempLongString[0] = '0';
 9763               		.loc 1 3081 0
 9764 376a B092 0000 		sts tempLongString,r11
3082:switcherator.c ****     tempLongString[1] = commandReceived[7];
 9765               		.loc 1 3082 0
 9766 376e EA81      		ldd r30,Y+2
 9767 3770 FB81      		ldd r31,Y+3
 9768 3772 8781      		ldd r24,Z+7
 9769 3774 8093 0000 		sts tempLongString+1,r24
3083:switcherator.c ****     tempLongString[2] = commandReceived[8];
 9770               		.loc 1 3083 0
 9771 3778 8085      		ldd r24,Z+8
 9772 377a 8093 0000 		sts tempLongString+2,r24
3084:switcherator.c ****     tempLongString[3] = commandReceived[9];
 9773               		.loc 1 3084 0
 9774 377e 8185      		ldd r24,Z+9
 9775 3780 8093 0000 		sts tempLongString+3,r24
3085:switcherator.c ****     lowPercent = atoi(tempLongString);
 9776               		.loc 1 3085 0
 9777 3784 80E0      		ldi r24,lo8(tempLongString)
 9778 3786 90E0      		ldi r25,hi8(tempLongString)
 9779 3788 0E94 0000 		call atoi
 9780               	.LVL810:
 9781 378c 5C01      		movw r10,r24
 9782               	.LVL811:
3086:switcherator.c ****     tempLongString[1] = commandReceived[10];
 9783               		.loc 1 3086 0
 9784 378e AA81      		ldd r26,Y+2
 9785 3790 BB81      		ldd r27,Y+3
 9786 3792 1A96      		adiw r26,10
 9787 3794 8C91      		ld r24,X
 9788 3796 1A97      		sbiw r26,10
 9789 3798 8093 0000 		sts tempLongString+1,r24
3087:switcherator.c ****     tempLongString[2] = commandReceived[11];
 9790               		.loc 1 3087 0
 9791 379c 1B96      		adiw r26,11
 9792 379e 8C91      		ld r24,X
 9793 37a0 1B97      		sbiw r26,11
 9794 37a2 8093 0000 		sts tempLongString+2,r24
3088:switcherator.c ****     tempLongString[3] = commandReceived[12];
 9795               		.loc 1 3088 0
 9796 37a6 1C96      		adiw r26,12
 9797 37a8 8C91      		ld r24,X
 9798 37aa 8093 0000 		sts tempLongString+3,r24
3089:switcherator.c ****     highPercent = atoi(tempLongString);
 9799               		.loc 1 3089 0
 9800 37ae 80E0      		ldi r24,lo8(tempLongString)
 9801 37b0 90E0      		ldi r25,hi8(tempLongString)
 9802 37b2 0E94 0000 		call atoi
 9803               	.LVL812:
 9804 37b6 2C01      		movw r4,r24
 9805               	.LVL813:
3091:switcherator.c ****     tempLongString[0] = commandReceived[16];
 9806               		.loc 1 3091 0
 9807 37b8 EA81      		ldd r30,Y+2
 9808 37ba FB81      		ldd r31,Y+3
 9809 37bc 8089      		ldd r24,Z+16
 9810 37be 8093 0000 		sts tempLongString,r24
3092:switcherator.c ****     tempLongString[1] = commandReceived[17];
 9811               		.loc 1 3092 0
 9812 37c2 8189      		ldd r24,Z+17
 9813 37c4 8093 0000 		sts tempLongString+1,r24
3093:switcherator.c ****     tempLongString[2] = commandReceived[18];
 9814               		.loc 1 3093 0
 9815 37c8 8289      		ldd r24,Z+18
 9816 37ca 8093 0000 		sts tempLongString+2,r24
3094:switcherator.c ****     tempLongString[3] = commandReceived[19];
 9817               		.loc 1 3094 0
 9818 37ce 8389      		ldd r24,Z+19
 9819 37d0 8093 0000 		sts tempLongString+3,r24
3095:switcherator.c ****     duration = atoi(tempLongString);
 9820               		.loc 1 3095 0
 9821 37d4 80E0      		ldi r24,lo8(tempLongString)
 9822 37d6 90E0      		ldi r25,hi8(tempLongString)
 9823 37d8 0E94 0000 		call atoi
 9824               	.LVL814:
 9825 37dc 682E      		mov r6,r24
 9826 37de 9983      		std Y+1,r25
 9827               	.LVL815:
3102:switcherator.c ****     if (commandReceived[5] != 'C' && commandReceived[5] != 'c') {
 9828               		.loc 1 3102 0
 9829 37e0 AA81      		ldd r26,Y+2
 9830 37e2 BB81      		ldd r27,Y+3
 9831 37e4 1596      		adiw r26,5
 9832 37e6 8C91      		ld r24,X
 9833 37e8 8334      		cpi r24,lo8(67)
 9834 37ea 01F0      		breq .L671
3102:switcherator.c ****     if (commandReceived[5] != 'C' && commandReceived[5] != 'c') {
 9835               		.loc 1 3102 0 is_stmt 0 discriminator 1
 9836 37ec 8336      		cpi r24,lo8(99)
 9837 37ee 01F0      		breq .L671
3103:switcherator.c ****         fail(0x03);
 9838               		.loc 1 3103 0 is_stmt 1
 9839 37f0 83E0      		ldi r24,lo8(3)
 9840 37f2 90E0      		ldi r25,0
 9841 37f4 00C0      		rjmp .L690
 9842               	.L671:
3113:switcherator.c ****     temp = pin * 2;
 9843               		.loc 1 3113 0
 9844 37f6 DD24      		clr r13
 9845               	.LVL816:
 9846 37f8 C601      		movw r24,r12
 9847 37fa 880F      		lsl r24
 9848 37fc 991F      		rol r25
 9849 37fe AA27      		clr r26
 9850 3800 97FD      		sbrc r25,7
 9851 3802 A095      		com r26
 9852 3804 BA2F      		mov r27,r26
 9853               	.LVL817:
3115:switcherator.c ****     temp += 32;
 9854               		.loc 1 3115 0
 9855 3806 8096      		adiw r24,32
 9856 3808 A11D      		adc r26,__zero_reg__
 9857 380a B11D      		adc r27,__zero_reg__
 9858               	.LVL818:
 9859 380c E0E0      		ldi r30,lo8(switchStuff)
 9860 380e F0E0      		ldi r31,hi8(switchStuff)
 9861               	.LVL819:
 9862               	.L673:
3117:switcherator.c ****         if (switchStuff[x] == temp) {
 9863               		.loc 1 3117 0
 9864 3810 4191      		ld r20,Z+
 9865 3812 50E0      		ldi r21,0
 9866 3814 60E0      		ldi r22,0
 9867 3816 70E0      		ldi r23,0
 9868 3818 4817      		cp r20,r24
 9869 381a 5907      		cpc r21,r25
 9870 381c 6A07      		cpc r22,r26
 9871 381e 7B07      		cpc r23,r27
 9872 3820 01F4      		brne .L672
3119:switcherator.c ****             fail(0x12);
 9873               		.loc 1 3119 0
 9874 3822 82E1      		ldi r24,lo8(18)
 9875 3824 90E0      		ldi r25,0
 9876               	.LVL820:
 9877 3826 00C0      		rjmp .L690
 9878               	.LVL821:
 9879               	.L672:
3116:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 9880               		.loc 1 3116 0
 9881 3828 20E0      		ldi r18,hi8(switchStuff+16)
 9882 382a E030      		cpi r30,lo8(switchStuff+16)
 9883 382c F207      		cpc r31,r18
 9884 382e 01F4      		brne .L673
3123:switcherator.c ****     inputs[inputNumber][0] = temp;
 9885               		.loc 1 3123 0
 9886 3830 93E0      		ldi r25,3
 9887               		1:
 9888 3832 000F      		lsl r16
 9889 3834 111F      		rol r17
 9890 3836 9A95      		dec r25
 9891 3838 01F4      		brne 1b
 9892               	.LVL822:
 9893 383a 20E0      		ldi r18,lo8(inputs)
 9894 383c 222E      		mov r2,r18
 9895 383e 20E0      		ldi r18,hi8(inputs)
 9896 3840 322E      		mov r3,r18
 9897 3842 200E      		add r2,r16
 9898 3844 311E      		adc r3,r17
 9899 3846 F101      		movw r30,r2
 9900 3848 8083      		st Z,r24
3124:switcherator.c ****     DDRC &= ~(1 << pin);
 9901               		.loc 1 3124 0
 9902 384a 27B1      		in r18,0x7
 9903 384c 81E0      		ldi r24,lo8(1)
 9904 384e 90E0      		ldi r25,0
 9905               	.LVL823:
 9906 3850 00C0      		rjmp 2f
 9907               		1:
 9908 3852 880F      		lsl r24
 9909               		2:
 9910 3854 CA94      		dec r12
 9911 3856 02F4      		brpl 1b
 9912 3858 8095      		com r24
 9913 385a 8223      		and r24,r18
 9914 385c 87B9      		out 0x7,r24
 9915               	.LVL824:
3126:switcherator.c ****     temp = temp * 255;
 9916               		.loc 1 3126 0
 9917 385e 2FEF      		ldi r18,lo8(-1)
 9918 3860 30E0      		ldi r19,0
 9919 3862 D501      		movw r26,r10
 9920 3864 0E94 0000 		call __usmulhisi3
 9921               	.LVL825:
3127:switcherator.c ****     temp = temp / 100;
 9922               		.loc 1 3127 0
 9923 3868 34E6      		ldi r19,lo8(100)
 9924 386a A32E      		mov r10,r19
 9925 386c B12C      		mov r11,__zero_reg__
 9926 386e C12C      		mov r12,__zero_reg__
 9927 3870 D12C      		mov r13,__zero_reg__
 9928               	.LVL826:
 9929 3872 A601      		movw r20,r12
 9930 3874 9501      		movw r18,r10
 9931 3876 0E94 0000 		call __divmodsi4
 9932               	.LVL827:
3128:switcherator.c ****     inputs[inputNumber][1] = temp;
 9933               		.loc 1 3128 0
 9934 387a D101      		movw r26,r2
 9935 387c 1196      		adiw r26,1
 9936 387e 2C93      		st X,r18
 9937               	.LVL828:
3130:switcherator.c ****     temp = temp * 255;
 9938               		.loc 1 3130 0
 9939 3880 2FEF      		ldi r18,lo8(-1)
 9940 3882 30E0      		ldi r19,0
 9941 3884 D201      		movw r26,r4
 9942 3886 0E94 0000 		call __usmulhisi3
 9943               	.LVL829:
3131:switcherator.c ****     temp = temp / 100;
 9944               		.loc 1 3131 0
 9945 388a A601      		movw r20,r12
 9946 388c 9501      		movw r18,r10
 9947 388e 0E94 0000 		call __divmodsi4
 9948               	.LVL830:
3132:switcherator.c ****     if (temp == 255) // if the top is 255 we need it to be 254 so its not digital
 9949               		.loc 1 3132 0
 9950 3892 2F3F      		cpi r18,-1
 9951 3894 3105      		cpc r19,__zero_reg__
 9952 3896 4105      		cpc r20,__zero_reg__
 9953 3898 5105      		cpc r21,__zero_reg__
 9954 389a 01F4      		brne .L674
3133:switcherator.c ****         temp = 254;
 9955               		.loc 1 3133 0
 9956 389c 2EEF      		ldi r18,lo8(-2)
 9957 389e 30E0      		ldi r19,0
 9958 38a0 40E0      		ldi r20,0
 9959 38a2 50E0      		ldi r21,0
 9960               	.LVL831:
 9961               	.L674:
3135:switcherator.c ****     inputs[inputNumber][2] = temp;
 9962               		.loc 1 3135 0
 9963 38a4 F801      		movw r30,r16
 9964 38a6 E050      		subi r30,lo8(-(inputs))
 9965 38a8 F040      		sbci r31,hi8(-(inputs))
 9966 38aa 2283      		std Z+2,r18
3137:switcherator.c ****     if (commandReceived[13] == 'P' || commandReceived[13] == 'p') {
 9967               		.loc 1 3137 0
 9968 38ac EA81      		ldd r30,Y+2
 9969 38ae FB81      		ldd r31,Y+3
 9970 38b0 8585      		ldd r24,Z+13
 9971 38b2 8035      		cpi r24,lo8(80)
 9972 38b4 01F0      		breq .L675
3137:switcherator.c ****     if (commandReceived[13] == 'P' || commandReceived[13] == 'p') {
 9973               		.loc 1 3137 0 is_stmt 0 discriminator 1
 9974 38b6 8037      		cpi r24,lo8(112)
 9975 38b8 01F4      		brne .L676
 9976               	.L675:
3138:switcherator.c ****         switchNumber += 128;
 9977               		.loc 1 3138 0 is_stmt 1
 9978 38ba F0E8      		ldi r31,-128
 9979 38bc EF0E      		add r14,r31
 9980 38be F11C      		adc r15,__zero_reg__
 9981               	.LVL832:
 9982               	.L676:
3140:switcherator.c ****     inputs[inputNumber][3] = switchNumber;
 9983               		.loc 1 3140 0
 9984 38c0 F801      		movw r30,r16
 9985 38c2 E050      		subi r30,lo8(-(inputs))
 9986 38c4 F040      		sbci r31,hi8(-(inputs))
 9987 38c6 E382      		std Z+3,r14
 9988               	.LVL833:
3142:switcherator.c ****     inputs[inputNumber][4] = temp;
 9989               		.loc 1 3142 0
 9990 38c8 2981      		ldd r18,Y+1
 9991 38ca 2483      		std Z+4,r18
 9992               	.LVL834:
3144:switcherator.c ****     inputs[inputNumber][5] = temp;
 9993               		.loc 1 3144 0
 9994 38cc 6582      		std Z+5,r6
 9995               	.LVL835:
3149:switcherator.c ****     inputs[inputNumber][6] = pollTime;
 9996               		.loc 1 3149 0
 9997 38ce 872D      		mov r24,r7
 9998 38d0 982D      		mov r25,r8
 9999 38d2 8F3F      		cpi r24,-1
 10000 38d4 9105      		cpc r25,__zero_reg__
 10001 38d6 01F0      		breq .L677
 10002 38d8 04F0      		brlt .L677
 10003 38da 8FEF      		ldi r24,lo8(-1)
 10004 38dc 90E0      		ldi r25,0
 10005               	.L677:
 10006 38de 8683      		std Z+6,r24
 10007               	.LVL836:
3154:switcherator.c ****     inputs[inputNumber][7] = whichRGB;
 10008               		.loc 1 3154 0
 10009 38e0 F801      		movw r30,r16
 10010 38e2 E050      		subi r30,lo8(-(inputs))
 10011 38e4 F040      		sbci r31,hi8(-(inputs))
 10012 38e6 892D      		mov r24,r9
 10013 38e8 8830      		cpi r24,lo8(8)
 10014 38ea 00F0      		brlo .L678
 10015 38ec 87E0      		ldi r24,lo8(7)
 10016               	.L678:
 10017 38ee 8783      		std Z+7,r24
3159:switcherator.c ****     ADCSRA |= (1 << ADPS2) || (1 << ADPS0);
 10018               		.loc 1 3159 0
 10019 38f0 8091 7A00 		lds r24,122
 10020 38f4 8160      		ori r24,lo8(1)
 10021 38f6 8093 7A00 		sts 122,r24
 10022               	/* epilogue start */
3163:switcherator.c **** }
 10023               		.loc 1 3163 0
 10024 38fa 0F90      		pop __tmp_reg__
 10025 38fc 0F90      		pop __tmp_reg__
 10026 38fe 0F90      		pop __tmp_reg__
 10027 3900 DF91      		pop r29
 10028 3902 CF91      		pop r28
 10029 3904 1F91      		pop r17
 10030 3906 0F91      		pop r16
 10031 3908 FF90      		pop r15
 10032 390a EF90      		pop r14
 10033 390c DF90      		pop r13
 10034 390e CF90      		pop r12
 10035 3910 BF90      		pop r11
 10036 3912 AF90      		pop r10
 10037 3914 9F90      		pop r9
 10038               	.LVL837:
 10039 3916 8F90      		pop r8
 10040               	.LVL838:
 10041 3918 7F90      		pop r7
 10042               	.LVL839:
 10043 391a 6F90      		pop r6
 10044               	.LVL840:
 10045 391c 5F90      		pop r5
 10046 391e 4F90      		pop r4
 10047               	.LVL841:
 10048 3920 3F90      		pop r3
 10049 3922 2F90      		pop r2
3162:switcherator.c ****     ok();
 10050               		.loc 1 3162 0
 10051 3924 0C94 0000 		jmp ok
 10052               	.LVL842:
 10053               	.LFE77:
 10055               	.global	startProgram
 10057               	startProgram:
 10058               	.LFB39:
1617:switcherator.c **** void startProgram(char * commandReceived) {
 10059               		.loc 1 1617 0
 10060               	.LVL843:
 10061 3928 0F93      		push r16
 10062               	.LCFI246:
 10063 392a 1F93      		push r17
 10064               	.LCFI247:
 10065 392c CF93      		push r28
 10066               	.LCFI248:
 10067 392e DF93      		push r29
 10068               	.LCFI249:
 10069               	/* prologue: function */
 10070               	/* frame size = 0 */
 10071               	/* stack size = 4 */
 10072               	.L__stack_usage = 4
 10073 3930 EC01      		movw r28,r24
 10074               	.LVL844:
1621:switcherator.c ****     tempIntString[0] = commandReceived[3];
 10075               		.loc 1 1621 0
 10076 3932 8B81      		ldd r24,Y+3
 10077               	.LVL845:
 10078 3934 8093 0000 		sts tempIntString,r24
1622:switcherator.c ****     tempIntString[1] = commandReceived[4];
 10079               		.loc 1 1622 0
 10080 3938 8C81      		ldd r24,Y+4
 10081 393a 8093 0000 		sts tempIntString+1,r24
1623:switcherator.c ****     programNumber = atoi(tempIntString);
 10082               		.loc 1 1623 0
 10083 393e 80E0      		ldi r24,lo8(tempIntString)
 10084 3940 90E0      		ldi r25,hi8(tempIntString)
 10085 3942 0E94 0000 		call atoi
 10086               	.LVL846:
 10087 3946 8C01      		movw r16,r24
 10088               	.LVL847:
1624:switcherator.c ****     if (programNumber >= MAX_PROGRAM) {
 10089               		.loc 1 1624 0
 10090 3948 8A30      		cpi r24,10
 10091 394a 9105      		cpc r25,__zero_reg__
 10092 394c 04F0      		brlt .L692
1625:switcherator.c ****         fail(2);
 10093               		.loc 1 1625 0
 10094 394e 82E0      		ldi r24,lo8(2)
 10095 3950 90E0      		ldi r25,0
 10096               	/* epilogue start */
1638:switcherator.c **** }
 10097               		.loc 1 1638 0
 10098 3952 DF91      		pop r29
 10099 3954 CF91      		pop r28
 10100               	.LVL848:
 10101 3956 1F91      		pop r17
 10102 3958 0F91      		pop r16
 10103               	.LVL849:
1625:switcherator.c ****         fail(2);
 10104               		.loc 1 1625 0
 10105 395a 0C94 0000 		jmp fail
 10106               	.LVL850:
 10107               	.L692:
1629:switcherator.c ****     tempHugeString[0] = commandReceived[5];
 10108               		.loc 1 1629 0
 10109 395e 8D81      		ldd r24,Y+5
 10110 3960 8093 0000 		sts tempHugeString,r24
1630:switcherator.c ****     tempHugeString[1] = commandReceived[6];
 10111               		.loc 1 1630 0
 10112 3964 8E81      		ldd r24,Y+6
 10113 3966 8093 0000 		sts tempHugeString+1,r24
1631:switcherator.c ****     tempHugeString[2] = commandReceived[7];
 10114               		.loc 1 1631 0
 10115 396a 8F81      		ldd r24,Y+7
 10116 396c 8093 0000 		sts tempHugeString+2,r24
1632:switcherator.c ****     tempHugeString[3] = commandReceived[8];
 10117               		.loc 1 1632 0
 10118 3970 8885      		ldd r24,Y+8
 10119 3972 8093 0000 		sts tempHugeString+3,r24
1633:switcherator.c ****     tempHugeString[4] = commandReceived[9];
 10120               		.loc 1 1633 0
 10121 3976 8985      		ldd r24,Y+9
 10122 3978 8093 0000 		sts tempHugeString+4,r24
1634:switcherator.c ****     tempHugeString[5] = commandReceived[10];
 10123               		.loc 1 1634 0
 10124 397c 8A85      		ldd r24,Y+10
 10125 397e 8093 0000 		sts tempHugeString+5,r24
1635:switcherator.c ****     duration = atol(tempHugeString);
 10126               		.loc 1 1635 0
 10127 3982 80E0      		ldi r24,lo8(tempHugeString)
 10128 3984 90E0      		ldi r25,hi8(tempHugeString)
 10129 3986 0E94 0000 		call atol
 10130               	.LVL851:
1636:switcherator.c ****     startTheProgram(programNumber, duration, 0);
 10131               		.loc 1 1636 0
 10132 398a 20E0      		ldi r18,0
 10133 398c 30E0      		ldi r19,0
 10134 398e A901      		movw r20,r18
 10135 3990 C801      		movw r24,r16
 10136 3992 0E94 0000 		call startTheProgram
 10137               	.LVL852:
 10138               	/* epilogue start */
1638:switcherator.c **** }
 10139               		.loc 1 1638 0
 10140 3996 DF91      		pop r29
 10141 3998 CF91      		pop r28
 10142               	.LVL853:
 10143 399a 1F91      		pop r17
 10144 399c 0F91      		pop r16
 10145               	.LVL854:
1637:switcherator.c ****     ok();
 10146               		.loc 1 1637 0
 10147 399e 0C94 0000 		jmp ok
 10148               	.LVL855:
 10149               	.LFE39:
 10151               	.global	programSetTime
 10153               	programSetTime:
 10154               	.LFB36:
1422:switcherator.c **** void programSetTime(char * commandReceived) {
 10155               		.loc 1 1422 0
 10156               	.LVL856:
 10157 39a2 AF92      		push r10
 10158               	.LCFI250:
 10159 39a4 BF92      		push r11
 10160               	.LCFI251:
 10161 39a6 CF92      		push r12
 10162               	.LCFI252:
 10163 39a8 DF92      		push r13
 10164               	.LCFI253:
 10165 39aa EF92      		push r14
 10166               	.LCFI254:
 10167 39ac FF92      		push r15
 10168               	.LCFI255:
 10169 39ae 0F93      		push r16
 10170               	.LCFI256:
 10171 39b0 1F93      		push r17
 10172               	.LCFI257:
 10173 39b2 CF93      		push r28
 10174               	.LCFI258:
 10175 39b4 DF93      		push r29
 10176               	.LCFI259:
 10177               	/* prologue: function */
 10178               	/* frame size = 0 */
 10179               	/* stack size = 10 */
 10180               	.L__stack_usage = 10
 10181 39b6 EC01      		movw r28,r24
 10182               	.LVL857:
1428:switcherator.c ****     tempIntString[0] = commandReceived[3];
 10183               		.loc 1 1428 0
 10184 39b8 8B81      		ldd r24,Y+3
 10185               	.LVL858:
 10186 39ba 8093 0000 		sts tempIntString,r24
1429:switcherator.c ****     tempIntString[1] = commandReceived[4];
 10187               		.loc 1 1429 0
 10188 39be FC80      		ldd r15,Y+4
 10189 39c0 F092 0000 		sts tempIntString+1,r15
1430:switcherator.c ****     programNumber = atoi(tempIntString);
 10190               		.loc 1 1430 0
 10191 39c4 80E0      		ldi r24,lo8(tempIntString)
 10192 39c6 90E0      		ldi r25,hi8(tempIntString)
 10193 39c8 0E94 0000 		call atoi
 10194               	.LVL859:
 10195 39cc 8C01      		movw r16,r24
 10196               	.LVL860:
1431:switcherator.c ****     if (programNumber >= MAX_PROGRAM || (programNumber == 0 && commandReceived[4] != '0')) {
 10197               		.loc 1 1431 0
 10198 39ce 8A30      		cpi r24,10
 10199 39d0 9105      		cpc r25,__zero_reg__
 10200 39d2 04F4      		brge .L694
1431:switcherator.c ****     if (programNumber >= MAX_PROGRAM || (programNumber == 0 && commandReceived[4] != '0')) {
 10201               		.loc 1 1431 0 is_stmt 0 discriminator 1
 10202 39d4 0097      		sbiw r24,0
 10203 39d6 01F4      		brne .L695
 10204 39d8 20E3      		ldi r18,lo8(48)
 10205 39da F216      		cp r15,r18
 10206 39dc 01F0      		breq .L695
 10207               	.L694:
1432:switcherator.c ****         fail(2);
 10208               		.loc 1 1432 0 is_stmt 1
 10209 39de 82E0      		ldi r24,lo8(2)
 10210 39e0 90E0      		ldi r25,0
 10211 39e2 00C0      		rjmp .L711
 10212               	.L695:
1439:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 10213               		.loc 1 1439 0
 10214 39e4 8AE0      		ldi r24,lo8(10)
 10215 39e6 809F      		mul r24,r16
 10216 39e8 F001      		movw r30,r0
 10217 39ea 819F      		mul r24,r17
 10218 39ec F00D      		add r31,r0
 10219 39ee 1124      		clr __zero_reg__
 10220 39f0 E050      		subi r30,lo8(-(weeklyProgram))
 10221 39f2 F040      		sbci r31,hi8(-(weeklyProgram))
 10222 39f4 8081      		ld r24,Z
 10223 39f6 8F3F      		cpi r24,lo8(-1)
 10224 39f8 01F4      		brne .L696
1439:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 10225               		.loc 1 1439 0 is_stmt 0 discriminator 1
 10226 39fa 8181      		ldd r24,Z+1
 10227 39fc 8F3F      		cpi r24,lo8(-1)
 10228 39fe 01F4      		brne .L696
1440:switcherator.c ****         fail(0x0d);
 10229               		.loc 1 1440 0 is_stmt 1
 10230 3a00 8DE0      		ldi r24,lo8(13)
 10231 3a02 90E0      		ldi r25,0
 10232               	.LVL861:
 10233               	.L711:
 10234               	/* epilogue start */
1479:switcherator.c **** }
 10235               		.loc 1 1479 0
 10236 3a04 DF91      		pop r29
 10237 3a06 CF91      		pop r28
 10238               	.LVL862:
 10239 3a08 1F91      		pop r17
 10240 3a0a 0F91      		pop r16
 10241               	.LVL863:
 10242 3a0c FF90      		pop r15
 10243 3a0e EF90      		pop r14
 10244 3a10 DF90      		pop r13
 10245 3a12 CF90      		pop r12
 10246 3a14 BF90      		pop r11
 10247 3a16 AF90      		pop r10
1440:switcherator.c ****         fail(0x0d);
 10248               		.loc 1 1440 0
 10249 3a18 0C94 0000 		jmp fail
 10250               	.LVL864:
 10251               	.L696:
1443:switcherator.c ****     tempIntString[0] = commandReceived[5];
 10252               		.loc 1 1443 0
 10253 3a1c 8D81      		ldd r24,Y+5
 10254 3a1e 8093 0000 		sts tempIntString,r24
1444:switcherator.c ****     tempIntString[1] = commandReceived[6];
 10255               		.loc 1 1444 0
 10256 3a22 AE80      		ldd r10,Y+6
 10257 3a24 A092 0000 		sts tempIntString+1,r10
1445:switcherator.c ****     hours = atoi(tempIntString);
 10258               		.loc 1 1445 0
 10259 3a28 80E0      		ldi r24,lo8(tempIntString)
 10260 3a2a 90E0      		ldi r25,hi8(tempIntString)
 10261 3a2c 0E94 0000 		call atoi
 10262               	.LVL865:
 10263 3a30 6C01      		movw r12,r24
 10264               	.LVL866:
1446:switcherator.c ****     tempIntString[0] = commandReceived[7];
 10265               		.loc 1 1446 0
 10266 3a32 8F81      		ldd r24,Y+7
 10267 3a34 8093 0000 		sts tempIntString,r24
1447:switcherator.c ****     tempIntString[1] = commandReceived[8];
 10268               		.loc 1 1447 0
 10269 3a38 B884      		ldd r11,Y+8
 10270 3a3a B092 0000 		sts tempIntString+1,r11
1448:switcherator.c ****     minutes = atoi(tempIntString);
 10271               		.loc 1 1448 0
 10272 3a3e 80E0      		ldi r24,lo8(tempIntString)
 10273 3a40 90E0      		ldi r25,hi8(tempIntString)
 10274 3a42 0E94 0000 		call atoi
 10275               	.LVL867:
 10276 3a46 7C01      		movw r14,r24
 10277               	.LVL868:
1449:switcherator.c ****     tempLongString[0] = commandReceived[9];
 10278               		.loc 1 1449 0
 10279 3a48 8985      		ldd r24,Y+9
 10280 3a4a 8093 0000 		sts tempLongString,r24
1450:switcherator.c ****     tempLongString[1] = commandReceived[10];
 10281               		.loc 1 1450 0
 10282 3a4e 8A85      		ldd r24,Y+10
 10283 3a50 8093 0000 		sts tempLongString+1,r24
1451:switcherator.c ****     tempLongString[2] = commandReceived[11];
 10284               		.loc 1 1451 0
 10285 3a54 8B85      		ldd r24,Y+11
 10286 3a56 8093 0000 		sts tempLongString+2,r24
1452:switcherator.c ****     tempLongString[3] = commandReceived[12];
 10287               		.loc 1 1452 0
 10288 3a5a 8C85      		ldd r24,Y+12
 10289 3a5c 8093 0000 		sts tempLongString+3,r24
1453:switcherator.c ****     duration = atoi(tempLongString);
 10290               		.loc 1 1453 0
 10291 3a60 80E0      		ldi r24,lo8(tempLongString)
 10292 3a62 90E0      		ldi r25,hi8(tempLongString)
 10293 3a64 0E94 0000 		call atoi
 10294               	.LVL869:
1454:switcherator.c ****     if (hours >= 24 || (hours == 0 && commandReceived[6] != '0')) {
 10295               		.loc 1 1454 0
 10296 3a68 28E1      		ldi r18,24
 10297 3a6a C216      		cp r12,r18
 10298 3a6c D104      		cpc r13,__zero_reg__
 10299 3a6e 04F4      		brge .L697
1454:switcherator.c ****     if (hours >= 24 || (hours == 0 && commandReceived[6] != '0')) {
 10300               		.loc 1 1454 0 is_stmt 0 discriminator 1
 10301 3a70 C114      		cp r12,__zero_reg__
 10302 3a72 D104      		cpc r13,__zero_reg__
 10303 3a74 01F4      		brne .L698
 10304 3a76 20E3      		ldi r18,lo8(48)
 10305 3a78 A216      		cp r10,r18
 10306 3a7a 01F0      		breq .L698
 10307               	.L697:
1455:switcherator.c ****         fail(9);
 10308               		.loc 1 1455 0 is_stmt 1
 10309 3a7c 89E0      		ldi r24,lo8(9)
 10310 3a7e 90E0      		ldi r25,0
 10311               	.LVL870:
 10312 3a80 00C0      		rjmp .L711
 10313               	.LVL871:
 10314               	.L698:
1458:switcherator.c ****     if (minutes >= 60 || (minutes == 0 && commandReceived[8] != '0')) {
 10315               		.loc 1 1458 0
 10316 3a82 2CE3      		ldi r18,60
 10317 3a84 E216      		cp r14,r18
 10318 3a86 F104      		cpc r15,__zero_reg__
 10319 3a88 04F4      		brge .L699
1458:switcherator.c ****     if (minutes >= 60 || (minutes == 0 && commandReceived[8] != '0')) {
 10320               		.loc 1 1458 0 is_stmt 0 discriminator 1
 10321 3a8a E114      		cp r14,__zero_reg__
 10322 3a8c F104      		cpc r15,__zero_reg__
 10323 3a8e 01F4      		brne .L700
 10324 3a90 20E3      		ldi r18,lo8(48)
 10325 3a92 B216      		cp r11,r18
 10326 3a94 01F0      		breq .L700
 10327               	.L699:
1459:switcherator.c ****         fail(0x0a);
 10328               		.loc 1 1459 0 is_stmt 1
 10329 3a96 8AE0      		ldi r24,lo8(10)
 10330 3a98 90E0      		ldi r25,0
 10331               	.LVL872:
 10332 3a9a 00C0      		rjmp .L711
 10333               	.LVL873:
 10334               	.L700:
1462:switcherator.c ****     if (duration == 0) {
 10335               		.loc 1 1462 0
 10336 3a9c 0097      		sbiw r24,0
 10337 3a9e 01F4      		brne .L701
1463:switcherator.c ****         fail(0x0b);
 10338               		.loc 1 1463 0
 10339 3aa0 8BE0      		ldi r24,lo8(11)
 10340 3aa2 90E0      		ldi r25,0
 10341               	.LVL874:
 10342 3aa4 00C0      		rjmp .L711
 10343               	.LVL875:
 10344               	.L701:
1466:switcherator.c ****     duration *= 60; // convert to seconds
 10345               		.loc 1 1466 0
 10346 3aa6 6CE3      		ldi r22,lo8(60)
 10347 3aa8 689F      		mul r22,r24
 10348 3aaa A001      		movw r20,r0
 10349 3aac 699F      		mul r22,r25
 10350 3aae 500D      		add r21,r0
 10351 3ab0 1124      		clr __zero_reg__
 10352               	.LVL876:
1467:switcherator.c ****     startTime = (hours * 60);
 10353               		.loc 1 1467 0
 10354 3ab2 6C9D      		mul r22,r12
 10355 3ab4 9001      		movw r18,r0
 10356 3ab6 6D9D      		mul r22,r13
 10357 3ab8 300D      		add r19,r0
 10358 3aba 1124      		clr __zero_reg__
 10359               	.LVL877:
1468:switcherator.c ****     startTime += minutes; // stored in minutes
 10360               		.loc 1 1468 0
 10361 3abc 2E0D      		add r18,r14
 10362 3abe 3F1D      		adc r19,r15
 10363               	.LVL878:
1471:switcherator.c ****     weeklyProgram[programNumber][1] = temp;
 10364               		.loc 1 1471 0
 10365 3ac0 8AE0      		ldi r24,lo8(10)
 10366 3ac2 809F      		mul r24,r16
 10367 3ac4 F001      		movw r30,r0
 10368 3ac6 819F      		mul r24,r17
 10369 3ac8 F00D      		add r31,r0
 10370 3aca 1124      		clr __zero_reg__
 10371 3acc E050      		subi r30,lo8(-(weeklyProgram))
 10372 3ace F040      		sbci r31,hi8(-(weeklyProgram))
 10373 3ad0 3183      		std Z+1,r19
 10374               	.LVL879:
1473:switcherator.c ****     weeklyProgram[programNumber][2] = temp;
 10375               		.loc 1 1473 0
 10376 3ad2 2283      		std Z+2,r18
 10377               	.LVL880:
1475:switcherator.c ****     weeklyProgram[programNumber][3] = temp;
 10378               		.loc 1 1475 0
 10379 3ad4 5383      		std Z+3,r21
 10380               	.LVL881:
1476:switcherator.c ****     temp = (duration & 0xff);
 10381               		.loc 1 1476 0
 10382 3ad6 5527      		clr r21
 10383               	.LVL882:
1477:switcherator.c ****     weeklyProgram[programNumber][4] = temp;
 10384               		.loc 1 1477 0
 10385 3ad8 4483      		std Z+4,r20
 10386               	/* epilogue start */
1479:switcherator.c **** }
 10387               		.loc 1 1479 0
 10388 3ada DF91      		pop r29
 10389 3adc CF91      		pop r28
 10390               	.LVL883:
 10391 3ade 1F91      		pop r17
 10392 3ae0 0F91      		pop r16
 10393               	.LVL884:
 10394 3ae2 FF90      		pop r15
 10395 3ae4 EF90      		pop r14
 10396               	.LVL885:
 10397 3ae6 DF90      		pop r13
 10398 3ae8 CF90      		pop r12
 10399               	.LVL886:
 10400 3aea BF90      		pop r11
 10401 3aec AF90      		pop r10
1478:switcherator.c ****     ok();
 10402               		.loc 1 1478 0
 10403 3aee 0C94 0000 		jmp ok
 10404               	.LVL887:
 10405               	.LFE36:
 10407               		.section	.rodata.str1.1
 10408               	.LC69:
 10409 0150 3030 3030 		.string	"0000000"
 10409      3030 3000 
 10410               		.text
 10411               	.global	programSetDays
 10413               	programSetDays:
 10414               	.LFB35:
1381:switcherator.c **** void programSetDays(char * commandReceived) {
 10415               		.loc 1 1381 0
 10416               	.LVL888:
 10417 3af2 EF92      		push r14
 10418               	.LCFI260:
 10419 3af4 FF92      		push r15
 10420               	.LCFI261:
 10421 3af6 0F93      		push r16
 10422               	.LCFI262:
 10423 3af8 1F93      		push r17
 10424               	.LCFI263:
 10425 3afa CF93      		push r28
 10426               	.LCFI264:
 10427 3afc DF93      		push r29
 10428               	.LCFI265:
 10429 3afe CDB7      		in r28,__SP_L__
 10430 3b00 DEB7      		in r29,__SP_H__
 10431               	.LCFI266:
 10432 3b02 2897      		sbiw r28,8
 10433               	.LCFI267:
 10434 3b04 0FB6      		in __tmp_reg__,__SREG__
 10435 3b06 F894      		cli
 10436 3b08 DEBF      		out __SP_H__,r29
 10437 3b0a 0FBE      		out __SREG__,__tmp_reg__
 10438 3b0c CDBF      		out __SP_L__,r28
 10439               	/* prologue: function */
 10440               	/* frame size = 8 */
 10441               	/* stack size = 14 */
 10442               	.L__stack_usage = 14
 10443 3b0e 7C01      		movw r14,r24
1382:switcherator.c ****     char tempReallyLongString[] = "0000000";
 10444               		.loc 1 1382 0
 10445 3b10 88E0      		ldi r24,lo8(8)
 10446               	.LVL889:
 10447 3b12 E0E0      		ldi r30,lo8(.LC69)
 10448 3b14 F0E0      		ldi r31,hi8(.LC69)
 10449 3b16 DE01      		movw r26,r28
 10450 3b18 1196      		adiw r26,1
 10451               		0:
 10452 3b1a 0190      		ld r0,Z+
 10453 3b1c 0D92      		st X+,r0
 10454 3b1e 8A95      		dec r24
 10455 3b20 01F4      		brne 0b
 10456               	.LVL890:
1385:switcherator.c ****     tempIntString[0] = commandReceived[3];
 10457               		.loc 1 1385 0
 10458 3b22 F701      		movw r30,r14
 10459 3b24 8381      		ldd r24,Z+3
 10460 3b26 8093 0000 		sts tempIntString,r24
1386:switcherator.c ****     tempIntString[1] = commandReceived[4];
 10461               		.loc 1 1386 0
 10462 3b2a 8481      		ldd r24,Z+4
 10463 3b2c 8093 0000 		sts tempIntString+1,r24
1387:switcherator.c ****     programNumber = atoi(tempIntString);
 10464               		.loc 1 1387 0
 10465 3b30 80E0      		ldi r24,lo8(tempIntString)
 10466 3b32 90E0      		ldi r25,hi8(tempIntString)
 10467 3b34 0E94 0000 		call atoi
 10468               	.LVL891:
 10469 3b38 8C01      		movw r16,r24
 10470               	.LVL892:
1388:switcherator.c ****     tempReallyLongString[0] = commandReceived[5];
 10471               		.loc 1 1388 0
 10472 3b3a F701      		movw r30,r14
 10473 3b3c 8581      		ldd r24,Z+5
 10474 3b3e 8983      		std Y+1,r24
1389:switcherator.c ****     tempReallyLongString[1] = commandReceived[6];
 10475               		.loc 1 1389 0
 10476 3b40 8681      		ldd r24,Z+6
 10477 3b42 8A83      		std Y+2,r24
1390:switcherator.c ****     tempReallyLongString[2] = commandReceived[7];
 10478               		.loc 1 1390 0
 10479 3b44 8781      		ldd r24,Z+7
 10480 3b46 8B83      		std Y+3,r24
1391:switcherator.c ****     tempReallyLongString[3] = commandReceived[8];
 10481               		.loc 1 1391 0
 10482 3b48 8085      		ldd r24,Z+8
 10483 3b4a 8C83      		std Y+4,r24
1392:switcherator.c ****     tempReallyLongString[4] = commandReceived[9];
 10484               		.loc 1 1392 0
 10485 3b4c 8185      		ldd r24,Z+9
 10486 3b4e 8D83      		std Y+5,r24
1393:switcherator.c ****     tempReallyLongString[5] = commandReceived[10];
 10487               		.loc 1 1393 0
 10488 3b50 8285      		ldd r24,Z+10
 10489 3b52 8E83      		std Y+6,r24
1394:switcherator.c ****     tempReallyLongString[6] = commandReceived[11];
 10490               		.loc 1 1394 0
 10491 3b54 8385      		ldd r24,Z+11
 10492 3b56 8F83      		std Y+7,r24
1395:switcherator.c ****     weekLong = strtol(tempReallyLongString, 0, 2);
 10493               		.loc 1 1395 0
 10494 3b58 42E0      		ldi r20,lo8(2)
 10495 3b5a 50E0      		ldi r21,0
 10496 3b5c 60E0      		ldi r22,0
 10497 3b5e 70E0      		ldi r23,0
 10498 3b60 CE01      		movw r24,r28
 10499 3b62 0196      		adiw r24,1
 10500 3b64 0E94 0000 		call strtol
 10501               	.LVL893:
1396:switcherator.c ****     if ((programNumber >= MAX_PROGRAM) || (programNumber == 0 && commandReceived[4] != '0')) {
 10502               		.loc 1 1396 0
 10503 3b68 0A30      		cpi r16,10
 10504 3b6a 1105      		cpc r17,__zero_reg__
 10505 3b6c 04F4      		brge .L713
1396:switcherator.c ****     if ((programNumber >= MAX_PROGRAM) || (programNumber == 0 && commandReceived[4] != '0')) {
 10506               		.loc 1 1396 0 is_stmt 0 discriminator 1
 10507 3b6e 0115      		cp r16,__zero_reg__
 10508 3b70 1105      		cpc r17,__zero_reg__
 10509 3b72 01F4      		brne .L714
 10510 3b74 F701      		movw r30,r14
 10511 3b76 2481      		ldd r18,Z+4
 10512 3b78 2033      		cpi r18,lo8(48)
 10513 3b7a 01F0      		breq .L714
 10514               	.L713:
1397:switcherator.c ****         fail(2);
 10515               		.loc 1 1397 0 is_stmt 1
 10516 3b7c 82E0      		ldi r24,lo8(2)
 10517 3b7e 90E0      		ldi r25,0
 10518 3b80 00C0      		rjmp .L722
 10519               	.L714:
1404:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 10520               		.loc 1 1404 0
 10521 3b82 2AE0      		ldi r18,lo8(10)
 10522 3b84 209F      		mul r18,r16
 10523 3b86 F001      		movw r30,r0
 10524 3b88 219F      		mul r18,r17
 10525 3b8a F00D      		add r31,r0
 10526 3b8c 1124      		clr __zero_reg__
 10527 3b8e E050      		subi r30,lo8(-(weeklyProgram))
 10528 3b90 F040      		sbci r31,hi8(-(weeklyProgram))
 10529 3b92 2081      		ld r18,Z
 10530 3b94 2F3F      		cpi r18,lo8(-1)
 10531 3b96 01F4      		brne .L716
1404:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 10532               		.loc 1 1404 0 is_stmt 0 discriminator 1
 10533 3b98 2181      		ldd r18,Z+1
 10534 3b9a 2F3F      		cpi r18,lo8(-1)
 10535 3b9c 01F4      		brne .L716
1405:switcherator.c ****         fail(0x0d);
 10536               		.loc 1 1405 0 is_stmt 1
 10537 3b9e 8DE0      		ldi r24,lo8(13)
 10538 3ba0 90E0      		ldi r25,0
 10539 3ba2 00C0      		rjmp .L722
 10540               	.L716:
1408:switcherator.c ****     if ((weekLong & 0x7f) == 0) {
 10541               		.loc 1 1408 0
 10542 3ba4 AB01      		movw r20,r22
 10543 3ba6 BC01      		movw r22,r24
 10544 3ba8 4F77      		andi r20,127
 10545 3baa 5527      		clr r21
 10546 3bac 6627      		clr r22
 10547 3bae 7727      		clr r23
 10548 3bb0 4115      		cp r20,__zero_reg__
 10549 3bb2 5105      		cpc r21,__zero_reg__
 10550 3bb4 6105      		cpc r22,__zero_reg__
 10551 3bb6 7105      		cpc r23,__zero_reg__
 10552 3bb8 01F4      		brne .L717
1409:switcherator.c ****         fail(0x0f);
 10553               		.loc 1 1409 0
 10554 3bba 8FE0      		ldi r24,lo8(15)
 10555 3bbc 90E0      		ldi r25,0
 10556               	.L722:
 10557 3bbe 0E94 0000 		call fail
 10558               	.LVL894:
 10559 3bc2 00C0      		rjmp .L712
 10560               	.LVL895:
 10561               	.L717:
1413:switcherator.c ****     weeklyProgram[programNumber][0] = weekdays;
 10562               		.loc 1 1413 0
 10563 3bc4 8AE0      		ldi r24,lo8(10)
 10564 3bc6 809F      		mul r24,r16
 10565 3bc8 F001      		movw r30,r0
 10566 3bca 819F      		mul r24,r17
 10567 3bcc F00D      		add r31,r0
 10568 3bce 1124      		clr __zero_reg__
 10569 3bd0 E050      		subi r30,lo8(-(weeklyProgram))
 10570 3bd2 F040      		sbci r31,hi8(-(weeklyProgram))
1412:switcherator.c ****     char weekdays = (weekLong & 0x7f);
 10571               		.loc 1 1412 0
 10572 3bd4 4083      		st Z,r20
1414:switcherator.c ****     ok();
 10573               		.loc 1 1414 0
 10574 3bd6 0E94 0000 		call ok
 10575               	.LVL896:
 10576               	.L712:
 10577               	/* epilogue start */
1415:switcherator.c **** }
 10578               		.loc 1 1415 0
 10579 3bda 2896      		adiw r28,8
 10580 3bdc 0FB6      		in __tmp_reg__,__SREG__
 10581 3bde F894      		cli
 10582 3be0 DEBF      		out __SP_H__,r29
 10583 3be2 0FBE      		out __SREG__,__tmp_reg__
 10584 3be4 CDBF      		out __SP_L__,r28
 10585 3be6 DF91      		pop r29
 10586 3be8 CF91      		pop r28
 10587 3bea 1F91      		pop r17
 10588 3bec 0F91      		pop r16
 10589               	.LVL897:
 10590 3bee FF90      		pop r15
 10591 3bf0 EF90      		pop r14
 10592               	.LVL898:
 10593 3bf2 0895      		ret
 10594               	.LFE35:
 10596               	.global	programAddSwitch
 10598               	programAddSwitch:
 10599               	.LFB33:
1276:switcherator.c **** void programAddSwitch(char * commandReceived) {
 10600               		.loc 1 1276 0
 10601               	.LVL899:
 10602 3bf4 CF92      		push r12
 10603               	.LCFI268:
 10604 3bf6 DF92      		push r13
 10605               	.LCFI269:
 10606 3bf8 EF92      		push r14
 10607               	.LCFI270:
 10608 3bfa FF92      		push r15
 10609               	.LCFI271:
 10610 3bfc 0F93      		push r16
 10611               	.LCFI272:
 10612 3bfe 1F93      		push r17
 10613               	.LCFI273:
 10614 3c00 CF93      		push r28
 10615               	.LCFI274:
 10616 3c02 DF93      		push r29
 10617               	.LCFI275:
 10618 3c04 CDB7      		in r28,__SP_L__
 10619 3c06 DEB7      		in r29,__SP_H__
 10620               	.LCFI276:
 10621 3c08 6097      		sbiw r28,16
 10622               	.LCFI277:
 10623 3c0a 0FB6      		in __tmp_reg__,__SREG__
 10624 3c0c F894      		cli
 10625 3c0e DEBF      		out __SP_H__,r29
 10626 3c10 0FBE      		out __SREG__,__tmp_reg__
 10627 3c12 CDBF      		out __SP_L__,r28
 10628               	/* prologue: function */
 10629               	/* frame size = 16 */
 10630               	/* stack size = 24 */
 10631               	.L__stack_usage = 24
 10632 3c14 7C01      		movw r14,r24
 10633               	.LVL900:
1279:switcherator.c ****     tempIntString[0] = commandReceived[3];
 10634               		.loc 1 1279 0
 10635 3c16 FC01      		movw r30,r24
 10636 3c18 8381      		ldd r24,Z+3
 10637               	.LVL901:
 10638 3c1a 8093 0000 		sts tempIntString,r24
1280:switcherator.c ****     tempIntString[1] = commandReceived[4];
 10639               		.loc 1 1280 0
 10640 3c1e 8481      		ldd r24,Z+4
 10641 3c20 8093 0000 		sts tempIntString+1,r24
1281:switcherator.c ****     programNumber = atoi(tempIntString);
 10642               		.loc 1 1281 0
 10643 3c24 80E0      		ldi r24,lo8(tempIntString)
 10644 3c26 90E0      		ldi r25,hi8(tempIntString)
 10645 3c28 0E94 0000 		call atoi
 10646               	.LVL902:
 10647 3c2c 8C01      		movw r16,r24
 10648               	.LVL903:
1282:switcherator.c ****     tempIntString[0] = commandReceived[5];
 10649               		.loc 1 1282 0
 10650 3c2e F701      		movw r30,r14
 10651 3c30 8581      		ldd r24,Z+5
 10652 3c32 8093 0000 		sts tempIntString,r24
1283:switcherator.c ****     tempIntString[1] = commandReceived[6];
 10653               		.loc 1 1283 0
 10654 3c36 8681      		ldd r24,Z+6
 10655 3c38 8093 0000 		sts tempIntString+1,r24
1284:switcherator.c ****     switchNumber = atoi(tempIntString);
 10656               		.loc 1 1284 0
 10657 3c3c 80E0      		ldi r24,lo8(tempIntString)
 10658 3c3e 90E0      		ldi r25,hi8(tempIntString)
 10659 3c40 0E94 0000 		call atoi
 10660               	.LVL904:
 10661 3c44 6C01      		movw r12,r24
 10662               	.LVL905:
1286:switcherator.c ****     switches[0] = 0;
 10663               		.loc 1 1286 0
 10664 3c46 1982      		std Y+1,__zero_reg__
1287:switcherator.c ****     int switchCount = programGetSwitches(programNumber, switches);
 10665               		.loc 1 1287 0
 10666 3c48 BE01      		movw r22,r28
 10667 3c4a 6F5F      		subi r22,-1
 10668 3c4c 7F4F      		sbci r23,-1
 10669 3c4e C801      		movw r24,r16
 10670 3c50 0E94 0000 		call programGetSwitches
 10671               	.LVL906:
 10672 3c54 FE01      		movw r30,r28
 10673 3c56 3196      		adiw r30,1
1276:switcherator.c **** void programAddSwitch(char * commandReceived) {
 10674               		.loc 1 1276 0
 10675 3c58 AF01      		movw r20,r30
1290:switcherator.c ****     for (x = 0; x < switchCount; x++) {
 10676               		.loc 1 1290 0
 10677 3c5a 00C0      		rjmp .L724
 10678               	.LVL907:
 10679               	.L726:
1291:switcherator.c ****         if (switches[x] == switchNumber) {
 10680               		.loc 1 1291 0
 10681 3c5c 2191      		ld r18,Z+
 10682 3c5e 30E0      		ldi r19,0
 10683 3c60 2C15      		cp r18,r12
 10684 3c62 3D05      		cpc r19,r13
 10685 3c64 01F4      		brne .L724
1292:switcherator.c ****             fail(0x0c);
 10686               		.loc 1 1292 0
 10687 3c66 8CE0      		ldi r24,lo8(12)
 10688 3c68 90E0      		ldi r25,0
 10689               	.LVL908:
 10690 3c6a 00C0      		rjmp .L750
 10691               	.LVL909:
 10692               	.L724:
1276:switcherator.c **** void programAddSwitch(char * commandReceived) {
 10693               		.loc 1 1276 0 discriminator 1
 10694 3c6c 9F01      		movw r18,r30
 10695 3c6e 241B      		sub r18,r20
 10696 3c70 350B      		sbc r19,r21
1290:switcherator.c ****     for (x = 0; x < switchCount; x++) {
 10697               		.loc 1 1290 0 discriminator 1
 10698 3c72 2817      		cp r18,r24
 10699 3c74 3907      		cpc r19,r25
 10700 3c76 04F0      		brlt .L726
1298:switcherator.c ****     if ((programNumber >= MAX_PROGRAM) || (programNumber == 0 && commandReceived[4] != '0')) {
 10701               		.loc 1 1298 0
 10702 3c78 0A30      		cpi r16,10
 10703 3c7a 1105      		cpc r17,__zero_reg__
 10704 3c7c 04F4      		brge .L727
1298:switcherator.c ****     if ((programNumber >= MAX_PROGRAM) || (programNumber == 0 && commandReceived[4] != '0')) {
 10705               		.loc 1 1298 0 is_stmt 0 discriminator 1
 10706 3c7e 0115      		cp r16,__zero_reg__
 10707 3c80 1105      		cpc r17,__zero_reg__
 10708 3c82 01F4      		brne .L728
 10709 3c84 F701      		movw r30,r14
 10710 3c86 8481      		ldd r24,Z+4
 10711               	.LVL910:
 10712 3c88 8033      		cpi r24,lo8(48)
 10713 3c8a 01F0      		breq .L728
 10714               	.L727:
1299:switcherator.c ****         fail(2);
 10715               		.loc 1 1299 0 is_stmt 1
 10716 3c8c 82E0      		ldi r24,lo8(2)
 10717 3c8e 90E0      		ldi r25,0
 10718 3c90 00C0      		rjmp .L750
 10719               	.L728:
1302:switcherator.c ****     if ((switchNumber >= NUM_SWITCHES) || (switchNumber == 0 && commandReceived[6] != '0')) {
 10720               		.loc 1 1302 0
 10721 3c92 F0E1      		ldi r31,16
 10722 3c94 CF16      		cp r12,r31
 10723 3c96 D104      		cpc r13,__zero_reg__
 10724 3c98 04F4      		brge .L729
1302:switcherator.c ****     if ((switchNumber >= NUM_SWITCHES) || (switchNumber == 0 && commandReceived[6] != '0')) {
 10725               		.loc 1 1302 0 is_stmt 0 discriminator 1
 10726 3c9a C114      		cp r12,__zero_reg__
 10727 3c9c D104      		cpc r13,__zero_reg__
 10728 3c9e 01F4      		brne .L730
 10729 3ca0 F701      		movw r30,r14
 10730 3ca2 8681      		ldd r24,Z+6
 10731 3ca4 8033      		cpi r24,lo8(48)
 10732 3ca6 01F0      		breq .L730
 10733               	.L729:
1303:switcherator.c ****         fail(1);
 10734               		.loc 1 1303 0 is_stmt 1
 10735 3ca8 81E0      		ldi r24,lo8(1)
 10736 3caa 90E0      		ldi r25,0
 10737 3cac 00C0      		rjmp .L750
 10738               	.L730:
1310:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 10739               		.loc 1 1310 0
 10740 3cae 8AE0      		ldi r24,lo8(10)
 10741 3cb0 809F      		mul r24,r16
 10742 3cb2 F001      		movw r30,r0
 10743 3cb4 819F      		mul r24,r17
 10744 3cb6 F00D      		add r31,r0
 10745 3cb8 1124      		clr __zero_reg__
 10746 3cba E050      		subi r30,lo8(-(weeklyProgram))
 10747 3cbc F040      		sbci r31,hi8(-(weeklyProgram))
 10748 3cbe 8081      		ld r24,Z
 10749 3cc0 8F3F      		cpi r24,lo8(-1)
 10750 3cc2 01F4      		brne .L731
1310:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 10751               		.loc 1 1310 0 is_stmt 0 discriminator 1
 10752 3cc4 8181      		ldd r24,Z+1
 10753 3cc6 8F3F      		cpi r24,lo8(-1)
 10754 3cc8 01F4      		brne .L731
1311:switcherator.c ****         fail(0x0d);
 10755               		.loc 1 1311 0 is_stmt 1
 10756 3cca 8DE0      		ldi r24,lo8(13)
 10757 3ccc 90E0      		ldi r25,0
 10758 3cce 00C0      		rjmp .L750
 10759               	.L731:
 10760               	.LVL911:
1318:switcherator.c ****     itoa(programNumber, tempIntString, 10);
 10761               		.loc 1 1318 0
 10762 3cd0 4AE0      		ldi r20,lo8(10)
 10763 3cd2 50E0      		ldi r21,0
 10764 3cd4 60E0      		ldi r22,lo8(tempIntString)
 10765 3cd6 70E0      		ldi r23,hi8(tempIntString)
 10766 3cd8 C801      		movw r24,r16
 10767 3cda 0E94 0000 		call itoa
 10768               	.LVL912:
1320:switcherator.c ****     blankSwitch = findOpenSwitch(programNumber);
 10769               		.loc 1 1320 0
 10770 3cde C801      		movw r24,r16
 10771 3ce0 0E94 0000 		call findOpenSwitch
 10772               	.LVL913:
1322:switcherator.c ****         if (blankSwitch == 0) {
 10773               		.loc 1 1322 0
 10774 3ce4 0097      		sbiw r24,0
 10775 3ce6 01F4      		brne .L732
1325:switcherator.c ****             overflowProgram = weeklyProgram[programNumber][9];
 10776               		.loc 1 1325 0
 10777 3ce8 4AE0      		ldi r20,lo8(10)
 10778               	.LVL914:
 10779               	.L749:
 10780 3cea 409F      		mul r20,r16
 10781 3cec F001      		movw r30,r0
 10782 3cee 419F      		mul r20,r17
 10783 3cf0 F00D      		add r31,r0
 10784 3cf2 1124      		clr __zero_reg__
 10785 3cf4 E050      		subi r30,lo8(-(weeklyProgram))
 10786 3cf6 F040      		sbci r31,hi8(-(weeklyProgram))
 10787 3cf8 8185      		ldd r24,Z+9
 10788 3cfa 90E0      		ldi r25,0
 10789               	.LVL915:
1326:switcherator.c ****             if (overflowProgram == 255) {
 10790               		.loc 1 1326 0
 10791 3cfc 8F3F      		cpi r24,-1
 10792 3cfe 9105      		cpc r25,__zero_reg__
 10793 3d00 01F4      		brne .L739
 10794 3d02 2FEF      		ldi r18,lo8(-1)
 10795 3d04 30E0      		ldi r19,0
 10796 3d06 89E0      		ldi r24,lo8(9)
 10797 3d08 90E0      		ldi r25,0
 10798               	.LVL916:
 10799               	.L735:
 10800               	.LBB28:
1333:switcherator.c ****                     if (weeklyProgram[x][0] == 255 && weeklyProgram[x][5] == 255) {
 10801               		.loc 1 1333 0
 10802 3d0a 489F      		mul r20,r24
 10803 3d0c F001      		movw r30,r0
 10804 3d0e 499F      		mul r20,r25
 10805 3d10 F00D      		add r31,r0
 10806 3d12 1124      		clr __zero_reg__
 10807 3d14 E050      		subi r30,lo8(-(weeklyProgram))
 10808 3d16 F040      		sbci r31,hi8(-(weeklyProgram))
 10809 3d18 5081      		ld r21,Z
 10810 3d1a 5F3F      		cpi r21,lo8(-1)
 10811 3d1c 01F4      		brne .L734
1333:switcherator.c ****                     if (weeklyProgram[x][0] == 255 && weeklyProgram[x][5] == 255) {
 10812               		.loc 1 1333 0 is_stmt 0 discriminator 1
 10813 3d1e 5581      		ldd r21,Z+5
 10814 3d20 5F3F      		cpi r21,lo8(-1)
 10815 3d22 01F4      		brne .L734
1333:switcherator.c ****                     if (weeklyProgram[x][0] == 255 && weeklyProgram[x][5] == 255) {
 10816               		.loc 1 1333 0
 10817 3d24 9C01      		movw r18,r24
1337:switcherator.c ****                         x = 0;
 10818               		.loc 1 1337 0 is_stmt 1
 10819 3d26 80E0      		ldi r24,0
 10820 3d28 90E0      		ldi r25,0
 10821               	.L734:
 10822               	.LVL917:
1331:switcherator.c ****                 for (x = (MAX_PROGRAM - 1); x > 0; x--) {
 10823               		.loc 1 1331 0
 10824 3d2a 0197      		sbiw r24,1
 10825               	.LVL918:
 10826 3d2c 1816      		cp __zero_reg__,r24
 10827 3d2e 1906      		cpc __zero_reg__,r25
 10828 3d30 04F0      		brlt .L735
1340:switcherator.c ****                 if (possibleBlank == 255) {
 10829               		.loc 1 1340 0
 10830 3d32 2F3F      		cpi r18,-1
 10831 3d34 3105      		cpc r19,__zero_reg__
 10832 3d36 01F4      		brne .L736
1342:switcherator.c ****                     fail(0x0e);
 10833               		.loc 1 1342 0
 10834 3d38 8EE0      		ldi r24,lo8(14)
 10835 3d3a 90E0      		ldi r25,0
 10836               	.LVL919:
 10837               	.L750:
 10838 3d3c 0E94 0000 		call fail
 10839               	.LVL920:
 10840 3d40 00C0      		rjmp .L723
 10841               	.LVL921:
 10842               	.L736:
1346:switcherator.c ****                 weeklyProgram[programNumber][9] = possibleBlank;
 10843               		.loc 1 1346 0
 10844 3d42 409F      		mul r20,r16
 10845 3d44 F001      		movw r30,r0
 10846 3d46 419F      		mul r20,r17
 10847 3d48 F00D      		add r31,r0
 10848 3d4a 1124      		clr __zero_reg__
 10849 3d4c E050      		subi r30,lo8(-(weeklyProgram))
 10850 3d4e F040      		sbci r31,hi8(-(weeklyProgram))
 10851 3d50 2187      		std Z+9,r18
 10852               	.LVL922:
 10853 3d52 8901      		movw r16,r18
 10854 3d54 00C0      		rjmp .L749
 10855               	.LVL923:
 10856               	.L739:
 10857               	.LBE28:
1326:switcherator.c ****             if (overflowProgram == 255) {
 10858               		.loc 1 1326 0
 10859 3d56 8C01      		movw r16,r24
 10860               	.LVL924:
 10861 3d58 00C0      		rjmp .L749
 10862               	.LVL925:
 10863               	.L732:
1358:switcherator.c ****     weeklyProgram[programNumber][blankSwitch] = switchNumber;
 10864               		.loc 1 1358 0 discriminator 1
 10865 3d5a 2AE0      		ldi r18,lo8(10)
 10866 3d5c 209F      		mul r18,r16
 10867 3d5e F001      		movw r30,r0
 10868 3d60 219F      		mul r18,r17
 10869 3d62 F00D      		add r31,r0
 10870 3d64 1124      		clr __zero_reg__
 10871 3d66 E80F      		add r30,r24
 10872 3d68 F91F      		adc r31,r25
 10873 3d6a E050      		subi r30,lo8(-(weeklyProgram))
 10874 3d6c F040      		sbci r31,hi8(-(weeklyProgram))
 10875 3d6e C082      		st Z,r12
1359:switcherator.c ****     ok();
 10876               		.loc 1 1359 0 discriminator 1
 10877 3d70 0E94 0000 		call ok
 10878               	.LVL926:
 10879               	.L723:
 10880               	/* epilogue start */
1360:switcherator.c **** }
 10881               		.loc 1 1360 0
 10882 3d74 6096      		adiw r28,16
 10883 3d76 0FB6      		in __tmp_reg__,__SREG__
 10884 3d78 F894      		cli
 10885 3d7a DEBF      		out __SP_H__,r29
 10886 3d7c 0FBE      		out __SREG__,__tmp_reg__
 10887 3d7e CDBF      		out __SP_L__,r28
 10888 3d80 DF91      		pop r29
 10889 3d82 CF91      		pop r28
 10890 3d84 1F91      		pop r17
 10891 3d86 0F91      		pop r16
 10892               	.LVL927:
 10893 3d88 FF90      		pop r15
 10894 3d8a EF90      		pop r14
 10895               	.LVL928:
 10896 3d8c DF90      		pop r13
 10897 3d8e CF90      		pop r12
 10898               	.LVL929:
 10899 3d90 0895      		ret
 10900               	.LFE33:
 10902               	.global	clearProgram
 10904               	clearProgram:
 10905               	.LFB31:
1246:switcherator.c **** void clearProgram(char * commandReceived) {
 10906               		.loc 1 1246 0
 10907               	.LVL930:
 10908 3d92 0F93      		push r16
 10909               	.LCFI278:
 10910 3d94 1F93      		push r17
 10911               	.LCFI279:
 10912 3d96 CF93      		push r28
 10913               	.LCFI280:
 10914 3d98 DF93      		push r29
 10915               	.LCFI281:
 10916               	/* prologue: function */
 10917               	/* frame size = 0 */
 10918               	/* stack size = 4 */
 10919               	.L__stack_usage = 4
 10920 3d9a 8C01      		movw r16,r24
1247:switcherator.c ****     int programNumber = getSwitchNumber(commandReceived);
 10921               		.loc 1 1247 0
 10922 3d9c 0E94 0000 		call getSwitchNumber
 10923               	.LVL931:
 10924 3da0 EC01      		movw r28,r24
 10925               	.LVL932:
1248:switcherator.c ****     if (programNumber >= MAX_PROGRAM || (programNumber == 0 && commandReceived[4] != '0')) {
 10926               		.loc 1 1248 0
 10927 3da2 8A30      		cpi r24,10
 10928 3da4 9105      		cpc r25,__zero_reg__
 10929 3da6 04F4      		brge .L752
1248:switcherator.c ****     if (programNumber >= MAX_PROGRAM || (programNumber == 0 && commandReceived[4] != '0')) {
 10930               		.loc 1 1248 0 is_stmt 0 discriminator 1
 10931 3da8 0097      		sbiw r24,0
 10932 3daa 01F4      		brne .L753
 10933 3dac F801      		movw r30,r16
 10934 3dae 8481      		ldd r24,Z+4
 10935               	.LVL933:
 10936 3db0 8033      		cpi r24,lo8(48)
 10937 3db2 01F0      		breq .L753
 10938               	.L752:
1249:switcherator.c ****         fail(2);
 10939               		.loc 1 1249 0 is_stmt 1
 10940 3db4 82E0      		ldi r24,lo8(2)
 10941 3db6 90E0      		ldi r25,0
 10942               	/* epilogue start */
1255:switcherator.c **** }
 10943               		.loc 1 1255 0
 10944 3db8 DF91      		pop r29
 10945 3dba CF91      		pop r28
 10946               	.LVL934:
 10947 3dbc 1F91      		pop r17
 10948 3dbe 0F91      		pop r16
 10949               	.LVL935:
1249:switcherator.c ****         fail(2);
 10950               		.loc 1 1249 0
 10951 3dc0 0C94 0000 		jmp fail
 10952               	.LVL936:
 10953               	.L753:
1251:switcherator.c ****         itoa(programNumber, tempIntString, 10);
 10954               		.loc 1 1251 0
 10955 3dc4 4AE0      		ldi r20,lo8(10)
 10956 3dc6 50E0      		ldi r21,0
 10957 3dc8 60E0      		ldi r22,lo8(tempIntString)
 10958 3dca 70E0      		ldi r23,hi8(tempIntString)
 10959 3dcc CE01      		movw r24,r28
 10960 3dce 0E94 0000 		call itoa
 10961               	.LVL937:
1252:switcherator.c ****         ok();
 10962               		.loc 1 1252 0
 10963 3dd2 0E94 0000 		call ok
 10964               	.LVL938:
1253:switcherator.c ****         clearTheProgram(programNumber);
 10965               		.loc 1 1253 0
 10966 3dd6 CE01      		movw r24,r28
 10967               	/* epilogue start */
1255:switcherator.c **** }
 10968               		.loc 1 1255 0
 10969 3dd8 DF91      		pop r29
 10970 3dda CF91      		pop r28
 10971               	.LVL939:
 10972 3ddc 1F91      		pop r17
 10973 3dde 0F91      		pop r16
 10974               	.LVL940:
1253:switcherator.c ****         clearTheProgram(programNumber);
 10975               		.loc 1 1253 0
 10976 3de0 0C94 0000 		jmp clearTheProgram
 10977               	.LVL941:
 10978               	.LFE31:
 10980               	.global	colorChangeSet
 10982               	colorChangeSet:
 10983               	.LFB25:
 954:switcherator.c **** void colorChangeSet(char * commandReceived) {
 10984               		.loc 1 954 0
 10985               	.LVL942:
 10986 3de4 EF92      		push r14
 10987               	.LCFI282:
 10988 3de6 FF92      		push r15
 10989               	.LCFI283:
 10990 3de8 0F93      		push r16
 10991               	.LCFI284:
 10992 3dea 1F93      		push r17
 10993               	.LCFI285:
 10994 3dec CF93      		push r28
 10995               	.LCFI286:
 10996 3dee DF93      		push r29
 10997               	.LCFI287:
 10998               	/* prologue: function */
 10999               	/* frame size = 0 */
 11000               	/* stack size = 6 */
 11001               	.L__stack_usage = 6
 11002 3df0 EC01      		movw r28,r24
 955:switcherator.c ****     int programNumber = getSwitchNumber(commandReceived);
 11003               		.loc 1 955 0
 11004 3df2 0E94 0000 		call getSwitchNumber
 11005               	.LVL943:
 11006 3df6 7C01      		movw r14,r24
 11007               	.LVL944:
 956:switcherator.c ****     if (programNumber >= NUM_COLOR_CHANGES) {
 11008               		.loc 1 956 0
 11009 3df8 86E0      		ldi r24,6
 11010 3dfa E816      		cp r14,r24
 11011 3dfc F104      		cpc r15,__zero_reg__
 11012 3dfe 04F0      		brlt .L758
 957:switcherator.c ****         fail(7);
 11013               		.loc 1 957 0
 11014 3e00 87E0      		ldi r24,lo8(7)
 11015 3e02 90E0      		ldi r25,0
 11016               	/* epilogue start */
 974:switcherator.c **** }
 11017               		.loc 1 974 0
 11018 3e04 DF91      		pop r29
 11019 3e06 CF91      		pop r28
 11020               	.LVL945:
 11021 3e08 1F91      		pop r17
 11022 3e0a 0F91      		pop r16
 11023 3e0c FF90      		pop r15
 11024 3e0e EF90      		pop r14
 11025               	.LVL946:
 957:switcherator.c ****         fail(7);
 11026               		.loc 1 957 0
 11027 3e10 0C94 0000 		jmp fail
 11028               	.LVL947:
 11029               	.L758:
 960:switcherator.c ****     tempLongString[3] = 0;
 11030               		.loc 1 960 0
 11031 3e14 1092 0000 		sts tempLongString+3,__zero_reg__
 961:switcherator.c ****     tempLongString[0] = commandReceived[6];
 11032               		.loc 1 961 0
 11033 3e18 8E81      		ldd r24,Y+6
 11034 3e1a 8093 0000 		sts tempLongString,r24
 962:switcherator.c ****     tempLongString[1] = commandReceived[7];
 11035               		.loc 1 962 0
 11036 3e1e 8F81      		ldd r24,Y+7
 11037 3e20 8093 0000 		sts tempLongString+1,r24
 963:switcherator.c ****     tempLongString[2] = commandReceived[8];
 11038               		.loc 1 963 0
 11039 3e24 8885      		ldd r24,Y+8
 11040 3e26 8093 0000 		sts tempLongString+2,r24
 964:switcherator.c ****     colorChanges[programNumber][0] = atoi(tempLongString);
 11041               		.loc 1 964 0
 11042 3e2a 80E0      		ldi r24,lo8(tempLongString)
 11043 3e2c 90E0      		ldi r25,hi8(tempLongString)
 11044 3e2e 0E94 0000 		call atoi
 11045               	.LVL948:
 11046 3e32 8701      		movw r16,r14
 11047 3e34 000F      		lsl r16
 11048 3e36 111F      		rol r17
 11049 3e38 0E0D      		add r16,r14
 11050 3e3a 1F1D      		adc r17,r15
 11051 3e3c 0050      		subi r16,lo8(-(colorChanges))
 11052 3e3e 1040      		sbci r17,hi8(-(colorChanges))
 11053 3e40 F801      		movw r30,r16
 11054 3e42 8083      		st Z,r24
 965:switcherator.c ****     tempLongString[0] = commandReceived[10];
 11055               		.loc 1 965 0
 11056 3e44 8A85      		ldd r24,Y+10
 11057 3e46 8093 0000 		sts tempLongString,r24
 966:switcherator.c ****     tempLongString[1] = commandReceived[11];
 11058               		.loc 1 966 0
 11059 3e4a 8B85      		ldd r24,Y+11
 11060 3e4c 8093 0000 		sts tempLongString+1,r24
 967:switcherator.c ****     tempLongString[2] = commandReceived[12];
 11061               		.loc 1 967 0
 11062 3e50 8C85      		ldd r24,Y+12
 11063 3e52 8093 0000 		sts tempLongString+2,r24
 968:switcherator.c ****     colorChanges[programNumber][1] = atoi(tempLongString);
 11064               		.loc 1 968 0
 11065 3e56 80E0      		ldi r24,lo8(tempLongString)
 11066 3e58 90E0      		ldi r25,hi8(tempLongString)
 11067 3e5a 0E94 0000 		call atoi
 11068               	.LVL949:
 11069 3e5e F801      		movw r30,r16
 11070 3e60 8183      		std Z+1,r24
 969:switcherator.c ****     tempLongString[0] = commandReceived[14];
 11071               		.loc 1 969 0
 11072 3e62 8E85      		ldd r24,Y+14
 11073 3e64 8093 0000 		sts tempLongString,r24
 970:switcherator.c ****     tempLongString[1] = commandReceived[15];
 11074               		.loc 1 970 0
 11075 3e68 8F85      		ldd r24,Y+15
 11076 3e6a 8093 0000 		sts tempLongString+1,r24
 971:switcherator.c ****     tempLongString[2] = commandReceived[16];
 11077               		.loc 1 971 0
 11078 3e6e 8889      		ldd r24,Y+16
 11079 3e70 8093 0000 		sts tempLongString+2,r24
 972:switcherator.c ****     colorChanges[programNumber][2] = atoi(tempLongString);
 11080               		.loc 1 972 0
 11081 3e74 80E0      		ldi r24,lo8(tempLongString)
 11082 3e76 90E0      		ldi r25,hi8(tempLongString)
 11083 3e78 0E94 0000 		call atoi
 11084               	.LVL950:
 11085 3e7c F801      		movw r30,r16
 11086 3e7e 8283      		std Z+2,r24
 11087               	/* epilogue start */
 974:switcherator.c **** }
 11088               		.loc 1 974 0
 11089 3e80 DF91      		pop r29
 11090 3e82 CF91      		pop r28
 11091               	.LVL951:
 11092 3e84 1F91      		pop r17
 11093 3e86 0F91      		pop r16
 11094 3e88 FF90      		pop r15
 11095 3e8a EF90      		pop r14
 11096               	.LVL952:
 973:switcherator.c ****     ok();
 11097               		.loc 1 973 0
 11098 3e8c 0C94 0000 		jmp ok
 11099               	.LVL953:
 11100               	.LFE25:
 11102               	.global	pwmSetup
 11104               	pwmSetup:
 11105               	.LFB20:
 831:switcherator.c **** void pwmSetup(char * commandReceived) {
 11106               		.loc 1 831 0
 11107               	.LVL954:
 11108 3e90 0F93      		push r16
 11109               	.LCFI288:
 11110 3e92 1F93      		push r17
 11111               	.LCFI289:
 11112 3e94 CF93      		push r28
 11113               	.LCFI290:
 11114 3e96 DF93      		push r29
 11115               	.LCFI291:
 11116               	/* prologue: function */
 11117               	/* frame size = 0 */
 11118               	/* stack size = 4 */
 11119               	.L__stack_usage = 4
 11120 3e98 EC01      		movw r28,r24
 11121               	.LVL955:
 11122 3e9a E0E0      		ldi r30,lo8(switchStuff)
 11123 3e9c F0E0      		ldi r31,hi8(switchStuff)
 11124               	.LVL956:
 11125               	.L762:
 834:switcherator.c ****         if (switchStuff[x] == 70 || switchStuff[x] == 71 || switchStuff[x] == 74 ||
 11126               		.loc 1 834 0
 11127 3e9e 8191      		ld r24,Z+
 11128 3ea0 982F      		mov r25,r24
 11129 3ea2 9654      		subi r25,lo8(-(-70))
 11130 3ea4 9230      		cpi r25,lo8(2)
 11131 3ea6 00F0      		brlo .L760
 834:switcherator.c ****         if (switchStuff[x] == 70 || switchStuff[x] == 71 || switchStuff[x] == 74 ||
 11132               		.loc 1 834 0 is_stmt 0 discriminator 1
 11133 3ea8 8A34      		cpi r24,lo8(74)
 11134 3eaa 01F0      		breq .L760
 11135 3eac 8B34      		cpi r24,lo8(75)
 11136 3eae 01F0      		breq .L760
 835:switcherator.c ****                 switchStuff[x] == 75 || switchStuff[x] == 76 || switchStuff[x] == 77) {
 11137               		.loc 1 835 0 is_stmt 1
 11138 3eb0 8C34      		cpi r24,lo8(76)
 11139 3eb2 01F0      		breq .L760
 835:switcherator.c ****                 switchStuff[x] == 75 || switchStuff[x] == 76 || switchStuff[x] == 77) {
 11140               		.loc 1 835 0 is_stmt 0 discriminator 1
 11141 3eb4 8D34      		cpi r24,lo8(77)
 11142 3eb6 01F4      		brne .L761
 11143               	.L760:
 836:switcherator.c ****             fail(6);
 11144               		.loc 1 836 0 is_stmt 1
 11145 3eb8 86E0      		ldi r24,lo8(6)
 11146 3eba 90E0      		ldi r25,0
 11147               	/* epilogue start */
 876:switcherator.c **** }
 11148               		.loc 1 876 0
 11149 3ebc DF91      		pop r29
 11150 3ebe CF91      		pop r28
 11151               	.LVL957:
 11152 3ec0 1F91      		pop r17
 11153 3ec2 0F91      		pop r16
 836:switcherator.c ****             fail(6);
 11154               		.loc 1 836 0
 11155 3ec4 0C94 0000 		jmp fail
 11156               	.LVL958:
 11157               	.L761:
 833:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 11158               		.loc 1 833 0
 11159 3ec8 80E0      		ldi r24,hi8(switchStuff+16)
 11160 3eca E030      		cpi r30,lo8(switchStuff+16)
 11161 3ecc F807      		cpc r31,r24
 11162 3ece 01F4      		brne .L762
 11163               	.LVL959:
 842:switcherator.c ****     tempIntString[0] = commandReceived[5];
 11164               		.loc 1 842 0
 11165 3ed0 8D81      		ldd r24,Y+5
 11166 3ed2 8093 0000 		sts tempIntString,r24
 843:switcherator.c ****     tempIntString[1] = commandReceived[6];
 11167               		.loc 1 843 0
 11168 3ed6 8E81      		ldd r24,Y+6
 11169 3ed8 8093 0000 		sts tempIntString+1,r24
 844:switcherator.c ****     switchNumber = atoi(tempIntString);
 11170               		.loc 1 844 0
 11171 3edc 80E0      		ldi r24,lo8(tempIntString)
 11172 3ede 90E0      		ldi r25,hi8(tempIntString)
 11173 3ee0 0E94 0000 		call atoi
 11174               	.LVL960:
 11175 3ee4 8C01      		movw r16,r24
 11176               	.LVL961:
 845:switcherator.c ****     clearTheSwitch(switchNumber);
 11177               		.loc 1 845 0
 11178 3ee6 0E94 0000 		call clearTheSwitch
 11179               	.LVL962:
 847:switcherator.c ****     if (commandReceived[8] == 'H' || commandReceived[8] == 'h' || commandReceived[8] == '1') {
 11180               		.loc 1 847 0
 11181 3eea 8885      		ldd r24,Y+8
 11182 3eec 8834      		cpi r24,lo8(72)
 11183 3eee 01F0      		breq .L763
 847:switcherator.c ****     if (commandReceived[8] == 'H' || commandReceived[8] == 'h' || commandReceived[8] == '1') {
 11184               		.loc 1 847 0 is_stmt 0 discriminator 1
 11185 3ef0 8836      		cpi r24,lo8(104)
 11186 3ef2 01F0      		breq .L763
 11187 3ef4 8133      		cpi r24,lo8(49)
 11188 3ef6 01F4      		brne .L764
 11189               	.L763:
 848:switcherator.c ****         switchStuff[switchNumber] = 201;
 11190               		.loc 1 848 0 is_stmt 1
 11191 3ef8 F801      		movw r30,r16
 11192 3efa E050      		subi r30,lo8(-(switchStuff))
 11193 3efc F040      		sbci r31,hi8(-(switchStuff))
 11194 3efe 89EC      		ldi r24,lo8(-55)
 11195 3f00 00C0      		rjmp .L789
 11196               	.L764:
 11197 3f02 F801      		movw r30,r16
 11198 3f04 E050      		subi r30,lo8(-(switchStuff))
 11199 3f06 F040      		sbci r31,hi8(-(switchStuff))
 849:switcherator.c ****     } else if (commandReceived[8] == 'C' || commandReceived[8] == 'c') {
 11200               		.loc 1 849 0
 11201 3f08 8334      		cpi r24,lo8(67)
 11202 3f0a 01F0      		breq .L766
 849:switcherator.c ****     } else if (commandReceived[8] == 'C' || commandReceived[8] == 'c') {
 11203               		.loc 1 849 0 is_stmt 0 discriminator 1
 11204 3f0c 8336      		cpi r24,lo8(99)
 11205 3f0e 01F4      		brne .L767
 11206               	.L766:
 850:switcherator.c ****         switchStuff[switchNumber] = 202;
 11207               		.loc 1 850 0 is_stmt 1
 11208 3f10 8AEC      		ldi r24,lo8(-54)
 11209 3f12 00C0      		rjmp .L789
 11210               	.L767:
 852:switcherator.c ****         switchStuff[switchNumber] = 200;
 11211               		.loc 1 852 0
 11212 3f14 88EC      		ldi r24,lo8(-56)
 11213               	.L789:
 11214 3f16 8083      		st Z,r24
 854:switcherator.c ****     DDRD |= (1 << PIND3) | (1 << PIND5) | (1 << PIND6);
 11215               		.loc 1 854 0
 11216 3f18 8AB1      		in r24,0xa
 11217 3f1a 8866      		ori r24,lo8(104)
 11218 3f1c 8AB9      		out 0xa,r24
 856:switcherator.c ****     Red = 0;
 11219               		.loc 1 856 0
 11220 3f1e 1092 B400 		sts 180,__zero_reg__
 857:switcherator.c ****     Green = 0;
 11221               		.loc 1 857 0
 11222 3f22 18BC      		out 0x28,__zero_reg__
 858:switcherator.c ****     Blue = 0;
 11223               		.loc 1 858 0
 11224 3f24 17BC      		out 0x27,__zero_reg__
 861:switcherator.c ****     if (commandReceived[7] == '0') {
 11225               		.loc 1 861 0
 11226 3f26 8F81      		ldd r24,Y+7
 11227 3f28 8033      		cpi r24,lo8(48)
 11228 3f2a 01F4      		brne .L768
 862:switcherator.c ****         pwmdir = 0;
 11229               		.loc 1 862 0
 11230 3f2c 1092 0000 		sts pwmdir,__zero_reg__
 863:switcherator.c ****         TCCR0A = (1 << COM0A0) | (1 << COM0A1) | (1 << COM0B0) | (1 << COM0B1) | (1 << WGM00);
 11231               		.loc 1 863 0
 11232 3f30 81EF      		ldi r24,lo8(-15)
 11233 3f32 84BD      		out 0x24,r24
 864:switcherator.c ****         TCCR2A = (1 << COM2B0) | (1 << COM2B1) | (1 << WGM20);
 11234               		.loc 1 864 0
 11235 3f34 81E3      		ldi r24,lo8(49)
 11236 3f36 00C0      		rjmp .L790
 11237               	.L768:
 866:switcherator.c ****         pwmdir = 1;
 11238               		.loc 1 866 0
 11239 3f38 81E0      		ldi r24,lo8(1)
 11240 3f3a 8093 0000 		sts pwmdir,r24
 867:switcherator.c ****         TCCR0A = (1 << COM0A1) | (1 << COM0B1) | (1 << WGM00);
 11241               		.loc 1 867 0
 11242 3f3e 81EA      		ldi r24,lo8(-95)
 11243 3f40 84BD      		out 0x24,r24
 868:switcherator.c ****         TCCR2A = (1 << COM2B1) | (1 << WGM20);
 11244               		.loc 1 868 0
 11245 3f42 81E2      		ldi r24,lo8(33)
 11246               	.L790:
 11247 3f44 8093 B000 		sts 176,r24
 871:switcherator.c ****     TCCR0B = (1 << CS01) | (1 << CS00);
 11248               		.loc 1 871 0
 11249 3f48 83E0      		ldi r24,lo8(3)
 11250 3f4a 85BD      		out 0x25,r24
 873:switcherator.c ****     TCCR2B = (1 << CS22); // F_CPU/64
 11251               		.loc 1 873 0
 11252 3f4c 84E0      		ldi r24,lo8(4)
 11253 3f4e 8093 B100 		sts 177,r24
 11254               	/* epilogue start */
 876:switcherator.c **** }
 11255               		.loc 1 876 0
 11256 3f52 DF91      		pop r29
 11257 3f54 CF91      		pop r28
 11258               	.LVL963:
 11259 3f56 1F91      		pop r17
 11260 3f58 0F91      		pop r16
 11261               	.LVL964:
 875:switcherator.c ****     ok();
 11262               		.loc 1 875 0
 11263 3f5a 0C94 0000 		jmp ok
 11264               	.LVL965:
 11265               	.LFE20:
 11267               	.global	startSwitch
 11269               	startSwitch:
 11270               	.LFB17:
 646:switcherator.c **** void startSwitch(char * commandReceived) {
 11271               		.loc 1 646 0
 11272               	.LVL966:
 11273 3f5e EF92      		push r14
 11274               	.LCFI292:
 11275 3f60 FF92      		push r15
 11276               	.LCFI293:
 11277 3f62 0F93      		push r16
 11278               	.LCFI294:
 11279 3f64 1F93      		push r17
 11280               	.LCFI295:
 11281 3f66 CF93      		push r28
 11282               	.LCFI296:
 11283 3f68 DF93      		push r29
 11284               	.LCFI297:
 11285 3f6a 00D0      		rcall .
 11286 3f6c 00D0      		rcall .
 11287               	.LCFI298:
 11288 3f6e CDB7      		in r28,__SP_L__
 11289 3f70 DEB7      		in r29,__SP_H__
 11290               	.LCFI299:
 11291               	/* prologue: function */
 11292               	/* frame size = 4 */
 11293               	/* stack size = 10 */
 11294               	.L__stack_usage = 10
 11295 3f72 7C01      		movw r14,r24
 11296               	.LVL967:
 650:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 11297               		.loc 1 650 0
 11298 3f74 0E94 0000 		call getSwitchNumber
 11299               	.LVL968:
 11300 3f78 8C01      		movw r16,r24
 11301               	.LVL969:
 651:switcherator.c ****     if ((switchNumber >= NUM_SWITCHES) || (switchStuff[switchNumber] == 255)) {
 11302               		.loc 1 651 0
 11303 3f7a 8031      		cpi r24,16
 11304 3f7c 9105      		cpc r25,__zero_reg__
 11305 3f7e 04F4      		brge .L792
 651:switcherator.c ****     if ((switchNumber >= NUM_SWITCHES) || (switchStuff[switchNumber] == 255)) {
 11306               		.loc 1 651 0 is_stmt 0 discriminator 1
 11307 3f80 FC01      		movw r30,r24
 11308 3f82 E050      		subi r30,lo8(-(switchStuff))
 11309 3f84 F040      		sbci r31,hi8(-(switchStuff))
 11310 3f86 2081      		ld r18,Z
 11311 3f88 2F3F      		cpi r18,lo8(-1)
 11312 3f8a 01F4      		brne .L793
 11313               	.L792:
 652:switcherator.c ****         fail(1);
 11314               		.loc 1 652 0 is_stmt 1
 11315 3f8c 81E0      		ldi r24,lo8(1)
 11316 3f8e 90E0      		ldi r25,0
 11317 3f90 00C0      		rjmp .L809
 11318               	.L793:
 656:switcherator.c ****     tempHugeString[0] = commandReceived[5];
 11319               		.loc 1 656 0
 11320 3f92 F701      		movw r30,r14
 11321 3f94 8581      		ldd r24,Z+5
 11322 3f96 8093 0000 		sts tempHugeString,r24
 657:switcherator.c ****     tempHugeString[1] = commandReceived[6];
 11323               		.loc 1 657 0
 11324 3f9a 8681      		ldd r24,Z+6
 11325 3f9c 8093 0000 		sts tempHugeString+1,r24
 658:switcherator.c ****     tempHugeString[2] = commandReceived[7];
 11326               		.loc 1 658 0
 11327 3fa0 8781      		ldd r24,Z+7
 11328 3fa2 8093 0000 		sts tempHugeString+2,r24
 659:switcherator.c ****     tempHugeString[3] = commandReceived[8];
 11329               		.loc 1 659 0
 11330 3fa6 8085      		ldd r24,Z+8
 11331 3fa8 8093 0000 		sts tempHugeString+3,r24
 660:switcherator.c ****     tempHugeString[4] = commandReceived[9];
 11332               		.loc 1 660 0
 11333 3fac 8185      		ldd r24,Z+9
 11334 3fae 8093 0000 		sts tempHugeString+4,r24
 661:switcherator.c ****     tempHugeString[5] = commandReceived[10];
 11335               		.loc 1 661 0
 11336 3fb2 8285      		ldd r24,Z+10
 11337 3fb4 8093 0000 		sts tempHugeString+5,r24
 662:switcherator.c ****     duration = atol(tempHugeString);
 11338               		.loc 1 662 0
 11339 3fb8 80E0      		ldi r24,lo8(tempHugeString)
 11340 3fba 90E0      		ldi r25,hi8(tempHugeString)
 11341 3fbc 2C83      		std Y+4,r18
 11342 3fbe 0E94 0000 		call atol
 11343               	.LVL970:
 11344 3fc2 462F      		mov r20,r22
 11345 3fc4 572F      		mov r21,r23
 11346 3fc6 BC01      		movw r22,r24
 11347               	.LVL971:
 663:switcherator.c ****     if (duration == 0) {
 11348               		.loc 1 663 0
 11349 3fc8 2C81      		ldd r18,Y+4
 11350 3fca 4115      		cp r20,__zero_reg__
 11351 3fcc 5105      		cpc r21,__zero_reg__
 11352 3fce 6105      		cpc r22,__zero_reg__
 11353 3fd0 7105      		cpc r23,__zero_reg__
 11354 3fd2 01F4      		brne .L795
 664:switcherator.c ****         fail(5);
 11355               		.loc 1 664 0
 11356 3fd4 85E0      		ldi r24,lo8(5)
 11357 3fd6 90E0      		ldi r25,0
 11358               	.LVL972:
 11359               	.L809:
 11360 3fd8 0E94 0000 		call fail
 11361               	.LVL973:
 665:switcherator.c ****         return;
 11362               		.loc 1 665 0
 11363 3fdc 00C0      		rjmp .L791
 11364               	.LVL974:
 11365               	.L795:
 668:switcherator.c ****     if ((weeklySeconds + duration) > switchStatus[switchNumber])
 11366               		.loc 1 668 0
 11367 3fde 8091 0000 		lds r24,weeklySeconds
 11368 3fe2 9091 0000 		lds r25,weeklySeconds+1
 11369 3fe6 A091 0000 		lds r26,weeklySeconds+2
 11370 3fea B091 0000 		lds r27,weeklySeconds+3
 11371 3fee 840F      		add r24,r20
 11372 3ff0 951F      		adc r25,r21
 11373 3ff2 A61F      		adc r26,r22
 11374 3ff4 B71F      		adc r27,r23
 11375 3ff6 F801      		movw r30,r16
 11376 3ff8 EE0F      		lsl r30
 11377 3ffa FF1F      		rol r31
 11378 3ffc EE0F      		lsl r30
 11379 3ffe FF1F      		rol r31
 11380 4000 E050      		subi r30,lo8(-(switchStatus))
 11381 4002 F040      		sbci r31,hi8(-(switchStatus))
 11382 4004 4081      		ld r20,Z
 11383 4006 5181      		ldd r21,Z+1
 11384 4008 6281      		ldd r22,Z+2
 11385 400a 7381      		ldd r23,Z+3
 11386               	.LVL975:
 11387 400c 4817      		cp r20,r24
 11388 400e 5907      		cpc r21,r25
 11389 4010 6A07      		cpc r22,r26
 11390 4012 7B07      		cpc r23,r27
 11391 4014 00F4      		brsh .L796
 669:switcherator.c ****         switchStatus[switchNumber] = (weeklySeconds + duration);
 11392               		.loc 1 669 0
 11393 4016 8083      		st Z,r24
 11394 4018 9183      		std Z+1,r25
 11395 401a A283      		std Z+2,r26
 11396 401c B383      		std Z+3,r27
 11397               	.L796:
 672:switcherator.c ****     if (switchStuff[switchNumber] >= 200 && switchStuff[switchNumber] <= 220) {
 11398               		.loc 1 672 0
 11399 401e 822F      		mov r24,r18
 11400 4020 885C      		subi r24,lo8(-(56))
 11401 4022 8531      		cpi r24,lo8(21)
 11402 4024 00F0      		brlo .+2
 11403 4026 00C0      		rjmp .L797
 674:switcherator.c ****         if (switchStuff[switchNumber] == 200) {
 11404               		.loc 1 674 0
 11405 4028 283C      		cpi r18,lo8(-56)
 11406 402a 01F4      		brne .L798
 677:switcherator.c ****             green = pwmValues[1];
 11407               		.loc 1 677 0
 11408 402c 8091 0000 		lds r24,pwmValues+1
 678:switcherator.c ****             blue = pwmValues[2];
 11409               		.loc 1 678 0
 11410 4030 E091 0000 		lds r30,pwmValues+2
 679:switcherator.c ****             red = red * bright / 16;
 11411               		.loc 1 679 0
 11412 4034 6091 0000 		lds r22,bright
 11413 4038 7091 0000 		lds r23,bright+1
 676:switcherator.c ****             red = pwmValues[0];
 11414               		.loc 1 676 0
 11415 403c 9091 0000 		lds r25,pwmValues
 679:switcherator.c ****             red = red * bright / 16;
 11416               		.loc 1 679 0
 11417 4040 969F      		mul r25,r22
 11418 4042 A001      		movw r20,r0
 11419 4044 979F      		mul r25,r23
 11420 4046 500D      		add r21,r0
 11421 4048 1124      		clr __zero_reg__
 11422 404a F4E0      		ldi r31,4
 11423               		1:
 11424 404c 5695      		lsr r21
 11425 404e 4795      		ror r20
 11426 4050 FA95      		dec r31
 11427 4052 01F4      		brne 1b
 11428 4054 5093 0000 		sts red+1,r21
 11429 4058 4093 0000 		sts red,r20
 680:switcherator.c ****             green = green * bright / 16;
 11430               		.loc 1 680 0
 11431 405c 869F      		mul r24,r22
 11432 405e 9001      		movw r18,r0
 11433 4060 879F      		mul r24,r23
 11434 4062 300D      		add r19,r0
 11435 4064 1124      		clr __zero_reg__
 11436 4066 A4E0      		ldi r26,4
 11437               		1:
 11438 4068 3695      		lsr r19
 11439 406a 2795      		ror r18
 11440 406c AA95      		dec r26
 11441 406e 01F4      		brne 1b
 11442 4070 3093 0000 		sts green+1,r19
 11443 4074 2093 0000 		sts green,r18
 681:switcherator.c ****             blue = blue * bright / 16;
 11444               		.loc 1 681 0
 11445 4078 E69F      		mul r30,r22
 11446 407a C001      		movw r24,r0
 11447 407c E79F      		mul r30,r23
 11448 407e 900D      		add r25,r0
 11449 4080 1124      		clr __zero_reg__
 11450 4082 B4E0      		ldi r27,4
 11451               		1:
 11452 4084 9695      		lsr r25
 11453 4086 8795      		ror r24
 11454 4088 BA95      		dec r27
 11455 408a 01F4      		brne 1b
 11456 408c 9093 0000 		sts blue+1,r25
 11457 4090 8093 0000 		sts blue,r24
 682:switcherator.c ****             Red = red;
 11458               		.loc 1 682 0
 11459 4094 4093 B400 		sts 180,r20
 683:switcherator.c ****             Green = green;
 11460               		.loc 1 683 0
 11461 4098 28BD      		out 0x28,r18
 684:switcherator.c ****             Blue = blue;
 11462               		.loc 1 684 0
 11463 409a 87BD      		out 0x27,r24
 11464 409c 00C0      		rjmp .L799
 11465               	.L798:
 685:switcherator.c ****         } else if (switchStuff[switchNumber] == 202) {
 11466               		.loc 1 685 0
 11467 409e 2A3C      		cpi r18,lo8(-54)
 11468 40a0 01F4      		brne .L800
 686:switcherator.c ****             runColorChanges = 1;
 11469               		.loc 1 686 0
 11470 40a2 81E0      		ldi r24,lo8(1)
 11471 40a4 8093 0000 		sts runColorChanges,r24
 11472 40a8 00C0      		rjmp .L799
 11473               	.L800:
 687:switcherator.c ****         } else if (switchStuff[switchNumber] == 212) {
 11474               		.loc 1 687 0
 11475 40aa 243D      		cpi r18,lo8(-44)
 11476 40ac 01F4      		brne .L801
 688:switcherator.c ****             bright = switchBright[switchNumber];
 11477               		.loc 1 688 0
 11478 40ae F801      		movw r30,r16
 11479 40b0 E050      		subi r30,lo8(-(switchBright))
 11480 40b2 F040      		sbci r31,hi8(-(switchBright))
 11481 40b4 8081      		ld r24,Z
 11482 40b6 8093 0000 		sts bright,r24
 11483 40ba 1092 0000 		sts bright+1,__zero_reg__
 11484 40be 00C0      		rjmp .L799
 11485               	.L801:
 690:switcherator.c ****             runHue = 1;
 11486               		.loc 1 690 0
 11487 40c0 81E0      		ldi r24,lo8(1)
 11488 40c2 8093 0000 		sts runHue,r24
 11489 40c6 00C0      		rjmp .L799
 11490               	.L797:
 11491               	.LVL976:
 11492               	.LBB29:
 701:switcherator.c ****         getPort(switchNumber, port, pin, direction);
 11493               		.loc 1 701 0
 11494 40c8 9E01      		movw r18,r28
 11495 40ca 2F5F      		subi r18,-1
 11496 40cc 3F4F      		sbci r19,-1
 11497 40ce AE01      		movw r20,r28
 11498 40d0 4E5F      		subi r20,-2
 11499 40d2 5F4F      		sbci r21,-1
 11500 40d4 BE01      		movw r22,r28
 11501 40d6 6D5F      		subi r22,-3
 11502 40d8 7F4F      		sbci r23,-1
 11503 40da C801      		movw r24,r16
 11504 40dc 0E94 0000 		call getPort
 11505               	.LVL977:
 703:switcherator.c ****         realPin = pin[0];
 11506               		.loc 1 703 0
 11507 40e0 3A81      		ldd r19,Y+2
 11508               	.LVL978:
 704:switcherator.c ****         if (port[0] == 'B')
 11509               		.loc 1 704 0
 11510 40e2 8B81      		ldd r24,Y+3
 11511 40e4 8234      		cpi r24,lo8(66)
 11512 40e6 01F0      		breq .L805
 711:switcherator.c ****         else if (port[0] == 'C')
 11513               		.loc 1 711 0
 11514 40e8 8334      		cpi r24,lo8(67)
 11515 40ea 01F0      		breq .L806
 715:switcherator.c ****         else if (port[0] == 'D')
 11516               		.loc 1 715 0
 11517 40ec 8434      		cpi r24,lo8(68)
 11518 40ee 01F0      		breq .L807
 700:switcherator.c ****         volatile unsigned char *thisPort = 0;
 11519               		.loc 1 700 0
 11520 40f0 E0E0      		ldi r30,0
 11521 40f2 F0E0      		ldi r31,0
 11522 40f4 00C0      		rjmp .L802
 11523               	.L805:
 705:switcherator.c ****             thisPort = &PORTB;
 11524               		.loc 1 705 0
 11525 40f6 E5E2      		ldi r30,lo8(37)
 11526 40f8 F0E0      		ldi r31,0
 11527 40fa 00C0      		rjmp .L802
 11528               	.L806:
 712:switcherator.c ****             thisPort = &PORTC;
 11529               		.loc 1 712 0
 11530 40fc E8E2      		ldi r30,lo8(40)
 11531 40fe F0E0      		ldi r31,0
 11532 4100 00C0      		rjmp .L802
 11533               	.L807:
 716:switcherator.c ****             thisPort = &PORTD;
 11534               		.loc 1 716 0
 11535 4102 EBE2      		ldi r30,lo8(43)
 11536 4104 F0E0      		ldi r31,0
 11537               	.L802:
 11538               	.LVL979:
 740:switcherator.c ****         if (direction[0] == 0) {
 11539               		.loc 1 740 0
 11540 4106 8981      		ldd r24,Y+1
 741:switcherator.c ****             *thisPort &= ~(1 << realPin);
 11541               		.loc 1 741 0
 11542 4108 2081      		ld r18,Z
 740:switcherator.c ****         if (direction[0] == 0) {
 11543               		.loc 1 740 0
 11544 410a 8111      		cpse r24,__zero_reg__
 11545 410c 00C0      		rjmp .L803
 741:switcherator.c ****             *thisPort &= ~(1 << realPin);
 11546               		.loc 1 741 0
 11547 410e 81E0      		ldi r24,lo8(1)
 11548 4110 90E0      		ldi r25,0
 11549 4112 032E      		mov r0,r19
 11550 4114 00C0      		rjmp 2f
 11551               		1:
 11552 4116 880F      		lsl r24
 11553               		2:
 11554 4118 0A94      		dec r0
 11555 411a 02F4      		brpl 1b
 11556 411c 8095      		com r24
 11557 411e 2823      		and r18,r24
 11558 4120 00C0      		rjmp .L808
 11559               	.L803:
 743:switcherator.c ****             *thisPort |= (1 << realPin);
 11560               		.loc 1 743 0
 11561 4122 81E0      		ldi r24,lo8(1)
 11562 4124 90E0      		ldi r25,0
 11563 4126 00C0      		rjmp 2f
 11564               		1:
 11565 4128 880F      		lsl r24
 11566               		2:
 11567 412a 3A95      		dec r19
 11568 412c 02F4      		brpl 1b
 11569 412e 282B      		or r18,r24
 11570               	.L808:
 11571 4130 2083      		st Z,r18
 11572               	.LVL980:
 11573               	.L799:
 11574               	.LBE29:
 746:switcherator.c ****     ok();
 11575               		.loc 1 746 0
 11576 4132 0E94 0000 		call ok
 11577               	.LVL981:
 11578               	.L791:
 11579               	/* epilogue start */
 747:switcherator.c **** }
 11580               		.loc 1 747 0
 11581 4136 0F90      		pop __tmp_reg__
 11582 4138 0F90      		pop __tmp_reg__
 11583 413a 0F90      		pop __tmp_reg__
 11584 413c 0F90      		pop __tmp_reg__
 11585 413e DF91      		pop r29
 11586 4140 CF91      		pop r28
 11587 4142 1F91      		pop r17
 11588 4144 0F91      		pop r16
 11589               	.LVL982:
 11590 4146 FF90      		pop r15
 11591 4148 EF90      		pop r14
 11592               	.LVL983:
 11593 414a 0895      		ret
 11594               	.LFE17:
 11596               	.global	setNewSwitch
 11598               	setNewSwitch:
 11599               	.LFB13:
 416:switcherator.c **** void setNewSwitch(char * commandReceived) {
 11600               		.loc 1 416 0
 11601               	.LVL984:
 11602 414c AF92      		push r10
 11603               	.LCFI300:
 11604 414e BF92      		push r11
 11605               	.LCFI301:
 11606 4150 CF92      		push r12
 11607               	.LCFI302:
 11608 4152 DF92      		push r13
 11609               	.LCFI303:
 11610 4154 EF92      		push r14
 11611               	.LCFI304:
 11612 4156 FF92      		push r15
 11613               	.LCFI305:
 11614 4158 0F93      		push r16
 11615               	.LCFI306:
 11616 415a 1F93      		push r17
 11617               	.LCFI307:
 11618 415c CF93      		push r28
 11619               	.LCFI308:
 11620 415e DF93      		push r29
 11621               	.LCFI309:
 11622 4160 1F92      		push __zero_reg__
 11623               	.LCFI310:
 11624 4162 CDB7      		in r28,__SP_L__
 11625 4164 DEB7      		in r29,__SP_H__
 11626               	.LCFI311:
 11627               	/* prologue: function */
 11628               	/* frame size = 1 */
 11629               	/* stack size = 11 */
 11630               	.L__stack_usage = 11
 11631 4166 6C01      		movw r12,r24
 11632               	.LVL985:
 426:switcherator.c ****     tempIntString[0] = '0';
 11633               		.loc 1 426 0
 11634 4168 80E3      		ldi r24,lo8(48)
 11635               	.LVL986:
 11636 416a 8093 0000 		sts tempIntString,r24
 427:switcherator.c ****     tempIntString[1] = commandReceived[6];
 11637               		.loc 1 427 0
 11638 416e D601      		movw r26,r12
 11639 4170 1696      		adiw r26,6
 11640 4172 8C91      		ld r24,X
 11641 4174 8093 0000 		sts tempIntString+1,r24
 428:switcherator.c ****     pin = atoi(tempIntString);
 11642               		.loc 1 428 0
 11643 4178 80E0      		ldi r24,lo8(tempIntString)
 11644 417a 90E0      		ldi r25,hi8(tempIntString)
 11645 417c 0E94 0000 		call atoi
 11646               	.LVL987:
 11647 4180 F82E      		mov r15,r24
 11648               	.LVL988:
 430:switcherator.c ****     tempIntString[1] = commandReceived[7];
 11649               		.loc 1 430 0
 11650 4182 F601      		movw r30,r12
 11651 4184 8781      		ldd r24,Z+7
 11652 4186 8093 0000 		sts tempIntString+1,r24
 431:switcherator.c ****     direction = atoi(tempIntString);
 11653               		.loc 1 431 0
 11654 418a 80E0      		ldi r24,lo8(tempIntString)
 11655 418c 90E0      		ldi r25,hi8(tempIntString)
 11656 418e 0E94 0000 		call atoi
 11657               	.LVL989:
 11658 4192 E82E      		mov r14,r24
 11659               	.LVL990:
 432:switcherator.c ****     port = commandReceived[5];
 11660               		.loc 1 432 0
 11661 4194 D601      		movw r26,r12
 11662 4196 1596      		adiw r26,5
 11663 4198 2C91      		ld r18,X
 11664               	.LVL991:
 433:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 11665               		.loc 1 433 0
 11666 419a C601      		movw r24,r12
 11667 419c 2983      		std Y+1,r18
 11668 419e 0E94 0000 		call getSwitchNumber
 11669               	.LVL992:
 11670 41a2 8C01      		movw r16,r24
 11671               	.LVL993:
 435:switcherator.c ****     clearTheSwitch(switchNumber);
 11672               		.loc 1 435 0
 11673 41a4 0E94 0000 		call clearTheSwitch
 11674               	.LVL994:
 437:switcherator.c ****     if (port == 'B' || port == 'b') {
 11675               		.loc 1 437 0
 11676 41a8 2981      		ldd r18,Y+1
 11677 41aa 2234      		cpi r18,lo8(66)
 11678 41ac 01F4      		brne .+2
 11679 41ae 00C0      		rjmp .L821
 437:switcherator.c ****     if (port == 'B' || port == 'b') {
 11680               		.loc 1 437 0 is_stmt 0 discriminator 1
 11681 41b0 2236      		cpi r18,lo8(98)
 11682 41b2 01F4      		brne .+2
 11683 41b4 00C0      		rjmp .L821
 448:switcherator.c ****     } else if (port == 'C' || port == 'c') {
 11684               		.loc 1 448 0 is_stmt 1
 11685 41b6 2334      		cpi r18,lo8(67)
 11686 41b8 01F4      		brne .+2
 11687 41ba 00C0      		rjmp .L823
 448:switcherator.c ****     } else if (port == 'C' || port == 'c') {
 11688               		.loc 1 448 0 is_stmt 0 discriminator 1
 11689 41bc 2336      		cpi r18,lo8(99)
 11690 41be 01F4      		brne .+2
 11691 41c0 00C0      		rjmp .L823
 454:switcherator.c ****     } else if (port == 'D' || port == 'd') {
 11692               		.loc 1 454 0 is_stmt 1
 11693 41c2 2434      		cpi r18,lo8(68)
 11694 41c4 01F4      		brne .+2
 11695 41c6 00C0      		rjmp .L825
 454:switcherator.c ****     } else if (port == 'D' || port == 'd') {
 11696               		.loc 1 454 0 is_stmt 0 discriminator 1
 11697 41c8 2436      		cpi r18,lo8(100)
 11698 41ca 01F0      		breq .+2
 11699 41cc 00C0      		rjmp .L835
 11700 41ce 00C0      		rjmp .L825
 11701               	.LVL995:
 11702               	.L836:
 495:switcherator.c ****     } else if ((switchNumber >= NUM_SWITCHES) ||
 11703               		.loc 1 495 0 is_stmt 1 discriminator 1
 11704 41d0 0115      		cp r16,__zero_reg__
 11705 41d2 1105      		cpc r17,__zero_reg__
 11706 41d4 01F4      		brne .L813
 496:switcherator.c ****             ((switchNumber == 0) && (commandReceived[3] != '0') && (commandReceived[4] != 0))) {
 11707               		.loc 1 496 0
 11708 41d6 D601      		movw r26,r12
 11709 41d8 1396      		adiw r26,3
 11710 41da 8C91      		ld r24,X
 11711 41dc 1397      		sbiw r26,3
 11712 41de 8033      		cpi r24,lo8(48)
 11713 41e0 01F0      		breq .L813
 496:switcherator.c ****             ((switchNumber == 0) && (commandReceived[3] != '0') && (commandReceived[4] != 0))) {
 11714               		.loc 1 496 0 is_stmt 0 discriminator 1
 11715 41e2 1496      		adiw r26,4
 11716 41e4 8C91      		ld r24,X
 11717 41e6 8823      		tst r24
 11718 41e8 01F0      		breq .L813
 11719               	.L818:
 497:switcherator.c ****         fail(1);
 11720               		.loc 1 497 0 is_stmt 1
 11721 41ea 81E0      		ldi r24,lo8(1)
 11722 41ec 90E0      		ldi r25,0
 11723 41ee 00C0      		rjmp .L837
 11724               	.L813:
 428:switcherator.c ****     pin = atoi(tempIntString);
 11725               		.loc 1 428 0
 11726 41f0 4F2D      		mov r20,r15
 498:switcherator.c ****     } else if ((pin > 7) || ((pin == 0) && (commandReceived[6] != '0'))) {
 11727               		.loc 1 498 0
 11728 41f2 4830      		cpi r20,lo8(8)
 11729 41f4 00F4      		brsh .L814
 498:switcherator.c ****     } else if ((pin > 7) || ((pin == 0) && (commandReceived[6] != '0'))) {
 11730               		.loc 1 498 0 is_stmt 0 discriminator 1
 11731 41f6 F110      		cpse r15,__zero_reg__
 11732 41f8 00C0      		rjmp .L815
 11733 41fa D601      		movw r26,r12
 11734 41fc 1696      		adiw r26,6
 11735 41fe 8C91      		ld r24,X
 11736 4200 8033      		cpi r24,lo8(48)
 11737 4202 01F0      		breq .L815
 11738               	.L814:
 499:switcherator.c ****         fail(4);
 11739               		.loc 1 499 0 is_stmt 1
 11740 4204 84E0      		ldi r24,lo8(4)
 11741 4206 90E0      		ldi r25,0
 11742 4208 00C0      		rjmp .L837
 11743               	.L815:
 502:switcherator.c ****         *realDDR |= (1 << originalPin);
 11744               		.loc 1 502 0
 11745 420a D501      		movw r26,r10
 11746 420c 5C91      		ld r21,X
 11747 420e 21E0      		ldi r18,lo8(1)
 11748 4210 30E0      		ldi r19,0
 11749 4212 0F2C      		mov r0,r15
 11750 4214 00C0      		rjmp 2f
 11751               		1:
 11752 4216 220F      		lsl r18
 11753               		2:
 11754 4218 0A94      		dec r0
 11755 421a 02F4      		brpl 1b
 11756 421c 522B      		or r21,r18
 11757 421e 5C93      		st X,r21
 504:switcherator.c ****         pinMultiplied = pin * 2;
 11758               		.loc 1 504 0
 11759 4220 440F      		lsl r20
 11760               	.LVL996:
 507:switcherator.c ****         switchStuff[switchNumber] = pin;
 11761               		.loc 1 507 0
 11762 4222 D801      		movw r26,r16
 11763 4224 A050      		subi r26,lo8(-(switchStuff))
 11764 4226 B040      		sbci r27,hi8(-(switchStuff))
 506:switcherator.c ****         pin = pinMultiplied + pinSubtractee;
 11765               		.loc 1 506 0
 11766 4228 490F      		add r20,r25
 11767               	.LVL997:
 507:switcherator.c ****         switchStuff[switchNumber] = pin;
 11768               		.loc 1 507 0
 11769 422a 4C93      		st X,r20
 511:switcherator.c ****             *realPort |= (1 << originalPin);
 11770               		.loc 1 511 0
 11771 422c 8081      		ld r24,Z
 509:switcherator.c ****         if (direction == 0) {
 11772               		.loc 1 509 0
 11773 422e E110      		cpse r14,__zero_reg__
 11774 4230 00C0      		rjmp .L816
 511:switcherator.c ****             *realPort |= (1 << originalPin);
 11775               		.loc 1 511 0
 11776 4232 822B      		or r24,r18
 11777 4234 8083      		st Z,r24
 11778 4236 00C0      		rjmp .L817
 11779               	.L816:
 513:switcherator.c ****             *realPort &= ~(1 << originalPin);
 11780               		.loc 1 513 0
 11781 4238 2095      		com r18
 11782 423a 8223      		and r24,r18
 11783 423c 8083      		st Z,r24
 514:switcherator.c ****             switchStuff[switchNumber]++;
 11784               		.loc 1 514 0
 11785 423e 8C91      		ld r24,X
 11786 4240 8F5F      		subi r24,lo8(-(1))
 11787 4242 8C93      		st X,r24
 11788               	.L817:
 11789               	/* epilogue start */
 518:switcherator.c **** }
 11790               		.loc 1 518 0
 11791 4244 0F90      		pop __tmp_reg__
 11792 4246 DF91      		pop r29
 11793 4248 CF91      		pop r28
 11794 424a 1F91      		pop r17
 11795 424c 0F91      		pop r16
 11796               	.LVL998:
 11797 424e FF90      		pop r15
 11798               	.LVL999:
 11799 4250 EF90      		pop r14
 11800               	.LVL1000:
 11801 4252 DF90      		pop r13
 11802 4254 CF90      		pop r12
 11803               	.LVL1001:
 11804 4256 BF90      		pop r11
 11805 4258 AF90      		pop r10
 11806               	.LVL1002:
 516:switcherator.c ****         ok();
 11807               		.loc 1 516 0
 11808 425a 0C94 0000 		jmp ok
 11809               	.LVL1003:
 11810               	.L835:
 494:switcherator.c ****         fail(2);
 11811               		.loc 1 494 0
 11812 425e 82E0      		ldi r24,lo8(2)
 11813 4260 90E0      		ldi r25,0
 11814               	.LVL1004:
 11815               	.L837:
 11816               	/* epilogue start */
 518:switcherator.c **** }
 11817               		.loc 1 518 0
 11818 4262 0F90      		pop __tmp_reg__
 11819 4264 DF91      		pop r29
 11820 4266 CF91      		pop r28
 11821 4268 1F91      		pop r17
 11822 426a 0F91      		pop r16
 11823               	.LVL1005:
 11824 426c FF90      		pop r15
 11825               	.LVL1006:
 11826 426e EF90      		pop r14
 11827               	.LVL1007:
 11828 4270 DF90      		pop r13
 11829 4272 CF90      		pop r12
 11830               	.LVL1008:
 11831 4274 BF90      		pop r11
 11832 4276 AF90      		pop r10
 494:switcherator.c ****         fail(2);
 11833               		.loc 1 494 0
 11834 4278 0C94 0000 		jmp fail
 11835               	.LVL1009:
 11836               	.L821:
 439:switcherator.c ****         realDDR = &DDRB;
 11837               		.loc 1 439 0
 11838 427c 64E2      		ldi r22,lo8(36)
 11839 427e A62E      		mov r10,r22
 11840 4280 B12C      		mov r11,__zero_reg__
 438:switcherator.c ****         realPort = &PORTB;
 11841               		.loc 1 438 0
 11842 4282 E5E2      		ldi r30,lo8(37)
 11843 4284 F0E0      		ldi r31,0
 440:switcherator.c ****         pinSubtractee = 16;
 11844               		.loc 1 440 0
 11845 4286 90E1      		ldi r25,lo8(16)
 11846 4288 00C0      		rjmp .L811
 11847               	.L823:
 450:switcherator.c ****         realDDR = &DDRC;
 11848               		.loc 1 450 0
 11849 428a 57E2      		ldi r21,lo8(39)
 11850 428c A52E      		mov r10,r21
 11851 428e B12C      		mov r11,__zero_reg__
 449:switcherator.c ****         realPort = &PORTC;
 11852               		.loc 1 449 0
 11853 4290 E8E2      		ldi r30,lo8(40)
 11854 4292 F0E0      		ldi r31,0
 451:switcherator.c ****         pinSubtractee = 32;
 11855               		.loc 1 451 0
 11856 4294 90E2      		ldi r25,lo8(32)
 11857 4296 00C0      		rjmp .L811
 11858               	.L825:
 456:switcherator.c ****         realDDR = &DDRD;
 11859               		.loc 1 456 0
 11860 4298 4AE2      		ldi r20,lo8(42)
 11861 429a A42E      		mov r10,r20
 11862 429c B12C      		mov r11,__zero_reg__
 455:switcherator.c ****         realPort = &PORTD;
 11863               		.loc 1 455 0
 11864 429e EBE2      		ldi r30,lo8(43)
 11865 42a0 F0E0      		ldi r31,0
 457:switcherator.c ****         pinSubtractee = 48;
 11866               		.loc 1 457 0
 11867 42a2 90E3      		ldi r25,lo8(48)
 11868               	.L811:
 11869               	.LVL1010:
 495:switcherator.c ****     } else if ((switchNumber >= NUM_SWITCHES) ||
 11870               		.loc 1 495 0
 11871 42a4 0031      		cpi r16,16
 11872 42a6 1105      		cpc r17,__zero_reg__
 11873 42a8 04F4      		brge .+2
 11874 42aa 00C0      		rjmp .L836
 11875 42ac 00C0      		rjmp .L818
 11876               	.LFE13:
 11878               		.section	.rodata.str1.1
 11879               	.LC70:
 11880 0158 5374 6172 		.string	"Start:"
 11880      743A 00
 11881               	.LC71:
 11882 015f 5374 6F70 		.string	"Stop:"
 11882      3A00 
 11883               		.text
 11884               	.global	setTimeLimits
 11886               	setTimeLimits:
 11887               	.LFB59:
2502:switcherator.c **** void setTimeLimits(char * commandReceived) {
 11888               		.loc 1 2502 0
 11889               	.LVL1011:
 11890 42ae 2F92      		push r2
 11891               	.LCFI312:
 11892 42b0 3F92      		push r3
 11893               	.LCFI313:
 11894 42b2 4F92      		push r4
 11895               	.LCFI314:
 11896 42b4 5F92      		push r5
 11897               	.LCFI315:
 11898 42b6 6F92      		push r6
 11899               	.LCFI316:
 11900 42b8 7F92      		push r7
 11901               	.LCFI317:
 11902 42ba 8F92      		push r8
 11903               	.LCFI318:
 11904 42bc 9F92      		push r9
 11905               	.LCFI319:
 11906 42be AF92      		push r10
 11907               	.LCFI320:
 11908 42c0 BF92      		push r11
 11909               	.LCFI321:
 11910 42c2 CF92      		push r12
 11911               	.LCFI322:
 11912 42c4 DF92      		push r13
 11913               	.LCFI323:
 11914 42c6 EF92      		push r14
 11915               	.LCFI324:
 11916 42c8 FF92      		push r15
 11917               	.LCFI325:
 11918 42ca 0F93      		push r16
 11919               	.LCFI326:
 11920 42cc 1F93      		push r17
 11921               	.LCFI327:
 11922 42ce CF93      		push r28
 11923               	.LCFI328:
 11924 42d0 DF93      		push r29
 11925               	.LCFI329:
 11926 42d2 CDB7      		in r28,__SP_L__
 11927 42d4 DEB7      		in r29,__SP_H__
 11928               	.LCFI330:
 11929 42d6 2C97      		sbiw r28,12
 11930               	.LCFI331:
 11931 42d8 0FB6      		in __tmp_reg__,__SREG__
 11932 42da F894      		cli
 11933 42dc DEBF      		out __SP_H__,r29
 11934 42de 0FBE      		out __SREG__,__tmp_reg__
 11935 42e0 CDBF      		out __SP_L__,r28
 11936               	/* prologue: function */
 11937               	/* frame size = 12 */
 11938               	/* stack size = 30 */
 11939               	.L__stack_usage = 30
 11940 42e2 6C01      		movw r12,r24
2503:switcherator.c ****     char tempReallyLongString[] = "0000000";
 11941               		.loc 1 2503 0
 11942 42e4 88E0      		ldi r24,lo8(8)
 11943               	.LVL1012:
 11944 42e6 E0E0      		ldi r30,lo8(.LC69)
 11945 42e8 F0E0      		ldi r31,hi8(.LC69)
 11946 42ea DE01      		movw r26,r28
 11947 42ec 1196      		adiw r26,1
 11948               		0:
 11949 42ee 0190      		ld r0,Z+
 11950 42f0 0D92      		st X+,r0
 11951 42f2 8A95      		dec r24
 11952 42f4 01F4      		brne 0b
 11953               	.LVL1013:
2509:switcherator.c ****     statusMsg[0] = 0;
 11954               		.loc 1 2509 0
 11955 42f6 1092 0000 		sts statusMsg,__zero_reg__
2511:switcherator.c ****     tempIntString[0] = commandReceived[3];
 11956               		.loc 1 2511 0
 11957 42fa F601      		movw r30,r12
 11958 42fc 8381      		ldd r24,Z+3
 11959 42fe 8093 0000 		sts tempIntString,r24
2512:switcherator.c ****     tempIntString[1] = commandReceived[4];
 11960               		.loc 1 2512 0
 11961 4302 8481      		ldd r24,Z+4
 11962 4304 8093 0000 		sts tempIntString+1,r24
2513:switcherator.c ****     programNumber = atoi(tempIntString);
 11963               		.loc 1 2513 0
 11964 4308 80E0      		ldi r24,lo8(tempIntString)
 11965 430a 90E0      		ldi r25,hi8(tempIntString)
 11966 430c 0E94 0000 		call atoi
 11967               	.LVL1014:
 11968 4310 8C01      		movw r16,r24
 11969               	.LVL1015:
2514:switcherator.c ****     if (programNumber > NUM_LIMITS) {
 11970               		.loc 1 2514 0
 11971 4312 8530      		cpi r24,5
 11972 4314 9105      		cpc r25,__zero_reg__
 11973 4316 04F0      		brlt .L839
2515:switcherator.c ****         fail(0x10);
 11974               		.loc 1 2515 0
 11975 4318 80E1      		ldi r24,lo8(16)
 11976 431a 90E0      		ldi r25,0
 11977 431c 00C0      		rjmp .L850
 11978               	.L839:
2518:switcherator.c ****     if (commandReceived[5] == 'x' || commandReceived[5] == 'x') {
 11979               		.loc 1 2518 0
 11980 431e F601      		movw r30,r12
 11981 4320 8581      		ldd r24,Z+5
 11982 4322 8837      		cpi r24,lo8(120)
 11983 4324 01F4      		brne .L841
2519:switcherator.c ****         timeLimits[programNumber][2] = 0;
 11984               		.loc 1 2519 0
 11985 4326 8CE0      		ldi r24,lo8(12)
 11986 4328 809F      		mul r24,r16
 11987 432a F001      		movw r30,r0
 11988 432c 819F      		mul r24,r17
 11989 432e F00D      		add r31,r0
 11990 4330 1124      		clr __zero_reg__
 11991 4332 E050      		subi r30,lo8(-(timeLimits))
 11992 4334 F040      		sbci r31,hi8(-(timeLimits))
 11993 4336 1086      		std Z+8,__zero_reg__
 11994 4338 1186      		std Z+9,__zero_reg__
 11995 433a 1286      		std Z+10,__zero_reg__
 11996 433c 1386      		std Z+11,__zero_reg__
 11997 433e 00C0      		rjmp .L851
 11998               	.L841:
2523:switcherator.c ****     if (commandReceived[5] == '?') {
 11999               		.loc 1 2523 0
 12000 4340 8F33      		cpi r24,lo8(63)
 12001 4342 01F0      		breq .+2
 12002 4344 00C0      		rjmp .L842
2525:switcherator.c ****         startTime = timeLimits[programNumber][0];
 12003               		.loc 1 2525 0
 12004 4346 8CE0      		ldi r24,lo8(12)
 12005 4348 809F      		mul r24,r16
 12006 434a F001      		movw r30,r0
 12007 434c 819F      		mul r24,r17
 12008 434e F00D      		add r31,r0
 12009 4350 1124      		clr __zero_reg__
 12010 4352 E050      		subi r30,lo8(-(timeLimits))
 12011 4354 F040      		sbci r31,hi8(-(timeLimits))
 12012 4356 8080      		ld r8,Z
 12013 4358 9180      		ldd r9,Z+1
 12014 435a A280      		ldd r10,Z+2
 12015 435c B380      		ldd r11,Z+3
 12016               	.LVL1016:
2527:switcherator.c ****         strcat(statusMsg, "Start:");
 12017               		.loc 1 2527 0
 12018 435e 60E0      		ldi r22,lo8(.LC70)
 12019 4360 70E0      		ldi r23,hi8(.LC70)
 12020 4362 80E0      		ldi r24,lo8(statusMsg)
 12021 4364 90E0      		ldi r25,hi8(statusMsg)
 12022 4366 0E94 0000 		call strcat
 12023               	.LVL1017:
2528:switcherator.c ****         startHour = (startTime / 60 / 60);
 12024               		.loc 1 2528 0
 12025 436a C501      		movw r24,r10
 12026 436c B401      		movw r22,r8
 12027 436e 20E1      		ldi r18,lo8(16)
 12028 4370 3EE0      		ldi r19,lo8(14)
 12029 4372 40E0      		ldi r20,0
 12030 4374 50E0      		ldi r21,0
 12031 4376 0E94 0000 		call __divmodsi4
 12032 437a 6901      		movw r12,r18
 12033 437c 7A01      		movw r14,r20
 12034               	.LVL1018:
2529:switcherator.c ****         returnInt(startHour, tempLongString);
 12035               		.loc 1 2529 0
 12036 437e 60E0      		ldi r22,lo8(tempLongString)
 12037 4380 70E0      		ldi r23,hi8(tempLongString)
 12038 4382 C901      		movw r24,r18
 12039 4384 0E94 0000 		call returnInt
 12040               	.LVL1019:
2530:switcherator.c ****         strcat(statusMsg, tempLongString);
 12041               		.loc 1 2530 0
 12042 4388 60E0      		ldi r22,lo8(tempLongString)
 12043 438a 70E0      		ldi r23,hi8(tempLongString)
 12044 438c 80E0      		ldi r24,lo8(statusMsg)
 12045 438e 90E0      		ldi r25,hi8(statusMsg)
 12046 4390 0E94 0000 		call strcat
 12047               	.LVL1020:
2532:switcherator.c ****         strcat(statusMsg, ":");
 12048               		.loc 1 2532 0
 12049 4394 60E0      		ldi r22,lo8(.LC4)
 12050 4396 70E0      		ldi r23,hi8(.LC4)
 12051 4398 80E0      		ldi r24,lo8(statusMsg)
 12052 439a 90E0      		ldi r25,hi8(statusMsg)
 12053 439c 0E94 0000 		call strcat
 12054               	.LVL1021:
2531:switcherator.c ****         startMinute = ((startTime - (startHour * 60 * 60)) / 60);
 12055               		.loc 1 2531 0
 12056 43a0 20E1      		ldi r18,lo8(16)
 12057 43a2 3EE0      		ldi r19,lo8(14)
 12058 43a4 C29E      		mul r12,r18
 12059 43a6 C001      		movw r24,r0
 12060 43a8 C39E      		mul r12,r19
 12061 43aa 900D      		add r25,r0
 12062 43ac D29E      		mul r13,r18
 12063 43ae 900D      		add r25,r0
 12064 43b0 1124      		clr r1
 12065 43b2 A501      		movw r20,r10
 12066 43b4 9401      		movw r18,r8
 12067 43b6 281B      		sub r18,r24
 12068 43b8 390B      		sbc r19,r25
 12069 43ba 4109      		sbc r20,__zero_reg__
 12070 43bc 5109      		sbc r21,__zero_reg__
 12071 43be CA01      		movw r24,r20
 12072 43c0 B901      		movw r22,r18
 12073 43c2 2CE3      		ldi r18,lo8(60)
 12074 43c4 30E0      		ldi r19,0
 12075 43c6 40E0      		ldi r20,0
 12076 43c8 50E0      		ldi r21,0
 12077 43ca 0E94 0000 		call __divmodsi4
2533:switcherator.c ****         returnInt(startMinute, tempLongString);
 12078               		.loc 1 2533 0
 12079 43ce 60E0      		ldi r22,lo8(tempLongString)
 12080 43d0 70E0      		ldi r23,hi8(tempLongString)
 12081 43d2 C901      		movw r24,r18
 12082 43d4 2987      		std Y+9,r18
 12083 43d6 3A87      		std Y+10,r19
 12084 43d8 4B87      		std Y+11,r20
 12085 43da 5C87      		std Y+12,r21
 12086 43dc 0E94 0000 		call returnInt
 12087               	.LVL1022:
2534:switcherator.c ****         strcat(statusMsg, tempLongString);
 12088               		.loc 1 2534 0
 12089 43e0 60E0      		ldi r22,lo8(tempLongString)
 12090 43e2 70E0      		ldi r23,hi8(tempLongString)
 12091 43e4 80E0      		ldi r24,lo8(statusMsg)
 12092 43e6 90E0      		ldi r25,hi8(statusMsg)
 12093 43e8 0E94 0000 		call strcat
 12094               	.LVL1023:
2535:switcherator.c ****         strcat(statusMsg, "Stop:");
 12095               		.loc 1 2535 0
 12096 43ec 60E0      		ldi r22,lo8(.LC71)
 12097 43ee 70E0      		ldi r23,hi8(.LC71)
 12098 43f0 80E0      		ldi r24,lo8(statusMsg)
 12099 43f2 90E0      		ldi r25,hi8(statusMsg)
 12100 43f4 0E94 0000 		call strcat
 12101               	.LVL1024:
2537:switcherator.c ****         returnInt(stopHour, tempLongString);
 12102               		.loc 1 2537 0
 12103 43f8 60E0      		ldi r22,lo8(tempLongString)
 12104 43fa 70E0      		ldi r23,hi8(tempLongString)
 12105 43fc C601      		movw r24,r12
 12106 43fe 0E94 0000 		call returnInt
 12107               	.LVL1025:
2538:switcherator.c ****         strcat(statusMsg, tempLongString);
 12108               		.loc 1 2538 0
 12109 4402 60E0      		ldi r22,lo8(tempLongString)
 12110 4404 70E0      		ldi r23,hi8(tempLongString)
 12111 4406 80E0      		ldi r24,lo8(statusMsg)
 12112 4408 90E0      		ldi r25,hi8(statusMsg)
 12113 440a 0E94 0000 		call strcat
 12114               	.LVL1026:
2540:switcherator.c ****         strcat(statusMsg, ":");
 12115               		.loc 1 2540 0
 12116 440e 60E0      		ldi r22,lo8(.LC4)
 12117 4410 70E0      		ldi r23,hi8(.LC4)
 12118 4412 80E0      		ldi r24,lo8(statusMsg)
 12119 4414 90E0      		ldi r25,hi8(statusMsg)
 12120 4416 0E94 0000 		call strcat
 12121               	.LVL1027:
2541:switcherator.c ****         returnInt(stopMinute, tempLongString);
 12122               		.loc 1 2541 0
 12123 441a 60E0      		ldi r22,lo8(tempLongString)
 12124 441c 70E0      		ldi r23,hi8(tempLongString)
 12125 441e 2985      		ldd r18,Y+9
 12126 4420 3A85      		ldd r19,Y+10
 12127 4422 C901      		movw r24,r18
 12128 4424 0E94 0000 		call returnInt
 12129               	.LVL1028:
2542:switcherator.c ****         strcat(statusMsg, tempLongString);
 12130               		.loc 1 2542 0
 12131 4428 60E0      		ldi r22,lo8(tempLongString)
 12132 442a 70E0      		ldi r23,hi8(tempLongString)
 12133 442c 80E0      		ldi r24,lo8(statusMsg)
 12134 442e 90E0      		ldi r25,hi8(statusMsg)
 12135 4430 0E94 0000 		call strcat
 12136               	.LVL1029:
2543:switcherator.c ****         sendMessage(statusMsg);
 12137               		.loc 1 2543 0
 12138 4434 80E0      		ldi r24,lo8(statusMsg)
 12139 4436 90E0      		ldi r25,hi8(statusMsg)
 12140 4438 0E94 0000 		call sendMessage
 12141               	.LVL1030:
 12142 443c 00C0      		rjmp .L838
 12143               	.LVL1031:
 12144               	.L842:
2502:switcherator.c **** void setTimeLimits(char * commandReceived) {
 12145               		.loc 1 2502 0
 12146 443e D601      		movw r26,r12
 12147 4440 1D96      		adiw r26,13
 12148 4442 FE01      		movw r30,r28
 12149 4444 3196      		adiw r30,1
 12150 4446 CE01      		movw r24,r28
 12151 4448 0896      		adiw r24,8
 12152               	.LVL1032:
 12153               	.L843:
2547:switcherator.c ****         tempReallyLongString[x] = commandReceived[x + 13];
 12154               		.loc 1 2547 0 discriminator 2
 12155 444a 2D91      		ld r18,X+
 12156 444c 2193      		st Z+,r18
2546:switcherator.c ****     for (x = 0; x < 7; x++) {
 12157               		.loc 1 2546 0 discriminator 2
 12158 444e E817      		cp r30,r24
 12159 4450 F907      		cpc r31,r25
 12160 4452 01F4      		brne .L843
2549:switcherator.c ****     weekLong = strtol(tempReallyLongString, 0, 2);
 12161               		.loc 1 2549 0
 12162 4454 42E0      		ldi r20,lo8(2)
 12163 4456 50E0      		ldi r21,0
 12164 4458 60E0      		ldi r22,0
 12165 445a 70E0      		ldi r23,0
 12166 445c CE01      		movw r24,r28
 12167 445e 0196      		adiw r24,1
 12168 4460 0E94 0000 		call strtol
 12169               	.LVL1033:
 12170 4464 2B01      		movw r4,r22
 12171 4466 3C01      		movw r6,r24
 12172               	.LVL1034:
2550:switcherator.c ****     tempIntString[0] = commandReceived[5];
 12173               		.loc 1 2550 0
 12174 4468 F601      		movw r30,r12
 12175 446a 8581      		ldd r24,Z+5
 12176 446c 8093 0000 		sts tempIntString,r24
2551:switcherator.c ****     tempIntString[1] = commandReceived[6];
 12177               		.loc 1 2551 0
 12178 4470 8681      		ldd r24,Z+6
 12179 4472 8093 0000 		sts tempIntString+1,r24
2552:switcherator.c ****     startHour = atoi(tempIntString);
 12180               		.loc 1 2552 0
 12181 4476 80E0      		ldi r24,lo8(tempIntString)
 12182 4478 90E0      		ldi r25,hi8(tempIntString)
 12183 447a 0E94 0000 		call atoi
 12184               	.LVL1035:
 12185 447e 7C01      		movw r14,r24
 12186               	.LVL1036:
2553:switcherator.c ****     tempIntString[0] = commandReceived[7];
 12187               		.loc 1 2553 0
 12188 4480 F601      		movw r30,r12
 12189 4482 8781      		ldd r24,Z+7
 12190 4484 8093 0000 		sts tempIntString,r24
2554:switcherator.c ****     tempIntString[1] = commandReceived[8];
 12191               		.loc 1 2554 0
 12192 4488 8085      		ldd r24,Z+8
 12193 448a 8093 0000 		sts tempIntString+1,r24
2555:switcherator.c ****     startMinute = atoi(tempIntString);
 12194               		.loc 1 2555 0
 12195 448e 80E0      		ldi r24,lo8(tempIntString)
 12196 4490 90E0      		ldi r25,hi8(tempIntString)
 12197 4492 0E94 0000 		call atoi
 12198               	.LVL1037:
 12199 4496 4C01      		movw r8,r24
 12200               	.LVL1038:
2556:switcherator.c ****     tempIntString[0] = commandReceived[9];
 12201               		.loc 1 2556 0
 12202 4498 F601      		movw r30,r12
 12203 449a 8185      		ldd r24,Z+9
 12204 449c 8093 0000 		sts tempIntString,r24
2557:switcherator.c ****     tempIntString[1] = commandReceived[10];
 12205               		.loc 1 2557 0
 12206 44a0 8285      		ldd r24,Z+10
 12207 44a2 8093 0000 		sts tempIntString+1,r24
2558:switcherator.c ****     stopHour = atoi(tempIntString);
 12208               		.loc 1 2558 0
 12209 44a6 80E0      		ldi r24,lo8(tempIntString)
 12210 44a8 90E0      		ldi r25,hi8(tempIntString)
 12211 44aa 0E94 0000 		call atoi
 12212               	.LVL1039:
 12213 44ae 1C01      		movw r2,r24
 12214               	.LVL1040:
2559:switcherator.c ****     tempIntString[0] = commandReceived[11];
 12215               		.loc 1 2559 0
 12216 44b0 F601      		movw r30,r12
 12217 44b2 8385      		ldd r24,Z+11
 12218 44b4 8093 0000 		sts tempIntString,r24
2560:switcherator.c ****     tempIntString[1] = commandReceived[12];
 12219               		.loc 1 2560 0
 12220 44b8 8485      		ldd r24,Z+12
 12221 44ba 8093 0000 		sts tempIntString+1,r24
2561:switcherator.c ****     stopMinute = atoi(tempIntString);
 12222               		.loc 1 2561 0
 12223 44be 80E0      		ldi r24,lo8(tempIntString)
 12224 44c0 90E0      		ldi r25,hi8(tempIntString)
 12225 44c2 0E94 0000 		call atoi
 12226               	.LVL1041:
2562:switcherator.c ****     if (startHour > 23 || stopHour > 23) {
 12227               		.loc 1 2562 0
 12228 44c6 F8E1      		ldi r31,24
 12229 44c8 EF16      		cp r14,r31
 12230 44ca F104      		cpc r15,__zero_reg__
 12231 44cc 00F4      		brsh .L844
2562:switcherator.c ****     if (startHour > 23 || stopHour > 23) {
 12232               		.loc 1 2562 0 is_stmt 0 discriminator 1
 12233 44ce 28E1      		ldi r18,24
 12234 44d0 2216      		cp r2,r18
 12235 44d2 3104      		cpc r3,__zero_reg__
 12236 44d4 00F0      		brlo .L845
 12237               	.L844:
2563:switcherator.c ****         fail(0x09);
 12238               		.loc 1 2563 0 is_stmt 1
 12239 44d6 89E0      		ldi r24,lo8(9)
 12240 44d8 90E0      		ldi r25,0
 12241               	.LVL1042:
 12242 44da 00C0      		rjmp .L850
 12243               	.LVL1043:
 12244               	.L845:
2555:switcherator.c ****     startMinute = atoi(tempIntString);
 12245               		.loc 1 2555 0
 12246 44dc F401      		movw r30,r8
2566:switcherator.c ****     if (startMinute > 59 || stopMinute > 59) {
 12247               		.loc 1 2566 0
 12248 44de EC33      		cpi r30,60
 12249 44e0 F105      		cpc r31,__zero_reg__
 12250 44e2 00F4      		brsh .L846
2561:switcherator.c ****     stopMinute = atoi(tempIntString);
 12251               		.loc 1 2561 0 discriminator 1
 12252 44e4 AC01      		movw r20,r24
2566:switcherator.c ****     if (startMinute > 59 || stopMinute > 59) {
 12253               		.loc 1 2566 0 discriminator 1
 12254 44e6 8C33      		cpi r24,60
 12255 44e8 9105      		cpc r25,__zero_reg__
 12256 44ea 00F0      		brlo .L847
 12257               	.L846:
2567:switcherator.c ****         fail(0x0A);
 12258               		.loc 1 2567 0
 12259 44ec 8AE0      		ldi r24,lo8(10)
 12260 44ee 90E0      		ldi r25,0
 12261               	.LVL1044:
 12262               	.L850:
 12263 44f0 0E94 0000 		call fail
 12264               	.LVL1045:
 12265 44f4 00C0      		rjmp .L838
 12266               	.LVL1046:
 12267               	.L847:
2571:switcherator.c ****     startTime = startTime * 60 * 60;
 12268               		.loc 1 2571 0
 12269 44f6 9701      		movw r18,r14
 12270 44f8 A0E1      		ldi r26,lo8(16)
 12271 44fa BEE0      		ldi r27,lo8(14)
 12272 44fc 0E94 0000 		call __umulhisi3
 12273 4500 6B01      		movw r12,r22
 12274 4502 7C01      		movw r14,r24
 12275               	.LVL1047:
2574:switcherator.c ****     stopTime = stopTime * 60 * 60;
 12276               		.loc 1 2574 0
 12277 4504 9101      		movw r18,r2
 12278 4506 0E94 0000 		call __umulhisi3
 12279               	.LVL1048:
2576:switcherator.c ****     timeLimits[programNumber][0] = startTime;
 12280               		.loc 1 2576 0
 12281 450a 2CE0      		ldi r18,lo8(12)
 12282 450c 209F      		mul r18,r16
 12283 450e D001      		movw r26,r0
 12284 4510 219F      		mul r18,r17
 12285 4512 B00D      		add r27,r0
 12286 4514 1124      		clr __zero_reg__
 12287 4516 A050      		subi r26,lo8(-(timeLimits))
 12288 4518 B040      		sbci r27,hi8(-(timeLimits))
2572:switcherator.c ****     startTime += (startMinute * 60);
 12289               		.loc 1 2572 0
 12290 451a 2CE3      		ldi r18,lo8(60)
 12291 451c 289D      		mul r18,r8
 12292 451e 8001      		movw r16,r0
 12293 4520 299D      		mul r18,r9
 12294 4522 100D      		add r17,r0
 12295 4524 1124      		clr __zero_reg__
 12296               	.LVL1049:
 12297 4526 C00E      		add r12,r16
 12298 4528 D11E      		adc r13,r17
 12299 452a E11C      		adc r14,__zero_reg__
 12300 452c F11C      		adc r15,__zero_reg__
 12301               	.LVL1050:
2576:switcherator.c ****     timeLimits[programNumber][0] = startTime;
 12302               		.loc 1 2576 0
 12303 452e CD92      		st X+,r12
 12304 4530 DD92      		st X+,r13
 12305 4532 ED92      		st X+,r14
 12306 4534 FC92      		st X,r15
 12307 4536 1397      		sbiw r26,3
2575:switcherator.c ****     stopTime += (stopMinute * 60);
 12308               		.loc 1 2575 0
 12309 4538 249F      		mul r18,r20
 12310 453a F001      		movw r30,r0
 12311 453c 259F      		mul r18,r21
 12312 453e F00D      		add r31,r0
 12313 4540 1124      		clr __zero_reg__
 12314 4542 6E0F      		add r22,r30
 12315 4544 7F1F      		adc r23,r31
 12316 4546 811D      		adc r24,__zero_reg__
 12317 4548 911D      		adc r25,__zero_reg__
 12318               	.LVL1051:
2577:switcherator.c ****     timeLimits[programNumber][1] = stopTime;
 12319               		.loc 1 2577 0
 12320 454a 1496      		adiw r26,4
 12321 454c 6D93      		st X+,r22
 12322 454e 7D93      		st X+,r23
 12323 4550 8D93      		st X+,r24
 12324 4552 9C93      		st X,r25
 12325 4554 1797      		sbiw r26,4+3
2578:switcherator.c ****     timeLimits[programNumber][2] = weekLong;
 12326               		.loc 1 2578 0
 12327 4556 1896      		adiw r26,8
 12328 4558 4D92      		st X+,r4
 12329 455a 5D92      		st X+,r5
 12330 455c 6D92      		st X+,r6
 12331 455e 7C92      		st X,r7
 12332 4560 1B97      		sbiw r26,8+3
 12333               	.LVL1052:
 12334               	.L851:
2579:switcherator.c ****     ok();
 12335               		.loc 1 2579 0
 12336 4562 0E94 0000 		call ok
 12337               	.LVL1053:
 12338               	.L838:
 12339               	/* epilogue start */
2581:switcherator.c **** }
 12340               		.loc 1 2581 0
 12341 4566 2C96      		adiw r28,12
 12342 4568 0FB6      		in __tmp_reg__,__SREG__
 12343 456a F894      		cli
 12344 456c DEBF      		out __SP_H__,r29
 12345 456e 0FBE      		out __SREG__,__tmp_reg__
 12346 4570 CDBF      		out __SP_L__,r28
 12347 4572 DF91      		pop r29
 12348 4574 CF91      		pop r28
 12349 4576 1F91      		pop r17
 12350 4578 0F91      		pop r16
 12351 457a FF90      		pop r15
 12352 457c EF90      		pop r14
 12353 457e DF90      		pop r13
 12354 4580 CF90      		pop r12
 12355 4582 BF90      		pop r11
 12356 4584 AF90      		pop r10
 12357 4586 9F90      		pop r9
 12358 4588 8F90      		pop r8
 12359 458a 7F90      		pop r7
 12360 458c 6F90      		pop r6
 12361 458e 5F90      		pop r5
 12362 4590 4F90      		pop r4
 12363 4592 3F90      		pop r3
 12364 4594 2F90      		pop r2
 12365 4596 0895      		ret
 12366               	.LFE59:
 12368               		.section	.rodata.str1.1
 12369               	.LC72:
 12370 0165 4E65 7720 		.string	"New prog#"
 12370      7072 6F67 
 12370      2300 
 12371               		.text
 12372               	.global	newProgram
 12374               	newProgram:
 12375               	.LFB30:
1177:switcherator.c **** void newProgram(char * commandReceived) {
 12376               		.loc 1 1177 0
 12377               	.LVL1054:
 12378 4598 AF92      		push r10
 12379               	.LCFI332:
 12380 459a BF92      		push r11
 12381               	.LCFI333:
 12382 459c CF92      		push r12
 12383               	.LCFI334:
 12384 459e DF92      		push r13
 12385               	.LCFI335:
 12386 45a0 EF92      		push r14
 12387               	.LCFI336:
 12388 45a2 FF92      		push r15
 12389               	.LCFI337:
 12390 45a4 0F93      		push r16
 12391               	.LCFI338:
 12392 45a6 1F93      		push r17
 12393               	.LCFI339:
 12394 45a8 CF93      		push r28
 12395               	.LCFI340:
 12396 45aa DF93      		push r29
 12397               	.LCFI341:
 12398               	/* prologue: function */
 12399               	/* frame size = 0 */
 12400               	/* stack size = 10 */
 12401               	.L__stack_usage = 10
 12402 45ac EC01      		movw r28,r24
 12403               	.LVL1055:
 12404 45ae E0E0      		ldi r30,lo8(weeklyProgram+1)
 12405 45b0 F0E0      		ldi r31,hi8(weeklyProgram+1)
1185:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 12406               		.loc 1 1185 0
 12407 45b2 00E0      		ldi r16,0
 12408 45b4 10E0      		ldi r17,0
 12409               	.LVL1056:
 12410               	.L855:
1177:switcherator.c **** void newProgram(char * commandReceived) {
 12411               		.loc 1 1177 0
 12412 45b6 DF01      		movw r26,r30
 12413 45b8 1197      		sbiw r26,1
1187:switcherator.c ****         if (weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) {
 12414               		.loc 1 1187 0
 12415 45ba 8C91      		ld r24,X
 12416 45bc 8F3F      		cpi r24,lo8(-1)
 12417 45be 01F4      		brne .L853
1187:switcherator.c ****         if (weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) {
 12418               		.loc 1 1187 0 is_stmt 0 discriminator 1
 12419 45c0 8081      		ld r24,Z
 12420 45c2 8F3F      		cpi r24,lo8(-1)
 12421 45c4 01F4      		brne .+2
 12422 45c6 00C0      		rjmp .L854
 12423               	.L853:
1185:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 12424               		.loc 1 1185 0 is_stmt 1
 12425 45c8 0F5F      		subi r16,-1
 12426 45ca 1F4F      		sbci r17,-1
 12427               	.LVL1057:
 12428 45cc 3A96      		adiw r30,10
 12429 45ce 0A30      		cpi r16,10
 12430 45d0 1105      		cpc r17,__zero_reg__
 12431 45d2 01F4      		brne .L855
 12432 45d4 00C0      		rjmp .L870
 12433               	.LVL1058:
 12434               	.L871:
1210:switcherator.c ****     if (hours >= 24 || (hours == 0 && commandReceived[4] != '0')) {
 12435               		.loc 1 1210 0 discriminator 1
 12436 45d6 E114      		cp r14,__zero_reg__
 12437 45d8 F104      		cpc r15,__zero_reg__
 12438 45da 01F4      		brne .L857
 12439 45dc 20E3      		ldi r18,lo8(48)
 12440 45de A216      		cp r10,r18
 12441 45e0 01F0      		breq .L857
 12442               	.L861:
1211:switcherator.c ****         fail(9);
 12443               		.loc 1 1211 0
 12444 45e2 89E0      		ldi r24,lo8(9)
 12445 45e4 90E0      		ldi r25,0
 12446               	.LVL1059:
 12447 45e6 00C0      		rjmp .L872
 12448               	.LVL1060:
 12449               	.L857:
1214:switcherator.c ****     if (minutes >= 60 || (minutes == 0 && commandReceived[6] != '0')) {
 12450               		.loc 1 1214 0
 12451 45e8 2CE3      		ldi r18,60
 12452 45ea C216      		cp r12,r18
 12453 45ec D104      		cpc r13,__zero_reg__
 12454 45ee 04F4      		brge .L858
1214:switcherator.c ****     if (minutes >= 60 || (minutes == 0 && commandReceived[6] != '0')) {
 12455               		.loc 1 1214 0 is_stmt 0 discriminator 1
 12456 45f0 C114      		cp r12,__zero_reg__
 12457 45f2 D104      		cpc r13,__zero_reg__
 12458 45f4 01F4      		brne .L859
 12459 45f6 20E3      		ldi r18,lo8(48)
 12460 45f8 B216      		cp r11,r18
 12461 45fa 01F0      		breq .L859
 12462               	.L858:
1215:switcherator.c ****         fail(0x0a);
 12463               		.loc 1 1215 0 is_stmt 1
 12464 45fc 8AE0      		ldi r24,lo8(10)
 12465 45fe 90E0      		ldi r25,0
 12466               	.LVL1061:
 12467 4600 00C0      		rjmp .L872
 12468               	.LVL1062:
 12469               	.L859:
1218:switcherator.c ****     if (duration == 0) {
 12470               		.loc 1 1218 0
 12471 4602 0097      		sbiw r24,0
 12472 4604 01F4      		brne .L860
1219:switcherator.c ****         fail(0x0b);
 12473               		.loc 1 1219 0
 12474 4606 8BE0      		ldi r24,lo8(11)
 12475 4608 90E0      		ldi r25,0
 12476               	.LVL1063:
 12477 460a 00C0      		rjmp .L872
 12478               	.LVL1064:
 12479               	.L860:
1222:switcherator.c ****     duration *= 60; // convert to seconds
 12480               		.loc 1 1222 0
 12481 460c 6CE3      		ldi r22,lo8(60)
 12482 460e 689F      		mul r22,r24
 12483 4610 A001      		movw r20,r0
 12484 4612 699F      		mul r22,r25
 12485 4614 500D      		add r21,r0
 12486 4616 1124      		clr __zero_reg__
 12487               	.LVL1065:
1223:switcherator.c ****     startTime = (hours * 60);
 12488               		.loc 1 1223 0
 12489 4618 6E9D      		mul r22,r14
 12490 461a 9001      		movw r18,r0
 12491 461c 6F9D      		mul r22,r15
 12492 461e 300D      		add r19,r0
 12493 4620 1124      		clr __zero_reg__
 12494               	.LVL1066:
1224:switcherator.c ****     startTime += minutes; // stored in minutes
 12495               		.loc 1 1224 0
 12496 4622 2C0D      		add r18,r12
 12497 4624 3D1D      		adc r19,r13
 12498               	.LVL1067:
1227:switcherator.c ****     weeklyProgram[programNumber][1] = temp;
 12499               		.loc 1 1227 0
 12500 4626 8AE0      		ldi r24,lo8(10)
 12501 4628 809F      		mul r24,r16
 12502 462a F001      		movw r30,r0
 12503 462c 819F      		mul r24,r17
 12504 462e F00D      		add r31,r0
 12505 4630 1124      		clr __zero_reg__
 12506 4632 E050      		subi r30,lo8(-(weeklyProgram))
 12507 4634 F040      		sbci r31,hi8(-(weeklyProgram))
 12508 4636 3183      		std Z+1,r19
 12509               	.LVL1068:
1229:switcherator.c ****     weeklyProgram[programNumber][2] = temp;
 12510               		.loc 1 1229 0
 12511 4638 2283      		std Z+2,r18
 12512               	.LVL1069:
1231:switcherator.c ****     weeklyProgram[programNumber][3] = temp;
 12513               		.loc 1 1231 0
 12514 463a 5383      		std Z+3,r21
 12515               	.LVL1070:
1232:switcherator.c ****     temp = (duration & 0xff);
 12516               		.loc 1 1232 0
 12517 463c 5527      		clr r21
 12518               	.LVL1071:
1233:switcherator.c ****     weeklyProgram[programNumber][4] = temp;
 12519               		.loc 1 1233 0
 12520 463e 4483      		std Z+4,r20
1234:switcherator.c ****     statusMsg[0] = 0;
 12521               		.loc 1 1234 0
 12522 4640 1092 0000 		sts statusMsg,__zero_reg__
1235:switcherator.c ****     strcat(statusMsg, "New prog#");
 12523               		.loc 1 1235 0
 12524 4644 60E0      		ldi r22,lo8(.LC72)
 12525 4646 70E0      		ldi r23,hi8(.LC72)
 12526 4648 80E0      		ldi r24,lo8(statusMsg)
 12527 464a 90E0      		ldi r25,hi8(statusMsg)
 12528 464c 0E94 0000 		call strcat
 12529               	.LVL1072:
1236:switcherator.c ****     returnInt(programNumber, tempIntString);
 12530               		.loc 1 1236 0
 12531 4650 60E0      		ldi r22,lo8(tempIntString)
 12532 4652 70E0      		ldi r23,hi8(tempIntString)
 12533 4654 C801      		movw r24,r16
 12534 4656 0E94 0000 		call returnInt
 12535               	.LVL1073:
1237:switcherator.c ****     strcat(statusMsg, tempIntString);
 12536               		.loc 1 1237 0
 12537 465a 60E0      		ldi r22,lo8(tempIntString)
 12538 465c 70E0      		ldi r23,hi8(tempIntString)
 12539 465e 80E0      		ldi r24,lo8(statusMsg)
 12540 4660 90E0      		ldi r25,hi8(statusMsg)
 12541 4662 0E94 0000 		call strcat
 12542               	.LVL1074:
1238:switcherator.c ****     sendMessage(statusMsg);
 12543               		.loc 1 1238 0
 12544 4666 80E0      		ldi r24,lo8(statusMsg)
 12545 4668 90E0      		ldi r25,hi8(statusMsg)
 12546               	/* epilogue start */
1239:switcherator.c **** }
 12547               		.loc 1 1239 0
 12548 466a DF91      		pop r29
 12549 466c CF91      		pop r28
 12550               	.LVL1075:
 12551 466e 1F91      		pop r17
 12552 4670 0F91      		pop r16
 12553               	.LVL1076:
 12554 4672 FF90      		pop r15
 12555 4674 EF90      		pop r14
 12556               	.LVL1077:
 12557 4676 DF90      		pop r13
 12558 4678 CF90      		pop r12
 12559               	.LVL1078:
 12560 467a BF90      		pop r11
 12561 467c AF90      		pop r10
1238:switcherator.c ****     sendMessage(statusMsg);
 12562               		.loc 1 1238 0
 12563 467e 0C94 0000 		jmp sendMessage
 12564               	.LVL1079:
 12565               	.L870:
1195:switcherator.c ****         fail(8);
 12566               		.loc 1 1195 0
 12567 4682 88E0      		ldi r24,lo8(8)
 12568 4684 90E0      		ldi r25,0
 12569               	.LVL1080:
 12570               	.L872:
 12571               	/* epilogue start */
1239:switcherator.c **** }
 12572               		.loc 1 1239 0
 12573 4686 DF91      		pop r29
 12574 4688 CF91      		pop r28
 12575               	.LVL1081:
 12576 468a 1F91      		pop r17
 12577 468c 0F91      		pop r16
 12578 468e FF90      		pop r15
 12579 4690 EF90      		pop r14
 12580 4692 DF90      		pop r13
 12581 4694 CF90      		pop r12
 12582 4696 BF90      		pop r11
 12583 4698 AF90      		pop r10
1195:switcherator.c ****         fail(8);
 12584               		.loc 1 1195 0
 12585 469a 0C94 0000 		jmp fail
 12586               	.LVL1082:
 12587               	.L854:
1198:switcherator.c ****     clearTheProgram(programNumber);
 12588               		.loc 1 1198 0
 12589 469e C801      		movw r24,r16
 12590 46a0 0E94 0000 		call clearTheProgram
 12591               	.LVL1083:
1199:switcherator.c ****     tempIntString[0] = commandReceived[3];
 12592               		.loc 1 1199 0
 12593 46a4 8B81      		ldd r24,Y+3
 12594 46a6 8093 0000 		sts tempIntString,r24
1200:switcherator.c ****     tempIntString[1] = commandReceived[4];
 12595               		.loc 1 1200 0
 12596 46aa AC80      		ldd r10,Y+4
 12597 46ac A092 0000 		sts tempIntString+1,r10
1201:switcherator.c ****     hours = atoi(tempIntString);
 12598               		.loc 1 1201 0
 12599 46b0 80E0      		ldi r24,lo8(tempIntString)
 12600 46b2 90E0      		ldi r25,hi8(tempIntString)
 12601 46b4 0E94 0000 		call atoi
 12602               	.LVL1084:
 12603 46b8 7C01      		movw r14,r24
 12604               	.LVL1085:
1202:switcherator.c ****     tempIntString[0] = commandReceived[5];
 12605               		.loc 1 1202 0
 12606 46ba 8D81      		ldd r24,Y+5
 12607 46bc 8093 0000 		sts tempIntString,r24
1203:switcherator.c ****     tempIntString[1] = commandReceived[6];
 12608               		.loc 1 1203 0
 12609 46c0 BE80      		ldd r11,Y+6
 12610 46c2 B092 0000 		sts tempIntString+1,r11
1204:switcherator.c ****     minutes = atoi(tempIntString);
 12611               		.loc 1 1204 0
 12612 46c6 80E0      		ldi r24,lo8(tempIntString)
 12613 46c8 90E0      		ldi r25,hi8(tempIntString)
 12614 46ca 0E94 0000 		call atoi
 12615               	.LVL1086:
 12616 46ce 6C01      		movw r12,r24
 12617               	.LVL1087:
1205:switcherator.c ****     tempLongString[0] = commandReceived[7];
 12618               		.loc 1 1205 0
 12619 46d0 8F81      		ldd r24,Y+7
 12620 46d2 8093 0000 		sts tempLongString,r24
1206:switcherator.c ****     tempLongString[1] = commandReceived[8];
 12621               		.loc 1 1206 0
 12622 46d6 8885      		ldd r24,Y+8
 12623 46d8 8093 0000 		sts tempLongString+1,r24
1207:switcherator.c ****     tempLongString[2] = commandReceived[9];
 12624               		.loc 1 1207 0
 12625 46dc 8985      		ldd r24,Y+9
 12626 46de 8093 0000 		sts tempLongString+2,r24
1208:switcherator.c ****     tempLongString[3] = commandReceived[10];
 12627               		.loc 1 1208 0
 12628 46e2 8A85      		ldd r24,Y+10
 12629 46e4 8093 0000 		sts tempLongString+3,r24
1209:switcherator.c ****     duration = atoi(tempLongString);
 12630               		.loc 1 1209 0
 12631 46e8 80E0      		ldi r24,lo8(tempLongString)
 12632 46ea 90E0      		ldi r25,hi8(tempLongString)
 12633 46ec 0E94 0000 		call atoi
 12634               	.LVL1088:
1210:switcherator.c ****     if (hours >= 24 || (hours == 0 && commandReceived[4] != '0')) {
 12635               		.loc 1 1210 0
 12636 46f0 28E1      		ldi r18,24
 12637 46f2 E216      		cp r14,r18
 12638 46f4 F104      		cpc r15,__zero_reg__
 12639 46f6 04F4      		brge .+2
 12640 46f8 00C0      		rjmp .L871
 12641 46fa 00C0      		rjmp .L861
 12642               	.LFE30:
 12644               	.global	switchBrightness
 12646               	switchBrightness:
 12647               	.LFB19:
 792:switcherator.c **** void switchBrightness(char * commandReceived) {
 12648               		.loc 1 792 0
 12649               	.LVL1089:
 12650 46fc FF92      		push r15
 12651               	.LCFI342:
 12652 46fe 0F93      		push r16
 12653               	.LCFI343:
 12654 4700 1F93      		push r17
 12655               	.LCFI344:
 12656 4702 CF93      		push r28
 12657               	.LCFI345:
 12658 4704 DF93      		push r29
 12659               	.LCFI346:
 12660               	/* prologue: function */
 12661               	/* frame size = 0 */
 12662               	/* stack size = 5 */
 12663               	.L__stack_usage = 5
 12664 4706 8C01      		movw r16,r24
 793:switcherator.c ****     int switchNumber = getSwitchNumber(commandReceived);
 12665               		.loc 1 793 0
 12666 4708 0E94 0000 		call getSwitchNumber
 12667               	.LVL1090:
 12668 470c EC01      		movw r28,r24
 12669               	.LVL1091:
 795:switcherator.c ****     if (switchNumber >= NUM_SWITCHES) {
 12670               		.loc 1 795 0
 12671 470e 8031      		cpi r24,16
 12672 4710 9105      		cpc r25,__zero_reg__
 12673 4712 04F0      		brlt .L874
 796:switcherator.c ****         fail(1);
 12674               		.loc 1 796 0
 12675 4714 81E0      		ldi r24,lo8(1)
 12676 4716 90E0      		ldi r25,0
 12677               	.LVL1092:
 12678               	/* epilogue start */
 818:switcherator.c **** }
 12679               		.loc 1 818 0
 12680 4718 DF91      		pop r29
 12681 471a CF91      		pop r28
 12682               	.LVL1093:
 12683 471c 1F91      		pop r17
 12684 471e 0F91      		pop r16
 12685               	.LVL1094:
 12686 4720 FF90      		pop r15
 796:switcherator.c ****         fail(1);
 12687               		.loc 1 796 0
 12688 4722 0C94 0000 		jmp fail
 12689               	.LVL1095:
 12690               	.L874:
 799:switcherator.c ****     tempIntString[0] = commandReceived[5];
 12691               		.loc 1 799 0
 12692 4726 F801      		movw r30,r16
 12693 4728 8581      		ldd r24,Z+5
 12694               	.LVL1096:
 12695 472a 8093 0000 		sts tempIntString,r24
 800:switcherator.c ****     tempIntString[1] = commandReceived[6];
 12696               		.loc 1 800 0
 12697 472e 8681      		ldd r24,Z+6
 12698 4730 8093 0000 		sts tempIntString+1,r24
 801:switcherator.c ****     char brightValue = atoi(tempIntString);
 12699               		.loc 1 801 0
 12700 4734 80E0      		ldi r24,lo8(tempIntString)
 12701 4736 90E0      		ldi r25,hi8(tempIntString)
 12702 4738 0E94 0000 		call atoi
 12703               	.LVL1097:
 12704 473c F82E      		mov r15,r24
 12705               	.LVL1098:
 12706 473e 8E01      		movw r16,r28
 12707               	.LVL1099:
 12708 4740 0050      		subi r16,lo8(-(switchBright))
 12709 4742 1040      		sbci r17,hi8(-(switchBright))
 802:switcherator.c ****     if (brightValue == 0) {
 12710               		.loc 1 802 0
 12711 4744 8111      		cpse r24,__zero_reg__
 12712 4746 00C0      		rjmp .L875
 12713               	.LVL1100:
 804:switcherator.c ****         itoa(tempBright, tempIntString, 10);
 12714               		.loc 1 804 0
 12715 4748 4AE0      		ldi r20,lo8(10)
 12716 474a 50E0      		ldi r21,0
 12717 474c 60E0      		ldi r22,lo8(tempIntString)
 12718 474e 70E0      		ldi r23,hi8(tempIntString)
 12719 4750 F801      		movw r30,r16
 12720 4752 8081      		ld r24,Z
 12721 4754 90E0      		ldi r25,0
 12722 4756 0E94 0000 		call itoa
 12723               	.LVL1101:
 805:switcherator.c ****         statusMsg[0] = 0;
 12724               		.loc 1 805 0
 12725 475a 1092 0000 		sts statusMsg,__zero_reg__
 806:switcherator.c ****         strcat(statusMsg, "Set @");
 12726               		.loc 1 806 0
 12727 475e 60E0      		ldi r22,lo8(.LC66)
 12728 4760 70E0      		ldi r23,hi8(.LC66)
 12729 4762 80E0      		ldi r24,lo8(statusMsg)
 12730 4764 90E0      		ldi r25,hi8(statusMsg)
 12731 4766 0E94 0000 		call strcat
 12732               	.LVL1102:
 807:switcherator.c ****         strcat(statusMsg, tempIntString);
 12733               		.loc 1 807 0
 12734 476a 60E0      		ldi r22,lo8(tempIntString)
 12735 476c 70E0      		ldi r23,hi8(tempIntString)
 12736 476e 80E0      		ldi r24,lo8(statusMsg)
 12737 4770 90E0      		ldi r25,hi8(statusMsg)
 12738 4772 0E94 0000 		call strcat
 12739               	.LVL1103:
 808:switcherator.c ****         sendMessage(statusMsg);
 12740               		.loc 1 808 0
 12741 4776 80E0      		ldi r24,lo8(statusMsg)
 12742 4778 90E0      		ldi r25,hi8(statusMsg)
 12743               	/* epilogue start */
 818:switcherator.c **** }
 12744               		.loc 1 818 0
 12745 477a DF91      		pop r29
 12746 477c CF91      		pop r28
 12747               	.LVL1104:
 12748 477e 1F91      		pop r17
 12749 4780 0F91      		pop r16
 12750               	.LVL1105:
 12751 4782 FF90      		pop r15
 12752               	.LVL1106:
 808:switcherator.c ****         sendMessage(statusMsg);
 12753               		.loc 1 808 0
 12754 4784 0C94 0000 		jmp sendMessage
 12755               	.LVL1107:
 12756               	.L875:
 812:switcherator.c ****         clearTheSwitch(switchNumber);
 12757               		.loc 1 812 0
 12758 4788 CE01      		movw r24,r28
 12759 478a 0E94 0000 		call clearTheSwitch
 12760               	.LVL1108:
 814:switcherator.c ****         switchStuff[switchNumber] = 212;
 12761               		.loc 1 814 0
 12762 478e C050      		subi r28,lo8(-(switchStuff))
 12763 4790 D040      		sbci r29,hi8(-(switchStuff))
 12764               	.LVL1109:
 12765 4792 84ED      		ldi r24,lo8(-44)
 12766 4794 8883      		st Y,r24
 815:switcherator.c ****         switchBright[switchNumber] = brightValue;
 12767               		.loc 1 815 0
 12768 4796 8F2D      		mov r24,r15
 12769 4798 8131      		cpi r24,lo8(17)
 12770 479a 00F0      		brlo .L876
 12771 479c 80E1      		ldi r24,lo8(16)
 12772               	.L876:
 12773 479e F801      		movw r30,r16
 12774 47a0 8083      		st Z,r24
 12775               	/* epilogue start */
 818:switcherator.c **** }
 12776               		.loc 1 818 0
 12777 47a2 DF91      		pop r29
 12778 47a4 CF91      		pop r28
 12779 47a6 1F91      		pop r17
 12780 47a8 0F91      		pop r16
 12781               	.LVL1110:
 12782 47aa FF90      		pop r15
 12783               	.LVL1111:
 816:switcherator.c ****         ok();
 12784               		.loc 1 816 0
 12785 47ac 0C94 0000 		jmp ok
 12786               	.LVL1112:
 12787               	.LFE19:
 12789               	.global	radioTest
 12791               	radioTest:
 12792               	.LFB71:
2866:switcherator.c **** int radioTest(void) {
 12793               		.loc 1 2866 0
 12794 47b0 AF92      		push r10
 12795               	.LCFI347:
 12796 47b2 BF92      		push r11
 12797               	.LCFI348:
 12798 47b4 CF92      		push r12
 12799               	.LCFI349:
 12800 47b6 DF92      		push r13
 12801               	.LCFI350:
 12802 47b8 EF92      		push r14
 12803               	.LCFI351:
 12804 47ba FF92      		push r15
 12805               	.LCFI352:
 12806 47bc 0F93      		push r16
 12807               	.LCFI353:
 12808 47be 1F93      		push r17
 12809               	.LCFI354:
 12810               	/* prologue: function */
 12811               	/* frame size = 0 */
 12812               	/* stack size = 8 */
 12813               	.L__stack_usage = 8
2868:switcherator.c ****     test_addr = readAddr(RX_ADDR_P0);    
 12814               		.loc 1 2868 0
 12815 47c0 8AE0      		ldi r24,lo8(10)
 12816 47c2 0E94 0000 		call readAddr
 12817               	.LVL1113:
2869:switcherator.c ****     if (test_addr != rx_addr_p0) {
 12818               		.loc 1 2869 0
 12819 47c6 A090 0000 		lds r10,rx_addr_p0
 12820 47ca B090 0000 		lds r11,rx_addr_p0+1
 12821 47ce C090 0000 		lds r12,rx_addr_p0+2
 12822 47d2 D090 0000 		lds r13,rx_addr_p0+3
 12823 47d6 E090 0000 		lds r14,rx_addr_p0+4
 12824 47da F090 0000 		lds r15,rx_addr_p0+5
 12825 47de 0091 0000 		lds r16,rx_addr_p0+6
 12826 47e2 1091 0000 		lds r17,rx_addr_p0+7
 12827 47e6 0E94 0000 		call __cmpdi2
 12828 47ea 01F0      		breq .L878
2871:switcherator.c ****         failCondition = 1;
 12829               		.loc 1 2871 0
 12830 47ec 81E0      		ldi r24,lo8(1)
 12831               	.LVL1114:
 12832 47ee 8093 0000 		sts failCondition,r24
2872:switcherator.c ****         return -1;
 12833               		.loc 1 2872 0
 12834 47f2 2FEF      		ldi r18,lo8(-1)
 12835 47f4 3FEF      		ldi r19,lo8(-1)
 12836 47f6 00C0      		rjmp .L879
 12837               	.LVL1115:
 12838               	.L878:
2874:switcherator.c ****     if(failCondition == 1 || failCondition == 2)
 12839               		.loc 1 2874 0
 12840 47f8 8091 0000 		lds r24,failCondition
 12841               	.LVL1116:
 12842 47fc 8150      		subi r24,lo8(-(-1))
 12843 47fe 8230      		cpi r24,lo8(2)
 12844 4800 00F4      		brsh .L880
2875:switcherator.c ****         clearFail();
 12845               		.loc 1 2875 0
 12846 4802 0E94 0000 		call clearFail
 12847               	.LVL1117:
 12848               	.L880:
2876:switcherator.c ****     return 1;
 12849               		.loc 1 2876 0
 12850 4806 21E0      		ldi r18,lo8(1)
 12851 4808 30E0      		ldi r19,0
 12852               	.L879:
2877:switcherator.c **** }
 12853               		.loc 1 2877 0
 12854 480a C901      		movw r24,r18
 12855               	/* epilogue start */
 12856 480c 1F91      		pop r17
 12857 480e 0F91      		pop r16
 12858 4810 FF90      		pop r15
 12859 4812 EF90      		pop r14
 12860 4814 DF90      		pop r13
 12861 4816 CF90      		pop r12
 12862 4818 BF90      		pop r11
 12863 481a AF90      		pop r10
 12864 481c 0895      		ret
 12865               	.LFE71:
 12867               	.global	radioInit
 12869               	radioInit:
 12870               	.LFB70:
2838:switcherator.c **** void radioInit(void) {
 12871               		.loc 1 2838 0
 12872 481e 0F93      		push r16
 12873               	.LCFI355:
 12874 4820 1F93      		push r17
 12875               	.LCFI356:
 12876               	/* prologue: function */
 12877               	/* frame size = 0 */
 12878               	/* stack size = 2 */
 12879               	.L__stack_usage = 2
2839:switcherator.c ****     nrfInit();
 12880               		.loc 1 2839 0
 12881 4822 0E94 0000 		call nrfInit
 12882               	.LVL1118:
2840:switcherator.c ****     rx_addr_p0 = SET_RX_ADDR_P0;
 12883               		.loc 1 2840 0
 12884 4826 91E0      		ldi r25,lo8(1)
 12885 4828 9093 0000 		sts rx_addr_p0,r25
 12886 482c 80EF      		ldi r24,lo8(-16)
 12887 482e 8093 0000 		sts rx_addr_p0+1,r24
 12888 4832 8093 0000 		sts rx_addr_p0+2,r24
 12889 4836 8093 0000 		sts rx_addr_p0+3,r24
 12890 483a 8093 0000 		sts rx_addr_p0+4,r24
 12891 483e 1092 0000 		sts rx_addr_p0+5,__zero_reg__
 12892 4842 1092 0000 		sts rx_addr_p0+6,__zero_reg__
 12893 4846 1092 0000 		sts rx_addr_p0+7,__zero_reg__
2841:switcherator.c ****     tx_addr = SET_TX_ADDR;
 12894               		.loc 1 2841 0
 12895 484a 9093 0000 		sts tx_addr,r25
 12896 484e 8093 0000 		sts tx_addr+1,r24
 12897 4852 8093 0000 		sts tx_addr+2,r24
 12898 4856 8093 0000 		sts tx_addr+3,r24
 12899 485a 8093 0000 		sts tx_addr+4,r24
 12900 485e 1092 0000 		sts tx_addr+5,__zero_reg__
 12901 4862 1092 0000 		sts tx_addr+6,__zero_reg__
 12902 4866 1092 0000 		sts tx_addr+7,__zero_reg__
2843:switcherator.c ****     rx_addr_p1 = readAddr(RX_ADDR_P1);
 12903               		.loc 1 2843 0
 12904 486a 8BE0      		ldi r24,lo8(11)
 12905 486c 0E94 0000 		call readAddr
 12906               	.LVL1119:
 12907 4870 2093 0000 		sts rx_addr_p1,r18
 12908 4874 3093 0000 		sts rx_addr_p1+1,r19
 12909 4878 4093 0000 		sts rx_addr_p1+2,r20
 12910 487c 5093 0000 		sts rx_addr_p1+3,r21
 12911 4880 6093 0000 		sts rx_addr_p1+4,r22
 12912 4884 7093 0000 		sts rx_addr_p1+5,r23
 12913 4888 8093 0000 		sts rx_addr_p1+6,r24
 12914 488c 9093 0000 		sts rx_addr_p1+7,r25
2844:switcherator.c ****     rx_addr_p2 = readAddr(RX_ADDR_P2);
 12915               		.loc 1 2844 0
 12916 4890 8CE0      		ldi r24,lo8(12)
 12917 4892 0E94 0000 		call readAddr
 12918               	.LVL1120:
 12919 4896 2093 0000 		sts rx_addr_p2,r18
 12920 489a 3093 0000 		sts rx_addr_p2+1,r19
 12921 489e 4093 0000 		sts rx_addr_p2+2,r20
 12922 48a2 5093 0000 		sts rx_addr_p2+3,r21
 12923 48a6 6093 0000 		sts rx_addr_p2+4,r22
 12924 48aa 7093 0000 		sts rx_addr_p2+5,r23
 12925 48ae 8093 0000 		sts rx_addr_p2+6,r24
 12926 48b2 9093 0000 		sts rx_addr_p2+7,r25
2845:switcherator.c ****     rx_addr_p3 = readAddr(RX_ADDR_P3);
 12927               		.loc 1 2845 0
 12928 48b6 8DE0      		ldi r24,lo8(13)
 12929 48b8 0E94 0000 		call readAddr
 12930               	.LVL1121:
 12931 48bc 2093 0000 		sts rx_addr_p3,r18
 12932 48c0 3093 0000 		sts rx_addr_p3+1,r19
 12933 48c4 4093 0000 		sts rx_addr_p3+2,r20
 12934 48c8 5093 0000 		sts rx_addr_p3+3,r21
 12935 48cc 6093 0000 		sts rx_addr_p3+4,r22
 12936 48d0 7093 0000 		sts rx_addr_p3+5,r23
 12937 48d4 8093 0000 		sts rx_addr_p3+6,r24
 12938 48d8 9093 0000 		sts rx_addr_p3+7,r25
2846:switcherator.c ****     rx_addr_p4 = readAddr(RX_ADDR_P4);
 12939               		.loc 1 2846 0
 12940 48dc 8EE0      		ldi r24,lo8(14)
 12941 48de 0E94 0000 		call readAddr
 12942               	.LVL1122:
 12943 48e2 2093 0000 		sts rx_addr_p4,r18
 12944 48e6 3093 0000 		sts rx_addr_p4+1,r19
 12945 48ea 4093 0000 		sts rx_addr_p4+2,r20
 12946 48ee 5093 0000 		sts rx_addr_p4+3,r21
 12947 48f2 6093 0000 		sts rx_addr_p4+4,r22
 12948 48f6 7093 0000 		sts rx_addr_p4+5,r23
 12949 48fa 8093 0000 		sts rx_addr_p4+6,r24
 12950 48fe 9093 0000 		sts rx_addr_p4+7,r25
2847:switcherator.c ****     rx_addr_p5 = readAddr(RX_ADDR_P5);
 12951               		.loc 1 2847 0
 12952 4902 8FE0      		ldi r24,lo8(15)
 12953 4904 0E94 0000 		call readAddr
 12954               	.LVL1123:
 12955 4908 2093 0000 		sts rx_addr_p5,r18
 12956 490c 3093 0000 		sts rx_addr_p5+1,r19
 12957 4910 4093 0000 		sts rx_addr_p5+2,r20
 12958 4914 5093 0000 		sts rx_addr_p5+3,r21
 12959 4918 6093 0000 		sts rx_addr_p5+4,r22
 12960 491c 7093 0000 		sts rx_addr_p5+5,r23
 12961 4920 8093 0000 		sts rx_addr_p5+6,r24
 12962 4924 9093 0000 		sts rx_addr_p5+7,r25
2849:switcherator.c ****     writeReg(RF_SETUP, SET_RF_SETUP);
 12963               		.loc 1 2849 0
 12964 4928 66E0      		ldi r22,lo8(6)
 12965 492a 86E0      		ldi r24,lo8(6)
 12966 492c 0E94 0000 		call writeReg
 12967               	.LVL1124:
2850:switcherator.c ****     writeAddr(RX_ADDR_P0, rx_addr_p0);
 12968               		.loc 1 2850 0
 12969 4930 0091 0000 		lds r16,rx_addr_p0
 12970 4934 1091 0000 		lds r17,rx_addr_p0+1
 12971 4938 2091 0000 		lds r18,rx_addr_p0+2
 12972 493c 3091 0000 		lds r19,rx_addr_p0+3
 12973 4940 4091 0000 		lds r20,rx_addr_p0+4
 12974 4944 5091 0000 		lds r21,rx_addr_p0+5
 12975 4948 6091 0000 		lds r22,rx_addr_p0+6
 12976 494c 7091 0000 		lds r23,rx_addr_p0+7
 12977 4950 8AE0      		ldi r24,lo8(10)
 12978 4952 0E94 0000 		call writeAddr
 12979               	.LVL1125:
2851:switcherator.c ****     writeAddr(TX_ADDR, tx_addr);
 12980               		.loc 1 2851 0
 12981 4956 0091 0000 		lds r16,tx_addr
 12982 495a 1091 0000 		lds r17,tx_addr+1
 12983 495e 2091 0000 		lds r18,tx_addr+2
 12984 4962 3091 0000 		lds r19,tx_addr+3
 12985 4966 4091 0000 		lds r20,tx_addr+4
 12986 496a 5091 0000 		lds r21,tx_addr+5
 12987 496e 6091 0000 		lds r22,tx_addr+6
 12988 4972 7091 0000 		lds r23,tx_addr+7
 12989 4976 80E1      		ldi r24,lo8(16)
 12990 4978 0E94 0000 		call writeAddr
 12991               	.LVL1126:
2852:switcherator.c ****     writeReg(DYNPD, SET_DYNPD);
 12992               		.loc 1 2852 0
 12993 497c 6FE3      		ldi r22,lo8(63)
 12994 497e 8CE1      		ldi r24,lo8(28)
 12995 4980 0E94 0000 		call writeReg
 12996               	.LVL1127:
2853:switcherator.c ****     writeReg(FEATURE, SET_FEATURE);
 12997               		.loc 1 2853 0
 12998 4984 64E0      		ldi r22,lo8(4)
 12999 4986 8DE1      		ldi r24,lo8(29)
 13000 4988 0E94 0000 		call writeReg
 13001               	.LVL1128:
2854:switcherator.c ****     writeReg(RF_CH, SET_RF_CH);
 13002               		.loc 1 2854 0
 13003 498c 6AE2      		ldi r22,lo8(42)
 13004 498e 85E0      		ldi r24,lo8(5)
 13005 4990 0E94 0000 		call writeReg
 13006               	.LVL1129:
2855:switcherator.c ****     writeReg(CONFIG, SET_CONFIG);
 13007               		.loc 1 2855 0
 13008 4994 68E0      		ldi r22,lo8(8)
 13009 4996 80E0      		ldi r24,0
 13010 4998 0E94 0000 		call writeReg
 13011               	.LVL1130:
2856:switcherator.c ****     writeReg(SETUP_RETR, SET_SETUP_RETR);
 13012               		.loc 1 2856 0
 13013 499c 6FE0      		ldi r22,lo8(15)
 13014 499e 84E0      		ldi r24,lo8(4)
 13015 49a0 0E94 0000 		call writeReg
 13016               	.LVL1131:
2859:switcherator.c ****     radioTest();
 13017               		.loc 1 2859 0
 13018 49a4 0E94 0000 		call radioTest
 13019               	.LVL1132:
 13020               	/* epilogue start */
2863:switcherator.c **** }
 13021               		.loc 1 2863 0
 13022 49a8 1F91      		pop r17
 13023 49aa 0F91      		pop r16
2861:switcherator.c ****     startRadio();
 13024               		.loc 1 2861 0
 13025 49ac 0C94 0000 		jmp startRadio
 13026               	.LVL1133:
 13027               	.LFE70:
 13029               	.global	setClock
 13031               	setClock:
 13032               	.LFB48:
2092:switcherator.c **** void setClock(char * commandReceived) {
 13033               		.loc 1 2092 0
 13034               	.LVL1134:
 13035 49b0 6F92      		push r6
 13036               	.LCFI357:
 13037 49b2 7F92      		push r7
 13038               	.LCFI358:
 13039 49b4 8F92      		push r8
 13040               	.LCFI359:
 13041 49b6 9F92      		push r9
 13042               	.LCFI360:
 13043 49b8 AF92      		push r10
 13044               	.LCFI361:
 13045 49ba BF92      		push r11
 13046               	.LCFI362:
 13047 49bc CF92      		push r12
 13048               	.LCFI363:
 13049 49be DF92      		push r13
 13050               	.LCFI364:
 13051 49c0 EF92      		push r14
 13052               	.LCFI365:
 13053 49c2 FF92      		push r15
 13054               	.LCFI366:
 13055 49c4 0F93      		push r16
 13056               	.LCFI367:
 13057 49c6 1F93      		push r17
 13058               	.LCFI368:
 13059 49c8 CF93      		push r28
 13060               	.LCFI369:
 13061 49ca DF93      		push r29
 13062               	.LCFI370:
 13063               	/* prologue: function */
 13064               	/* frame size = 0 */
 13065               	/* stack size = 14 */
 13066               	.L__stack_usage = 14
 13067 49cc EC01      		movw r28,r24
2095:switcherator.c ****     tempLongString[0] = '0';
 13068               		.loc 1 2095 0
 13069 49ce 80E3      		ldi r24,lo8(48)
 13070               	.LVL1135:
 13071 49d0 8093 0000 		sts tempLongString,r24
2096:switcherator.c ****     tempLongString[1] = '0';
 13072               		.loc 1 2096 0
 13073 49d4 8093 0000 		sts tempLongString+1,r24
2099:switcherator.c ****     tempLongString[2] = commandReceived[3];
 13074               		.loc 1 2099 0
 13075 49d8 8B81      		ldd r24,Y+3
 13076 49da 8093 0000 		sts tempLongString+2,r24
2100:switcherator.c ****     tempLongString[3] = commandReceived[4];
 13077               		.loc 1 2100 0
 13078 49de 8C81      		ldd r24,Y+4
 13079 49e0 8093 0000 		sts tempLongString+3,r24
2101:switcherator.c ****     globalMonth = atoi(tempLongString);
 13080               		.loc 1 2101 0
 13081 49e4 80E0      		ldi r24,lo8(tempLongString)
 13082 49e6 90E0      		ldi r25,hi8(tempLongString)
 13083 49e8 0E94 0000 		call atoi
 13084               	.LVL1136:
 13085 49ec 6C01      		movw r12,r24
 13086 49ee 9093 0000 		sts globalMonth+1,r25
 13087 49f2 8093 0000 		sts globalMonth,r24
2103:switcherator.c ****     tempLongString[2] = commandReceived[5];
 13088               		.loc 1 2103 0
 13089 49f6 8D81      		ldd r24,Y+5
 13090 49f8 8093 0000 		sts tempLongString+2,r24
2104:switcherator.c ****     tempLongString[3] = commandReceived[6];
 13091               		.loc 1 2104 0
 13092 49fc 8E81      		ldd r24,Y+6
 13093 49fe 8093 0000 		sts tempLongString+3,r24
2105:switcherator.c ****     globalDay = atoi(tempLongString);
 13094               		.loc 1 2105 0
 13095 4a02 80E0      		ldi r24,lo8(tempLongString)
 13096 4a04 90E0      		ldi r25,hi8(tempLongString)
 13097 4a06 0E94 0000 		call atoi
 13098               	.LVL1137:
 13099 4a0a 8C01      		movw r16,r24
 13100 4a0c 9093 0000 		sts globalDay+1,r25
 13101 4a10 8093 0000 		sts globalDay,r24
2107:switcherator.c ****     tempLongString[2] = commandReceived[11];
 13102               		.loc 1 2107 0
 13103 4a14 8B85      		ldd r24,Y+11
 13104 4a16 8093 0000 		sts tempLongString+2,r24
2108:switcherator.c ****     tempLongString[3] = commandReceived[12];
 13105               		.loc 1 2108 0
 13106 4a1a 8C85      		ldd r24,Y+12
 13107 4a1c 8093 0000 		sts tempLongString+3,r24
2109:switcherator.c ****     globalHour = atoi(tempLongString);
 13108               		.loc 1 2109 0
 13109 4a20 80E0      		ldi r24,lo8(tempLongString)
 13110 4a22 90E0      		ldi r25,hi8(tempLongString)
 13111 4a24 0E94 0000 		call atoi
 13112               	.LVL1138:
 13113 4a28 4C01      		movw r8,r24
 13114 4a2a 8093 0000 		sts globalHour,r24
 13115 4a2e 9092 0000 		sts globalHour+1,r9
2111:switcherator.c ****     tempLongString[2] = commandReceived[13];
 13116               		.loc 1 2111 0
 13117 4a32 8D85      		ldd r24,Y+13
 13118 4a34 8093 0000 		sts tempLongString+2,r24
2112:switcherator.c ****     tempLongString[3] = commandReceived[14];
 13119               		.loc 1 2112 0
 13120 4a38 8E85      		ldd r24,Y+14
 13121 4a3a 8093 0000 		sts tempLongString+3,r24
2113:switcherator.c ****     globalMinute = atoi(tempLongString);
 13122               		.loc 1 2113 0
 13123 4a3e 80E0      		ldi r24,lo8(tempLongString)
 13124 4a40 90E0      		ldi r25,hi8(tempLongString)
 13125 4a42 0E94 0000 		call atoi
 13126               	.LVL1139:
 13127 4a46 5C01      		movw r10,r24
 13128 4a48 8093 0000 		sts globalMinute,r24
 13129 4a4c B092 0000 		sts globalMinute+1,r11
2115:switcherator.c ****     tempLongString[2] = commandReceived[15];
 13130               		.loc 1 2115 0
 13131 4a50 8F85      		ldd r24,Y+15
 13132 4a52 8093 0000 		sts tempLongString+2,r24
2116:switcherator.c ****     tempLongString[3] = commandReceived[16];
 13133               		.loc 1 2116 0
 13134 4a56 8889      		ldd r24,Y+16
 13135 4a58 8093 0000 		sts tempLongString+3,r24
2117:switcherator.c ****     globalSecond = atoi(tempLongString);
 13136               		.loc 1 2117 0
 13137 4a5c 80E0      		ldi r24,lo8(tempLongString)
 13138 4a5e 90E0      		ldi r25,hi8(tempLongString)
 13139 4a60 0E94 0000 		call atoi
 13140               	.LVL1140:
 13141 4a64 3C01      		movw r6,r24
 13142 4a66 9093 0000 		sts globalSecond+1,r25
 13143 4a6a 8093 0000 		sts globalSecond,r24
2119:switcherator.c ****     tempLongString[0] = commandReceived[7];
 13144               		.loc 1 2119 0
 13145 4a6e 8F81      		ldd r24,Y+7
 13146 4a70 8093 0000 		sts tempLongString,r24
2120:switcherator.c ****     tempLongString[1] = commandReceived[8];
 13147               		.loc 1 2120 0
 13148 4a74 8885      		ldd r24,Y+8
 13149 4a76 8093 0000 		sts tempLongString+1,r24
2121:switcherator.c ****     tempLongString[2] = commandReceived[9];
 13150               		.loc 1 2121 0
 13151 4a7a 8985      		ldd r24,Y+9
 13152 4a7c 8093 0000 		sts tempLongString+2,r24
2122:switcherator.c ****     tempLongString[3] = commandReceived[10];
 13153               		.loc 1 2122 0
 13154 4a80 8A85      		ldd r24,Y+10
 13155 4a82 8093 0000 		sts tempLongString+3,r24
2123:switcherator.c ****     globalYear = atoi(tempLongString);
 13156               		.loc 1 2123 0
 13157 4a86 80E0      		ldi r24,lo8(tempLongString)
 13158 4a88 90E0      		ldi r25,hi8(tempLongString)
 13159 4a8a 0E94 0000 		call atoi
 13160               	.LVL1141:
 13161 4a8e 9093 0000 		sts globalYear+1,r25
 13162 4a92 8093 0000 		sts globalYear,r24
2124:switcherator.c ****     dow = getWeekday(globalYear, globalMonth, globalDay); // get day of week
 13163               		.loc 1 2124 0
 13164 4a96 A801      		movw r20,r16
 13165 4a98 B601      		movw r22,r12
 13166 4a9a 0E94 0000 		call getWeekday
 13167               	.LVL1142:
 13168 4a9e DC01      		movw r26,r24
 13169 4aa0 8093 0000 		sts dow,r24
 13170 4aa4 B093 0000 		sts dow+1,r27
 13171               	.LVL1143:
2126:switcherator.c ****     tempInt = tempInt * 24 * 60 * 60;
 13172               		.loc 1 2126 0
 13173 4aa8 20E8      		ldi r18,lo8(-128)
 13174 4aaa 31E5      		ldi r19,lo8(81)
 13175 4aac 41E0      		ldi r20,lo8(1)
 13176 4aae 50E0      		ldi r21,0
 13177 4ab0 0E94 0000 		call __muluhisi3
 13178 4ab4 6B01      		movw r12,r22
 13179 4ab6 7C01      		movw r14,r24
2129:switcherator.c ****     tempInt = tempInt * 60 * 60;
 13180               		.loc 1 2129 0
 13181 4ab8 9401      		movw r18,r8
 13182 4aba A0E1      		ldi r26,lo8(16)
 13183 4abc BEE0      		ldi r27,lo8(14)
 13184 4abe 0E94 0000 		call __umulhisi3
2130:switcherator.c ****     weeklySeconds += tempInt;
 13185               		.loc 1 2130 0
 13186 4ac2 C60E      		add r12,r22
 13187 4ac4 D71E      		adc r13,r23
 13188 4ac6 E81E      		adc r14,r24
 13189 4ac8 F91E      		adc r15,r25
2133:switcherator.c ****     weeklySeconds += tempInt;
 13190               		.loc 1 2133 0
 13191 4aca C60C      		add r12,r6
 13192 4acc D71C      		adc r13,r7
 13193 4ace E11C      		adc r14,__zero_reg__
 13194 4ad0 F11C      		adc r15,__zero_reg__
2132:switcherator.c ****     tempInt = tempInt * 60;
 13195               		.loc 1 2132 0
 13196 4ad2 9501      		movw r18,r10
 13197 4ad4 ACE3      		ldi r26,lo8(60)
 13198 4ad6 B0E0      		ldi r27,0
 13199 4ad8 0E94 0000 		call __umulhisi3
2134:switcherator.c ****     weeklySeconds += globalSecond;
 13200               		.loc 1 2134 0
 13201 4adc C60E      		add r12,r22
 13202 4ade D71E      		adc r13,r23
 13203 4ae0 E81E      		adc r14,r24
 13204 4ae2 F91E      		adc r15,r25
 13205 4ae4 C092 0000 		sts weeklySeconds,r12
 13206 4ae8 D092 0000 		sts weeklySeconds+1,r13
 13207 4aec E092 0000 		sts weeklySeconds+2,r14
 13208 4af0 F092 0000 		sts weeklySeconds+3,r15
2135:switcherator.c ****     clockString();
 13209               		.loc 1 2135 0
 13210 4af4 0E94 0000 		call clockString
 13211               	.LVL1144:
2136:switcherator.c ****     sendMessage(statusMsg);
 13212               		.loc 1 2136 0
 13213 4af8 80E0      		ldi r24,lo8(statusMsg)
 13214 4afa 90E0      		ldi r25,hi8(statusMsg)
 13215 4afc 0E94 0000 		call sendMessage
 13216               	.LVL1145:
2137:switcherator.c ****     stopClock();
 13217               		.loc 1 2137 0
 13218 4b00 0E94 0000 		call stopClock
 13219               	.LVL1146:
2138:switcherator.c ****     startClock();
 13220               		.loc 1 2138 0
 13221 4b04 0E94 0000 		call startClock
 13222               	.LVL1147:
2139:switcherator.c ****     panicMyClockIsNotSet = 0;
 13223               		.loc 1 2139 0
 13224 4b08 1092 0000 		sts panicMyClockIsNotSet,__zero_reg__
2140:switcherator.c ****     if(failCondition == 3) {
 13225               		.loc 1 2140 0
 13226 4b0c 8091 0000 		lds r24,failCondition
 13227 4b10 8330      		cpi r24,lo8(3)
 13228 4b12 01F4      		brne .L882
 13229               	/* epilogue start */
2143:switcherator.c **** }
 13230               		.loc 1 2143 0
 13231 4b14 DF91      		pop r29
 13232 4b16 CF91      		pop r28
 13233               	.LVL1148:
 13234 4b18 1F91      		pop r17
 13235 4b1a 0F91      		pop r16
 13236 4b1c FF90      		pop r15
 13237 4b1e EF90      		pop r14
 13238 4b20 DF90      		pop r13
 13239 4b22 CF90      		pop r12
 13240 4b24 BF90      		pop r11
 13241               	.LVL1149:
 13242 4b26 AF90      		pop r10
 13243 4b28 9F90      		pop r9
 13244 4b2a 8F90      		pop r8
 13245 4b2c 7F90      		pop r7
 13246 4b2e 6F90      		pop r6
2141:switcherator.c ****         clearFail();      
 13247               		.loc 1 2141 0
 13248 4b30 0C94 0000 		jmp clearFail
 13249               	.LVL1150:
 13250               	.L882:
 13251               	/* epilogue start */
2143:switcherator.c **** }
 13252               		.loc 1 2143 0
 13253 4b34 DF91      		pop r29
 13254 4b36 CF91      		pop r28
 13255               	.LVL1151:
 13256 4b38 1F91      		pop r17
 13257 4b3a 0F91      		pop r16
 13258 4b3c FF90      		pop r15
 13259 4b3e EF90      		pop r14
 13260 4b40 DF90      		pop r13
 13261 4b42 CF90      		pop r12
 13262 4b44 BF90      		pop r11
 13263               	.LVL1152:
 13264 4b46 AF90      		pop r10
 13265 4b48 9F90      		pop r9
 13266 4b4a 8F90      		pop r8
 13267 4b4c 7F90      		pop r7
 13268 4b4e 6F90      		pop r6
 13269 4b50 0895      		ret
 13270               	.LFE48:
 13272               	.global	checkCommand
 13274               	checkCommand:
 13275               	.LFB8:
 233:switcherator.c **** void checkCommand(char * commandReceived) {
 13276               		.loc 1 233 0
 13277               	.LVL1153:
 13278               	/* prologue: function */
 13279               	/* frame size = 0 */
 13280               	/* stack size = 0 */
 13281               	.L__stack_usage = 0
 234:switcherator.c ****     if (commandReceived[0] > 0x60)
 13282               		.loc 1 234 0
 13283 4b52 FC01      		movw r30,r24
 13284 4b54 2081      		ld r18,Z
 13285 4b56 2136      		cpi r18,lo8(97)
 13286 4b58 00F0      		brlo .L885
 235:switcherator.c ****         commandReceived[0] -= 0x20;
 13287               		.loc 1 235 0
 13288 4b5a 2052      		subi r18,lo8(-(-32))
 13289 4b5c 2083      		st Z,r18
 13290               	.L885:
 236:switcherator.c ****     if (commandReceived[1] > 0x60)
 13291               		.loc 1 236 0
 13292 4b5e FC01      		movw r30,r24
 13293 4b60 2181      		ldd r18,Z+1
 13294 4b62 2136      		cpi r18,lo8(97)
 13295 4b64 00F0      		brlo .L886
 237:switcherator.c ****         commandReceived[1] -= 0x20;
 13296               		.loc 1 237 0
 13297 4b66 2052      		subi r18,lo8(-(-32))
 13298 4b68 2183      		std Z+1,r18
 13299               	.L886:
 239:switcherator.c ****     switchme <<= 8;
 13300               		.loc 1 239 0
 13301 4b6a FC01      		movw r30,r24
 13302 4b6c 3081      		ld r19,Z
 13303 4b6e 20E0      		ldi r18,0
 13304               	.LVL1154:
 240:switcherator.c ****     switchme |= commandReceived[1];
 13305               		.loc 1 240 0
 13306 4b70 4181      		ldd r20,Z+1
 13307 4b72 242B      		or r18,r20
 13308               	.LVL1155:
 241:switcherator.c ****     switch (switchme) {
 13309               		.loc 1 241 0
 13310 4b74 2434      		cpi r18,68
 13311 4b76 F0E5      		ldi r31,80
 13312 4b78 3F07      		cpc r19,r31
 13313 4b7a 01F4      		brne .+2
 13314 4b7c 00C0      		rjmp .L905
 13315 4b7e 04F0      		brlt .+2
 13316 4b80 00C0      		rjmp .L924
 13317 4b82 2934      		cpi r18,73
 13318 4b84 E4E4      		ldi r30,68
 13319 4b86 3E07      		cpc r19,r30
 13320 4b88 01F4      		brne .+2
 13321 4b8a 00C0      		rjmp .L896
 13322 4b8c 04F4      		brge .L925
 13323 4b8e 2834      		cpi r18,72
 13324 4b90 43E4      		ldi r20,67
 13325 4b92 3407      		cpc r19,r20
 13326 4b94 01F4      		brne .+2
 13327 4b96 00C0      		rjmp .L891
 13328 4b98 04F4      		brge .L926
 13329 4b9a 2335      		cpi r18,83
 13330 4b9c F2E4      		ldi r31,66
 13331 4b9e 3F07      		cpc r19,r31
 13332 4ba0 01F4      		brne .+2
 13333 4ba2 00C0      		rjmp .L889
 13334 4ba4 2334      		cpi r18,67
 13335 4ba6 43E4      		ldi r20,67
 13336 4ba8 3407      		cpc r19,r20
 13337 4baa 01F4      		brne .+2
 13338 4bac 00C0      		rjmp .L890
 13339 4bae 2934      		cpi r18,73
 13340 4bb0 3144      		sbci r19,65
 13341 4bb2 01F0      		breq .+2
 13342 4bb4 00C0      		rjmp .L884
 13343 4bb6 00C0      		rjmp .L888
 13344               	.L926:
 13345 4bb8 2C34      		cpi r18,76
 13346 4bba F3E4      		ldi r31,67
 13347 4bbc 3F07      		cpc r19,r31
 13348 4bbe 01F4      		brne .+2
 13349 4bc0 00C0      		rjmp .L893
 13350 4bc2 04F4      		brge .L927
 13351 4bc4 2934      		cpi r18,73
 13352 4bc6 3344      		sbci r19,67
 13353 4bc8 01F0      		breq .+2
 13354 4bca 00C0      		rjmp .L884
 13355 4bcc 00C0      		rjmp .L892
 13356               	.L927:
 13357 4bce 2035      		cpi r18,80
 13358 4bd0 F3E4      		ldi r31,67
 13359 4bd2 3F07      		cpc r19,r31
 13360 4bd4 01F4      		brne .+2
 13361 4bd6 00C0      		rjmp .L894
 13362 4bd8 2435      		cpi r18,84
 13363 4bda 3344      		sbci r19,67
 13364 4bdc 01F0      		breq .+2
 13365 4bde 00C0      		rjmp .L884
 13366 4be0 00C0      		rjmp .L895
 13367               	.L925:
 13368 4be2 2436      		cpi r18,100
 13369 4be4 E8E4      		ldi r30,72
 13370 4be6 3E07      		cpc r19,r30
 13371 4be8 01F4      		brne .+2
 13372 4bea 00C0      		rjmp .L900
 13373 4bec 04F4      		brge .L928
 13374 4bee 2934      		cpi r18,73
 13375 4bf0 47E4      		ldi r20,71
 13376 4bf2 3407      		cpc r19,r20
 13377 4bf4 01F4      		brne .+2
 13378 4bf6 00C0      		rjmp .L898
 13379 4bf8 2335      		cpi r18,83
 13380 4bfa E7E4      		ldi r30,71
 13381 4bfc 3E07      		cpc r19,r30
 13382 4bfe 01F4      		brne .+2
 13383 4c00 00C0      		rjmp .L899
 13384 4c02 2335      		cpi r18,83
 13385 4c04 3444      		sbci r19,68
 13386 4c06 01F0      		breq .+2
 13387 4c08 00C0      		rjmp .L884
 13388 4c0a 00C0      		rjmp .L897
 13389               	.L928:
 13390 4c0c 2035      		cpi r18,80
 13391 4c0e 4EE4      		ldi r20,78
 13392 4c10 3407      		cpc r19,r20
 13393 4c12 01F4      		brne .+2
 13394 4c14 00C0      		rjmp .L902
 13395 4c16 04F4      		brge .L929
 13396 4c18 2035      		cpi r18,80
 13397 4c1a 3944      		sbci r19,73
 13398 4c1c 01F0      		breq .+2
 13399 4c1e 00C0      		rjmp .L884
 13400 4c20 00C0      		rjmp .L901
 13401               	.L929:
 13402 4c22 2335      		cpi r18,83
 13403 4c24 4EE4      		ldi r20,78
 13404 4c26 3407      		cpc r19,r20
 13405 4c28 01F4      		brne .+2
 13406 4c2a 00C0      		rjmp .L903
 13407 4c2c 2134      		cpi r18,65
 13408 4c2e 3045      		sbci r19,80
 13409 4c30 01F0      		breq .+2
 13410 4c32 00C0      		rjmp .L884
 13411 4c34 00C0      		rjmp .L904
 13412               	.L924:
 13413 4c36 2134      		cpi r18,65
 13414 4c38 F3E5      		ldi r31,83
 13415 4c3a 3F07      		cpc r19,r31
 13416 4c3c 01F4      		brne .+2
 13417 4c3e 00C0      		rjmp .L914
 13418 4c40 04F4      		brge .L930
 13419 4c42 2435      		cpi r18,84
 13420 4c44 E0E5      		ldi r30,80
 13421 4c46 3E07      		cpc r19,r30
 13422 4c48 01F4      		brne .+2
 13423 4c4a 00C0      		rjmp .L909
 13424 4c4c 04F4      		brge .L931
 13425 4c4e 2035      		cpi r18,80
 13426 4c50 40E5      		ldi r20,80
 13427 4c52 3407      		cpc r19,r20
 13428 4c54 01F4      		brne .+2
 13429 4c56 00C0      		rjmp .L907
 13430 4c58 2335      		cpi r18,83
 13431 4c5a E0E5      		ldi r30,80
 13432 4c5c 3E07      		cpc r19,r30
 13433 4c5e 01F4      		brne .+2
 13434 4c60 00C0      		rjmp .L908
 13435 4c62 2934      		cpi r18,73
 13436 4c64 3045      		sbci r19,80
 13437 4c66 01F0      		breq .+2
 13438 4c68 00C0      		rjmp .L884
 13439 4c6a 00C0      		rjmp .L906
 13440               	.L931:
 13441 4c6c 2735      		cpi r18,87
 13442 4c6e 40E5      		ldi r20,80
 13443 4c70 3407      		cpc r19,r20
 13444 4c72 01F4      		brne .+2
 13445 4c74 00C0      		rjmp .L911
 13446 4c76 04F4      		brge .L932
 13447 4c78 2635      		cpi r18,86
 13448 4c7a 3045      		sbci r19,80
 13449 4c7c 01F0      		breq .+2
 13450 4c7e 00C0      		rjmp .L884
 13451 4c80 00C0      		rjmp .L910
 13452               	.L932:
 13453 4c82 2334      		cpi r18,67
 13454 4c84 42E5      		ldi r20,82
 13455 4c86 3407      		cpc r19,r20
 13456 4c88 01F4      		brne .+2
 13457 4c8a 00C0      		rjmp .L912
 13458 4c8c 2434      		cpi r18,68
 13459 4c8e 3245      		sbci r19,82
 13460 4c90 01F0      		breq .+2
 13461 4c92 00C0      		rjmp .L884
 13462 4c94 00C0      		rjmp .L913
 13463               	.L930:
 13464 4c96 2035      		cpi r18,80
 13465 4c98 F3E5      		ldi r31,83
 13466 4c9a 3F07      		cpc r19,r31
 13467 4c9c 01F4      		brne .+2
 13468 4c9e 00C0      		rjmp .L919
 13469 4ca0 04F4      		brge .L933
 13470 4ca2 2334      		cpi r18,67
 13471 4ca4 E3E5      		ldi r30,83
 13472 4ca6 3E07      		cpc r19,r30
 13473 4ca8 01F0      		breq .L916
 13474 4caa 04F4      		brge .+2
 13475 4cac 00C0      		rjmp .L915
 13476 4cae 2434      		cpi r18,68
 13477 4cb0 43E5      		ldi r20,83
 13478 4cb2 3407      		cpc r19,r20
 13479 4cb4 01F0      		breq .L917
 13480 4cb6 2F34      		cpi r18,79
 13481 4cb8 3345      		sbci r19,83
 13482               	.LVL1156:
 13483 4cba 01F0      		breq .+2
 13484 4cbc 00C0      		rjmp .L884
 13485 4cbe 00C0      		rjmp .L918
 13486               	.LVL1157:
 13487               	.L933:
 13488 4cc0 2735      		cpi r18,87
 13489 4cc2 E3E5      		ldi r30,83
 13490 4cc4 3E07      		cpc r19,r30
 13491 4cc6 01F4      		brne .+2
 13492 4cc8 00C0      		rjmp .L921
 13493 4cca 04F4      		brge .L934
 13494 4ccc 2335      		cpi r18,83
 13495 4cce 3345      		sbci r19,83
 13496 4cd0 01F0      		breq .+2
 13497 4cd2 00C0      		rjmp .L884
 13498 4cd4 00C0      		rjmp .L920
 13499               	.L934:
 13500 4cd6 2934      		cpi r18,73
 13501 4cd8 E4E5      		ldi r30,84
 13502 4cda 3E07      		cpc r19,r30
 13503 4cdc 01F0      		breq .L922
 13504 4cde 2C34      		cpi r18,76
 13505 4ce0 3445      		sbci r19,84
 13506 4ce2 01F0      		breq .+2
 13507 4ce4 00C0      		rjmp .L884
 13508 4ce6 00C0      		rjmp .L923
 13509               	.L922:
 243:switcherator.c ****             setClock(commandReceived);
 13510               		.loc 1 243 0
 13511 4ce8 0C94 0000 		jmp setClock
 13512               	.LVL1158:
 13513               	.L897:
 246:switcherator.c ****             setDaylightSavings(commandReceived);
 13514               		.loc 1 246 0
 13515 4cec 0C94 0000 		jmp setDaylightSavings
 13516               	.LVL1159:
 13517               	.L923:
 249:switcherator.c ****             setTimeLimits(commandReceived);
 13518               		.loc 1 249 0
 13519 4cf0 0C94 0000 		jmp setTimeLimits
 13520               	.LVL1160:
 13521               	.L903:
 252:switcherator.c ****             setNewSwitch(commandReceived);
 13522               		.loc 1 252 0
 13523 4cf4 0C94 0000 		jmp setNewSwitch
 13524               	.LVL1161:
 13525               	.L916:
 255:switcherator.c ****             switchClear(commandReceived);
 13526               		.loc 1 255 0
 13527 4cf8 0C94 0000 		jmp switchClear
 13528               	.LVL1162:
 13529               	.L917:
 258:switcherator.c ****             switchDisplay(commandReceived);
 13530               		.loc 1 258 0
 13531 4cfc 0C94 0000 		jmp switchDisplay
 13532               	.LVL1163:
 13533               	.L908:
 261:switcherator.c ****             pwmSetup(commandReceived);
 13534               		.loc 1 261 0
 13535 4d00 0C94 0000 		jmp pwmSetup
 13536               	.LVL1164:
 13537               	.L891:
 264:switcherator.c ****             cycleHue(commandReceived);
 13538               		.loc 1 264 0
 13539 4d04 0C94 0000 		jmp cycleHue
 13540               	.LVL1165:
 13541               	.L900:
 267:switcherator.c ****             setHueSpeed(commandReceived);
 13542               		.loc 1 267 0
 13543 4d08 0C94 0000 		jmp setHueSpeed
 13544               	.LVL1166:
 13545               	.L910:
 270:switcherator.c ****             pwmValueSet(commandReceived);
 13546               		.loc 1 270 0
 13547 4d0c 0C94 0000 		jmp pwmValueSet
 13548               	.LVL1167:
 13549               	.L902:
 273:switcherator.c ****             newProgram(commandReceived);
 13550               		.loc 1 273 0
 13551 4d10 0C94 0000 		jmp newProgram
 13552               	.LVL1168:
 13553               	.L894:
 276:switcherator.c ****             clearProgram(commandReceived);
 13554               		.loc 1 276 0
 13555 4d14 0C94 0000 		jmp clearProgram
 13556               	.LVL1169:
 13557               	.L904:
 279:switcherator.c ****             programAddSwitch(commandReceived);
 13558               		.loc 1 279 0
 13559 4d18 0C94 0000 		jmp programAddSwitch
 13560               	.LVL1170:
 13561               	.L905:
 282:switcherator.c ****             programSetDays(commandReceived);
 13562               		.loc 1 282 0
 13563 4d1c 0C94 0000 		jmp programSetDays
 13564               	.LVL1171:
 13565               	.L909:
 285:switcherator.c ****             programSetTime(commandReceived);
 13566               		.loc 1 285 0
 13567 4d20 0C94 0000 		jmp programSetTime
 13568               	.LVL1172:
 13569               	.L906:
 288:switcherator.c ****             programDisplay(commandReceived);
 13570               		.loc 1 288 0
 13571 4d24 0C94 0000 		jmp programDisplay
 13572               	.LVL1173:
 13573               	.L920:
 291:switcherator.c ****             startSwitch(commandReceived);
 13574               		.loc 1 291 0
 13575 4d28 0C94 0000 		jmp startSwitch
 13576               	.LVL1174:
 13577               	.L919:
 294:switcherator.c ****             startProgram(commandReceived);
 13578               		.loc 1 294 0
 13579 4d2c 0C94 0000 		jmp startProgram
 13580               	.LVL1175:
 13581               	.L914:
 297:switcherator.c ****             saveToEEPROM();
 13582               		.loc 1 297 0
 13583 4d30 0C94 0000 		jmp saveToEEPROM
 13584               	.LVL1176:
 13585               	.L893:
 300:switcherator.c ****             clearToEEPROM();
 13586               		.loc 1 300 0
 13587 4d34 0C94 0000 		jmp clearToEEPROM
 13588               	.LVL1177:
 13589               	.L913:
 303:switcherator.c ****             radioDisplayAddress(commandReceived);
 13590               		.loc 1 303 0
 13591 4d38 0C94 0000 		jmp radioDisplayAddress
 13592               	.LVL1178:
 13593               	.L912:
 306:switcherator.c ****             radioChangeAddress(commandReceived);
 13594               		.loc 1 306 0
 13595 4d3c 0C94 0000 		jmp radioChangeAddress
 13596               	.LVL1179:
 13597               	.L888:
 309:switcherator.c ****             setAnalogInput(commandReceived);
 13598               		.loc 1 309 0
 13599 4d40 0C94 0000 		jmp setAnalogInput
 13600               	.LVL1180:
 13601               	.L896:
 312:switcherator.c ****             setDigitalInput(commandReceived);
 13602               		.loc 1 312 0
 13603 4d44 0C94 0000 		jmp setDigitalInput
 13604               	.LVL1181:
 13605               	.L892:
 315:switcherator.c ****             clearInput(commandReceived);
 13606               		.loc 1 315 0
 13607 4d48 0C94 0000 		jmp clearInput
 13608               	.LVL1182:
 13609               	.L895:
 318:switcherator.c ****             clockTweak(commandReceived);
 13610               		.loc 1 318 0
 13611 4d4c 0C94 0000 		jmp clockTweak
 13612               	.LVL1183:
 13613               	.L911:
 321:switcherator.c ****             pwmSummary();
 13614               		.loc 1 321 0
 13615 4d50 0C94 0000 		jmp pwmSummary
 13616               	.LVL1184:
 13617               	.L899:
 327:switcherator.c ****             generalStatus(commandReceived);
 13618               		.loc 1 327 0
 13619 4d54 0C94 0000 		jmp generalStatus
 13620               	.LVL1185:
 13621               	.L890:
 333:switcherator.c ****             colorChangeSet(commandReceived);
 13622               		.loc 1 333 0
 13623 4d58 0C94 0000 		jmp colorChangeSet
 13624               	.LVL1186:
 13625               	.L915:
 336:switcherator.c ****             switchBrightness(commandReceived);
 13626               		.loc 1 336 0
 13627 4d5c 0C94 0000 		jmp switchBrightness
 13628               	.LVL1187:
 13629               	.L889:
 339:switcherator.c ****             brightnessSet(commandReceived);
 13630               		.loc 1 339 0
 13631 4d60 0C94 0000 		jmp brightnessSet
 13632               	.LVL1188:
 13633               	.L898:
 342:switcherator.c ****             generalInformation();
 13634               		.loc 1 342 0
 13635 4d64 0C94 0000 		jmp generalInformation
 13636               	.LVL1189:
 13637               	.L907:
 345:switcherator.c ****             programsProgrammed();
 13638               		.loc 1 345 0
 13639 4d68 0C94 0000 		jmp programsProgrammed
 13640               	.LVL1190:
 13641               	.L921:
 348:switcherator.c ****             switchesProgrammed();
 13642               		.loc 1 348 0
 13643 4d6c 0C94 0000 		jmp switchesProgrammed
 13644               	.LVL1191:
 13645               	.L901:
 351:switcherator.c ****             inputsProgrammed();
 13646               		.loc 1 351 0
 13647 4d70 0C94 0000 		jmp inputsProgrammed
 13648               	.LVL1192:
 13649               	.L918:
 354:switcherator.c ****             switchesOn();
 13650               		.loc 1 354 0
 13651 4d74 0C94 0000 		jmp switchesOn
 13652               	.LVL1193:
 13653               	.L884:
 13654 4d78 0895      		ret
 13655               	.LFE8:
 13657               		.section	.rodata.str1.1
 13658               	.LC73:
 13659 016f 6773 7100 		.string	"gsq"
 13660               		.section	.text.startup,"ax",@progbits
 13661               	.global	main
 13663               	main:
 13664               	.LFB7:
 121:switcherator.c **** int main(void) {
 13665               		.loc 1 121 0
 13666               	/* prologue: function */
 13667               	/* frame size = 0 */
 13668               	/* stack size = 0 */
 13669               	.L__stack_usage = 0
 122:switcherator.c ****     receiveBuffer[0] = 0;
 13670               		.loc 1 122 0
 13671 0000 1092 0000 		sts receiveBuffer,__zero_reg__
 123:switcherator.c ****     radioReceiveBuffer[0] = 0;
 13672               		.loc 1 123 0
 13673 0004 1092 0000 		sts radioReceiveBuffer,__zero_reg__
 13674               	.LVL1194:
 126:switcherator.c ****     INDICATOR_DDR |= INDICATOR_PIN;
 13675               		.loc 1 126 0
 13676 0008 529A      		sbi 0xa,2
 13677 000a 84E0      		ldi r24,lo8(4)
 13678 000c 90E0      		ldi r25,0
 13679               	.LVL1195:
 13680               	.L936:
 128:switcherator.c ****         INDICATOR_PORT |= INDICATOR_PIN;
 13681               		.loc 1 128 0 discriminator 2
 13682 000e 5A9A      		sbi 0xb,2
 13683               	.LVL1196:
 13684               	.LBB30:
 13685               	.LBB31:
 164:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 13686               		.loc 2 164 0 discriminator 2
 13687 0010 2FEF      		ldi r18,lo8(159999)
 13688 0012 30E7      		ldi r19,hi8(159999)
 13689 0014 42E0      		ldi r20,hlo8(159999)
 13690 0016 2150      		1: subi r18,1
 13691 0018 3040      		sbci r19,0
 13692 001a 4040      		sbci r20,0
 13693 001c 01F4      		brne 1b
 13694 001e 00C0      		rjmp .
 13695 0020 0000      		nop
 13696               	.LBE31:
 13697               	.LBE30:
 130:switcherator.c ****         INDICATOR_PORT &= ~(INDICATOR_PIN);
 13698               		.loc 1 130 0 discriminator 2
 13699 0022 5A98      		cbi 0xb,2
 13700               	.LVL1197:
 13701               	.LBB32:
 13702               	.LBB33:
 164:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 13703               		.loc 2 164 0 discriminator 2
 13704 0024 2FEF      		ldi r18,lo8(319999)
 13705 0026 31EE      		ldi r19,hi8(319999)
 13706 0028 44E0      		ldi r20,hlo8(319999)
 13707 002a 2150      		1: subi r18,1
 13708 002c 3040      		sbci r19,0
 13709 002e 4040      		sbci r20,0
 13710 0030 01F4      		brne 1b
 13711 0032 00C0      		rjmp .
 13712 0034 0000      		nop
 13713 0036 0197      		sbiw r24,1
 13714               	.LBE33:
 13715               	.LBE32:
 127:switcherator.c ****     for (x = 0; x < 4; x++) {
 13716               		.loc 1 127 0 discriminator 2
 13717 0038 01F4      		brne .L936
 133:switcherator.c ****     INDICATOR_PORT |= INDICATOR_PIN;
 13718               		.loc 1 133 0
 13719 003a 5A9A      		sbi 0xb,2
 13720               	.LVL1198:
 13721 003c E0E0      		ldi r30,lo8(colorChanges+2)
 13722 003e F0E0      		ldi r31,hi8(colorChanges+2)
 139:switcherator.c ****         colorChanges[x][1] = 1;
 13723               		.loc 1 139 0
 13724 0040 81E0      		ldi r24,lo8(1)
 13725               	.LVL1199:
 13726               	.L937:
 121:switcherator.c **** int main(void) {
 13727               		.loc 1 121 0 discriminator 2
 13728 0042 DF01      		movw r26,r30
 13729 0044 1297      		sbiw r26,2
 138:switcherator.c ****         colorChanges[x][0] = 0;
 13730               		.loc 1 138 0 discriminator 2
 13731 0046 1C92      		st X,__zero_reg__
 121:switcherator.c **** int main(void) {
 13732               		.loc 1 121 0 discriminator 2
 13733 0048 DF01      		movw r26,r30
 13734 004a 1197      		sbiw r26,1
 139:switcherator.c ****         colorChanges[x][1] = 1;
 13735               		.loc 1 139 0 discriminator 2
 13736 004c 8C93      		st X,r24
 140:switcherator.c ****         colorChanges[x][2] = 0;
 13737               		.loc 1 140 0 discriminator 2
 13738 004e 1082      		st Z,__zero_reg__
 13739 0050 3396      		adiw r30,3
 137:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 13740               		.loc 1 137 0 discriminator 2
 13741 0052 90E0      		ldi r25,hi8(colorChanges+20)
 13742 0054 E030      		cpi r30,lo8(colorChanges+20)
 13743 0056 F907      		cpc r31,r25
 13744 0058 01F4      		brne .L937
 144:switcherator.c ****     globalYear = globalMonth = globalDay = globalHour = globalMinute = globalSecond = dow = 0;
 13745               		.loc 1 144 0
 13746 005a 1092 0000 		sts dow+1,__zero_reg__
 13747 005e 1092 0000 		sts dow,__zero_reg__
 13748 0062 1092 0000 		sts globalSecond+1,__zero_reg__
 13749 0066 1092 0000 		sts globalSecond,__zero_reg__
 13750 006a 1092 0000 		sts globalMinute+1,__zero_reg__
 13751 006e 1092 0000 		sts globalMinute,__zero_reg__
 13752 0072 1092 0000 		sts globalHour+1,__zero_reg__
 13753 0076 1092 0000 		sts globalHour,__zero_reg__
 13754 007a 1092 0000 		sts globalDay+1,__zero_reg__
 13755 007e 1092 0000 		sts globalDay,__zero_reg__
 13756 0082 1092 0000 		sts globalMonth+1,__zero_reg__
 13757 0086 1092 0000 		sts globalMonth,__zero_reg__
 13758 008a 1092 0000 		sts globalYear+1,__zero_reg__
 13759 008e 1092 0000 		sts globalYear,__zero_reg__
 13760               	.LVL1200:
 13761 0092 E0E0      		ldi r30,lo8(switchStatus)
 13762 0094 F0E0      		ldi r31,hi8(switchStatus)
 13763 0096 C0E0      		ldi r28,lo8(switchStuff)
 13764 0098 D0E0      		ldi r29,hi8(switchStuff)
 13765 009a A0E0      		ldi r26,lo8(switchBright)
 13766 009c B0E0      		ldi r27,hi8(switchBright)
 147:switcherator.c ****         switchStuff[x] = 255;
 13767               		.loc 1 147 0
 13768 009e 2FEF      		ldi r18,lo8(-1)
 148:switcherator.c ****         switchBright[x] = 16;
 13769               		.loc 1 148 0
 13770 00a0 90E1      		ldi r25,lo8(16)
 13771               	.LVL1201:
 13772               	.L938:
 146:switcherator.c ****         switchStatus[x] = 0;
 13773               		.loc 1 146 0 discriminator 2
 13774 00a2 1192      		st Z+,__zero_reg__
 13775 00a4 1192      		st Z+,__zero_reg__
 13776 00a6 1192      		st Z+,__zero_reg__
 13777 00a8 1192      		st Z+,__zero_reg__
 147:switcherator.c ****         switchStuff[x] = 255;
 13778               		.loc 1 147 0 discriminator 2
 13779 00aa 8FEF      		ldi r24,lo8(-1)
 13780 00ac 2993      		st Y+,r18
 148:switcherator.c ****         switchBright[x] = 16;
 13781               		.loc 1 148 0 discriminator 2
 13782 00ae 9D93      		st X+,r25
 145:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 13783               		.loc 1 145 0 discriminator 2
 13784 00b0 30E0      		ldi r19,hi8(switchStatus+64)
 13785 00b2 E030      		cpi r30,lo8(switchStatus+64)
 13786 00b4 F307      		cpc r31,r19
 13787 00b6 01F4      		brne .L938
 13788               	.LVL1202:
 151:switcherator.c ****         inputs[x][0] = 255;
 13789               		.loc 1 151 0 discriminator 1
 13790 00b8 8093 0000 		sts inputs,r24
 13791               	.LVL1203:
 13792 00bc 8093 0000 		sts inputs+8,r24
 13793               	.LVL1204:
 13794 00c0 8093 0000 		sts inputs+16,r24
 13795               	.LVL1205:
 13796 00c4 8093 0000 		sts inputs+24,r24
 13797               	.LVL1206:
 153:switcherator.c ****     sei();
 13798               		.loc 1 153 0 discriminator 1
 13799               	/* #APP */
 13800               	 ;  153 "switcherator.c" 1
 13801 00c8 7894      		sei
 13802               	 ;  0 "" 2
 13803               	.LVL1207:
 156:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 13804               		.loc 1 156 0 discriminator 1
 13805               	/* #NOAPP */
 13806 00ca C0E0      		ldi r28,0
 13807 00cc D0E0      		ldi r29,0
 13808               	.LVL1208:
 13809               	.L939:
 157:switcherator.c ****         clearTheProgram(x);
 13810               		.loc 1 157 0 discriminator 2
 13811 00ce CE01      		movw r24,r28
 13812 00d0 0E94 0000 		call clearTheProgram
 13813               	.LVL1209:
 156:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 13814               		.loc 1 156 0 discriminator 2
 13815 00d4 2196      		adiw r28,1
 13816               	.LVL1210:
 13817 00d6 CA30      		cpi r28,10
 13818 00d8 D105      		cpc r29,__zero_reg__
 13819 00da 01F4      		brne .L939
 162:switcherator.c ****     clockInit();
 13820               		.loc 1 162 0
 13821 00dc 0E94 0000 		call clockInit
 13822               	.LVL1211:
 163:switcherator.c ****     radioInit();
 13823               		.loc 1 163 0
 13824 00e0 0E94 0000 		call radioInit
 13825               	.LVL1212:
 164:switcherator.c ****     startRx();
 13826               		.loc 1 164 0
 13827 00e4 0E94 0000 		call startRx
 13828               	.LVL1213:
 166:switcherator.c ****     generalInit();
 13829               		.loc 1 166 0
 13830 00e8 0E94 0000 		call generalInit
 13831               	.LVL1214:
 167:switcherator.c ****     startClock();
 13832               		.loc 1 167 0
 13833 00ec 0E94 0000 		call startClock
 13834               	.LVL1215:
 13835               	.L963:
 178:switcherator.c ****         if (newSecond == 1) {
 13836               		.loc 1 178 0
 13837 00f0 8091 0000 		lds r24,newSecond
 13838 00f4 8130      		cpi r24,lo8(1)
 13839 00f6 01F4      		brne .L940
 179:switcherator.c ****             newSecond = 0;
 13840               		.loc 1 179 0
 13841 00f8 1092 0000 		sts newSecond,__zero_reg__
 180:switcherator.c ****             timerCheck();
 13842               		.loc 1 180 0
 13843 00fc 0E94 0000 		call timerCheck
 13844               	.LVL1216:
 181:switcherator.c ****             inputCheck();
 13845               		.loc 1 181 0
 13846 0100 0E94 0000 		call inputCheck
 13847               	.LVL1217:
 13848               	.L940:
 184:switcherator.c ****         if (switchChanged == 1) {
 13849               		.loc 1 184 0
 13850 0104 8091 0000 		lds r24,switchChanged
 13851 0108 8130      		cpi r24,lo8(1)
 13852 010a 01F4      		brne .L941
 185:switcherator.c ****             switchChanged = 0;
 13853               		.loc 1 185 0
 13854 010c 1092 0000 		sts switchChanged,__zero_reg__
 186:switcherator.c ****             switchOnOff();
 13855               		.loc 1 186 0
 13856 0110 0E94 0000 		call switchOnOff
 13857               	.LVL1218:
 13858               	.L941:
 188:switcherator.c ****         if (runHue == 1) {
 13859               		.loc 1 188 0
 13860 0114 8091 0000 		lds r24,runHue
 13861 0118 8130      		cpi r24,lo8(1)
 13862 011a 01F4      		brne .L942
 189:switcherator.c ****             runHueFunction();
 13863               		.loc 1 189 0
 13864 011c 0E94 0000 		call runHueFunction
 13865               	.LVL1219:
 13866               	.L942:
 191:switcherator.c ****         if (runColorChanges == 1) {
 13867               		.loc 1 191 0
 13868 0120 C091 0000 		lds r28,runColorChanges
 13869 0124 C130      		cpi r28,lo8(1)
 13870 0126 01F4      		brne .L943
 192:switcherator.c ****             runColorFunction();
 13871               		.loc 1 192 0
 13872 0128 0E94 0000 		call runColorFunction
 13873               	.LVL1220:
 13874               	.L943:
 194:switcherator.c ****         if (tenthFlag == 1) {
 13875               		.loc 1 194 0
 13876 012c 8091 0000 		lds r24,tenthFlag
 13877 0130 8130      		cpi r24,lo8(1)
 13878 0132 01F4      		brne .L945
 195:switcherator.c ****             tenthFlag = 0;
 13879               		.loc 1 195 0
 13880 0134 1092 0000 		sts tenthFlag,__zero_reg__
 196:switcherator.c ****             inputTenthCheck();
 13881               		.loc 1 196 0
 13882 0138 0E94 0000 		call inputTenthCheck
 13883               	.LVL1221:
 197:switcherator.c ****             if (failCondition > 0) {
 13884               		.loc 1 197 0
 13885 013c 8091 0000 		lds r24,failCondition
 13886 0140 8111      		cpse r24,__zero_reg__
 198:switcherator.c ****                 flashFail();
 13887               		.loc 1 198 0
 13888 0142 0E94 0000 		call flashFail
 13889               	.LVL1222:
 13890               	.L946:
 200:switcherator.c ****             if (runColorChanges == 1) {
 13891               		.loc 1 200 0
 13892 0146 C130      		cpi r28,lo8(1)
 13893 0148 01F4      		brne .L945
 201:switcherator.c ****                 runColorFunction();
 13894               		.loc 1 201 0
 13895 014a 0E94 0000 		call runColorFunction
 13896               	.LVL1223:
 13897               	.L945:
 204:switcherator.c ****         if (newMinute == 1) {
 13898               		.loc 1 204 0
 13899 014e 8091 0000 		lds r24,newMinute
 13900 0152 8130      		cpi r24,lo8(1)
 13901 0154 01F4      		brne .L948
 205:switcherator.c ****             newMinute = 0;
 13902               		.loc 1 205 0
 13903 0156 1092 0000 		sts newMinute,__zero_reg__
 206:switcherator.c ****             if (panicMyClockIsNotSet == 1) {
 13904               		.loc 1 206 0
 13905 015a 8091 0000 		lds r24,panicMyClockIsNotSet
 13906 015e 8130      		cpi r24,lo8(1)
 13907 0160 01F4      		brne .L949
 207:switcherator.c ****                 generalStatus("gsq");
 13908               		.loc 1 207 0
 13909 0162 80E0      		ldi r24,lo8(.LC73)
 13910 0164 90E0      		ldi r25,hi8(.LC73)
 13911 0166 0E94 0000 		call generalStatus
 13912               	.LVL1224:
 13913               	.L949:
 209:switcherator.c ****             radioTest();
 13914               		.loc 1 209 0
 13915 016a 0E94 0000 		call radioTest
 13916               	.LVL1225:
 13917               	.L948:
 212:switcherator.c ****         payloadLength = dynReceive(radioReceiveBuffer);
 13918               		.loc 1 212 0
 13919 016e 80E0      		ldi r24,lo8(radioReceiveBuffer)
 13920 0170 90E0      		ldi r25,hi8(radioReceiveBuffer)
 13921 0172 0E94 0000 		call dynReceive
 13922               	.LVL1226:
 13923 0176 90E0      		ldi r25,0
 213:switcherator.c ****         if (payloadLength > 1) {
 13924               		.loc 1 213 0
 13925 0178 0297      		sbiw r24,2
 13926 017a 04F4      		brge .+2
 13927 017c 00C0      		rjmp .L963
 13928               	.LVL1227:
 13929               	.LBB34:
 13930               	.LBB35:
 164:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 13931               		.loc 2 164 0
 13932 017e 4FEF      		ldi r20,lo8(287999)
 13933 0180 84E6      		ldi r24,hi8(287999)
 13934 0182 94E0      		ldi r25,hlo8(287999)
 13935 0184 4150      		1: subi r20,1
 13936 0186 8040      		sbci r24,0
 13937 0188 9040      		sbci r25,0
 13938 018a 01F4      		brne 1b
 13939               	.LVL1228:
 13940 018c 00C0      		rjmp .
 13941 018e 0000      		nop
 13942               	.LBE35:
 13943               	.LBE34:
 216:switcherator.c ****             checkCommand(radioReceiveBuffer);
 13944               		.loc 1 216 0
 13945 0190 80E0      		ldi r24,lo8(radioReceiveBuffer)
 13946 0192 90E0      		ldi r25,hi8(radioReceiveBuffer)
 13947 0194 0E94 0000 		call checkCommand
 13948               	.LVL1229:
 13949 0198 E0E0      		ldi r30,lo8(radioReceiveBuffer)
 13950 019a F0E0      		ldi r31,hi8(radioReceiveBuffer)
 13951 019c A0E0      		ldi r26,lo8(receiveBuffer)
 13952 019e B0E0      		ldi r27,hi8(receiveBuffer)
 13953               	.LVL1230:
 13954               	.L951:
 220:switcherator.c ****                 radioReceiveBuffer[x] = 0;
 13955               		.loc 1 220 0 discriminator 2
 13956 01a0 1192      		st Z+,__zero_reg__
 221:switcherator.c ****                 receiveBuffer[x] = 0;
 13957               		.loc 1 221 0 discriminator 2
 13958 01a2 1D92      		st X+,__zero_reg__
 219:switcherator.c ****             for (x = 0; x < 30; x++) {
 13959               		.loc 1 219 0 discriminator 2
 13960 01a4 20E0      		ldi r18,hi8(radioReceiveBuffer+30)
 13961 01a6 E030      		cpi r30,lo8(radioReceiveBuffer+30)
 13962 01a8 F207      		cpc r31,r18
 13963 01aa 01F4      		brne .L951
 13964 01ac 00C0      		rjmp .L963
 13965               	.LFE7:
 13967               		.text
 13968               	.global	__vector_11
 13970               	__vector_11:
 13971               	.LFB85:
3705:switcherator.c **** }
3706:switcherator.c **** 
3707:switcherator.c **** ISR(TIMER1_COMPA_vect) {
 13972               		.loc 1 3707 0
 13973 4d7a 1F92      		push r1
 13974               	.LCFI371:
 13975 4d7c 0F92      		push r0
 13976               	.LCFI372:
 13977 4d7e 0FB6      		in r0,__SREG__
 13978 4d80 0F92      		push r0
 13979 4d82 1124      		clr __zero_reg__
 13980 4d84 2F93      		push r18
 13981               	.LCFI373:
 13982 4d86 3F93      		push r19
 13983               	.LCFI374:
 13984 4d88 4F93      		push r20
 13985               	.LCFI375:
 13986 4d8a 5F93      		push r21
 13987               	.LCFI376:
 13988 4d8c 6F93      		push r22
 13989               	.LCFI377:
 13990 4d8e 7F93      		push r23
 13991               	.LCFI378:
 13992 4d90 8F93      		push r24
 13993               	.LCFI379:
 13994 4d92 9F93      		push r25
 13995               	.LCFI380:
 13996 4d94 AF93      		push r26
 13997               	.LCFI381:
 13998 4d96 BF93      		push r27
 13999               	.LCFI382:
 14000 4d98 EF93      		push r30
 14001               	.LCFI383:
 14002 4d9a FF93      		push r31
 14003               	.LCFI384:
 14004               	/* prologue: Signal */
 14005               	/* frame size = 0 */
 14006               	/* stack size = 15 */
 14007               	.L__stack_usage = 15
3708:switcherator.c ****     int tenthTicks;
3709:switcherator.c ****     ticks++;
 14008               		.loc 1 3709 0
 14009 4d9c 4091 0000 		lds r20,ticks
 14010 4da0 5091 0000 		lds r21,ticks+1
 14011 4da4 4F5F      		subi r20,-1
 14012 4da6 5F4F      		sbci r21,-1
 14013 4da8 5093 0000 		sts ticks+1,r21
 14014 4dac 4093 0000 		sts ticks,r20
3710:switcherator.c ****     // if its been a second
3711:switcherator.c ****     if (ticks >= tweakTimer) {
 14015               		.loc 1 3711 0
 14016 4db0 60E0      		ldi r22,0
 14017 4db2 70E0      		ldi r23,0
 14018 4db4 8091 0000 		lds r24,tweakTimer
 14019 4db8 9091 0000 		lds r25,tweakTimer+1
 14020 4dbc A091 0000 		lds r26,tweakTimer+2
 14021 4dc0 B091 0000 		lds r27,tweakTimer+3
 14022 4dc4 4817      		cp r20,r24
 14023 4dc6 5907      		cpc r21,r25
 14024 4dc8 6A07      		cpc r22,r26
 14025 4dca 7B07      		cpc r23,r27
 14026 4dcc 04F4      		brge .+2
 14027 4dce 00C0      		rjmp .L966
3712:switcherator.c ****         ticks = 0;
 14028               		.loc 1 3712 0
 14029 4dd0 1092 0000 		sts ticks+1,__zero_reg__
 14030 4dd4 1092 0000 		sts ticks,__zero_reg__
3713:switcherator.c ****         globalSecond++;
 14031               		.loc 1 3713 0
 14032 4dd8 2091 0000 		lds r18,globalSecond
 14033 4ddc 3091 0000 		lds r19,globalSecond+1
 14034 4de0 2F5F      		subi r18,-1
 14035 4de2 3F4F      		sbci r19,-1
 14036 4de4 3093 0000 		sts globalSecond+1,r19
 14037 4de8 2093 0000 		sts globalSecond,r18
3714:switcherator.c ****         weeklySeconds++;
 14038               		.loc 1 3714 0
 14039 4dec 8091 0000 		lds r24,weeklySeconds
 14040 4df0 9091 0000 		lds r25,weeklySeconds+1
 14041 4df4 A091 0000 		lds r26,weeklySeconds+2
 14042 4df8 B091 0000 		lds r27,weeklySeconds+3
 14043 4dfc 0196      		adiw r24,1
 14044 4dfe A11D      		adc r26,__zero_reg__
 14045 4e00 B11D      		adc r27,__zero_reg__
 14046 4e02 8093 0000 		sts weeklySeconds,r24
 14047 4e06 9093 0000 		sts weeklySeconds+1,r25
 14048 4e0a A093 0000 		sts weeklySeconds+2,r26
 14049 4e0e B093 0000 		sts weeklySeconds+3,r27
3715:switcherator.c ****         newSecond = 1;
 14050               		.loc 1 3715 0
 14051 4e12 41E0      		ldi r20,lo8(1)
 14052 4e14 4093 0000 		sts newSecond,r20
3716:switcherator.c ****         if (globalSecond == 60) {
 14053               		.loc 1 3716 0
 14054 4e18 2C33      		cpi r18,60
 14055 4e1a 3105      		cpc r19,__zero_reg__
 14056 4e1c 01F4      		brne .L966
3717:switcherator.c ****             globalMinute++;
 14057               		.loc 1 3717 0
 14058 4e1e 8091 0000 		lds r24,globalMinute
 14059 4e22 9091 0000 		lds r25,globalMinute+1
 14060 4e26 0196      		adiw r24,1
 14061 4e28 9093 0000 		sts globalMinute+1,r25
 14062 4e2c 8093 0000 		sts globalMinute,r24
3718:switcherator.c ****             globalSecond = 0;
 14063               		.loc 1 3718 0
 14064 4e30 1092 0000 		sts globalSecond+1,__zero_reg__
 14065 4e34 1092 0000 		sts globalSecond,__zero_reg__
3719:switcherator.c ****             newMinute = 1;
 14066               		.loc 1 3719 0
 14067 4e38 4093 0000 		sts newMinute,r20
3720:switcherator.c ****             if (globalMinute == 60) {
 14068               		.loc 1 3720 0
 14069 4e3c CC97      		sbiw r24,60
 14070 4e3e 01F4      		brne .L966
3721:switcherator.c ****                 globalHour++;
 14071               		.loc 1 3721 0
 14072 4e40 8091 0000 		lds r24,globalHour
 14073 4e44 9091 0000 		lds r25,globalHour+1
 14074 4e48 0196      		adiw r24,1
 14075 4e4a 9093 0000 		sts globalHour+1,r25
 14076 4e4e 8093 0000 		sts globalHour,r24
3722:switcherator.c ****                 globalMinute = 0;
 14077               		.loc 1 3722 0
 14078 4e52 1092 0000 		sts globalMinute+1,__zero_reg__
 14079 4e56 1092 0000 		sts globalMinute,__zero_reg__
3723:switcherator.c ****                 // daylight savings is always at 3am
3724:switcherator.c ****                 if (globalHour == 3)
 14080               		.loc 1 3724 0
 14081 4e5a 0397      		sbiw r24,3
 14082 4e5c 01F4      		brne .L968
3725:switcherator.c ****                     checkDaylightSavings();
 14083               		.loc 1 3725 0
 14084 4e5e 0E94 0000 		call checkDaylightSavings
 14085               	.LVL1231:
 14086               	.L968:
3726:switcherator.c ****                 if (globalHour == 24) {
 14087               		.loc 1 3726 0
 14088 4e62 8091 0000 		lds r24,globalHour
 14089 4e66 9091 0000 		lds r25,globalHour+1
 14090 4e6a 4897      		sbiw r24,24
 14091 4e6c 01F4      		brne .L966
3727:switcherator.c ****                     globalHour = 0;
 14092               		.loc 1 3727 0
 14093 4e6e 1092 0000 		sts globalHour+1,__zero_reg__
 14094 4e72 1092 0000 		sts globalHour,__zero_reg__
3728:switcherator.c ****                     advanceDay();
 14095               		.loc 1 3728 0
 14096 4e76 0E94 0000 		call advanceDay
 14097               	.LVL1232:
 14098               	.L966:
3729:switcherator.c ****                 }
3730:switcherator.c ****             }
3731:switcherator.c ****         }
3732:switcherator.c ****     }
3733:switcherator.c ****     tenthTicks = ticks % TIMER_TENTH;
 14099               		.loc 1 3733 0
 14100 4e7a 8091 0000 		lds r24,ticks
 14101 4e7e 9091 0000 		lds r25,ticks+1
 14102 4e82 68E1      		ldi r22,lo8(24)
 14103 4e84 76E0      		ldi r23,lo8(6)
 14104 4e86 0E94 0000 		call __udivmodhi4
 14105               	.LVL1233:
3734:switcherator.c ****     if (tenthTicks == 0) {
 14106               		.loc 1 3734 0
 14107 4e8a 892B      		or r24,r25
 14108 4e8c 01F4      		brne .L964
3735:switcherator.c ****         tenthFlag = 1;
 14109               		.loc 1 3735 0
 14110 4e8e 81E0      		ldi r24,lo8(1)
 14111               	.LVL1234:
 14112 4e90 8093 0000 		sts tenthFlag,r24
 14113               	.L964:
 14114               	/* epilogue start */
3736:switcherator.c ****         // set flags for whatever functions we want to do every 10th of a second here
3737:switcherator.c ****     }
3738:switcherator.c **** }
 14115               		.loc 1 3738 0
 14116 4e94 FF91      		pop r31
 14117 4e96 EF91      		pop r30
 14118 4e98 BF91      		pop r27
 14119 4e9a AF91      		pop r26
 14120 4e9c 9F91      		pop r25
 14121 4e9e 8F91      		pop r24
 14122 4ea0 7F91      		pop r23
 14123 4ea2 6F91      		pop r22
 14124 4ea4 5F91      		pop r21
 14125 4ea6 4F91      		pop r20
 14126 4ea8 3F91      		pop r19
 14127 4eaa 2F91      		pop r18
 14128 4eac 0F90      		pop r0
 14129 4eae 0FBE      		out __SREG__,r0
 14130 4eb0 0F90      		pop r0
 14131 4eb2 1F90      		pop r1
 14132 4eb4 1895      		reti
 14133               	.LFE85:
 14135               		.local	receiveBuffer
 14136               		.comm	receiveBuffer,30,1
 14137               		.local	radioReceiveBuffer
 14138               		.comm	radioReceiveBuffer,30,1
 14139               		.local	colorChanges
 14140               		.comm	colorChanges,18,1
 14141               		.local	dow
 14142               		.comm	dow,2,1
 14143               		.local	globalSecond
 14144               		.comm	globalSecond,2,1
 14145               		.local	globalMinute
 14146               		.comm	globalMinute,2,1
 14147               		.local	globalHour
 14148               		.comm	globalHour,2,1
 14149               		.local	globalDay
 14150               		.comm	globalDay,2,1
 14151               		.local	globalMonth
 14152               		.comm	globalMonth,2,1
 14153               		.local	globalYear
 14154               		.comm	globalYear,2,1
 14155               		.local	switchStatus
 14156               		.comm	switchStatus,64,1
 14157               		.local	switchStuff
 14158               		.comm	switchStuff,16,1
 14159               		.local	switchBright
 14160               		.comm	switchBright,16,1
 14161               		.local	inputs
 14162               		.comm	inputs,32,1
 14163               		.local	newSecond
 14164               		.comm	newSecond,1,1
 14165               		.local	switchChanged
 14166               		.comm	switchChanged,1,1
 14167               		.local	runHue
 14168               		.comm	runHue,1,1
 14169               		.local	runColorChanges
 14170               		.comm	runColorChanges,1,1
 14171               		.local	tenthFlag
 14172               		.comm	tenthFlag,1,1
 14173               		.data
 14176               	failCondition:
 14177 0000 03        		.byte	3
 14178               		.local	newMinute
 14179               		.comm	newMinute,1,1
 14182               	panicMyClockIsNotSet:
 14183 0001 01        		.byte	1
 14184               		.local	statusMsg
 14185               		.comm	statusMsg,32,1
 14188               	tempIntString:
 14189 0002 3030 00   		.string	"00"
 14192               	tempHugeString:
 14193 0005 3030 3030 		.string	"000000"
 14193      3030 00
 14194               		.local	weeklySeconds
 14195               		.comm	weeklySeconds,4,1
 14196               		.local	pwmValues
 14197               		.comm	pwmValues,3,1
 14198               		.local	red
 14199               		.comm	red,2,1
 14200               		.local	green
 14201               		.comm	green,2,1
 14202               		.local	blue
 14203               		.comm	blue,2,1
 14206               	bright:
 14207 000c 1000      		.word	16
 14208               		.local	pwmdir
 14209               		.comm	pwmdir,1,1
 14212               	oldBright:
 14213 000e 10        		.byte	16
 14216               	tempLongString:
 14217 000f 3030 3030 		.string	"0000"
 14217      00
 14220               	colorChangeSpeed:
 14221 0014 0A00      		.word	10
 14224               	hueSpeed:
 14225 0016 1000      		.word	16
 14226               		.local	colorChangeCount
 14227               		.comm	colorChangeCount,2,1
 14228               		.local	currentColor
 14229               		.comm	currentColor,1,1
 14230               		.local	littleCount
 14231               		.comm	littleCount,1,1
 14232               		.local	hueCount
 14233               		.comm	hueCount,2,1
 14234               		.local	currentHue
 14235               		.comm	currentHue,2,1
 14236               		.local	weeklyProgram
 14237               		.comm	weeklyProgram,100,1
 14238               		.local	tx_addr
 14239               		.comm	tx_addr,8,1
 14240               		.local	rx_addr_p0
 14241               		.comm	rx_addr_p0,8,1
 14242               		.local	rx_addr_p1
 14243               		.comm	rx_addr_p1,8,1
 14244               		.local	rx_addr_p2
 14245               		.comm	rx_addr_p2,8,1
 14246               		.local	rx_addr_p3
 14247               		.comm	rx_addr_p3,8,1
 14248               		.local	rx_addr_p4
 14249               		.comm	rx_addr_p4,8,1
 14250               		.local	rx_addr_p5
 14251               		.comm	rx_addr_p5,8,1
 14254               	tweakTimer:
 14255 0018 09        		.byte	9
 14256 0019 3D        		.byte	61
 14257 001a 00        		.byte	0
 14258 001b 00        		.byte	0
 14259               		.local	daylightSavings
 14260               		.comm	daylightSavings,8,1
 14261               		.local	timeLimits
 14262               		.comm	timeLimits,48,1
 14263               		.local	wasDaylightSavings
 14264               		.comm	wasDaylightSavings,1,1
 14265               		.local	failTimer
 14266               		.comm	failTimer,1,1
 14267               		.local	ticks
 14268               		.comm	ticks,2,1
 17153               	.Letext0:
 17154               		.file 3 "/usr/lib/gcc/avr/4.7.2/include/stddef.h"
 17155               		.file 4 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/stdint.h"
 17156               		.file 5 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/stdlib.h"
 17157               		.file 6 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/eeprom.h"
 17158               		.file 7 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/string.h"
 17159               		.file 8 "../myavrnrflib/nrf.h"
DEFINED SYMBOLS
                            *ABS*:00000000 switcherator.c
     /tmp/cc0nDDU3.s:2      *ABS*:0000003e __SP_H__
     /tmp/cc0nDDU3.s:3      *ABS*:0000003d __SP_L__
     /tmp/cc0nDDU3.s:4      *ABS*:0000003f __SREG__
     /tmp/cc0nDDU3.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/cc0nDDU3.s:6      *ABS*:00000001 __zero_reg__
     /tmp/cc0nDDU3.s:11     .text:00000000 drawInterface
     /tmp/cc0nDDU3.s:24     .text:00000002 getSwitchNumber
     /tmp/cc0nDDU3.s:14188  .data:00000002 tempIntString
     /tmp/cc0nDDU3.s:49     .text:00000018 getPort
     /tmp/cc0nDDU3.s:14156  .bss:0000009c switchStuff
     /tmp/cc0nDDU3.s:208    .text:000000bc pwmClear
     /tmp/cc0nDDU3.s:14212  .data:0000000e oldBright
     /tmp/cc0nDDU3.s:14206  .data:0000000c bright
     /tmp/cc0nDDU3.s:14166  .bss:000000de runHue
     /tmp/cc0nDDU3.s:14168  .bss:000000df runColorChanges
     /tmp/cc0nDDU3.s:257    .text:000000f8 clearTheSwitch
     /tmp/cc0nDDU3.s:413    .text:000001be runColorFunction
     /tmp/cc0nDDU3.s:14209  .bss:00000110 colorChangeCount
     /tmp/cc0nDDU3.s:14220  .data:00000014 colorChangeSpeed
     /tmp/cc0nDDU3.s:14227  .bss:00000112 currentColor
     /tmp/cc0nDDU3.s:14138  .bss:0000003c colorChanges
     /tmp/cc0nDDU3.s:14197  .bss:00000109 red
     /tmp/cc0nDDU3.s:14199  .bss:0000010b green
     /tmp/cc0nDDU3.s:14201  .bss:0000010d blue
     /tmp/cc0nDDU3.s:555    .text:000002ae runHueFunction
     /tmp/cc0nDDU3.s:14229  .bss:00000113 littleCount
     /tmp/cc0nDDU3.s:14231  .bss:00000114 hueCount
     /tmp/cc0nDDU3.s:14224  .data:00000016 hueSpeed
     /tmp/cc0nDDU3.s:14233  .bss:00000116 currentHue
     /tmp/cc0nDDU3.s:792    .text:00000492 clearTheProgram
     /tmp/cc0nDDU3.s:14235  .bss:00000118 weeklyProgram
     /tmp/cc0nDDU3.s:838    .text:000004be findOpenSwitch
     /tmp/cc0nDDU3.s:889    .text:000004f2 programGetSwitches
     /tmp/cc0nDDU3.s:973    .text:00000552 startTheProgram
     /tmp/cc0nDDU3.s:14185  .bss:00000102 weeklySeconds
     /tmp/cc0nDDU3.s:14154  .bss:0000005c switchStatus
     /tmp/cc0nDDU3.s:14164  .bss:000000dd switchChanged
     /tmp/cc0nDDU3.s:1148   .text:0000064e readEEPROM
     /tmp/cc0nDDU3.s:1238   .text:000006aa writeEEPROM
     /tmp/cc0nDDU3.s:1277   .text:000006ca clearEEPROM
     /tmp/cc0nDDU3.s:1294   .text:000006d2 clockInit
     /tmp/cc0nDDU3.s:1317   .text:000006ec startClock
     /tmp/cc0nDDU3.s:1340   .text:00000704 stopClock
     /tmp/cc0nDDU3.s:1358   .text:00000710 getWeekday
     /tmp/cc0nDDU3.s:14152  .bss:0000005a globalYear
     /tmp/cc0nDDU3.s:1469   .text:000007a4 getDayofYear
     /tmp/cc0nDDU3.s:1557   .text:0000080a checkDaylightSavings
     /tmp/cc0nDDU3.s:14262  .bss:000001ec wasDaylightSavings
     /tmp/cc0nDDU3.s:14150  .bss:00000058 globalMonth
     /tmp/cc0nDDU3.s:14251  .bss:000001b4 daylightSavings
     /tmp/cc0nDDU3.s:14148  .bss:00000056 globalDay
     /tmp/cc0nDDU3.s:14146  .bss:00000054 globalHour
     /tmp/cc0nDDU3.s:1623   .text:0000088e advanceDay
     /tmp/cc0nDDU3.s:14140  .bss:0000004e dow
     /tmp/cc0nDDU3.s:1810   .text:000009da timerCheck
     /tmp/cc0nDDU3.s:2050   .text:00000b42 switchOnOff
     /tmp/cc0nDDU3.s:14195  .bss:00000106 pwmValues
     /tmp/cc0nDDU3.s:14158  .bss:000000ac switchBright
     /tmp/cc0nDDU3.s:2404   .text:00000d40 returnInt
     /tmp/cc0nDDU3.s:14192  .data:00000005 tempHugeString
     /tmp/cc0nDDU3.s:2468   .text:00000d7c clockString
     /tmp/cc0nDDU3.s:14179  .bss:000000e2 statusMsg
     /tmp/cc0nDDU3.s:14144  .bss:00000052 globalMinute
     /tmp/cc0nDDU3.s:14142  .bss:00000050 globalSecond
     /tmp/cc0nDDU3.s:2613   .text:00000e74 returnHex
     /tmp/cc0nDDU3.s:2692   .text:00000ed0 returnHexWithout
     /tmp/cc0nDDU3.s:2755   .text:00000f16 formatAddress
     /tmp/cc0nDDU3.s:2815   .text:00000f50 generalInit
     /tmp/cc0nDDU3.s:14237  .bss:0000017c tx_addr
     /tmp/cc0nDDU3.s:14239  .bss:00000184 rx_addr_p0
     /tmp/cc0nDDU3.s:14241  .bss:0000018c rx_addr_p1
     /tmp/cc0nDDU3.s:14243  .bss:00000194 rx_addr_p2
     /tmp/cc0nDDU3.s:14245  .bss:0000019c rx_addr_p3
     /tmp/cc0nDDU3.s:14247  .bss:000001a4 rx_addr_p4
     /tmp/cc0nDDU3.s:14249  .bss:000001ac rx_addr_p5
     /tmp/cc0nDDU3.s:14254  .data:00000018 tweakTimer
     /tmp/cc0nDDU3.s:14160  .bss:000000bc inputs
     /tmp/cc0nDDU3.s:14260  .bss:000001bc timeLimits
     /tmp/cc0nDDU3.s:14203  .bss:0000010f pwmdir
     /tmp/cc0nDDU3.s:3602   .text:0000147a unformatAddress
     /tmp/cc0nDDU3.s:3650   .text:000014a2 getInput
     /tmp/cc0nDDU3.s:4654   .text:00001a92 inputTenthCheck
     /tmp/cc0nDDU3.s:4714   .text:00001ad0 inputCheck
     /tmp/cc0nDDU3.s:4793   .text:00001b32 flashFail
     /tmp/cc0nDDU3.s:14264  .bss:000001ed failTimer
     /tmp/cc0nDDU3.s:14176  .data:00000000 failCondition
     /tmp/cc0nDDU3.s:4904   .text:00001bb0 clearFail
     /tmp/cc0nDDU3.s:4922   .text:00001bba sendMessage
     /tmp/cc0nDDU3.s:5020   .text:00001c16 radioChangeAddress
     /tmp/cc0nDDU3.s:14216  .data:0000000f tempLongString
     /tmp/cc0nDDU3.s:5472   .text:00001f26 radioDisplayAddress
     /tmp/cc0nDDU3.s:5728   .text:00002106 switchesOn
     /tmp/cc0nDDU3.s:5817   .text:00002174 inputsProgrammed
     /tmp/cc0nDDU3.s:5902   .text:000021da switchesProgrammed
     /tmp/cc0nDDU3.s:5986   .text:0000223e programsProgrammed
     /tmp/cc0nDDU3.s:6084   .text:000022aa generalInformation
     /tmp/cc0nDDU3.s:6439   .text:000024b0 generalStatus
     /tmp/cc0nDDU3.s:14182  .data:00000001 panicMyClockIsNotSet
     /tmp/cc0nDDU3.s:6666   .text:000025f0 programDisplay
     /tmp/cc0nDDU3.s:7179   .text:000028c6 pwmSummary
     /tmp/cc0nDDU3.s:7511   .text:00002a9c switchDisplay
     /tmp/cc0nDDU3.s:7664   .text:00002b6a ok
     /tmp/cc0nDDU3.s:7680   .text:00002b72 clearInput
     /tmp/cc0nDDU3.s:7789   .text:00002bf0 setDaylightSavings
     /tmp/cc0nDDU3.s:7896   .text:00002c82 clearToEEPROM
     /tmp/cc0nDDU3.s:8057   .text:00002d7a saveToEEPROM
     /tmp/cc0nDDU3.s:8717   .text:000031f8 pwmValueSet
     /tmp/cc0nDDU3.s:8826   .text:0000328e setHueSpeed
     /tmp/cc0nDDU3.s:8863   .text:000032b6 cycleHue
     /tmp/cc0nDDU3.s:8906   .text:000032ea switchClear
     /tmp/cc0nDDU3.s:8931   .text:000032f6 clockTweak
     /tmp/cc0nDDU3.s:9025   .text:00003388 brightnessSet
     /tmp/cc0nDDU3.s:9130   .text:00003426 fail
     /tmp/cc0nDDU3.s:9181   .text:0000345e setDigitalInput
     /tmp/cc0nDDU3.s:9581   .text:00003666 setAnalogInput
     /tmp/cc0nDDU3.s:10057  .text:00003928 startProgram
     /tmp/cc0nDDU3.s:10153  .text:000039a2 programSetTime
     /tmp/cc0nDDU3.s:10413  .text:00003af2 programSetDays
     /tmp/cc0nDDU3.s:10598  .text:00003bf4 programAddSwitch
     /tmp/cc0nDDU3.s:10904  .text:00003d92 clearProgram
     /tmp/cc0nDDU3.s:10982  .text:00003de4 colorChangeSet
     /tmp/cc0nDDU3.s:11104  .text:00003e90 pwmSetup
     /tmp/cc0nDDU3.s:11269  .text:00003f5e startSwitch
     /tmp/cc0nDDU3.s:11598  .text:0000414c setNewSwitch
     /tmp/cc0nDDU3.s:11886  .text:000042ae setTimeLimits
     /tmp/cc0nDDU3.s:12374  .text:00004598 newProgram
     /tmp/cc0nDDU3.s:12646  .text:000046fc switchBrightness
     /tmp/cc0nDDU3.s:12791  .text:000047b0 radioTest
     /tmp/cc0nDDU3.s:12869  .text:0000481e radioInit
     /tmp/cc0nDDU3.s:13031  .text:000049b0 setClock
     /tmp/cc0nDDU3.s:13274  .text:00004b52 checkCommand
     /tmp/cc0nDDU3.s:13663  .text.startup:00000000 main
                             .bss:00000000 receiveBuffer
     /tmp/cc0nDDU3.s:14136  .bss:0000001e radioReceiveBuffer
     /tmp/cc0nDDU3.s:14162  .bss:000000dc newSecond
     /tmp/cc0nDDU3.s:14170  .bss:000000e0 tenthFlag
     /tmp/cc0nDDU3.s:14172  .bss:000000e1 newMinute
     /tmp/cc0nDDU3.s:13970  .text:00004d7a __vector_11
     /tmp/cc0nDDU3.s:14266  .bss:000001ee ticks

UNDEFINED SYMBOLS
atoi
__eerd_word_m328
__eerd_block_m328
__eeupd_block_m328
__eeupd_word_m328
__divmodhi4
__muluhisi3
itoa
strcat
__ashldi3
writeAddr
__lshrdi3
__mulsi3
__umulhisi3
__divmodsi4
__udivmodsi4
stopRx
transmit
startRx
strtol
__udivmodhi4
__cmpdi2_s8
__usmulhisi3
atol
readAddr
__cmpdi2
nrfInit
writeReg
startRadio
dynReceive
__do_copy_data
__do_clear_bss
