   1               		.file	"switcherator.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               	.global	drawInterface
  11               	drawInterface:
  12               	.LFB9:
  13               		.file 1 "switcherator.c"
   1:switcherator.c **** #ifndef __AVR_ATmega328__
   2:switcherator.c **** #define __AVR_ATmega328__
   3:switcherator.c **** #endif
   4:switcherator.c **** #ifndef F_CPU
   5:switcherator.c **** #define F_CPU 16000000
   6:switcherator.c **** #endif
   7:switcherator.c **** 
   8:switcherator.c **** 
   9:switcherator.c **** #include "switcherator.h"
  10:switcherator.c **** 
  11:switcherator.c **** // Uncomment if you want the print variables command available (costs 1K in program memory)
  12:switcherator.c **** // warning - probably way to big.
  13:switcherator.c **** //#define debug
  14:switcherator.c **** //#define help
  15:switcherator.c **** 
  16:switcherator.c **** // globals and such
  17:switcherator.c **** 
  18:switcherator.c **** // First time we are turned on and we have the wrong time
  19:switcherator.c **** static char panicMyClockIsNotSet = 1;
  20:switcherator.c **** 
  21:switcherator.c **** 
  22:switcherator.c **** // clock related
  23:switcherator.c **** static unsigned int ticks = 0; // ticks for the clock
  24:switcherator.c **** static unsigned int globalYear, globalMonth, globalDay, globalHour, globalMinute, globalSecond, dow
  25:switcherator.c **** // dow - Sunday = 0
  26:switcherator.c **** static unsigned long weeklySeconds = 0;
  27:switcherator.c **** // This is 1 on daylight savings day so I don't do it twice
  28:switcherator.c **** static char wasDaylightSavings = 0;
  29:switcherator.c **** static unsigned int daylightSavings[2][2]; // [0][0] = spring month, [0][1] = spring day, etc...
  30:switcherator.c **** 
  31:switcherator.c **** // flags
  32:switcherator.c **** static char newSecond = 0;
  33:switcherator.c **** static char newMinute = 0;
  34:switcherator.c **** static char switchChanged = 0;
  35:switcherator.c **** static char tenthFlag = 0; // 10th of a second(ish) has passed
  36:switcherator.c **** static char failCondition = 3;
  37:switcherator.c **** static char failTimer = 0;
  38:switcherator.c **** #define INDICATOR_PORT PORTD
  39:switcherator.c **** #define INDICATOR_PIN (1 << PIND2)
  40:switcherator.c **** #define INDICATOR_DDR DDRD
  41:switcherator.c **** 
  42:switcherator.c **** // When the switch will turn off (weekly seconds))
  43:switcherator.c **** static unsigned long switchStatus[NUM_SWITCHES];
  44:switcherator.c **** // Coded information for the switches
  45:switcherator.c **** // value of 255 (default) means nothing programmed
  46:switcherator.c **** // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
  47:switcherator.c **** // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
  48:switcherator.c **** // pin is abs(value/2)-the base - PINB3 = (22-16)/2  PINB3 (22-16)%2 = 0 - low (23-16)%2 = 1 - high
  49:switcherator.c **** // 200 = PWM, 201 = PWM rotating hue. PWM always uses PORTD3,PORTD5,PORTD6 for RGB
  50:switcherator.c **** // 202 = Color changing PWM
  51:switcherator.c **** // future - 202 - PWM with other ports. Can't on 328p since radio overlaps pwm pins
  52:switcherator.c **** static char switchStuff[NUM_SWITCHES];
  53:switcherator.c **** 
  54:switcherator.c **** 
  55:switcherator.c **** // strings
  56:switcherator.c **** static char receiveBuffer[30];
  57:switcherator.c **** static char radioReceiveBuffer[30];
  58:switcherator.c **** static char tempIntString[] = "00";
  59:switcherator.c **** static char tempLongString[] = "0000";
  60:switcherator.c **** static char tempHugeString[] = "000000";
  61:switcherator.c **** static char statusMsg[32];
  62:switcherator.c **** 
  63:switcherator.c **** // HardwarePWM
  64:switcherator.c **** static char runHue = 0;
  65:switcherator.c **** static char runColorChanges = 0;
  66:switcherator.c **** // PD3, PD5, PD6 or red,green,blue
  67:switcherator.c **** static char pwmValues[] = {0, 0, 0};
  68:switcherator.c **** static char colorChanges[NUM_COLOR_CHANGES][3];
  69:switcherator.c **** 
  70:switcherator.c **** 
  71:switcherator.c **** // rotating hue
  72:switcherator.c **** static unsigned int currentHue = 0;
  73:switcherator.c **** static unsigned int hueSpeed = 16;
  74:switcherator.c **** static unsigned int hueCount = 0;
  75:switcherator.c **** static unsigned char littleCount = 0;
  76:switcherator.c **** static unsigned int colorChangeSpeed = 10; // how many 1/10 seconds in each color change
  77:switcherator.c **** static unsigned int colorChangeCount = 0;
  78:switcherator.c **** static unsigned char currentColor = 0;
  79:switcherator.c **** #define Red OCR2B
  80:switcherator.c **** #define Green OCR0B
  81:switcherator.c **** #define Blue OCR0A
  82:switcherator.c **** static unsigned int red = 0;
  83:switcherator.c **** static unsigned int green = 0;
  84:switcherator.c **** static unsigned int blue = 0;
  85:switcherator.c **** static unsigned int bright = 16;
  86:switcherator.c **** static unsigned char oldBright = 16;
  87:switcherator.c **** static char switchBright[NUM_SWITCHES];
  88:switcherator.c **** static unsigned char pwmdir = 0;
  89:switcherator.c **** 
  90:switcherator.c **** 
  91:switcherator.c **** // programs and such kept in EEPROM
  92:switcherator.c **** // 1 byte day of week mask or 0 for everyday
  93:switcherator.c **** // 2 byte start time (seconds in day), 2 bytes duration (seconds), 1 byte additional program
  94:switcherator.c **** // If more than 4 switches are desired it will roll over to an additional program
  95:switcherator.c **** // DssddSSSSP
  96:switcherator.c **** // 0123456789   
  97:switcherator.c **** static unsigned char weeklyProgram[MAX_PROGRAM][10];
  98:switcherator.c **** 
  99:switcherator.c **** // input information
 100:switcherator.c **** // Pp - value of 255 (default) means nothing programmed
 101:switcherator.c **** // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
 102:switcherator.c **** // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
 103:switcherator.c **** // pin is abs(value/2)-the base - PINB3 = (22-16)/2  PINB3 (22-16)%2 = 0 - low (23-16)%2 = 1 - high
 104:switcherator.c **** // pLHsDDPw Pp int pin/port like sw, L%,H% (0,255 - digital), s - 0-127=switch, 128-255 = prog
 105:switcherator.c **** // dur in seconds, poll time in secs or  0 for continuous. w = which rgb (mask);)
 106:switcherator.c **** static unsigned char inputs[NUM_INPUTS][8];
 107:switcherator.c **** 
 108:switcherator.c **** // Times that the PROGRAMS will react to a switch (eg dusk to dawn)
 109:switcherator.c **** // [0]=start,[1]=stop,[2]=days
 110:switcherator.c **** static unsigned long timeLimits[NUM_LIMITS][3];
 111:switcherator.c **** 
 112:switcherator.c **** 
 113:switcherator.c **** // adjust the timer so it can be accurate
 114:switcherator.c **** static long tweakTimer = TIMER_TOTAL;
 115:switcherator.c **** 
 116:switcherator.c **** 
 117:switcherator.c **** 
 118:switcherator.c **** // send receive addresses
 119:switcherator.c **** static uint64_t rx_addr_p0, rx_addr_p1, rx_addr_p2, rx_addr_p3, rx_addr_p4, rx_addr_p5, tx_addr;
 120:switcherator.c **** 
 121:switcherator.c **** int main(void) {
 122:switcherator.c ****     receiveBuffer[0] = 0;
 123:switcherator.c ****     radioReceiveBuffer[0] = 0;
 124:switcherator.c ****     int x = 0;
 125:switcherator.c **** 
 126:switcherator.c ****     INDICATOR_DDR |= INDICATOR_PIN;
 127:switcherator.c ****     for (x = 0; x < 4; x++) {
 128:switcherator.c ****         INDICATOR_PORT |= INDICATOR_PIN;
 129:switcherator.c ****         _delay_ms(50);
 130:switcherator.c ****         INDICATOR_PORT &= ~(INDICATOR_PIN);
 131:switcherator.c ****         _delay_ms(100);
 132:switcherator.c ****     }
 133:switcherator.c ****     INDICATOR_PORT |= INDICATOR_PIN;
 134:switcherator.c **** 
 135:switcherator.c **** 
 136:switcherator.c ****     // set color changes to blank
 137:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 138:switcherator.c ****         colorChanges[x][0] = 0;
 139:switcherator.c ****         colorChanges[x][1] = 1;
 140:switcherator.c ****         colorChanges[x][2] = 0;
 141:switcherator.c ****     }
 142:switcherator.c **** 
 143:switcherator.c ****     // just initializing memory
 144:switcherator.c ****     globalYear = globalMonth = globalDay = globalHour = globalMinute = globalSecond = dow = 0;
 145:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 146:switcherator.c ****         switchStatus[x] = 0;
 147:switcherator.c ****         switchStuff[x] = 255;
 148:switcherator.c ****         switchBright[x] = 16;
 149:switcherator.c ****     }
 150:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 151:switcherator.c ****         inputs[x][0] = 255;
 152:switcherator.c ****     }
 153:switcherator.c ****     sei();
 154:switcherator.c **** 
 155:switcherator.c ****     // initialize programs
 156:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 157:switcherator.c ****         clearTheProgram(x);
 158:switcherator.c ****     }
 159:switcherator.c **** 
 160:switcherator.c **** 
 161:switcherator.c **** 
 162:switcherator.c ****     clockInit();
 163:switcherator.c ****     radioInit();
 164:switcherator.c ****     startRx();
 165:switcherator.c ****     // make sure general init is after radioinit
 166:switcherator.c ****     generalInit();
 167:switcherator.c ****     startClock();
 168:switcherator.c **** 
 169:switcherator.c **** 
 170:switcherator.c **** 
 171:switcherator.c ****     // radio related
 172:switcherator.c ****     int payloadLength = 0;
 173:switcherator.c **** 
 174:switcherator.c ****     
 175:switcherator.c **** 
 176:switcherator.c ****     while (1) {
 177:switcherator.c ****         // what to run every second
 178:switcherator.c ****         if (newSecond == 1) {
 179:switcherator.c ****             newSecond = 0;
 180:switcherator.c ****             timerCheck();
 181:switcherator.c ****             inputCheck();
 182:switcherator.c ****         }
 183:switcherator.c ****         // runs only if a switch changed
 184:switcherator.c ****         if (switchChanged == 1) {
 185:switcherator.c ****             switchChanged = 0;
 186:switcherator.c ****             switchOnOff();
 187:switcherator.c ****         }
 188:switcherator.c ****         if (runHue == 1) {
 189:switcherator.c ****             runHueFunction();
 190:switcherator.c ****         }
 191:switcherator.c ****         if (runColorChanges == 1) {
 192:switcherator.c ****             runColorFunction();
 193:switcherator.c ****         }
 194:switcherator.c ****         if (tenthFlag == 1) {
 195:switcherator.c ****             tenthFlag = 0;
 196:switcherator.c ****             inputTenthCheck();
 197:switcherator.c ****             if (failCondition > 0) {
 198:switcherator.c ****                 flashFail();
 199:switcherator.c ****             }
 200:switcherator.c ****             if (runColorChanges == 1) {
 201:switcherator.c ****                 runColorFunction();
 202:switcherator.c ****             }
 203:switcherator.c ****         }
 204:switcherator.c ****         if (newMinute == 1) {
 205:switcherator.c ****             newMinute = 0;
 206:switcherator.c ****             if (panicMyClockIsNotSet == 1) {
 207:switcherator.c ****                 generalStatus("gsq");
 208:switcherator.c ****             }
 209:switcherator.c ****             radioTest();
 210:switcherator.c ****         }
 211:switcherator.c ****         // check for radio instructions
 212:switcherator.c ****         payloadLength = dynReceive(radioReceiveBuffer);
 213:switcherator.c ****         if (payloadLength > 1) {
 214:switcherator.c ****             // wait so the receiver won't miss our response
 215:switcherator.c ****             _delay_ms(90);
 216:switcherator.c ****             checkCommand(radioReceiveBuffer);
 217:switcherator.c ****             
 218:switcherator.c ****             // clear the buffer
 219:switcherator.c ****             for (x = 0; x < 30; x++) {
 220:switcherator.c ****                 radioReceiveBuffer[x] = 0;
 221:switcherator.c ****                 receiveBuffer[x] = 0;
 222:switcherator.c ****             }
 223:switcherator.c ****         }
 224:switcherator.c ****     }
 225:switcherator.c **** }
 226:switcherator.c **** 
 227:switcherator.c **** /****************************************************************
 228:switcherator.c ****  *
 229:switcherator.c ****  *              All Things Command and Interface Related
 230:switcherator.c ****  *
 231:switcherator.c ****  ****************************************************************/
 232:switcherator.c **** 
 233:switcherator.c **** void checkCommand(char * commandReceived) {
 234:switcherator.c ****     if (commandReceived[0] > 0x60)
 235:switcherator.c ****         commandReceived[0] -= 0x20;
 236:switcherator.c ****     if (commandReceived[1] > 0x60)
 237:switcherator.c ****         commandReceived[1] -= 0x20;
 238:switcherator.c ****     int switchme = commandReceived[0];
 239:switcherator.c ****     switchme <<= 8;
 240:switcherator.c ****     switchme |= commandReceived[1];
 241:switcherator.c ****     switch (switchme) {
 242:switcherator.c ****         case 0x5449: //TI
 243:switcherator.c ****             setClock(commandReceived);
 244:switcherator.c ****             break;
 245:switcherator.c ****         case 0x4453: //DS
 246:switcherator.c ****             setDaylightSavings(commandReceived);
 247:switcherator.c ****             break;
 248:switcherator.c ****         case 0x544C: //TL
 249:switcherator.c ****             setTimeLimits(commandReceived);
 250:switcherator.c ****             break;
 251:switcherator.c ****         case 0x4E53: //NS
 252:switcherator.c ****             setNewSwitch(commandReceived);
 253:switcherator.c ****             break;
 254:switcherator.c ****         case 0x5343: //SC
 255:switcherator.c ****             switchClear(commandReceived);
 256:switcherator.c ****             break;
 257:switcherator.c ****         case 0x5344: //SD
 258:switcherator.c ****             switchDisplay(commandReceived);
 259:switcherator.c ****             break;
 260:switcherator.c ****         case 0x5053: //PS
 261:switcherator.c ****             pwmSetup(commandReceived);
 262:switcherator.c ****             break;
 263:switcherator.c ****         case 0x4348: //CH
 264:switcherator.c ****             cycleHue(commandReceived);
 265:switcherator.c ****             break;
 266:switcherator.c ****         case 0x4864: //HS
 267:switcherator.c ****             setHueSpeed(commandReceived);
 268:switcherator.c ****             break;
 269:switcherator.c ****         case 0x5056: //PV
 270:switcherator.c ****             pwmValueSet(commandReceived);
 271:switcherator.c ****             break;
 272:switcherator.c ****         case 0x4E50: //NP
 273:switcherator.c ****             newProgram(commandReceived);
 274:switcherator.c ****             break;
 275:switcherator.c ****         case 0x4350: //CP
 276:switcherator.c ****             clearProgram(commandReceived);
 277:switcherator.c ****             break;
 278:switcherator.c ****         case 0x5041: //PA
 279:switcherator.c ****             programAddSwitch(commandReceived);
 280:switcherator.c ****             break;
 281:switcherator.c ****         case 0x5044: //PD
 282:switcherator.c ****             programSetDays(commandReceived);
 283:switcherator.c ****             break;
 284:switcherator.c ****         case 0x5054: //PT
 285:switcherator.c ****             programSetTime(commandReceived);
 286:switcherator.c ****             break;
 287:switcherator.c ****         case 0x5049: //PI
 288:switcherator.c ****             programDisplay(commandReceived);
 289:switcherator.c ****             break;
 290:switcherator.c ****         case 0x5353: //SS
 291:switcherator.c ****             startSwitch(commandReceived);
 292:switcherator.c ****             break;
 293:switcherator.c ****         case 0x5350: //SP
 294:switcherator.c ****             startProgram(commandReceived);
 295:switcherator.c ****             break;
 296:switcherator.c ****         case 0x5341: //SA
 297:switcherator.c ****             saveToEEPROM();
 298:switcherator.c ****             break;
 299:switcherator.c ****         case 0x434C: //CL
 300:switcherator.c ****             clearToEEPROM();
 301:switcherator.c ****             break;
 302:switcherator.c ****         case 0x5244: //RD
 303:switcherator.c ****             radioDisplayAddress(commandReceived);
 304:switcherator.c ****             break;
 305:switcherator.c ****         case 0x5243: //RC
 306:switcherator.c ****             radioChangeAddress(commandReceived);
 307:switcherator.c ****             break;
 308:switcherator.c ****         case 0x4149: //AI
 309:switcherator.c ****             setAnalogInput(commandReceived);
 310:switcherator.c ****             break;
 311:switcherator.c ****         case 0x4449: //DI
 312:switcherator.c ****             setDigitalInput(commandReceived);
 313:switcherator.c ****             break;
 314:switcherator.c ****         case 0x4349: //CI
 315:switcherator.c ****             clearInput(commandReceived);
 316:switcherator.c ****             break;
 317:switcherator.c ****         case 0x4354: //CT
 318:switcherator.c ****             clockTweak(commandReceived);
 319:switcherator.c ****             break;
 320:switcherator.c ****         case 0x5057: //PW
 321:switcherator.c ****             pwmSummary();
 322:switcherator.c ****             break;
 323:switcherator.c ****         case 0x4845: //HE
 324:switcherator.c ****             drawInterface();
 325:switcherator.c ****             break;
 326:switcherator.c ****         case 0x4753: //GS
 327:switcherator.c ****             generalStatus(commandReceived);
 328:switcherator.c ****             break;
 329:switcherator.c ****         case 0x5248: //RH
 330:switcherator.c ****             drawInterface();
 331:switcherator.c ****             break;
 332:switcherator.c ****         case 0x4343: //CC
 333:switcherator.c ****             colorChangeSet(commandReceived);
 334:switcherator.c ****             break;
 335:switcherator.c ****         case 0x5342: //sb
 336:switcherator.c ****             switchBrightness(commandReceived);
 337:switcherator.c ****             break;
 338:switcherator.c ****         case 0x4253: //bs
 339:switcherator.c ****             brightnessSet(commandReceived);
 340:switcherator.c ****             break;
 341:switcherator.c ****         case 0x4749: //GI
 342:switcherator.c ****             generalInformation();
 343:switcherator.c ****             break;
 344:switcherator.c ****         case 0x5050: //PP
 345:switcherator.c ****             programsProgrammed();
 346:switcherator.c ****             break;
 347:switcherator.c ****         case 0x5357: //SW
 348:switcherator.c ****             switchesProgrammed();
 349:switcherator.c ****             break;
 350:switcherator.c ****         case 0x4950: //IP
 351:switcherator.c ****             inputsProgrammed();
 352:switcherator.c ****             break;
 353:switcherator.c ****         case 0x534F: //SO
 354:switcherator.c ****             switchesOn();
 355:switcherator.c ****             break;
 356:switcherator.c ****         default:
 357:switcherator.c ****             break;
 358:switcherator.c ****     }
 359:switcherator.c **** }
 360:switcherator.c **** 
 361:switcherator.c **** void drawInterface(void) {
  14               		.loc 1 361 0
  15               	/* prologue: function */
  16               	/* frame size = 0 */
  17               	/* stack size = 0 */
  18               	.L__stack_usage = 0
  19 0000 0895      		ret
  20               	.LFE9:
  22               	.global	getSwitchNumber
  24               	getSwitchNumber:
  25               	.LFB12:
 362:switcherator.c **** #ifdef help
 363:switcherator.c ****     sendMessage("TI:MMDDYYYYHHMMSS");
 364:switcherator.c ****     sendMessage("DS:MMDD MMDD");
 365:switcherator.c ****     sendMessage("TL:##HHMMHHMMdddddd");
 366:switcherator.c ****     sendMessage("NS:S#PpD,SC:S# SD NP:HHMMDur.");
 367:switcherator.c ****     sendMessage("CP:P# PA:P#S# PD:P#SMTWTFS");
 368:switcherator.c ****     sendMessage("PT:P#HHMMDur. PI:P#");
 369:switcherator.c ****     sendMessage("PS:P#S#DH CH:P#vvvv ");
 370:switcherator.c ****     sendMessage("PV:P#,vvv,vvv,vvv PW");
 371:switcherator.c ****     sendMessage("CC:##,vvv,vvv,vvv PW (sum)");
 372:switcherator.c ****     sendMessage("BS:16 SB S#16 HS:16");
 373:switcherator.c ****     sendMessage("SS S#Durat. SP P#Durat.");
 374:switcherator.c ****     sendMessage("SE nnnnnn SA CL CTvvv");
 375:switcherator.c ****     sendMessage("RD:N RC:N 0xnnnnnnnnnn");
 376:switcherator.c ****     sendMessage("AI:##PpLLLHHH?##DuraPO");
 377:switcherator.c ****     sendMessage("DI:##Ppx?##DuraPO  CI xx");
 378:switcherator.c ****     sendMessage("HE RH GS");
 379:switcherator.c **** #endif
 380:switcherator.c **** }
 381:switcherator.c **** 
 382:switcherator.c **** void fail(int failCode) {
 383:switcherator.c ****     statusMsg[0] = 0;
 384:switcherator.c ****     strcat(statusMsg, "fail:");
 385:switcherator.c ****     returnHex(failCode, tempLongString);
 386:switcherator.c ****     strcat(statusMsg, tempLongString);
 387:switcherator.c ****     sendMessage(statusMsg);
 388:switcherator.c **** }
 389:switcherator.c **** 
 390:switcherator.c **** void ok(void) {
 391:switcherator.c ****     sendMessage("ok");
 392:switcherator.c **** }
 393:switcherator.c **** 
 394:switcherator.c **** 
 395:switcherator.c **** // Helper function to get the switch number from char 3 and 4 of an array
 396:switcherator.c **** 
 397:switcherator.c **** int getSwitchNumber(char * commandReceived) {
  26               		.loc 1 397 0
  27               	.LVL0:
  28               	/* prologue: function */
  29               	/* frame size = 0 */
  30               	/* stack size = 0 */
  31               	.L__stack_usage = 0
 398:switcherator.c ****     int switchNumber = 0;
 399:switcherator.c ****     // get switch number
 400:switcherator.c ****     tempIntString[0] = commandReceived[3];
  32               		.loc 1 400 0
  33 0002 FC01      		movw r30,r24
  34 0004 2381      		ldd r18,Z+3
  35 0006 2093 0000 		sts tempIntString,r18
 401:switcherator.c ****     tempIntString[1] = commandReceived[4];
  36               		.loc 1 401 0
  37 000a 8481      		ldd r24,Z+4
  38               	.LVL1:
  39 000c 8093 0000 		sts tempIntString+1,r24
 402:switcherator.c ****     switchNumber = atoi(tempIntString);
  40               		.loc 1 402 0
  41 0010 80E0      		ldi r24,lo8(tempIntString)
  42 0012 90E0      		ldi r25,hi8(tempIntString)
  43 0014 0C94 0000 		jmp atoi
  44               	.LVL2:
  45               	.LFE12:
  47               	.global	getPort
  49               	getPort:
  50               	.LFB18:
 403:switcherator.c ****     return switchNumber;
 404:switcherator.c **** }
 405:switcherator.c **** 
 406:switcherator.c **** 
 407:switcherator.c **** /****************************************************************
 408:switcherator.c ****  *
 409:switcherator.c ****  *              All Things Switch Related
 410:switcherator.c ****  *
 411:switcherator.c ****  ****************************************************************/
 412:switcherator.c **** // Setup a new switch
 413:switcherator.c **** // NS:S#PpD
 414:switcherator.c **** // 01234567
 415:switcherator.c **** 
 416:switcherator.c **** void setNewSwitch(char * commandReceived) {
 417:switcherator.c ****     int switchNumber = 0;
 418:switcherator.c ****     char port = 0;
 419:switcherator.c ****     unsigned char pinMultiplied = 0;
 420:switcherator.c ****     unsigned char pinSubtractee = 0;
 421:switcherator.c ****     volatile unsigned char *realPort = 0;
 422:switcherator.c ****     volatile unsigned char *realDDR = 0;
 423:switcherator.c ****     char pin = 0;
 424:switcherator.c ****     char originalPin = 0;
 425:switcherator.c ****     char direction = 0;
 426:switcherator.c ****     tempIntString[0] = '0';
 427:switcherator.c ****     tempIntString[1] = commandReceived[6];
 428:switcherator.c ****     pin = atoi(tempIntString);
 429:switcherator.c ****     originalPin = pin;
 430:switcherator.c ****     tempIntString[1] = commandReceived[7];
 431:switcherator.c ****     direction = atoi(tempIntString);
 432:switcherator.c ****     port = commandReceived[5];
 433:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 434:switcherator.c ****     // make sure it is off before doing a new one.
 435:switcherator.c ****     clearTheSwitch(switchNumber);
 436:switcherator.c ****     // get the pin string ready for below
 437:switcherator.c ****     if (port == 'B' || port == 'b') {
 438:switcherator.c ****         realPort = &PORTB;
 439:switcherator.c ****         realDDR = &DDRB;
 440:switcherator.c ****         pinSubtractee = 16;
 441:switcherator.c **** #ifdef PORTA
 442:switcherator.c ****     } else if (port == 'A' || port == 'a') {
 443:switcherator.c ****         realPort = &PORTA;
 444:switcherator.c ****         realDDR = &DDRA;
 445:switcherator.c ****         pinSubtractee = 0;
 446:switcherator.c **** #endif
 447:switcherator.c **** #ifdef PORTC
 448:switcherator.c ****     } else if (port == 'C' || port == 'c') {
 449:switcherator.c ****         realPort = &PORTC;
 450:switcherator.c ****         realDDR = &DDRC;
 451:switcherator.c ****         pinSubtractee = 32;
 452:switcherator.c **** #endif
 453:switcherator.c **** #ifdef PORTD
 454:switcherator.c ****     } else if (port == 'D' || port == 'd') {
 455:switcherator.c ****         realPort = &PORTD;
 456:switcherator.c ****         realDDR = &DDRD;
 457:switcherator.c ****         pinSubtractee = 48;
 458:switcherator.c **** #endif
 459:switcherator.c **** #ifdef PORTE
 460:switcherator.c ****     } else if (port == 'E' || port == 'e') {
 461:switcherator.c ****         realPort = &PORTE;
 462:switcherator.c ****         realDDR = &DDRE;
 463:switcherator.c ****         pinSubtractee = 64;
 464:switcherator.c **** #endif
 465:switcherator.c **** #ifdef PORTF
 466:switcherator.c ****     } else if (port == 'F' || port == 'f') {
 467:switcherator.c ****         realPort = &PORTF;
 468:switcherator.c ****         realDDR = &DDRF;
 469:switcherator.c ****         pinSubtractee = 80;
 470:switcherator.c **** #endif
 471:switcherator.c **** #ifdef PORTG
 472:switcherator.c ****     } else if (port == 'G' || port == 'g') {
 473:switcherator.c ****         realPort = &PORTG;
 474:switcherator.c ****         realDDR = &DDRG;
 475:switcherator.c ****         pinSubtractee = 96;
 476:switcherator.c **** #endif
 477:switcherator.c **** #ifdef PORTH
 478:switcherator.c ****     } else if (port == 'H' || port == 'h') {
 479:switcherator.c ****         realPort = &PORTH;
 480:switcherator.c ****         realDDR = &DDRH;
 481:switcherator.c ****         pinSubtractee = 112;
 482:switcherator.c **** #endif
 483:switcherator.c **** #ifdef PORTI
 484:switcherator.c ****     } else if (port == 'I' || port == 'i') {
 485:switcherator.c ****         realPort = &PORTI;
 486:switcherator.c ****         realDDR = &DDRI;
 487:switcherator.c ****         pinSubtractee = 128;
 488:switcherator.c **** #endif
 489:switcherator.c **** 
 490:switcherator.c ****     }
 491:switcherator.c **** 
 492:switcherator.c **** 
 493:switcherator.c ****     if (realPort == 0) {
 494:switcherator.c ****         fail(2);
 495:switcherator.c ****     } else if ((switchNumber >= NUM_SWITCHES) ||
 496:switcherator.c ****             ((switchNumber == 0) && (commandReceived[3] != '0') && (commandReceived[4] != 0))) {
 497:switcherator.c ****         fail(1);
 498:switcherator.c ****     } else if ((pin > 7) || ((pin == 0) && (commandReceived[6] != '0'))) {
 499:switcherator.c ****         fail(4);
 500:switcherator.c ****     } else {
 501:switcherator.c ****         // set DDR out
 502:switcherator.c ****         *realDDR |= (1 << originalPin);
 503:switcherator.c ****         // double the pin and add 1 if it is high
 504:switcherator.c ****         pinMultiplied = pin * 2;
 505:switcherator.c ****         // turn switch off
 506:switcherator.c ****         pin = pinMultiplied + pinSubtractee;
 507:switcherator.c ****         switchStuff[switchNumber] = pin;
 508:switcherator.c **** 
 509:switcherator.c ****         if (direction == 0) {
 510:switcherator.c ****             // 0 = low is on  1 = high is on
 511:switcherator.c ****             *realPort |= (1 << originalPin);
 512:switcherator.c ****         } else {
 513:switcherator.c ****             *realPort &= ~(1 << originalPin);
 514:switcherator.c ****             switchStuff[switchNumber]++;
 515:switcherator.c ****         }
 516:switcherator.c ****         ok();
 517:switcherator.c ****     }
 518:switcherator.c **** }
 519:switcherator.c **** 
 520:switcherator.c **** // get rid of a switch and turn it off
 521:switcherator.c **** // SC:S#
 522:switcherator.c **** // 01234
 523:switcherator.c **** 
 524:switcherator.c **** void switchClear(char * commandReceived) {
 525:switcherator.c ****     int switchNumber = 0;
 526:switcherator.c ****     // get switch number
 527:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 528:switcherator.c ****     clearTheSwitch(switchNumber);
 529:switcherator.c ****     ok();
 530:switcherator.c **** }
 531:switcherator.c **** 
 532:switcherator.c **** // actual turning switch off (called with new switch as well)
 533:switcherator.c **** 
 534:switcherator.c **** void clearTheSwitch(int switchNumber) {
 535:switcherator.c ****     char port[] = {0};
 536:switcherator.c ****     char pin[] = {0};
 537:switcherator.c ****     char direction[] = {0};
 538:switcherator.c ****     volatile unsigned char *thisPort = 0;
 539:switcherator.c ****     volatile unsigned char *thisDDR = 0;
 540:switcherator.c ****     int realPin = 0;
 541:switcherator.c ****     // Figure out if it is pwm
 542:switcherator.c ****     if (switchStuff[switchNumber] >= 200 && switchStuff[switchNumber] <= 220) {
 543:switcherator.c ****         // if it is something else
 544:switcherator.c ****         pwmClear(switchNumber);
 545:switcherator.c ****         switchStuff[switchNumber] = 255;
 546:switcherator.c ****         return;
 547:switcherator.c ****     }
 548:switcherator.c ****     getPort(switchNumber, port, pin, direction);
 549:switcherator.c ****     if (port[0] == 'B') {
 550:switcherator.c ****         thisPort = &PORTB;
 551:switcherator.c ****         thisDDR = &DDRB;
 552:switcherator.c **** #ifdef PORTA
 553:switcherator.c ****     } else if (port[0] == 'A') {
 554:switcherator.c ****         thisPort = &PORTA;
 555:switcherator.c ****         thisDDR = &DDRA;
 556:switcherator.c **** #endif        
 557:switcherator.c **** #ifdef PORTC
 558:switcherator.c ****     } else if (port[0] == 'C') {
 559:switcherator.c ****         thisPort = &PORTC;
 560:switcherator.c ****         thisDDR = &DDRC;
 561:switcherator.c **** #endif        
 562:switcherator.c **** #ifdef PORTD
 563:switcherator.c ****     } else if (port[0] == 'D') {
 564:switcherator.c ****         thisPort = &PORTD;
 565:switcherator.c ****         thisDDR = &DDRD;
 566:switcherator.c **** #endif        
 567:switcherator.c **** #ifdef PORTE
 568:switcherator.c ****     } else if (port[0] == 'E') {
 569:switcherator.c ****         thisPort = &PORTE;
 570:switcherator.c ****         thisDDR = &DDRE;
 571:switcherator.c **** #endif        
 572:switcherator.c **** #ifdef PORTF
 573:switcherator.c ****     } else if (port[0] == 'F') {
 574:switcherator.c ****         thisPort = &PORTF;
 575:switcherator.c ****         thisDDR = &DDRF;
 576:switcherator.c **** #endif        
 577:switcherator.c **** #ifdef PORTG
 578:switcherator.c ****     } else if (port[0] == 'G') {
 579:switcherator.c ****         thisPort = &PORTG;
 580:switcherator.c ****         thisDDR = &DDRG;
 581:switcherator.c **** #endif        
 582:switcherator.c **** #ifdef PORTH
 583:switcherator.c ****     } else if (port[0] == 'H') {
 584:switcherator.c ****         thisPort = &PORTH;
 585:switcherator.c ****         thisDDR = &DDRH;
 586:switcherator.c **** #endif        
 587:switcherator.c **** #ifdef PORTI
 588:switcherator.c ****     } else if (port[0] == 'I') {
 589:switcherator.c ****         thisPort = &PORTI;
 590:switcherator.c ****         thisDDR = &DDRI;
 591:switcherator.c **** #endif        
 592:switcherator.c ****     }
 593:switcherator.c ****     realPin = pin[0];
 594:switcherator.c ****     *thisDDR &= ~(1 << realPin);
 595:switcherator.c ****     *thisPort &= ~(1 << realPin);
 596:switcherator.c ****     switchStuff[switchNumber] = 255;
 597:switcherator.c **** }
 598:switcherator.c **** 
 599:switcherator.c **** // show a summary of the switches
 600:switcherator.c **** 
 601:switcherator.c **** void switchDisplay(char * commandReceived) {
 602:switcherator.c ****     char port[] = {0};
 603:switcherator.c ****     char pin[] = {0};
 604:switcherator.c ****     char direction[] = {0};
 605:switcherator.c ****     int switchNumber = 0;
 606:switcherator.c ****     int realPin = 0;
 607:switcherator.c ****     char statusMsg[32];
 608:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 609:switcherator.c ****     statusMsg[0] = 0;
 610:switcherator.c ****     // see if this is a pwm switch
 611:switcherator.c ****     if (switchStuff[switchNumber] >= 200 && switchStuff[switchNumber] <= 220) {
 612:switcherator.c ****         // yes pwm
 613:switcherator.c ****         if (switchStuff[switchNumber] % 2 == 0) {
 614:switcherator.c ****             if (switchStuff[switchNumber] == 202) {
 615:switcherator.c ****                 strcat(statusMsg, "CoC");
 616:switcherator.c ****             } else if (switchStuff[switchNumber] == 212) {
 617:switcherator.c ****                 strcat(statusMsg, "Brt");
 618:switcherator.c ****             } else {
 619:switcherator.c ****                 strcat(statusMsg, "Fix");
 620:switcherator.c ****             }
 621:switcherator.c ****         } else {
 622:switcherator.c ****             strcat(statusMsg, "Hue");
 623:switcherator.c ****         }
 624:switcherator.c ****     } else {
 625:switcherator.c ****         getPort(switchNumber, port, pin, direction);
 626:switcherator.c ****         tempIntString[0] = port[0];
 627:switcherator.c ****         tempIntString[1] = 0;
 628:switcherator.c ****         strcat(statusMsg, tempIntString);
 629:switcherator.c ****         realPin = pin[0];
 630:switcherator.c ****         itoa(realPin, tempIntString, 10);
 631:switcherator.c ****         strcat(statusMsg, tempIntString);
 632:switcherator.c ****         if (direction[0] == 0) {
 633:switcherator.c ****             strcat(statusMsg, "L");
 634:switcherator.c ****         } else {
 635:switcherator.c ****             strcat(statusMsg, "H");
 636:switcherator.c ****         }
 637:switcherator.c ****     }
 638:switcherator.c ****     sendMessage(statusMsg);
 639:switcherator.c **** 
 640:switcherator.c **** }
 641:switcherator.c **** 
 642:switcherator.c **** // takes in a switch number and time and turns on the switch
 643:switcherator.c **** // SS S#Durat.
 644:switcherator.c **** // 01234567890
 645:switcherator.c **** 
 646:switcherator.c **** void startSwitch(char * commandReceived) {
 647:switcherator.c ****     unsigned long duration;
 648:switcherator.c ****     int switchNumber = 0;
 649:switcherator.c ****     // get switch number
 650:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 651:switcherator.c ****     if ((switchNumber >= NUM_SWITCHES) || (switchStuff[switchNumber] == 255)) {
 652:switcherator.c ****         fail(1);
 653:switcherator.c ****         return;
 654:switcherator.c ****     }
 655:switcherator.c ****     // get duration
 656:switcherator.c ****     tempHugeString[0] = commandReceived[5];
 657:switcherator.c ****     tempHugeString[1] = commandReceived[6];
 658:switcherator.c ****     tempHugeString[2] = commandReceived[7];
 659:switcherator.c ****     tempHugeString[3] = commandReceived[8];
 660:switcherator.c ****     tempHugeString[4] = commandReceived[9];
 661:switcherator.c ****     tempHugeString[5] = commandReceived[10];
 662:switcherator.c ****     duration = atol(tempHugeString);
 663:switcherator.c ****     if (duration == 0) {
 664:switcherator.c ****         fail(5);
 665:switcherator.c ****         return;
 666:switcherator.c ****     }
 667:switcherator.c ****     // only update the time if it is longer than what the switch is already turned on to
 668:switcherator.c ****     if ((weeklySeconds + duration) > switchStatus[switchNumber])
 669:switcherator.c ****         switchStatus[switchNumber] = (weeklySeconds + duration);
 670:switcherator.c **** 
 671:switcherator.c ****     // see if it is PWM
 672:switcherator.c ****     if (switchStuff[switchNumber] >= 200 && switchStuff[switchNumber] <= 220) {
 673:switcherator.c ****         // k it is PWM.  See if it is hue
 674:switcherator.c ****         if (switchStuff[switchNumber] == 200) {
 675:switcherator.c ****             // even number so values, not hue
 676:switcherator.c ****             red = pwmValues[0];
 677:switcherator.c ****             green = pwmValues[1];
 678:switcherator.c ****             blue = pwmValues[2];
 679:switcherator.c ****             red = red * bright / 16;
 680:switcherator.c ****             green = green * bright / 16;
 681:switcherator.c ****             blue = blue * bright / 16;
 682:switcherator.c ****             Red = red;
 683:switcherator.c ****             Green = green;
 684:switcherator.c ****             Blue = blue;
 685:switcherator.c ****         } else if (switchStuff[switchNumber] == 202) {
 686:switcherator.c ****             runColorChanges = 1;
 687:switcherator.c ****         } else if (switchStuff[switchNumber] == 212) {
 688:switcherator.c ****             bright = switchBright[switchNumber];
 689:switcherator.c ****         } else {
 690:switcherator.c ****             runHue = 1;
 691:switcherator.c ****         }
 692:switcherator.c **** 
 693:switcherator.c ****     } else {
 694:switcherator.c **** 
 695:switcherator.c ****         // get the port and turn it on
 696:switcherator.c ****         char port[1];
 697:switcherator.c ****         char pin[1];
 698:switcherator.c ****         int realPin = 0;
 699:switcherator.c ****         char direction[1];
 700:switcherator.c ****         volatile unsigned char *thisPort = 0;
 701:switcherator.c ****         getPort(switchNumber, port, pin, direction);
 702:switcherator.c ****         // yeah pointers and casts and whatevers. this fixes it
 703:switcherator.c ****         realPin = pin[0];
 704:switcherator.c ****         if (port[0] == 'B')
 705:switcherator.c ****             thisPort = &PORTB;
 706:switcherator.c **** #ifdef PORTA
 707:switcherator.c ****         else if (port[0] == 'A')
 708:switcherator.c ****             thisPort = &PORTA;
 709:switcherator.c **** #endif
 710:switcherator.c **** #ifdef PORTC
 711:switcherator.c ****         else if (port[0] == 'C')
 712:switcherator.c ****             thisPort = &PORTC;
 713:switcherator.c **** #endif
 714:switcherator.c **** #ifdef PORTD
 715:switcherator.c ****         else if (port[0] == 'D')
 716:switcherator.c ****             thisPort = &PORTD;
 717:switcherator.c **** #endif
 718:switcherator.c **** #ifdef PORTE
 719:switcherator.c ****         else if (port[0] == 'E')
 720:switcherator.c ****             thisPort = &PORTE;
 721:switcherator.c **** #endif
 722:switcherator.c **** #ifdef PORTF
 723:switcherator.c ****         else if (port[0] == 'F')
 724:switcherator.c ****             thisPort = &PORTF;
 725:switcherator.c **** #endif
 726:switcherator.c **** #ifdef PORTG
 727:switcherator.c ****         else if (port[0] == 'G')
 728:switcherator.c ****             thisPort = &PORTG;
 729:switcherator.c **** #endif
 730:switcherator.c **** #ifdef PORTH
 731:switcherator.c ****         else if (port[0] == 'H')
 732:switcherator.c ****             thisPort = &PORTH;
 733:switcherator.c **** #endif
 734:switcherator.c **** #ifdef PORTI
 735:switcherator.c ****         else if (port[0] == 'I')
 736:switcherator.c ****             thisPort = &PORTI;
 737:switcherator.c **** #endif
 738:switcherator.c **** 
 739:switcherator.c ****         // turn it on based on what direction
 740:switcherator.c ****         if (direction[0] == 0) {
 741:switcherator.c ****             *thisPort &= ~(1 << realPin);
 742:switcherator.c ****         } else {
 743:switcherator.c ****             *thisPort |= (1 << realPin);
 744:switcherator.c ****         }
 745:switcherator.c ****     }
 746:switcherator.c ****     ok();
 747:switcherator.c **** }
 748:switcherator.c **** // Takes in a switch number and returns the port (as a letter), pin, direction 0,1, and actual PORT
 749:switcherator.c **** 
 750:switcherator.c **** void getPort(int switchNumber, char * port, char * pin, char * direction) {
  51               		.loc 1 750 0
  52               	.LVL3:
  53               	/* prologue: function */
  54               	/* frame size = 0 */
  55               	/* stack size = 0 */
  56               	.L__stack_usage = 0
  57 0018 FB01      		movw r30,r22
 751:switcherator.c ****     char switchInfo = switchStuff[switchNumber];
  58               		.loc 1 751 0
  59 001a 8050      		subi r24,lo8(-(switchStuff))
  60 001c 9040      		sbci r25,hi8(-(switchStuff))
  61               	.LVL4:
  62 001e DC01      		movw r26,r24
  63 0020 8C91      		ld r24,X
  64               	.LVL5:
 752:switcherator.c ****     if ((switchInfo >= 16 && switchInfo < 32)) {
  65               		.loc 1 752 0
  66 0022 982F      		mov r25,r24
  67 0024 9051      		subi r25,lo8(-(-16))
  68 0026 9031      		cpi r25,lo8(16)
  69 0028 00F4      		brsh .L4
 753:switcherator.c ****         port[0] = 'B';
  70               		.loc 1 753 0
  71 002a 82E4      		ldi r24,lo8(66)
  72               	.LVL6:
  73 002c 8083      		st Z,r24
  74               	.LVL7:
  75 002e 00C0      		rjmp .L5
  76               	.LVL8:
  77               	.L4:
 754:switcherator.c ****         switchInfo -= 16;
 755:switcherator.c ****     } else if (switchInfo < 16) {
  78               		.loc 1 755 0
  79 0030 8031      		cpi r24,lo8(16)
  80 0032 00F4      		brsh .L6
 756:switcherator.c ****         port[0] = 'A';
  81               		.loc 1 756 0
  82 0034 91E4      		ldi r25,lo8(65)
  83 0036 9083      		st Z,r25
  84 0038 982F      		mov r25,r24
  85 003a 00C0      		rjmp .L5
  86               	.L6:
 757:switcherator.c ****         switchInfo -= 0;
 758:switcherator.c ****     } else if (switchInfo < 48) {
  87               		.loc 1 758 0
  88 003c 8033      		cpi r24,lo8(48)
  89 003e 00F4      		brsh .L7
 759:switcherator.c ****         port[0] = 'C';
  90               		.loc 1 759 0
  91 0040 93E4      		ldi r25,lo8(67)
  92 0042 9083      		st Z,r25
 760:switcherator.c ****         switchInfo -= 32;
  93               		.loc 1 760 0
  94 0044 982F      		mov r25,r24
  95 0046 9052      		subi r25,lo8(-(-32))
  96               	.LVL9:
  97 0048 00C0      		rjmp .L5
  98               	.LVL10:
  99               	.L7:
 761:switcherator.c ****     } else if (switchInfo < 64) {
 100               		.loc 1 761 0
 101 004a 8034      		cpi r24,lo8(64)
 102 004c 00F4      		brsh .L8
 762:switcherator.c ****         port[0] = 'D';
 103               		.loc 1 762 0
 104 004e 94E4      		ldi r25,lo8(68)
 105 0050 9083      		st Z,r25
 763:switcherator.c ****         switchInfo -= 48;
 106               		.loc 1 763 0
 107 0052 982F      		mov r25,r24
 108 0054 9053      		subi r25,lo8(-(-48))
 109               	.LVL11:
 110 0056 00C0      		rjmp .L5
 111               	.LVL12:
 112               	.L8:
 764:switcherator.c ****     } else if (switchInfo < 80) {
 113               		.loc 1 764 0
 114 0058 8035      		cpi r24,lo8(80)
 115 005a 00F4      		brsh .L9
 765:switcherator.c ****         port[0] = 'E';
 116               		.loc 1 765 0
 117 005c 95E4      		ldi r25,lo8(69)
 118 005e 9083      		st Z,r25
 766:switcherator.c ****         switchInfo -= 64;
 119               		.loc 1 766 0
 120 0060 982F      		mov r25,r24
 121 0062 9054      		subi r25,lo8(-(-64))
 122               	.LVL13:
 123 0064 00C0      		rjmp .L5
 124               	.LVL14:
 125               	.L9:
 767:switcherator.c ****     } else if (switchInfo < 96) {
 126               		.loc 1 767 0
 127 0066 8036      		cpi r24,lo8(96)
 128 0068 00F4      		brsh .L10
 768:switcherator.c ****         port[0] = 'F';
 129               		.loc 1 768 0
 130 006a 96E4      		ldi r25,lo8(70)
 131 006c 9083      		st Z,r25
 769:switcherator.c ****         switchInfo -= 80;
 132               		.loc 1 769 0
 133 006e 982F      		mov r25,r24
 134 0070 9055      		subi r25,lo8(-(-80))
 135               	.LVL15:
 136 0072 00C0      		rjmp .L5
 137               	.LVL16:
 138               	.L10:
 770:switcherator.c ****     } else if (switchInfo < 112) {
 139               		.loc 1 770 0
 140 0074 8037      		cpi r24,lo8(112)
 141 0076 00F4      		brsh .L11
 771:switcherator.c ****         port[0] = 'G';
 142               		.loc 1 771 0
 143 0078 97E4      		ldi r25,lo8(71)
 144 007a 9083      		st Z,r25
 772:switcherator.c ****         switchInfo -= 96;
 145               		.loc 1 772 0
 146 007c 982F      		mov r25,r24
 147 007e 9056      		subi r25,lo8(-(-96))
 148               	.LVL17:
 149 0080 00C0      		rjmp .L5
 150               	.LVL18:
 151               	.L11:
 773:switcherator.c ****     } else if (switchInfo < 128) {
 152               		.loc 1 773 0
 153 0082 87FD      		sbrc r24,7
 154 0084 00C0      		rjmp .L12
 774:switcherator.c ****         port[0] = 'H';
 155               		.loc 1 774 0
 156 0086 98E4      		ldi r25,lo8(72)
 157 0088 9083      		st Z,r25
 775:switcherator.c ****         switchInfo -= 112;
 158               		.loc 1 775 0
 159 008a 982F      		mov r25,r24
 160 008c 9057      		subi r25,lo8(-(-112))
 161               	.LVL19:
 162 008e 00C0      		rjmp .L5
 163               	.LVL20:
 164               	.L12:
 776:switcherator.c ****     } else if (switchInfo < 144) {
 165               		.loc 1 776 0
 166 0090 8039      		cpi r24,lo8(-112)
 167 0092 00F4      		brsh .L13
 777:switcherator.c ****         port[0] = 'I';
 168               		.loc 1 777 0
 169 0094 99E4      		ldi r25,lo8(73)
 170 0096 9083      		st Z,r25
 778:switcherator.c ****         switchInfo -= 128;
 171               		.loc 1 778 0
 172 0098 982F      		mov r25,r24
 173 009a 9058      		subi r25,lo8(-(-128))
 174               	.LVL21:
 175 009c 00C0      		rjmp .L5
 176               	.LVL22:
 177               	.L13:
 779:switcherator.c ****     } else {
 780:switcherator.c ****         port[0] = '?';
 178               		.loc 1 780 0
 179 009e 8FE3      		ldi r24,lo8(63)
 180               	.LVL23:
 181 00a0 8083      		st Z,r24
 781:switcherator.c ****         pin[0] = 0;
 182               		.loc 1 781 0
 183 00a2 FA01      		movw r30,r20
 184 00a4 1082      		st Z,__zero_reg__
 782:switcherator.c ****         direction[0] = 0;
 185               		.loc 1 782 0
 186 00a6 D901      		movw r26,r18
 187               	.LVL24:
 188 00a8 1C92      		st X,__zero_reg__
 783:switcherator.c ****         return;
 189               		.loc 1 783 0
 190 00aa 0895      		ret
 191               	.LVL25:
 192               	.L5:
 784:switcherator.c ****     }
 785:switcherator.c ****     pin[0] = switchInfo / 2;
 193               		.loc 1 785 0
 194 00ac 892F      		mov r24,r25
 195 00ae 8695      		lsr r24
 196 00b0 FA01      		movw r30,r20
 197 00b2 8083      		st Z,r24
 786:switcherator.c ****     direction[0] = switchInfo % 2;
 198               		.loc 1 786 0
 199 00b4 9170      		andi r25,lo8(1)
 200               	.LVL26:
 201 00b6 D901      		movw r26,r18
 202 00b8 9C93      		st X,r25
 203 00ba 0895      		ret
 204               	.LFE18:
 206               	.global	pwmClear
 208               	pwmClear:
 209               	.LFB21:
 787:switcherator.c **** }
 788:switcherator.c **** 
 789:switcherator.c **** // assign a secondary brightness to a switch
 790:switcherator.c **** // sb s#16
 791:switcherator.c **** 
 792:switcherator.c **** void switchBrightness(char * commandReceived) {
 793:switcherator.c ****     int switchNumber = getSwitchNumber(commandReceived);
 794:switcherator.c ****     char tempBright = 0;
 795:switcherator.c ****     if (switchNumber >= NUM_SWITCHES) {
 796:switcherator.c ****         fail(1);
 797:switcherator.c ****         return;
 798:switcherator.c ****     }
 799:switcherator.c ****     tempIntString[0] = commandReceived[5];
 800:switcherator.c ****     tempIntString[1] = commandReceived[6];
 801:switcherator.c ****     char brightValue = atoi(tempIntString);
 802:switcherator.c ****     if (brightValue == 0) {
 803:switcherator.c ****         tempBright = switchBright[switchNumber];
 804:switcherator.c ****         itoa(tempBright, tempIntString, 10);
 805:switcherator.c ****         statusMsg[0] = 0;
 806:switcherator.c ****         strcat(statusMsg, "Set @");
 807:switcherator.c ****         strcat(statusMsg, tempIntString);
 808:switcherator.c ****         sendMessage(statusMsg);
 809:switcherator.c ****     } else {
 810:switcherator.c ****         if (brightValue > 16)
 811:switcherator.c ****             brightValue = 16;
 812:switcherator.c ****         clearTheSwitch(switchNumber);
 813:switcherator.c ****         // value to indicate this is brightness
 814:switcherator.c ****         switchStuff[switchNumber] = 212;
 815:switcherator.c ****         switchBright[switchNumber] = brightValue;
 816:switcherator.c ****         ok();
 817:switcherator.c ****     }
 818:switcherator.c **** }
 819:switcherator.c **** 
 820:switcherator.c **** /****************************************************************
 821:switcherator.c ****  *
 822:switcherator.c ****  *              All Things PWM Related
 823:switcherator.c ****  *
 824:switcherator.c ****  ****************************************************************/
 825:switcherator.c **** 
 826:switcherator.c **** // PWM setup.  This is initially  geared for the 328p but the framework
 827:switcherator.c **** // exists for other chips
 828:switcherator.c **** // PS:P#S#DH
 829:switcherator.c **** // 012345678
 830:switcherator.c **** 
 831:switcherator.c **** void pwmSetup(char * commandReceived) {
 832:switcherator.c ****     int x = 0;
 833:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 834:switcherator.c ****         if (switchStuff[x] == 70 || switchStuff[x] == 71 || switchStuff[x] == 74 ||
 835:switcherator.c ****                 switchStuff[x] == 75 || switchStuff[x] == 76 || switchStuff[x] == 77) {
 836:switcherator.c ****             fail(6);
 837:switcherator.c ****             return;
 838:switcherator.c ****         }
 839:switcherator.c ****     }
 840:switcherator.c ****     int switchNumber = 0;
 841:switcherator.c ****     // get switch number
 842:switcherator.c ****     tempIntString[0] = commandReceived[5];
 843:switcherator.c ****     tempIntString[1] = commandReceived[6];
 844:switcherator.c ****     switchNumber = atoi(tempIntString);
 845:switcherator.c ****     clearTheSwitch(switchNumber);
 846:switcherator.c ****     // set up a hue pwm
 847:switcherator.c ****     if (commandReceived[8] == 'H' || commandReceived[8] == 'h' || commandReceived[8] == '1') {
 848:switcherator.c ****         switchStuff[switchNumber] = 201;
 849:switcherator.c ****     } else if (commandReceived[8] == 'C' || commandReceived[8] == 'c') {
 850:switcherator.c ****         switchStuff[switchNumber] = 202;
 851:switcherator.c ****     } else {
 852:switcherator.c ****         switchStuff[switchNumber] = 200;
 853:switcherator.c ****     }
 854:switcherator.c ****     DDRD |= (1 << PIND3) | (1 << PIND5) | (1 << PIND6);
 855:switcherator.c ****     // make sure initial values are 0
 856:switcherator.c ****     Red = 0;
 857:switcherator.c ****     Green = 0;
 858:switcherator.c ****     Blue = 0;
 859:switcherator.c ****     // Set output phase correct whatevers
 860:switcherator.c ****     // set it to inverted if the direction is 0
 861:switcherator.c ****     if (commandReceived[7] == '0') {
 862:switcherator.c ****         pwmdir = 0;
 863:switcherator.c ****         TCCR0A = (1 << COM0A0) | (1 << COM0A1) | (1 << COM0B0) | (1 << COM0B1) | (1 << WGM00);
 864:switcherator.c ****         TCCR2A = (1 << COM2B0) | (1 << COM2B1) | (1 << WGM20);
 865:switcherator.c ****     } else {
 866:switcherator.c ****         pwmdir = 1;
 867:switcherator.c ****         TCCR0A = (1 << COM0A1) | (1 << COM0B1) | (1 << WGM00);
 868:switcherator.c ****         TCCR2A = (1 << COM2B1) | (1 << WGM20);
 869:switcherator.c ****     }
 870:switcherator.c ****     // F_CPU/64 timers
 871:switcherator.c ****     TCCR0B = (1 << CS01) | (1 << CS00);
 872:switcherator.c **** 
 873:switcherator.c ****     TCCR2B = (1 << CS22); // F_CPU/64
 874:switcherator.c ****     // pwm to output
 875:switcherator.c ****     ok();
 876:switcherator.c **** }
 877:switcherator.c **** 
 878:switcherator.c **** // Turn off the PWM - called by clearing the switch
 879:switcherator.c **** 
 880:switcherator.c **** void pwmClear(int switchNumber) {
 210               		.loc 1 880 0
 211               	.LVL27:
 212               	/* prologue: function */
 213               	/* frame size = 0 */
 214               	/* stack size = 0 */
 215               	.L__stack_usage = 0
 881:switcherator.c ****     if (switchStuff[switchNumber] == 212) {
 216               		.loc 1 881 0
 217 00bc 8050      		subi r24,lo8(-(switchStuff))
 218 00be 9040      		sbci r25,hi8(-(switchStuff))
 219               	.LVL28:
 220 00c0 FC01      		movw r30,r24
 221 00c2 8081      		ld r24,Z
 222               	.LVL29:
 223 00c4 843D      		cpi r24,lo8(-44)
 224 00c6 01F4      		brne .L16
 882:switcherator.c ****         bright = oldBright;
 225               		.loc 1 882 0
 226 00c8 8091 0000 		lds r24,oldBright
 227 00cc 8093 0000 		sts bright,r24
 228 00d0 1092 0000 		sts bright+1,__zero_reg__
 229 00d4 0895      		ret
 230               	.L16:
 883:switcherator.c ****     } else {
 884:switcherator.c ****         TCCR0A = 0;
 231               		.loc 1 884 0
 232 00d6 14BC      		out 0x24,__zero_reg__
 885:switcherator.c ****         TCCR0B = 0;
 233               		.loc 1 885 0
 234 00d8 15BC      		out 0x25,__zero_reg__
 886:switcherator.c ****         TCCR2A = 0;
 235               		.loc 1 886 0
 236 00da 1092 B000 		sts 176,__zero_reg__
 887:switcherator.c ****         TCCR2B = 0;
 237               		.loc 1 887 0
 238 00de 1092 B100 		sts 177,__zero_reg__
 888:switcherator.c ****         Red = 0;
 239               		.loc 1 888 0
 240 00e2 1092 B400 		sts 180,__zero_reg__
 889:switcherator.c ****         Green = 0;
 241               		.loc 1 889 0
 242 00e6 18BC      		out 0x28,__zero_reg__
 890:switcherator.c ****         Blue = 0;
 243               		.loc 1 890 0
 244 00e8 17BC      		out 0x27,__zero_reg__
 891:switcherator.c ****         DDRD &= ~((1 << PIND3)&(1 << PIND5)&(1 << PIND6));
 245               		.loc 1 891 0
 246 00ea 8AB1      		in r24,0xa
 247 00ec 8AB9      		out 0xa,r24
 892:switcherator.c ****         runHue = 0;
 248               		.loc 1 892 0
 249 00ee 1092 0000 		sts runHue,__zero_reg__
 893:switcherator.c ****         runColorChanges = 0;
 250               		.loc 1 893 0
 251 00f2 1092 0000 		sts runColorChanges,__zero_reg__
 252 00f6 0895      		ret
 253               	.LFE21:
 255               	.global	clearTheSwitch
 257               	clearTheSwitch:
 258               	.LFB15:
 534:switcherator.c **** void clearTheSwitch(int switchNumber) {
 259               		.loc 1 534 0
 260               	.LVL30:
 261 00f8 EF92      		push r14
 262               	.LCFI0:
 263 00fa FF92      		push r15
 264               	.LCFI1:
 265 00fc 0F93      		push r16
 266               	.LCFI2:
 267 00fe 1F93      		push r17
 268               	.LCFI3:
 269 0100 CF93      		push r28
 270               	.LCFI4:
 271 0102 DF93      		push r29
 272               	.LCFI5:
 273 0104 00D0      		rcall .
 274 0106 1F92      		push __zero_reg__
 275               	.LCFI6:
 276 0108 CDB7      		in r28,__SP_L__
 277 010a DEB7      		in r29,__SP_H__
 278               	.LCFI7:
 279               	/* prologue: function */
 280               	/* frame size = 3 */
 281               	/* stack size = 9 */
 282               	.L__stack_usage = 9
 283 010c 8C01      		movw r16,r24
 535:switcherator.c ****     char port[] = {0};
 284               		.loc 1 535 0
 285 010e 1B82      		std Y+3,__zero_reg__
 536:switcherator.c ****     char pin[] = {0};
 286               		.loc 1 536 0
 287 0110 1A82      		std Y+2,__zero_reg__
 537:switcherator.c ****     char direction[] = {0};
 288               		.loc 1 537 0
 289 0112 1982      		std Y+1,__zero_reg__
 290               	.LVL31:
 542:switcherator.c ****     if (switchStuff[switchNumber] >= 200 && switchStuff[switchNumber] <= 220) {
 291               		.loc 1 542 0
 292 0114 80E0      		ldi r24,lo8(switchStuff)
 293 0116 E82E      		mov r14,r24
 294 0118 80E0      		ldi r24,hi8(switchStuff)
 295 011a F82E      		mov r15,r24
 296               	.LVL32:
 297 011c E00E      		add r14,r16
 298 011e F11E      		adc r15,r17
 299 0120 F701      		movw r30,r14
 300 0122 8081      		ld r24,Z
 301 0124 885C      		subi r24,lo8(-(56))
 302 0126 8531      		cpi r24,lo8(21)
 303 0128 00F4      		brsh .L19
 544:switcherator.c ****         pwmClear(switchNumber);
 304               		.loc 1 544 0
 305 012a C801      		movw r24,r16
 306 012c 0E94 0000 		call pwmClear
 307               	.LVL33:
 545:switcherator.c ****         switchStuff[switchNumber] = 255;
 308               		.loc 1 545 0
 309 0130 8FEF      		ldi r24,lo8(-1)
 310 0132 F701      		movw r30,r14
 311 0134 00C0      		rjmp .L25
 312               	.L19:
 548:switcherator.c ****     getPort(switchNumber, port, pin, direction);
 313               		.loc 1 548 0
 314 0136 9E01      		movw r18,r28
 315 0138 2F5F      		subi r18,-1
 316 013a 3F4F      		sbci r19,-1
 317 013c AE01      		movw r20,r28
 318 013e 4E5F      		subi r20,-2
 319 0140 5F4F      		sbci r21,-1
 320 0142 BE01      		movw r22,r28
 321 0144 6D5F      		subi r22,-3
 322 0146 7F4F      		sbci r23,-1
 323 0148 C801      		movw r24,r16
 324 014a 0E94 0000 		call getPort
 325               	.LVL34:
 549:switcherator.c ****     if (port[0] == 'B') {
 326               		.loc 1 549 0
 327 014e 8B81      		ldd r24,Y+3
 328 0150 8234      		cpi r24,lo8(66)
 329 0152 01F0      		breq .L22
 558:switcherator.c ****     } else if (port[0] == 'C') {
 330               		.loc 1 558 0
 331 0154 8334      		cpi r24,lo8(67)
 332 0156 01F0      		breq .L23
 563:switcherator.c ****     } else if (port[0] == 'D') {
 333               		.loc 1 563 0
 334 0158 8434      		cpi r24,lo8(68)
 335 015a 01F0      		breq .L24
 539:switcherator.c ****     volatile unsigned char *thisDDR = 0;
 336               		.loc 1 539 0
 337 015c A0E0      		ldi r26,0
 338 015e B0E0      		ldi r27,0
 538:switcherator.c ****     volatile unsigned char *thisPort = 0;
 339               		.loc 1 538 0
 340 0160 E0E0      		ldi r30,0
 341 0162 F0E0      		ldi r31,0
 342 0164 00C0      		rjmp .L21
 343               	.L22:
 551:switcherator.c ****         thisDDR = &DDRB;
 344               		.loc 1 551 0
 345 0166 A4E2      		ldi r26,lo8(36)
 346 0168 B0E0      		ldi r27,0
 550:switcherator.c ****         thisPort = &PORTB;
 347               		.loc 1 550 0
 348 016a E5E2      		ldi r30,lo8(37)
 349 016c F0E0      		ldi r31,0
 350 016e 00C0      		rjmp .L21
 351               	.L23:
 560:switcherator.c ****         thisDDR = &DDRC;
 352               		.loc 1 560 0
 353 0170 A7E2      		ldi r26,lo8(39)
 354 0172 B0E0      		ldi r27,0
 559:switcherator.c ****         thisPort = &PORTC;
 355               		.loc 1 559 0
 356 0174 E8E2      		ldi r30,lo8(40)
 357 0176 F0E0      		ldi r31,0
 358 0178 00C0      		rjmp .L21
 359               	.L24:
 565:switcherator.c ****         thisDDR = &DDRD;
 360               		.loc 1 565 0
 361 017a AAE2      		ldi r26,lo8(42)
 362 017c B0E0      		ldi r27,0
 564:switcherator.c ****         thisPort = &PORTD;
 363               		.loc 1 564 0
 364 017e EBE2      		ldi r30,lo8(43)
 365 0180 F0E0      		ldi r31,0
 366               	.L21:
 367               	.LVL35:
 594:switcherator.c ****     *thisDDR &= ~(1 << realPin);
 368               		.loc 1 594 0
 369 0182 2C91      		ld r18,X
 370 0184 81E0      		ldi r24,lo8(1)
 371 0186 90E0      		ldi r25,0
 372 0188 0A80      		ldd r0,Y+2
 373 018a 00C0      		rjmp 2f
 374               		1:
 375 018c 880F      		lsl r24
 376 018e 991F      		rol r25
 377               		2:
 378 0190 0A94      		dec r0
 379 0192 02F4      		brpl 1b
 380 0194 8095      		com r24
 381 0196 2823      		and r18,r24
 382 0198 2C93      		st X,r18
 595:switcherator.c ****     *thisPort &= ~(1 << realPin);
 383               		.loc 1 595 0
 384 019a 9081      		ld r25,Z
 385 019c 9823      		and r25,r24
 386 019e 9083      		st Z,r25
 596:switcherator.c ****     switchStuff[switchNumber] = 255;
 387               		.loc 1 596 0
 388 01a0 F801      		movw r30,r16
 389               	.LVL36:
 390 01a2 E050      		subi r30,lo8(-(switchStuff))
 391 01a4 F040      		sbci r31,hi8(-(switchStuff))
 392 01a6 8FEF      		ldi r24,lo8(-1)
 393               	.LVL37:
 394               	.L25:
 395 01a8 8083      		st Z,r24
 396               	/* epilogue start */
 597:switcherator.c **** }
 397               		.loc 1 597 0
 398 01aa 0F90      		pop __tmp_reg__
 399 01ac 0F90      		pop __tmp_reg__
 400 01ae 0F90      		pop __tmp_reg__
 401 01b0 DF91      		pop r29
 402 01b2 CF91      		pop r28
 403 01b4 1F91      		pop r17
 404 01b6 0F91      		pop r16
 405               	.LVL38:
 406 01b8 FF90      		pop r15
 407 01ba EF90      		pop r14
 408 01bc 0895      		ret
 409               	.LFE15:
 411               	.global	runColorFunction
 413               	runColorFunction:
 414               	.LFB27:
 894:switcherator.c ****     }
 895:switcherator.c **** }
 896:switcherator.c **** 
 897:switcherator.c **** // This just sets up the times for the PWM hues
 898:switcherator.c **** // CH:P#TTTTT 
 899:switcherator.c **** // 0123456789
 900:switcherator.c **** 
 901:switcherator.c **** void cycleHue(char * commandReceived) {
 902:switcherator.c ****     // right now we just have 1 pwm but I could add more
 903:switcherator.c ****     tempLongString[0] = commandReceived[5];
 904:switcherator.c ****     tempLongString[1] = commandReceived[6];
 905:switcherator.c ****     tempLongString[2] = commandReceived[7];
 906:switcherator.c ****     tempLongString[3] = commandReceived[8];
 907:switcherator.c ****     int programNumber = 0;
 908:switcherator.c ****     programNumber = atoi(tempLongString);
 909:switcherator.c ****     if (programNumber > 0)
 910:switcherator.c ****         colorChangeSpeed = programNumber;
 911:switcherator.c ****     ok();
 912:switcherator.c **** }
 913:switcherator.c **** 
 914:switcherator.c **** // Changes the hue speed
 915:switcherator.c **** // HS:xx
 916:switcherator.c **** 
 917:switcherator.c **** void setHueSpeed(char * commandReceived) {
 918:switcherator.c ****     tempIntString[0] = commandReceived[3];
 919:switcherator.c ****     tempIntString[1] = commandReceived[4];
 920:switcherator.c ****     int programNumber = 0;
 921:switcherator.c ****     programNumber = atoi(tempIntString);
 922:switcherator.c ****     if (programNumber > 0)
 923:switcherator.c ****         hueSpeed = programNumber;
 924:switcherator.c ****     ok();
 925:switcherator.c **** }
 926:switcherator.c **** 
 927:switcherator.c **** 
 928:switcherator.c **** // set up the values for a solid pwm
 929:switcherator.c **** // PV:P#,vvv,vvv,vvv
 930:switcherator.c **** // 01234567890123456
 931:switcherator.c **** 
 932:switcherator.c **** void pwmValueSet(char * commandReceived) {
 933:switcherator.c ****     tempLongString[3] = 0;
 934:switcherator.c ****     tempLongString[0] = commandReceived[6];
 935:switcherator.c ****     tempLongString[1] = commandReceived[7];
 936:switcherator.c ****     tempLongString[2] = commandReceived[8];
 937:switcherator.c ****     pwmValues[0] = atoi(tempLongString);
 938:switcherator.c ****     tempLongString[0] = commandReceived[10];
 939:switcherator.c ****     tempLongString[1] = commandReceived[11];
 940:switcherator.c ****     tempLongString[2] = commandReceived[12];
 941:switcherator.c ****     pwmValues[1] = atoi(tempLongString);
 942:switcherator.c ****     tempLongString[0] = commandReceived[14];
 943:switcherator.c ****     tempLongString[1] = commandReceived[15];
 944:switcherator.c ****     tempLongString[2] = commandReceived[16];
 945:switcherator.c ****     pwmValues[2] = atoi(tempLongString);
 946:switcherator.c ****     statusMsg[0] = 0;
 947:switcherator.c ****     ok();
 948:switcherator.c **** }
 949:switcherator.c **** 
 950:switcherator.c **** // add a color to the color change
 951:switcherator.c **** // CC:##,vvv,vvv,vvv
 952:switcherator.c **** // 01234567890123456
 953:switcherator.c **** 
 954:switcherator.c **** void colorChangeSet(char * commandReceived) {
 955:switcherator.c ****     int programNumber = getSwitchNumber(commandReceived);
 956:switcherator.c ****     if (programNumber >= NUM_COLOR_CHANGES) {
 957:switcherator.c ****         fail(7);
 958:switcherator.c ****         return;
 959:switcherator.c ****     }
 960:switcherator.c ****     tempLongString[3] = 0;
 961:switcherator.c ****     tempLongString[0] = commandReceived[6];
 962:switcherator.c ****     tempLongString[1] = commandReceived[7];
 963:switcherator.c ****     tempLongString[2] = commandReceived[8];
 964:switcherator.c ****     colorChanges[programNumber][0] = atoi(tempLongString);
 965:switcherator.c ****     tempLongString[0] = commandReceived[10];
 966:switcherator.c ****     tempLongString[1] = commandReceived[11];
 967:switcherator.c ****     tempLongString[2] = commandReceived[12];
 968:switcherator.c ****     colorChanges[programNumber][1] = atoi(tempLongString);
 969:switcherator.c ****     tempLongString[0] = commandReceived[14];
 970:switcherator.c ****     tempLongString[1] = commandReceived[15];
 971:switcherator.c ****     tempLongString[2] = commandReceived[16];
 972:switcherator.c ****     colorChanges[programNumber][2] = atoi(tempLongString);
 973:switcherator.c ****     ok();
 974:switcherator.c **** }
 975:switcherator.c **** 
 976:switcherator.c **** // show the pwm values & color change values
 977:switcherator.c **** 
 978:switcherator.c **** void pwmSummary(void) {
 979:switcherator.c ****     statusMsg[0] = 0;
 980:switcherator.c ****     strcat(statusMsg, "Val 0x");
 981:switcherator.c ****     int x = 0;
 982:switcherator.c ****     for (x = 0; x < 3; x++) {
 983:switcherator.c ****         if (x > 0)
 984:switcherator.c ****             strcat(statusMsg, ",");
 985:switcherator.c ****         returnHexWithout(pwmValues[x], tempLongString);
 986:switcherator.c ****         strcat(statusMsg, tempLongString);
 987:switcherator.c ****     }
 988:switcherator.c ****     strcat(statusMsg, " dir ");
 989:switcherator.c ****     returnInt(pwmdir, tempLongString);
 990:switcherator.c ****     strcat(statusMsg, tempLongString);
 991:switcherator.c ****     sendMessage(statusMsg);
 992:switcherator.c ****     statusMsg[0] = 0;
 993:switcherator.c ****     strcat(statusMsg, "ColCh:");
 994:switcherator.c ****     int y = 0;
 995:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 996:switcherator.c ****         if (x > 0)
 997:switcherator.c ****             strcat(statusMsg, ",");
 998:switcherator.c ****         strcat(statusMsg, "0x");
 999:switcherator.c ****         if(colorChanges[x][0] == 0 && colorChanges[x][1] == 1 &&
1000:switcherator.c ****                 colorChanges[x][2] == 0)
1001:switcherator.c ****             strcat(statusMsg,"--");
1002:switcherator.c ****         else {
1003:switcherator.c ****             for (y = 0; y < 3; y++) {
1004:switcherator.c ****                 if (y > 0)
1005:switcherator.c ****                     strcat(statusMsg,",");
1006:switcherator.c ****                 returnHexWithout(colorChanges[x][y], tempLongString);
1007:switcherator.c ****                 strcat(statusMsg, tempLongString);
1008:switcherator.c ****             }
1009:switcherator.c ****         }
1010:switcherator.c ****         if (strlen(statusMsg) > 20) {
1011:switcherator.c ****             sendMessage(statusMsg);
1012:switcherator.c ****             statusMsg[6] = 0;
1013:switcherator.c ****         }
1014:switcherator.c ****     }
1015:switcherator.c ****     if(strlen(statusMsg)> 6)
1016:switcherator.c ****         sendMessage(statusMsg);
1017:switcherator.c ****     statusMsg[0] = 0;
1018:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
1019:switcherator.c ****         if ((switchStuff[x] >= 200) && (switchStuff[x] <= 220)) {
1020:switcherator.c ****             strcat(statusMsg, "PWM ");
1021:switcherator.c ****             if (switchStuff[x] == 200) {
1022:switcherator.c ****                 strcat(statusMsg, "static");
1023:switcherator.c ****             } else if (switchStuff[x] == 202) {
1024:switcherator.c ****                 strcat(statusMsg, "ColCh");
1025:switcherator.c ****             } else {
1026:switcherator.c ****                 strcat(statusMsg, "hue");
1027:switcherator.c ****             }
1028:switcherator.c ****             strcat(statusMsg, "on sw# ");
1029:switcherator.c ****             returnInt(x, tempLongString);
1030:switcherator.c ****             strcat(statusMsg, tempLongString);
1031:switcherator.c ****             sendMessage(statusMsg);
1032:switcherator.c ****             statusMsg[0] = 0;
1033:switcherator.c ****         }
1034:switcherator.c ****     }
1035:switcherator.c **** }
1036:switcherator.c **** // HardwarePWM
1037:switcherator.c **** //static char runHue = 0;
1038:switcherator.c **** // PD3, PD5, PD6 or red,green,blue
1039:switcherator.c **** //static char pwmValues[] = {0 , 0 , 0};
1040:switcherator.c **** 
1041:switcherator.c **** // Run color function
1042:switcherator.c **** // goes through the colors and switches them.
1043:switcherator.c **** 
1044:switcherator.c **** void runColorFunction(void) {
 415               		.loc 1 1044 0
 416               	/* prologue: function */
 417               	/* frame size = 0 */
 418               	/* stack size = 0 */
 419               	.L__stack_usage = 0
1045:switcherator.c ****     // delay
1046:switcherator.c ****     colorChangeCount++;
 420               		.loc 1 1046 0
 421 01be 8091 0000 		lds r24,colorChangeCount
 422 01c2 9091 0000 		lds r25,colorChangeCount+1
 423 01c6 0196      		adiw r24,1
 424 01c8 9093 0000 		sts colorChangeCount+1,r25
 425 01cc 8093 0000 		sts colorChangeCount,r24
1047:switcherator.c ****     if (colorChangeCount < colorChangeSpeed)
 426               		.loc 1 1047 0
 427 01d0 2091 0000 		lds r18,colorChangeSpeed
 428 01d4 3091 0000 		lds r19,colorChangeSpeed+1
 429 01d8 8217      		cp r24,r18
 430 01da 9307      		cpc r25,r19
 431 01dc 00F4      		brsh .+2
 432 01de 00C0      		rjmp .L26
1048:switcherator.c ****         return;
1049:switcherator.c ****     colorChangeCount = 0;
 433               		.loc 1 1049 0
 434 01e0 1092 0000 		sts colorChangeCount+1,__zero_reg__
 435 01e4 1092 0000 		sts colorChangeCount,__zero_reg__
1050:switcherator.c ****     currentColor++;
 436               		.loc 1 1050 0
 437 01e8 8091 0000 		lds r24,currentColor
 438 01ec 8F5F      		subi r24,lo8(-(1))
1051:switcherator.c ****     if (currentColor == NUM_COLOR_CHANGES)
 439               		.loc 1 1051 0
 440 01ee 8630      		cpi r24,lo8(6)
 441 01f0 01F0      		breq .L29
1050:switcherator.c ****     currentColor++;
 442               		.loc 1 1050 0
 443 01f2 8093 0000 		sts currentColor,r24
 444 01f6 00C0      		rjmp .L30
 445               	.L29:
1052:switcherator.c ****         currentColor = 0;
 446               		.loc 1 1052 0
 447 01f8 1092 0000 		sts currentColor,__zero_reg__
 448               	.L30:
1053:switcherator.c ****     if (colorChanges[currentColor][0] == 0 &&
 449               		.loc 1 1053 0
 450 01fc 2091 0000 		lds r18,currentColor
 451 0200 822F      		mov r24,r18
 452 0202 90E0      		ldi r25,0
 453 0204 FC01      		movw r30,r24
 454 0206 EE0F      		lsl r30
 455 0208 FF1F      		rol r31
 456 020a E80F      		add r30,r24
 457 020c F91F      		adc r31,r25
 458 020e E050      		subi r30,lo8(-(colorChanges))
 459 0210 F040      		sbci r31,hi8(-(colorChanges))
 460 0212 8081      		ld r24,Z
 461 0214 8111      		cpse r24,__zero_reg__
 462 0216 00C0      		rjmp .L31
 463               		.loc 1 1053 0 is_stmt 0 discriminator 1
 464 0218 8181      		ldd r24,Z+1
 465 021a 8130      		cpi r24,lo8(1)
 466 021c 01F4      		brne .L31
1054:switcherator.c ****             colorChanges[currentColor][1] == 1 &&
 467               		.loc 1 1054 0 is_stmt 1
 468 021e 8281      		ldd r24,Z+2
 469 0220 8111      		cpse r24,__zero_reg__
 470 0222 00C0      		rjmp .L31
1055:switcherator.c ****             colorChanges[currentColor][2] == 0) {
1056:switcherator.c ****         // this one is blank.
1057:switcherator.c ****         if (currentColor == 0)
 471               		.loc 1 1057 0
 472 0224 2223      		tst r18
 473 0226 01F4      		brne .+2
 474 0228 00C0      		rjmp .L26
1058:switcherator.c ****             return;
1059:switcherator.c ****         currentColor = 0;
 475               		.loc 1 1059 0
 476 022a 1092 0000 		sts currentColor,__zero_reg__
 477               	.L31:
 478               	.LBB16:
 479               	.LBB17:
1060:switcherator.c ****     }
1061:switcherator.c ****     red = colorChanges[currentColor][0];
 480               		.loc 1 1061 0
 481 022e 8091 0000 		lds r24,currentColor
 482 0232 90E0      		ldi r25,0
1062:switcherator.c ****     green = colorChanges[currentColor][1];
 483               		.loc 1 1062 0
 484 0234 FC01      		movw r30,r24
 485 0236 EE0F      		lsl r30
 486 0238 FF1F      		rol r31
 487 023a E80F      		add r30,r24
 488 023c F91F      		adc r31,r25
 489 023e E050      		subi r30,lo8(-(colorChanges))
 490 0240 F040      		sbci r31,hi8(-(colorChanges))
 491 0242 8181      		ldd r24,Z+1
1063:switcherator.c ****     blue = colorChanges[currentColor][2];
 492               		.loc 1 1063 0
 493 0244 A281      		ldd r26,Z+2
1064:switcherator.c ****     red = red * bright / 16;
 494               		.loc 1 1064 0
 495 0246 6091 0000 		lds r22,bright
 496 024a 7091 0000 		lds r23,bright+1
1061:switcherator.c ****     red = colorChanges[currentColor][0];
 497               		.loc 1 1061 0
 498 024e 9081      		ld r25,Z
 499               		.loc 1 1064 0
 500 0250 969F      		mul r25,r22
 501 0252 A001      		movw r20,r0
 502 0254 979F      		mul r25,r23
 503 0256 500D      		add r21,r0
 504 0258 1124      		clr __zero_reg__
 505 025a 34E0      		ldi r19,4
 506               		1:
 507 025c 5695      		lsr r21
 508 025e 4795      		ror r20
 509 0260 3A95      		dec r19
 510 0262 01F4      		brne 1b
 511 0264 5093 0000 		sts red+1,r21
 512 0268 4093 0000 		sts red,r20
1065:switcherator.c ****     green = green * bright / 16;
 513               		.loc 1 1065 0
 514 026c 869F      		mul r24,r22
 515 026e 9001      		movw r18,r0
 516 0270 879F      		mul r24,r23
 517 0272 300D      		add r19,r0
 518 0274 1124      		clr __zero_reg__
 519 0276 54E0      		ldi r21,4
 520               		1:
 521 0278 3695      		lsr r19
 522 027a 2795      		ror r18
 523 027c 5A95      		dec r21
 524 027e 01F4      		brne 1b
 525 0280 3093 0000 		sts green+1,r19
 526 0284 2093 0000 		sts green,r18
1066:switcherator.c ****     blue = blue * bright / 16;
 527               		.loc 1 1066 0
 528 0288 A69F      		mul r26,r22
 529 028a C001      		movw r24,r0
 530 028c A79F      		mul r26,r23
 531 028e 900D      		add r25,r0
 532 0290 1124      		clr __zero_reg__
 533 0292 64E0      		ldi r22,4
 534               		1:
 535 0294 9695      		lsr r25
 536 0296 8795      		ror r24
 537 0298 6A95      		dec r22
 538 029a 01F4      		brne 1b
 539 029c 9093 0000 		sts blue+1,r25
 540 02a0 8093 0000 		sts blue,r24
1067:switcherator.c ****     Red = red;
 541               		.loc 1 1067 0
 542 02a4 4093 B400 		sts 180,r20
1068:switcherator.c ****     Green = green;
 543               		.loc 1 1068 0
 544 02a8 28BD      		out 0x28,r18
1069:switcherator.c ****     Blue = blue;
 545               		.loc 1 1069 0
 546 02aa 87BD      		out 0x27,r24
 547               	.L26:
 548 02ac 0895      		ret
 549               	.LBE17:
 550               	.LBE16:
 551               	.LFE27:
 553               	.global	runHueFunction
 555               	runHueFunction:
 556               	.LFB28:
1070:switcherator.c **** }
1071:switcherator.c **** // rotating hue
1072:switcherator.c **** //static int currentHue = 0;
1073:switcherator.c **** //static int hueSpeed = 0;
1074:switcherator.c **** //static char hueCount = 0;
1075:switcherator.c **** //#define Red OCR2B
1076:switcherator.c **** //#define Green OCR0B
1077:switcherator.c **** //#define Blue OCR0A
1078:switcherator.c **** 
1079:switcherator.c **** // go through and rotate the hue based color rotation
1080:switcherator.c **** // static int currentHue = 0;
1081:switcherator.c **** // static char hueSpeed = 0;
1082:switcherator.c **** // static char hueCount = 0;
1083:switcherator.c **** 
1084:switcherator.c **** void runHueFunction(void) {
 557               		.loc 1 1084 0
 558               	/* prologue: function */
 559               	/* frame size = 0 */
 560               	/* stack size = 0 */
 561               	.L__stack_usage = 0
1085:switcherator.c ****     // extra fixed delay
1086:switcherator.c ****     littleCount++;
 562               		.loc 1 1086 0
 563 02ae 8091 0000 		lds r24,littleCount
 564 02b2 8F5F      		subi r24,lo8(-(1))
 565 02b4 8093 0000 		sts littleCount,r24
1087:switcherator.c ****     if (littleCount != 2)
 566               		.loc 1 1087 0
 567 02b8 8230      		cpi r24,lo8(2)
 568 02ba 01F0      		breq .+2
 569 02bc 00C0      		rjmp .L36
1088:switcherator.c ****         return;
1089:switcherator.c ****     littleCount = 0;
 570               		.loc 1 1089 0
 571 02be 1092 0000 		sts littleCount,__zero_reg__
1090:switcherator.c ****     hueCount++;
 572               		.loc 1 1090 0
 573 02c2 8091 0000 		lds r24,hueCount
 574 02c6 9091 0000 		lds r25,hueCount+1
 575 02ca 0196      		adiw r24,1
 576 02cc 9093 0000 		sts hueCount+1,r25
 577 02d0 8093 0000 		sts hueCount,r24
1091:switcherator.c ****     // only run if the count is higher than the "speed"
1092:switcherator.c ****     if (hueCount < hueSpeed) {
 578               		.loc 1 1092 0
 579 02d4 2091 0000 		lds r18,hueSpeed
 580 02d8 3091 0000 		lds r19,hueSpeed+1
 581 02dc 8217      		cp r24,r18
 582 02de 9307      		cpc r25,r19
 583 02e0 00F4      		brsh .+2
 584 02e2 00C0      		rjmp .L36
1093:switcherator.c ****         return;
1094:switcherator.c ****     }
1095:switcherator.c ****     hueCount = 0;
 585               		.loc 1 1095 0
 586 02e4 1092 0000 		sts hueCount+1,__zero_reg__
 587 02e8 1092 0000 		sts hueCount,__zero_reg__
1096:switcherator.c ****     if (currentHue < 0x00ff) {
 588               		.loc 1 1096 0
 589 02ec 8091 0000 		lds r24,currentHue
 590 02f0 9091 0000 		lds r25,currentHue+1
 591 02f4 8F3F      		cpi r24,-1
 592 02f6 9105      		cpc r25,__zero_reg__
 593 02f8 00F4      		brsh .L40
1097:switcherator.c ****         red = 255;
 594               		.loc 1 1097 0
 595 02fa 2FEF      		ldi r18,lo8(-1)
 596 02fc 30E0      		ldi r19,0
 597 02fe 3093 0000 		sts red+1,r19
 598 0302 2093 0000 		sts red,r18
 599 0306 00C0      		rjmp .L47
 600               	.L40:
1098:switcherator.c ****         green = currentHue;
1099:switcherator.c ****         blue = 0;
1100:switcherator.c ****     } else if (currentHue < 0x01ff) {
 601               		.loc 1 1100 0
 602 0308 8F3F      		cpi r24,-1
 603 030a 21E0      		ldi r18,1
 604 030c 9207      		cpc r25,r18
 605 030e 00F4      		brsh .L42
1101:switcherator.c ****         red = 255 - (currentHue - 0xff);
 606               		.loc 1 1101 0
 607 0310 2EEF      		ldi r18,lo8(-2)
 608 0312 31E0      		ldi r19,lo8(1)
 609 0314 281B      		sub r18,r24
 610 0316 390B      		sbc r19,r25
 611 0318 3093 0000 		sts red+1,r19
 612 031c 2093 0000 		sts red,r18
1102:switcherator.c ****         green = 255;
 613               		.loc 1 1102 0
 614 0320 8FEF      		ldi r24,lo8(-1)
 615 0322 90E0      		ldi r25,0
 616               	.L47:
 617 0324 9093 0000 		sts green+1,r25
 618 0328 8093 0000 		sts green,r24
1103:switcherator.c ****         blue = 0;
 619               		.loc 1 1103 0
 620 032c 1092 0000 		sts blue+1,__zero_reg__
 621 0330 1092 0000 		sts blue,__zero_reg__
 622 0334 00C0      		rjmp .L41
 623               	.L42:
1104:switcherator.c ****     } else if (currentHue < 0x02ff) {
 624               		.loc 1 1104 0
 625 0336 8F3F      		cpi r24,-1
 626 0338 22E0      		ldi r18,2
 627 033a 9207      		cpc r25,r18
 628 033c 00F4      		brsh .L43
1105:switcherator.c ****         red = 0;
 629               		.loc 1 1105 0
 630 033e 1092 0000 		sts red+1,__zero_reg__
 631 0342 1092 0000 		sts red,__zero_reg__
1106:switcherator.c ****         green = 255;
 632               		.loc 1 1106 0
 633 0346 2FEF      		ldi r18,lo8(-1)
 634 0348 30E0      		ldi r19,0
 635 034a 3093 0000 		sts green+1,r19
 636 034e 2093 0000 		sts green,r18
1107:switcherator.c ****         blue = (currentHue - 0x1ff);
 637               		.loc 1 1107 0
 638 0352 8F5F      		subi r24,-1
 639 0354 9140      		sbci r25,1
 640 0356 00C0      		rjmp .L48
 641               	.L43:
1108:switcherator.c ****     } else if (currentHue < 0x03ff) {
 642               		.loc 1 1108 0
 643 0358 8F3F      		cpi r24,-1
 644 035a 23E0      		ldi r18,3
 645 035c 9207      		cpc r25,r18
 646 035e 00F4      		brsh .L44
1109:switcherator.c ****         red = 0;
 647               		.loc 1 1109 0
 648 0360 1092 0000 		sts red+1,__zero_reg__
 649 0364 1092 0000 		sts red,__zero_reg__
1110:switcherator.c ****         green = 255 - (currentHue - 0x2ff);
 650               		.loc 1 1110 0
 651 0368 2EEF      		ldi r18,lo8(-2)
 652 036a 33E0      		ldi r19,lo8(3)
 653 036c 281B      		sub r18,r24
 654 036e 390B      		sbc r19,r25
 655 0370 3093 0000 		sts green+1,r19
 656 0374 2093 0000 		sts green,r18
 657               	.L49:
1111:switcherator.c ****         blue = 255;
 658               		.loc 1 1111 0
 659 0378 8FEF      		ldi r24,lo8(-1)
 660 037a 90E0      		ldi r25,0
 661               	.L48:
 662 037c 9093 0000 		sts blue+1,r25
 663 0380 8093 0000 		sts blue,r24
 664 0384 00C0      		rjmp .L41
 665               	.L44:
1112:switcherator.c ****     } else if (currentHue < 0x04ff) {
 666               		.loc 1 1112 0
 667 0386 8F3F      		cpi r24,-1
 668 0388 24E0      		ldi r18,4
 669 038a 9207      		cpc r25,r18
 670 038c 00F4      		brsh .L45
1113:switcherator.c ****         red = (currentHue - 0x3ff);
 671               		.loc 1 1113 0
 672 038e 8F5F      		subi r24,-1
 673 0390 9340      		sbci r25,3
 674 0392 9093 0000 		sts red+1,r25
 675 0396 8093 0000 		sts red,r24
1114:switcherator.c ****         green = 0;
 676               		.loc 1 1114 0
 677 039a 1092 0000 		sts green+1,__zero_reg__
 678 039e 1092 0000 		sts green,__zero_reg__
 679 03a2 00C0      		rjmp .L49
 680               	.L45:
1115:switcherator.c ****         blue = 255;
1116:switcherator.c ****     } else if (currentHue < 0x05ff) {
 681               		.loc 1 1116 0
 682 03a4 8F3F      		cpi r24,-1
 683 03a6 25E0      		ldi r18,5
 684 03a8 9207      		cpc r25,r18
 685 03aa 00F4      		brsh .L46
1117:switcherator.c ****         red = 255;
 686               		.loc 1 1117 0
 687 03ac 2FEF      		ldi r18,lo8(-1)
 688 03ae 30E0      		ldi r19,0
 689 03b0 3093 0000 		sts red+1,r19
 690 03b4 2093 0000 		sts red,r18
1118:switcherator.c ****         green = 0;
 691               		.loc 1 1118 0
 692 03b8 1092 0000 		sts green+1,__zero_reg__
 693 03bc 1092 0000 		sts green,__zero_reg__
1119:switcherator.c ****         blue = 255 - (currentHue - 0x4ff);
 694               		.loc 1 1119 0
 695 03c0 2EEF      		ldi r18,lo8(-2)
 696 03c2 35E0      		ldi r19,lo8(5)
 697 03c4 281B      		sub r18,r24
 698 03c6 390B      		sbc r19,r25
 699 03c8 3093 0000 		sts blue+1,r19
 700 03cc 2093 0000 		sts blue,r18
 701 03d0 00C0      		rjmp .L41
 702               	.L46:
1120:switcherator.c ****     } else {
1121:switcherator.c ****         red = 255;
 703               		.loc 1 1121 0
 704 03d2 8FEF      		ldi r24,lo8(-1)
 705 03d4 90E0      		ldi r25,0
 706 03d6 9093 0000 		sts red+1,r25
 707 03da 8093 0000 		sts red,r24
1122:switcherator.c ****         green = 0;
 708               		.loc 1 1122 0
 709 03de 1092 0000 		sts green+1,__zero_reg__
 710 03e2 1092 0000 		sts green,__zero_reg__
1123:switcherator.c ****         blue = 0;
 711               		.loc 1 1123 0
 712 03e6 1092 0000 		sts blue+1,__zero_reg__
 713 03ea 1092 0000 		sts blue,__zero_reg__
1124:switcherator.c ****         currentHue = 0;
 714               		.loc 1 1124 0
 715 03ee 1092 0000 		sts currentHue+1,__zero_reg__
 716 03f2 1092 0000 		sts currentHue,__zero_reg__
 717               	.L41:
1125:switcherator.c ****     }
1126:switcherator.c ****     red = red * bright / 16;
 718               		.loc 1 1126 0
 719 03f6 6091 0000 		lds r22,bright
 720 03fa 7091 0000 		lds r23,bright+1
 721 03fe 8091 0000 		lds r24,red
 722 0402 9091 0000 		lds r25,red+1
 723 0406 689F      		mul r22,r24
 724 0408 A001      		movw r20,r0
 725 040a 699F      		mul r22,r25
 726 040c 500D      		add r21,r0
 727 040e 789F      		mul r23,r24
 728 0410 500D      		add r21,r0
 729 0412 1124      		clr r1
 730 0414 E4E0      		ldi r30,4
 731               		1:
 732 0416 5695      		lsr r21
 733 0418 4795      		ror r20
 734 041a EA95      		dec r30
 735 041c 01F4      		brne 1b
 736 041e 5093 0000 		sts red+1,r21
 737 0422 4093 0000 		sts red,r20
1127:switcherator.c ****     green = green * bright / 16;
 738               		.loc 1 1127 0
 739 0426 8091 0000 		lds r24,green
 740 042a 9091 0000 		lds r25,green+1
 741 042e 689F      		mul r22,r24
 742 0430 9001      		movw r18,r0
 743 0432 699F      		mul r22,r25
 744 0434 300D      		add r19,r0
 745 0436 789F      		mul r23,r24
 746 0438 300D      		add r19,r0
 747 043a 1124      		clr r1
 748 043c F4E0      		ldi r31,4
 749               		1:
 750 043e 3695      		lsr r19
 751 0440 2795      		ror r18
 752 0442 FA95      		dec r31
 753 0444 01F4      		brne 1b
 754 0446 3093 0000 		sts green+1,r19
 755 044a 2093 0000 		sts green,r18
1128:switcherator.c ****     blue = blue * bright / 16;
 756               		.loc 1 1128 0
 757 044e E091 0000 		lds r30,blue
 758 0452 F091 0000 		lds r31,blue+1
 759 0456 6E9F      		mul r22,r30
 760 0458 C001      		movw r24,r0
 761 045a 6F9F      		mul r22,r31
 762 045c 900D      		add r25,r0
 763 045e 7E9F      		mul r23,r30
 764 0460 900D      		add r25,r0
 765 0462 1124      		clr r1
 766 0464 A4E0      		ldi r26,4
 767               		1:
 768 0466 9695      		lsr r25
 769 0468 8795      		ror r24
 770 046a AA95      		dec r26
 771 046c 01F4      		brne 1b
 772 046e 9093 0000 		sts blue+1,r25
 773 0472 8093 0000 		sts blue,r24
1129:switcherator.c ****     Red = red;
 774               		.loc 1 1129 0
 775 0476 4093 B400 		sts 180,r20
1130:switcherator.c ****     Green = green;
 776               		.loc 1 1130 0
 777 047a 28BD      		out 0x28,r18
1131:switcherator.c ****     Blue = blue;
 778               		.loc 1 1131 0
 779 047c 87BD      		out 0x27,r24
1132:switcherator.c ****     currentHue++;
 780               		.loc 1 1132 0
 781 047e 8091 0000 		lds r24,currentHue
 782 0482 9091 0000 		lds r25,currentHue+1
 783 0486 0196      		adiw r24,1
 784 0488 9093 0000 		sts currentHue+1,r25
 785 048c 8093 0000 		sts currentHue,r24
 786               	.L36:
 787 0490 0895      		ret
 788               	.LFE28:
 790               	.global	clearTheProgram
 792               	clearTheProgram:
 793               	.LFB32:
1133:switcherator.c **** }
1134:switcherator.c **** 
1135:switcherator.c **** // sets the pwm brightness value
1136:switcherator.c **** // bs 16
1137:switcherator.c **** 
1138:switcherator.c **** void brightnessSet(char * commandReceived) {
1139:switcherator.c ****     int brightValue = getSwitchNumber(commandReceived);
1140:switcherator.c ****     if (brightValue == 0) {
1141:switcherator.c ****         // display the brightness
1142:switcherator.c ****         itoa(oldBright, tempIntString, 10);
1143:switcherator.c ****         statusMsg[0] = 0;
1144:switcherator.c ****         strcat(statusMsg, "Set @");
1145:switcherator.c ****         strcat(statusMsg, tempIntString);
1146:switcherator.c ****         strcat(statusMsg, "B@");
1147:switcherator.c ****         itoa(bright, tempIntString, 10);
1148:switcherator.c ****         strcat(statusMsg, tempIntString);
1149:switcherator.c ****         sendMessage(statusMsg);
1150:switcherator.c ****     } else {
1151:switcherator.c ****         if (brightValue > 16)
1152:switcherator.c ****             brightValue = 16;
1153:switcherator.c ****         if (oldBright == bright) {
1154:switcherator.c ****             // currently not being overridden
1155:switcherator.c ****             bright = brightValue;
1156:switcherator.c ****         }
1157:switcherator.c ****         oldBright = brightValue;
1158:switcherator.c ****         switchChanged = 1;
1159:switcherator.c ****         ok();
1160:switcherator.c ****     }
1161:switcherator.c **** }
1162:switcherator.c **** 
1163:switcherator.c **** 
1164:switcherator.c **** /****************************************************************
1165:switcherator.c ****  *
1166:switcherator.c ****  *              All Things Program Related
1167:switcherator.c ****  *
1168:switcherator.c ****  ****************************************************************/
1169:switcherator.c **** 
1170:switcherator.c **** // programs and such kept in EEPROM
1171:switcherator.c **** // 1 byte day of week mask or 0 for everyday
1172:switcherator.c **** // 2 byte start time (minutes), 2 bytes duration (seconds), 1 byte additional program
1173:switcherator.c **** // If more than 4 switches are desired it will roll over to an additional program
1174:switcherator.c **** // DssddSSSSP
1175:switcherator.c **** // 0123456789   
1176:switcherator.c **** //static unsigned char weeklyProgram[MAX_PROGRAM][10];
1177:switcherator.c **** //uart_puts_P("NewProgram, ClearProg, ProgAddSwitch, ProgDays, ProgTime, ProgDispln PN\r\n");
1178:switcherator.c **** //uart_puts_P("NP:P#HHMMDur. - CP:P# - PA:P#S# PD:P#SMTWTFS-PT:P#HHMMDur. PI:P#\r\n");
1179:switcherator.c **** //uart_puts_P("P#=Prog Num,HH=Hour,MM=Min,Dur.=Duration(min) SMTWTFS=1010000=Sun/Tue\r\n");
1180:switcherator.c **** 
1181:switcherator.c **** // Create a new program
1182:switcherator.c **** // NP:HHMMDur.
1183:switcherator.c **** // 0123456789012
1184:switcherator.c **** 
1185:switcherator.c **** void newProgram(char * commandReceived) {
1186:switcherator.c ****     int programNumber = 255;
1187:switcherator.c ****     int hours = 0;
1188:switcherator.c ****     int minutes = 0;
1189:switcherator.c ****     int startTime = 0;
1190:switcherator.c ****     int duration = 0;
1191:switcherator.c ****     int x = 0;
1192:switcherator.c ****     // find an open program;
1193:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
1194:switcherator.c ****         // dont want it to wrap though 0 is a valid program
1195:switcherator.c ****         if (weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) {
1196:switcherator.c ****             // Use this one
1197:switcherator.c ****             programNumber = x;
1198:switcherator.c ****             // end the loop
1199:switcherator.c ****             break;
1200:switcherator.c ****         }
1201:switcherator.c ****     }
1202:switcherator.c ****     if (programNumber == 255) {
1203:switcherator.c ****         fail(8);
1204:switcherator.c ****         return;
1205:switcherator.c ****     }
1206:switcherator.c ****     clearTheProgram(programNumber);
1207:switcherator.c ****     tempIntString[0] = commandReceived[3];
1208:switcherator.c ****     tempIntString[1] = commandReceived[4];
1209:switcherator.c ****     hours = atoi(tempIntString);
1210:switcherator.c ****     tempIntString[0] = commandReceived[5];
1211:switcherator.c ****     tempIntString[1] = commandReceived[6];
1212:switcherator.c ****     minutes = atoi(tempIntString);
1213:switcherator.c ****     tempLongString[0] = commandReceived[7];
1214:switcherator.c ****     tempLongString[1] = commandReceived[8];
1215:switcherator.c ****     tempLongString[2] = commandReceived[9];
1216:switcherator.c ****     tempLongString[3] = commandReceived[10];
1217:switcherator.c ****     duration = atoi(tempLongString);
1218:switcherator.c ****     if (hours >= 24 || (hours == 0 && commandReceived[4] != '0')) {
1219:switcherator.c ****         fail(9);
1220:switcherator.c ****         return;
1221:switcherator.c ****     }
1222:switcherator.c ****     if (minutes >= 60 || (minutes == 0 && commandReceived[6] != '0')) {
1223:switcherator.c ****         fail(0x0a);
1224:switcherator.c ****         return;
1225:switcherator.c ****     }
1226:switcherator.c ****     if (duration == 0) {
1227:switcherator.c ****         fail(0x0b);
1228:switcherator.c ****         return;
1229:switcherator.c ****     }
1230:switcherator.c ****     duration *= 60; // convert to seconds
1231:switcherator.c ****     startTime = (hours * 60);
1232:switcherator.c ****     startTime += minutes; // stored in minutes
1233:switcherator.c ****     int temp = 0;
1234:switcherator.c ****     temp = (startTime >> 8);
1235:switcherator.c ****     weeklyProgram[programNumber][1] = temp;
1236:switcherator.c ****     temp = (startTime & 0xff);
1237:switcherator.c ****     weeklyProgram[programNumber][2] = temp;
1238:switcherator.c ****     temp = (duration >> 8);
1239:switcherator.c ****     weeklyProgram[programNumber][3] = temp;
1240:switcherator.c ****     temp = (duration & 0xff);
1241:switcherator.c ****     weeklyProgram[programNumber][4] = temp;
1242:switcherator.c ****     statusMsg[0] = 0;
1243:switcherator.c ****     strcat(statusMsg, "New prog#");
1244:switcherator.c ****     returnInt(programNumber, tempIntString);
1245:switcherator.c ****     strcat(statusMsg, tempIntString);
1246:switcherator.c ****     sendMessage(statusMsg);
1247:switcherator.c **** }
1248:switcherator.c **** 
1249:switcherator.c **** // clears an existing program
1250:switcherator.c **** // the clearTheProgram does the work so this is the interface
1251:switcherator.c **** // CP:P#
1252:switcherator.c **** // 01234
1253:switcherator.c **** 
1254:switcherator.c **** void clearProgram(char * commandReceived) {
1255:switcherator.c ****     int programNumber = getSwitchNumber(commandReceived);
1256:switcherator.c ****     if (programNumber >= MAX_PROGRAM || (programNumber == 0 && commandReceived[4] != '0')) {
1257:switcherator.c ****         fail(2);
1258:switcherator.c ****     } else {
1259:switcherator.c ****         itoa(programNumber, tempIntString, 10);
1260:switcherator.c ****         ok();
1261:switcherator.c ****         clearTheProgram(programNumber);
1262:switcherator.c ****     }
1263:switcherator.c **** }
1264:switcherator.c **** 
1265:switcherator.c **** // zeros out the program
1266:switcherator.c **** 
1267:switcherator.c **** void clearTheProgram(int programNumber) {
 794               		.loc 1 1267 0
 795               	.LVL39:
 796               	/* prologue: function */
 797               	/* frame size = 0 */
 798               	/* stack size = 0 */
 799               	.L__stack_usage = 0
 800               		.loc 1 1267 0
 801 0492 2AE0      		ldi r18,lo8(10)
 802 0494 AC01      		movw r20,r24
 803 0496 249F      		mul r18,r20
 804 0498 C001      		movw r24,r0
 805 049a 259F      		mul r18,r21
 806 049c 900D      		add r25,r0
 807 049e 1124      		clr __zero_reg__
 808               	.LVL40:
 809 04a0 8050      		subi r24,lo8(-(weeklyProgram))
 810 04a2 9040      		sbci r25,hi8(-(weeklyProgram))
1268:switcherator.c ****     int x = 0;
1269:switcherator.c ****     // some of these "0" is a valid option so make it 255
1270:switcherator.c ****     for (x = 0; x < 10; x++) {
 811               		.loc 1 1270 0
 812 04a4 20E0      		ldi r18,0
 813 04a6 30E0      		ldi r19,0
1271:switcherator.c ****         weeklyProgram[programNumber][x] = 255;
 814               		.loc 1 1271 0
 815 04a8 4FEF      		ldi r20,lo8(-1)
 816               	.LVL41:
 817               	.L51:
1267:switcherator.c **** void clearTheProgram(int programNumber) {
 818               		.loc 1 1267 0 discriminator 2
 819 04aa FC01      		movw r30,r24
 820 04ac E20F      		add r30,r18
 821 04ae F31F      		adc r31,r19
 822               		.loc 1 1271 0 discriminator 2
 823 04b0 4083      		st Z,r20
1270:switcherator.c ****     for (x = 0; x < 10; x++) {
 824               		.loc 1 1270 0 discriminator 2
 825 04b2 2F5F      		subi r18,-1
 826 04b4 3F4F      		sbci r19,-1
 827               	.LVL42:
 828 04b6 2A30      		cpi r18,10
 829 04b8 3105      		cpc r19,__zero_reg__
 830 04ba 01F4      		brne .L51
 831               	/* epilogue start */
1272:switcherator.c ****     }
1273:switcherator.c **** }
 832               		.loc 1 1273 0
 833 04bc 0895      		ret
 834               	.LFE32:
 836               	.global	findOpenSwitch
 838               	findOpenSwitch:
 839               	.LFB34:
1274:switcherator.c **** 
1275:switcherator.c **** // there are multiple switches per program.  This adds them.
1276:switcherator.c **** // For memory constraints each program natively has up to 4
1277:switcherator.c **** // switches.  For more than that another program will be linked
1278:switcherator.c **** // Program in memory:
1279:switcherator.c **** // DssddSSSSP
1280:switcherator.c **** // 0123456789
1281:switcherator.c **** // PA:P#S#
1282:switcherator.c **** // 0123456
1283:switcherator.c **** 
1284:switcherator.c **** void programAddSwitch(char * commandReceived) {
1285:switcherator.c ****     int programNumber = 0;
1286:switcherator.c ****     int switchNumber = 0;
1287:switcherator.c ****     tempIntString[0] = commandReceived[3];
1288:switcherator.c ****     tempIntString[1] = commandReceived[4];
1289:switcherator.c ****     programNumber = atoi(tempIntString);
1290:switcherator.c ****     tempIntString[0] = commandReceived[5];
1291:switcherator.c ****     tempIntString[1] = commandReceived[6];
1292:switcherator.c ****     switchNumber = atoi(tempIntString);
1293:switcherator.c ****     char switches[NUM_SWITCHES];
1294:switcherator.c ****     switches[0] = 0;
1295:switcherator.c ****     int switchCount = programGetSwitches(programNumber, switches);
1296:switcherator.c ****     int x = 0;
1297:switcherator.c ****     // see if the switch is already there
1298:switcherator.c ****     for (x = 0; x < switchCount; x++) {
1299:switcherator.c ****         if (switches[x] == switchNumber) {
1300:switcherator.c ****             fail(0x0c);
1301:switcherator.c ****             return;
1302:switcherator.c ****         }
1303:switcherator.c ****     }
1304:switcherator.c **** 
1305:switcherator.c ****     // check validity 
1306:switcherator.c ****     if ((programNumber >= MAX_PROGRAM) || (programNumber == 0 && commandReceived[4] != '0')) {
1307:switcherator.c ****         fail(2);
1308:switcherator.c ****         return;
1309:switcherator.c ****     }
1310:switcherator.c ****     if ((switchNumber >= NUM_SWITCHES) || (switchNumber == 0 && commandReceived[6] != '0')) {
1311:switcherator.c ****         fail(1);
1312:switcherator.c ****         return;
1313:switcherator.c ****     }
1314:switcherator.c ****     // check for valid program
1315:switcherator.c ****     // The day mask maxes out at 127 - the high but shouldn't be set if it is valid
1316:switcherator.c ****     // unless it is a overflow program in which case the first switch will be set
1317:switcherator.c ****     // 255 = not set
1318:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
1319:switcherator.c ****         fail(0x0d);
1320:switcherator.c ****         return;
1321:switcherator.c ****     }
1322:switcherator.c ****     int noSwitchYet = 1;
1323:switcherator.c ****     int blankSwitch = 0;
1324:switcherator.c ****     int overflowProgram = 255;
1325:switcherator.c ****     // prepare number string for output later
1326:switcherator.c ****     itoa(programNumber, tempIntString, 10);
1327:switcherator.c ****     // see if our program has a valid switch
1328:switcherator.c ****     blankSwitch = findOpenSwitch(programNumber);
1329:switcherator.c ****     while (noSwitchYet == 1) {
1330:switcherator.c ****         if (blankSwitch == 0) {
1331:switcherator.c ****             // our program is full.  Find or make another one
1332:switcherator.c ****             // first check if we already are overflowing.
1333:switcherator.c ****             overflowProgram = weeklyProgram[programNumber][9];
1334:switcherator.c ****             if (overflowProgram == 255) {
1335:switcherator.c ****                 // no overflow.  Need to create one.
1336:switcherator.c ****                 // find blank program slot
1337:switcherator.c ****                 int possibleBlank = 255;
1338:switcherator.c ****                 // yeah I know but programNumber 0 won't be an overflow so there
1339:switcherator.c ****                 for (x = (MAX_PROGRAM - 1); x > 0; x--) {
1340:switcherator.c ****                     // dont want it to wrap though 0 is a valid program
1341:switcherator.c ****                     if (weeklyProgram[x][0] == 255 && weeklyProgram[x][5] == 255) {
1342:switcherator.c ****                         // this is blank
1343:switcherator.c ****                         possibleBlank = x;
1344:switcherator.c ****                         // end the loop
1345:switcherator.c ****                         x = 0;
1346:switcherator.c ****                     }
1347:switcherator.c ****                 }
1348:switcherator.c ****                 if (possibleBlank == 255) {
1349:switcherator.c ****                     // oh oh, no room
1350:switcherator.c ****                     fail(0x0e);
1351:switcherator.c ****                     return;
1352:switcherator.c ****                 }
1353:switcherator.c ****                 // now record the overflow and move forward
1354:switcherator.c ****                 weeklyProgram[programNumber][9] = possibleBlank;
1355:switcherator.c ****                 programNumber = possibleBlank;
1356:switcherator.c ****                 // and now we loop again...
1357:switcherator.c ****             } else {
1358:switcherator.c ****                 // move to overflow program and try again
1359:switcherator.c ****                 programNumber = overflowProgram;
1360:switcherator.c ****             }
1361:switcherator.c ****         } else { // if(blankSwitch == 0)
1362:switcherator.c ****             // we have a program and a slot.  move on.
1363:switcherator.c ****             noSwitchYet = 0;
1364:switcherator.c ****         }
1365:switcherator.c ****     }
1366:switcherator.c ****     weeklyProgram[programNumber][blankSwitch] = switchNumber;
1367:switcherator.c ****     ok();
1368:switcherator.c **** }
1369:switcherator.c **** 
1370:switcherator.c **** // iterates through a program and returns the index of an open switch or 0 if none
1371:switcherator.c **** 
1372:switcherator.c **** int findOpenSwitch(int programNumber) {
 840               		.loc 1 1372 0
 841               	.LVL43:
 842               	/* prologue: function */
 843               	/* frame size = 0 */
 844               	/* stack size = 0 */
 845               	.L__stack_usage = 0
 846               		.loc 1 1372 0
 847 04be 2AE0      		ldi r18,lo8(10)
 848 04c0 AC01      		movw r20,r24
 849 04c2 249F      		mul r18,r20
 850 04c4 C001      		movw r24,r0
 851 04c6 259F      		mul r18,r21
 852 04c8 900D      		add r25,r0
 853 04ca 1124      		clr __zero_reg__
 854               	.LVL44:
 855 04cc 8050      		subi r24,lo8(-(weeklyProgram))
 856 04ce 9040      		sbci r25,hi8(-(weeklyProgram))
1373:switcherator.c ****     int switchIndex = 0;
1374:switcherator.c ****     int x = 0;
1375:switcherator.c ****     for (x = 5; x < 9; x++) {
 857               		.loc 1 1375 0
 858 04d0 25E0      		ldi r18,lo8(5)
 859 04d2 30E0      		ldi r19,0
 860               	.LVL45:
 861               	.L55:
1372:switcherator.c **** int findOpenSwitch(int programNumber) {
 862               		.loc 1 1372 0
 863 04d4 FC01      		movw r30,r24
 864 04d6 E20F      		add r30,r18
 865 04d8 F31F      		adc r31,r19
1376:switcherator.c ****         if (weeklyProgram[programNumber][x] == 255) {
 866               		.loc 1 1376 0
 867 04da 4081      		ld r20,Z
 868 04dc 4F3F      		cpi r20,lo8(-1)
 869 04de 01F0      		breq .L54
1375:switcherator.c ****     for (x = 5; x < 9; x++) {
 870               		.loc 1 1375 0
 871 04e0 2F5F      		subi r18,-1
 872 04e2 3F4F      		sbci r19,-1
 873               	.LVL46:
 874 04e4 2930      		cpi r18,9
 875 04e6 3105      		cpc r19,__zero_reg__
 876 04e8 01F4      		brne .L55
1377:switcherator.c ****             // blank switch
1378:switcherator.c ****             switchIndex = x;
1379:switcherator.c ****             return switchIndex;
1380:switcherator.c ****         }
1381:switcherator.c ****     }
1382:switcherator.c ****     return 0;
 877               		.loc 1 1382 0
 878 04ea 20E0      		ldi r18,0
 879 04ec 30E0      		ldi r19,0
 880               	.LVL47:
 881               	.L54:
1383:switcherator.c **** }
 882               		.loc 1 1383 0
 883 04ee C901      		movw r24,r18
 884 04f0 0895      		ret
 885               	.LFE34:
 887               	.global	programGetSwitches
 889               	programGetSwitches:
 890               	.LFB38:
1384:switcherator.c **** 
1385:switcherator.c **** // Sets the days a program will run
1386:switcherator.c **** // PD:P#SMTWTFS
1387:switcherator.c **** // 012345678901
1388:switcherator.c **** 
1389:switcherator.c **** void programSetDays(char * commandReceived) {
1390:switcherator.c ****     char tempReallyLongString[] = "0000000";
1391:switcherator.c ****     int programNumber = 0;
1392:switcherator.c ****     long weekLong = 0;
1393:switcherator.c ****     tempIntString[0] = commandReceived[3];
1394:switcherator.c ****     tempIntString[1] = commandReceived[4];
1395:switcherator.c ****     programNumber = atoi(tempIntString);
1396:switcherator.c ****     tempReallyLongString[0] = commandReceived[5];
1397:switcherator.c ****     tempReallyLongString[1] = commandReceived[6];
1398:switcherator.c ****     tempReallyLongString[2] = commandReceived[7];
1399:switcherator.c ****     tempReallyLongString[3] = commandReceived[8];
1400:switcherator.c ****     tempReallyLongString[4] = commandReceived[9];
1401:switcherator.c ****     tempReallyLongString[5] = commandReceived[10];
1402:switcherator.c ****     tempReallyLongString[6] = commandReceived[11];
1403:switcherator.c ****     weekLong = strtol(tempReallyLongString, 0, 2);
1404:switcherator.c ****     if ((programNumber >= MAX_PROGRAM) || (programNumber == 0 && commandReceived[4] != '0')) {
1405:switcherator.c ****         fail(2);
1406:switcherator.c ****         return;
1407:switcherator.c ****     }
1408:switcherator.c ****     // check for valid program
1409:switcherator.c ****     // The day mask maxes out at 127 - the high but shouldn't be set if it is valid
1410:switcherator.c ****     // unless it is a overflow program in which case the first switch will be set
1411:switcherator.c ****     // 255 = not set
1412:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
1413:switcherator.c ****         fail(0x0d);
1414:switcherator.c ****         return;
1415:switcherator.c ****     }
1416:switcherator.c ****     if ((weekLong & 0x7f) == 0) {
1417:switcherator.c ****         fail(0x0f);
1418:switcherator.c ****         return;
1419:switcherator.c ****     }
1420:switcherator.c ****     char weekdays = (weekLong & 0x7f);
1421:switcherator.c ****     weeklyProgram[programNumber][0] = weekdays;
1422:switcherator.c ****     ok();
1423:switcherator.c **** }
1424:switcherator.c **** 
1425:switcherator.c **** // DssddSSSSP
1426:switcherator.c **** // 0123456789   
1427:switcherator.c **** // PT:P#HHMMDur.
1428:switcherator.c **** // 0123456789012
1429:switcherator.c **** 
1430:switcherator.c **** void programSetTime(char * commandReceived) {
1431:switcherator.c ****     int programNumber = 0;
1432:switcherator.c ****     int hours = 0;
1433:switcherator.c ****     int minutes = 0;
1434:switcherator.c ****     int startTime = 0;
1435:switcherator.c ****     int duration = 0;
1436:switcherator.c ****     tempIntString[0] = commandReceived[3];
1437:switcherator.c ****     tempIntString[1] = commandReceived[4];
1438:switcherator.c ****     programNumber = atoi(tempIntString);
1439:switcherator.c ****     if (programNumber >= MAX_PROGRAM || (programNumber == 0 && commandReceived[4] != '0')) {
1440:switcherator.c ****         fail(2);
1441:switcherator.c ****         return;
1442:switcherator.c ****     }
1443:switcherator.c ****     // check for valid program
1444:switcherator.c ****     // The day mask maxes out at 127 - the high but shouldn't be set if it is valid
1445:switcherator.c ****     // unless it is a overflow program in which case the first switch will be set
1446:switcherator.c ****     // 255 = not set
1447:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
1448:switcherator.c ****         fail(0x0d);
1449:switcherator.c ****         return;
1450:switcherator.c ****     }
1451:switcherator.c ****     tempIntString[0] = commandReceived[5];
1452:switcherator.c ****     tempIntString[1] = commandReceived[6];
1453:switcherator.c ****     hours = atoi(tempIntString);
1454:switcherator.c ****     tempIntString[0] = commandReceived[7];
1455:switcherator.c ****     tempIntString[1] = commandReceived[8];
1456:switcherator.c ****     minutes = atoi(tempIntString);
1457:switcherator.c ****     tempLongString[0] = commandReceived[9];
1458:switcherator.c ****     tempLongString[1] = commandReceived[10];
1459:switcherator.c ****     tempLongString[2] = commandReceived[11];
1460:switcherator.c ****     tempLongString[3] = commandReceived[12];
1461:switcherator.c ****     duration = atoi(tempLongString);
1462:switcherator.c ****     if (hours >= 24 || (hours == 0 && commandReceived[6] != '0')) {
1463:switcherator.c ****         fail(9);
1464:switcherator.c ****         return;
1465:switcherator.c ****     }
1466:switcherator.c ****     if (minutes >= 60 || (minutes == 0 && commandReceived[8] != '0')) {
1467:switcherator.c ****         fail(0x0a);
1468:switcherator.c ****         return;
1469:switcherator.c ****     }
1470:switcherator.c ****     if (duration == 0) {
1471:switcherator.c ****         fail(0x0b);
1472:switcherator.c ****         return;
1473:switcherator.c ****     }
1474:switcherator.c ****     duration *= 60; // convert to seconds
1475:switcherator.c ****     startTime = (hours * 60);
1476:switcherator.c ****     startTime += minutes; // stored in minutes
1477:switcherator.c ****     int temp = 0;
1478:switcherator.c ****     temp = (startTime >> 8);
1479:switcherator.c ****     weeklyProgram[programNumber][1] = temp;
1480:switcherator.c ****     temp = (startTime & 0xff);
1481:switcherator.c ****     weeklyProgram[programNumber][2] = temp;
1482:switcherator.c ****     temp = (duration >> 8);
1483:switcherator.c ****     weeklyProgram[programNumber][3] = temp;
1484:switcherator.c ****     temp = (duration & 0xff);
1485:switcherator.c ****     weeklyProgram[programNumber][4] = temp;
1486:switcherator.c ****     ok();
1487:switcherator.c **** }
1488:switcherator.c **** 
1489:switcherator.c **** void programDisplay(char * commandReceived) {
1490:switcherator.c ****     int x = 0;
1491:switcherator.c ****     int programNumber = 0;
1492:switcherator.c ****     tempIntString[0] = commandReceived[3];
1493:switcherator.c ****     tempIntString[1] = commandReceived[4];
1494:switcherator.c ****     programNumber = atoi(tempIntString);
1495:switcherator.c ****     statusMsg[0] = 0;
1496:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
1497:switcherator.c ****         strcat(statusMsg, "Prog#");
1498:switcherator.c ****         returnInt(programNumber, tempIntString);
1499:switcherator.c ****         strcat(statusMsg, tempIntString);
1500:switcherator.c ****         strcat(statusMsg, "blank.");
1501:switcherator.c ****         sendMessage(statusMsg);
1502:switcherator.c ****         return;
1503:switcherator.c ****     }
1504:switcherator.c ****     char switches[NUM_SWITCHES];
1505:switcherator.c ****     switches[0] = 0;
1506:switcherator.c ****     int switchCount = 0;
1507:switcherator.c ****     switchCount = programGetSwitches(programNumber, switches);
1508:switcherator.c ****     statusMsg[0] = 0;
1509:switcherator.c ****     strcat(statusMsg, "Prog#");
1510:switcherator.c ****     itoa(programNumber, tempIntString, 10);
1511:switcherator.c ****     strcat(statusMsg, tempIntString);
1512:switcherator.c ****     if (switchCount == 0) {
1513:switcherator.c ****         strcat(switches, "S:-");
1514:switcherator.c ****     } else {
1515:switcherator.c ****         int temp = 0;
1516:switcherator.c ****         strcat(statusMsg, "S");
1517:switcherator.c ****         for (x = 0; x < switchCount; x++) {
1518:switcherator.c ****             if(strlen(statusMsg)>30) {
1519:switcherator.c ****                 sendMessage(statusMsg);
1520:switcherator.c ****                 statusMsg[6] = 0;
1521:switcherator.c ****             }
1522:switcherator.c ****             strcat(statusMsg, ":");
1523:switcherator.c ****             temp = switches[x];
1524:switcherator.c ****             itoa(temp, tempIntString, 10);
1525:switcherator.c ****             strcat(statusMsg, tempIntString);
1526:switcherator.c ****         }
1527:switcherator.c ****     }
1528:switcherator.c ****     sendMessage(statusMsg);
1529:switcherator.c ****     statusMsg[0] = 0;
1530:switcherator.c ****     unsigned int time = 0;
1531:switcherator.c ****     time = weeklyProgram[programNumber][1];
1532:switcherator.c ****     time <<= 8;
1533:switcherator.c ****     time |= weeklyProgram[programNumber][2];
1534:switcherator.c ****     unsigned int hours = (time / 60);
1535:switcherator.c ****     unsigned int minutes = (time - (hours * 60));
1536:switcherator.c ****     time = weeklyProgram[programNumber][3];
1537:switcherator.c ****     time <<= 8;
1538:switcherator.c ****     time |= weeklyProgram[programNumber][4];
1539:switcherator.c ****     int duration = (time / 60);
1540:switcherator.c ****     char weekdays = 0;
1541:switcherator.c ****     weekdays = weeklyProgram[programNumber][0];
1542:switcherator.c ****     strcat(statusMsg, "T-");
1543:switcherator.c ****     itoa(hours, tempIntString, 10);
1544:switcherator.c ****     strcat(statusMsg, tempIntString);
1545:switcherator.c ****     strcat(statusMsg, ":");
1546:switcherator.c ****     itoa(minutes, tempIntString, 10);
1547:switcherator.c ****     strcat(statusMsg, tempIntString);
1548:switcherator.c ****     strcat(statusMsg, " Dur:");
1549:switcherator.c ****     itoa(duration, tempLongString, 10);
1550:switcherator.c ****     strcat(statusMsg, tempLongString);
1551:switcherator.c ****     strcat(statusMsg, " D:");
1552:switcherator.c ****     if (weekdays == 255) {
1553:switcherator.c ****         strcat(statusMsg, "-------");
1554:switcherator.c ****         sendMessage(statusMsg);
1555:switcherator.c ****         return;
1556:switcherator.c ****     }
1557:switcherator.c ****     if (weekdays & 0x40) {
1558:switcherator.c ****         strcat(statusMsg, "S");
1559:switcherator.c ****     } else {
1560:switcherator.c ****         strcat(statusMsg, "-");
1561:switcherator.c ****     }
1562:switcherator.c ****     if (weekdays & 0x20) {
1563:switcherator.c ****         strcat(statusMsg, "M");
1564:switcherator.c ****     } else {
1565:switcherator.c ****         strcat(statusMsg, "-");
1566:switcherator.c ****     }
1567:switcherator.c ****     if (weekdays & 0x10) {
1568:switcherator.c ****         strcat(statusMsg, "T");
1569:switcherator.c ****     } else {
1570:switcherator.c ****         strcat(statusMsg, "-");
1571:switcherator.c ****     }
1572:switcherator.c ****     if (weekdays & 0x08) {
1573:switcherator.c ****         strcat(statusMsg, "W");
1574:switcherator.c ****     } else {
1575:switcherator.c ****         strcat(statusMsg, "-");
1576:switcherator.c ****     }
1577:switcherator.c ****     if (weekdays & 0x04) {
1578:switcherator.c ****         strcat(statusMsg, "T");
1579:switcherator.c ****     } else {
1580:switcherator.c ****         strcat(statusMsg, "-");
1581:switcherator.c ****     }
1582:switcherator.c ****     if (weekdays & 0x02) {
1583:switcherator.c ****         strcat(statusMsg, "F");
1584:switcherator.c ****     } else {
1585:switcherator.c ****         strcat(statusMsg, "-");
1586:switcherator.c ****     }
1587:switcherator.c ****     if (weekdays & 0x01) {
1588:switcherator.c ****         strcat(statusMsg, "S");
1589:switcherator.c ****     } else {
1590:switcherator.c ****         strcat(statusMsg, "-");
1591:switcherator.c ****     }
1592:switcherator.c **** 
1593:switcherator.c ****     sendMessage(statusMsg);
1594:switcherator.c **** }
1595:switcherator.c **** 
1596:switcherator.c **** // get the switches for a program
1597:switcherator.c **** // char * switches should be set as large as NUM_SWITCHES
1598:switcherator.c **** // so you don't overflow
1599:switcherator.c **** 
1600:switcherator.c **** int programGetSwitches(int programNumber, char * switches) {
 891               		.loc 1 1600 0
 892               	.LVL48:
 893 04f2 CF93      		push r28
 894               	.LCFI8:
 895 04f4 DF93      		push r29
 896               	.LCFI9:
 897               	/* prologue: function */
 898               	/* frame size = 0 */
 899               	/* stack size = 2 */
 900               	.L__stack_usage = 2
 901               	.LVL49:
1601:switcherator.c ****     int element = 0;
 902               		.loc 1 1601 0
 903 04f6 20E0      		ldi r18,0
 904 04f8 30E0      		ldi r19,0
1600:switcherator.c **** int programGetSwitches(int programNumber, char * switches) {
 905               		.loc 1 1600 0
 906 04fa CAE0      		ldi r28,lo8(10)
 907               	.LVL50:
 908               	.L61:
 909 04fc F901      		movw r30,r18
 910 04fe 3496      		adiw r30,4
 911 0500 C89F      		mul r28,r24
 912 0502 A001      		movw r20,r0
 913 0504 C99F      		mul r28,r25
 914 0506 500D      		add r21,r0
 915 0508 1124      		clr __zero_reg__
 916 050a 421B      		sub r20,r18
 917 050c 530B      		sbc r21,r19
 918 050e 4050      		subi r20,lo8(-(weeklyProgram))
 919 0510 5040      		sbci r21,hi8(-(weeklyProgram))
 920               	.LVL51:
 921               	.L60:
 922 0512 DA01      		movw r26,r20
 923 0514 A20F      		add r26,r18
 924 0516 B31F      		adc r27,r19
1602:switcherator.c ****     int x = 0;
1603:switcherator.c ****     // start loading the switch array
1604:switcherator.c ****     while (1) {
1605:switcherator.c ****         for (x = 5; x < 9; x++) {
1606:switcherator.c ****             if (weeklyProgram[programNumber][x] == 255) {
 925               		.loc 1 1606 0
 926 0518 1596      		adiw r26,5
 927 051a DC91      		ld r29,X
 928 051c DF3F      		cpi r29,lo8(-1)
 929 051e 01F0      		breq .L59
1600:switcherator.c **** int programGetSwitches(int programNumber, char * switches) {
 930               		.loc 1 1600 0
 931 0520 DB01      		movw r26,r22
 932 0522 A20F      		add r26,r18
 933 0524 B31F      		adc r27,r19
1607:switcherator.c ****                 // blank switch we are done
1608:switcherator.c ****                 return element;
1609:switcherator.c ****             } else {
1610:switcherator.c ****                 switches[element] = weeklyProgram[programNumber][x];
 934               		.loc 1 1610 0
 935 0526 DC93      		st X,r29
1611:switcherator.c ****                 element++;
 936               		.loc 1 1611 0
 937 0528 2F5F      		subi r18,-1
 938 052a 3F4F      		sbci r19,-1
 939               	.LVL52:
1605:switcherator.c ****         for (x = 5; x < 9; x++) {
 940               		.loc 1 1605 0
 941 052c 2E17      		cp r18,r30
 942 052e 3F07      		cpc r19,r31
 943 0530 01F4      		brne .L60
1612:switcherator.c ****             }
1613:switcherator.c ****         } // for x=5-9
1614:switcherator.c ****         // see if this program iterates around
1615:switcherator.c ****         if (weeklyProgram[programNumber][9] == 255) {
 944               		.loc 1 1615 0
 945 0532 C89F      		mul r28,r24
 946 0534 F001      		movw r30,r0
 947 0536 C99F      		mul r28,r25
 948 0538 F00D      		add r31,r0
 949 053a 1124      		clr __zero_reg__
 950 053c E050      		subi r30,lo8(-(weeklyProgram))
 951 053e F040      		sbci r31,hi8(-(weeklyProgram))
 952 0540 8185      		ldd r24,Z+9
 953               	.LVL53:
 954 0542 8F3F      		cpi r24,lo8(-1)
 955 0544 01F0      		breq .L59
1616:switcherator.c ****             // we are done;
1617:switcherator.c ****             return element;
1618:switcherator.c ****         } else {
1619:switcherator.c ****             // move to the next programNumber and continue
1620:switcherator.c ****             programNumber = weeklyProgram[programNumber][9];
 956               		.loc 1 1620 0
 957 0546 90E0      		ldi r25,0
 958               	.LVL54:
1621:switcherator.c ****         }
1622:switcherator.c ****     }
 959               		.loc 1 1622 0
 960 0548 00C0      		rjmp .L61
 961               	.LVL55:
 962               	.L59:
1623:switcherator.c **** }
 963               		.loc 1 1623 0
 964 054a C901      		movw r24,r18
 965               	/* epilogue start */
 966 054c DF91      		pop r29
 967 054e CF91      		pop r28
 968 0550 0895      		ret
 969               	.LFE38:
 971               	.global	startTheProgram
 973               	startTheProgram:
 974               	.LFB40:
1624:switcherator.c **** 
1625:switcherator.c **** // takes in a program number and time and turns on the program
1626:switcherator.c **** // SP P#Durat.
1627:switcherator.c **** // 01234567890
1628:switcherator.c **** 
1629:switcherator.c **** void startProgram(char * commandReceived) {
1630:switcherator.c ****     unsigned long duration;
1631:switcherator.c ****     int programNumber = 0;
1632:switcherator.c ****     // get switch number
1633:switcherator.c ****     tempIntString[0] = commandReceived[3];
1634:switcherator.c ****     tempIntString[1] = commandReceived[4];
1635:switcherator.c ****     programNumber = atoi(tempIntString);
1636:switcherator.c ****     if (programNumber >= MAX_PROGRAM) {
1637:switcherator.c ****         fail(2);
1638:switcherator.c ****         return;
1639:switcherator.c ****     }
1640:switcherator.c ****     // get duration
1641:switcherator.c ****     tempHugeString[0] = commandReceived[5];
1642:switcherator.c ****     tempHugeString[1] = commandReceived[6];
1643:switcherator.c ****     tempHugeString[2] = commandReceived[7];
1644:switcherator.c ****     tempHugeString[3] = commandReceived[8];
1645:switcherator.c ****     tempHugeString[4] = commandReceived[9];
1646:switcherator.c ****     tempHugeString[5] = commandReceived[10];
1647:switcherator.c ****     duration = atol(tempHugeString);
1648:switcherator.c ****     startTheProgram(programNumber, duration, 0);
1649:switcherator.c ****     ok();
1650:switcherator.c **** }
1651:switcherator.c **** 
1652:switcherator.c **** void startTheProgram(int programNumber, int duration, long time) {
 975               		.loc 1 1652 0
 976               	.LVL56:
 977 0552 8F92      		push r8
 978               	.LCFI10:
 979 0554 9F92      		push r9
 980               	.LCFI11:
 981 0556 AF92      		push r10
 982               	.LCFI12:
 983 0558 BF92      		push r11
 984               	.LCFI13:
 985 055a CF92      		push r12
 986               	.LCFI14:
 987 055c DF92      		push r13
 988               	.LCFI15:
 989 055e EF92      		push r14
 990               	.LCFI16:
 991 0560 FF92      		push r15
 992               	.LCFI17:
 993 0562 1F93      		push r17
 994               	.LCFI18:
 995 0564 CF93      		push r28
 996               	.LCFI19:
 997 0566 DF93      		push r29
 998               	.LCFI20:
 999 0568 CDB7      		in r28,__SP_L__
 1000 056a DEB7      		in r29,__SP_H__
 1001               	.LCFI21:
 1002 056c 6497      		sbiw r28,20
 1003               	.LCFI22:
 1004 056e 0FB6      		in __tmp_reg__,__SREG__
 1005 0570 F894      		cli
 1006 0572 DEBF      		out __SP_H__,r29
 1007 0574 0FBE      		out __SREG__,__tmp_reg__
 1008 0576 CDBF      		out __SP_L__,r28
 1009               	/* prologue: function */
 1010               	/* frame size = 20 */
 1011               	/* stack size = 31 */
 1012               	.L__stack_usage = 31
 1013 0578 4B01      		movw r8,r22
 1014               	.LVL57:
1653:switcherator.c ****     char switches[NUM_SWITCHES];
1654:switcherator.c ****     int switchCount = 0;
1655:switcherator.c ****     int thisSwitch = 0;
1656:switcherator.c ****     int x = 0;
1657:switcherator.c **** 
1658:switcherator.c ****     if (duration == 0) {
 1015               		.loc 1 1658 0
 1016 057a 6115      		cp r22,__zero_reg__
 1017 057c 7105      		cpc r23,__zero_reg__
 1018 057e 01F4      		brne .L70
 1019               	.LVL58:
1659:switcherator.c ****         // get the duration since we weren't fed it
1660:switcherator.c ****         duration = weeklyProgram[programNumber][3];
1661:switcherator.c ****         duration <<= 8;
1662:switcherator.c ****         duration = weeklyProgram[programNumber][4];
 1020               		.loc 1 1662 0
 1021 0580 6AE0      		ldi r22,lo8(10)
 1022 0582 689F      		mul r22,r24
 1023 0584 F001      		movw r30,r0
 1024 0586 699F      		mul r22,r25
 1025 0588 F00D      		add r31,r0
 1026 058a 1124      		clr __zero_reg__
 1027 058c E050      		subi r30,lo8(-(weeklyProgram))
 1028 058e F040      		sbci r31,hi8(-(weeklyProgram))
 1029 0590 8480      		ldd r8,Z+4
 1030 0592 912C      		mov r9,__zero_reg__
 1031               	.LVL59:
 1032               	.L70:
1663:switcherator.c ****     }
1664:switcherator.c ****     switchCount = programGetSwitches(programNumber, switches);
 1033               		.loc 1 1664 0
 1034 0594 BE01      		movw r22,r28
 1035 0596 6F5F      		subi r22,-1
 1036 0598 7F4F      		sbci r23,-1
 1037 059a 298B      		std Y+17,r18
 1038 059c 3A8B      		std Y+18,r19
 1039 059e 4B8B      		std Y+19,r20
 1040 05a0 5C8B      		std Y+20,r21
 1041 05a2 0E94 0000 		call programGetSwitches
 1042               	.LVL60:
 1043 05a6 AA24      		clr r10
 1044 05a8 97FC      		sbrc r9,7
 1045 05aa A094      		com r10
 1046 05ac BA2C      		mov r11,r10
 1047 05ae C090 0000 		lds r12,weeklySeconds
 1048 05b2 D090 0000 		lds r13,weeklySeconds+1
 1049 05b6 E090 0000 		lds r14,weeklySeconds+2
 1050 05ba F090 0000 		lds r15,weeklySeconds+3
1665:switcherator.c ****     // see if we were fed the start time so we don't go too long
1666:switcherator.c ****     // this may run multiple times
1667:switcherator.c ****     if (time == 0) {
 1051               		.loc 1 1667 0
 1052 05be 2989      		ldd r18,Y+17
 1053 05c0 3A89      		ldd r19,Y+18
 1054 05c2 4B89      		ldd r20,Y+19
 1055 05c4 5C89      		ldd r21,Y+20
 1056 05c6 2115      		cp r18,__zero_reg__
 1057 05c8 3105      		cpc r19,__zero_reg__
 1058 05ca 4105      		cpc r20,__zero_reg__
 1059 05cc 5105      		cpc r21,__zero_reg__
 1060 05ce 01F4      		brne .L71
1668:switcherator.c ****         time = weeklySeconds + duration;
 1061               		.loc 1 1668 0
 1062 05d0 A501      		movw r20,r10
 1063 05d2 9401      		movw r18,r8
 1064 05d4 2C0D      		add r18,r12
 1065 05d6 3D1D      		adc r19,r13
 1066 05d8 4E1D      		adc r20,r14
 1067 05da 5F1D      		adc r21,r15
 1068               	.LVL61:
 1069               	.L71:
1669:switcherator.c ****     }
1670:switcherator.c ****     for (x = 0; x < switchCount; x++) {
1671:switcherator.c ****         thisSwitch = switches[x];
1672:switcherator.c ****         // only update the time if it is longer than what the switch is already turned on to
1673:switcherator.c ****         if ((weeklySeconds + duration) > switchStatus[thisSwitch])
 1070               		.loc 1 1673 0
 1071 05dc C80C      		add r12,r8
 1072 05de D91C      		adc r13,r9
 1073 05e0 EA1C      		adc r14,r10
 1074 05e2 FB1C      		adc r15,r11
 1075 05e4 FE01      		movw r30,r28
 1076 05e6 3196      		adiw r30,1
1652:switcherator.c **** void startTheProgram(int programNumber, int duration, long time) {
 1077               		.loc 1 1652 0
 1078 05e8 BF01      		movw r22,r30
1670:switcherator.c ****     for (x = 0; x < switchCount; x++) {
 1079               		.loc 1 1670 0
 1080 05ea 00C0      		rjmp .L77
 1081               	.LVL62:
 1082               	.L74:
1671:switcherator.c ****         thisSwitch = switches[x];
 1083               		.loc 1 1671 0
 1084 05ec A191      		ld r26,Z+
 1085               	.LVL63:
 1086               		.loc 1 1673 0
 1087 05ee 14E0      		ldi r17,lo8(4)
 1088 05f0 A19F      		mul r26,r17
 1089 05f2 D001      		movw r26,r0
 1090 05f4 1124      		clr __zero_reg__
 1091               	.LVL64:
 1092 05f6 A050      		subi r26,lo8(-(switchStatus))
 1093 05f8 B040      		sbci r27,hi8(-(switchStatus))
 1094 05fa 8D90      		ld r8,X+
 1095 05fc 9D90      		ld r9,X+
 1096 05fe AD90      		ld r10,X+
 1097 0600 BC90      		ld r11,X
 1098 0602 1397      		sbiw r26,3
 1099 0604 8C14      		cp r8,r12
 1100 0606 9D04      		cpc r9,r13
 1101 0608 AE04      		cpc r10,r14
 1102 060a BF04      		cpc r11,r15
 1103 060c 00F4      		brsh .L77
1674:switcherator.c ****             switchStatus[thisSwitch] = time;
 1104               		.loc 1 1674 0
 1105 060e 2D93      		st X+,r18
 1106 0610 3D93      		st X+,r19
 1107 0612 4D93      		st X+,r20
 1108 0614 5C93      		st X,r21
 1109 0616 1397      		sbiw r26,3
 1110               	.LVL65:
 1111               	.L77:
1652:switcherator.c **** void startTheProgram(int programNumber, int duration, long time) {
 1112               		.loc 1 1652 0 discriminator 1
 1113 0618 DF01      		movw r26,r30
 1114 061a A61B      		sub r26,r22
 1115 061c B70B      		sbc r27,r23
1670:switcherator.c ****     for (x = 0; x < switchCount; x++) {
 1116               		.loc 1 1670 0 discriminator 1
 1117 061e A817      		cp r26,r24
 1118 0620 B907      		cpc r27,r25
 1119 0622 04F0      		brlt .L74
1675:switcherator.c ****     }
1676:switcherator.c ****     switchChanged = 1;
 1120               		.loc 1 1676 0
 1121 0624 81E0      		ldi r24,lo8(1)
 1122               	.LVL66:
 1123 0626 8093 0000 		sts switchChanged,r24
 1124               	/* epilogue start */
1677:switcherator.c **** }
 1125               		.loc 1 1677 0
 1126 062a 6496      		adiw r28,20
 1127 062c 0FB6      		in __tmp_reg__,__SREG__
 1128 062e F894      		cli
 1129 0630 DEBF      		out __SP_H__,r29
 1130 0632 0FBE      		out __SREG__,__tmp_reg__
 1131 0634 CDBF      		out __SP_L__,r28
 1132 0636 DF91      		pop r29
 1133 0638 CF91      		pop r28
 1134 063a 1F91      		pop r17
 1135 063c FF90      		pop r15
 1136 063e EF90      		pop r14
 1137 0640 DF90      		pop r13
 1138 0642 CF90      		pop r12
 1139 0644 BF90      		pop r11
 1140 0646 AF90      		pop r10
 1141 0648 9F90      		pop r9
 1142 064a 8F90      		pop r8
 1143 064c 0895      		ret
 1144               	.LFE40:
 1146               	.global	readEEPROM
 1148               	readEEPROM:
 1149               	.LFB42:
1678:switcherator.c **** 
1679:switcherator.c **** 
1680:switcherator.c **** /****************************************************************
1681:switcherator.c ****  *
1682:switcherator.c ****  *              All Things EEPROM Related
1683:switcherator.c ****  *
1684:switcherator.c ****  ****************************************************************/
1685:switcherator.c **** 
1686:switcherator.c **** // Get variables out of EEPROM and set things up
1687:switcherator.c **** 
1688:switcherator.c **** void generalInit(void) {
1689:switcherator.c ****     // read the program info
1690:switcherator.c ****     char tempStuff[14];
1691:switcherator.c ****     int x = 0;
1692:switcherator.c ****     // Go through the addresses and assign them if set
1693:switcherator.c ****     // decided later that this is a really bad idea. gets corrupted.  use default
1694:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_TX, RADIO_ADDR_TX_BYTES) == 1) {
1695:switcherator.c ****         tx_addr = formatAddress(tempStuff);
1696:switcherator.c ****         writeAddr(TX_ADDR, tx_addr);
1697:switcherator.c ****     }
1698:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R0, RADIO_ADDR_R0_BYTES) == 1) {
1699:switcherator.c ****         rx_addr_p0 = formatAddress(tempStuff);
1700:switcherator.c ****         writeAddr(RX_ADDR_P0, rx_addr_p0);
1701:switcherator.c ****     }
1702:switcherator.c **** 
1703:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R1, RADIO_ADDR_R1_BYTES) == 1) {
1704:switcherator.c ****         rx_addr_p1 = formatAddress(tempStuff);
1705:switcherator.c ****         writeAddr(RX_ADDR_P1, rx_addr_p1);
1706:switcherator.c ****     }
1707:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R2, RADIO_ADDR_R2_BYTES) == 1) {
1708:switcherator.c ****         rx_addr_p2 = tempStuff[0];
1709:switcherator.c ****         writeAddr(RX_ADDR_P2, rx_addr_p2);
1710:switcherator.c ****     }
1711:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R3, RADIO_ADDR_R3_BYTES) == 1) {
1712:switcherator.c ****         rx_addr_p3 = tempStuff[0];
1713:switcherator.c ****         writeAddr(RX_ADDR_P3, rx_addr_p3);
1714:switcherator.c ****     }
1715:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R4, RADIO_ADDR_R4_BYTES) == 1) {
1716:switcherator.c ****         rx_addr_p4 = tempStuff[0];
1717:switcherator.c ****         writeAddr(RX_ADDR_P4, rx_addr_p4);
1718:switcherator.c ****     }
1719:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R5, RADIO_ADDR_R5_BYTES) == 1) {
1720:switcherator.c ****         rx_addr_p5 = tempStuff[0];
1721:switcherator.c ****         writeAddr(RX_ADDR_P5, rx_addr_p5);
1722:switcherator.c ****     }
1723:switcherator.c ****     if (readEEPROM(tempStuff, TWEAK_TIMER, TWEAK_TIMER_BYTES) == 1) {
1724:switcherator.c ****         tweakTimer = tempStuff[0];
1725:switcherator.c ****         tweakTimer <<= 8;
1726:switcherator.c ****         tweakTimer |= tempStuff[1];
1727:switcherator.c ****     }
1728:switcherator.c **** 
1729:switcherator.c **** 
1730:switcherator.c ****     // process daylight savings
1731:switcherator.c ****     if (readEEPROM(tempStuff, DAYLIGHT_SAVE, DAYLIGHT_SAVE_BYTES) == 1) {
1732:switcherator.c ****         // Spring month
1733:switcherator.c ****         daylightSavings[0][0] = ((tempStuff[0] << 8) | (tempStuff[1]));
1734:switcherator.c ****         // Spring day
1735:switcherator.c ****         daylightSavings[0][1] = ((tempStuff[2] << 8) | (tempStuff[3]));
1736:switcherator.c ****         // Fall month
1737:switcherator.c ****         daylightSavings[1][0] = ((tempStuff[4] << 8) | (tempStuff[5]));
1738:switcherator.c ****         // Fall day
1739:switcherator.c ****         daylightSavings[1][1] = ((tempStuff[6] << 8) | (tempStuff[7]));
1740:switcherator.c ****     }
1741:switcherator.c **** 
1742:switcherator.c **** 
1743:switcherator.c ****     // switches
1744:switcherator.c ****     if (readEEPROM(switchStuff, SWITCH_STUFF, SWITCH_STUFF_BYTES) == 1) {
1745:switcherator.c ****         readEEPROM(switchBright, BRIGHTNESS, BRIGHTNESS_BYTES);
1746:switcherator.c ****         volatile unsigned char *realPort = 0;
1747:switcherator.c ****         volatile unsigned char *realDDR = 0;
1748:switcherator.c ****         char realPin = 0;
1749:switcherator.c ****         char temp = 0;
1750:switcherator.c ****         // Pp - value of 255 (default) means nothing programmed
1751:switcherator.c ****         // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
1752:switcherator.c ****         // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
1753:switcherator.c ****         for (x = 0; x < NUM_SWITCHES; x++) {
1754:switcherator.c ****             temp = switchStuff[x];
1755:switcherator.c ****             if (temp > 15 && temp < 32) {
1756:switcherator.c ****                 realPort = &PORTB;
1757:switcherator.c ****                 realDDR = &DDRB;
1758:switcherator.c ****                 temp -= 16;
1759:switcherator.c **** #ifdef PINA
1760:switcherator.c ****             } else if (temp < 16) {
1761:switcherator.c ****                 realPort = &PORTA;
1762:switcherator.c ****                 realDDR = &DDRA;
1763:switcherator.c ****                 temp -= 0;
1764:switcherator.c **** #endif
1765:switcherator.c **** #ifdef PINC
1766:switcherator.c ****             } else if (temp < 48) {
1767:switcherator.c ****                 realPort = &PORTC;
1768:switcherator.c ****                 realDDR = &DDRC;
1769:switcherator.c ****                 temp -= 32;
1770:switcherator.c **** #endif
1771:switcherator.c **** #ifdef PIND
1772:switcherator.c ****             } else if (temp < 64) {
1773:switcherator.c ****                 realPort = &PORTD;
1774:switcherator.c ****                 realDDR = &DDRD;
1775:switcherator.c ****                 temp -= 48;
1776:switcherator.c **** #endif
1777:switcherator.c **** #ifdef PINE
1778:switcherator.c ****             } else if (temp < 80) {
1779:switcherator.c ****                 realPort = &PORTE;
1780:switcherator.c ****                 realDDR = &DDRE;
1781:switcherator.c ****                 temp -= 64;
1782:switcherator.c **** #endif
1783:switcherator.c **** #ifdef PINF
1784:switcherator.c ****             } else if (temp < 96) {
1785:switcherator.c ****                 realPort = &PORTF;
1786:switcherator.c ****                 realDDR = &DDRF;
1787:switcherator.c ****                 temp -= 80;
1788:switcherator.c **** #endif
1789:switcherator.c **** #ifdef PING
1790:switcherator.c ****             } else if (temp < 112) {
1791:switcherator.c ****                 realPort = &PORTG;
1792:switcherator.c ****                 realDDR = &DDRG;
1793:switcherator.c ****                 temp -= 96;
1794:switcherator.c **** #endif
1795:switcherator.c **** #ifdef PINH
1796:switcherator.c ****             } else if (temp < 128) {
1797:switcherator.c ****                 realPort = &PORTH;
1798:switcherator.c ****                 realDDR = &DDRH;
1799:switcherator.c ****                 temp -= 112;
1800:switcherator.c **** #endif
1801:switcherator.c **** #ifdef PINI
1802:switcherator.c ****             } else if (temp < 144) {
1803:switcherator.c ****                 realPort = &PORTI;
1804:switcherator.c ****                 realDDR = &DDRI;
1805:switcherator.c ****                 temp -= 128;
1806:switcherator.c **** #endif
1807:switcherator.c ****                 // pwm setup
1808:switcherator.c ****             } else {
1809:switcherator.c ****                 continue;
1810:switcherator.c ****             }
1811:switcherator.c ****             realPin = (temp / 2);
1812:switcherator.c ****             *realDDR |= (1 << realPin);
1813:switcherator.c ****             // figure out direction
1814:switcherator.c ****             if (temp % 2 == 0) {
1815:switcherator.c ****                 // 0 = low is on  1 = high is on
1816:switcherator.c ****                 *realPort |= (1 << realPin);
1817:switcherator.c ****             } else {
1818:switcherator.c ****                 *realPort &= ~(1 << realPin);
1819:switcherator.c ****             }
1820:switcherator.c ****         }
1821:switcherator.c ****     } else {
1822:switcherator.c ****         for (x = 0; x < NUM_SWITCHES; x++)
1823:switcherator.c ****             switchStuff[x] = 255;
1824:switcherator.c ****     }
1825:switcherator.c **** 
1826:switcherator.c ****     int memoryMarker = 0;
1827:switcherator.c ****     int y = 0;
1828:switcherator.c ****     // get the programs
1829:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
1830:switcherator.c ****         memoryMarker = (WEEKLY_PROGRAM + (x * WEEKLY_PROGRAM_BYTES));
1831:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, WEEKLY_PROGRAM_BYTES) == 1) {
1832:switcherator.c ****             for (y = 0; y < 10; y++) {
1833:switcherator.c ****                 weeklyProgram[x][y] = tempStuff[y];
1834:switcherator.c ****             }
1835:switcherator.c ****         }
1836:switcherator.c ****     }
1837:switcherator.c ****     // get the inputs
1838:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
1839:switcherator.c ****         memoryMarker = (INPUT + (x * INPUT_BYTES));
1840:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, INPUT_BYTES) == 1) {
1841:switcherator.c ****             for (y = 0; y < 8; y++) {
1842:switcherator.c ****                 inputs[x][y] = tempStuff[y];
1843:switcherator.c ****             }
1844:switcherator.c ****         }
1845:switcherator.c ****     }
1846:switcherator.c ****     // get the time limits
1847:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++) {
1848:switcherator.c ****         memoryMarker = (LIMIT + (x * LIMIT_BYTES));
1849:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, LIMIT_BYTES) == 1) {
1850:switcherator.c ****             for (y = 0; y < 3; y++) {
1851:switcherator.c ****                 timeLimits[x][y] = tempStuff[y];
1852:switcherator.c ****             }
1853:switcherator.c ****         }
1854:switcherator.c ****     }
1855:switcherator.c **** 
1856:switcherator.c ****     if (readEEPROM(tempStuff, PWM_DIR, PWM_DIR_BYTES) == 1) {
1857:switcherator.c ****         DDRD |= (1 << PIND3) | (1 << PIND5) | (1 << PIND6);
1858:switcherator.c ****         // make sure initial values are 0
1859:switcherator.c ****         Red = 0;
1860:switcherator.c ****         Green = 0;
1861:switcherator.c ****         Blue = 0;
1862:switcherator.c ****         // Set output phase correct whatevers
1863:switcherator.c ****         // set it to inverted if the direction is 0
1864:switcherator.c ****         if (tempStuff[0] == 0) {
1865:switcherator.c ****             TCCR0A = (1 << COM0A0) | (1 << COM0A1) | (1 << COM0B0) | (1 << COM0B1) | (1 << WGM00);
1866:switcherator.c ****             TCCR2A = (1 << COM2B0) | (1 << COM2B1) | (1 << WGM20);
1867:switcherator.c ****             pwmdir = 0;
1868:switcherator.c ****         } else {
1869:switcherator.c ****             TCCR0A = (1 << COM0A1) | (1 << COM0B1) | (1 << WGM00);
1870:switcherator.c ****             TCCR2A = (1 << COM2B1) | (1 << WGM20);
1871:switcherator.c ****             pwmdir = 1;
1872:switcherator.c ****         }
1873:switcherator.c ****         // F_CPU/64 timers
1874:switcherator.c ****         TCCR0B = (1 << CS01) | (1 << CS00);
1875:switcherator.c **** 
1876:switcherator.c ****         TCCR2B = (1 << CS22); // F_CPU/64
1877:switcherator.c ****     }
1878:switcherator.c **** 
1879:switcherator.c ****     // get the pwm value bytes
1880:switcherator.c ****     memoryMarker = (PWM_VALUE);
1881:switcherator.c ****     if (readEEPROM(tempStuff, memoryMarker, PWM_VALUE_BYTES) == 1) {
1882:switcherator.c ****         pwmValues[0] = tempStuff[0];
1883:switcherator.c ****         pwmValues[1] = tempStuff[1];
1884:switcherator.c ****         pwmValues[2] = tempStuff[2];
1885:switcherator.c ****     }
1886:switcherator.c ****     // get the color change
1887:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
1888:switcherator.c ****         memoryMarker = (COLOR_CHANGE + (x * COLOR_CHANGE_BYTES));
1889:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, PWM_VALUE_BYTES) == 1) {
1890:switcherator.c ****             for (y = 0; y < 3; y++) {
1891:switcherator.c ****                 colorChanges[x][y] = tempStuff[y];
1892:switcherator.c ****             }
1893:switcherator.c ****         }
1894:switcherator.c ****     }
1895:switcherator.c **** }
1896:switcherator.c **** 
1897:switcherator.c **** int readEEPROM(char * data, int memLocation, int memBytes) {
 1150               		.loc 1 1897 0
 1151               	.LVL67:
 1152 064e EF92      		push r14
 1153               	.LCFI23:
 1154 0650 FF92      		push r15
 1155               	.LCFI24:
 1156 0652 0F93      		push r16
 1157               	.LCFI25:
 1158 0654 1F93      		push r17
 1159               	.LCFI26:
 1160 0656 CF93      		push r28
 1161               	.LCFI27:
 1162 0658 DF93      		push r29
 1163               	.LCFI28:
 1164               	/* prologue: function */
 1165               	/* frame size = 0 */
 1166               	/* stack size = 6 */
 1167               	.L__stack_usage = 6
 1168 065a 7C01      		movw r14,r24
 1169 065c EB01      		movw r28,r22
 1170 065e 8A01      		movw r16,r20
 1171               	.LVL68:
 1172 0660 FC01      		movw r30,r24
1898:switcherator.c ****     uint16_t checkProgram;
1899:switcherator.c ****     int x = 0;
1900:switcherator.c ****     for (x = 0; x < 14; x++) {
 1173               		.loc 1 1900 0
 1174 0662 20E0      		ldi r18,0
 1175 0664 30E0      		ldi r19,0
 1176               	.LVL69:
 1177               	.L79:
1901:switcherator.c ****         data[x] = 0;
 1178               		.loc 1 1901 0 discriminator 2
 1179 0666 1192      		st Z+,__zero_reg__
1900:switcherator.c ****     for (x = 0; x < 14; x++) {
 1180               		.loc 1 1900 0 discriminator 2
 1181 0668 2F5F      		subi r18,-1
 1182 066a 3F4F      		sbci r19,-1
 1183               	.LVL70:
 1184 066c 2E30      		cpi r18,14
 1185 066e 3105      		cpc r19,__zero_reg__
 1186 0670 01F4      		brne .L79
1902:switcherator.c ****     }
1903:switcherator.c ****     // see if it has been programmed
1904:switcherator.c ****     checkProgram = eeprom_read_word((uint16_t*) memLocation);
 1187               		.loc 1 1904 0
 1188 0672 CE01      		movw r24,r28
 1189 0674 0E94 0000 		call __eerd_word_m328
 1190               	.LVL71:
1905:switcherator.c ****     // "DW" = 68,87 = 0x4457
1906:switcherator.c ****     if (checkProgram == 0x4457) {
 1191               		.loc 1 1906 0
 1192 0678 8735      		cpi r24,87
 1193 067a 9444      		sbci r25,68
 1194 067c 01F4      		brne .L81
 1195               	.LVL72:
 1196               	.LBB20:
 1197               	.LBB21:
1907:switcherator.c ****         // we've written here before. now get the data (except marker)
1908:switcherator.c ****         eeprom_read_block((void*) data, (const void*) (memLocation + 2), (memBytes - 2));
 1198               		.loc 1 1908 0
 1199 067e A801      		movw r20,r16
 1200 0680 4250      		subi r20,2
 1201 0682 5109      		sbc r21,__zero_reg__
 1202 0684 BE01      		movw r22,r28
 1203 0686 6E5F      		subi r22,-2
 1204 0688 7F4F      		sbci r23,-1
 1205 068a C701      		movw r24,r14
 1206               	.LVL73:
 1207 068c 0E94 0000 		call __eerd_block_m328
 1208               	.LVL74:
 1209 0690 21E0      		ldi r18,lo8(1)
 1210 0692 30E0      		ldi r19,0
 1211 0694 00C0      		rjmp .L80
 1212               	.LVL75:
 1213               	.L81:
 1214               	.LBE21:
 1215               	.LBE20:
1909:switcherator.c ****         return 1;
1910:switcherator.c ****     } else {
1911:switcherator.c ****         return 0;
 1216               		.loc 1 1911 0
 1217 0696 20E0      		ldi r18,0
 1218 0698 30E0      		ldi r19,0
 1219               	.LVL76:
 1220               	.L80:
1912:switcherator.c ****     }
1913:switcherator.c **** }
 1221               		.loc 1 1913 0
 1222 069a C901      		movw r24,r18
 1223               	/* epilogue start */
 1224 069c DF91      		pop r29
 1225 069e CF91      		pop r28
 1226               	.LVL77:
 1227 06a0 1F91      		pop r17
 1228 06a2 0F91      		pop r16
 1229               	.LVL78:
 1230 06a4 FF90      		pop r15
 1231 06a6 EF90      		pop r14
 1232               	.LVL79:
 1233 06a8 0895      		ret
 1234               	.LFE42:
 1236               	.global	writeEEPROM
 1238               	writeEEPROM:
 1239               	.LFB43:
1914:switcherator.c **** 
1915:switcherator.c **** void writeEEPROM(char * data, int memLocation, int memBytes) {
 1240               		.loc 1 1915 0
 1241               	.LVL80:
 1242 06aa CF93      		push r28
 1243               	.LCFI29:
 1244 06ac DF93      		push r29
 1245               	.LCFI30:
 1246               	/* prologue: function */
 1247               	/* frame size = 0 */
 1248               	/* stack size = 2 */
 1249               	.L__stack_usage = 2
 1250 06ae EB01      		movw r28,r22
 1251               	.LVL81:
1916:switcherator.c ****     uint16_t marker = 0x4457; // "DW" in ascii
1917:switcherator.c ****     eeprom_update_block((const void*) data, (void*) (memLocation + 2), (memBytes - 2));
 1252               		.loc 1 1917 0
 1253 06b0 4250      		subi r20,2
 1254 06b2 5109      		sbc r21,__zero_reg__
 1255               	.LVL82:
 1256 06b4 6E5F      		subi r22,-2
 1257 06b6 7F4F      		sbci r23,-1
 1258               	.LVL83:
 1259 06b8 0E94 0000 		call __eeupd_block_m328
 1260               	.LVL84:
1918:switcherator.c ****     eeprom_update_word((uint16_t*) memLocation, marker);
 1261               		.loc 1 1918 0
 1262 06bc 67E5      		ldi r22,lo8(87)
 1263 06be 74E4      		ldi r23,lo8(68)
 1264 06c0 CE01      		movw r24,r28
 1265               	/* epilogue start */
1919:switcherator.c **** }
 1266               		.loc 1 1919 0
 1267 06c2 DF91      		pop r29
 1268 06c4 CF91      		pop r28
 1269               	.LVL85:
1918:switcherator.c ****     eeprom_update_word((uint16_t*) memLocation, marker);
 1270               		.loc 1 1918 0
 1271 06c6 0C94 0000 		jmp __eeupd_word_m328
 1272               	.LVL86:
 1273               	.LFE43:
 1275               	.global	clearEEPROM
 1277               	clearEEPROM:
 1278               	.LFB44:
1920:switcherator.c **** 
1921:switcherator.c **** void clearEEPROM(int memLocation) {
 1279               		.loc 1 1921 0
 1280               	.LVL87:
 1281               	/* prologue: function */
 1282               	/* frame size = 0 */
 1283               	/* stack size = 0 */
 1284               	.L__stack_usage = 0
1922:switcherator.c ****     uint16_t marker = 0x0000; // blank it out
1923:switcherator.c ****     eeprom_update_word((uint16_t*) memLocation, marker);
 1285               		.loc 1 1923 0
 1286 06ca 60E0      		ldi r22,0
 1287 06cc 70E0      		ldi r23,0
 1288 06ce 0C94 0000 		jmp __eeupd_word_m328
 1289               	.LVL88:
 1290               	.LFE44:
 1292               	.global	clockInit
 1294               	clockInit:
 1295               	.LFB47:
1924:switcherator.c **** }
1925:switcherator.c **** 
1926:switcherator.c **** void saveToEEPROM(void) {
1927:switcherator.c ****     char tempStuff[14];
1928:switcherator.c ****     int x = 0;
1929:switcherator.c ****     // Go through the addresses and assign them if set
1930:switcherator.c ****     if (tx_addr > 0) {
1931:switcherator.c ****         unformatAddress(tx_addr, tempStuff);
1932:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_TX, RADIO_ADDR_TX_BYTES);
1933:switcherator.c ****     }
1934:switcherator.c ****     if (rx_addr_p0 > 0) {
1935:switcherator.c ****         unformatAddress(rx_addr_p0, tempStuff);
1936:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R0, RADIO_ADDR_R0_BYTES);
1937:switcherator.c ****     }
1938:switcherator.c ****     if (rx_addr_p1 > 0) {
1939:switcherator.c ****         unformatAddress(rx_addr_p1, tempStuff);
1940:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R1, RADIO_ADDR_R1_BYTES);
1941:switcherator.c ****     }
1942:switcherator.c ****     if (rx_addr_p2 > 0) {
1943:switcherator.c ****         tempStuff[0] = rx_addr_p2;
1944:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R2, RADIO_ADDR_R2_BYTES);
1945:switcherator.c ****     }
1946:switcherator.c ****     if (rx_addr_p3 > 0) {
1947:switcherator.c ****         tempStuff[0] = rx_addr_p3;
1948:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R3, RADIO_ADDR_R3_BYTES);
1949:switcherator.c ****     }
1950:switcherator.c ****     if (rx_addr_p4 > 0) {
1951:switcherator.c ****         tempStuff[0] = rx_addr_p4;
1952:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R4, RADIO_ADDR_R4_BYTES);
1953:switcherator.c ****     }
1954:switcherator.c ****     if (rx_addr_p5 > 0) {
1955:switcherator.c ****         tempStuff[0] = rx_addr_p5;
1956:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R5, RADIO_ADDR_R5_BYTES);
1957:switcherator.c ****     }
1958:switcherator.c **** 
1959:switcherator.c ****     if (tweakTimer != 0) {
1960:switcherator.c ****         tempStuff[0] = tweakTimer >> 8;
1961:switcherator.c ****         tempStuff[1] = (tweakTimer & 0xff);
1962:switcherator.c ****         writeEEPROM(tempStuff, TWEAK_TIMER, TWEAK_TIMER_BYTES);
1963:switcherator.c ****     }
1964:switcherator.c **** 
1965:switcherator.c **** 
1966:switcherator.c **** 
1967:switcherator.c ****     if (daylightSavings[0][0] > 0) {
1968:switcherator.c ****         tempStuff[0] = (daylightSavings[0][0] >> 8);
1969:switcherator.c ****         tempStuff[1] = (daylightSavings[0][0] & 0xff);
1970:switcherator.c ****         tempStuff[2] = (daylightSavings[0][1] >> 8);
1971:switcherator.c ****         tempStuff[3] = (daylightSavings[0][1] & 0xff);
1972:switcherator.c ****         tempStuff[4] = (daylightSavings[1][0] >> 8);
1973:switcherator.c ****         tempStuff[5] = (daylightSavings[1][0] & 0xff);
1974:switcherator.c ****         tempStuff[6] = (daylightSavings[1][1] >> 8);
1975:switcherator.c ****         tempStuff[7] = (daylightSavings[1][1] & 0xff);
1976:switcherator.c ****         writeEEPROM(tempStuff, DAYLIGHT_SAVE, DAYLIGHT_SAVE_BYTES);
1977:switcherator.c ****     }
1978:switcherator.c ****     char setupaSwitch = 0;
1979:switcherator.c ****     char setupPWM = 0;
1980:switcherator.c **** 
1981:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
1982:switcherator.c ****         if (switchStuff[x] < 255)
1983:switcherator.c ****             setupaSwitch = 1;
1984:switcherator.c ****         if (switchStuff[x] >= 200 && switchStuff[x] <= 230)
1985:switcherator.c ****             setupPWM = 1;
1986:switcherator.c ****     }
1987:switcherator.c ****     if (setupaSwitch == 1) {
1988:switcherator.c ****         writeEEPROM(switchStuff, SWITCH_STUFF, SWITCH_STUFF_BYTES);
1989:switcherator.c ****         writeEEPROM(switchBright, BRIGHTNESS, BRIGHTNESS_BYTES);
1990:switcherator.c ****     }
1991:switcherator.c ****     tempStuff[0] = pwmdir;
1992:switcherator.c ****     if (setupPWM == 1)
1993:switcherator.c ****         writeEEPROM(tempStuff, PWM_DIR, PWM_DIR_BYTES);
1994:switcherator.c **** 
1995:switcherator.c ****     int memoryMarker;
1996:switcherator.c **** 
1997:switcherator.c **** 
1998:switcherator.c **** 
1999:switcherator.c **** 
2000:switcherator.c ****     // save the programs
2001:switcherator.c ****     int y = 0;
2002:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
2003:switcherator.c ****         memoryMarker = (WEEKLY_PROGRAM + (x * WEEKLY_PROGRAM_BYTES));
2004:switcherator.c ****         if (weeklyProgram[x][0] != 255 || weeklyProgram[x][1] != 255) {
2005:switcherator.c ****             for (y = 0; y < 10; y++)
2006:switcherator.c ****                 tempStuff[y] = weeklyProgram[x][y];
2007:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, WEEKLY_PROGRAM_BYTES);
2008:switcherator.c ****         }
2009:switcherator.c ****     }
2010:switcherator.c **** 
2011:switcherator.c ****     // save the inputs
2012:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
2013:switcherator.c ****         memoryMarker = (INPUT + (x * INPUT_BYTES));
2014:switcherator.c ****         if (inputs[x][0] != 255) {
2015:switcherator.c ****             for (y = 0; y < 8; y++) {
2016:switcherator.c ****                 tempStuff[y] = inputs[x][y];
2017:switcherator.c ****             }
2018:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, INPUT_BYTES);
2019:switcherator.c ****         }
2020:switcherator.c ****     }
2021:switcherator.c **** 
2022:switcherator.c ****     // save the time limits
2023:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++) {
2024:switcherator.c ****         memoryMarker = (LIMIT + (x * LIMIT_BYTES));
2025:switcherator.c ****         if (timeLimits[x][2] > 0) {
2026:switcherator.c ****             for (y = 0; y < 3; y++) {
2027:switcherator.c ****                 tempStuff[y] = timeLimits[x][y];
2028:switcherator.c ****             }
2029:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, INPUT_BYTES);
2030:switcherator.c ****         }
2031:switcherator.c ****     }
2032:switcherator.c **** 
2033:switcherator.c **** 
2034:switcherator.c ****     // save the pwm value bytes
2035:switcherator.c ****     memoryMarker = (PWM_VALUE);
2036:switcherator.c ****     if (pwmValues[0] != 0 || pwmValues[1] != 0 || pwmValues[2] != 0) {
2037:switcherator.c ****         for (y = 0; y < 3; y++) {
2038:switcherator.c ****             tempStuff[y] = pwmValues[y];
2039:switcherator.c ****         }
2040:switcherator.c ****         writeEEPROM(tempStuff, memoryMarker, PWM_VALUE_BYTES);
2041:switcherator.c ****     }
2042:switcherator.c **** 
2043:switcherator.c ****     // save the color change
2044:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
2045:switcherator.c ****         memoryMarker = (COLOR_CHANGE + (x * COLOR_CHANGE_BYTES));
2046:switcherator.c ****         if (colorChanges[0][0] != 0 || colorChanges[0][1] != 1 || colorChanges[0][2] != 0) {
2047:switcherator.c ****             for (y = 0; y < 3; y++) {
2048:switcherator.c ****                 tempStuff[y] = inputs[x][y];
2049:switcherator.c ****             }
2050:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, COLOR_CHANGE_BYTES);
2051:switcherator.c ****         }
2052:switcherator.c ****     }
2053:switcherator.c ****     ok();
2054:switcherator.c **** }
2055:switcherator.c **** 
2056:switcherator.c **** void clearToEEPROM(void) {
2057:switcherator.c ****     int x = 0;
2058:switcherator.c ****     clearEEPROM(DAYLIGHT_SAVE);
2059:switcherator.c ****     clearEEPROM(RADIO_ADDR_TX);
2060:switcherator.c ****     clearEEPROM(RADIO_ADDR_R0);
2061:switcherator.c ****     clearEEPROM(RADIO_ADDR_R1);
2062:switcherator.c ****     clearEEPROM(RADIO_ADDR_R2);
2063:switcherator.c ****     clearEEPROM(RADIO_ADDR_R3);
2064:switcherator.c ****     clearEEPROM(RADIO_ADDR_R4);
2065:switcherator.c ****     clearEEPROM(RADIO_ADDR_R5);
2066:switcherator.c ****     clearEEPROM(SWITCH_STUFF);
2067:switcherator.c ****     clearEEPROM(PWM_DIR);
2068:switcherator.c ****     clearEEPROM(BRIGHTNESS);
2069:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++)
2070:switcherator.c ****         clearEEPROM((INPUT + (x * INPUT_BYTES)));
2071:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++)
2072:switcherator.c ****         clearEEPROM((LIMIT + (x * LIMIT_BYTES)));
2073:switcherator.c ****     clearEEPROM(PWM_VALUE);
2074:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++)
2075:switcherator.c ****         clearEEPROM((COLOR_CHANGE + (x * COLOR_CHANGE_BYTES)));
2076:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++)
2077:switcherator.c ****         clearEEPROM((WEEKLY_PROGRAM + (x * WEEKLY_PROGRAM_BYTES)));
2078:switcherator.c ****     clearEEPROM(TWEAK_TIMER);
2079:switcherator.c ****     ok();
2080:switcherator.c **** }
2081:switcherator.c **** 
2082:switcherator.c **** /****************************************************************
2083:switcherator.c ****  *
2084:switcherator.c ****  *              All Things Clock Related
2085:switcherator.c ****  *
2086:switcherator.c ****  ****************************************************************/
2087:switcherator.c **** 
2088:switcherator.c **** 
2089:switcherator.c **** // initialize the clock
2090:switcherator.c **** 
2091:switcherator.c **** void clockInit(void) {
 1296               		.loc 1 2091 0
 1297               	/* prologue: function */
 1298               	/* frame size = 0 */
 1299               	/* stack size = 0 */
 1300               	.L__stack_usage = 0
2092:switcherator.c ****     // Set CTC mode (clear timer on compare)
2093:switcherator.c ****     TCCR1A = 0;
 1301               		.loc 1 2093 0
 1302 06d2 1092 8000 		sts 128,__zero_reg__
2094:switcherator.c ****     TCCR1B = (1 << WGM12);
 1303               		.loc 1 2094 0
 1304 06d6 88E0      		ldi r24,lo8(8)
 1305 06d8 8093 8100 		sts 129,r24
2095:switcherator.c ****     OCR1A = TIMER_RESET;
 1306               		.loc 1 2095 0
 1307 06dc 1092 8900 		sts 136+1,__zero_reg__
 1308 06e0 1092 8800 		sts 136,__zero_reg__
2096:switcherator.c ****     TIMSK1 = (1 << OCIE1A); // set interrupt
 1309               		.loc 1 2096 0
 1310 06e4 82E0      		ldi r24,lo8(2)
 1311 06e6 8093 6F00 		sts 111,r24
 1312 06ea 0895      		ret
 1313               	.LFE47:
 1315               	.global	startClock
 1317               	startClock:
 1318               	.LFB50:
2097:switcherator.c **** }
2098:switcherator.c **** 
2099:switcherator.c **** // we received a time command.  set the clock
2100:switcherator.c **** // Must be this format:
2101:switcherator.c **** // TI:MMDDYYYYHHMMSS
2102:switcherator.c **** // 012345678901234567
2103:switcherator.c **** 
2104:switcherator.c **** void setClock(char * commandReceived) {
2105:switcherator.c ****     long tempInt;
2106:switcherator.c ****     // iterate through and get the times.
2107:switcherator.c ****     tempLongString[0] = '0';
2108:switcherator.c ****     tempLongString[1] = '0';
2109:switcherator.c ****     // Can't see a good loop so just get to it.
2110:switcherator.c ****     // Month
2111:switcherator.c ****     tempLongString[2] = commandReceived[3];
2112:switcherator.c ****     tempLongString[3] = commandReceived[4];
2113:switcherator.c ****     globalMonth = atoi(tempLongString);
2114:switcherator.c ****     // Day
2115:switcherator.c ****     tempLongString[2] = commandReceived[5];
2116:switcherator.c ****     tempLongString[3] = commandReceived[6];
2117:switcherator.c ****     globalDay = atoi(tempLongString);
2118:switcherator.c ****     // hour
2119:switcherator.c ****     tempLongString[2] = commandReceived[11];
2120:switcherator.c ****     tempLongString[3] = commandReceived[12];
2121:switcherator.c ****     globalHour = atoi(tempLongString);
2122:switcherator.c ****     // minute
2123:switcherator.c ****     tempLongString[2] = commandReceived[13];
2124:switcherator.c ****     tempLongString[3] = commandReceived[14];
2125:switcherator.c ****     globalMinute = atoi(tempLongString);
2126:switcherator.c ****     // second
2127:switcherator.c ****     tempLongString[2] = commandReceived[15];
2128:switcherator.c ****     tempLongString[3] = commandReceived[16];
2129:switcherator.c ****     globalSecond = atoi(tempLongString);
2130:switcherator.c ****     // year
2131:switcherator.c ****     tempLongString[0] = commandReceived[7];
2132:switcherator.c ****     tempLongString[1] = commandReceived[8];
2133:switcherator.c ****     tempLongString[2] = commandReceived[9];
2134:switcherator.c ****     tempLongString[3] = commandReceived[10];
2135:switcherator.c ****     globalYear = atoi(tempLongString);
2136:switcherator.c ****     dow = getWeekday(globalYear, globalMonth, globalDay); // get day of week
2137:switcherator.c ****     tempInt = dow;
2138:switcherator.c ****     tempInt = tempInt * 24 * 60 * 60;
2139:switcherator.c ****     weeklySeconds = tempInt;
2140:switcherator.c ****     tempInt = globalHour;
2141:switcherator.c ****     tempInt = tempInt * 60 * 60;
2142:switcherator.c ****     weeklySeconds += tempInt;
2143:switcherator.c ****     tempInt = globalMinute;
2144:switcherator.c ****     tempInt = tempInt * 60;
2145:switcherator.c ****     weeklySeconds += tempInt;
2146:switcherator.c ****     weeklySeconds += globalSecond;
2147:switcherator.c ****     clockString();
2148:switcherator.c ****     sendMessage(statusMsg);
2149:switcherator.c ****     stopClock();
2150:switcherator.c ****     startClock();
2151:switcherator.c ****     panicMyClockIsNotSet = 0;
2152:switcherator.c ****     if(failCondition == 3) {
2153:switcherator.c ****         clearFail();      
2154:switcherator.c ****     }
2155:switcherator.c **** }
2156:switcherator.c **** 
2157:switcherator.c **** 
2158:switcherator.c **** // Change the clock values to a string
2159:switcherator.c **** 
2160:switcherator.c **** void clockString(void) {
2161:switcherator.c ****     statusMsg[0] = 0;
2162:switcherator.c **** 
2163:switcherator.c ****     strcat(statusMsg, " ");
2164:switcherator.c ****     returnInt(globalMonth, tempIntString);
2165:switcherator.c ****     strcat(statusMsg, tempIntString);
2166:switcherator.c ****     strcat(statusMsg, "/");
2167:switcherator.c ****     returnInt(globalDay, tempIntString);
2168:switcherator.c ****     strcat(statusMsg, tempIntString);
2169:switcherator.c ****     strcat(statusMsg, "/");
2170:switcherator.c ****     itoa(globalYear, tempIntString, 10);
2171:switcherator.c ****     strcat(statusMsg, tempIntString);
2172:switcherator.c ****     strcat(statusMsg, " ");
2173:switcherator.c ****     returnInt(globalHour, tempIntString);
2174:switcherator.c ****     strcat(statusMsg, tempIntString);
2175:switcherator.c ****     strcat(statusMsg, ":");
2176:switcherator.c ****     returnInt(globalMinute, tempIntString);
2177:switcherator.c ****     strcat(statusMsg, tempIntString);
2178:switcherator.c ****     strcat(statusMsg, ":");
2179:switcherator.c ****     returnInt(globalSecond, tempIntString);
2180:switcherator.c ****     strcat(statusMsg, tempIntString);
2181:switcherator.c **** }
2182:switcherator.c **** 
2183:switcherator.c **** // start the clock
2184:switcherator.c **** 
2185:switcherator.c **** void startClock(void) {
 1319               		.loc 1 2185 0
 1320               	/* prologue: function */
 1321               	/* frame size = 0 */
 1322               	/* stack size = 0 */
 1323               	.L__stack_usage = 0
2186:switcherator.c ****     TCNT1 = 65535;
 1324               		.loc 1 2186 0
 1325 06ec 8FEF      		ldi r24,lo8(-1)
 1326 06ee 9FEF      		ldi r25,lo8(-1)
 1327 06f0 9093 8500 		sts 132+1,r25
 1328 06f4 8093 8400 		sts 132,r24
2187:switcherator.c ****     TCCR1B |= TIMER_CLOCK_SEL;
 1329               		.loc 1 2187 0
 1330 06f8 E1E8      		ldi r30,lo8(-127)
 1331 06fa F0E0      		ldi r31,0
 1332 06fc 8081      		ld r24,Z
 1333 06fe 8560      		ori r24,lo8(5)
 1334 0700 8083      		st Z,r24
 1335 0702 0895      		ret
 1336               	.LFE50:
 1338               	.global	stopClock
 1340               	stopClock:
 1341               	.LFB51:
2188:switcherator.c **** }
2189:switcherator.c **** 
2190:switcherator.c **** void stopClock(void) {
 1342               		.loc 1 2190 0
 1343               	/* prologue: function */
 1344               	/* frame size = 0 */
 1345               	/* stack size = 0 */
 1346               	.L__stack_usage = 0
2191:switcherator.c ****     TCCR1B &= ~(TIMER_CLOCK_SEL);
 1347               		.loc 1 2191 0
 1348 0704 E1E8      		ldi r30,lo8(-127)
 1349 0706 F0E0      		ldi r31,0
 1350 0708 8081      		ld r24,Z
 1351 070a 8A7F      		andi r24,lo8(-6)
 1352 070c 8083      		st Z,r24
 1353 070e 0895      		ret
 1354               	.LFE51:
 1356               	.global	getWeekday
 1358               	getWeekday:
 1359               	.LFB52:
2192:switcherator.c **** }
2193:switcherator.c **** 
2194:switcherator.c **** // returns the weekday - sunday = 0
2195:switcherator.c **** 
2196:switcherator.c **** int getWeekday(int year, int month, int day) {
 1360               		.loc 1 2196 0
 1361               	.LVL89:
 1362 0710 CF93      		push r28
 1363               	.LCFI31:
 1364 0712 DF93      		push r29
 1365               	.LCFI32:
 1366               	/* prologue: function */
 1367               	/* frame size = 0 */
 1368               	/* stack size = 2 */
 1369               	.L__stack_usage = 2
 1370 0714 FB01      		movw r30,r22
 1371 0716 EA01      		movw r28,r20
2197:switcherator.c ****     int adjustment, mm, yy;
2198:switcherator.c **** 
2199:switcherator.c ****     adjustment = (14 - month) / 12; // Jan is 13, feb is 14 in calculation
 1372               		.loc 1 2199 0
 1373 0718 8EE0      		ldi r24,lo8(14)
 1374 071a 90E0      		ldi r25,0
 1375               	.LVL90:
 1376 071c 861B      		sub r24,r22
 1377 071e 970B      		sbc r25,r23
 1378 0720 6CE0      		ldi r22,lo8(12)
 1379 0722 70E0      		ldi r23,0
 1380               	.LVL91:
 1381 0724 0E94 0000 		call __divmodhi4
 1382               	.LVL92:
2200:switcherator.c ****     mm = month + 12 * adjustment - 2;
2201:switcherator.c ****     yy = globalYear - adjustment;
 1383               		.loc 1 2201 0
 1384 0728 2091 0000 		lds r18,globalYear
 1385 072c 3091 0000 		lds r19,globalYear+1
 1386 0730 261B      		sub r18,r22
 1387 0732 370B      		sbc r19,r23
 1388               	.LVL93:
2200:switcherator.c ****     mm = month + 12 * adjustment - 2;
 1389               		.loc 1 2200 0
 1390 0734 8CE0      		ldi r24,lo8(12)
 1391 0736 869F      		mul r24,r22
 1392 0738 A001      		movw r20,r0
 1393 073a 879F      		mul r24,r23
 1394 073c 500D      		add r21,r0
 1395 073e 1124      		clr __zero_reg__
 1396               	.LVL94:
 1397 0740 4E0F      		add r20,r30
 1398 0742 5F1F      		adc r21,r31
 1399 0744 4250      		subi r20,2
 1400 0746 5109      		sbc r21,__zero_reg__
2202:switcherator.c ****     return ((day + (13 * mm - 1) / 5 + yy + yy / 4 - yy / 100 + yy / 400) % 7);
 1401               		.loc 1 2202 0
 1402 0748 6DE0      		ldi r22,lo8(13)
 1403               	.LVL95:
 1404 074a 649F      		mul r22,r20
 1405 074c C001      		movw r24,r0
 1406 074e 659F      		mul r22,r21
 1407 0750 900D      		add r25,r0
 1408 0752 1124      		clr __zero_reg__
 1409 0754 0197      		sbiw r24,1
 1410 0756 65E0      		ldi r22,lo8(5)
 1411 0758 70E0      		ldi r23,0
 1412 075a 0E94 0000 		call __divmodhi4
 1413 075e C60F      		add r28,r22
 1414 0760 D71F      		adc r29,r23
 1415               	.LVL96:
 1416 0762 C20F      		add r28,r18
 1417 0764 D31F      		adc r29,r19
 1418 0766 F901      		movw r30,r18
 1419               	.LVL97:
 1420 0768 37FD      		sbrc r19,7
 1421 076a 3396      		adiw r30,3
 1422               	.L89:
 1423 076c F595      		asr r31
 1424 076e E795      		ror r30
 1425 0770 F595      		asr r31
 1426 0772 E795      		ror r30
 1427 0774 EC0F      		add r30,r28
 1428 0776 FD1F      		adc r31,r29
 1429 0778 C901      		movw r24,r18
 1430 077a 6CE9      		ldi r22,lo8(-100)
 1431 077c 7FEF      		ldi r23,lo8(-1)
 1432 077e 0E94 0000 		call __divmodhi4
 1433 0782 E60F      		add r30,r22
 1434 0784 F71F      		adc r31,r23
 1435 0786 C901      		movw r24,r18
 1436 0788 60E9      		ldi r22,lo8(-112)
 1437 078a 71E0      		ldi r23,lo8(1)
 1438 078c 0E94 0000 		call __divmodhi4
 1439 0790 E60F      		add r30,r22
 1440 0792 F71F      		adc r31,r23
 1441 0794 CF01      		movw r24,r30
 1442 0796 67E0      		ldi r22,lo8(7)
 1443 0798 70E0      		ldi r23,0
 1444 079a 0E94 0000 		call __divmodhi4
 1445               	/* epilogue start */
2203:switcherator.c **** }
 1446               		.loc 1 2203 0
 1447 079e DF91      		pop r29
 1448 07a0 CF91      		pop r28
 1449 07a2 0895      		ret
 1450               	.LFE52:
 1452               		.section	.rodata
 1453               	.LC0:
 1454 0000 0000      		.word	0
 1455 0002 1F00      		.word	31
 1456 0004 1C00      		.word	28
 1457 0006 1F00      		.word	31
 1458 0008 1E00      		.word	30
 1459 000a 1F00      		.word	31
 1460 000c 1E00      		.word	30
 1461 000e 1F00      		.word	31
 1462 0010 1F00      		.word	31
 1463 0012 1E00      		.word	30
 1464 0014 1F00      		.word	31
 1465 0016 1E00      		.word	30
 1466               		.text
 1467               	.global	getDayofYear
 1469               	getDayofYear:
 1470               	.LFB53:
2204:switcherator.c **** 
2205:switcherator.c **** // returns the day of the year (1 - 365 or 366)
2206:switcherator.c **** 
2207:switcherator.c **** int getDayofYear(int year, int month, int day) {
 1471               		.loc 1 2207 0
 1472               	.LVL98:
 1473 07a4 CF93      		push r28
 1474               	.LCFI33:
 1475 07a6 DF93      		push r29
 1476               	.LCFI34:
 1477 07a8 CDB7      		in r28,__SP_L__
 1478 07aa DEB7      		in r29,__SP_H__
 1479               	.LCFI35:
 1480 07ac 6897      		sbiw r28,24
 1481               	.LCFI36:
 1482 07ae 0FB6      		in __tmp_reg__,__SREG__
 1483 07b0 F894      		cli
 1484 07b2 DEBF      		out __SP_H__,r29
 1485 07b4 0FBE      		out __SREG__,__tmp_reg__
 1486 07b6 CDBF      		out __SP_L__,r28
 1487               	/* prologue: function */
 1488               	/* frame size = 24 */
 1489               	/* stack size = 26 */
 1490               	.L__stack_usage = 26
2208:switcherator.c ****     int months[12] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30};
 1491               		.loc 1 2208 0
 1492 07b8 28E1      		ldi r18,lo8(24)
 1493 07ba E0E0      		ldi r30,lo8(.LC0)
 1494 07bc F0E0      		ldi r31,hi8(.LC0)
 1495 07be DE01      		movw r26,r28
 1496 07c0 1196      		adiw r26,1
 1497               		0:
 1498 07c2 0190      		ld r0,Z+
 1499 07c4 0D92      		st X+,r0
 1500 07c6 2A95      		dec r18
 1501 07c8 01F4      		brne 0b
 1502               	.LVL99:
2209:switcherator.c ****     int x = 0;
2210:switcherator.c ****     // adjust feb for leap year
2211:switcherator.c ****     if ((year % 4) == 0)
 1503               		.loc 1 2211 0
 1504 07ca 8370      		andi r24,3
 1505 07cc 9927      		clr r25
 1506               	.LVL100:
 1507 07ce 892B      		or r24,r25
 1508 07d0 01F4      		brne .L91
2212:switcherator.c ****         months[3] = 29;
 1509               		.loc 1 2212 0
 1510 07d2 8DE1      		ldi r24,lo8(29)
 1511 07d4 90E0      		ldi r25,0
 1512 07d6 9887      		std Y+8,r25
 1513 07d8 8F83      		std Y+7,r24
 1514               	.L91:
 1515               	.LVL101:
 1516 07da FE01      		movw r30,r28
 1517 07dc 3196      		adiw r30,1
2213:switcherator.c ****     // start with the day of the month, then add amounts for each month
2214:switcherator.c ****     int doy = day;
 1518               		.loc 1 2214 0
 1519 07de 9A01      		movw r18,r20
2215:switcherator.c ****     for (x = 0; x < month; x++) {
 1520               		.loc 1 2215 0
 1521 07e0 80E0      		ldi r24,0
 1522 07e2 90E0      		ldi r25,0
 1523 07e4 00C0      		rjmp .L92
 1524               	.LVL102:
 1525               	.L93:
2216:switcherator.c ****         doy += months[x];
 1526               		.loc 1 2216 0 discriminator 2
 1527 07e6 4191      		ld r20,Z+
 1528 07e8 5191      		ld r21,Z+
 1529 07ea 240F      		add r18,r20
 1530 07ec 351F      		adc r19,r21
 1531               	.LVL103:
2215:switcherator.c ****     for (x = 0; x < month; x++) {
 1532               		.loc 1 2215 0 discriminator 2
 1533 07ee 0196      		adiw r24,1
 1534               	.LVL104:
 1535               	.L92:
2215:switcherator.c ****     for (x = 0; x < month; x++) {
 1536               		.loc 1 2215 0 is_stmt 0 discriminator 1
 1537 07f0 8617      		cp r24,r22
 1538 07f2 9707      		cpc r25,r23
 1539 07f4 04F0      		brlt .L93
2217:switcherator.c ****     }
2218:switcherator.c ****     return doy;
2219:switcherator.c **** }
 1540               		.loc 1 2219 0 is_stmt 1
 1541 07f6 C901      		movw r24,r18
 1542               	.LVL105:
 1543               	/* epilogue start */
 1544 07f8 6896      		adiw r28,24
 1545 07fa 0FB6      		in __tmp_reg__,__SREG__
 1546 07fc F894      		cli
 1547 07fe DEBF      		out __SP_H__,r29
 1548 0800 0FBE      		out __SREG__,__tmp_reg__
 1549 0802 CDBF      		out __SP_L__,r28
 1550 0804 DF91      		pop r29
 1551 0806 CF91      		pop r28
 1552 0808 0895      		ret
 1553               	.LFE53:
 1555               	.global	checkDaylightSavings
 1557               	checkDaylightSavings:
 1558               	.LFB55:
2220:switcherator.c **** 
2221:switcherator.c **** // Sets up the days we do daylight savings
2222:switcherator.c **** // DS:MMDD MMDD
2223:switcherator.c **** // 012345678901
2224:switcherator.c **** 
2225:switcherator.c **** void setDaylightSavings(char * commandReceived) {
2226:switcherator.c ****     int dlInt;
2227:switcherator.c ****     tempIntString[0] = commandReceived[3];
2228:switcherator.c ****     tempIntString[1] = commandReceived[4];
2229:switcherator.c ****     dlInt = atoi(tempIntString);
2230:switcherator.c ****     daylightSavings[0][0] = dlInt;
2231:switcherator.c ****     tempIntString[0] = commandReceived[5];
2232:switcherator.c ****     tempIntString[1] = commandReceived[6];
2233:switcherator.c ****     dlInt = atoi(tempIntString);
2234:switcherator.c ****     daylightSavings[0][1] = dlInt;
2235:switcherator.c ****     tempIntString[0] = commandReceived[8];
2236:switcherator.c ****     tempIntString[1] = commandReceived[9];
2237:switcherator.c ****     dlInt = atoi(tempIntString);
2238:switcherator.c ****     daylightSavings[1][0] = dlInt;
2239:switcherator.c ****     tempIntString[0] = commandReceived[10];
2240:switcherator.c ****     tempIntString[1] = commandReceived[11];
2241:switcherator.c ****     dlInt = atoi(tempIntString);
2242:switcherator.c ****     daylightSavings[1][1] = dlInt;
2243:switcherator.c ****     ok();
2244:switcherator.c **** }
2245:switcherator.c **** 
2246:switcherator.c **** // Decide if this 3:00am is daylight savings and adjust accordingly
2247:switcherator.c **** 
2248:switcherator.c **** void checkDaylightSavings(void) {
 1559               		.loc 1 2248 0
 1560               	/* prologue: function */
 1561               	/* frame size = 0 */
 1562               	/* stack size = 0 */
 1563               	.L__stack_usage = 0
2249:switcherator.c ****     // have we adjusted for daylight savings?
2250:switcherator.c ****     if (wasDaylightSavings == 1)
 1564               		.loc 1 2250 0
 1565 080a 8091 0000 		lds r24,wasDaylightSavings
 1566 080e 8130      		cpi r24,lo8(1)
 1567 0810 01F0      		breq .L94
2251:switcherator.c ****         return;
2252:switcherator.c ****     if (globalMonth == daylightSavings[0][0] && globalDay == daylightSavings[0][1]) {
 1568               		.loc 1 2252 0
 1569 0812 8091 0000 		lds r24,globalMonth
 1570 0816 9091 0000 		lds r25,globalMonth+1
 1571 081a 2091 0000 		lds r18,daylightSavings
 1572 081e 3091 0000 		lds r19,daylightSavings+1
 1573 0822 8217      		cp r24,r18
 1574 0824 9307      		cpc r25,r19
 1575 0826 01F4      		brne .L96
 1576               		.loc 1 2252 0 is_stmt 0 discriminator 1
 1577 0828 4091 0000 		lds r20,globalDay
 1578 082c 5091 0000 		lds r21,globalDay+1
 1579 0830 2091 0000 		lds r18,daylightSavings+2
 1580 0834 3091 0000 		lds r19,daylightSavings+2+1
 1581 0838 4217      		cp r20,r18
 1582 083a 5307      		cpc r21,r19
 1583 083c 01F4      		brne .L96
2253:switcherator.c ****         wasDaylightSavings = 1;
 1584               		.loc 1 2253 0 is_stmt 1
 1585 083e 81E0      		ldi r24,lo8(1)
 1586 0840 8093 0000 		sts wasDaylightSavings,r24
2254:switcherator.c ****         globalHour++;
 1587               		.loc 1 2254 0
 1588 0844 8091 0000 		lds r24,globalHour
 1589 0848 9091 0000 		lds r25,globalHour+1
 1590 084c 0196      		adiw r24,1
 1591 084e 00C0      		rjmp .L100
 1592               	.L96:
2255:switcherator.c ****     } else if (globalMonth == daylightSavings[1][0] && globalDay == daylightSavings[1][1]) {
 1593               		.loc 1 2255 0
 1594 0850 2091 0000 		lds r18,daylightSavings+4
 1595 0854 3091 0000 		lds r19,daylightSavings+4+1
 1596 0858 8217      		cp r24,r18
 1597 085a 9307      		cpc r25,r19
 1598 085c 01F4      		brne .L94
 1599               		.loc 1 2255 0 is_stmt 0 discriminator 1
 1600 085e 2091 0000 		lds r18,globalDay
 1601 0862 3091 0000 		lds r19,globalDay+1
 1602 0866 8091 0000 		lds r24,daylightSavings+6
 1603 086a 9091 0000 		lds r25,daylightSavings+6+1
 1604 086e 2817      		cp r18,r24
 1605 0870 3907      		cpc r19,r25
 1606 0872 01F4      		brne .L94
2256:switcherator.c ****         wasDaylightSavings = 1;
 1607               		.loc 1 2256 0 is_stmt 1
 1608 0874 81E0      		ldi r24,lo8(1)
 1609 0876 8093 0000 		sts wasDaylightSavings,r24
2257:switcherator.c ****         globalHour--;
 1610               		.loc 1 2257 0
 1611 087a 8091 0000 		lds r24,globalHour
 1612 087e 9091 0000 		lds r25,globalHour+1
 1613 0882 0197      		sbiw r24,1
 1614               	.L100:
 1615 0884 9093 0000 		sts globalHour+1,r25
 1616 0888 8093 0000 		sts globalHour,r24
 1617               	.L94:
 1618 088c 0895      		ret
 1619               	.LFE55:
 1621               	.global	advanceDay
 1623               	advanceDay:
 1624               	.LFB56:
2258:switcherator.c ****     }
2259:switcherator.c **** }
2260:switcherator.c **** 
2261:switcherator.c **** // Advance a day in the calendar. 
2262:switcherator.c **** 
2263:switcherator.c **** void advanceDay(void) {
 1625               		.loc 1 2263 0
 1626               	/* prologue: function */
 1627               	/* frame size = 0 */
 1628               	/* stack size = 0 */
 1629               	.L__stack_usage = 0
 1630               	.LVL106:
2264:switcherator.c ****     int x = 0;
2265:switcherator.c ****     // Reset the daylight savings for next time
2266:switcherator.c ****     wasDaylightSavings = 0;
 1631               		.loc 1 2266 0
 1632 088e 1092 0000 		sts wasDaylightSavings,__zero_reg__
2267:switcherator.c ****     // start with dow
2268:switcherator.c ****     dow++;
 1633               		.loc 1 2268 0
 1634 0892 8091 0000 		lds r24,dow
 1635 0896 9091 0000 		lds r25,dow+1
 1636 089a 0196      		adiw r24,1
 1637 089c 9093 0000 		sts dow+1,r25
 1638 08a0 8093 0000 		sts dow,r24
2269:switcherator.c ****     if (dow == 7) {
 1639               		.loc 1 2269 0
 1640 08a4 0797      		sbiw r24,7
 1641 08a6 01F0      		breq .L102
 1642               	.LVL107:
 1643               	.L107:
2270:switcherator.c ****         // reset it to Sunday
2271:switcherator.c ****         dow = 0;
2272:switcherator.c ****         weeklySeconds = 0;
2273:switcherator.c ****         // switchStatus might be more than a week (604,800 seconds)
2274:switcherator.c ****         for (x = 0; x < NUM_SWITCHES; x++) {
2275:switcherator.c ****             if (switchStatus[x] >= 604800)
2276:switcherator.c ****                 switchStatus[x] -= 604800;
2277:switcherator.c ****         }
2278:switcherator.c ****     }
2279:switcherator.c ****     // then the day
2280:switcherator.c ****     globalDay++;
 1644               		.loc 1 2280 0
 1645 08a8 2091 0000 		lds r18,globalDay
 1646 08ac 3091 0000 		lds r19,globalDay+1
 1647 08b0 2F5F      		subi r18,-1
 1648 08b2 3F4F      		sbci r19,-1
 1649 08b4 3093 0000 		sts globalDay+1,r19
 1650 08b8 2093 0000 		sts globalDay,r18
2281:switcherator.c ****     // If we aren't advancing a month just move on
2282:switcherator.c ****     if (globalDay <= 28) {
 1651               		.loc 1 2282 0
 1652 08bc 2D31      		cpi r18,29
 1653 08be 3105      		cpc r19,__zero_reg__
 1654 08c0 00F4      		brsh .L140
 1655 08c2 0895      		ret
 1656               	.LVL108:
 1657               	.L102:
2271:switcherator.c ****         dow = 0;
 1658               		.loc 1 2271 0
 1659 08c4 1092 0000 		sts dow+1,__zero_reg__
 1660 08c8 1092 0000 		sts dow,__zero_reg__
2272:switcherator.c ****         weeklySeconds = 0;
 1661               		.loc 1 2272 0
 1662 08cc 1092 0000 		sts weeklySeconds,__zero_reg__
 1663 08d0 1092 0000 		sts weeklySeconds+1,__zero_reg__
 1664 08d4 1092 0000 		sts weeklySeconds+2,__zero_reg__
 1665 08d8 1092 0000 		sts weeklySeconds+3,__zero_reg__
 1666 08dc E0E0      		ldi r30,lo8(switchStatus)
 1667 08de F0E0      		ldi r31,hi8(switchStatus)
 1668               	.LVL109:
 1669               	.L106:
2275:switcherator.c ****             if (switchStatus[x] >= 604800)
 1670               		.loc 1 2275 0
 1671 08e0 8081      		ld r24,Z
 1672 08e2 9181      		ldd r25,Z+1
 1673 08e4 A281      		ldd r26,Z+2
 1674 08e6 B381      		ldd r27,Z+3
 1675 08e8 8038      		cpi r24,-128
 1676 08ea 2AE3      		ldi r18,58
 1677 08ec 9207      		cpc r25,r18
 1678 08ee 29E0      		ldi r18,9
 1679 08f0 A207      		cpc r26,r18
 1680 08f2 B105      		cpc r27,__zero_reg__
 1681 08f4 00F0      		brlo .L105
2276:switcherator.c ****                 switchStatus[x] -= 604800;
 1682               		.loc 1 2276 0
 1683 08f6 8058      		subi r24,-128
 1684 08f8 9A43      		sbci r25,58
 1685 08fa A940      		sbci r26,9
 1686 08fc B109      		sbc r27,__zero_reg__
 1687 08fe 8083      		st Z,r24
 1688 0900 9183      		std Z+1,r25
 1689 0902 A283      		std Z+2,r26
 1690 0904 B383      		std Z+3,r27
 1691               	.L105:
 1692 0906 3496      		adiw r30,4
2274:switcherator.c ****         for (x = 0; x < NUM_SWITCHES; x++) {
 1693               		.loc 1 2274 0
 1694 0908 80E0      		ldi r24,hi8(switchStatus+64)
 1695 090a E030      		cpi r30,lo8(switchStatus+64)
 1696 090c F807      		cpc r31,r24
 1697 090e 01F4      		brne .L106
 1698 0910 00C0      		rjmp .L107
 1699               	.L140:
2283:switcherator.c ****         return;
2284:switcherator.c ****     }
2285:switcherator.c ****     // possibly advancing a month
2286:switcherator.c ****     switch (globalMonth) {
 1700               		.loc 1 2286 0
 1701 0912 8091 0000 		lds r24,globalMonth
 1702 0916 9091 0000 		lds r25,globalMonth+1
 1703 091a 8630      		cpi r24,6
 1704 091c 9105      		cpc r25,__zero_reg__
 1705 091e 01F0      		breq .L110
 1706 0920 00F4      		brsh .L112
 1707 0922 8330      		cpi r24,3
 1708 0924 9105      		cpc r25,__zero_reg__
 1709 0926 01F0      		breq .L108
 1710 0928 00F4      		brsh .L113
 1711 092a 8130      		cpi r24,1
 1712 092c 9105      		cpc r25,__zero_reg__
 1713 092e 01F0      		breq .L108
 1714 0930 0297      		sbiw r24,2
 1715 0932 01F0      		breq .+2
 1716 0934 00C0      		rjmp .L101
 1717 0936 00C0      		rjmp .L109
 1718               	.L113:
 1719 0938 8430      		cpi r24,4
 1720 093a 9105      		cpc r25,__zero_reg__
 1721 093c 01F0      		breq .L110
 1722 093e 8530      		cpi r24,5
 1723 0940 9105      		cpc r25,__zero_reg__
 1724 0942 01F0      		breq .+2
 1725 0944 00C0      		rjmp .L101
 1726 0946 00C0      		rjmp .L108
 1727               	.L112:
 1728 0948 8930      		cpi r24,9
 1729 094a 9105      		cpc r25,__zero_reg__
 1730 094c 01F0      		breq .L110
 1731 094e 00F0      		brlo .L108
 1732 0950 8B30      		cpi r24,11
 1733 0952 9105      		cpc r25,__zero_reg__
 1734 0954 01F0      		breq .L110
 1735 0956 00F0      		brlo .L108
 1736 0958 0C97      		sbiw r24,12
 1737 095a 01F4      		brne .L101
 1738 095c 00C0      		rjmp .L111
 1739               	.L110:
2287:switcherator.c ****         // 30 days have september, april, june and november
2288:switcherator.c ****         case 4:
2289:switcherator.c ****         case 6:
2290:switcherator.c ****         case 9:
2291:switcherator.c ****         case 11:
2292:switcherator.c ****             if (globalDay > 30) {
 1740               		.loc 1 2292 0
 1741 095e 2F31      		cpi r18,31
 1742 0960 3105      		cpc r19,__zero_reg__
 1743 0962 00F0      		brlo .L101
 1744 0964 00C0      		rjmp .L142
 1745               	.L108:
2293:switcherator.c ****                 globalDay = 1;
2294:switcherator.c ****                 globalMonth++;
2295:switcherator.c ****             } else {
2296:switcherator.c ****                 return;
2297:switcherator.c ****             }
2298:switcherator.c ****             break;
2299:switcherator.c ****         case 1:
2300:switcherator.c ****         case 3:
2301:switcherator.c ****         case 5:
2302:switcherator.c ****         case 7:
2303:switcherator.c ****         case 8:
2304:switcherator.c ****         case 10:
2305:switcherator.c ****             if (globalDay > 31) {
 1746               		.loc 1 2305 0
 1747 0966 2032      		cpi r18,32
 1748 0968 3105      		cpc r19,__zero_reg__
 1749 096a 00F0      		brlo .L101
 1750               	.L142:
2306:switcherator.c ****                 globalDay = 1;
 1751               		.loc 1 2306 0
 1752 096c 21E0      		ldi r18,lo8(1)
 1753 096e 30E0      		ldi r19,0
 1754 0970 3093 0000 		sts globalDay+1,r19
 1755 0974 2093 0000 		sts globalDay,r18
2307:switcherator.c ****                 globalMonth++;
 1756               		.loc 1 2307 0
 1757 0978 0196      		adiw r24,1
 1758 097a 00C0      		rjmp .L141
 1759               	.L111:
2308:switcherator.c ****             } else {
2309:switcherator.c ****                 return;
2310:switcherator.c ****             }
2311:switcherator.c ****             break;
2312:switcherator.c ****         case 12:
2313:switcherator.c ****             if (globalDay > 31) {
 1760               		.loc 1 2313 0
 1761 097c 2032      		cpi r18,32
 1762 097e 3105      		cpc r19,__zero_reg__
 1763 0980 00F0      		brlo .L101
2314:switcherator.c ****                 // happy new year
2315:switcherator.c ****                 globalDay = 1;
 1764               		.loc 1 2315 0
 1765 0982 81E0      		ldi r24,lo8(1)
 1766 0984 90E0      		ldi r25,0
 1767 0986 9093 0000 		sts globalDay+1,r25
 1768 098a 8093 0000 		sts globalDay,r24
2316:switcherator.c ****                 globalMonth = 1;
 1769               		.loc 1 2316 0
 1770 098e 9093 0000 		sts globalMonth+1,r25
 1771 0992 8093 0000 		sts globalMonth,r24
2317:switcherator.c ****                 globalYear++;
 1772               		.loc 1 2317 0
 1773 0996 8091 0000 		lds r24,globalYear
 1774 099a 9091 0000 		lds r25,globalYear+1
 1775 099e 0196      		adiw r24,1
 1776 09a0 9093 0000 		sts globalYear+1,r25
 1777 09a4 8093 0000 		sts globalYear,r24
2318:switcherator.c ****             } else {
2319:switcherator.c ****                 return;
2320:switcherator.c ****             }
2321:switcherator.c ****             break;
 1778               		.loc 1 2321 0
 1779 09a8 0895      		ret
 1780               	.L109:
2322:switcherator.c ****         case 2:
2323:switcherator.c ****             // leap year?
2324:switcherator.c ****             if (globalYear % 4 == 0) {
 1781               		.loc 1 2324 0
 1782 09aa 8091 0000 		lds r24,globalYear
 1783 09ae 9091 0000 		lds r25,globalYear+1
 1784 09b2 8370      		andi r24,3
 1785 09b4 9927      		clr r25
 1786 09b6 892B      		or r24,r25
 1787 09b8 01F4      		brne .L114
2325:switcherator.c ****                 // yes
2326:switcherator.c ****                 if (globalDay > 29) {
 1788               		.loc 1 2326 0
 1789 09ba 2D31      		cpi r18,29
 1790 09bc 3105      		cpc r19,__zero_reg__
 1791 09be 01F0      		breq .L101
 1792               	.L114:
2327:switcherator.c ****                     globalDay = 1;
2328:switcherator.c ****                     globalMonth++;
2329:switcherator.c ****                 } else {
2330:switcherator.c ****                     return;
2331:switcherator.c ****                 }
2332:switcherator.c ****             } else {
2333:switcherator.c ****                 if (globalDay > 28) {
2334:switcherator.c ****                     globalDay = 1;
 1793               		.loc 1 2334 0
 1794 09c0 81E0      		ldi r24,lo8(1)
 1795 09c2 90E0      		ldi r25,0
 1796 09c4 9093 0000 		sts globalDay+1,r25
 1797 09c8 8093 0000 		sts globalDay,r24
2335:switcherator.c ****                     globalMonth++;
 1798               		.loc 1 2335 0
 1799 09cc 83E0      		ldi r24,lo8(3)
 1800 09ce 90E0      		ldi r25,0
 1801               	.L141:
 1802 09d0 9093 0000 		sts globalMonth+1,r25
 1803 09d4 8093 0000 		sts globalMonth,r24
 1804               	.L101:
 1805 09d8 0895      		ret
 1806               	.LFE56:
 1808               	.global	timerCheck
 1810               	timerCheck:
 1811               	.LFB57:
2336:switcherator.c ****                 } else {
2337:switcherator.c ****                     return;
2338:switcherator.c ****                 }
2339:switcherator.c ****             }
2340:switcherator.c ****             break;
2341:switcherator.c ****     }
2342:switcherator.c ****     return;
2343:switcherator.c **** }
2344:switcherator.c **** 
2345:switcherator.c **** // runs every second.  Checks to see if we need to turn something on or off
2346:switcherator.c **** 
2347:switcherator.c **** void timerCheck(void) {
 1812               		.loc 1 2347 0
 1813 09da 6F92      		push r6
 1814               	.LCFI37:
 1815 09dc 7F92      		push r7
 1816               	.LCFI38:
 1817 09de 8F92      		push r8
 1818               	.LCFI39:
 1819 09e0 9F92      		push r9
 1820               	.LCFI40:
 1821 09e2 AF92      		push r10
 1822               	.LCFI41:
 1823 09e4 BF92      		push r11
 1824               	.LCFI42:
 1825 09e6 CF92      		push r12
 1826               	.LCFI43:
 1827 09e8 DF92      		push r13
 1828               	.LCFI44:
 1829 09ea EF92      		push r14
 1830               	.LCFI45:
 1831 09ec FF92      		push r15
 1832               	.LCFI46:
 1833 09ee 0F93      		push r16
 1834               	.LCFI47:
 1835 09f0 1F93      		push r17
 1836               	.LCFI48:
 1837 09f2 CF93      		push r28
 1838               	.LCFI49:
 1839 09f4 DF93      		push r29
 1840               	.LCFI50:
 1841               	/* prologue: function */
 1842               	/* frame size = 0 */
 1843               	/* stack size = 14 */
 1844               	.L__stack_usage = 14
 1845               	.LVL110:
2348:switcherator.c ****     int x = 0;
2349:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
2350:switcherator.c ****         // see if something should turn off
2351:switcherator.c ****         if ((switchStatus[x] > 0) && (switchStatus[x] < weeklySeconds)) {
 1846               		.loc 1 2351 0
 1847 09f6 4091 0000 		lds r20,weeklySeconds
 1848 09fa 5091 0000 		lds r21,weeklySeconds+1
 1849 09fe 6091 0000 		lds r22,weeklySeconds+2
 1850 0a02 7091 0000 		lds r23,weeklySeconds+3
 1851 0a06 2091 0000 		lds r18,switchChanged
 1852 0a0a E0E0      		ldi r30,lo8(switchStatus)
 1853 0a0c F0E0      		ldi r31,hi8(switchStatus)
 1854               	.LVL111:
 1855               	.L145:
 1856 0a0e 8081      		ld r24,Z
 1857 0a10 9181      		ldd r25,Z+1
 1858 0a12 A281      		ldd r26,Z+2
 1859 0a14 B381      		ldd r27,Z+3
 1860 0a16 0097      		sbiw r24,0
 1861 0a18 A105      		cpc r26,__zero_reg__
 1862 0a1a B105      		cpc r27,__zero_reg__
 1863 0a1c 01F0      		breq .L144
 1864               		.loc 1 2351 0 is_stmt 0 discriminator 1
 1865 0a1e 8417      		cp r24,r20
 1866 0a20 9507      		cpc r25,r21
 1867 0a22 A607      		cpc r26,r22
 1868 0a24 B707      		cpc r27,r23
 1869 0a26 00F4      		brsh .L144
2352:switcherator.c ****             switchChanged = 1;
2353:switcherator.c ****             switchStatus[x] = 0;
 1870               		.loc 1 2353 0 is_stmt 1
 1871 0a28 1082      		st Z,__zero_reg__
 1872 0a2a 1182      		std Z+1,__zero_reg__
 1873 0a2c 1282      		std Z+2,__zero_reg__
 1874 0a2e 1382      		std Z+3,__zero_reg__
2352:switcherator.c ****             switchChanged = 1;
 1875               		.loc 1 2352 0
 1876 0a30 21E0      		ldi r18,lo8(1)
 1877               	.L144:
 1878 0a32 3496      		adiw r30,4
2349:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 1879               		.loc 1 2349 0
 1880 0a34 80E0      		ldi r24,hi8(switchStatus+64)
 1881 0a36 E030      		cpi r30,lo8(switchStatus+64)
 1882 0a38 F807      		cpc r31,r24
 1883 0a3a 01F4      		brne .L145
 1884 0a3c 2093 0000 		sts switchChanged,r18
 1885 0a40 C0E0      		ldi r28,lo8(weeklyProgram+4)
 1886 0a42 D0E0      		ldi r29,hi8(weeklyProgram+4)
 1887 0a44 00E0      		ldi r16,0
 1888 0a46 10E0      		ldi r17,0
2354:switcherator.c ****         }
2355:switcherator.c ****     }
2356:switcherator.c ****     // see if something should turn on
2357:switcherator.c ****     // weeklyProgram format
2358:switcherator.c ****     // DssddSSSSP
2359:switcherator.c ****     // 0123456789
2360:switcherator.c ****     long time;
2361:switcherator.c ****     int today = 0;
2362:switcherator.c ****     int duration = 0;
2363:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
2364:switcherator.c ****         // check if there is a valid program
2365:switcherator.c ****         if (weeklyProgram[x][0] != 255 && weeklyProgram[x][1] != 255) { // yes
2366:switcherator.c ****             // see if it goes today
2367:switcherator.c ****             // if dow = 0 (sunday) the program stores this as 0x40 then down from there
2368:switcherator.c ****             today = (0x40 >> dow);
 1889               		.loc 1 2368 0
 1890 0a48 30E4      		ldi r19,lo8(64)
 1891 0a4a C32E      		mov r12,r19
 1892 0a4c D12C      		mov r13,__zero_reg__
 1893               	.L147:
2347:switcherator.c **** void timerCheck(void) {
 1894               		.loc 1 2347 0
 1895 0a4e FE01      		movw r30,r28
 1896 0a50 3497      		sbiw r30,4
2365:switcherator.c ****         if (weeklyProgram[x][0] != 255 && weeklyProgram[x][1] != 255) { // yes
 1897               		.loc 1 2365 0
 1898 0a52 8081      		ld r24,Z
 1899 0a54 8F3F      		cpi r24,lo8(-1)
 1900 0a56 01F4      		brne .+2
 1901 0a58 00C0      		rjmp .L146
2347:switcherator.c **** void timerCheck(void) {
 1902               		.loc 1 2347 0 discriminator 1
 1903 0a5a FE01      		movw r30,r28
 1904 0a5c 3397      		sbiw r30,3
2365:switcherator.c ****         if (weeklyProgram[x][0] != 255 && weeklyProgram[x][1] != 255) { // yes
 1905               		.loc 1 2365 0 discriminator 1
 1906 0a5e 2081      		ld r18,Z
 1907 0a60 2F3F      		cpi r18,lo8(-1)
 1908 0a62 01F4      		brne .+2
 1909 0a64 00C0      		rjmp .L146
 1910               		.loc 1 2368 0
 1911 0a66 7090 0000 		lds r7,dow
 1912 0a6a 6090 0000 		lds r6,dow+1
 1913               	.LVL112:
2369:switcherator.c ****             // k is today the day?
2370:switcherator.c ****             if (weeklyProgram[x][0] & today) {
 1914               		.loc 1 2370 0
 1915 0a6e 90E0      		ldi r25,0
2368:switcherator.c ****             today = (0x40 >> dow);
 1916               		.loc 1 2368 0
 1917 0a70 A601      		movw r20,r12
 1918 0a72 072C      		mov r0,r7
 1919 0a74 00C0      		rjmp 2f
 1920               		1:
 1921 0a76 5595      		asr r21
 1922 0a78 4795      		ror r20
 1923               		2:
 1924 0a7a 0A94      		dec r0
 1925 0a7c 02F4      		brpl 1b
 1926               		.loc 1 2370 0
 1927 0a7e 8423      		and r24,r20
 1928 0a80 9523      		and r25,r21
 1929 0a82 892B      		or r24,r25
 1930 0a84 01F4      		brne .+2
 1931 0a86 00C0      		rjmp .L146
2371:switcherator.c **** 
2372:switcherator.c ****                 // yes we run today
2373:switcherator.c ****                 time = weeklyProgram[x][1];
 1932               		.loc 1 2373 0
 1933 0a88 822F      		mov r24,r18
 1934 0a8a 90E0      		ldi r25,0
 1935 0a8c A0E0      		ldi r26,0
 1936 0a8e B0E0      		ldi r27,0
 1937               	.LVL113:
2374:switcherator.c ****                 time <<= 8;
 1938               		.loc 1 2374 0
 1939 0a90 2227      		clr r18
 1940 0a92 382F      		mov r19,r24
 1941 0a94 492F      		mov r20,r25
 1942 0a96 5A2F      		mov r21,r26
 1943               	.LVL114:
2347:switcherator.c **** void timerCheck(void) {
 1944               		.loc 1 2347 0
 1945 0a98 FE01      		movw r30,r28
 1946 0a9a 3297      		sbiw r30,2
2375:switcherator.c ****                 time |= weeklyProgram[x][2];
 1947               		.loc 1 2375 0
 1948 0a9c 8081      		ld r24,Z
 1949 0a9e 282B      		or r18,r24
 1950               	.LVL115:
2376:switcherator.c ****                 // weeklyProgram is stored in minutes
2377:switcherator.c ****                 time *= 60;
 1951               		.loc 1 2377 0
 1952 0aa0 ACE3      		ldi r26,lo8(60)
 1953 0aa2 B0E0      		ldi r27,0
 1954 0aa4 0E94 0000 		call __muluhisi3
 1955 0aa8 4B01      		movw r8,r22
 1956 0aaa 5C01      		movw r10,r24
 1957               	.LVL116:
2347:switcherator.c **** void timerCheck(void) {
 1958               		.loc 1 2347 0
 1959 0aac FE01      		movw r30,r28
 1960 0aae 3197      		sbiw r30,1
2378:switcherator.c ****                 duration = weeklyProgram[x][3];
 1961               		.loc 1 2378 0
 1962 0ab0 F081      		ld r31,Z
 1963               	.LVL117:
2379:switcherator.c ****                 duration <<= 8;
2380:switcherator.c ****                 duration |= weeklyProgram[x][4];
 1964               		.loc 1 2380 0
 1965 0ab2 E881      		ld r30,Y
 1966               	.LVL118:
2381:switcherator.c ****                 time += (dow * 86400); //seconds in day
 1967               		.loc 1 2381 0
 1968 0ab4 A72D      		mov r26,r7
 1969 0ab6 B62D      		mov r27,r6
 1970 0ab8 20E8      		ldi r18,lo8(-128)
 1971 0aba 31E5      		ldi r19,lo8(81)
 1972 0abc 41E0      		ldi r20,lo8(1)
 1973 0abe 50E0      		ldi r21,0
 1974 0ac0 0E94 0000 		call __muluhisi3
 1975 0ac4 860E      		add r8,r22
 1976 0ac6 971E      		adc r9,r23
 1977 0ac8 A81E      		adc r10,r24
 1978 0aca B91E      		adc r11,r25
 1979               	.LVL119:
2382:switcherator.c ****                 // check if we are between start & stop time
2383:switcherator.c ****                 if ((weeklySeconds >= time) && (weeklySeconds < (time + duration))) {
 1980               		.loc 1 2383 0
 1981 0acc 4091 0000 		lds r20,weeklySeconds
 1982 0ad0 5091 0000 		lds r21,weeklySeconds+1
 1983 0ad4 6091 0000 		lds r22,weeklySeconds+2
 1984 0ad8 7091 0000 		lds r23,weeklySeconds+3
 1985 0adc 4815      		cp r20,r8
 1986 0ade 5905      		cpc r21,r9
 1987 0ae0 6A05      		cpc r22,r10
 1988 0ae2 7B05      		cpc r23,r11
 1989 0ae4 00F0      		brlo .L146
2379:switcherator.c ****                 duration <<= 8;
 1990               		.loc 1 2379 0 discriminator 1
 1991 0ae6 FF2E      		mov r15,r31
 1992 0ae8 E12C      		mov r14,__zero_reg__
2380:switcherator.c ****                 duration |= weeklyProgram[x][4];
 1993               		.loc 1 2380 0 discriminator 1
 1994 0aea C701      		movw r24,r14
 1995 0aec 8E2B      		or r24,r30
 1996               		.loc 1 2383 0 discriminator 1
 1997 0aee AA27      		clr r26
 1998 0af0 97FD      		sbrc r25,7
 1999 0af2 A095      		com r26
 2000 0af4 BA2F      		mov r27,r26
 2001 0af6 880D      		add r24,r8
 2002 0af8 991D      		adc r25,r9
 2003 0afa AA1D      		adc r26,r10
 2004 0afc BB1D      		adc r27,r11
 2005 0afe 4817      		cp r20,r24
 2006 0b00 5907      		cpc r21,r25
 2007 0b02 6A07      		cpc r22,r26
 2008 0b04 7B07      		cpc r23,r27
 2009 0b06 00F4      		brsh .L146
2384:switcherator.c ****                     // feed time to it so the end time won't change
2385:switcherator.c ****                     startTheProgram(x, 0, time);
 2010               		.loc 1 2385 0
 2011 0b08 A501      		movw r20,r10
 2012 0b0a 9401      		movw r18,r8
 2013 0b0c 60E0      		ldi r22,0
 2014 0b0e 70E0      		ldi r23,0
 2015 0b10 C801      		movw r24,r16
 2016 0b12 0E94 0000 		call startTheProgram
 2017               	.LVL120:
 2018               	.L146:
2363:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 2019               		.loc 1 2363 0
 2020 0b16 0F5F      		subi r16,-1
 2021 0b18 1F4F      		sbci r17,-1
 2022               	.LVL121:
 2023 0b1a 2A96      		adiw r28,10
 2024 0b1c 0431      		cpi r16,20
 2025 0b1e 1105      		cpc r17,__zero_reg__
 2026 0b20 01F0      		breq .+2
 2027 0b22 00C0      		rjmp .L147
 2028               	/* epilogue start */
2386:switcherator.c ****                 }
2387:switcherator.c ****             }
2388:switcherator.c ****         }
2389:switcherator.c ****     }
2390:switcherator.c **** }
 2029               		.loc 1 2390 0
 2030 0b24 DF91      		pop r29
 2031 0b26 CF91      		pop r28
 2032 0b28 1F91      		pop r17
 2033 0b2a 0F91      		pop r16
 2034               	.LVL122:
 2035 0b2c FF90      		pop r15
 2036 0b2e EF90      		pop r14
 2037 0b30 DF90      		pop r13
 2038 0b32 CF90      		pop r12
 2039 0b34 BF90      		pop r11
 2040 0b36 AF90      		pop r10
 2041 0b38 9F90      		pop r9
 2042 0b3a 8F90      		pop r8
 2043 0b3c 7F90      		pop r7
 2044 0b3e 6F90      		pop r6
 2045 0b40 0895      		ret
 2046               	.LFE57:
 2048               	.global	switchOnOff
 2050               	switchOnOff:
 2051               	.LFB58:
2391:switcherator.c **** 
2392:switcherator.c **** // iterate through the switches and turn them on or off
2393:switcherator.c **** 
2394:switcherator.c **** void switchOnOff(void) {
 2052               		.loc 1 2394 0
 2053 0b42 7F92      		push r7
 2054               	.LCFI51:
 2055 0b44 8F92      		push r8
 2056               	.LCFI52:
 2057 0b46 9F92      		push r9
 2058               	.LCFI53:
 2059 0b48 AF92      		push r10
 2060               	.LCFI54:
 2061 0b4a BF92      		push r11
 2062               	.LCFI55:
 2063 0b4c CF92      		push r12
 2064               	.LCFI56:
 2065 0b4e DF92      		push r13
 2066               	.LCFI57:
 2067 0b50 EF92      		push r14
 2068               	.LCFI58:
 2069 0b52 FF92      		push r15
 2070               	.LCFI59:
 2071 0b54 0F93      		push r16
 2072               	.LCFI60:
 2073 0b56 1F93      		push r17
 2074               	.LCFI61:
 2075 0b58 CF93      		push r28
 2076               	.LCFI62:
 2077 0b5a DF93      		push r29
 2078               	.LCFI63:
 2079 0b5c 00D0      		rcall .
 2080 0b5e 1F92      		push __zero_reg__
 2081               	.LCFI64:
 2082 0b60 CDB7      		in r28,__SP_L__
 2083 0b62 DEB7      		in r29,__SP_H__
 2084               	.LCFI65:
 2085               	/* prologue: function */
 2086               	/* frame size = 3 */
 2087               	/* stack size = 16 */
 2088               	.L__stack_usage = 16
 2089               	.LVL123:
 2090 0b64 10E0      		ldi r17,lo8(switchStuff)
 2091 0b66 812E      		mov r8,r17
 2092 0b68 10E0      		ldi r17,hi8(switchStuff)
 2093 0b6a 912E      		mov r9,r17
 2094 0b6c 00E0      		ldi r16,lo8(switchStatus)
 2095 0b6e C02E      		mov r12,r16
 2096 0b70 00E0      		ldi r16,hi8(switchStatus)
 2097 0b72 D02E      		mov r13,r16
2395:switcherator.c ****     char port[1];
2396:switcherator.c ****     char pin[1];
2397:switcherator.c ****     int realPin = 0;
2398:switcherator.c ****     int x = 0;
2399:switcherator.c ****     char direction[1];
2400:switcherator.c ****     volatile unsigned char *thisPort = 0;
 2098               		.loc 1 2400 0
 2099 0b74 00E0      		ldi r16,0
 2100 0b76 10E0      		ldi r17,0
2401:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 2101               		.loc 1 2401 0
 2102 0b78 E12C      		mov r14,__zero_reg__
 2103 0b7a F12C      		mov r15,__zero_reg__
2402:switcherator.c ****         // see if a switch is set up
2403:switcherator.c ****         if (switchStuff[x] != 255) {
2404:switcherator.c ****             // find out if this is pwm
2405:switcherator.c ****             if (switchStuff[x] >= 200 && switchStuff[x] <= 220) {
2406:switcherator.c ****                 // are we turning it on or off
2407:switcherator.c ****                 if (switchStatus[x] == 0) {
2408:switcherator.c ****                     // turning it off
2409:switcherator.c ****                     if (switchStuff[x] == 200) {
2410:switcherator.c ****                         Red = 0;
2411:switcherator.c ****                         Green = 0;
2412:switcherator.c ****                         Blue = 0;
2413:switcherator.c ****                     } else if (switchStuff[x] == 201) {
2414:switcherator.c ****                         Red = 0;
2415:switcherator.c ****                         Green = 0;
2416:switcherator.c ****                         Blue = 0;
2417:switcherator.c ****                         runHue = 0;
2418:switcherator.c ****                     } else if (switchStuff[x] == 202) {
2419:switcherator.c ****                         Red = 0;
2420:switcherator.c ****                         Green = 0;
2421:switcherator.c ****                         Blue = 0;
2422:switcherator.c ****                         runColorChanges = 0;
2423:switcherator.c ****                     } else if (switchStuff[x] == 212) {
2424:switcherator.c ****                         bright = oldBright;
2425:switcherator.c ****                     }
2426:switcherator.c ****                 } else {
2427:switcherator.c ****                     // turn it on
2428:switcherator.c ****                     // decide if it is a changing hue or static values
2429:switcherator.c ****                     if (switchStuff[x] == 200) {
2430:switcherator.c ****                         // even numbers are static colors;
2431:switcherator.c ****                         red = pwmValues[0];
2432:switcherator.c ****                         green = pwmValues[1];
2433:switcherator.c ****                         blue = pwmValues[2];
2434:switcherator.c ****                         red = red * bright / 16;
2435:switcherator.c ****                         green = green * bright / 16;
2436:switcherator.c ****                         blue = blue * bright / 16;
2437:switcherator.c ****                         Red = red;
2438:switcherator.c ****                         Green = green;
2439:switcherator.c ****                         Blue = blue;
2440:switcherator.c ****                     } else if (switchStuff[x] == 202) {
2441:switcherator.c ****                         runColorChanges = 1;
2442:switcherator.c ****                     } else if (switchStuff[x] == 212) {
2443:switcherator.c ****                         // change the brightness
2444:switcherator.c ****                         bright = switchBright[x];
2445:switcherator.c ****                     } else {
2446:switcherator.c ****                         // get the hue cycle going
2447:switcherator.c ****                         runHue = 1;
2448:switcherator.c ****                     }
2449:switcherator.c ****                 }
2450:switcherator.c ****                 continue;
2451:switcherator.c ****             }
2452:switcherator.c ****             // switch is set up. Get details
2453:switcherator.c ****             getPort(x, port, pin, direction);
2454:switcherator.c ****             // yeah pointers and casts and whatevers. this fixes it
2455:switcherator.c ****             realPin = pin[0];
2456:switcherator.c ****             if (port[0] == 'B')
2457:switcherator.c ****                 thisPort = &PORTB;
2458:switcherator.c **** #ifdef PORTA
2459:switcherator.c ****             else if (port[0] == 'A')
2460:switcherator.c ****                 thisPort = &PORTA;
2461:switcherator.c **** #endif
2462:switcherator.c **** #ifdef PORTC
2463:switcherator.c ****             else if (port[0] == 'C')
2464:switcherator.c ****                 thisPort = &PORTC;
2465:switcherator.c **** #endif
2466:switcherator.c **** #ifdef PORTD
2467:switcherator.c ****             else if (port[0] == 'D')
2468:switcherator.c ****                 thisPort = &PORTD;
2469:switcherator.c **** #endif
2470:switcherator.c **** #ifdef PORTE
2471:switcherator.c ****             else if (port[0] == 'E')
2472:switcherator.c ****                 thisPort = &PORTE;
2473:switcherator.c **** #endif
2474:switcherator.c **** #ifdef PORTF
2475:switcherator.c ****             else if (port[0] == 'F')
2476:switcherator.c ****                 thisPort = &PORTF;
2477:switcherator.c **** #endif
2478:switcherator.c **** #ifdef PORTG
2479:switcherator.c ****             else if (port[0] == 'G')
2480:switcherator.c ****                 thisPort = &PORTG;
2481:switcherator.c **** #endif
2482:switcherator.c **** #ifdef PORTH
2483:switcherator.c ****             else if (port[0] == 'H')
2484:switcherator.c ****                 thisPort = &PORTH;
2485:switcherator.c **** #endif
2486:switcherator.c **** #ifdef PORTI
2487:switcherator.c ****             else if (port[0] == 'I')
2488:switcherator.c ****                 thisPort = &PORTI;
2489:switcherator.c **** #endif
2490:switcherator.c ****             // k we have the port - now decide if we are turning it on or off and turn it on/off
2491:switcherator.c ****             if (switchStatus[x] == 0) {
2492:switcherator.c ****                 // turning it off
2493:switcherator.c ****                 if (direction[0] == 0) {
2494:switcherator.c ****                     *thisPort |= (1 << realPin);
2495:switcherator.c ****                 } else {
2496:switcherator.c ****                     *thisPort &= ~(1 << realPin);
2497:switcherator.c ****                 }
2498:switcherator.c ****             } else {
2499:switcherator.c ****                 // turning it on
2500:switcherator.c ****                 if (direction[0] == 0) {
2501:switcherator.c ****                     *thisPort &= ~(1 << realPin);
2502:switcherator.c ****                 } else {
2503:switcherator.c ****                     *thisPort |= (1 << realPin);
 2104               		.loc 1 2503 0
 2105 0b7c AA24      		clr r10
 2106 0b7e A394      		inc r10
 2107 0b80 B12C      		mov r11,__zero_reg__
2447:switcherator.c ****                         runHue = 1;
 2108               		.loc 1 2447 0
 2109 0b82 7724      		clr r7
 2110 0b84 7394      		inc r7
 2111               	.LVL124:
 2112               	.L176:
2403:switcherator.c ****         if (switchStuff[x] != 255) {
 2113               		.loc 1 2403 0
 2114 0b86 F401      		movw r30,r8
 2115 0b88 2191      		ld r18,Z+
 2116 0b8a 4F01      		movw r8,r30
 2117 0b8c 2F3F      		cpi r18,lo8(-1)
 2118 0b8e 01F4      		brne .+2
 2119 0b90 00C0      		rjmp .L163
2405:switcherator.c ****             if (switchStuff[x] >= 200 && switchStuff[x] <= 220) {
 2120               		.loc 1 2405 0
 2121 0b92 822F      		mov r24,r18
 2122 0b94 885C      		subi r24,lo8(-(56))
 2123 0b96 8531      		cpi r24,lo8(21)
 2124 0b98 00F0      		brlo .+2
 2125 0b9a 00C0      		rjmp .L164
2407:switcherator.c ****                 if (switchStatus[x] == 0) {
 2126               		.loc 1 2407 0
 2127 0b9c F601      		movw r30,r12
 2128 0b9e 8081      		ld r24,Z
 2129 0ba0 9181      		ldd r25,Z+1
 2130 0ba2 A281      		ldd r26,Z+2
 2131 0ba4 B381      		ldd r27,Z+3
 2132 0ba6 892B      		or r24,r25
 2133 0ba8 8A2B      		or r24,r26
 2134 0baa 8B2B      		or r24,r27
 2135 0bac 01F4      		brne .L165
2409:switcherator.c ****                     if (switchStuff[x] == 200) {
 2136               		.loc 1 2409 0
 2137 0bae 283C      		cpi r18,lo8(-56)
 2138 0bb0 01F4      		brne .L166
2410:switcherator.c ****                         Red = 0;
 2139               		.loc 1 2410 0
 2140 0bb2 1092 B400 		sts 180,__zero_reg__
2411:switcherator.c ****                         Green = 0;
 2141               		.loc 1 2411 0
 2142 0bb6 18BC      		out 0x28,__zero_reg__
2412:switcherator.c ****                         Blue = 0;
 2143               		.loc 1 2412 0
 2144 0bb8 17BC      		out 0x27,__zero_reg__
 2145 0bba 00C0      		rjmp .L163
 2146               	.L166:
2413:switcherator.c ****                     } else if (switchStuff[x] == 201) {
 2147               		.loc 1 2413 0
 2148 0bbc 293C      		cpi r18,lo8(-55)
 2149 0bbe 01F4      		brne .L167
2414:switcherator.c ****                         Red = 0;
 2150               		.loc 1 2414 0
 2151 0bc0 1092 B400 		sts 180,__zero_reg__
2415:switcherator.c ****                         Green = 0;
 2152               		.loc 1 2415 0
 2153 0bc4 18BC      		out 0x28,__zero_reg__
2416:switcherator.c ****                         Blue = 0;
 2154               		.loc 1 2416 0
 2155 0bc6 17BC      		out 0x27,__zero_reg__
2417:switcherator.c ****                         runHue = 0;
 2156               		.loc 1 2417 0
 2157 0bc8 1092 0000 		sts runHue,__zero_reg__
 2158 0bcc 00C0      		rjmp .L163
 2159               	.L167:
2418:switcherator.c ****                     } else if (switchStuff[x] == 202) {
 2160               		.loc 1 2418 0
 2161 0bce 2A3C      		cpi r18,lo8(-54)
 2162 0bd0 01F4      		brne .L168
2419:switcherator.c ****                         Red = 0;
 2163               		.loc 1 2419 0
 2164 0bd2 1092 B400 		sts 180,__zero_reg__
2420:switcherator.c ****                         Green = 0;
 2165               		.loc 1 2420 0
 2166 0bd6 18BC      		out 0x28,__zero_reg__
2421:switcherator.c ****                         Blue = 0;
 2167               		.loc 1 2421 0
 2168 0bd8 17BC      		out 0x27,__zero_reg__
2422:switcherator.c ****                         runColorChanges = 0;
 2169               		.loc 1 2422 0
 2170 0bda 1092 0000 		sts runColorChanges,__zero_reg__
 2171 0bde 00C0      		rjmp .L163
 2172               	.L168:
2423:switcherator.c ****                     } else if (switchStuff[x] == 212) {
 2173               		.loc 1 2423 0
 2174 0be0 243D      		cpi r18,lo8(-44)
 2175 0be2 01F0      		breq .+2
 2176 0be4 00C0      		rjmp .L163
2424:switcherator.c ****                         bright = oldBright;
 2177               		.loc 1 2424 0
 2178 0be6 8091 0000 		lds r24,oldBright
 2179 0bea 00C0      		rjmp .L184
 2180               	.L165:
2429:switcherator.c ****                     if (switchStuff[x] == 200) {
 2181               		.loc 1 2429 0
 2182 0bec 283C      		cpi r18,lo8(-56)
 2183 0bee 01F4      		brne .L169
2432:switcherator.c ****                         green = pwmValues[1];
 2184               		.loc 1 2432 0
 2185 0bf0 8091 0000 		lds r24,pwmValues+1
2433:switcherator.c ****                         blue = pwmValues[2];
 2186               		.loc 1 2433 0
 2187 0bf4 E091 0000 		lds r30,pwmValues+2
2434:switcherator.c ****                         red = red * bright / 16;
 2188               		.loc 1 2434 0
 2189 0bf8 6091 0000 		lds r22,bright
 2190 0bfc 7091 0000 		lds r23,bright+1
2431:switcherator.c ****                         red = pwmValues[0];
 2191               		.loc 1 2431 0
 2192 0c00 9091 0000 		lds r25,pwmValues
2434:switcherator.c ****                         red = red * bright / 16;
 2193               		.loc 1 2434 0
 2194 0c04 969F      		mul r25,r22
 2195 0c06 A001      		movw r20,r0
 2196 0c08 979F      		mul r25,r23
 2197 0c0a 500D      		add r21,r0
 2198 0c0c 1124      		clr __zero_reg__
 2199 0c0e F4E0      		ldi r31,4
 2200               		1:
 2201 0c10 5695      		lsr r21
 2202 0c12 4795      		ror r20
 2203 0c14 FA95      		dec r31
 2204 0c16 01F4      		brne 1b
 2205 0c18 5093 0000 		sts red+1,r21
 2206 0c1c 4093 0000 		sts red,r20
2435:switcherator.c ****                         green = green * bright / 16;
 2207               		.loc 1 2435 0
 2208 0c20 869F      		mul r24,r22
 2209 0c22 9001      		movw r18,r0
 2210 0c24 879F      		mul r24,r23
 2211 0c26 300D      		add r19,r0
 2212 0c28 1124      		clr __zero_reg__
 2213 0c2a A4E0      		ldi r26,4
 2214               		1:
 2215 0c2c 3695      		lsr r19
 2216 0c2e 2795      		ror r18
 2217 0c30 AA95      		dec r26
 2218 0c32 01F4      		brne 1b
 2219 0c34 3093 0000 		sts green+1,r19
 2220 0c38 2093 0000 		sts green,r18
2436:switcherator.c ****                         blue = blue * bright / 16;
 2221               		.loc 1 2436 0
 2222 0c3c E69F      		mul r30,r22
 2223 0c3e C001      		movw r24,r0
 2224 0c40 E79F      		mul r30,r23
 2225 0c42 900D      		add r25,r0
 2226 0c44 1124      		clr __zero_reg__
 2227 0c46 B4E0      		ldi r27,4
 2228               		1:
 2229 0c48 9695      		lsr r25
 2230 0c4a 8795      		ror r24
 2231 0c4c BA95      		dec r27
 2232 0c4e 01F4      		brne 1b
 2233 0c50 9093 0000 		sts blue+1,r25
 2234 0c54 8093 0000 		sts blue,r24
2437:switcherator.c ****                         Red = red;
 2235               		.loc 1 2437 0
 2236 0c58 4093 B400 		sts 180,r20
2438:switcherator.c ****                         Green = green;
 2237               		.loc 1 2438 0
 2238 0c5c 28BD      		out 0x28,r18
2439:switcherator.c ****                         Blue = blue;
 2239               		.loc 1 2439 0
 2240 0c5e 87BD      		out 0x27,r24
 2241 0c60 00C0      		rjmp .L163
 2242               	.L169:
2440:switcherator.c ****                     } else if (switchStuff[x] == 202) {
 2243               		.loc 1 2440 0
 2244 0c62 2A3C      		cpi r18,lo8(-54)
 2245 0c64 01F4      		brne .L170
2441:switcherator.c ****                         runColorChanges = 1;
 2246               		.loc 1 2441 0
 2247 0c66 7092 0000 		sts runColorChanges,r7
 2248 0c6a 00C0      		rjmp .L163
 2249               	.L170:
2442:switcherator.c ****                     } else if (switchStuff[x] == 212) {
 2250               		.loc 1 2442 0
 2251 0c6c 243D      		cpi r18,lo8(-44)
 2252 0c6e 01F4      		brne .L171
2394:switcherator.c **** void switchOnOff(void) {
 2253               		.loc 1 2394 0
 2254 0c70 F701      		movw r30,r14
 2255 0c72 E050      		subi r30,lo8(-(switchBright))
 2256 0c74 F040      		sbci r31,hi8(-(switchBright))
2444:switcherator.c ****                         bright = switchBright[x];
 2257               		.loc 1 2444 0
 2258 0c76 8081      		ld r24,Z
 2259               	.L184:
 2260 0c78 8093 0000 		sts bright,r24
 2261 0c7c 1092 0000 		sts bright+1,__zero_reg__
 2262 0c80 00C0      		rjmp .L163
 2263               	.L171:
2447:switcherator.c ****                         runHue = 1;
 2264               		.loc 1 2447 0
 2265 0c82 7092 0000 		sts runHue,r7
 2266 0c86 00C0      		rjmp .L163
 2267               	.L164:
2453:switcherator.c ****             getPort(x, port, pin, direction);
 2268               		.loc 1 2453 0
 2269 0c88 9E01      		movw r18,r28
 2270 0c8a 2F5F      		subi r18,-1
 2271 0c8c 3F4F      		sbci r19,-1
 2272 0c8e AE01      		movw r20,r28
 2273 0c90 4E5F      		subi r20,-2
 2274 0c92 5F4F      		sbci r21,-1
 2275 0c94 BE01      		movw r22,r28
 2276 0c96 6D5F      		subi r22,-3
 2277 0c98 7F4F      		sbci r23,-1
 2278 0c9a C701      		movw r24,r14
 2279 0c9c 0E94 0000 		call getPort
 2280               	.LVL125:
2455:switcherator.c ****             realPin = pin[0];
 2281               		.loc 1 2455 0
 2282 0ca0 2A81      		ldd r18,Y+2
2456:switcherator.c ****             if (port[0] == 'B')
 2283               		.loc 1 2456 0
 2284 0ca2 8B81      		ldd r24,Y+3
 2285 0ca4 8234      		cpi r24,lo8(66)
 2286 0ca6 01F0      		breq .L177
2463:switcherator.c ****             else if (port[0] == 'C')
 2287               		.loc 1 2463 0
 2288 0ca8 8334      		cpi r24,lo8(67)
 2289 0caa 01F0      		breq .L178
2467:switcherator.c ****             else if (port[0] == 'D')
 2290               		.loc 1 2467 0
 2291 0cac 8434      		cpi r24,lo8(68)
 2292 0cae 01F4      		brne .L172
 2293 0cb0 00C0      		rjmp .L179
 2294               	.L177:
2457:switcherator.c ****                 thisPort = &PORTB;
 2295               		.loc 1 2457 0
 2296 0cb2 05E2      		ldi r16,lo8(37)
 2297 0cb4 10E0      		ldi r17,0
 2298 0cb6 00C0      		rjmp .L172
 2299               	.L178:
2464:switcherator.c ****                 thisPort = &PORTC;
 2300               		.loc 1 2464 0
 2301 0cb8 08E2      		ldi r16,lo8(40)
 2302 0cba 10E0      		ldi r17,0
 2303 0cbc 00C0      		rjmp .L172
 2304               	.L179:
2468:switcherator.c ****                 thisPort = &PORTD;
 2305               		.loc 1 2468 0
 2306 0cbe 0BE2      		ldi r16,lo8(43)
 2307 0cc0 10E0      		ldi r17,0
 2308               	.L172:
 2309               	.LVL126:
2491:switcherator.c ****             if (switchStatus[x] == 0) {
 2310               		.loc 1 2491 0
 2311 0cc2 F601      		movw r30,r12
 2312 0cc4 8081      		ld r24,Z
 2313 0cc6 9181      		ldd r25,Z+1
 2314 0cc8 A281      		ldd r26,Z+2
 2315 0cca B381      		ldd r27,Z+3
 2316 0ccc 3981      		ldd r19,Y+1
2494:switcherator.c ****                     *thisPort |= (1 << realPin);
 2317               		.loc 1 2494 0
 2318 0cce F801      		movw r30,r16
2491:switcherator.c ****             if (switchStatus[x] == 0) {
 2319               		.loc 1 2491 0
 2320 0cd0 892B      		or r24,r25
 2321 0cd2 8A2B      		or r24,r26
 2322 0cd4 8B2B      		or r24,r27
 2323 0cd6 01F4      		brne .L173
2493:switcherator.c ****                 if (direction[0] == 0) {
 2324               		.loc 1 2493 0
 2325 0cd8 3111      		cpse r19,__zero_reg__
 2326 0cda 00C0      		rjmp .L186
 2327 0cdc 00C0      		rjmp .L175
 2328               	.L173:
2500:switcherator.c ****                 if (direction[0] == 0) {
 2329               		.loc 1 2500 0
 2330 0cde 3111      		cpse r19,__zero_reg__
 2331 0ce0 00C0      		rjmp .L175
 2332               	.L186:
2501:switcherator.c ****                     *thisPort &= ~(1 << realPin);
 2333               		.loc 1 2501 0
 2334 0ce2 3081      		ld r19,Z
 2335 0ce4 C501      		movw r24,r10
 2336 0ce6 022E      		mov r0,r18
 2337 0ce8 00C0      		rjmp 2f
 2338               		1:
 2339 0cea 880F      		lsl r24
 2340               		2:
 2341 0cec 0A94      		dec r0
 2342 0cee 02F4      		brpl 1b
 2343 0cf0 8095      		com r24
 2344 0cf2 3823      		and r19,r24
 2345 0cf4 00C0      		rjmp .L185
 2346               	.L175:
 2347               		.loc 1 2503 0
 2348 0cf6 3081      		ld r19,Z
 2349 0cf8 C501      		movw r24,r10
 2350 0cfa 022E      		mov r0,r18
 2351 0cfc 00C0      		rjmp 2f
 2352               		1:
 2353 0cfe 880F      		lsl r24
 2354               		2:
 2355 0d00 0A94      		dec r0
 2356 0d02 02F4      		brpl 1b
 2357 0d04 382B      		or r19,r24
 2358               	.L185:
 2359 0d06 3083      		st Z,r19
 2360               	.LVL127:
 2361               	.L163:
2401:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 2362               		.loc 1 2401 0
 2363 0d08 FFEF      		ldi r31,-1
 2364 0d0a EF1A      		sub r14,r31
 2365 0d0c FF0A      		sbc r15,r31
 2366               	.LVL128:
 2367 0d0e 84E0      		ldi r24,4
 2368 0d10 C80E      		add r12,r24
 2369 0d12 D11C      		adc r13,__zero_reg__
 2370 0d14 E0E1      		ldi r30,16
 2371 0d16 EE16      		cp r14,r30
 2372 0d18 F104      		cpc r15,__zero_reg__
 2373 0d1a 01F0      		breq .+2
 2374 0d1c 00C0      		rjmp .L176
 2375               	/* epilogue start */
2504:switcherator.c ****                 }
2505:switcherator.c ****             }
2506:switcherator.c ****         }
2507:switcherator.c ****     }
2508:switcherator.c **** }
 2376               		.loc 1 2508 0
 2377 0d1e 0F90      		pop __tmp_reg__
 2378 0d20 0F90      		pop __tmp_reg__
 2379 0d22 0F90      		pop __tmp_reg__
 2380 0d24 DF91      		pop r29
 2381 0d26 CF91      		pop r28
 2382 0d28 1F91      		pop r17
 2383 0d2a 0F91      		pop r16
 2384               	.LVL129:
 2385 0d2c FF90      		pop r15
 2386 0d2e EF90      		pop r14
 2387               	.LVL130:
 2388 0d30 DF90      		pop r13
 2389 0d32 CF90      		pop r12
 2390 0d34 BF90      		pop r11
 2391 0d36 AF90      		pop r10
 2392 0d38 9F90      		pop r9
 2393 0d3a 8F90      		pop r8
 2394 0d3c 7F90      		pop r7
 2395 0d3e 0895      		ret
 2396               	.LFE58:
 2398               		.section	.rodata.str1.1,"aMS",@progbits,1
 2399               	.LC1:
 2400 0000 3000      		.string	"0"
 2401               		.text
 2402               	.global	returnInt
 2404               	returnInt:
 2405               	.LFB67:
2509:switcherator.c **** 
2510:switcherator.c **** // sets the time limits for switches to affect progams
2511:switcherator.c **** // TL:##HHMMHHMMddddddd
2512:switcherator.c **** // 01234567890123456789
2513:switcherator.c **** 
2514:switcherator.c **** void setTimeLimits(char * commandReceived) {
2515:switcherator.c ****     char tempReallyLongString[] = "0000000";
2516:switcherator.c ****     int programNumber = 0;
2517:switcherator.c ****     long weekLong = 0;
2518:switcherator.c ****     long startTime = 0;
2519:switcherator.c ****     long stopTime = 0;
2520:switcherator.c ****     int x = 0;
2521:switcherator.c ****     statusMsg[0] = 0;
2522:switcherator.c ****     unsigned int startHour, startMinute, stopHour, stopMinute;
2523:switcherator.c ****     tempIntString[0] = commandReceived[3];
2524:switcherator.c ****     tempIntString[1] = commandReceived[4];
2525:switcherator.c ****     programNumber = atoi(tempIntString);
2526:switcherator.c ****     if (programNumber > NUM_LIMITS) {
2527:switcherator.c ****         fail(0x10);
2528:switcherator.c ****         return;
2529:switcherator.c ****     }
2530:switcherator.c ****     if (commandReceived[5] == 'x' || commandReceived[5] == 'x') {
2531:switcherator.c ****         timeLimits[programNumber][2] = 0;
2532:switcherator.c ****         ok();
2533:switcherator.c ****         return;
2534:switcherator.c ****     }
2535:switcherator.c ****     if (commandReceived[5] == '?') {
2536:switcherator.c ****         // show the limit.
2537:switcherator.c ****         startTime = timeLimits[programNumber][0];
2538:switcherator.c ****         stopTime = timeLimits[programNumber][1];
2539:switcherator.c ****         strcat(statusMsg, "Start:");
2540:switcherator.c ****         startHour = (startTime / 60 / 60);
2541:switcherator.c ****         returnInt(startHour, tempLongString);
2542:switcherator.c ****         strcat(statusMsg, tempLongString);
2543:switcherator.c ****         startMinute = ((startTime - (startHour * 60 * 60)) / 60);
2544:switcherator.c ****         strcat(statusMsg, ":");
2545:switcherator.c ****         returnInt(startMinute, tempLongString);
2546:switcherator.c ****         strcat(statusMsg, tempLongString);
2547:switcherator.c ****         strcat(statusMsg, "Stop:");
2548:switcherator.c ****         stopHour = (startTime / 60 / 60);
2549:switcherator.c ****         returnInt(stopHour, tempLongString);
2550:switcherator.c ****         strcat(statusMsg, tempLongString);
2551:switcherator.c ****         stopMinute = ((startTime - (stopHour * 60 * 60)) / 60);
2552:switcherator.c ****         strcat(statusMsg, ":");
2553:switcherator.c ****         returnInt(stopMinute, tempLongString);
2554:switcherator.c ****         strcat(statusMsg, tempLongString);
2555:switcherator.c ****         sendMessage(statusMsg);
2556:switcherator.c ****         return;
2557:switcherator.c ****     }
2558:switcherator.c ****     for (x = 0; x < 7; x++) {
2559:switcherator.c ****         tempReallyLongString[x] = commandReceived[x + 13];
2560:switcherator.c ****     }
2561:switcherator.c ****     weekLong = strtol(tempReallyLongString, 0, 2);
2562:switcherator.c ****     tempIntString[0] = commandReceived[5];
2563:switcherator.c ****     tempIntString[1] = commandReceived[6];
2564:switcherator.c ****     startHour = atoi(tempIntString);
2565:switcherator.c ****     tempIntString[0] = commandReceived[7];
2566:switcherator.c ****     tempIntString[1] = commandReceived[8];
2567:switcherator.c ****     startMinute = atoi(tempIntString);
2568:switcherator.c ****     tempIntString[0] = commandReceived[9];
2569:switcherator.c ****     tempIntString[1] = commandReceived[10];
2570:switcherator.c ****     stopHour = atoi(tempIntString);
2571:switcherator.c ****     tempIntString[0] = commandReceived[11];
2572:switcherator.c ****     tempIntString[1] = commandReceived[12];
2573:switcherator.c ****     stopMinute = atoi(tempIntString);
2574:switcherator.c ****     if (startHour > 23 || stopHour > 23) {
2575:switcherator.c ****         fail(0x09);
2576:switcherator.c ****         return;
2577:switcherator.c ****     }
2578:switcherator.c ****     if (startMinute > 59 || stopMinute > 59) {
2579:switcherator.c ****         fail(0x0A);
2580:switcherator.c ****         return;
2581:switcherator.c ****     }
2582:switcherator.c ****     startTime = startHour;
2583:switcherator.c ****     startTime = startTime * 60 * 60;
2584:switcherator.c ****     startTime += (startMinute * 60);
2585:switcherator.c ****     stopTime = stopHour;
2586:switcherator.c ****     stopTime = stopTime * 60 * 60;
2587:switcherator.c ****     stopTime += (stopMinute * 60);
2588:switcherator.c ****     timeLimits[programNumber][0] = startTime;
2589:switcherator.c ****     timeLimits[programNumber][1] = stopTime;
2590:switcherator.c ****     timeLimits[programNumber][2] = weekLong;
2591:switcherator.c ****     ok();
2592:switcherator.c **** 
2593:switcherator.c **** }
2594:switcherator.c **** 
2595:switcherator.c **** // take in 3 digits to tweak the clock time
2596:switcherator.c **** // CT xxxx
2597:switcherator.c **** 
2598:switcherator.c **** void clockTweak(char * commandReceived) {
2599:switcherator.c ****     int x = 0;
2600:switcherator.c ****     for (x = 0; x < 4; x++) {
2601:switcherator.c ****         tempLongString[x] = commandReceived[(x + 3)];
2602:switcherator.c ****     }
2603:switcherator.c ****     int adjustment = atoi(tempLongString);
2604:switcherator.c ****     if (adjustment == 0) {
2605:switcherator.c ****         itoa(tweakTimer, tempLongString, 10);
2606:switcherator.c ****         statusMsg[0] = 0;
2607:switcherator.c ****         strcat(statusMsg, "Curr Tweak:");
2608:switcherator.c ****         strcat(statusMsg, tempLongString);
2609:switcherator.c ****         sendMessage(statusMsg);
2610:switcherator.c ****         return;
2611:switcherator.c ****     }
2612:switcherator.c ****     tweakTimer += adjustment;
2613:switcherator.c ****     ok();
2614:switcherator.c **** }
2615:switcherator.c **** 
2616:switcherator.c **** /****************************************************************
2617:switcherator.c ****  *
2618:switcherator.c ****  *              All Things debug and output Related
2619:switcherator.c ****  *
2620:switcherator.c ****  ****************************************************************/
2621:switcherator.c **** 
2622:switcherator.c **** 
2623:switcherator.c **** 
2624:switcherator.c **** 
2625:switcherator.c **** 
2626:switcherator.c **** 
2627:switcherator.c **** // sends a general status
2628:switcherator.c **** // basically an overview of the system
2629:switcherator.c **** 
2630:switcherator.c **** void generalStatus(char * commandReceived) {
2631:switcherator.c ****     statusMsg[0] = 0;
2632:switcherator.c ****     tempIntString[0] = commandReceived[2];
2633:switcherator.c ****     tempIntString[1] = commandReceived[3];
2634:switcherator.c **** 
2635:switcherator.c **** 
2636:switcherator.c ****     if (panicMyClockIsNotSet == 1) {
2637:switcherator.c ****         strcat(statusMsg, " T:xx/xx/xxxx xx:xx:xx");
2638:switcherator.c ****     } else {
2639:switcherator.c ****         strcat(statusMsg, " T:");
2640:switcherator.c ****         returnInt(globalMonth, tempLongString);
2641:switcherator.c ****         strcat(statusMsg, tempLongString);
2642:switcherator.c ****         strcat(statusMsg, "/");
2643:switcherator.c ****         returnInt(globalDay, tempLongString);
2644:switcherator.c ****         strcat(statusMsg, tempLongString);
2645:switcherator.c ****         strcat(statusMsg, "/");
2646:switcherator.c ****         returnInt(globalYear, tempLongString);
2647:switcherator.c ****         strcat(statusMsg, tempLongString);
2648:switcherator.c ****         strcat(statusMsg, " ");
2649:switcherator.c ****         returnInt(globalHour, tempLongString);
2650:switcherator.c ****         strcat(statusMsg, tempLongString);
2651:switcherator.c ****         strcat(statusMsg, ":");
2652:switcherator.c ****         returnInt(globalMinute, tempLongString);
2653:switcherator.c ****         strcat(statusMsg, tempLongString);
2654:switcherator.c ****         strcat(statusMsg, ":");
2655:switcherator.c ****         returnInt(globalSecond, tempLongString);
2656:switcherator.c ****         strcat(statusMsg, tempLongString);
2657:switcherator.c ****     }
2658:switcherator.c ****     sendMessage(statusMsg);
2659:switcherator.c ****     statusMsg[0] = 0;
2660:switcherator.c ****     if (commandReceived[2] == 'q')
2661:switcherator.c ****         return;
2662:switcherator.c **** 
2663:switcherator.c ****     programsProgrammed();
2664:switcherator.c ****     switchesProgrammed();
2665:switcherator.c ****     inputsProgrammed();
2666:switcherator.c ****     switchesOn();
2667:switcherator.c **** }
2668:switcherator.c **** 
2669:switcherator.c **** // returns a basic view of the capabilities
2670:switcherator.c **** void generalInformation(void) {
2671:switcherator.c ****     statusMsg[0] = 0;
2672:switcherator.c ****     strcat(statusMsg,"Pr,");
2673:switcherator.c ****     int count = 0;
2674:switcherator.c ****     int x;
2675:switcherator.c ****     for(x=0;x<MAX_PROGRAM;x++) {
2676:switcherator.c ****         if(weeklyProgram[x][0] < 255 || weeklyProgram[x][1] < 255) 
2677:switcherator.c ****             count++;
2678:switcherator.c ****     }
2679:switcherator.c ****     returnInt(count,tempLongString);
2680:switcherator.c ****     strcat(statusMsg,tempLongString);
2681:switcherator.c ****     strcat(statusMsg,"/");
2682:switcherator.c ****     returnInt(MAX_PROGRAM,tempLongString);
2683:switcherator.c ****     strcat(statusMsg,tempLongString);
2684:switcherator.c ****     strcat(statusMsg,",Sw,");
2685:switcherator.c ****     count = 0;
2686:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
2687:switcherator.c ****         if (switchStuff[x] < 255)
2688:switcherator.c ****             count ++;
2689:switcherator.c ****     }
2690:switcherator.c ****     returnInt(count,tempLongString);
2691:switcherator.c ****     strcat(statusMsg,tempLongString);
2692:switcherator.c ****     strcat(statusMsg,"/");
2693:switcherator.c ****     returnInt(NUM_SWITCHES,tempLongString);
2694:switcherator.c ****     strcat(statusMsg,tempLongString);
2695:switcherator.c ****     sendMessage(statusMsg);
2696:switcherator.c ****     statusMsg[0] = 0;
2697:switcherator.c ****     strcat(statusMsg,",In,");
2698:switcherator.c ****     count = 0;
2699:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
2700:switcherator.c ****         if (inputs[x][0] < 255)
2701:switcherator.c ****             count ++;
2702:switcherator.c ****     }
2703:switcherator.c ****     returnInt(count,tempLongString);
2704:switcherator.c ****     strcat(statusMsg,tempLongString);
2705:switcherator.c ****     strcat(statusMsg,"/");
2706:switcherator.c ****     returnInt(NUM_INPUTS,tempLongString);
2707:switcherator.c ****     strcat(statusMsg,tempLongString);
2708:switcherator.c ****     strcat(statusMsg,",Li,");
2709:switcherator.c ****     count = 0;
2710:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++) {
2711:switcherator.c ****         if (inputs[x][2] > 0)
2712:switcherator.c ****             count ++;
2713:switcherator.c ****     }
2714:switcherator.c ****     returnInt(count,tempLongString);
2715:switcherator.c ****     strcat(statusMsg,tempLongString);
2716:switcherator.c ****     strcat(statusMsg,"/");
2717:switcherator.c ****     returnInt(NUM_LIMITS,tempLongString);
2718:switcherator.c ****     strcat(statusMsg,tempLongString);
2719:switcherator.c ****     strcat(statusMsg,",CC,");
2720:switcherator.c ****     count = 0;
2721:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
2722:switcherator.c ****         if (colorChanges[x][0] != 0 || colorChanges[x][1] != 1 || colorChanges[x][2] != 0)
2723:switcherator.c ****             count ++;
2724:switcherator.c ****     }
2725:switcherator.c ****     returnInt(count,tempLongString);
2726:switcherator.c ****     strcat(statusMsg,tempLongString);
2727:switcherator.c ****     strcat(statusMsg,"/");
2728:switcherator.c ****     returnInt(NUM_COLOR_CHANGES,tempLongString);
2729:switcherator.c ****     strcat(statusMsg,tempLongString);
2730:switcherator.c ****     sendMessage(statusMsg);
2731:switcherator.c **** }
2732:switcherator.c **** 
2733:switcherator.c **** // transmits Y or N for which programs have been programmed
2734:switcherator.c **** void programsProgrammed(void) {
2735:switcherator.c ****     statusMsg[0] = 0;
2736:switcherator.c ****     strcat(statusMsg, "Progs:");
2737:switcherator.c ****     int x;
2738:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
2739:switcherator.c ****         if (weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) {
2740:switcherator.c ****             strcat(statusMsg, "n");
2741:switcherator.c ****         } else {
2742:switcherator.c ****             strcat(statusMsg, "y");
2743:switcherator.c ****         }
2744:switcherator.c ****         // can only send 32 bytes at a time
2745:switcherator.c ****         if (strlen(statusMsg) > 30) {
2746:switcherator.c ****             sendMessage(statusMsg);
2747:switcherator.c ****             statusMsg[6] = 0;
2748:switcherator.c ****         }
2749:switcherator.c ****     }
2750:switcherator.c ****     sendMessage(statusMsg);    
2751:switcherator.c **** }
2752:switcherator.c **** // transmits Y or N for which switches have been programmed
2753:switcherator.c **** void switchesProgrammed(void) {
2754:switcherator.c ****     statusMsg[0] = 0;
2755:switcherator.c ****     strcat(statusMsg, "Swi:");
2756:switcherator.c ****     int x;
2757:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
2758:switcherator.c **** 
2759:switcherator.c ****         if (switchStuff[x] == 255) {
2760:switcherator.c ****             strcat(statusMsg, "n");
2761:switcherator.c ****         } else {
2762:switcherator.c ****             strcat(statusMsg, "y");
2763:switcherator.c ****         }
2764:switcherator.c ****         // can only send 32 bytes at a time
2765:switcherator.c ****         if (strlen(statusMsg) > 30) {
2766:switcherator.c ****             sendMessage(statusMsg);
2767:switcherator.c ****             statusMsg[4] = 0;
2768:switcherator.c ****         }
2769:switcherator.c ****     }
2770:switcherator.c ****     sendMessage(statusMsg);
2771:switcherator.c **** }
2772:switcherator.c **** 
2773:switcherator.c **** // transmits Y or N for which inputs have been programmed
2774:switcherator.c **** void inputsProgrammed(void) {
2775:switcherator.c ****     statusMsg[0] = 0;
2776:switcherator.c ****     strcat(statusMsg, "Inp:");
2777:switcherator.c ****     int x;
2778:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
2779:switcherator.c ****         if (inputs[x][0] == 255) {
2780:switcherator.c ****             strcat(statusMsg, "n");
2781:switcherator.c ****         } else {
2782:switcherator.c ****             strcat(statusMsg, "y");
2783:switcherator.c ****         }
2784:switcherator.c ****         // can only send 32 bytes at a time
2785:switcherator.c ****         if (strlen(statusMsg) > 30) {
2786:switcherator.c ****             sendMessage(statusMsg);
2787:switcherator.c ****             statusMsg[4] = 0;
2788:switcherator.c ****         }
2789:switcherator.c ****     }
2790:switcherator.c ****     sendMessage(statusMsg);
2791:switcherator.c **** }
2792:switcherator.c **** 
2793:switcherator.c **** // transmits Y or N for which switches are currently turned on
2794:switcherator.c **** void switchesOn(void) {
2795:switcherator.c ****     statusMsg[0] = 0;
2796:switcherator.c ****     strcat(statusMsg, "SwOn:");
2797:switcherator.c ****     int x;
2798:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
2799:switcherator.c ****         if (switchStatus[x] > 0) {
2800:switcherator.c ****             strcat(statusMsg, "y");
2801:switcherator.c ****         } else {
2802:switcherator.c ****             strcat(statusMsg, "n");
2803:switcherator.c ****         }
2804:switcherator.c ****         if (strlen(statusMsg) > 30) {
2805:switcherator.c ****             sendMessage(statusMsg);
2806:switcherator.c ****             statusMsg[5] = 0;
2807:switcherator.c ****         }
2808:switcherator.c ****     }
2809:switcherator.c ****     sendMessage(statusMsg);
2810:switcherator.c **** }
2811:switcherator.c **** 
2812:switcherator.c **** void returnInt(int number, char * thisString) {
 2406               		.loc 1 2812 0
 2407               	.LVL131:
 2408 0d40 CF93      		push r28
 2409               	.LCFI66:
 2410 0d42 DF93      		push r29
 2411               	.LCFI67:
 2412               	/* prologue: function */
 2413               	/* frame size = 0 */
 2414               	/* stack size = 2 */
 2415               	.L__stack_usage = 2
 2416 0d44 EB01      		movw r28,r22
2813:switcherator.c ****     thisString[0] = 0;
 2417               		.loc 1 2813 0
 2418 0d46 1882      		st Y,__zero_reg__
2814:switcherator.c ****     itoa(number, tempHugeString, 10);
 2419               		.loc 1 2814 0
 2420 0d48 4AE0      		ldi r20,lo8(10)
 2421 0d4a 50E0      		ldi r21,0
 2422 0d4c 60E0      		ldi r22,lo8(tempHugeString)
 2423 0d4e 70E0      		ldi r23,hi8(tempHugeString)
 2424               	.LVL132:
 2425 0d50 0E94 0000 		call itoa
 2426               	.LVL133:
2815:switcherator.c ****     if (strlen(tempHugeString) == 1)
 2427               		.loc 1 2815 0
 2428 0d54 E0E0      		ldi r30,lo8(tempHugeString)
 2429 0d56 F0E0      		ldi r31,hi8(tempHugeString)
 2430               		0:
 2431 0d58 0190      		ld __tmp_reg__,Z+
 2432 0d5a 0020      		tst __tmp_reg__
 2433 0d5c 01F4      		brne 0b
 2434 0d5e E050      		subi r30,lo8(tempHugeString+2)
 2435 0d60 F040      		sbci r31,hi8(tempHugeString+2)
 2436 0d62 01F4      		brne .L188
2816:switcherator.c ****         strcat(thisString, "0");
 2437               		.loc 1 2816 0
 2438 0d64 60E0      		ldi r22,lo8(.LC1)
 2439 0d66 70E0      		ldi r23,hi8(.LC1)
 2440 0d68 CE01      		movw r24,r28
 2441 0d6a 0E94 0000 		call strcat
 2442               	.LVL134:
 2443               	.L188:
2817:switcherator.c ****     strcat(thisString, tempHugeString);
 2444               		.loc 1 2817 0
 2445 0d6e 60E0      		ldi r22,lo8(tempHugeString)
 2446 0d70 70E0      		ldi r23,hi8(tempHugeString)
 2447 0d72 CE01      		movw r24,r28
 2448               	/* epilogue start */
2818:switcherator.c **** }
 2449               		.loc 1 2818 0
 2450 0d74 DF91      		pop r29
 2451 0d76 CF91      		pop r28
 2452               	.LVL135:
2817:switcherator.c ****     strcat(thisString, tempHugeString);
 2453               		.loc 1 2817 0
 2454 0d78 0C94 0000 		jmp strcat
 2455               	.LVL136:
 2456               	.LFE67:
 2458               		.section	.rodata.str1.1
 2459               	.LC2:
 2460 0002 2000      		.string	" "
 2461               	.LC3:
 2462 0004 2F00      		.string	"/"
 2463               	.LC4:
 2464 0006 3A00      		.string	":"
 2465               		.text
 2466               	.global	clockString
 2468               	clockString:
 2469               	.LFB49:
2160:switcherator.c **** void clockString(void) {
 2470               		.loc 1 2160 0
 2471               	/* prologue: function */
 2472               	/* frame size = 0 */
 2473               	/* stack size = 0 */
 2474               	.L__stack_usage = 0
2161:switcherator.c ****     statusMsg[0] = 0;
 2475               		.loc 1 2161 0
 2476 0d7c 1092 0000 		sts statusMsg,__zero_reg__
2163:switcherator.c ****     strcat(statusMsg, " ");
 2477               		.loc 1 2163 0
 2478 0d80 60E0      		ldi r22,lo8(.LC2)
 2479 0d82 70E0      		ldi r23,hi8(.LC2)
 2480 0d84 80E0      		ldi r24,lo8(statusMsg)
 2481 0d86 90E0      		ldi r25,hi8(statusMsg)
 2482 0d88 0E94 0000 		call strcat
 2483               	.LVL137:
2164:switcherator.c ****     returnInt(globalMonth, tempIntString);
 2484               		.loc 1 2164 0
 2485 0d8c 60E0      		ldi r22,lo8(tempIntString)
 2486 0d8e 70E0      		ldi r23,hi8(tempIntString)
 2487 0d90 8091 0000 		lds r24,globalMonth
 2488 0d94 9091 0000 		lds r25,globalMonth+1
 2489 0d98 0E94 0000 		call returnInt
 2490               	.LVL138:
2165:switcherator.c ****     strcat(statusMsg, tempIntString);
 2491               		.loc 1 2165 0
 2492 0d9c 60E0      		ldi r22,lo8(tempIntString)
 2493 0d9e 70E0      		ldi r23,hi8(tempIntString)
 2494 0da0 80E0      		ldi r24,lo8(statusMsg)
 2495 0da2 90E0      		ldi r25,hi8(statusMsg)
 2496 0da4 0E94 0000 		call strcat
 2497               	.LVL139:
2166:switcherator.c ****     strcat(statusMsg, "/");
 2498               		.loc 1 2166 0
 2499 0da8 60E0      		ldi r22,lo8(.LC3)
 2500 0daa 70E0      		ldi r23,hi8(.LC3)
 2501 0dac 80E0      		ldi r24,lo8(statusMsg)
 2502 0dae 90E0      		ldi r25,hi8(statusMsg)
 2503 0db0 0E94 0000 		call strcat
 2504               	.LVL140:
2167:switcherator.c ****     returnInt(globalDay, tempIntString);
 2505               		.loc 1 2167 0
 2506 0db4 60E0      		ldi r22,lo8(tempIntString)
 2507 0db6 70E0      		ldi r23,hi8(tempIntString)
 2508 0db8 8091 0000 		lds r24,globalDay
 2509 0dbc 9091 0000 		lds r25,globalDay+1
 2510 0dc0 0E94 0000 		call returnInt
 2511               	.LVL141:
2168:switcherator.c ****     strcat(statusMsg, tempIntString);
 2512               		.loc 1 2168 0
 2513 0dc4 60E0      		ldi r22,lo8(tempIntString)
 2514 0dc6 70E0      		ldi r23,hi8(tempIntString)
 2515 0dc8 80E0      		ldi r24,lo8(statusMsg)
 2516 0dca 90E0      		ldi r25,hi8(statusMsg)
 2517 0dcc 0E94 0000 		call strcat
 2518               	.LVL142:
2169:switcherator.c ****     strcat(statusMsg, "/");
 2519               		.loc 1 2169 0
 2520 0dd0 60E0      		ldi r22,lo8(.LC3)
 2521 0dd2 70E0      		ldi r23,hi8(.LC3)
 2522 0dd4 80E0      		ldi r24,lo8(statusMsg)
 2523 0dd6 90E0      		ldi r25,hi8(statusMsg)
 2524 0dd8 0E94 0000 		call strcat
 2525               	.LVL143:
2170:switcherator.c ****     itoa(globalYear, tempIntString, 10);
 2526               		.loc 1 2170 0
 2527 0ddc 4AE0      		ldi r20,lo8(10)
 2528 0dde 50E0      		ldi r21,0
 2529 0de0 60E0      		ldi r22,lo8(tempIntString)
 2530 0de2 70E0      		ldi r23,hi8(tempIntString)
 2531 0de4 8091 0000 		lds r24,globalYear
 2532 0de8 9091 0000 		lds r25,globalYear+1
 2533 0dec 0E94 0000 		call itoa
 2534               	.LVL144:
2171:switcherator.c ****     strcat(statusMsg, tempIntString);
 2535               		.loc 1 2171 0
 2536 0df0 60E0      		ldi r22,lo8(tempIntString)
 2537 0df2 70E0      		ldi r23,hi8(tempIntString)
 2538 0df4 80E0      		ldi r24,lo8(statusMsg)
 2539 0df6 90E0      		ldi r25,hi8(statusMsg)
 2540 0df8 0E94 0000 		call strcat
 2541               	.LVL145:
2172:switcherator.c ****     strcat(statusMsg, " ");
 2542               		.loc 1 2172 0
 2543 0dfc 60E0      		ldi r22,lo8(.LC2)
 2544 0dfe 70E0      		ldi r23,hi8(.LC2)
 2545 0e00 80E0      		ldi r24,lo8(statusMsg)
 2546 0e02 90E0      		ldi r25,hi8(statusMsg)
 2547 0e04 0E94 0000 		call strcat
 2548               	.LVL146:
2173:switcherator.c ****     returnInt(globalHour, tempIntString);
 2549               		.loc 1 2173 0
 2550 0e08 60E0      		ldi r22,lo8(tempIntString)
 2551 0e0a 70E0      		ldi r23,hi8(tempIntString)
 2552 0e0c 8091 0000 		lds r24,globalHour
 2553 0e10 9091 0000 		lds r25,globalHour+1
 2554 0e14 0E94 0000 		call returnInt
 2555               	.LVL147:
2174:switcherator.c ****     strcat(statusMsg, tempIntString);
 2556               		.loc 1 2174 0
 2557 0e18 60E0      		ldi r22,lo8(tempIntString)
 2558 0e1a 70E0      		ldi r23,hi8(tempIntString)
 2559 0e1c 80E0      		ldi r24,lo8(statusMsg)
 2560 0e1e 90E0      		ldi r25,hi8(statusMsg)
 2561 0e20 0E94 0000 		call strcat
 2562               	.LVL148:
2175:switcherator.c ****     strcat(statusMsg, ":");
 2563               		.loc 1 2175 0
 2564 0e24 60E0      		ldi r22,lo8(.LC4)
 2565 0e26 70E0      		ldi r23,hi8(.LC4)
 2566 0e28 80E0      		ldi r24,lo8(statusMsg)
 2567 0e2a 90E0      		ldi r25,hi8(statusMsg)
 2568 0e2c 0E94 0000 		call strcat
 2569               	.LVL149:
2176:switcherator.c ****     returnInt(globalMinute, tempIntString);
 2570               		.loc 1 2176 0
 2571 0e30 60E0      		ldi r22,lo8(tempIntString)
 2572 0e32 70E0      		ldi r23,hi8(tempIntString)
 2573 0e34 8091 0000 		lds r24,globalMinute
 2574 0e38 9091 0000 		lds r25,globalMinute+1
 2575 0e3c 0E94 0000 		call returnInt
 2576               	.LVL150:
2177:switcherator.c ****     strcat(statusMsg, tempIntString);
 2577               		.loc 1 2177 0
 2578 0e40 60E0      		ldi r22,lo8(tempIntString)
 2579 0e42 70E0      		ldi r23,hi8(tempIntString)
 2580 0e44 80E0      		ldi r24,lo8(statusMsg)
 2581 0e46 90E0      		ldi r25,hi8(statusMsg)
 2582 0e48 0E94 0000 		call strcat
 2583               	.LVL151:
2178:switcherator.c ****     strcat(statusMsg, ":");
 2584               		.loc 1 2178 0
 2585 0e4c 60E0      		ldi r22,lo8(.LC4)
 2586 0e4e 70E0      		ldi r23,hi8(.LC4)
 2587 0e50 80E0      		ldi r24,lo8(statusMsg)
 2588 0e52 90E0      		ldi r25,hi8(statusMsg)
 2589 0e54 0E94 0000 		call strcat
 2590               	.LVL152:
2179:switcherator.c ****     returnInt(globalSecond, tempIntString);
 2591               		.loc 1 2179 0
 2592 0e58 60E0      		ldi r22,lo8(tempIntString)
 2593 0e5a 70E0      		ldi r23,hi8(tempIntString)
 2594 0e5c 8091 0000 		lds r24,globalSecond
 2595 0e60 9091 0000 		lds r25,globalSecond+1
 2596 0e64 0E94 0000 		call returnInt
 2597               	.LVL153:
2180:switcherator.c ****     strcat(statusMsg, tempIntString);
 2598               		.loc 1 2180 0
 2599 0e68 60E0      		ldi r22,lo8(tempIntString)
 2600 0e6a 70E0      		ldi r23,hi8(tempIntString)
 2601 0e6c 80E0      		ldi r24,lo8(statusMsg)
 2602 0e6e 90E0      		ldi r25,hi8(statusMsg)
 2603 0e70 0C94 0000 		jmp strcat
 2604               	.LVL154:
 2605               	.LFE49:
 2607               		.section	.rodata.str1.1
 2608               	.LC5:
 2609 0008 3078 00   		.string	"0x"
 2610               		.text
 2611               	.global	returnHex
 2613               	returnHex:
 2614               	.LFB68:
2819:switcherator.c **** 
2820:switcherator.c **** void returnHex(unsigned int number, char * thisString) {
 2615               		.loc 1 2820 0
 2616               	.LVL155:
 2617 0e74 0F93      		push r16
 2618               	.LCFI68:
 2619 0e76 1F93      		push r17
 2620               	.LCFI69:
 2621 0e78 CF93      		push r28
 2622               	.LCFI70:
 2623 0e7a DF93      		push r29
 2624               	.LCFI71:
 2625               	/* prologue: function */
 2626               	/* frame size = 0 */
 2627               	/* stack size = 4 */
 2628               	.L__stack_usage = 4
 2629 0e7c 8C01      		movw r16,r24
 2630 0e7e EB01      		movw r28,r22
2821:switcherator.c ****     thisString[0] = 0;
 2631               		.loc 1 2821 0
 2632 0e80 1882      		st Y,__zero_reg__
2822:switcherator.c ****     strcat(thisString, "0x");
 2633               		.loc 1 2822 0
 2634 0e82 60E0      		ldi r22,lo8(.LC5)
 2635 0e84 70E0      		ldi r23,hi8(.LC5)
 2636               	.LVL156:
 2637 0e86 CE01      		movw r24,r28
 2638               	.LVL157:
 2639 0e88 0E94 0000 		call strcat
 2640               	.LVL158:
2823:switcherator.c ****     itoa(number, tempHugeString, 16);
 2641               		.loc 1 2823 0
 2642 0e8c 40E1      		ldi r20,lo8(16)
 2643 0e8e 50E0      		ldi r21,0
 2644 0e90 60E0      		ldi r22,lo8(tempHugeString)
 2645 0e92 70E0      		ldi r23,hi8(tempHugeString)
 2646 0e94 C801      		movw r24,r16
 2647 0e96 0E94 0000 		call itoa
 2648               	.LVL159:
2824:switcherator.c ****     if (strlen(tempHugeString) == 1 || strlen(tempHugeString) == 3)
 2649               		.loc 1 2824 0
 2650 0e9a E0E0      		ldi r30,lo8(tempHugeString)
 2651 0e9c F0E0      		ldi r31,hi8(tempHugeString)
 2652               		0:
 2653 0e9e 0190      		ld __tmp_reg__,Z+
 2654 0ea0 0020      		tst __tmp_reg__
 2655 0ea2 01F4      		brne 0b
 2656 0ea4 3197      		sbiw r30,1
 2657 0ea6 E050      		subi r30,lo8(tempHugeString)
 2658 0ea8 F040      		sbci r31,hi8(tempHugeString)
 2659 0eaa E130      		cpi r30,1
 2660 0eac F105      		cpc r31,__zero_reg__
 2661 0eae 01F0      		breq .L191
 2662               		.loc 1 2824 0 is_stmt 0 discriminator 1
 2663 0eb0 3397      		sbiw r30,3
 2664 0eb2 01F4      		brne .L192
 2665               	.L191:
2825:switcherator.c ****         strcat(thisString, "0");
 2666               		.loc 1 2825 0 is_stmt 1
 2667 0eb4 60E0      		ldi r22,lo8(.LC1)
 2668 0eb6 70E0      		ldi r23,hi8(.LC1)
 2669 0eb8 CE01      		movw r24,r28
 2670 0eba 0E94 0000 		call strcat
 2671               	.LVL160:
 2672               	.L192:
2826:switcherator.c ****     strcat(thisString, tempHugeString);
 2673               		.loc 1 2826 0
 2674 0ebe 60E0      		ldi r22,lo8(tempHugeString)
 2675 0ec0 70E0      		ldi r23,hi8(tempHugeString)
 2676 0ec2 CE01      		movw r24,r28
 2677               	/* epilogue start */
2827:switcherator.c **** }
 2678               		.loc 1 2827 0
 2679 0ec4 DF91      		pop r29
 2680 0ec6 CF91      		pop r28
 2681               	.LVL161:
 2682 0ec8 1F91      		pop r17
 2683 0eca 0F91      		pop r16
 2684               	.LVL162:
2826:switcherator.c ****     strcat(thisString, tempHugeString);
 2685               		.loc 1 2826 0
 2686 0ecc 0C94 0000 		jmp strcat
 2687               	.LVL163:
 2688               	.LFE68:
 2690               	.global	returnHexWithout
 2692               	returnHexWithout:
 2693               	.LFB69:
2828:switcherator.c **** 
2829:switcherator.c **** 
2830:switcherator.c **** 
2831:switcherator.c **** // print hex without 0x
2832:switcherator.c **** 
2833:switcherator.c **** void returnHexWithout(unsigned int number, char * tempMe) {
 2694               		.loc 1 2833 0
 2695               	.LVL164:
 2696 0ed0 CF93      		push r28
 2697               	.LCFI72:
 2698 0ed2 DF93      		push r29
 2699               	.LCFI73:
 2700               	/* prologue: function */
 2701               	/* frame size = 0 */
 2702               	/* stack size = 2 */
 2703               	.L__stack_usage = 2
 2704 0ed4 EB01      		movw r28,r22
2834:switcherator.c ****     tempMe[0] = 0;
 2705               		.loc 1 2834 0
 2706 0ed6 1882      		st Y,__zero_reg__
2835:switcherator.c ****     itoa(number, tempHugeString, 16);
 2707               		.loc 1 2835 0
 2708 0ed8 40E1      		ldi r20,lo8(16)
 2709 0eda 50E0      		ldi r21,0
 2710 0edc 60E0      		ldi r22,lo8(tempHugeString)
 2711 0ede 70E0      		ldi r23,hi8(tempHugeString)
 2712               	.LVL165:
 2713 0ee0 0E94 0000 		call itoa
 2714               	.LVL166:
2836:switcherator.c ****     if (strlen(tempHugeString) == 1 || strlen(tempHugeString) == 3)
 2715               		.loc 1 2836 0
 2716 0ee4 E0E0      		ldi r30,lo8(tempHugeString)
 2717 0ee6 F0E0      		ldi r31,hi8(tempHugeString)
 2718               		0:
 2719 0ee8 0190      		ld __tmp_reg__,Z+
 2720 0eea 0020      		tst __tmp_reg__
 2721 0eec 01F4      		brne 0b
 2722 0eee 3197      		sbiw r30,1
 2723 0ef0 E050      		subi r30,lo8(tempHugeString)
 2724 0ef2 F040      		sbci r31,hi8(tempHugeString)
 2725 0ef4 E130      		cpi r30,1
 2726 0ef6 F105      		cpc r31,__zero_reg__
 2727 0ef8 01F0      		breq .L197
 2728               		.loc 1 2836 0 is_stmt 0 discriminator 1
 2729 0efa 3397      		sbiw r30,3
 2730 0efc 01F4      		brne .L198
 2731               	.L197:
2837:switcherator.c ****         strcat(tempMe, "0");
 2732               		.loc 1 2837 0 is_stmt 1
 2733 0efe 60E0      		ldi r22,lo8(.LC1)
 2734 0f00 70E0      		ldi r23,hi8(.LC1)
 2735 0f02 CE01      		movw r24,r28
 2736 0f04 0E94 0000 		call strcat
 2737               	.LVL167:
 2738               	.L198:
2838:switcherator.c ****     strcat(tempMe, tempHugeString);
 2739               		.loc 1 2838 0
 2740 0f08 60E0      		ldi r22,lo8(tempHugeString)
 2741 0f0a 70E0      		ldi r23,hi8(tempHugeString)
 2742 0f0c CE01      		movw r24,r28
 2743               	/* epilogue start */
2839:switcherator.c **** }
 2744               		.loc 1 2839 0
 2745 0f0e DF91      		pop r29
 2746 0f10 CF91      		pop r28
 2747               	.LVL168:
2838:switcherator.c ****     strcat(tempMe, tempHugeString);
 2748               		.loc 1 2838 0
 2749 0f12 0C94 0000 		jmp strcat
 2750               	.LVL169:
 2751               	.LFE69:
 2753               	.global	formatAddress
 2755               	formatAddress:
 2756               	.LFB72:
2840:switcherator.c **** 
2841:switcherator.c **** // Clock interrupt - fires when the compare is off
2842:switcherator.c **** 
2843:switcherator.c **** /****************************************************************
2844:switcherator.c ****  *
2845:switcherator.c ****  *              All Things Radio Related
2846:switcherator.c ****  *
2847:switcherator.c ****  ****************************************************************/
2848:switcherator.c **** 
2849:switcherator.c **** // initialize the radio
2850:switcherator.c **** 
2851:switcherator.c **** void radioInit(void) {
2852:switcherator.c ****     nrfInit();
2853:switcherator.c ****     rx_addr_p0 = SET_RX_ADDR_P0;
2854:switcherator.c ****     tx_addr = SET_TX_ADDR;
2855:switcherator.c ****     // use defaults the radio has
2856:switcherator.c ****     rx_addr_p1 = readAddr(RX_ADDR_P1);
2857:switcherator.c ****     rx_addr_p2 = readAddr(RX_ADDR_P2);
2858:switcherator.c ****     rx_addr_p3 = readAddr(RX_ADDR_P3);
2859:switcherator.c ****     rx_addr_p4 = readAddr(RX_ADDR_P4);
2860:switcherator.c ****     rx_addr_p5 = readAddr(RX_ADDR_P5);
2861:switcherator.c **** 
2862:switcherator.c ****     writeReg(RF_SETUP, SET_RF_SETUP);
2863:switcherator.c ****     writeAddr(RX_ADDR_P0, rx_addr_p0);
2864:switcherator.c ****     writeAddr(TX_ADDR, tx_addr);
2865:switcherator.c ****     writeReg(DYNPD, SET_DYNPD);
2866:switcherator.c ****     writeReg(FEATURE, SET_FEATURE);
2867:switcherator.c ****     writeReg(RF_CH, SET_RF_CH);
2868:switcherator.c ****     writeReg(CONFIG, SET_CONFIG);
2869:switcherator.c ****     writeReg(SETUP_RETR, SET_SETUP_RETR);
2870:switcherator.c **** 
2871:switcherator.c ****     // We've written the address - now see if we get the same result
2872:switcherator.c ****     radioTest();
2873:switcherator.c **** 
2874:switcherator.c ****     startRadio();
2875:switcherator.c **** 
2876:switcherator.c **** }
2877:switcherator.c **** 
2878:switcherator.c **** // radio test - just make sure it is still working
2879:switcherator.c **** int radioTest(void) {
2880:switcherator.c ****     uint64_t test_addr;
2881:switcherator.c ****     test_addr = readAddr(RX_ADDR_P0);    
2882:switcherator.c ****     if (test_addr != rx_addr_p0) {
2883:switcherator.c ****         // nope.  broken
2884:switcherator.c ****         failCondition = 1;
2885:switcherator.c ****         return -1;
2886:switcherator.c ****     }
2887:switcherator.c ****     if(failCondition == 1 || failCondition == 2)
2888:switcherator.c ****         clearFail();
2889:switcherator.c ****     return 1;
2890:switcherator.c **** }
2891:switcherator.c **** 
2892:switcherator.c **** // Take in an address and return a long long with the number
2893:switcherator.c **** 
2894:switcherator.c **** uint64_t formatAddress(char * address) {
 2757               		.loc 1 2894 0
 2758               	.LVL170:
 2759 0f16 0F93      		push r16
 2760               	.LCFI74:
 2761 0f18 CF93      		push r28
 2762               	.LCFI75:
 2763               	/* prologue: function */
 2764               	/* frame size = 0 */
 2765               	/* stack size = 2 */
 2766               	.L__stack_usage = 2
 2767               	.LVL171:
 2768 0f1a DC01      		movw r26,r24
2895:switcherator.c ****     int x = 0;
2896:switcherator.c ****     uint64_t newAddress = 0;
 2769               		.loc 1 2896 0
 2770 0f1c 20E0      		ldi r18,0
 2771 0f1e 30E0      		ldi r19,0
 2772 0f20 40E0      		ldi r20,0
 2773 0f22 50E0      		ldi r21,0
 2774 0f24 60E0      		ldi r22,0
 2775 0f26 70E0      		ldi r23,0
 2776 0f28 80E0      		ldi r24,0
 2777               	.LVL172:
 2778 0f2a 90E0      		ldi r25,0
2897:switcherator.c ****     int tempInt;
2898:switcherator.c ****     for (x = 0; x < 5; x++) {
 2779               		.loc 1 2898 0
 2780 0f2c E0E0      		ldi r30,0
 2781 0f2e F0E0      		ldi r31,0
 2782               	.LVL173:
 2783               	.L205:
2899:switcherator.c ****         tempInt = address[x];
 2784               		.loc 1 2899 0
 2785 0f30 CD91      		ld r28,X+
 2786               	.LVL174:
 2787 0f32 C22B      		or r28,r18
 2788               	.LVL175:
2900:switcherator.c ****         if (x < 4) {
2901:switcherator.c ****             newAddress |= (tempInt);
2902:switcherator.c ****             newAddress <<= 8;
 2789               		.loc 1 2902 0
 2790 0f34 2C2F      		mov r18,r28
2900:switcherator.c ****         if (x < 4) {
 2791               		.loc 1 2900 0
 2792 0f36 E430      		cpi r30,4
 2793 0f38 F105      		cpc r31,__zero_reg__
 2794 0f3a 01F0      		breq .L204
 2795               		.loc 1 2902 0
 2796 0f3c 08E0      		ldi r16,lo8(8)
 2797 0f3e 0E94 0000 		call __ashldi3
 2798               	.LVL176:
 2799               	.L204:
2898:switcherator.c ****     for (x = 0; x < 5; x++) {
 2800               		.loc 1 2898 0
 2801 0f42 3196      		adiw r30,1
 2802               	.LVL177:
 2803 0f44 E530      		cpi r30,5
 2804 0f46 F105      		cpc r31,__zero_reg__
 2805 0f48 01F4      		brne .L205
 2806               	/* epilogue start */
2903:switcherator.c ****         } else
2904:switcherator.c ****             newAddress |= tempInt;
2905:switcherator.c ****     }
2906:switcherator.c ****     return newAddress;
2907:switcherator.c **** }
 2807               		.loc 1 2907 0
 2808 0f4a CF91      		pop r28
 2809 0f4c 0F91      		pop r16
 2810 0f4e 0895      		ret
 2811               	.LFE72:
 2813               	.global	generalInit
 2815               	generalInit:
 2816               	.LFB41:
1688:switcherator.c **** void generalInit(void) {
 2817               		.loc 1 1688 0
 2818 0f50 EF92      		push r14
 2819               	.LCFI76:
 2820 0f52 FF92      		push r15
 2821               	.LCFI77:
 2822 0f54 0F93      		push r16
 2823               	.LCFI78:
 2824 0f56 1F93      		push r17
 2825               	.LCFI79:
 2826 0f58 CF93      		push r28
 2827               	.LCFI80:
 2828 0f5a DF93      		push r29
 2829               	.LCFI81:
 2830 0f5c CDB7      		in r28,__SP_L__
 2831 0f5e DEB7      		in r29,__SP_H__
 2832               	.LCFI82:
 2833 0f60 2E97      		sbiw r28,14
 2834               	.LCFI83:
 2835 0f62 0FB6      		in __tmp_reg__,__SREG__
 2836 0f64 F894      		cli
 2837 0f66 DEBF      		out __SP_H__,r29
 2838 0f68 0FBE      		out __SREG__,__tmp_reg__
 2839 0f6a CDBF      		out __SP_L__,r28
 2840               	/* prologue: function */
 2841               	/* frame size = 14 */
 2842               	/* stack size = 20 */
 2843               	.L__stack_usage = 20
 2844               	.LVL178:
1694:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_TX, RADIO_ADDR_TX_BYTES) == 1) {
 2845               		.loc 1 1694 0
 2846 0f6c 47E0      		ldi r20,lo8(7)
 2847 0f6e 50E0      		ldi r21,0
 2848 0f70 6EE0      		ldi r22,lo8(14)
 2849 0f72 70E0      		ldi r23,0
 2850 0f74 CE01      		movw r24,r28
 2851 0f76 0196      		adiw r24,1
 2852 0f78 0E94 0000 		call readEEPROM
 2853               	.LVL179:
 2854 0f7c 0197      		sbiw r24,1
 2855 0f7e 01F4      		brne .L208
1695:switcherator.c ****         tx_addr = formatAddress(tempStuff);
 2856               		.loc 1 1695 0
 2857 0f80 CE01      		movw r24,r28
 2858 0f82 0196      		adiw r24,1
 2859 0f84 0E94 0000 		call formatAddress
 2860               	.LVL180:
 2861 0f88 2093 0000 		sts tx_addr,r18
 2862 0f8c 3093 0000 		sts tx_addr+1,r19
 2863 0f90 4093 0000 		sts tx_addr+2,r20
 2864 0f94 5093 0000 		sts tx_addr+3,r21
 2865 0f98 6093 0000 		sts tx_addr+4,r22
 2866 0f9c 7093 0000 		sts tx_addr+5,r23
 2867 0fa0 8093 0000 		sts tx_addr+6,r24
 2868 0fa4 9093 0000 		sts tx_addr+7,r25
1696:switcherator.c ****         writeAddr(TX_ADDR, tx_addr);
 2869               		.loc 1 1696 0
 2870 0fa8 8901      		movw r16,r18
 2871 0faa 9A01      		movw r18,r20
 2872 0fac AB01      		movw r20,r22
 2873 0fae BC01      		movw r22,r24
 2874 0fb0 80E1      		ldi r24,lo8(16)
 2875 0fb2 0E94 0000 		call writeAddr
 2876               	.LVL181:
 2877               	.L208:
1698:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R0, RADIO_ADDR_R0_BYTES) == 1) {
 2878               		.loc 1 1698 0
 2879 0fb6 47E0      		ldi r20,lo8(7)
 2880 0fb8 50E0      		ldi r21,0
 2881 0fba 65E1      		ldi r22,lo8(21)
 2882 0fbc 70E0      		ldi r23,0
 2883 0fbe CE01      		movw r24,r28
 2884 0fc0 0196      		adiw r24,1
 2885 0fc2 0E94 0000 		call readEEPROM
 2886               	.LVL182:
 2887 0fc6 0197      		sbiw r24,1
 2888 0fc8 01F4      		brne .L209
1699:switcherator.c ****         rx_addr_p0 = formatAddress(tempStuff);
 2889               		.loc 1 1699 0
 2890 0fca CE01      		movw r24,r28
 2891 0fcc 0196      		adiw r24,1
 2892 0fce 0E94 0000 		call formatAddress
 2893               	.LVL183:
 2894 0fd2 2093 0000 		sts rx_addr_p0,r18
 2895 0fd6 3093 0000 		sts rx_addr_p0+1,r19
 2896 0fda 4093 0000 		sts rx_addr_p0+2,r20
 2897 0fde 5093 0000 		sts rx_addr_p0+3,r21
 2898 0fe2 6093 0000 		sts rx_addr_p0+4,r22
 2899 0fe6 7093 0000 		sts rx_addr_p0+5,r23
 2900 0fea 8093 0000 		sts rx_addr_p0+6,r24
 2901 0fee 9093 0000 		sts rx_addr_p0+7,r25
1700:switcherator.c ****         writeAddr(RX_ADDR_P0, rx_addr_p0);
 2902               		.loc 1 1700 0
 2903 0ff2 8901      		movw r16,r18
 2904 0ff4 9A01      		movw r18,r20
 2905 0ff6 AB01      		movw r20,r22
 2906 0ff8 BC01      		movw r22,r24
 2907 0ffa 8AE0      		ldi r24,lo8(10)
 2908 0ffc 0E94 0000 		call writeAddr
 2909               	.LVL184:
 2910               	.L209:
1703:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R1, RADIO_ADDR_R1_BYTES) == 1) {
 2911               		.loc 1 1703 0
 2912 1000 47E0      		ldi r20,lo8(7)
 2913 1002 50E0      		ldi r21,0
 2914 1004 6CE1      		ldi r22,lo8(28)
 2915 1006 70E0      		ldi r23,0
 2916 1008 CE01      		movw r24,r28
 2917 100a 0196      		adiw r24,1
 2918 100c 0E94 0000 		call readEEPROM
 2919               	.LVL185:
 2920 1010 0197      		sbiw r24,1
 2921 1012 01F4      		brne .L210
1704:switcherator.c ****         rx_addr_p1 = formatAddress(tempStuff);
 2922               		.loc 1 1704 0
 2923 1014 CE01      		movw r24,r28
 2924 1016 0196      		adiw r24,1
 2925 1018 0E94 0000 		call formatAddress
 2926               	.LVL186:
 2927 101c 2093 0000 		sts rx_addr_p1,r18
 2928 1020 3093 0000 		sts rx_addr_p1+1,r19
 2929 1024 4093 0000 		sts rx_addr_p1+2,r20
 2930 1028 5093 0000 		sts rx_addr_p1+3,r21
 2931 102c 6093 0000 		sts rx_addr_p1+4,r22
 2932 1030 7093 0000 		sts rx_addr_p1+5,r23
 2933 1034 8093 0000 		sts rx_addr_p1+6,r24
 2934 1038 9093 0000 		sts rx_addr_p1+7,r25
1705:switcherator.c ****         writeAddr(RX_ADDR_P1, rx_addr_p1);
 2935               		.loc 1 1705 0
 2936 103c 8901      		movw r16,r18
 2937 103e 9A01      		movw r18,r20
 2938 1040 AB01      		movw r20,r22
 2939 1042 BC01      		movw r22,r24
 2940 1044 8BE0      		ldi r24,lo8(11)
 2941 1046 0E94 0000 		call writeAddr
 2942               	.LVL187:
 2943               	.L210:
1707:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R2, RADIO_ADDR_R2_BYTES) == 1) {
 2944               		.loc 1 1707 0
 2945 104a 43E0      		ldi r20,lo8(3)
 2946 104c 50E0      		ldi r21,0
 2947 104e 63E2      		ldi r22,lo8(35)
 2948 1050 70E0      		ldi r23,0
 2949 1052 CE01      		movw r24,r28
 2950 1054 0196      		adiw r24,1
 2951 1056 0E94 0000 		call readEEPROM
 2952               	.LVL188:
 2953 105a 0197      		sbiw r24,1
 2954 105c 01F4      		brne .L211
1708:switcherator.c ****         rx_addr_p2 = tempStuff[0];
 2955               		.loc 1 1708 0
 2956 105e 0981      		ldd r16,Y+1
 2957 1060 0093 0000 		sts rx_addr_p2,r16
 2958 1064 1092 0000 		sts rx_addr_p2+1,__zero_reg__
 2959 1068 1092 0000 		sts rx_addr_p2+2,__zero_reg__
 2960 106c 1092 0000 		sts rx_addr_p2+3,__zero_reg__
 2961 1070 1092 0000 		sts rx_addr_p2+4,__zero_reg__
 2962 1074 1092 0000 		sts rx_addr_p2+5,__zero_reg__
 2963 1078 1092 0000 		sts rx_addr_p2+6,__zero_reg__
 2964 107c 1092 0000 		sts rx_addr_p2+7,__zero_reg__
1709:switcherator.c ****         writeAddr(RX_ADDR_P2, rx_addr_p2);
 2965               		.loc 1 1709 0
 2966 1080 10E0      		ldi r17,0
 2967 1082 20E0      		ldi r18,0
 2968 1084 30E0      		ldi r19,0
 2969 1086 40E0      		ldi r20,0
 2970 1088 50E0      		ldi r21,0
 2971 108a 60E0      		ldi r22,0
 2972 108c 70E0      		ldi r23,0
 2973 108e 8CE0      		ldi r24,lo8(12)
 2974 1090 0E94 0000 		call writeAddr
 2975               	.LVL189:
 2976               	.L211:
1711:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R3, RADIO_ADDR_R3_BYTES) == 1) {
 2977               		.loc 1 1711 0
 2978 1094 43E0      		ldi r20,lo8(3)
 2979 1096 50E0      		ldi r21,0
 2980 1098 66E2      		ldi r22,lo8(38)
 2981 109a 70E0      		ldi r23,0
 2982 109c CE01      		movw r24,r28
 2983 109e 0196      		adiw r24,1
 2984 10a0 0E94 0000 		call readEEPROM
 2985               	.LVL190:
 2986 10a4 0197      		sbiw r24,1
 2987 10a6 01F4      		brne .L212
1712:switcherator.c ****         rx_addr_p3 = tempStuff[0];
 2988               		.loc 1 1712 0
 2989 10a8 0981      		ldd r16,Y+1
 2990 10aa 0093 0000 		sts rx_addr_p3,r16
 2991 10ae 1092 0000 		sts rx_addr_p3+1,__zero_reg__
 2992 10b2 1092 0000 		sts rx_addr_p3+2,__zero_reg__
 2993 10b6 1092 0000 		sts rx_addr_p3+3,__zero_reg__
 2994 10ba 1092 0000 		sts rx_addr_p3+4,__zero_reg__
 2995 10be 1092 0000 		sts rx_addr_p3+5,__zero_reg__
 2996 10c2 1092 0000 		sts rx_addr_p3+6,__zero_reg__
 2997 10c6 1092 0000 		sts rx_addr_p3+7,__zero_reg__
1713:switcherator.c ****         writeAddr(RX_ADDR_P3, rx_addr_p3);
 2998               		.loc 1 1713 0
 2999 10ca 10E0      		ldi r17,0
 3000 10cc 20E0      		ldi r18,0
 3001 10ce 30E0      		ldi r19,0
 3002 10d0 40E0      		ldi r20,0
 3003 10d2 50E0      		ldi r21,0
 3004 10d4 60E0      		ldi r22,0
 3005 10d6 70E0      		ldi r23,0
 3006 10d8 8DE0      		ldi r24,lo8(13)
 3007 10da 0E94 0000 		call writeAddr
 3008               	.LVL191:
 3009               	.L212:
1715:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R4, RADIO_ADDR_R4_BYTES) == 1) {
 3010               		.loc 1 1715 0
 3011 10de 43E0      		ldi r20,lo8(3)
 3012 10e0 50E0      		ldi r21,0
 3013 10e2 69E2      		ldi r22,lo8(41)
 3014 10e4 70E0      		ldi r23,0
 3015 10e6 CE01      		movw r24,r28
 3016 10e8 0196      		adiw r24,1
 3017 10ea 0E94 0000 		call readEEPROM
 3018               	.LVL192:
 3019 10ee 0197      		sbiw r24,1
 3020 10f0 01F4      		brne .L213
1716:switcherator.c ****         rx_addr_p4 = tempStuff[0];
 3021               		.loc 1 1716 0
 3022 10f2 0981      		ldd r16,Y+1
 3023 10f4 0093 0000 		sts rx_addr_p4,r16
 3024 10f8 1092 0000 		sts rx_addr_p4+1,__zero_reg__
 3025 10fc 1092 0000 		sts rx_addr_p4+2,__zero_reg__
 3026 1100 1092 0000 		sts rx_addr_p4+3,__zero_reg__
 3027 1104 1092 0000 		sts rx_addr_p4+4,__zero_reg__
 3028 1108 1092 0000 		sts rx_addr_p4+5,__zero_reg__
 3029 110c 1092 0000 		sts rx_addr_p4+6,__zero_reg__
 3030 1110 1092 0000 		sts rx_addr_p4+7,__zero_reg__
1717:switcherator.c ****         writeAddr(RX_ADDR_P4, rx_addr_p4);
 3031               		.loc 1 1717 0
 3032 1114 10E0      		ldi r17,0
 3033 1116 20E0      		ldi r18,0
 3034 1118 30E0      		ldi r19,0
 3035 111a 40E0      		ldi r20,0
 3036 111c 50E0      		ldi r21,0
 3037 111e 60E0      		ldi r22,0
 3038 1120 70E0      		ldi r23,0
 3039 1122 8EE0      		ldi r24,lo8(14)
 3040 1124 0E94 0000 		call writeAddr
 3041               	.LVL193:
 3042               	.L213:
1719:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R5, RADIO_ADDR_R5_BYTES) == 1) {
 3043               		.loc 1 1719 0
 3044 1128 43E0      		ldi r20,lo8(3)
 3045 112a 50E0      		ldi r21,0
 3046 112c 6CE2      		ldi r22,lo8(44)
 3047 112e 70E0      		ldi r23,0
 3048 1130 CE01      		movw r24,r28
 3049 1132 0196      		adiw r24,1
 3050 1134 0E94 0000 		call readEEPROM
 3051               	.LVL194:
 3052 1138 0197      		sbiw r24,1
 3053 113a 01F4      		brne .L214
1720:switcherator.c ****         rx_addr_p5 = tempStuff[0];
 3054               		.loc 1 1720 0
 3055 113c 0981      		ldd r16,Y+1
 3056 113e 0093 0000 		sts rx_addr_p5,r16
 3057 1142 1092 0000 		sts rx_addr_p5+1,__zero_reg__
 3058 1146 1092 0000 		sts rx_addr_p5+2,__zero_reg__
 3059 114a 1092 0000 		sts rx_addr_p5+3,__zero_reg__
 3060 114e 1092 0000 		sts rx_addr_p5+4,__zero_reg__
 3061 1152 1092 0000 		sts rx_addr_p5+5,__zero_reg__
 3062 1156 1092 0000 		sts rx_addr_p5+6,__zero_reg__
 3063 115a 1092 0000 		sts rx_addr_p5+7,__zero_reg__
1721:switcherator.c ****         writeAddr(RX_ADDR_P5, rx_addr_p5);
 3064               		.loc 1 1721 0
 3065 115e 10E0      		ldi r17,0
 3066 1160 20E0      		ldi r18,0
 3067 1162 30E0      		ldi r19,0
 3068 1164 40E0      		ldi r20,0
 3069 1166 50E0      		ldi r21,0
 3070 1168 60E0      		ldi r22,0
 3071 116a 70E0      		ldi r23,0
 3072 116c 8FE0      		ldi r24,lo8(15)
 3073 116e 0E94 0000 		call writeAddr
 3074               	.LVL195:
 3075               	.L214:
1723:switcherator.c ****     if (readEEPROM(tempStuff, TWEAK_TIMER, TWEAK_TIMER_BYTES) == 1) {
 3076               		.loc 1 1723 0
 3077 1172 44E0      		ldi r20,lo8(4)
 3078 1174 50E0      		ldi r21,0
 3079 1176 61E9      		ldi r22,lo8(-111)
 3080 1178 71E0      		ldi r23,lo8(1)
 3081 117a CE01      		movw r24,r28
 3082 117c 0196      		adiw r24,1
 3083 117e 0E94 0000 		call readEEPROM
 3084               	.LVL196:
 3085 1182 0197      		sbiw r24,1
 3086 1184 01F4      		brne .L215
1724:switcherator.c ****         tweakTimer = tempStuff[0];
 3087               		.loc 1 1724 0
 3088 1186 8981      		ldd r24,Y+1
 3089 1188 90E0      		ldi r25,0
 3090 118a A0E0      		ldi r26,0
 3091 118c B0E0      		ldi r27,0
1725:switcherator.c ****         tweakTimer <<= 8;
 3092               		.loc 1 1725 0
 3093 118e BA2F      		mov r27,r26
 3094 1190 A92F      		mov r26,r25
 3095 1192 982F      		mov r25,r24
 3096 1194 8827      		clr r24
1726:switcherator.c ****         tweakTimer |= tempStuff[1];
 3097               		.loc 1 1726 0
 3098 1196 2A81      		ldd r18,Y+2
 3099 1198 822B      		or r24,r18
 3100 119a 8093 0000 		sts tweakTimer,r24
 3101 119e 9093 0000 		sts tweakTimer+1,r25
 3102 11a2 A093 0000 		sts tweakTimer+2,r26
 3103 11a6 B093 0000 		sts tweakTimer+3,r27
 3104               	.L215:
1731:switcherator.c ****     if (readEEPROM(tempStuff, DAYLIGHT_SAVE, DAYLIGHT_SAVE_BYTES) == 1) {
 3105               		.loc 1 1731 0
 3106 11aa 4AE0      		ldi r20,lo8(10)
 3107 11ac 50E0      		ldi r21,0
 3108 11ae 66E0      		ldi r22,lo8(6)
 3109 11b0 70E0      		ldi r23,0
 3110 11b2 CE01      		movw r24,r28
 3111 11b4 0196      		adiw r24,1
 3112 11b6 0E94 0000 		call readEEPROM
 3113               	.LVL197:
 3114 11ba 0197      		sbiw r24,1
 3115 11bc 01F4      		brne .L216
1733:switcherator.c ****         daylightSavings[0][0] = ((tempStuff[0] << 8) | (tempStuff[1]));
 3116               		.loc 1 1733 0
 3117 11be 9981      		ldd r25,Y+1
 3118 11c0 80E0      		ldi r24,0
 3119 11c2 2A81      		ldd r18,Y+2
 3120 11c4 822B      		or r24,r18
 3121 11c6 9093 0000 		sts daylightSavings+1,r25
 3122 11ca 8093 0000 		sts daylightSavings,r24
1735:switcherator.c ****         daylightSavings[0][1] = ((tempStuff[2] << 8) | (tempStuff[3]));
 3123               		.loc 1 1735 0
 3124 11ce 9B81      		ldd r25,Y+3
 3125 11d0 80E0      		ldi r24,0
 3126 11d2 2C81      		ldd r18,Y+4
 3127 11d4 822B      		or r24,r18
 3128 11d6 9093 0000 		sts daylightSavings+2+1,r25
 3129 11da 8093 0000 		sts daylightSavings+2,r24
1737:switcherator.c ****         daylightSavings[1][0] = ((tempStuff[4] << 8) | (tempStuff[5]));
 3130               		.loc 1 1737 0
 3131 11de 9D81      		ldd r25,Y+5
 3132 11e0 80E0      		ldi r24,0
 3133 11e2 2E81      		ldd r18,Y+6
 3134 11e4 822B      		or r24,r18
 3135 11e6 9093 0000 		sts daylightSavings+4+1,r25
 3136 11ea 8093 0000 		sts daylightSavings+4,r24
1739:switcherator.c ****         daylightSavings[1][1] = ((tempStuff[6] << 8) | (tempStuff[7]));
 3137               		.loc 1 1739 0
 3138 11ee 9F81      		ldd r25,Y+7
 3139 11f0 80E0      		ldi r24,0
 3140 11f2 2885      		ldd r18,Y+8
 3141 11f4 822B      		or r24,r18
 3142 11f6 9093 0000 		sts daylightSavings+6+1,r25
 3143 11fa 8093 0000 		sts daylightSavings+6,r24
 3144               	.L216:
1744:switcherator.c ****     if (readEEPROM(switchStuff, SWITCH_STUFF, SWITCH_STUFF_BYTES) == 1) {
 3145               		.loc 1 1744 0
 3146 11fe 42E1      		ldi r20,lo8(18)
 3147 1200 50E0      		ldi r21,0
 3148 1202 60E3      		ldi r22,lo8(48)
 3149 1204 70E0      		ldi r23,0
 3150 1206 80E0      		ldi r24,lo8(switchStuff)
 3151 1208 90E0      		ldi r25,hi8(switchStuff)
 3152 120a 0E94 0000 		call readEEPROM
 3153               	.LVL198:
 3154 120e 0197      		sbiw r24,1
 3155 1210 01F0      		breq .+2
 3156 1212 00C0      		rjmp .L217
 3157               	.LBB22:
1745:switcherator.c ****         readEEPROM(switchBright, BRIGHTNESS, BRIGHTNESS_BYTES);
 3158               		.loc 1 1745 0
 3159 1214 42E1      		ldi r20,lo8(18)
 3160 1216 50E0      		ldi r21,0
 3161 1218 68E9      		ldi r22,lo8(-104)
 3162 121a 71E0      		ldi r23,lo8(1)
 3163 121c 80E0      		ldi r24,lo8(switchBright)
 3164 121e 90E0      		ldi r25,hi8(switchBright)
 3165 1220 0E94 0000 		call readEEPROM
 3166               	.LVL199:
 3167 1224 80E0      		ldi r24,lo8(switchStuff)
 3168 1226 90E0      		ldi r25,hi8(switchStuff)
1812:switcherator.c ****             *realDDR |= (1 << realPin);
 3169               		.loc 1 1812 0
 3170 1228 41E0      		ldi r20,lo8(1)
 3171 122a 50E0      		ldi r21,0
 3172               	.LVL200:
 3173               	.L222:
1754:switcherator.c ****             temp = switchStuff[x];
 3174               		.loc 1 1754 0
 3175 122c FC01      		movw r30,r24
 3176 122e 2191      		ld r18,Z+
 3177 1230 CF01      		movw r24,r30
 3178               	.LVL201:
1755:switcherator.c ****             if (temp > 15 && temp < 32) {
 3179               		.loc 1 1755 0
 3180 1232 622F      		mov r22,r18
 3181 1234 6051      		subi r22,lo8(-(-16))
 3182 1236 6031      		cpi r22,lo8(16)
 3183 1238 00F0      		brlo .L243
1766:switcherator.c ****             } else if (temp < 48) {
 3184               		.loc 1 1766 0
 3185 123a 2033      		cpi r18,lo8(48)
 3186 123c 00F4      		brsh .L219
 3187               	.LVL202:
1769:switcherator.c ****                 temp -= 32;
 3188               		.loc 1 1769 0
 3189 123e 6051      		subi r22,lo8(-(-16))
 3190               	.LVL203:
1768:switcherator.c ****                 realDDR = &DDRC;
 3191               		.loc 1 1768 0
 3192 1240 A7E2      		ldi r26,lo8(39)
 3193 1242 B0E0      		ldi r27,0
1767:switcherator.c ****                 realPort = &PORTC;
 3194               		.loc 1 1767 0
 3195 1244 E8E2      		ldi r30,lo8(40)
 3196 1246 F0E0      		ldi r31,0
 3197 1248 00C0      		rjmp .L218
 3198               	.LVL204:
 3199               	.L219:
1772:switcherator.c ****             } else if (temp < 64) {
 3200               		.loc 1 1772 0
 3201 124a 2034      		cpi r18,lo8(64)
 3202 124c 00F4      		brsh .L220
 3203               	.LVL205:
1775:switcherator.c ****                 temp -= 48;
 3204               		.loc 1 1775 0
 3205 124e 622F      		mov r22,r18
 3206 1250 6053      		subi r22,lo8(-(-48))
 3207               	.LVL206:
1774:switcherator.c ****                 realDDR = &DDRD;
 3208               		.loc 1 1774 0
 3209 1252 AAE2      		ldi r26,lo8(42)
 3210 1254 B0E0      		ldi r27,0
1773:switcherator.c ****                 realPort = &PORTD;
 3211               		.loc 1 1773 0
 3212 1256 EBE2      		ldi r30,lo8(43)
 3213 1258 F0E0      		ldi r31,0
 3214 125a 00C0      		rjmp .L218
 3215               	.LVL207:
 3216               	.L243:
1757:switcherator.c ****                 realDDR = &DDRB;
 3217               		.loc 1 1757 0
 3218 125c A4E2      		ldi r26,lo8(36)
 3219 125e B0E0      		ldi r27,0
1756:switcherator.c ****                 realPort = &PORTB;
 3220               		.loc 1 1756 0
 3221 1260 E5E2      		ldi r30,lo8(37)
 3222 1262 F0E0      		ldi r31,0
 3223               	.LVL208:
 3224               	.L218:
1812:switcherator.c ****             *realDDR |= (1 << realPin);
 3225               		.loc 1 1812 0
 3226 1264 7C91      		ld r23,X
1811:switcherator.c ****             realPin = (temp / 2);
 3227               		.loc 1 1811 0
 3228 1266 262F      		mov r18,r22
 3229 1268 2695      		lsr r18
 3230               	.LVL209:
1812:switcherator.c ****             *realDDR |= (1 << realPin);
 3231               		.loc 1 1812 0
 3232 126a 8A01      		movw r16,r20
 3233 126c 00C0      		rjmp 2f
 3234               		1:
 3235 126e 000F      		lsl r16
 3236 1270 111F      		rol r17
 3237               		2:
 3238 1272 2A95      		dec r18
 3239 1274 02F4      		brpl 1b
 3240 1276 9801      		movw r18,r16
 3241               	.LVL210:
 3242 1278 702B      		or r23,r16
 3243 127a 7C93      		st X,r23
1814:switcherator.c ****             if (temp % 2 == 0) {
 3244               		.loc 1 1814 0
 3245 127c 60FD      		sbrc r22,0
 3246 127e 00C0      		rjmp .L221
1816:switcherator.c ****                 *realPort |= (1 << realPin);
 3247               		.loc 1 1816 0
 3248 1280 2081      		ld r18,Z
 3249 1282 202B      		or r18,r16
 3250 1284 00C0      		rjmp .L254
 3251               	.L221:
1818:switcherator.c ****                 *realPort &= ~(1 << realPin);
 3252               		.loc 1 1818 0
 3253 1286 3081      		ld r19,Z
 3254 1288 2095      		com r18
 3255 128a 2323      		and r18,r19
 3256               	.L254:
 3257 128c 2083      		st Z,r18
 3258               	.LVL211:
 3259               	.L220:
1753:switcherator.c ****         for (x = 0; x < NUM_SWITCHES; x++) {
 3260               		.loc 1 1753 0
 3261 128e 10E0      		ldi r17,hi8(switchStuff+16)
 3262 1290 8030      		cpi r24,lo8(switchStuff+16)
 3263 1292 9107      		cpc r25,r17
 3264 1294 01F4      		brne .L222
 3265               	.L225:
 3266               	.LVL212:
 3267 1296 40E0      		ldi r20,lo8(weeklyProgram)
 3268 1298 E42E      		mov r14,r20
 3269 129a 40E0      		ldi r20,hi8(weeklyProgram)
 3270 129c F42E      		mov r15,r20
1773:switcherator.c ****                 realPort = &PORTD;
 3271               		.loc 1 1773 0
 3272 129e 01EA      		ldi r16,lo8(-95)
 3273 12a0 10E0      		ldi r17,0
 3274 12a2 00C0      		rjmp .L223
 3275               	.L217:
 3276 12a4 E0E0      		ldi r30,lo8(switchStuff)
 3277 12a6 F0E0      		ldi r31,hi8(switchStuff)
 3278               	.LBE22:
1823:switcherator.c ****             switchStuff[x] = 255;
 3279               		.loc 1 1823 0
 3280 12a8 8FEF      		ldi r24,lo8(-1)
 3281               	.LVL213:
 3282               	.L224:
1823:switcherator.c ****             switchStuff[x] = 255;
 3283               		.loc 1 1823 0 is_stmt 0 discriminator 2
 3284 12aa 8193      		st Z+,r24
1822:switcherator.c ****         for (x = 0; x < NUM_SWITCHES; x++)
 3285               		.loc 1 1822 0 is_stmt 1 discriminator 2
 3286 12ac 20E0      		ldi r18,hi8(switchStuff+16)
 3287 12ae E030      		cpi r30,lo8(switchStuff+16)
 3288 12b0 F207      		cpc r31,r18
 3289 12b2 01F4      		brne .L224
 3290 12b4 00C0      		rjmp .L225
 3291               	.L223:
 3292               	.LVL214:
1831:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, WEEKLY_PROGRAM_BYTES) == 1) {
 3293               		.loc 1 1831 0
 3294 12b6 4CE0      		ldi r20,lo8(12)
 3295 12b8 50E0      		ldi r21,0
 3296 12ba B801      		movw r22,r16
 3297 12bc CE01      		movw r24,r28
 3298 12be 0196      		adiw r24,1
 3299 12c0 0E94 0000 		call readEEPROM
 3300               	.LVL215:
 3301 12c4 0197      		sbiw r24,1
 3302 12c6 01F0      		breq .L226
 3303               	.L229:
 3304 12c8 045F      		subi r16,-12
 3305 12ca 1F4F      		sbci r17,-1
 3306               	.LVL216:
 3307 12cc 8AE0      		ldi r24,10
 3308 12ce E80E      		add r14,r24
 3309 12d0 F11C      		adc r15,__zero_reg__
1829:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 3310               		.loc 1 1829 0
 3311 12d2 0139      		cpi r16,-111
 3312 12d4 91E0      		ldi r25,1
 3313 12d6 1907      		cpc r17,r25
 3314 12d8 01F4      		brne .L223
 3315 12da 00C0      		rjmp .L252
 3316               	.LVL217:
 3317               	.L226:
 3318 12dc FE01      		movw r30,r28
 3319 12de 3196      		adiw r30,1
1831:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, WEEKLY_PROGRAM_BYTES) == 1) {
 3320               		.loc 1 1831 0
 3321 12e0 80E0      		ldi r24,0
 3322 12e2 90E0      		ldi r25,0
 3323               	.L228:
1833:switcherator.c ****                 weeklyProgram[x][y] = tempStuff[y];
 3324               		.loc 1 1833 0 discriminator 2
 3325 12e4 2191      		ld r18,Z+
1688:switcherator.c **** void generalInit(void) {
 3326               		.loc 1 1688 0 discriminator 2
 3327 12e6 D701      		movw r26,r14
 3328 12e8 A80F      		add r26,r24
 3329 12ea B91F      		adc r27,r25
1833:switcherator.c ****                 weeklyProgram[x][y] = tempStuff[y];
 3330               		.loc 1 1833 0 discriminator 2
 3331 12ec 2C93      		st X,r18
1832:switcherator.c ****             for (y = 0; y < 10; y++) {
 3332               		.loc 1 1832 0 discriminator 2
 3333 12ee 0196      		adiw r24,1
 3334               	.LVL218:
 3335 12f0 8A30      		cpi r24,10
 3336 12f2 9105      		cpc r25,__zero_reg__
 3337 12f4 01F4      		brne .L228
 3338 12f6 00C0      		rjmp .L229
 3339               	.LVL219:
 3340               	.L252:
 3341 12f8 30E0      		ldi r19,lo8(inputs)
 3342 12fa E32E      		mov r14,r19
 3343 12fc 30E0      		ldi r19,hi8(inputs)
 3344 12fe F32E      		mov r15,r19
1829:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 3345               		.loc 1 1829 0
 3346 1300 02E4      		ldi r16,lo8(66)
 3347 1302 10E0      		ldi r17,0
 3348               	.LVL220:
 3349               	.L231:
1840:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, INPUT_BYTES) == 1) {
 3350               		.loc 1 1840 0
 3351 1304 4AE0      		ldi r20,lo8(10)
 3352 1306 50E0      		ldi r21,0
 3353 1308 B801      		movw r22,r16
 3354 130a CE01      		movw r24,r28
 3355 130c 0196      		adiw r24,1
 3356 130e 0E94 0000 		call readEEPROM
 3357               	.LVL221:
 3358 1312 0197      		sbiw r24,1
 3359 1314 01F0      		breq .L230
 3360               	.L234:
 3361 1316 065F      		subi r16,-10
 3362 1318 1F4F      		sbci r17,-1
 3363               	.LVL222:
 3364 131a E8E0      		ldi r30,8
 3365 131c EE0E      		add r14,r30
 3366 131e F11C      		adc r15,__zero_reg__
1838:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 3367               		.loc 1 1838 0
 3368 1320 0A36      		cpi r16,106
 3369 1322 1105      		cpc r17,__zero_reg__
 3370 1324 01F4      		brne .L231
 3371 1326 00C0      		rjmp .L253
 3372               	.LVL223:
 3373               	.L230:
 3374 1328 FE01      		movw r30,r28
 3375 132a 3196      		adiw r30,1
1840:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, INPUT_BYTES) == 1) {
 3376               		.loc 1 1840 0
 3377 132c 80E0      		ldi r24,0
 3378 132e 90E0      		ldi r25,0
 3379               	.L233:
1842:switcherator.c ****                 inputs[x][y] = tempStuff[y];
 3380               		.loc 1 1842 0 discriminator 2
 3381 1330 2191      		ld r18,Z+
1688:switcherator.c **** void generalInit(void) {
 3382               		.loc 1 1688 0 discriminator 2
 3383 1332 D701      		movw r26,r14
 3384 1334 A80F      		add r26,r24
 3385 1336 B91F      		adc r27,r25
1842:switcherator.c ****                 inputs[x][y] = tempStuff[y];
 3386               		.loc 1 1842 0 discriminator 2
 3387 1338 2C93      		st X,r18
1841:switcherator.c ****             for (y = 0; y < 8; y++) {
 3388               		.loc 1 1841 0 discriminator 2
 3389 133a 0196      		adiw r24,1
 3390               	.LVL224:
 3391 133c 8830      		cpi r24,8
 3392 133e 9105      		cpc r25,__zero_reg__
 3393 1340 01F4      		brne .L233
 3394 1342 00C0      		rjmp .L234
 3395               	.LVL225:
 3396               	.L253:
 3397 1344 00E0      		ldi r16,lo8(timeLimits)
 3398 1346 10E0      		ldi r17,hi8(timeLimits)
 3399               	.LVL226:
1838:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 3400               		.loc 1 1838 0
 3401 1348 2AE6      		ldi r18,lo8(106)
 3402 134a E22E      		mov r14,r18
 3403 134c F12C      		mov r15,__zero_reg__
 3404               	.L236:
 3405               	.LVL227:
1849:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, LIMIT_BYTES) == 1) {
 3406               		.loc 1 1849 0
 3407 134e 45E0      		ldi r20,lo8(5)
 3408 1350 50E0      		ldi r21,0
 3409 1352 B701      		movw r22,r14
 3410 1354 CE01      		movw r24,r28
 3411 1356 0196      		adiw r24,1
 3412 1358 0E94 0000 		call readEEPROM
 3413               	.LVL228:
 3414 135c 0197      		sbiw r24,1
 3415 135e 01F4      		brne .L235
 3416               	.LVL229:
1851:switcherator.c ****                 timeLimits[x][y] = tempStuff[y];
 3417               		.loc 1 1851 0 discriminator 1
 3418 1360 8981      		ldd r24,Y+1
 3419 1362 90E0      		ldi r25,0
 3420 1364 A0E0      		ldi r26,0
 3421 1366 B0E0      		ldi r27,0
 3422 1368 F801      		movw r30,r16
 3423 136a 8083      		st Z,r24
 3424 136c 9183      		std Z+1,r25
 3425 136e A283      		std Z+2,r26
 3426 1370 B383      		std Z+3,r27
 3427               	.LVL230:
 3428 1372 8A81      		ldd r24,Y+2
 3429 1374 90E0      		ldi r25,0
 3430 1376 A0E0      		ldi r26,0
 3431 1378 B0E0      		ldi r27,0
 3432 137a 8483      		std Z+4,r24
 3433 137c 9583      		std Z+5,r25
 3434 137e A683      		std Z+6,r26
 3435 1380 B783      		std Z+7,r27
 3436               	.LVL231:
 3437 1382 8B81      		ldd r24,Y+3
 3438 1384 90E0      		ldi r25,0
 3439 1386 A0E0      		ldi r26,0
 3440 1388 B0E0      		ldi r27,0
 3441 138a 8087      		std Z+8,r24
 3442 138c 9187      		std Z+9,r25
 3443 138e A287      		std Z+10,r26
 3444 1390 B387      		std Z+11,r27
 3445               	.LVL232:
 3446               	.L235:
 3447 1392 F5E0      		ldi r31,5
 3448 1394 EF0E      		add r14,r31
 3449 1396 F11C      		adc r15,__zero_reg__
 3450               	.LVL233:
 3451 1398 045F      		subi r16,-12
 3452 139a 1F4F      		sbci r17,-1
1847:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++) {
 3453               		.loc 1 1847 0
 3454 139c 2EE7      		ldi r18,126
 3455 139e E216      		cp r14,r18
 3456 13a0 F104      		cpc r15,__zero_reg__
 3457 13a2 01F4      		brne .L236
1856:switcherator.c ****     if (readEEPROM(tempStuff, PWM_DIR, PWM_DIR_BYTES) == 1) {
 3458               		.loc 1 1856 0
 3459 13a4 43E0      		ldi r20,lo8(3)
 3460 13a6 50E0      		ldi r21,0
 3461 13a8 65E9      		ldi r22,lo8(-107)
 3462 13aa 71E0      		ldi r23,lo8(1)
 3463 13ac CE01      		movw r24,r28
 3464 13ae 0196      		adiw r24,1
 3465 13b0 0E94 0000 		call readEEPROM
 3466               	.LVL234:
 3467 13b4 0197      		sbiw r24,1
 3468 13b6 01F4      		brne .L237
1857:switcherator.c ****         DDRD |= (1 << PIND3) | (1 << PIND5) | (1 << PIND6);
 3469               		.loc 1 1857 0
 3470 13b8 8AB1      		in r24,0xa
 3471 13ba 8866      		ori r24,lo8(104)
 3472 13bc 8AB9      		out 0xa,r24
1859:switcherator.c ****         Red = 0;
 3473               		.loc 1 1859 0
 3474 13be 1092 B400 		sts 180,__zero_reg__
1860:switcherator.c ****         Green = 0;
 3475               		.loc 1 1860 0
 3476 13c2 18BC      		out 0x28,__zero_reg__
1861:switcherator.c ****         Blue = 0;
 3477               		.loc 1 1861 0
 3478 13c4 17BC      		out 0x27,__zero_reg__
1864:switcherator.c ****         if (tempStuff[0] == 0) {
 3479               		.loc 1 1864 0
 3480 13c6 8981      		ldd r24,Y+1
 3481 13c8 8111      		cpse r24,__zero_reg__
 3482 13ca 00C0      		rjmp .L238
1865:switcherator.c ****             TCCR0A = (1 << COM0A0) | (1 << COM0A1) | (1 << COM0B0) | (1 << COM0B1) | (1 << WGM00);
 3483               		.loc 1 1865 0
 3484 13cc 81EF      		ldi r24,lo8(-15)
 3485 13ce 84BD      		out 0x24,r24
1866:switcherator.c ****             TCCR2A = (1 << COM2B0) | (1 << COM2B1) | (1 << WGM20);
 3486               		.loc 1 1866 0
 3487 13d0 81E3      		ldi r24,lo8(49)
 3488 13d2 8093 B000 		sts 176,r24
1867:switcherator.c ****             pwmdir = 0;
 3489               		.loc 1 1867 0
 3490 13d6 1092 0000 		sts pwmdir,__zero_reg__
 3491 13da 00C0      		rjmp .L239
 3492               	.L238:
1869:switcherator.c ****             TCCR0A = (1 << COM0A1) | (1 << COM0B1) | (1 << WGM00);
 3493               		.loc 1 1869 0
 3494 13dc 81EA      		ldi r24,lo8(-95)
 3495 13de 84BD      		out 0x24,r24
1870:switcherator.c ****             TCCR2A = (1 << COM2B1) | (1 << WGM20);
 3496               		.loc 1 1870 0
 3497 13e0 81E2      		ldi r24,lo8(33)
 3498 13e2 8093 B000 		sts 176,r24
1871:switcherator.c ****             pwmdir = 1;
 3499               		.loc 1 1871 0
 3500 13e6 81E0      		ldi r24,lo8(1)
 3501 13e8 8093 0000 		sts pwmdir,r24
 3502               	.L239:
1874:switcherator.c ****         TCCR0B = (1 << CS01) | (1 << CS00);
 3503               		.loc 1 1874 0
 3504 13ec 83E0      		ldi r24,lo8(3)
 3505 13ee 85BD      		out 0x25,r24
1876:switcherator.c ****         TCCR2B = (1 << CS22); // F_CPU/64
 3506               		.loc 1 1876 0
 3507 13f0 84E0      		ldi r24,lo8(4)
 3508 13f2 8093 B100 		sts 177,r24
 3509               	.L237:
 3510               	.LVL235:
1881:switcherator.c ****     if (readEEPROM(tempStuff, memoryMarker, PWM_VALUE_BYTES) == 1) {
 3511               		.loc 1 1881 0
 3512 13f6 45E0      		ldi r20,lo8(5)
 3513 13f8 50E0      		ldi r21,0
 3514 13fa 6EE7      		ldi r22,lo8(126)
 3515 13fc 70E0      		ldi r23,0
 3516 13fe CE01      		movw r24,r28
 3517 1400 0196      		adiw r24,1
 3518 1402 0E94 0000 		call readEEPROM
 3519               	.LVL236:
 3520 1406 0197      		sbiw r24,1
 3521 1408 01F4      		brne .L240
1882:switcherator.c ****         pwmValues[0] = tempStuff[0];
 3522               		.loc 1 1882 0
 3523 140a 8981      		ldd r24,Y+1
 3524 140c 8093 0000 		sts pwmValues,r24
1883:switcherator.c ****         pwmValues[1] = tempStuff[1];
 3525               		.loc 1 1883 0
 3526 1410 8A81      		ldd r24,Y+2
 3527 1412 8093 0000 		sts pwmValues+1,r24
1884:switcherator.c ****         pwmValues[2] = tempStuff[2];
 3528               		.loc 1 1884 0
 3529 1416 8B81      		ldd r24,Y+3
 3530 1418 8093 0000 		sts pwmValues+2,r24
 3531               	.L240:
 3532               	.LVL237:
 3533 141c 00E0      		ldi r16,lo8(colorChanges+2)
 3534 141e 10E0      		ldi r17,hi8(colorChanges+2)
1838:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 3535               		.loc 1 1838 0 discriminator 1
 3536 1420 93E8      		ldi r25,lo8(-125)
 3537 1422 E92E      		mov r14,r25
 3538 1424 F12C      		mov r15,__zero_reg__
 3539               	.LVL238:
 3540               	.L242:
1889:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, PWM_VALUE_BYTES) == 1) {
 3541               		.loc 1 1889 0
 3542 1426 45E0      		ldi r20,lo8(5)
 3543 1428 50E0      		ldi r21,0
 3544 142a B701      		movw r22,r14
 3545 142c CE01      		movw r24,r28
 3546 142e 0196      		adiw r24,1
 3547 1430 0E94 0000 		call readEEPROM
 3548               	.LVL239:
 3549 1434 0197      		sbiw r24,1
 3550 1436 01F4      		brne .L241
 3551               	.LVL240:
1688:switcherator.c **** void generalInit(void) {
 3552               		.loc 1 1688 0 discriminator 1
 3553 1438 F801      		movw r30,r16
 3554 143a 3297      		sbiw r30,2
1891:switcherator.c ****                 colorChanges[x][y] = tempStuff[y];
 3555               		.loc 1 1891 0 discriminator 1
 3556 143c 8981      		ldd r24,Y+1
 3557 143e 8083      		st Z,r24
 3558               	.LVL241:
1688:switcherator.c **** void generalInit(void) {
 3559               		.loc 1 1688 0 discriminator 1
 3560 1440 F801      		movw r30,r16
 3561 1442 3197      		sbiw r30,1
1891:switcherator.c ****                 colorChanges[x][y] = tempStuff[y];
 3562               		.loc 1 1891 0 discriminator 1
 3563 1444 8A81      		ldd r24,Y+2
 3564 1446 8083      		st Z,r24
 3565               	.LVL242:
 3566 1448 8B81      		ldd r24,Y+3
 3567 144a F801      		movw r30,r16
 3568 144c 8083      		st Z,r24
 3569               	.LVL243:
 3570               	.L241:
 3571 144e F5E0      		ldi r31,5
 3572 1450 EF0E      		add r14,r31
 3573 1452 F11C      		adc r15,__zero_reg__
 3574               	.LVL244:
 3575 1454 0D5F      		subi r16,-3
 3576 1456 1F4F      		sbci r17,-1
1887:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 3577               		.loc 1 1887 0
 3578 1458 21EA      		ldi r18,-95
 3579 145a E216      		cp r14,r18
 3580 145c F104      		cpc r15,__zero_reg__
 3581 145e 01F4      		brne .L242
 3582               	/* epilogue start */
1895:switcherator.c **** }
 3583               		.loc 1 1895 0
 3584 1460 2E96      		adiw r28,14
 3585 1462 0FB6      		in __tmp_reg__,__SREG__
 3586 1464 F894      		cli
 3587 1466 DEBF      		out __SP_H__,r29
 3588 1468 0FBE      		out __SREG__,__tmp_reg__
 3589 146a CDBF      		out __SP_L__,r28
 3590 146c DF91      		pop r29
 3591 146e CF91      		pop r28
 3592 1470 1F91      		pop r17
 3593 1472 0F91      		pop r16
 3594 1474 FF90      		pop r15
 3595 1476 EF90      		pop r14
 3596               	.LVL245:
 3597 1478 0895      		ret
 3598               	.LFE41:
 3600               	.global	unformatAddress
 3602               	unformatAddress:
 3603               	.LFB75:
2908:switcherator.c **** 
2909:switcherator.c **** // send receive addresses
2910:switcherator.c **** //static uint64_t rx_addr_p0, rx_addr_p1, rx_addr_p2, rx_addr_p3, rx_addr_p4, rx_addr_p5, tx_addr;
2911:switcherator.c **** 
2912:switcherator.c **** // display's a given address
2913:switcherator.c **** //RD:N RC:N 0xnnnnnnnnnn
2914:switcherator.c **** //0123
2915:switcherator.c **** 
2916:switcherator.c **** void radioDisplayAddress(char * commandReceived) {
2917:switcherator.c ****     int x = 0;
2918:switcherator.c ****     char tempRadioString[6];
2919:switcherator.c ****     statusMsg[0] = 0;
2920:switcherator.c ****     if(commandReceived[3] == '1') {
2921:switcherator.c ****         unformatAddress(rx_addr_p1, tempRadioString);
2922:switcherator.c ****         strcat(statusMsg, "r1-0x");
2923:switcherator.c ****     } else if(commandReceived[3] == '2') {
2924:switcherator.c ****         unformatAddress(rx_addr_p2, tempRadioString);
2925:switcherator.c ****         strcat(statusMsg, "r2-0x");
2926:switcherator.c ****     } else if(commandReceived[3] == '3') {
2927:switcherator.c ****         unformatAddress(rx_addr_p3, tempRadioString);
2928:switcherator.c ****         strcat(statusMsg, "r3-0x");
2929:switcherator.c ****     } else if(commandReceived[3] == '4') {
2930:switcherator.c ****         unformatAddress(rx_addr_p4, tempRadioString);
2931:switcherator.c ****         strcat(statusMsg, "r4-0x");
2932:switcherator.c ****     } else if (commandReceived[3] == '5') {
2933:switcherator.c ****         unformatAddress(rx_addr_p5, tempRadioString);
2934:switcherator.c ****         strcat(statusMsg, "r5-0x");
2935:switcherator.c ****     } else if (commandReceived[3] == 'T') {
2936:switcherator.c ****         unformatAddress(tx_addr, tempRadioString);
2937:switcherator.c ****         strcat(statusMsg, "t-0x");
2938:switcherator.c ****     } else {
2939:switcherator.c ****         unformatAddress(rx_addr_p0, tempRadioString);
2940:switcherator.c ****         strcat(statusMsg, "r0-0x");
2941:switcherator.c ****     }
2942:switcherator.c ****     for (x = 0; x < 5; x++) {
2943:switcherator.c ****         returnHexWithout(tempRadioString[x], tempLongString);
2944:switcherator.c ****         strcat(statusMsg, tempLongString);
2945:switcherator.c ****     }
2946:switcherator.c ****     sendMessage(statusMsg);
2947:switcherator.c **** }
2948:switcherator.c **** 
2949:switcherator.c **** // change the radio address
2950:switcherator.c **** // send receive addresses
2951:switcherator.c **** //static uint64_t rx_addr_p0, rx_addr_p1, rx_addr_p2, rx_addr_p3, rx_addr_p4, rx_addr_p5, tx_addr;
2952:switcherator.c **** 
2953:switcherator.c **** //RD:N RC:N 0xnnnnnnnnnn
2954:switcherator.c **** //     01234567890123456
2955:switcherator.c **** 
2956:switcherator.c **** void radioChangeAddress(char * commandReceived) {
2957:switcherator.c ****     int x = 0;
2958:switcherator.c ****     statusMsg[0] = 0;
2959:switcherator.c ****     int tempInt = 0;
2960:switcherator.c ****     uint64_t newAddress = 0;
2961:switcherator.c ****     char tempString[] = "0x00";
2962:switcherator.c ****     char tempRadioString[] = "00000";
2963:switcherator.c ****     for (x = 0; x < 5; x++) {
2964:switcherator.c ****         tempString[2] = commandReceived[((x * 2) + 7)];
2965:switcherator.c ****         tempString[3] = commandReceived[((x * 2) + 8)];
2966:switcherator.c ****         tempInt = strtol(tempString, 0, 0);
2967:switcherator.c ****         newAddress |= tempInt;
2968:switcherator.c ****         if (x < 4)
2969:switcherator.c ****             newAddress <<= 8;
2970:switcherator.c ****     }
2971:switcherator.c ****     switch (commandReceived[3]) {
2972:switcherator.c ****         case '0':
2973:switcherator.c ****             rx_addr_p0 = newAddress;
2974:switcherator.c ****             strcat(statusMsg, "r0 0x");
2975:switcherator.c ****             writeAddr(RX_ADDR_P0, newAddress);
2976:switcherator.c ****             break;
2977:switcherator.c ****         case '1':
2978:switcherator.c ****             rx_addr_p1 = newAddress;
2979:switcherator.c ****             strcat(statusMsg, "r1 0x");
2980:switcherator.c ****             writeAddr(RX_ADDR_P1, newAddress);
2981:switcherator.c ****             break;
2982:switcherator.c ****         case '2':
2983:switcherator.c ****             rx_addr_p2 = newAddress;
2984:switcherator.c ****             strcat(statusMsg, "r2 0x");
2985:switcherator.c ****             writeAddr(RX_ADDR_P2, newAddress);
2986:switcherator.c ****             break;
2987:switcherator.c ****         case '3':
2988:switcherator.c ****             rx_addr_p3 = newAddress;
2989:switcherator.c ****             strcat(statusMsg, "r3 0x");
2990:switcherator.c ****             writeAddr(RX_ADDR_P3, newAddress);
2991:switcherator.c ****             break;
2992:switcherator.c ****         case '4':
2993:switcherator.c ****             rx_addr_p4 = newAddress;
2994:switcherator.c ****             strcat(statusMsg, "r4 0x");
2995:switcherator.c ****             writeAddr(RX_ADDR_P4, newAddress);
2996:switcherator.c ****             break;
2997:switcherator.c ****         case '5':
2998:switcherator.c ****             rx_addr_p5 = newAddress;
2999:switcherator.c ****             strcat(statusMsg, "r5 0x");
3000:switcherator.c ****             writeAddr(RX_ADDR_P5, newAddress);
3001:switcherator.c ****             break;
3002:switcherator.c ****         case 'T':
3003:switcherator.c ****             tx_addr = newAddress;
3004:switcherator.c ****             strcat(statusMsg, "t 0x");
3005:switcherator.c ****             writeAddr(TX_ADDR, newAddress);
3006:switcherator.c ****             break;
3007:switcherator.c ****     }
3008:switcherator.c ****     unformatAddress(newAddress, tempRadioString);
3009:switcherator.c ****     for (x = 0; x < 5; x++) {
3010:switcherator.c ****         returnHexWithout(tempRadioString[x], tempLongString);
3011:switcherator.c ****         strcat(statusMsg, tempLongString);
3012:switcherator.c ****     }
3013:switcherator.c ****     sendMessage(statusMsg);
3014:switcherator.c **** }
3015:switcherator.c **** 
3016:switcherator.c **** 
3017:switcherator.c **** // take the int and return the array
3018:switcherator.c **** 
3019:switcherator.c **** void unformatAddress(uint64_t oldAddress, char * formattedAddress) {
 3604               		.loc 1 3019 0
 3605               	.LVL246:
 3606 147a 0F93      		push r16
 3607               	.LCFI84:
 3608 147c 1F93      		push r17
 3609               	.LCFI85:
 3610               	/* prologue: function */
 3611               	/* frame size = 0 */
 3612               	/* stack size = 2 */
 3613               	.L__stack_usage = 2
 3614 147e F801      		movw r30,r16
 3615               	.LVL247:
3020:switcherator.c ****     uint64_t tempInt = oldAddress;
3021:switcherator.c ****     formattedAddress[4] = (tempInt & 0xff);
 3616               		.loc 1 3021 0
 3617 1480 2483      		std Z+4,r18
3022:switcherator.c ****     tempInt >>= 8;
 3618               		.loc 1 3022 0
 3619 1482 08E0      		ldi r16,lo8(8)
 3620               	.LVL248:
 3621 1484 0E94 0000 		call __lshrdi3
 3622               	.LVL249:
3023:switcherator.c ****     formattedAddress[3] = (tempInt & 0xff);
 3623               		.loc 1 3023 0
 3624 1488 2383      		std Z+3,r18
3024:switcherator.c ****     tempInt >>= 8;
 3625               		.loc 1 3024 0
 3626 148a 0E94 0000 		call __lshrdi3
 3627               	.LVL250:
3025:switcherator.c ****     formattedAddress[2] = (tempInt & 0xff);
 3628               		.loc 1 3025 0
 3629 148e 2283      		std Z+2,r18
3026:switcherator.c ****     tempInt >>= 8;
 3630               		.loc 1 3026 0
 3631 1490 0E94 0000 		call __lshrdi3
 3632               	.LVL251:
3027:switcherator.c ****     formattedAddress[1] = (tempInt & 0xff);
 3633               		.loc 1 3027 0
 3634 1494 2183      		std Z+1,r18
 3635               	.LVL252:
3028:switcherator.c ****     tempInt >>= 8;
 3636               		.loc 1 3028 0
 3637 1496 0E94 0000 		call __lshrdi3
 3638               	.LVL253:
3029:switcherator.c ****     formattedAddress[0] = (tempInt & 0xff);
 3639               		.loc 1 3029 0
 3640 149a 2083      		st Z,r18
 3641               	/* epilogue start */
3030:switcherator.c **** }
 3642               		.loc 1 3030 0
 3643 149c 1F91      		pop r17
 3644 149e 0F91      		pop r16
 3645 14a0 0895      		ret
 3646               	.LFE75:
 3648               	.global	getInput
 3650               	getInput:
 3651               	.LFB81:
3031:switcherator.c **** 
3032:switcherator.c **** void sendMessage(char * myResponse) {
3033:switcherator.c ****     stopRx();
3034:switcherator.c ****     _delay_us(100);
3035:switcherator.c ****     int transmitLength = strlen(myResponse);
3036:switcherator.c ****     if(!transmit(myResponse, transmitLength)) {
3037:switcherator.c ****         failCondition = 2;
3038:switcherator.c ****     } else {
3039:switcherator.c ****         failCondition = 0;
3040:switcherator.c ****         clearFail();
3041:switcherator.c ****     }
3042:switcherator.c ****     startRx();
3043:switcherator.c **** }
3044:switcherator.c **** 
3045:switcherator.c **** 
3046:switcherator.c **** /****************************************************************
3047:switcherator.c ****  *
3048:switcherator.c ****  *              All Things Input Related
3049:switcherator.c ****  *
3050:switcherator.c ****  ****************************************************************/
3051:switcherator.c **** 
3052:switcherator.c **** // sets up an input on one of the analog pins
3053:switcherator.c **** // DI:##Ppx?##DuraPO
3054:switcherator.c **** // AI:##PpLLLHHH?##DuraPOw
3055:switcherator.c **** // 0123456789012345678901234
3056:switcherator.c **** // int Port/pin like switches, low%,high%, switch/program, dur, poll time
3057:switcherator.c **** // inputs[NUM_INPUTS]
3058:switcherator.c **** 
3059:switcherator.c **** void setAnalogInput(char * commandReceived) {
3060:switcherator.c ****     int x = 0;
3061:switcherator.c ****     int inputNumber, lowPercent, highPercent, pollTime, outputNum, duration;
3062:switcherator.c ****     char pin = 0;
3063:switcherator.c ****     inputNumber = lowPercent = highPercent = pollTime = outputNum = duration = 0;
3064:switcherator.c ****     int switchNumber = 0;
3065:switcherator.c ****     long temp = 0;
3066:switcherator.c ****     char whichRGB = 0;
3067:switcherator.c ****     tempIntString[0] = commandReceived[3];
3068:switcherator.c ****     tempIntString[1] = commandReceived[4];
3069:switcherator.c ****     inputNumber = atoi(tempIntString);
3070:switcherator.c ****     if (inputNumber >= NUM_INPUTS) {
3071:switcherator.c ****         fail(0x11);
3072:switcherator.c ****         return;
3073:switcherator.c ****     }
3074:switcherator.c ****     tempIntString[0] = '0';
3075:switcherator.c ****     tempIntString[1] = commandReceived[6];
3076:switcherator.c ****     pin = atoi(tempIntString);
3077:switcherator.c ****     if (pin > 7) {
3078:switcherator.c ****         fail(0x04);
3079:switcherator.c ****         return;
3080:switcherator.c ****     }
3081:switcherator.c **** 
3082:switcherator.c ****     tempIntString[0] = commandReceived[14];
3083:switcherator.c ****     tempIntString[1] = commandReceived[15];
3084:switcherator.c ****     switchNumber = atoi(tempIntString);
3085:switcherator.c **** 
3086:switcherator.c ****     tempIntString[0] = commandReceived[20];
3087:switcherator.c ****     tempIntString[1] = commandReceived[21];
3088:switcherator.c ****     pollTime = atoi(tempIntString);
3089:switcherator.c **** 
3090:switcherator.c ****     tempIntString[0] = '0';
3091:switcherator.c ****     tempIntString[1] = commandReceived[22];
3092:switcherator.c ****     whichRGB = atoi(tempIntString);
3093:switcherator.c **** 
3094:switcherator.c ****     tempLongString[0] = '0';
3095:switcherator.c ****     tempLongString[1] = commandReceived[7];
3096:switcherator.c ****     tempLongString[2] = commandReceived[8];
3097:switcherator.c ****     tempLongString[3] = commandReceived[9];
3098:switcherator.c ****     lowPercent = atoi(tempLongString);
3099:switcherator.c ****     tempLongString[1] = commandReceived[10];
3100:switcherator.c ****     tempLongString[2] = commandReceived[11];
3101:switcherator.c ****     tempLongString[3] = commandReceived[12];
3102:switcherator.c ****     highPercent = atoi(tempLongString);
3103:switcherator.c **** 
3104:switcherator.c ****     tempLongString[0] = commandReceived[16];
3105:switcherator.c ****     tempLongString[1] = commandReceived[17];
3106:switcherator.c ****     tempLongString[2] = commandReceived[18];
3107:switcherator.c ****     tempLongString[3] = commandReceived[19];
3108:switcherator.c ****     duration = atoi(tempLongString);
3109:switcherator.c **** 
3110:switcherator.c ****     // pLHsDDP p int pin/port like sw, L%,H% (0,255 - digital), s - 0-127=switch, 128-255 = prog
3111:switcherator.c ****     // 0123456
3112:switcherator.c ****     // dur in seconds, poll time in secs or  0 for continuous. 
3113:switcherator.c ****     // #= analogIn num, p=pin, LLL=low%, HHH=High%,? = 'P'rog or 'S', ## = num
3114:switcherator.c ****     // Durat. = duration in seconds, POLL = poll time in seconds or 0 for 1/10
3115:switcherator.c ****     if (commandReceived[5] != 'C' && commandReceived[5] != 'c') {
3116:switcherator.c ****         fail(0x03);
3117:switcherator.c ****         return;
3118:switcherator.c ****     }
3119:switcherator.c ****     // Port / Pin
3120:switcherator.c ****     // value of 255 (default) means nothing programmed
3121:switcherator.c ****     // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
3122:switcherator.c ****     // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
3123:switcherator.c ****     // pin is abs(value/2)-the base - PINB3 = (22-16)/2  PINB3 (22-16)%2 = 0 - low (23-16)%2 = 1 - 
3124:switcherator.c ****     // port is C.  This is analog in so its not normal but need to set the DDR anyway
3125:switcherator.c ****     // get the pin
3126:switcherator.c ****     temp = pin * 2;
3127:switcherator.c ****     // add # for port C
3128:switcherator.c ****     temp += 32;
3129:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
3130:switcherator.c ****         if (switchStuff[x] == temp) {
3131:switcherator.c **** 
3132:switcherator.c ****             fail(0x12);
3133:switcherator.c ****             return;
3134:switcherator.c ****         }
3135:switcherator.c ****     }
3136:switcherator.c ****     inputs[inputNumber][0] = temp;
3137:switcherator.c ****     DDRC &= ~(1 << pin);
3138:switcherator.c ****     temp = lowPercent;
3139:switcherator.c ****     temp = temp * 255;
3140:switcherator.c ****     temp = temp / 100;
3141:switcherator.c ****     inputs[inputNumber][1] = temp;
3142:switcherator.c ****     temp = highPercent;
3143:switcherator.c ****     temp = temp * 255;
3144:switcherator.c ****     temp = temp / 100;
3145:switcherator.c ****     if (temp == 255) // if the top is 255 we need it to be 254 so its not digital
3146:switcherator.c ****         temp = 254;
3147:switcherator.c **** 
3148:switcherator.c ****     inputs[inputNumber][2] = temp;
3149:switcherator.c ****     // 128 switches and 128 programs possible
3150:switcherator.c ****     if (commandReceived[13] == 'P' || commandReceived[13] == 'p') {
3151:switcherator.c ****         switchNumber += 128;
3152:switcherator.c ****     }
3153:switcherator.c ****     inputs[inputNumber][3] = switchNumber;
3154:switcherator.c ****     temp = duration >> 8;
3155:switcherator.c ****     inputs[inputNumber][4] = temp;
3156:switcherator.c ****     temp = duration & 0xff;
3157:switcherator.c ****     inputs[inputNumber][5] = temp;
3158:switcherator.c **** 
3159:switcherator.c **** 
3160:switcherator.c ****     if (pollTime > 255)
3161:switcherator.c ****         pollTime = 255;
3162:switcherator.c ****     inputs[inputNumber][6] = pollTime;
3163:switcherator.c **** 
3164:switcherator.c ****     // if we are using a RGB switch then which ones do we activate (mask)
3165:switcherator.c ****     if (whichRGB > 7)
3166:switcherator.c ****         whichRGB = 7;
3167:switcherator.c ****     inputs[inputNumber][7] = whichRGB;
3168:switcherator.c **** 
3169:switcherator.c **** 
3170:switcherator.c ****     // set ADMUX when we do a conversion
3171:switcherator.c ****     // Set prescaler 1/32. why not... ;-)
3172:switcherator.c ****     ADCSRA |= (1 << ADPS2) || (1 << ADPS0);
3173:switcherator.c **** 
3174:switcherator.c **** 
3175:switcherator.c ****     ok();
3176:switcherator.c **** }
3177:switcherator.c **** 
3178:switcherator.c **** // set up an input on a regular pin
3179:switcherator.c **** // DI:##Ppx?##DuraPO
3180:switcherator.c **** // 012345678901234567890
3181:switcherator.c **** // #=digital in num, P=Port,p=pin, x=High or Low, ?='P'rog or 'S'witch,
3182:switcherator.c **** // ## = prog/switch num, Durat.=duration in seconds, POLL=poll time in sec or 0 for 1/10
3183:switcherator.c **** 
3184:switcherator.c **** void setDigitalInput(char * commandReceived) {
3185:switcherator.c ****     int x = 0;
3186:switcherator.c ****     int inputNumber, pollTime, outputNum, duration;
3187:switcherator.c ****     volatile unsigned char *realDDR = 0;
3188:switcherator.c ****     volatile unsigned char *realPort = 0;
3189:switcherator.c ****     char pin = 0;
3190:switcherator.c ****     inputNumber = pollTime = outputNum = duration = 0;
3191:switcherator.c ****     int switchNumber = 0;
3192:switcherator.c ****     int temp = 0;
3193:switcherator.c ****     tempIntString[0] = commandReceived[3];
3194:switcherator.c ****     tempIntString[1] = commandReceived[4];
3195:switcherator.c ****     inputNumber = atoi(tempIntString);
3196:switcherator.c ****     if (inputNumber >= NUM_INPUTS) {
3197:switcherator.c ****         fail(0x11);
3198:switcherator.c ****         return;
3199:switcherator.c ****     }
3200:switcherator.c ****     tempIntString[0] = '0';
3201:switcherator.c ****     tempIntString[1] = commandReceived[6];
3202:switcherator.c ****     pin = atoi(tempIntString);
3203:switcherator.c ****     if (pin > 7) {
3204:switcherator.c ****         fail(0x04);
3205:switcherator.c ****         return;
3206:switcherator.c ****     }
3207:switcherator.c **** 
3208:switcherator.c ****     tempIntString[0] = commandReceived[9];
3209:switcherator.c ****     tempIntString[1] = commandReceived[10];
3210:switcherator.c ****     switchNumber = atoi(tempIntString);
3211:switcherator.c **** 
3212:switcherator.c ****     tempIntString[0] = commandReceived[15];
3213:switcherator.c ****     tempIntString[1] = commandReceived[16];
3214:switcherator.c ****     pollTime = atoi(tempIntString);
3215:switcherator.c **** 
3216:switcherator.c ****     tempLongString[0] = commandReceived[11];
3217:switcherator.c ****     tempLongString[1] = commandReceived[12];
3218:switcherator.c ****     tempLongString[2] = commandReceived[13];
3219:switcherator.c ****     tempLongString[3] = commandReceived[14];
3220:switcherator.c ****     duration = atoi(tempLongString);
3221:switcherator.c ****     // if we are activating a program
3222:switcherator.c ****     if (commandReceived[8] == 'P' || commandReceived[8] == 'p') {
3223:switcherator.c ****         switchNumber += 128;
3224:switcherator.c ****     }
3225:switcherator.c ****     temp = pin * 2;
3226:switcherator.c ****     if (commandReceived[5] == 'B' || commandReceived[5] == 'b') {
3227:switcherator.c ****         realDDR = &DDRB;
3228:switcherator.c ****         realPort = &PORTB;
3229:switcherator.c ****         temp += 16;
3230:switcherator.c **** #ifdef PORTA
3231:switcherator.c ****     } else if (commandReceived[5] == 'A' || commandReceived[5] == 'a') {
3232:switcherator.c ****         realDDR = &DDRA;
3233:switcherator.c ****         realPort = &PORTA;
3234:switcherator.c ****         temp += 0;
3235:switcherator.c **** #endif        
3236:switcherator.c **** #ifdef PORTC
3237:switcherator.c ****     } else if (commandReceived[5] == 'C' || commandReceived[5] == 'c') {
3238:switcherator.c ****         realDDR = &DDRC;
3239:switcherator.c ****         realPort = &PORTC;
3240:switcherator.c ****         temp += 32;
3241:switcherator.c **** #endif        
3242:switcherator.c **** #ifdef PORTD
3243:switcherator.c ****     } else if (commandReceived[5] == 'D' || commandReceived[5] == 'd') {
3244:switcherator.c ****         realDDR = &DDRD;
3245:switcherator.c ****         realPort = &PORTD;
3246:switcherator.c ****         temp += 48;
3247:switcherator.c **** #endif        
3248:switcherator.c **** #ifdef PORTE
3249:switcherator.c ****     } else if (commandReceived[5] == 'E' || commandReceived[5] == 'e') {
3250:switcherator.c ****         realDDR = &DDRE;
3251:switcherator.c ****         realPort = &PORTE;
3252:switcherator.c ****         temp += 64;
3253:switcherator.c **** #endif        
3254:switcherator.c **** #ifdef PORTF
3255:switcherator.c ****     } else if (commandReceived[5] == 'F' || commandReceived[5] == 'f') {
3256:switcherator.c ****         realDDR = &DDRF;
3257:switcherator.c ****         realPort = &PORTF;
3258:switcherator.c ****         temp += 80;
3259:switcherator.c **** #endif        
3260:switcherator.c **** #ifdef PORTG
3261:switcherator.c ****     } else if (commandReceived[5] == 'G' || commandReceived[5] == 'g') {
3262:switcherator.c ****         realDDR = &DDRG;
3263:switcherator.c ****         realPort = &PORTG;
3264:switcherator.c ****         temp += 96;
3265:switcherator.c **** #endif        
3266:switcherator.c **** #ifdef PORTH
3267:switcherator.c ****     } else if (commandReceived[5] == 'H' || commandReceived[5] == 'h') {
3268:switcherator.c ****         realDDR = &DDRH;
3269:switcherator.c ****         realPort = &PORTH;
3270:switcherator.c ****         temp += 112;
3271:switcherator.c **** #endif        
3272:switcherator.c **** #ifdef PORTI
3273:switcherator.c ****     } else if (commandReceived[5] == 'I' || commandReceived[5] == 'i') {
3274:switcherator.c ****         realDDR = &DDRI;
3275:switcherator.c ****         realPort = &PORTI;
3276:switcherator.c ****         temp += 128;
3277:switcherator.c **** #endif        
3278:switcherator.c ****     }
3279:switcherator.c ****     // value of 255 (default) means nothing programmed
3280:switcherator.c ****     // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
3281:switcherator.c ****     // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
3282:switcherator.c ****     // pin is abs(value/2)-the base - PINB3 = (22-16)/2  PINB3 (22-16)%2 = 0 - low (23-16)%2 = 1 - 
3283:switcherator.c ****     // port is C.  This is analog in so its not normal but need to set the DDR anyway
3284:switcherator.c ****     // get the pin
3285:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
3286:switcherator.c ****         if (switchStuff[x] == temp || switchStuff[x] == (temp + 1)) {
3287:switcherator.c ****             fail(0x12);
3288:switcherator.c ****             return;
3289:switcherator.c ****         }
3290:switcherator.c ****     }
3291:switcherator.c **** 
3292:switcherator.c ****     inputs[inputNumber][0] = temp;
3293:switcherator.c **** 
3294:switcherator.c ****     if (commandReceived[7] == 'H' || commandReceived[7] == 'h' ||
3295:switcherator.c ****             commandReceived[7] == '1') {
3296:switcherator.c ****         inputs[inputNumber][1] = 0;
3297:switcherator.c ****         inputs[inputNumber][2] = 255;
3298:switcherator.c ****     } else {
3299:switcherator.c ****         inputs[inputNumber][1] = 255;
3300:switcherator.c ****         inputs[inputNumber][2] = 0;
3301:switcherator.c ****     }
3302:switcherator.c ****     inputs[inputNumber][3] = switchNumber;
3303:switcherator.c ****     temp = duration >> 8;
3304:switcherator.c ****     inputs[inputNumber][4] = temp;
3305:switcherator.c ****     temp = duration & 0xff;
3306:switcherator.c ****     inputs[inputNumber][5] = temp;
3307:switcherator.c **** 
3308:switcherator.c ****     if (pollTime > 255)
3309:switcherator.c ****         pollTime = 255;
3310:switcherator.c ****     inputs[inputNumber][6] = pollTime;
3311:switcherator.c **** 
3312:switcherator.c ****     *realDDR &= ~(1 << pin);
3313:switcherator.c ****     *realPort |= (1 << pin);
3314:switcherator.c **** 
3315:switcherator.c ****     ok();
3316:switcherator.c ****     // DI:##Ppx?##DuraPO
3317:switcherator.c ****     // 012345678901234567890
3318:switcherator.c **** }
3319:switcherator.c **** 
3320:switcherator.c **** // inputs[NUM_INPUTS] - is the following
3321:switcherator.c **** // pLHsDDP p int pin/port like sw, L%,H% (0,255 - digital), s - 0-127=switch, 128-255 = prog
3322:switcherator.c **** // 0123456
3323:switcherator.c **** // Port / Pin
3324:switcherator.c **** // value of 255 (default) means nothing programmed
3325:switcherator.c **** // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
3326:switcherator.c **** // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
3327:switcherator.c **** 
3328:switcherator.c **** // see if we check any inputs this second
3329:switcherator.c **** 
3330:switcherator.c **** void inputCheck(void) {
3331:switcherator.c ****     int x = 0;
3332:switcherator.c ****     int pollTime = 0;
3333:switcherator.c ****     // figure out if we care about our inputs
3334:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
3335:switcherator.c ****         // see if it is a valid input
3336:switcherator.c ****         if (inputs[x][0] == 255)
3337:switcherator.c ****             continue; // not valid. Skip
3338:switcherator.c ****         pollTime = inputs[x][6];
3339:switcherator.c ****         // see if it is one we check continuously or every second
3340:switcherator.c ****         if (pollTime == 0 || pollTime == 1) {
3341:switcherator.c ****             getInput(x);
3342:switcherator.c ****             // see if we it is the right second otherwise
3343:switcherator.c ****         } else if (weeklySeconds % pollTime == 0) {
3344:switcherator.c ****             getInput(x);
3345:switcherator.c ****         }
3346:switcherator.c ****     }
3347:switcherator.c **** }
3348:switcherator.c **** 
3349:switcherator.c **** // see if we check inputs continuously (every 10th)
3350:switcherator.c **** 
3351:switcherator.c **** void inputTenthCheck(void) {
3352:switcherator.c ****     int x = 0;
3353:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
3354:switcherator.c ****         // see if it is valid and marked continuously
3355:switcherator.c ****         if (inputs[x][0] != 255 && inputs[x][6] == 0)
3356:switcherator.c ****             getInput(x);
3357:switcherator.c ****     }
3358:switcherator.c **** }
3359:switcherator.c **** 
3360:switcherator.c **** // inputs[NUM_INPUTS] - is the following
3361:switcherator.c **** // pLHsDDPw p int pin/port like sw, L%,H% (0,255 - digital), s - 0-127=switch, 128-255 = prog
3362:switcherator.c **** // 01234567 - w= which analog out if needed
3363:switcherator.c **** // Port / Pin
3364:switcherator.c **** // value of 255 (default) means nothing programmed
3365:switcherator.c **** // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
3366:switcherator.c **** // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
3367:switcherator.c **** 
3368:switcherator.c **** 
3369:switcherator.c **** // actually check the input and do something based on that
3370:switcherator.c **** 
3371:switcherator.c **** void getInput(int inputNumber) {
 3652               		.loc 1 3371 0
 3653               	.LVL254:
 3654 14a2 2F92      		push r2
 3655               	.LCFI86:
 3656 14a4 3F92      		push r3
 3657               	.LCFI87:
 3658 14a6 4F92      		push r4
 3659               	.LCFI88:
 3660 14a8 5F92      		push r5
 3661               	.LCFI89:
 3662 14aa 6F92      		push r6
 3663               	.LCFI90:
 3664 14ac 7F92      		push r7
 3665               	.LCFI91:
 3666 14ae 8F92      		push r8
 3667               	.LCFI92:
 3668 14b0 9F92      		push r9
 3669               	.LCFI93:
 3670 14b2 AF92      		push r10
 3671               	.LCFI94:
 3672 14b4 BF92      		push r11
 3673               	.LCFI95:
 3674 14b6 CF92      		push r12
 3675               	.LCFI96:
 3676 14b8 DF92      		push r13
 3677               	.LCFI97:
 3678 14ba EF92      		push r14
 3679               	.LCFI98:
 3680 14bc FF92      		push r15
 3681               	.LCFI99:
 3682 14be 0F93      		push r16
 3683               	.LCFI100:
 3684 14c0 1F93      		push r17
 3685               	.LCFI101:
 3686 14c2 CF93      		push r28
 3687               	.LCFI102:
 3688 14c4 DF93      		push r29
 3689               	.LCFI103:
 3690 14c6 CDB7      		in r28,__SP_L__
 3691 14c8 DEB7      		in r29,__SP_H__
 3692               	.LCFI104:
 3693 14ca 2C97      		sbiw r28,12
 3694               	.LCFI105:
 3695 14cc 0FB6      		in __tmp_reg__,__SREG__
 3696 14ce F894      		cli
 3697 14d0 DEBF      		out __SP_H__,r29
 3698 14d2 0FBE      		out __SREG__,__tmp_reg__
 3699 14d4 CDBF      		out __SP_L__,r28
 3700               	/* prologue: function */
 3701               	/* frame size = 12 */
 3702               	/* stack size = 30 */
 3703               	.L__stack_usage = 30
 3704 14d6 FC01      		movw r30,r24
 3705               	.LVL255:
3372:switcherator.c ****     int x = 0;
3373:switcherator.c ****     unsigned int outputNum, duration, low, high, switchNumber;
3374:switcherator.c ****     volatile unsigned char *thisPin = 0;
3375:switcherator.c ****     long temp = 0;
3376:switcherator.c ****     char test = 0;
3377:switcherator.c ****     char pwmValue = 0;
3378:switcherator.c ****     char whichRGB = 0;
3379:switcherator.c ****     // set up how many seconds are at the beginning of today
3380:switcherator.c ****     long daySeconds = (dow * 86400);
 3706               		.loc 1 3380 0
 3707 14d8 2090 0000 		lds r2,dow
 3708 14dc 3090 0000 		lds r3,dow+1
 3709 14e0 2101      		movw r4,r2
 3710 14e2 612C      		mov r6,__zero_reg__
 3711 14e4 712C      		mov r7,__zero_reg__
 3712 14e6 A301      		movw r20,r6
 3713 14e8 9201      		movw r18,r4
 3714 14ea 60E8      		ldi r22,lo8(-128)
 3715 14ec 71E5      		ldi r23,lo8(81)
 3716 14ee 81E0      		ldi r24,lo8(1)
 3717 14f0 90E0      		ldi r25,0
 3718 14f2 0E94 0000 		call __mulsi3
 3719 14f6 4B01      		movw r8,r22
 3720 14f8 5C01      		movw r10,r24
 3721               	.LVL256:
3381:switcherator.c ****     long startTime, stopTime;
3382:switcherator.c ****     startTime = stopTime = 0;
3383:switcherator.c ****     outputNum = duration = low = high = switchNumber = 0;
3384:switcherator.c ****     outputNum = inputs[inputNumber][0];
 3722               		.loc 1 3384 0
 3723 14fa 43E0      		ldi r20,3
 3724               		1:
 3725 14fc EE0F      		lsl r30
 3726 14fe FF1F      		rol r31
 3727 1500 4A95      		dec r20
 3728 1502 01F4      		brne 1b
 3729 1504 E050      		subi r30,lo8(-(inputs))
 3730 1506 F040      		sbci r31,hi8(-(inputs))
 3731 1508 6081      		ld r22,Z
 3732               	.LVL257:
3385:switcherator.c ****     low = inputs[inputNumber][1];
 3733               		.loc 1 3385 0
 3734 150a C180      		ldd r12,Z+1
 3735 150c EC2C      		mov r14,r12
 3736 150e F12C      		mov r15,__zero_reg__
 3737               	.LVL258:
3386:switcherator.c ****     high = inputs[inputNumber][2];
 3738               		.loc 1 3386 0
 3739 1510 0281      		ldd r16,Z+2
 3740 1512 0983      		std Y+1,r16
 3741               	.LVL259:
3387:switcherator.c ****     switchNumber = inputs[inputNumber][3];
 3742               		.loc 1 3387 0
 3743 1514 0381      		ldd r16,Z+3
 3744               	.LVL260:
 3745 1516 10E0      		ldi r17,0
 3746               	.LVL261:
3388:switcherator.c ****     temp = inputs[inputNumber][4];
3389:switcherator.c ****     duration = (temp << 8);
 3747               		.loc 1 3389 0
 3748 1518 3481      		ldd r19,Z+4
 3749 151a 20E0      		ldi r18,0
3390:switcherator.c ****     temp = inputs[inputNumber][5];
3391:switcherator.c ****     duration |= temp;
 3750               		.loc 1 3391 0
 3751 151c 8581      		ldd r24,Z+5
 3752               	.LVL262:
 3753 151e A901      		movw r20,r18
 3754 1520 482B      		or r20,r24
 3755 1522 5C87      		std Y+12,r21
 3756 1524 4B87      		std Y+11,r20
 3757               	.LVL263:
3392:switcherator.c ****     whichRGB = inputs[inputNumber][7];
 3758               		.loc 1 3392 0
 3759 1526 D780      		ldd r13,Z+7
 3760               	.LVL264:
3393:switcherator.c ****     // if this is an analog input than both the low% or the high% will not be 255
3394:switcherator.c ****     if (low != 255 && high != 255) {
 3761               		.loc 1 3394 0
 3762 1528 5FEF      		ldi r21,-1
 3763 152a E516      		cp r14,r21
 3764 152c F104      		cpc r15,__zero_reg__
 3765 152e 01F4      		brne .+2
 3766 1530 00C0      		rjmp .L257
3386:switcherator.c ****     high = inputs[inputNumber][2];
 3767               		.loc 1 3386 0 discriminator 1
 3768 1532 F981      		ldd r31,Y+1
 3769 1534 EF2F      		mov r30,r31
 3770               	.LVL265:
 3771 1536 F0E0      		ldi r31,0
 3772 1538 FA87      		std Y+10,r31
 3773 153a E987      		std Y+9,r30
 3774               		.loc 1 3394 0 discriminator 1
 3775 153c EF3F      		cpi r30,-1
 3776 153e F105      		cpc r31,__zero_reg__
 3777 1540 01F4      		brne .+2
 3778 1542 00C0      		rjmp .L257
3384:switcherator.c ****     outputNum = inputs[inputNumber][0];
 3779               		.loc 1 3384 0
 3780 1544 70E0      		ldi r23,0
3395:switcherator.c ****         // this is an analog input
3396:switcherator.c ****         // currently only port C is supported for analog inputs
3397:switcherator.c ****         temp = outputNum - 32;
 3781               		.loc 1 3397 0
 3782 1546 6052      		subi r22,32
 3783 1548 7109      		sbc r23,__zero_reg__
 3784               	.LVL266:
 3785 154a CB01      		movw r24,r22
 3786 154c A0E0      		ldi r26,0
 3787 154e B0E0      		ldi r27,0
 3788               	.LVL267:
3398:switcherator.c ****         temp = temp / 2;
 3789               		.loc 1 3398 0
 3790 1550 B595      		asr r27
 3791 1552 A795      		ror r26
 3792 1554 9795      		ror r25
 3793 1556 8795      		ror r24
 3794               	.LVL268:
3399:switcherator.c ****         if (temp > 7) // if things got goofed up somehow 
 3795               		.loc 1 3399 0
 3796 1558 8830      		cpi r24,8
 3797 155a 9105      		cpc r25,__zero_reg__
 3798 155c A105      		cpc r26,__zero_reg__
 3799 155e B105      		cpc r27,__zero_reg__
 3800 1560 04F0      		brlt .+2
 3801 1562 00C0      		rjmp .L256
3400:switcherator.c ****             return;
3401:switcherator.c ****         ADMUX = temp; // which pin to check
 3802               		.loc 1 3401 0
 3803 1564 8093 7C00 		sts 124,r24
3402:switcherator.c ****         ADCSRA |= (1 << ADEN) | (1 << ADSC); // turn on ADC and start a conversion
 3804               		.loc 1 3402 0
 3805 1568 8091 7A00 		lds r24,122
 3806               	.LVL269:
 3807 156c 806C      		ori r24,lo8(-64)
 3808 156e 8093 7A00 		sts 122,r24
 3809               	.L260:
3403:switcherator.c ****         loop_until_bit_is_set(ADCSRA, ADIF);
 3810               		.loc 1 3403 0 discriminator 1
 3811 1572 8091 7A00 		lds r24,122
 3812 1576 84FF      		sbrs r24,4
 3813 1578 00C0      		rjmp .L260
3404:switcherator.c ****         temp = ADC;
 3814               		.loc 1 3404 0
 3815 157a 2091 7800 		lds r18,120
 3816 157e 3091 7900 		lds r19,120+1
 3817               	.LVL270:
3405:switcherator.c ****         temp = temp * 255;
 3818               		.loc 1 3405 0
 3819 1582 AFEF      		ldi r26,lo8(-1)
 3820 1584 B0E0      		ldi r27,0
 3821 1586 0E94 0000 		call __umulhisi3
 3822               	.LVL271:
3406:switcherator.c ****         temp = temp / 1024; // now its a number between 0 and 255;
 3823               		.loc 1 3406 0
 3824 158a 2AE0      		ldi r18,10
 3825               		1:
 3826 158c 9595      		asr r25
 3827 158e 8795      		ror r24
 3828 1590 7795      		ror r23
 3829 1592 6795      		ror r22
 3830 1594 2A95      		dec r18
 3831 1596 01F4      		brne 1b
 3832               	.LVL272:
3407:switcherator.c ****         ADCSRA |= (1 << ADIF); // clear the ADC
 3833               		.loc 1 3407 0
 3834 1598 2091 7A00 		lds r18,122
 3835 159c 2061      		ori r18,lo8(16)
 3836 159e 2093 7A00 		sts 122,r18
3408:switcherator.c ****         // see if we are turning on the switch
3409:switcherator.c ****         if (temp > low && temp < (high + 1)) {
 3837               		.loc 1 3409 0
 3838 15a2 4C2C      		mov r4,r12
 3839 15a4 512C      		mov r5,__zero_reg__
 3840 15a6 612C      		mov r6,__zero_reg__
 3841 15a8 712C      		mov r7,__zero_reg__
 3842 15aa 4616      		cp r4,r22
 3843 15ac 5706      		cpc r5,r23
 3844 15ae 6806      		cpc r6,r24
 3845 15b0 7906      		cpc r7,r25
 3846 15b2 04F0      		brlt .+2
 3847 15b4 00C0      		rjmp .L256
 3848               		.loc 1 3409 0 is_stmt 0 discriminator 1
 3849 15b6 A985      		ldd r26,Y+9
 3850 15b8 BA85      		ldd r27,Y+10
 3851 15ba 1196      		adiw r26,1
 3852 15bc 9D01      		movw r18,r26
 3853 15be 40E0      		ldi r20,0
 3854 15c0 50E0      		ldi r21,0
 3855               	.LVL273:
 3856 15c2 6217      		cp r22,r18
 3857 15c4 7307      		cpc r23,r19
 3858 15c6 8407      		cpc r24,r20
 3859 15c8 9507      		cpc r25,r21
 3860 15ca 04F0      		brlt .+2
 3861 15cc 00C0      		rjmp .L256
3410:switcherator.c ****             // see if it is a PWM switch (not a program)
3411:switcherator.c ****             if (switchNumber < 128 && switchStuff[switchNumber] == 200) {
 3862               		.loc 1 3411 0 is_stmt 1
 3863 15ce 0038      		cpi r16,-128
 3864 15d0 1105      		cpc r17,__zero_reg__
 3865 15d2 00F4      		brsh .L262
 3866               		.loc 1 3411 0 is_stmt 0 discriminator 1
 3867 15d4 F801      		movw r30,r16
 3868               	.LVL274:
 3869 15d6 E050      		subi r30,lo8(-(switchStuff))
 3870 15d8 F040      		sbci r31,hi8(-(switchStuff))
 3871 15da 2081      		ld r18,Z
 3872 15dc 283C      		cpi r18,lo8(-56)
 3873 15de 01F0      		breq .+2
 3874 15e0 00C0      		rjmp .L293
3412:switcherator.c ****                 // this is a PWM so we're doing it based on the relative ADC value
3413:switcherator.c ****                 // see if we are using the whole range.
3414:switcherator.c ****                 if ((high - low) > 250) {
 3875               		.loc 1 3414 0 is_stmt 1
 3876 15e2 4985      		ldd r20,Y+9
 3877 15e4 5A85      		ldd r21,Y+10
 3878 15e6 4E19      		sub r20,r14
 3879 15e8 5F09      		sbc r21,r15
 3880 15ea 4B3F      		cpi r20,-5
 3881 15ec 5105      		cpc r21,__zero_reg__
 3882 15ee 00F0      		brlo .+2
 3883 15f0 00C0      		rjmp .L293
 3884               	.LVL275:
 3885               	.LBB23:
3415:switcherator.c ****                     pwmValue = temp;
3416:switcherator.c ****                 } else {
3417:switcherator.c ****                     // figure out what percentage between the values we are
3418:switcherator.c ****                     char range = high - low;
3419:switcherator.c ****                     temp = temp - low;
 3886               		.loc 1 3419 0
 3887 15f2 9B01      		movw r18,r22
 3888 15f4 AC01      		movw r20,r24
 3889 15f6 2419      		sub r18,r4
 3890 15f8 3509      		sbc r19,r5
 3891 15fa 4609      		sbc r20,r6
 3892 15fc 5709      		sbc r21,r7
 3893               	.LVL276:
3420:switcherator.c ****                     temp = temp * 255;
 3894               		.loc 1 3420 0
 3895 15fe AFEF      		ldi r26,lo8(-1)
 3896 1600 B0E0      		ldi r27,0
 3897 1602 0E94 0000 		call __muluhisi3
 3898               	.LVL277:
3418:switcherator.c ****                     char range = high - low;
 3899               		.loc 1 3418 0
 3900 1606 2981      		ldd r18,Y+1
 3901 1608 2C19      		sub r18,r12
 3902               	.LVL278:
3421:switcherator.c ****                     temp = temp / range; // now we have a relative value between 0&255
 3903               		.loc 1 3421 0
 3904 160a 30E0      		ldi r19,0
 3905 160c 40E0      		ldi r20,0
 3906 160e 50E0      		ldi r21,0
 3907 1610 0E94 0000 		call __divmodsi4
 3908               	.LVL279:
3422:switcherator.c ****                     pwmValue = temp;
 3909               		.loc 1 3422 0
 3910 1614 822F      		mov r24,r18
 3911               	.LVL280:
3423:switcherator.c ****                     // see if we are changing RGB
3424:switcherator.c ****                     if (whichRGB & 4)
 3912               		.loc 1 3424 0
 3913 1616 D2FC      		sbrc r13,2
3425:switcherator.c ****                         pwmValues[0] = pwmValue;
 3914               		.loc 1 3425 0
 3915 1618 2093 0000 		sts pwmValues,r18
 3916               	.L264:
3426:switcherator.c ****                     if (whichRGB & 2)
 3917               		.loc 1 3426 0
 3918 161c D1FC      		sbrc r13,1
3427:switcherator.c ****                         pwmValues[1] = pwmValue;
 3919               		.loc 1 3427 0
 3920 161e 8093 0000 		sts pwmValues+1,r24
 3921               	.L265:
3428:switcherator.c ****                     if (whichRGB & 1)
 3922               		.loc 1 3428 0
 3923 1622 D0FC      		sbrc r13,0
3429:switcherator.c ****                         pwmValues[2] = pwmValue;
 3924               		.loc 1 3429 0
 3925 1624 8093 0000 		sts pwmValues+2,r24
 3926               	.L266:
3430:switcherator.c ****                     if (whichRGB & 7) // if anything changed
 3927               		.loc 1 3430 0
 3928 1628 8D2D      		mov r24,r13
 3929 162a 8770      		andi r24,lo8(7)
 3930 162c 01F4      		brne .+2
 3931 162e 00C0      		rjmp .L293
3431:switcherator.c ****                         switchChanged = 1;
 3932               		.loc 1 3431 0
 3933 1630 81E0      		ldi r24,lo8(1)
 3934 1632 8093 0000 		sts switchChanged,r24
 3935 1636 00C0      		rjmp .L293
 3936               	.LVL281:
 3937               	.L262:
 3938 1638 E0E0      		ldi r30,lo8(timeLimits+8)
 3939 163a F0E0      		ldi r31,hi8(timeLimits+8)
 3940               	.LVL282:
 3941               	.LBE23:
3371:switcherator.c **** void getInput(int inputNumber) {
 3942               		.loc 1 3371 0
 3943 163c 20E0      		ldi r18,0
 3944               	.LVL283:
 3945               	.L269:
3432:switcherator.c ****                 }
3433:switcherator.c ****             }
3434:switcherator.c ****             // k we set up PWM now make it so it switches on
3435:switcherator.c ****             if (switchNumber < 128) { // its a switch
3436:switcherator.c ****                 if (switchStatus[switchNumber] == 0) // the switch is off
3437:switcherator.c ****                     switchChanged = 1;
3438:switcherator.c ****                 if (switchStatus[switchNumber] < (weeklySeconds + duration))
3439:switcherator.c ****                     switchStatus[switchNumber] = (weeklySeconds + duration);
3440:switcherator.c ****             } else { // its a program;
3441:switcherator.c ****                 test = 0;
3442:switcherator.c ****                 // check and make sure we are within the time limits (eg dusk to dawn)
3443:switcherator.c ****                 // first if no time limits set up then ignore it
3444:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
3445:switcherator.c ****                     if (timeLimits[x][2] > 0)
 3946               		.loc 1 3445 0
 3947 163e 8081      		ld r24,Z
 3948 1640 9181      		ldd r25,Z+1
 3949 1642 A281      		ldd r26,Z+2
 3950 1644 B381      		ldd r27,Z+3
 3951 1646 892B      		or r24,r25
 3952 1648 8A2B      		or r24,r26
 3953 164a 8B2B      		or r24,r27
 3954 164c 01F0      		breq .L268
3446:switcherator.c ****                         test = 1;
 3955               		.loc 1 3446 0
 3956 164e 21E0      		ldi r18,lo8(1)
 3957               	.L268:
 3958               	.LVL284:
 3959 1650 3C96      		adiw r30,12
3444:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
 3960               		.loc 1 3444 0
 3961 1652 30E0      		ldi r19,hi8(timeLimits+56)
 3962 1654 E030      		cpi r30,lo8(timeLimits+56)
 3963 1656 F307      		cpc r31,r19
 3964 1658 01F4      		brne .L269
3447:switcherator.c ****                 }
3448:switcherator.c ****                 // no limits set up
3449:switcherator.c ****                 if (test == 0)
 3965               		.loc 1 3449 0
 3966 165a 2111      		cpse r18,__zero_reg__
 3967 165c 00C0      		rjmp .L270
3450:switcherator.c ****                     startTheProgram((switchNumber - 128), duration, 0);
 3968               		.loc 1 3450 0
 3969 165e 20E0      		ldi r18,0
 3970 1660 30E0      		ldi r19,0
 3971 1662 A901      		movw r20,r18
 3972               	.LVL285:
 3973 1664 6B85      		ldd r22,Y+11
 3974 1666 7C85      		ldd r23,Y+12
 3975               	.LVL286:
 3976 1668 C801      		movw r24,r16
 3977 166a 8058      		subi r24,-128
 3978 166c 9109      		sbc r25,__zero_reg__
 3979 166e 0E94 0000 		call startTheProgram
 3980               	.LVL287:
 3981               	.L270:
 3982 1672 80E0      		ldi r24,lo8(timeLimits)
 3983 1674 E82E      		mov r14,r24
 3984 1676 80E0      		ldi r24,hi8(timeLimits)
 3985 1678 F82E      		mov r15,r24
 3986               	.LVL288:
3451:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
3452:switcherator.c ****                     startTime = timeLimits[x][0];
3453:switcherator.c ****                     stopTime = timeLimits[x][1];
3454:switcherator.c ****                     // deal with nights that cross midnight
3455:switcherator.c ****                     if (stopTime < startTime) {
3456:switcherator.c ****                         temp = dow;
3457:switcherator.c ****                         // weekly seconds resets at the end of the week. so do lots of 9
3458:switcherator.c ****                         if (weeklySeconds <= (stopTime + daySeconds)) {
3459:switcherator.c ****                             // k this is dow + 1
3460:switcherator.c ****                             if (temp == 0)
3461:switcherator.c ****                                 temp = 6;
3462:switcherator.c ****                             else
3463:switcherator.c ****                                 temp--;
3464:switcherator.c ****                             if (timeLimits[x][2] & (1 << temp))
3465:switcherator.c ****                                 startTheProgram((switchNumber - 128), duration, 0);
3466:switcherator.c ****                         } else if (weeklySeconds >= (startTime + daySeconds)) {
3467:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
3468:switcherator.c ****                                 startTheProgram((switchNumber - 128), duration, 0);
3469:switcherator.c ****                         }
3470:switcherator.c ****                     } else {
3471:switcherator.c ****                         if (weeklySeconds >= (startTime + daySeconds) &&
3472:switcherator.c ****                                 weeklySeconds <= (stopTime + daySeconds)) {
3473:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
 3987               		.loc 1 3473 0 discriminator 1
 3988 167a CC24      		clr r12
 3989 167c C394      		inc r12
 3990 167e D12C      		mov r13,__zero_reg__
3474:switcherator.c ****                                 startTheProgram((switchNumber - 128), duration, 0);
 3991               		.loc 1 3474 0 discriminator 1
 3992 1680 0058      		subi r16,-128
 3993 1682 1109      		sbc r17,__zero_reg__
 3994               	.LVL289:
 3995               	.L275:
3452:switcherator.c ****                     startTime = timeLimits[x][0];
 3996               		.loc 1 3452 0
 3997 1684 D701      		movw r26,r14
 3998 1686 4D90      		ld r4,X+
 3999 1688 5D90      		ld r5,X+
 4000 168a 6D90      		ld r6,X+
 4001 168c 7C90      		ld r7,X
 4002 168e 1397      		sbiw r26,3
 4003               	.LVL290:
3453:switcherator.c ****                     stopTime = timeLimits[x][1];
 4004               		.loc 1 3453 0
 4005 1690 1496      		adiw r26,4
 4006 1692 4D91      		ld r20,X+
 4007 1694 5D91      		ld r21,X+
 4008 1696 6D91      		ld r22,X+
 4009 1698 7C91      		ld r23,X
 4010 169a 1797      		sbiw r26,4+3
 4011               	.LVL291:
 4012 169c 8091 0000 		lds r24,weeklySeconds
 4013 16a0 9091 0000 		lds r25,weeklySeconds+1
 4014 16a4 A091 0000 		lds r26,weeklySeconds+2
 4015 16a8 B091 0000 		lds r27,weeklySeconds+3
3455:switcherator.c ****                     if (stopTime < startTime) {
 4016               		.loc 1 3455 0
 4017 16ac 4415      		cp r20,r4
 4018 16ae 5505      		cpc r21,r5
 4019 16b0 6605      		cpc r22,r6
 4020 16b2 7705      		cpc r23,r7
 4021 16b4 04F0      		brlt .+2
 4022 16b6 00C0      		rjmp .L271
3456:switcherator.c ****                         temp = dow;
 4023               		.loc 1 3456 0
 4024 16b8 2091 0000 		lds r18,dow
 4025 16bc 3091 0000 		lds r19,dow+1
 4026               	.LVL292:
3458:switcherator.c ****                         if (weeklySeconds <= (stopTime + daySeconds)) {
 4027               		.loc 1 3458 0
 4028 16c0 480D      		add r20,r8
 4029 16c2 591D      		adc r21,r9
 4030 16c4 6A1D      		adc r22,r10
 4031 16c6 7B1D      		adc r23,r11
 4032               	.LVL293:
 4033 16c8 4817      		cp r20,r24
 4034 16ca 5907      		cpc r21,r25
 4035 16cc 6A07      		cpc r22,r26
 4036 16ce 7B07      		cpc r23,r27
 4037 16d0 00F0      		brlo .L272
3456:switcherator.c ****                         temp = dow;
 4038               		.loc 1 3456 0
 4039 16d2 C901      		movw r24,r18
 4040 16d4 A0E0      		ldi r26,0
 4041 16d6 B0E0      		ldi r27,0
3460:switcherator.c ****                             if (temp == 0)
 4042               		.loc 1 3460 0
 4043 16d8 0097      		sbiw r24,0
 4044 16da A105      		cpc r26,__zero_reg__
 4045 16dc B105      		cpc r27,__zero_reg__
 4046 16de 01F0      		breq .L295
3463:switcherator.c ****                                 temp--;
 4047               		.loc 1 3463 0
 4048 16e0 0197      		sbiw r24,1
 4049 16e2 A109      		sbc r26,__zero_reg__
 4050 16e4 B109      		sbc r27,__zero_reg__
 4051               	.LVL294:
 4052 16e6 00C0      		rjmp .L273
 4053               	.LVL295:
 4054               	.L295:
3461:switcherator.c ****                                 temp = 6;
 4055               		.loc 1 3461 0
 4056 16e8 86E0      		ldi r24,lo8(6)
 4057 16ea 90E0      		ldi r25,0
 4058 16ec A0E0      		ldi r26,0
 4059 16ee B0E0      		ldi r27,0
 4060               	.LVL296:
 4061               	.L273:
3464:switcherator.c ****                             if (timeLimits[x][2] & (1 << temp))
 4062               		.loc 1 3464 0
 4063 16f0 9601      		movw r18,r12
 4064 16f2 00C0      		rjmp 2f
 4065               		1:
 4066 16f4 220F      		lsl r18
 4067 16f6 331F      		rol r19
 4068               		2:
 4069 16f8 8A95      		dec r24
 4070 16fa 02F4      		brpl 1b
 4071 16fc A901      		movw r20,r18
 4072 16fe 6627      		clr r22
 4073 1700 57FD      		sbrc r21,7
 4074 1702 6095      		com r22
 4075 1704 762F      		mov r23,r22
 4076 1706 F701      		movw r30,r14
 4077 1708 8085      		ldd r24,Z+8
 4078 170a 9185      		ldd r25,Z+9
 4079 170c A285      		ldd r26,Z+10
 4080 170e B385      		ldd r27,Z+11
 4081 1710 4823      		and r20,r24
 4082 1712 5923      		and r21,r25
 4083 1714 6A23      		and r22,r26
 4084 1716 7B23      		and r23,r27
 4085 1718 452B      		or r20,r21
 4086 171a 462B      		or r20,r22
 4087 171c 472B      		or r20,r23
 4088 171e 01F4      		brne .+2
 4089 1720 00C0      		rjmp .L274
 4090 1722 00C0      		rjmp .L347
 4091               	.LVL297:
 4092               	.L272:
3466:switcherator.c ****                         } else if (weeklySeconds >= (startTime + daySeconds)) {
 4093               		.loc 1 3466 0
 4094 1724 480C      		add r4,r8
 4095 1726 591C      		adc r5,r9
 4096 1728 6A1C      		adc r6,r10
 4097 172a 7B1C      		adc r7,r11
 4098               	.LVL298:
 4099 172c 8415      		cp r24,r4
 4100 172e 9505      		cpc r25,r5
 4101 1730 A605      		cpc r26,r6
 4102 1732 B705      		cpc r27,r7
 4103 1734 00F0      		brlo .L274
3467:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
 4104               		.loc 1 3467 0
 4105 1736 C601      		movw r24,r12
 4106 1738 00C0      		rjmp 2f
 4107               		1:
 4108 173a 880F      		lsl r24
 4109 173c 991F      		rol r25
 4110               		2:
 4111 173e 2A95      		dec r18
 4112 1740 02F4      		brpl 1b
 4113 1742 00C0      		rjmp .L351
 4114               	.LVL299:
 4115               	.L271:
3471:switcherator.c ****                         if (weeklySeconds >= (startTime + daySeconds) &&
 4116               		.loc 1 3471 0
 4117 1744 480C      		add r4,r8
 4118 1746 591C      		adc r5,r9
 4119 1748 6A1C      		adc r6,r10
 4120 174a 7B1C      		adc r7,r11
 4121               	.LVL300:
 4122 174c 8415      		cp r24,r4
 4123 174e 9505      		cpc r25,r5
 4124 1750 A605      		cpc r26,r6
 4125 1752 B705      		cpc r27,r7
 4126 1754 00F0      		brlo .L274
3472:switcherator.c ****                                 weeklySeconds <= (stopTime + daySeconds)) {
 4127               		.loc 1 3472 0 discriminator 1
 4128 1756 480D      		add r20,r8
 4129 1758 591D      		adc r21,r9
 4130 175a 6A1D      		adc r22,r10
 4131 175c 7B1D      		adc r23,r11
 4132               	.LVL301:
3471:switcherator.c ****                         if (weeklySeconds >= (startTime + daySeconds) &&
 4133               		.loc 1 3471 0 discriminator 1
 4134 175e 4817      		cp r20,r24
 4135 1760 5907      		cpc r21,r25
 4136 1762 6A07      		cpc r22,r26
 4137 1764 7B07      		cpc r23,r27
 4138 1766 00F0      		brlo .L274
3473:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
 4139               		.loc 1 3473 0
 4140 1768 C601      		movw r24,r12
 4141 176a 0090 0000 		lds r0,dow
 4142 176e 00C0      		rjmp 2f
 4143               		1:
 4144 1770 880F      		lsl r24
 4145 1772 991F      		rol r25
 4146               		2:
 4147 1774 0A94      		dec r0
 4148 1776 02F4      		brpl 1b
 4149               	.L351:
 4150 1778 AA27      		clr r26
 4151 177a 97FD      		sbrc r25,7
 4152 177c A095      		com r26
 4153 177e BA2F      		mov r27,r26
 4154 1780 F701      		movw r30,r14
 4155 1782 4085      		ldd r20,Z+8
 4156 1784 5185      		ldd r21,Z+9
 4157 1786 6285      		ldd r22,Z+10
 4158 1788 7385      		ldd r23,Z+11
 4159 178a 8423      		and r24,r20
 4160 178c 9523      		and r25,r21
 4161 178e A623      		and r26,r22
 4162 1790 B723      		and r27,r23
 4163 1792 892B      		or r24,r25
 4164 1794 8A2B      		or r24,r26
 4165 1796 8B2B      		or r24,r27
 4166 1798 01F0      		breq .L274
 4167               	.L347:
 4168               		.loc 1 3474 0
 4169 179a 20E0      		ldi r18,0
 4170 179c 30E0      		ldi r19,0
 4171 179e A901      		movw r20,r18
 4172 17a0 6B85      		ldd r22,Y+11
 4173 17a2 7C85      		ldd r23,Y+12
 4174 17a4 C801      		movw r24,r16
 4175 17a6 0E94 0000 		call startTheProgram
 4176               	.LVL302:
 4177               	.L274:
 4178 17aa FCE0      		ldi r31,12
 4179 17ac EF0E      		add r14,r31
 4180 17ae F11C      		adc r15,__zero_reg__
3451:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
 4181               		.loc 1 3451 0
 4182 17b0 20E0      		ldi r18,lo8(timeLimits+48)
 4183 17b2 E216      		cp r14,r18
 4184 17b4 20E0      		ldi r18,hi8(timeLimits+48)
 4185 17b6 F206      		cpc r15,r18
 4186 17b8 01F0      		breq .+2
 4187 17ba 00C0      		rjmp .L275
 4188 17bc 00C0      		rjmp .L256
 4189               	.LVL303:
 4190               	.L257:
 4191               	.LBB24:
3475:switcherator.c ****                         }
3476:switcherator.c ****                     }
3477:switcherator.c ****                 } // end of the for
3478:switcherator.c ****             }
3479:switcherator.c ****         }
3480:switcherator.c **** 
3481:switcherator.c ****     } else {
3482:switcherator.c ****         // this is a digital input
3483:switcherator.c ****         // value of 255 (default) means nothing programmed
3484:switcherator.c ****         // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
3485:switcherator.c ****         // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG        
3486:switcherator.c ****         // figure out what we are dealing with and check it.
3487:switcherator.c ****         temp = outputNum;
 4192               		.loc 1 3487 0
 4193 17be 862F      		mov r24,r22
 4194 17c0 90E0      		ldi r25,0
 4195 17c2 A0E0      		ldi r26,0
 4196 17c4 B0E0      		ldi r27,0
 4197               	.LVL304:
3488:switcherator.c ****         if (temp > 15 && temp < 32) {
 4198               		.loc 1 3488 0
 4199 17c6 AC01      		movw r20,r24
 4200 17c8 BD01      		movw r22,r26
 4201               	.LVL305:
 4202 17ca 4051      		subi r20,16
 4203 17cc 5109      		sbc r21,__zero_reg__
 4204 17ce 6109      		sbc r22,__zero_reg__
 4205 17d0 7109      		sbc r23,__zero_reg__
 4206 17d2 4031      		cpi r20,16
 4207 17d4 5105      		cpc r21,__zero_reg__
 4208 17d6 6105      		cpc r22,__zero_reg__
 4209 17d8 7105      		cpc r23,__zero_reg__
 4210 17da 00F4      		brsh .L276
 4211               	.LVL306:
3489:switcherator.c ****             thisPin = &PINB;
3490:switcherator.c ****             temp -= 16;
 4212               		.loc 1 3490 0
 4213 17dc CB01      		movw r24,r22
 4214 17de BA01      		movw r22,r20
 4215               	.LVL307:
3489:switcherator.c ****             thisPin = &PINB;
 4216               		.loc 1 3489 0
 4217 17e0 B3E2      		ldi r27,lo8(35)
 4218 17e2 CB2E      		mov r12,r27
 4219 17e4 D12C      		mov r13,__zero_reg__
 4220 17e6 00C0      		rjmp .L277
 4221               	.LVL308:
 4222               	.L276:
3491:switcherator.c **** #ifdef PINA
3492:switcherator.c ****         } else if (temp < 16) {
3493:switcherator.c ****             thisPin = &PINA;
3494:switcherator.c ****             temp -= 0;
3495:switcherator.c **** #endif
3496:switcherator.c **** #ifdef PINC
3497:switcherator.c ****         } else if (temp < 48) {
 4223               		.loc 1 3497 0
 4224 17e8 8033      		cpi r24,48
 4225 17ea 9105      		cpc r25,__zero_reg__
 4226 17ec A105      		cpc r26,__zero_reg__
 4227 17ee B105      		cpc r27,__zero_reg__
 4228 17f0 04F4      		brge .L278
 4229               	.LVL309:
3498:switcherator.c ****             thisPin = &PINC;
3499:switcherator.c ****             temp -= 32;
 4230               		.loc 1 3499 0
 4231 17f2 BC01      		movw r22,r24
 4232 17f4 CD01      		movw r24,r26
 4233               	.LVL310:
 4234 17f6 6052      		subi r22,32
 4235 17f8 7109      		sbc r23,__zero_reg__
 4236 17fa 8109      		sbc r24,__zero_reg__
 4237 17fc 9109      		sbc r25,__zero_reg__
 4238               	.LVL311:
3498:switcherator.c ****             thisPin = &PINC;
 4239               		.loc 1 3498 0
 4240 17fe A6E2      		ldi r26,lo8(38)
 4241 1800 CA2E      		mov r12,r26
 4242 1802 D12C      		mov r13,__zero_reg__
 4243 1804 00C0      		rjmp .L277
 4244               	.LVL312:
 4245               	.L278:
3500:switcherator.c **** #endif
3501:switcherator.c **** #ifdef PIND
3502:switcherator.c ****         } else if (temp < 64) {
 4246               		.loc 1 3502 0
 4247 1806 8034      		cpi r24,64
 4248 1808 9105      		cpc r25,__zero_reg__
 4249 180a A105      		cpc r26,__zero_reg__
 4250 180c B105      		cpc r27,__zero_reg__
 4251 180e 04F0      		brlt .+2
 4252 1810 00C0      		rjmp .L256
 4253               	.LVL313:
3503:switcherator.c ****             thisPin = &PIND;
3504:switcherator.c ****             temp -= 48;
 4254               		.loc 1 3504 0
 4255 1812 BC01      		movw r22,r24
 4256 1814 CD01      		movw r24,r26
 4257               	.LVL314:
 4258 1816 6053      		subi r22,48
 4259 1818 7109      		sbc r23,__zero_reg__
 4260 181a 8109      		sbc r24,__zero_reg__
 4261 181c 9109      		sbc r25,__zero_reg__
 4262               	.LVL315:
3503:switcherator.c ****             thisPin = &PIND;
 4263               		.loc 1 3503 0
 4264 181e F9E2      		ldi r31,lo8(41)
 4265 1820 CF2E      		mov r12,r31
 4266 1822 D12C      		mov r13,__zero_reg__
 4267               	.LVL316:
 4268               	.L277:
3505:switcherator.c **** #endif
3506:switcherator.c **** #ifdef PINE
3507:switcherator.c ****         } else if (temp < 80) {
3508:switcherator.c ****             thisPin = &PINE;
3509:switcherator.c ****             temp -= 64;
3510:switcherator.c **** #endif
3511:switcherator.c **** #ifdef PINF
3512:switcherator.c ****         } else if (temp < 96) {
3513:switcherator.c ****             thisPin = &PINF;
3514:switcherator.c ****             temp -= 80;
3515:switcherator.c **** #endif
3516:switcherator.c **** #ifdef PING
3517:switcherator.c ****         } else if (temp < 112) {
3518:switcherator.c ****             thisPin = &PING;
3519:switcherator.c ****             temp -= 96;
3520:switcherator.c **** #endif
3521:switcherator.c **** #ifdef PINH
3522:switcherator.c ****         } else if (temp < 128) {
3523:switcherator.c ****             thisPin = &PINH;
3524:switcherator.c ****             temp -= 112;
3525:switcherator.c **** #endif
3526:switcherator.c **** #ifdef PINI
3527:switcherator.c ****         } else if (temp < 144) {
3528:switcherator.c ****             thisPin = &PINI;
3529:switcherator.c ****             temp -= 128;
3530:switcherator.c **** #endif
3531:switcherator.c ****         } else {
3532:switcherator.c ****             // something went wrong.  Who cares.
3533:switcherator.c ****             return;
3534:switcherator.c ****         }
3535:switcherator.c ****         // if we want the input to be high then low = 0.  If we want it to be 
3536:switcherator.c ****         // low to be on then low = 255;
3537:switcherator.c ****         temp = temp / 2;
 4269               		.loc 1 3537 0
 4270 1824 22E0      		ldi r18,lo8(2)
 4271 1826 30E0      		ldi r19,0
 4272 1828 40E0      		ldi r20,0
 4273 182a 50E0      		ldi r21,0
 4274 182c 0E94 0000 		call __divmodsi4
 4275               	.LVL317:
3538:switcherator.c ****         if (temp > 7) {
 4276               		.loc 1 3538 0
 4277 1830 2830      		cpi r18,8
 4278 1832 3105      		cpc r19,__zero_reg__
 4279 1834 4105      		cpc r20,__zero_reg__
 4280 1836 5105      		cpc r21,__zero_reg__
 4281 1838 04F0      		brlt .+2
 4282 183a 00C0      		rjmp .L256
3539:switcherator.c ****             return; // something wrong again
3540:switcherator.c ****         }
3541:switcherator.c ****         int pinsOn = *thisPin;
 4283               		.loc 1 3541 0
 4284 183c D601      		movw r26,r12
 4285 183e 8C91      		ld r24,X
 4286               	.LVL318:
 4287 1840 90E0      		ldi r25,0
3542:switcherator.c ****         char yeaOurInputIsOn = 0;
3543:switcherator.c ****         if (pinsOn & (1 << temp)) {
 4288               		.loc 1 3543 0
 4289 1842 00C0      		rjmp 2f
 4290               		1:
 4291 1844 9595      		asr r25
 4292 1846 8795      		ror r24
 4293               		2:
 4294 1848 2A95      		dec r18
 4295 184a 02F4      		brpl 1b
 4296               	.LVL319:
 4297 184c 80FF      		sbrs r24,0
 4298 184e 00C0      		rjmp .L279
3544:switcherator.c ****             // pin is high
3545:switcherator.c ****             if (low == 0)
 4299               		.loc 1 3545 0
 4300 1850 EF28      		or r14,r15
 4301 1852 01F4      		brne .+2
 4302 1854 00C0      		rjmp .L280
 4303 1856 00C0      		rjmp .L256
 4304               	.L279:
3546:switcherator.c ****                 yeaOurInputIsOn = 1;
3547:switcherator.c ****         } else {
3548:switcherator.c ****             // pin is low
3549:switcherator.c ****             if (low == 255)
 4305               		.loc 1 3549 0
 4306 1858 BFEF      		ldi r27,-1
 4307 185a EB16      		cp r14,r27
 4308 185c F104      		cpc r15,__zero_reg__
 4309 185e 01F0      		breq .+2
 4310 1860 00C0      		rjmp .L256
 4311 1862 00C0      		rjmp .L280
 4312               	.LVL320:
 4313               	.L293:
3550:switcherator.c ****                 yeaOurInputIsOn = 1;
3551:switcherator.c ****         }
3552:switcherator.c ****         if (yeaOurInputIsOn == 1) {
3553:switcherator.c ****             if (switchNumber < 128) { // this is a switch
3554:switcherator.c ****                 if (switchStatus[switchNumber] == 0) // the switch is off
 4314               		.loc 1 3554 0
 4315 1864 000F      		lsl r16
 4316 1866 111F      		rol r17
 4317 1868 000F      		lsl r16
 4318 186a 111F      		rol r17
 4319               	.LVL321:
 4320 186c F801      		movw r30,r16
 4321 186e E050      		subi r30,lo8(-(switchStatus))
 4322 1870 F040      		sbci r31,hi8(-(switchStatus))
 4323 1872 4081      		ld r20,Z
 4324 1874 5181      		ldd r21,Z+1
 4325 1876 6281      		ldd r22,Z+2
 4326 1878 7381      		ldd r23,Z+3
 4327 187a 4115      		cp r20,__zero_reg__
 4328 187c 5105      		cpc r21,__zero_reg__
 4329 187e 6105      		cpc r22,__zero_reg__
 4330 1880 7105      		cpc r23,__zero_reg__
 4331 1882 01F4      		brne .L281
3555:switcherator.c ****                     switchChanged = 1;
 4332               		.loc 1 3555 0
 4333 1884 81E0      		ldi r24,lo8(1)
 4334 1886 8093 0000 		sts switchChanged,r24
 4335               	.L281:
3556:switcherator.c ****                 if ((switchStatus[switchNumber]) < (weeklySeconds + duration))
 4336               		.loc 1 3556 0
 4337 188a 8091 0000 		lds r24,weeklySeconds
 4338 188e 9091 0000 		lds r25,weeklySeconds+1
 4339 1892 A091 0000 		lds r26,weeklySeconds+2
 4340 1896 B091 0000 		lds r27,weeklySeconds+3
 4341 189a EB85      		ldd r30,Y+11
 4342 189c FC85      		ldd r31,Y+12
 4343 189e 8E0F      		add r24,r30
 4344 18a0 9F1F      		adc r25,r31
 4345 18a2 A11D      		adc r26,__zero_reg__
 4346 18a4 B11D      		adc r27,__zero_reg__
 4347 18a6 4817      		cp r20,r24
 4348 18a8 5907      		cpc r21,r25
 4349 18aa 6A07      		cpc r22,r26
 4350 18ac 7B07      		cpc r23,r27
 4351 18ae 00F0      		brlo .+2
 4352 18b0 00C0      		rjmp .L256
3557:switcherator.c ****                     switchStatus[switchNumber] = (weeklySeconds + duration);
 4353               		.loc 1 3557 0
 4354 18b2 F801      		movw r30,r16
 4355 18b4 E050      		subi r30,lo8(-(switchStatus))
 4356 18b6 F040      		sbci r31,hi8(-(switchStatus))
 4357 18b8 8083      		st Z,r24
 4358 18ba 9183      		std Z+1,r25
 4359 18bc A283      		std Z+2,r26
 4360 18be B383      		std Z+3,r27
 4361 18c0 00C0      		rjmp .L256
 4362               	.LVL322:
 4363               	.L283:
3558:switcherator.c ****             } else { // its a program;
3559:switcherator.c ****                 test = 0;
3560:switcherator.c ****                 // check and make sure we are within the time limits (eg dusk to dawn)
3561:switcherator.c ****                 // first if no time limits set up then ignore it
3562:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
3563:switcherator.c ****                     if (timeLimits[x][2] > 0)
 4364               		.loc 1 3563 0
 4365 18c2 8081      		ld r24,Z
 4366 18c4 9181      		ldd r25,Z+1
 4367 18c6 A281      		ldd r26,Z+2
 4368 18c8 B381      		ldd r27,Z+3
 4369 18ca 892B      		or r24,r25
 4370 18cc 8A2B      		or r24,r26
 4371 18ce 8B2B      		or r24,r27
 4372 18d0 01F0      		breq .L282
3564:switcherator.c ****                         test = 1;
 4373               		.loc 1 3564 0
 4374 18d2 21E0      		ldi r18,lo8(1)
 4375               	.L282:
 4376               	.LVL323:
 4377 18d4 3C96      		adiw r30,12
3562:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
 4378               		.loc 1 3562 0
 4379 18d6 30E0      		ldi r19,hi8(timeLimits+56)
 4380 18d8 E030      		cpi r30,lo8(timeLimits+56)
 4381 18da F307      		cpc r31,r19
 4382 18dc 01F4      		brne .L283
3565:switcherator.c ****                 }
3566:switcherator.c ****                 // no limits set up
3567:switcherator.c ****                 if (test == 0)
 4383               		.loc 1 3567 0
 4384 18de 2111      		cpse r18,__zero_reg__
 4385 18e0 00C0      		rjmp .L284
3568:switcherator.c ****                     startTheProgram((switchNumber - 128), duration, 0);
 4386               		.loc 1 3568 0
 4387 18e2 20E0      		ldi r18,0
 4388 18e4 30E0      		ldi r19,0
 4389 18e6 A901      		movw r20,r18
 4390               	.LVL324:
 4391 18e8 6B85      		ldd r22,Y+11
 4392 18ea 7C85      		ldd r23,Y+12
 4393 18ec C801      		movw r24,r16
 4394 18ee 8058      		subi r24,-128
 4395 18f0 9109      		sbc r25,__zero_reg__
 4396 18f2 0E94 0000 		call startTheProgram
 4397               	.LVL325:
 4398               	.L284:
3569:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
3570:switcherator.c ****                     startTime = timeLimits[x][0];
3571:switcherator.c ****                     stopTime = timeLimits[x][1];
3572:switcherator.c ****                     // deal with nights that cross midnight
3573:switcherator.c ****                     if (stopTime < startTime) {
3574:switcherator.c ****                         temp = dow;
3575:switcherator.c ****                         // weekly seconds resets at the end of the week. so do lots of 9
3576:switcherator.c ****                         if (weeklySeconds <= (stopTime + daySeconds)) {
3577:switcherator.c ****                             // k this is dow + 1
3578:switcherator.c ****                             if (temp == 0)
3579:switcherator.c ****                                 temp = 6;
3580:switcherator.c ****                             else
3581:switcherator.c ****                                 temp--;
 4399               		.loc 1 3581 0 discriminator 1
 4400 18f6 D301      		movw r26,r6
 4401 18f8 C201      		movw r24,r4
 4402 18fa 0197      		sbiw r24,1
 4403 18fc A109      		sbc r26,__zero_reg__
 4404 18fe B109      		sbc r27,__zero_reg__
3582:switcherator.c ****                             if (timeLimits[x][2] & (1 << temp))
 4405               		.loc 1 3582 0 discriminator 1
 4406 1900 4528      		or r4,r5
 4407 1902 4628      		or r4,r6
 4408 1904 4728      		or r4,r7
 4409 1906 01F4      		brne .L285
 4410 1908 76E0      		ldi r23,lo8(6)
 4411 190a 472E      		mov r4,r23
 4412 190c 512C      		mov r5,__zero_reg__
 4413 190e 612C      		mov r6,__zero_reg__
 4414 1910 712C      		mov r7,__zero_reg__
 4415 1912 00C0      		rjmp .L286
 4416               	.L285:
 4417 1914 2C01      		movw r4,r24
 4418 1916 3D01      		movw r6,r26
 4419               	.L286:
 4420 1918 81E0      		ldi r24,lo8(1)
 4421 191a 90E0      		ldi r25,0
 4422 191c AC01      		movw r20,r24
 4423 191e 00C0      		rjmp 2f
 4424               		1:
 4425 1920 440F      		lsl r20
 4426 1922 551F      		rol r21
 4427               		2:
 4428 1924 4A94      		dec r4
 4429 1926 02F4      		brpl 1b
 4430 1928 9A01      		movw r18,r20
 4431 192a 4427      		clr r20
 4432 192c 37FD      		sbrc r19,7
 4433 192e 4095      		com r20
 4434 1930 542F      		mov r21,r20
 4435 1932 2983      		std Y+1,r18
 4436 1934 3A83      		std Y+2,r19
 4437 1936 4B83      		std Y+3,r20
 4438 1938 5C83      		std Y+4,r21
3583:switcherator.c ****                                 startTheProgram((switchNumber - 128), duration, 0);
3584:switcherator.c ****                         } else if (weeklySeconds >= (startTime + daySeconds)) {
3585:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
 4439               		.loc 1 3585 0 discriminator 1
 4440 193a 2C01      		movw r4,r24
 4441 193c 00C0      		rjmp 2f
 4442               		1:
 4443 193e 440C      		lsl r4
 4444 1940 551C      		rol r5
 4445               		2:
 4446 1942 2A94      		dec r2
 4447 1944 02F4      		brpl 1b
 4448 1946 6624      		clr r6
 4449 1948 57FC      		sbrc r5,7
 4450 194a 6094      		com r6
 4451 194c 762C      		mov r7,r6
 4452 194e 60E0      		ldi r22,lo8(timeLimits)
 4453 1950 E62E      		mov r14,r22
 4454 1952 60E0      		ldi r22,hi8(timeLimits)
 4455 1954 F62E      		mov r15,r22
 4456               	.LVL326:
3586:switcherator.c ****                                 startTheProgram((switchNumber - 128), duration, 0);
3587:switcherator.c ****                         }
3588:switcherator.c ****                     } else {
3589:switcherator.c ****                         if (weeklySeconds >= (startTime + daySeconds) &&
3590:switcherator.c ****                                 weeklySeconds <= (stopTime + daySeconds)) {
3591:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
3592:switcherator.c ****                                 startTheProgram((switchNumber - 128), duration, 0);
 4457               		.loc 1 3592 0 discriminator 1
 4458 1956 6801      		movw r12,r16
 4459               	.LVL327:
 4460 1958 30E8      		ldi r19,-128
 4461 195a C31A      		sub r12,r19
 4462 195c D108      		sbc r13,__zero_reg__
 4463               	.LVL328:
 4464               	.L290:
3570:switcherator.c ****                     startTime = timeLimits[x][0];
 4465               		.loc 1 3570 0
 4466 195e D701      		movw r26,r14
 4467 1960 8D91      		ld r24,X+
 4468 1962 9D91      		ld r25,X+
 4469 1964 0D90      		ld __tmp_reg__,X+
 4470 1966 BC91      		ld r27,X
 4471 1968 A02D      		mov r26,__tmp_reg__
 4472 196a 8D83      		std Y+5,r24
 4473 196c 9E83      		std Y+6,r25
 4474 196e AF83      		std Y+7,r26
 4475 1970 B887      		std Y+8,r27
 4476               	.LVL329:
3571:switcherator.c ****                     stopTime = timeLimits[x][1];
 4477               		.loc 1 3571 0
 4478 1972 F701      		movw r30,r14
 4479 1974 4481      		ldd r20,Z+4
 4480 1976 5581      		ldd r21,Z+5
 4481 1978 6681      		ldd r22,Z+6
 4482 197a 7781      		ldd r23,Z+7
 4483               	.LVL330:
 4484 197c 8091 0000 		lds r24,weeklySeconds
 4485 1980 9091 0000 		lds r25,weeklySeconds+1
 4486 1984 A091 0000 		lds r26,weeklySeconds+2
 4487 1988 B091 0000 		lds r27,weeklySeconds+3
 4488               	.LVL331:
3573:switcherator.c ****                     if (stopTime < startTime) {
 4489               		.loc 1 3573 0
 4490 198c 0D81      		ldd r16,Y+5
 4491 198e 1E81      		ldd r17,Y+6
 4492 1990 2F81      		ldd r18,Y+7
 4493 1992 3885      		ldd r19,Y+8
 4494 1994 4017      		cp r20,r16
 4495 1996 5107      		cpc r21,r17
 4496 1998 6207      		cpc r22,r18
 4497 199a 7307      		cpc r23,r19
 4498 199c 04F4      		brge .L287
3576:switcherator.c ****                         if (weeklySeconds <= (stopTime + daySeconds)) {
 4499               		.loc 1 3576 0
 4500 199e 480D      		add r20,r8
 4501 19a0 591D      		adc r21,r9
 4502 19a2 6A1D      		adc r22,r10
 4503 19a4 7B1D      		adc r23,r11
 4504               	.LVL332:
 4505 19a6 4817      		cp r20,r24
 4506 19a8 5907      		cpc r21,r25
 4507 19aa 6A07      		cpc r22,r26
 4508 19ac 7B07      		cpc r23,r27
 4509 19ae 00F0      		brlo .L288
3582:switcherator.c ****                             if (timeLimits[x][2] & (1 << temp))
 4510               		.loc 1 3582 0
 4511 19b0 8085      		ldd r24,Z+8
 4512 19b2 9185      		ldd r25,Z+9
 4513 19b4 A285      		ldd r26,Z+10
 4514 19b6 B385      		ldd r27,Z+11
 4515 19b8 2981      		ldd r18,Y+1
 4516 19ba 3A81      		ldd r19,Y+2
 4517 19bc 4B81      		ldd r20,Y+3
 4518 19be 5C81      		ldd r21,Y+4
 4519 19c0 8223      		and r24,r18
 4520 19c2 9323      		and r25,r19
 4521 19c4 A423      		and r26,r20
 4522 19c6 B523      		and r27,r21
 4523 19c8 00C0      		rjmp .L354
 4524               	.L288:
3584:switcherator.c ****                         } else if (weeklySeconds >= (startTime + daySeconds)) {
 4525               		.loc 1 3584 0
 4526 19ca 4D81      		ldd r20,Y+5
 4527 19cc 5E81      		ldd r21,Y+6
 4528 19ce 6F81      		ldd r22,Y+7
 4529 19d0 7885      		ldd r23,Y+8
 4530 19d2 480D      		add r20,r8
 4531 19d4 591D      		adc r21,r9
 4532 19d6 6A1D      		adc r22,r10
 4533 19d8 7B1D      		adc r23,r11
 4534 19da 8417      		cp r24,r20
 4535 19dc 9507      		cpc r25,r21
 4536 19de A607      		cpc r26,r22
 4537 19e0 B707      		cpc r27,r23
 4538 19e2 00F0      		brlo .L289
 4539 19e4 00C0      		rjmp .L356
 4540               	.LVL333:
 4541               	.L287:
3589:switcherator.c ****                         if (weeklySeconds >= (startTime + daySeconds) &&
 4542               		.loc 1 3589 0
 4543 19e6 0D81      		ldd r16,Y+5
 4544 19e8 1E81      		ldd r17,Y+6
 4545 19ea 2F81      		ldd r18,Y+7
 4546 19ec 3885      		ldd r19,Y+8
 4547 19ee 080D      		add r16,r8
 4548 19f0 191D      		adc r17,r9
 4549 19f2 2A1D      		adc r18,r10
 4550 19f4 3B1D      		adc r19,r11
 4551 19f6 8017      		cp r24,r16
 4552 19f8 9107      		cpc r25,r17
 4553 19fa A207      		cpc r26,r18
 4554 19fc B307      		cpc r27,r19
 4555 19fe 00F0      		brlo .L289
3590:switcherator.c ****                                 weeklySeconds <= (stopTime + daySeconds)) {
 4556               		.loc 1 3590 0 discriminator 1
 4557 1a00 480D      		add r20,r8
 4558 1a02 591D      		adc r21,r9
 4559 1a04 6A1D      		adc r22,r10
 4560 1a06 7B1D      		adc r23,r11
 4561               	.LVL334:
3589:switcherator.c ****                         if (weeklySeconds >= (startTime + daySeconds) &&
 4562               		.loc 1 3589 0 discriminator 1
 4563 1a08 4817      		cp r20,r24
 4564 1a0a 5907      		cpc r21,r25
 4565 1a0c 6A07      		cpc r22,r26
 4566 1a0e 7B07      		cpc r23,r27
 4567 1a10 00F0      		brlo .L289
 4568               	.L356:
3591:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
 4569               		.loc 1 3591 0
 4570 1a12 F701      		movw r30,r14
 4571 1a14 8085      		ldd r24,Z+8
 4572 1a16 9185      		ldd r25,Z+9
 4573 1a18 A285      		ldd r26,Z+10
 4574 1a1a B385      		ldd r27,Z+11
 4575 1a1c 8421      		and r24,r4
 4576 1a1e 9521      		and r25,r5
 4577 1a20 A621      		and r26,r6
 4578 1a22 B721      		and r27,r7
 4579               	.L354:
 4580 1a24 892B      		or r24,r25
 4581 1a26 8A2B      		or r24,r26
 4582 1a28 8B2B      		or r24,r27
 4583 1a2a 01F0      		breq .L289
 4584               		.loc 1 3592 0
 4585 1a2c 20E0      		ldi r18,0
 4586 1a2e 30E0      		ldi r19,0
 4587 1a30 A901      		movw r20,r18
 4588 1a32 6B85      		ldd r22,Y+11
 4589 1a34 7C85      		ldd r23,Y+12
 4590 1a36 C601      		movw r24,r12
 4591 1a38 0E94 0000 		call startTheProgram
 4592               	.LVL335:
 4593               	.L289:
 4594 1a3c FCE0      		ldi r31,12
 4595 1a3e EF0E      		add r14,r31
 4596 1a40 F11C      		adc r15,__zero_reg__
3569:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
 4597               		.loc 1 3569 0
 4598 1a42 00E0      		ldi r16,lo8(timeLimits+48)
 4599 1a44 E016      		cp r14,r16
 4600 1a46 00E0      		ldi r16,hi8(timeLimits+48)
 4601 1a48 F006      		cpc r15,r16
 4602 1a4a 01F0      		breq .+2
 4603 1a4c 00C0      		rjmp .L290
 4604 1a4e 00C0      		rjmp .L256
 4605               	.LVL336:
 4606               	.L280:
3553:switcherator.c ****             if (switchNumber < 128) { // this is a switch
 4607               		.loc 1 3553 0
 4608 1a50 0038      		cpi r16,-128
 4609 1a52 1105      		cpc r17,__zero_reg__
 4610 1a54 00F4      		brsh .+2
 4611 1a56 00C0      		rjmp .L293
 4612 1a58 E0E0      		ldi r30,lo8(timeLimits+8)
 4613 1a5a F0E0      		ldi r31,hi8(timeLimits+8)
3371:switcherator.c **** void getInput(int inputNumber) {
 4614               		.loc 1 3371 0
 4615 1a5c 20E0      		ldi r18,0
 4616               	.LVL337:
 4617 1a5e 00C0      		rjmp .L283
 4618               	.LVL338:
 4619               	.L256:
 4620               	/* epilogue start */
 4621               	.LBE24:
3593:switcherator.c ****                         }
3594:switcherator.c ****                     }
3595:switcherator.c ****                 } // end of the for
3596:switcherator.c ****             }
3597:switcherator.c ****         }
3598:switcherator.c ****     }
3599:switcherator.c **** }
 4622               		.loc 1 3599 0
 4623 1a60 2C96      		adiw r28,12
 4624 1a62 0FB6      		in __tmp_reg__,__SREG__
 4625 1a64 F894      		cli
 4626 1a66 DEBF      		out __SP_H__,r29
 4627 1a68 0FBE      		out __SREG__,__tmp_reg__
 4628 1a6a CDBF      		out __SP_L__,r28
 4629 1a6c DF91      		pop r29
 4630 1a6e CF91      		pop r28
 4631 1a70 1F91      		pop r17
 4632 1a72 0F91      		pop r16
 4633 1a74 FF90      		pop r15
 4634 1a76 EF90      		pop r14
 4635 1a78 DF90      		pop r13
 4636               	.LVL339:
 4637 1a7a CF90      		pop r12
 4638 1a7c BF90      		pop r11
 4639 1a7e AF90      		pop r10
 4640 1a80 9F90      		pop r9
 4641 1a82 8F90      		pop r8
 4642               	.LVL340:
 4643 1a84 7F90      		pop r7
 4644 1a86 6F90      		pop r6
 4645 1a88 5F90      		pop r5
 4646 1a8a 4F90      		pop r4
 4647 1a8c 3F90      		pop r3
 4648 1a8e 2F90      		pop r2
 4649 1a90 0895      		ret
 4650               	.LFE81:
 4652               	.global	inputTenthCheck
 4654               	inputTenthCheck:
 4655               	.LFB80:
3351:switcherator.c **** void inputTenthCheck(void) {
 4656               		.loc 1 3351 0
 4657 1a92 0F93      		push r16
 4658               	.LCFI106:
 4659 1a94 1F93      		push r17
 4660               	.LCFI107:
 4661 1a96 CF93      		push r28
 4662               	.LCFI108:
 4663 1a98 DF93      		push r29
 4664               	.LCFI109:
 4665               	/* prologue: function */
 4666               	/* frame size = 0 */
 4667               	/* stack size = 4 */
 4668               	.L__stack_usage = 4
 4669               	.LVL341:
 4670 1a9a 00E0      		ldi r16,lo8(inputs+6)
 4671 1a9c 10E0      		ldi r17,hi8(inputs+6)
3353:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 4672               		.loc 1 3353 0
 4673 1a9e C0E0      		ldi r28,0
 4674 1aa0 D0E0      		ldi r29,0
 4675               	.LVL342:
 4676               	.L360:
3351:switcherator.c **** void inputTenthCheck(void) {
 4677               		.loc 1 3351 0
 4678 1aa2 F801      		movw r30,r16
 4679 1aa4 3697      		sbiw r30,6
3355:switcherator.c ****         if (inputs[x][0] != 255 && inputs[x][6] == 0)
 4680               		.loc 1 3355 0
 4681 1aa6 8081      		ld r24,Z
 4682 1aa8 8F3F      		cpi r24,lo8(-1)
 4683 1aaa 01F0      		breq .L359
3355:switcherator.c ****         if (inputs[x][0] != 255 && inputs[x][6] == 0)
 4684               		.loc 1 3355 0 is_stmt 0 discriminator 1
 4685 1aac F801      		movw r30,r16
 4686 1aae 8081      		ld r24,Z
 4687 1ab0 8111      		cpse r24,__zero_reg__
 4688 1ab2 00C0      		rjmp .L359
3356:switcherator.c ****             getInput(x);
 4689               		.loc 1 3356 0 is_stmt 1
 4690 1ab4 CE01      		movw r24,r28
 4691 1ab6 0E94 0000 		call getInput
 4692               	.LVL343:
 4693               	.L359:
3353:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 4694               		.loc 1 3353 0
 4695 1aba 2196      		adiw r28,1
 4696               	.LVL344:
 4697 1abc 085F      		subi r16,-8
 4698 1abe 1F4F      		sbci r17,-1
 4699 1ac0 C430      		cpi r28,4
 4700 1ac2 D105      		cpc r29,__zero_reg__
 4701 1ac4 01F4      		brne .L360
 4702               	/* epilogue start */
3358:switcherator.c **** }
 4703               		.loc 1 3358 0
 4704 1ac6 DF91      		pop r29
 4705 1ac8 CF91      		pop r28
 4706               	.LVL345:
 4707 1aca 1F91      		pop r17
 4708 1acc 0F91      		pop r16
 4709 1ace 0895      		ret
 4710               	.LFE80:
 4712               	.global	inputCheck
 4714               	inputCheck:
 4715               	.LFB79:
3330:switcherator.c **** void inputCheck(void) {
 4716               		.loc 1 3330 0
 4717 1ad0 0F93      		push r16
 4718               	.LCFI110:
 4719 1ad2 1F93      		push r17
 4720               	.LCFI111:
 4721 1ad4 CF93      		push r28
 4722               	.LCFI112:
 4723 1ad6 DF93      		push r29
 4724               	.LCFI113:
 4725               	/* prologue: function */
 4726               	/* frame size = 0 */
 4727               	/* stack size = 4 */
 4728               	.L__stack_usage = 4
 4729               	.LVL346:
 4730 1ad8 00E0      		ldi r16,lo8(inputs+6)
 4731 1ada 10E0      		ldi r17,hi8(inputs+6)
3334:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 4732               		.loc 1 3334 0
 4733 1adc C0E0      		ldi r28,0
 4734 1ade D0E0      		ldi r29,0
 4735               	.LVL347:
 4736               	.L368:
3330:switcherator.c **** void inputCheck(void) {
 4737               		.loc 1 3330 0
 4738 1ae0 F801      		movw r30,r16
 4739 1ae2 3697      		sbiw r30,6
3336:switcherator.c ****         if (inputs[x][0] == 255)
 4740               		.loc 1 3336 0
 4741 1ae4 8081      		ld r24,Z
 4742 1ae6 8F3F      		cpi r24,lo8(-1)
 4743 1ae8 01F0      		breq .L366
3338:switcherator.c ****         pollTime = inputs[x][6];
 4744               		.loc 1 3338 0
 4745 1aea F801      		movw r30,r16
 4746 1aec 2081      		ld r18,Z
 4747               	.LVL348:
3340:switcherator.c ****         if (pollTime == 0 || pollTime == 1) {
 4748               		.loc 1 3340 0
 4749 1aee 2230      		cpi r18,lo8(2)
 4750 1af0 00F4      		brsh .L367
 4751 1af2 00C0      		rjmp .L373
 4752               	.L367:
3343:switcherator.c ****         } else if (weeklySeconds % pollTime == 0) {
 4753               		.loc 1 3343 0
 4754 1af4 30E0      		ldi r19,0
 4755 1af6 40E0      		ldi r20,0
 4756 1af8 50E0      		ldi r21,0
 4757 1afa 6091 0000 		lds r22,weeklySeconds
 4758 1afe 7091 0000 		lds r23,weeklySeconds+1
 4759 1b02 8091 0000 		lds r24,weeklySeconds+2
 4760 1b06 9091 0000 		lds r25,weeklySeconds+3
 4761 1b0a 0E94 0000 		call __udivmodsi4
 4762               	.LVL349:
 4763 1b0e 672B      		or r22,r23
 4764 1b10 682B      		or r22,r24
 4765 1b12 692B      		or r22,r25
 4766 1b14 01F4      		brne .L366
 4767               	.L373:
3344:switcherator.c ****             getInput(x);
 4768               		.loc 1 3344 0
 4769 1b16 CE01      		movw r24,r28
 4770 1b18 0E94 0000 		call getInput
 4771               	.LVL350:
 4772               	.L366:
3334:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 4773               		.loc 1 3334 0
 4774 1b1c 2196      		adiw r28,1
 4775               	.LVL351:
 4776 1b1e 085F      		subi r16,-8
 4777 1b20 1F4F      		sbci r17,-1
 4778 1b22 C430      		cpi r28,4
 4779 1b24 D105      		cpc r29,__zero_reg__
 4780 1b26 01F4      		brne .L368
 4781               	/* epilogue start */
3347:switcherator.c **** }
 4782               		.loc 1 3347 0
 4783 1b28 DF91      		pop r29
 4784 1b2a CF91      		pop r28
 4785               	.LVL352:
 4786 1b2c 1F91      		pop r17
 4787 1b2e 0F91      		pop r16
 4788 1b30 0895      		ret
 4789               	.LFE79:
 4791               	.global	flashFail
 4793               	flashFail:
 4794               	.LFB83:
3600:switcherator.c **** 
3601:switcherator.c **** // clears an input
3602:switcherator.c **** // CI nn = input number
3603:switcherator.c **** 
3604:switcherator.c **** void clearInput(char * commandReceived) {
3605:switcherator.c ****     int inputNumber = 0;
3606:switcherator.c ****     volatile unsigned char *thisPort = 0;
3607:switcherator.c ****     tempIntString[0] = commandReceived[3];
3608:switcherator.c ****     tempIntString[1] = commandReceived[4];
3609:switcherator.c ****     inputNumber = atoi(tempIntString);
3610:switcherator.c ****     int temp = inputs[inputNumber][0];
3611:switcherator.c ****     if (temp > 15 && temp < 32) {
3612:switcherator.c ****         thisPort = &PINB;
3613:switcherator.c ****         temp -= 16;
3614:switcherator.c **** #ifdef PINA
3615:switcherator.c ****     } else if (temp < 16) {
3616:switcherator.c ****         thisPort = &PINA;
3617:switcherator.c ****         temp -= 0;
3618:switcherator.c **** #endif
3619:switcherator.c **** #ifdef PINC
3620:switcherator.c ****     } else if (temp < 48) {
3621:switcherator.c ****         thisPort = &PINC;
3622:switcherator.c ****         temp -= 32;
3623:switcherator.c **** #endif
3624:switcherator.c **** #ifdef PIND
3625:switcherator.c ****     } else if (temp < 64) {
3626:switcherator.c ****         thisPort = &PIND;
3627:switcherator.c ****         temp -= 48;
3628:switcherator.c **** #endif
3629:switcherator.c **** #ifdef PINE
3630:switcherator.c ****     } else if (temp < 80) {
3631:switcherator.c ****         thisPort = &PINE;
3632:switcherator.c ****         temp -= 64;
3633:switcherator.c **** #endif
3634:switcherator.c **** #ifdef PINF
3635:switcherator.c ****     } else if (temp < 96) {
3636:switcherator.c ****         thisPort = &PINF;
3637:switcherator.c ****         temp -= 80;
3638:switcherator.c **** #endif
3639:switcherator.c **** #ifdef PING
3640:switcherator.c ****     } else if (temp < 112) {
3641:switcherator.c ****         thisPort = &PING;
3642:switcherator.c ****         temp -= 96;
3643:switcherator.c **** #endif
3644:switcherator.c **** #ifdef PINH
3645:switcherator.c ****     } else if (temp < 128) {
3646:switcherator.c ****         thisPort = &PINH;
3647:switcherator.c ****         temp -= 112;
3648:switcherator.c **** #endif
3649:switcherator.c **** #ifdef PINI
3650:switcherator.c ****     } else if (temp < 144) {
3651:switcherator.c ****         thisPort = &PINI;
3652:switcherator.c ****         temp -= 128;
3653:switcherator.c **** #endif
3654:switcherator.c ****     } else {
3655:switcherator.c ****         ok();
3656:switcherator.c ****         return;
3657:switcherator.c ****     }
3658:switcherator.c ****     // zero out the port
3659:switcherator.c ****     *thisPort &= ~(1 << temp);
3660:switcherator.c ****     inputs[inputNumber][0] = 255;
3661:switcherator.c ****     ok();
3662:switcherator.c **** }
3663:switcherator.c **** 
3664:switcherator.c **** /****************************************************************
3665:switcherator.c ****  *
3666:switcherator.c ****  *              All Things Interrupt and on offish Related
3667:switcherator.c ****  *
3668:switcherator.c ****  ****************************************************************/
3669:switcherator.c **** 
3670:switcherator.c **** 
3671:switcherator.c **** // Flashes the indicator pin to determine problems
3672:switcherator.c **** 
3673:switcherator.c **** void flashFail(void) {
 4795               		.loc 1 3673 0
 4796               	/* prologue: function */
 4797               	/* frame size = 0 */
 4798               	/* stack size = 0 */
 4799               	.L__stack_usage = 0
3674:switcherator.c ****     failTimer++;
 4800               		.loc 1 3674 0
 4801 1b32 8091 0000 		lds r24,failTimer
 4802 1b36 8F5F      		subi r24,lo8(-(1))
 4803 1b38 8093 0000 		sts failTimer,r24
3675:switcherator.c ****     INDICATOR_DDR |= INDICATOR_PIN;
 4804               		.loc 1 3675 0
 4805 1b3c 529A      		sbi 0xa,2
3676:switcherator.c ****     // different timings for different fails
3677:switcherator.c ****     if (failCondition == 1) {
 4806               		.loc 1 3677 0
 4807 1b3e 9091 0000 		lds r25,failCondition
 4808 1b42 9130      		cpi r25,lo8(1)
 4809 1b44 01F4      		brne .L375
3678:switcherator.c ****         if (failTimer == 2) {
 4810               		.loc 1 3678 0
 4811 1b46 8230      		cpi r24,lo8(2)
 4812 1b48 01F4      		brne .L376
 4813 1b4a 00C0      		rjmp .L393
 4814               	.L376:
3679:switcherator.c ****             INDICATOR_PORT |= INDICATOR_PIN;
3680:switcherator.c ****         } else if (failTimer == 4) {
 4815               		.loc 1 3680 0
 4816 1b4c 8430      		cpi r24,lo8(4)
 4817 1b4e 01F4      		brne .L378
 4818 1b50 00C0      		rjmp .L391
 4819               	.L378:
3681:switcherator.c ****             INDICATOR_PORT &= ~(INDICATOR_PIN);
3682:switcherator.c ****         } else if (failTimer == 24)
 4820               		.loc 1 3682 0
 4821 1b52 8831      		cpi r24,lo8(24)
 4822 1b54 01F4      		brne .L374
 4823 1b56 00C0      		rjmp .L392
 4824               	.L375:
3683:switcherator.c ****             failTimer = 0;
3684:switcherator.c ****     } else if (failCondition == 2) {
 4825               		.loc 1 3684 0
 4826 1b58 9230      		cpi r25,lo8(2)
 4827 1b5a 01F4      		brne .L379
3685:switcherator.c ****         if (failTimer == 2) {
 4828               		.loc 1 3685 0
 4829 1b5c 8230      		cpi r24,lo8(2)
 4830 1b5e 01F4      		brne .L380
 4831 1b60 00C0      		rjmp .L393
 4832               	.L380:
3686:switcherator.c ****             INDICATOR_PORT |= INDICATOR_PIN;
3687:switcherator.c ****         } else if (failTimer == 4) {
 4833               		.loc 1 3687 0
 4834 1b62 8430      		cpi r24,lo8(4)
 4835 1b64 01F4      		brne .L381
 4836 1b66 00C0      		rjmp .L391
 4837               	.L381:
3688:switcherator.c ****             INDICATOR_PORT &= ~(INDICATOR_PIN);
3689:switcherator.c ****         } else if (failTimer == 8) {
 4838               		.loc 1 3689 0
 4839 1b68 8830      		cpi r24,lo8(8)
 4840 1b6a 01F4      		brne .L382
 4841 1b6c 00C0      		rjmp .L393
 4842               	.L382:
3690:switcherator.c ****             INDICATOR_PORT |= INDICATOR_PIN;
3691:switcherator.c ****         } else if (failTimer == 10) {
 4843               		.loc 1 3691 0
 4844 1b6e 8A30      		cpi r24,lo8(10)
 4845 1b70 01F4      		brne .L383
 4846 1b72 00C0      		rjmp .L391
 4847               	.L383:
3692:switcherator.c ****             INDICATOR_PORT &= ~(INDICATOR_PIN);
3693:switcherator.c ****         } else if (failTimer == 30)
 4848               		.loc 1 3693 0
 4849 1b74 8E31      		cpi r24,lo8(30)
 4850 1b76 01F4      		brne .L374
 4851 1b78 00C0      		rjmp .L392
 4852               	.L379:
3694:switcherator.c ****             failTimer = 0;
3695:switcherator.c ****     } else if (failCondition == 3) {
 4853               		.loc 1 3695 0
 4854 1b7a 9330      		cpi r25,lo8(3)
 4855 1b7c 01F4      		brne .L374
3696:switcherator.c ****         if (failTimer == 2) {
 4856               		.loc 1 3696 0
 4857 1b7e 8230      		cpi r24,lo8(2)
 4858 1b80 01F4      		brne .L384
 4859 1b82 00C0      		rjmp .L393
 4860               	.L384:
3697:switcherator.c ****             INDICATOR_PORT |= INDICATOR_PIN;
3698:switcherator.c ****         } else if (failTimer == 4) {
 4861               		.loc 1 3698 0
 4862 1b84 8430      		cpi r24,lo8(4)
 4863 1b86 01F4      		brne .L385
 4864 1b88 00C0      		rjmp .L391
 4865               	.L385:
3699:switcherator.c ****             INDICATOR_PORT &= ~(INDICATOR_PIN);
3700:switcherator.c ****         } else if (failTimer == 8) {
 4866               		.loc 1 3700 0
 4867 1b8a 8830      		cpi r24,lo8(8)
 4868 1b8c 01F4      		brne .L386
 4869 1b8e 00C0      		rjmp .L393
 4870               	.L386:
3701:switcherator.c ****             INDICATOR_PORT |= INDICATOR_PIN;
3702:switcherator.c ****         } else if (failTimer == 10) {
 4871               		.loc 1 3702 0
 4872 1b90 8A30      		cpi r24,lo8(10)
 4873 1b92 01F4      		brne .L387
 4874 1b94 00C0      		rjmp .L391
 4875               	.L387:
3703:switcherator.c ****             INDICATOR_PORT &= ~(INDICATOR_PIN);
3704:switcherator.c ****         } else if (failTimer == 14) {
 4876               		.loc 1 3704 0
 4877 1b96 8E30      		cpi r24,lo8(14)
 4878 1b98 01F4      		brne .L388
 4879               	.L393:
3705:switcherator.c ****             INDICATOR_PORT |= INDICATOR_PIN;
 4880               		.loc 1 3705 0
 4881 1b9a 5A9A      		sbi 0xb,2
 4882 1b9c 0895      		ret
 4883               	.L388:
3706:switcherator.c ****         } else if (failTimer == 16) {
 4884               		.loc 1 3706 0
 4885 1b9e 8031      		cpi r24,lo8(16)
 4886 1ba0 01F4      		brne .L389
 4887               	.L391:
3707:switcherator.c ****             INDICATOR_PORT &= ~(INDICATOR_PIN);
 4888               		.loc 1 3707 0
 4889 1ba2 5A98      		cbi 0xb,2
 4890 1ba4 0895      		ret
 4891               	.L389:
3708:switcherator.c ****         } else if (failTimer == 36)
 4892               		.loc 1 3708 0
 4893 1ba6 8432      		cpi r24,lo8(36)
 4894 1ba8 01F4      		brne .L374
 4895               	.L392:
3709:switcherator.c ****             failTimer = 0;
 4896               		.loc 1 3709 0
 4897 1baa 1092 0000 		sts failTimer,__zero_reg__
 4898               	.L374:
 4899 1bae 0895      		ret
 4900               	.LFE83:
 4902               	.global	clearFail
 4904               	clearFail:
 4905               	.LFB84:
3710:switcherator.c ****     }
3711:switcherator.c **** }
3712:switcherator.c **** 
3713:switcherator.c **** // turns off the indicator pin
3714:switcherator.c **** void clearFail(void) {
 4906               		.loc 1 3714 0
 4907               	/* prologue: function */
 4908               	/* frame size = 0 */
 4909               	/* stack size = 0 */
 4910               	.L__stack_usage = 0
3715:switcherator.c ****     failTimer = 0;
 4911               		.loc 1 3715 0
 4912 1bb0 1092 0000 		sts failTimer,__zero_reg__
3716:switcherator.c ****     INDICATOR_PORT |= (INDICATOR_PIN);
 4913               		.loc 1 3716 0
 4914 1bb4 5A9A      		sbi 0xb,2
3717:switcherator.c ****     INDICATOR_DDR |= (INDICATOR_PIN);
 4915               		.loc 1 3717 0
 4916 1bb6 529A      		sbi 0xa,2
 4917 1bb8 0895      		ret
 4918               	.LFE84:
 4920               	.global	sendMessage
 4922               	sendMessage:
 4923               	.LFB76:
3032:switcherator.c **** void sendMessage(char * myResponse) {
 4924               		.loc 1 3032 0
 4925               	.LVL353:
 4926 1bba CF93      		push r28
 4927               	.LCFI114:
 4928 1bbc DF93      		push r29
 4929               	.LCFI115:
 4930 1bbe 00D0      		rcall .
 4931               	.LCFI116:
 4932 1bc0 CDB7      		in r28,__SP_L__
 4933 1bc2 DEB7      		in r29,__SP_H__
 4934               	.LCFI117:
 4935               	/* prologue: function */
 4936               	/* frame size = 2 */
 4937               	/* stack size = 4 */
 4938               	.L__stack_usage = 4
3033:switcherator.c ****     stopRx();
 4939               		.loc 1 3033 0
 4940 1bc4 8983      		std Y+1,r24
 4941 1bc6 9A83      		std Y+2,r25
 4942 1bc8 0E94 0000 		call stopRx
 4943               	.LVL354:
 4944               	.LBB25:
 4945               	.LBB26:
 4946               		.file 2 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h"
   1:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
   6:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
   9:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  12:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  17:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  21:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  33:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  35:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  38:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  41:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  42:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  46:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /** \file */
  47:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \code
  49:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \endcode
  53:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  54:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     used.
  58:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  59:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  68:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  77:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  81:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** */
  82:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  83:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  87:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  88:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  93:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  94:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  97:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  98:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
 103:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 104:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /**
 105:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 107:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 109:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 112:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 114:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 120:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 125:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 129:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 132:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 140:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****  */
 141:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** void
 142:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** {
 144:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 153:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 156:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 159:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#else
 160:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#endif
 163:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 164:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 165:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 166:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #else
 167:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	{
 172:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		{
 176:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		}
 180:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		return;
 181:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	}
 182:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	else
 183:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
 186:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** }
 187:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 188:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /**
 189:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 191:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 193:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 196:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 198:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 202:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   
 207:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 211:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****  
 214:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 222:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****  */
 223:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** void
 224:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** {
 226:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 235:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 238:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 241:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#else
 242:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		//round up by default
 243:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#endif
 245:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 246:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 4947               		.loc 2 246 0
 4948 1bcc AFE8      		ldi r26,lo8(399)
 4949 1bce B1E0      		ldi r27,hi8(399)
 4950 1bd0 1197      		1: sbiw r26,1
 4951 1bd2 01F4      		brne 1b
 4952 1bd4 00C0      		rjmp .
 4953 1bd6 0000      		nop
 4954               	.LBE26:
 4955               	.LBE25:
3035:switcherator.c ****     int transmitLength = strlen(myResponse);
 4956               		.loc 1 3035 0
 4957 1bd8 8981      		ldd r24,Y+1
 4958 1bda E82F      		mov r30,r24
 4959 1bdc 9A81      		ldd r25,Y+2
 4960 1bde F92F      		mov r31,r25
 4961 1be0 DF01      		movw r26,r30
 4962               		0:
 4963 1be2 0D90      		ld __tmp_reg__,X+
 4964 1be4 0020      		tst __tmp_reg__
 4965 1be6 01F4      		brne 0b
 4966 1be8 BD01      		movw r22,r26
 4967 1bea 6150      		subi r22,1
 4968 1bec 7109      		sbc r23,__zero_reg__
 4969 1bee 6E1B      		sub r22,r30
 4970 1bf0 7F0B      		sbc r23,r31
3036:switcherator.c ****     if(!transmit(myResponse, transmitLength)) {
 4971               		.loc 1 3036 0
 4972 1bf2 0E94 0000 		call transmit
 4973               	.LVL355:
 4974 1bf6 8111      		cpse r24,__zero_reg__
 4975 1bf8 00C0      		rjmp .L396
3037:switcherator.c ****         failCondition = 2;
 4976               		.loc 1 3037 0
 4977 1bfa 82E0      		ldi r24,lo8(2)
 4978 1bfc 8093 0000 		sts failCondition,r24
 4979 1c00 00C0      		rjmp .L397
 4980               	.L396:
3039:switcherator.c ****         failCondition = 0;
 4981               		.loc 1 3039 0
 4982 1c02 1092 0000 		sts failCondition,__zero_reg__
3040:switcherator.c ****         clearFail();
 4983               		.loc 1 3040 0
 4984 1c06 0E94 0000 		call clearFail
 4985               	.LVL356:
 4986               	.L397:
 4987               	/* epilogue start */
3043:switcherator.c **** }
 4988               		.loc 1 3043 0
 4989 1c0a 0F90      		pop __tmp_reg__
 4990 1c0c 0F90      		pop __tmp_reg__
 4991 1c0e DF91      		pop r29
 4992 1c10 CF91      		pop r28
3042:switcherator.c ****     startRx();
 4993               		.loc 1 3042 0
 4994 1c12 0C94 0000 		jmp startRx
 4995               	.LVL357:
 4996               	.LFE76:
 4998               		.section	.rodata.str1.1
 4999               	.LC8:
 5000 000b 7230 2030 		.string	"r0 0x"
 5000      7800 
 5001               	.LC9:
 5002 0011 7231 2030 		.string	"r1 0x"
 5002      7800 
 5003               	.LC10:
 5004 0017 7232 2030 		.string	"r2 0x"
 5004      7800 
 5005               	.LC11:
 5006 001d 7233 2030 		.string	"r3 0x"
 5006      7800 
 5007               	.LC12:
 5008 0023 7234 2030 		.string	"r4 0x"
 5008      7800 
 5009               	.LC13:
 5010 0029 7235 2030 		.string	"r5 0x"
 5010      7800 
 5011               	.LC14:
 5012 002f 7420 3078 		.string	"t 0x"
 5012      00
 5013               	.LC6:
 5014 0034 3078 3030 		.string	"0x00"
 5014      00
 5015               	.LC7:
 5016 0039 3030 3030 		.string	"00000"
 5016      3000 
 5017               		.text
 5018               	.global	radioChangeAddress
 5020               	radioChangeAddress:
 5021               	.LFB74:
2956:switcherator.c **** void radioChangeAddress(char * commandReceived) {
 5022               		.loc 1 2956 0
 5023               	.LVL358:
 5024 1c16 2F92      		push r2
 5025               	.LCFI118:
 5026 1c18 3F92      		push r3
 5027               	.LCFI119:
 5028 1c1a 4F92      		push r4
 5029               	.LCFI120:
 5030 1c1c 5F92      		push r5
 5031               	.LCFI121:
 5032 1c1e 6F92      		push r6
 5033               	.LCFI122:
 5034 1c20 7F92      		push r7
 5035               	.LCFI123:
 5036 1c22 8F92      		push r8
 5037               	.LCFI124:
 5038 1c24 9F92      		push r9
 5039               	.LCFI125:
 5040 1c26 AF92      		push r10
 5041               	.LCFI126:
 5042 1c28 BF92      		push r11
 5043               	.LCFI127:
 5044 1c2a CF92      		push r12
 5045               	.LCFI128:
 5046 1c2c DF92      		push r13
 5047               	.LCFI129:
 5048 1c2e EF92      		push r14
 5049               	.LCFI130:
 5050 1c30 FF92      		push r15
 5051               	.LCFI131:
 5052 1c32 0F93      		push r16
 5053               	.LCFI132:
 5054 1c34 1F93      		push r17
 5055               	.LCFI133:
 5056 1c36 CF93      		push r28
 5057               	.LCFI134:
 5058 1c38 DF93      		push r29
 5059               	.LCFI135:
 5060 1c3a CDB7      		in r28,__SP_L__
 5061 1c3c DEB7      		in r29,__SP_H__
 5062               	.LCFI136:
 5063 1c3e 2B97      		sbiw r28,11
 5064               	.LCFI137:
 5065 1c40 0FB6      		in __tmp_reg__,__SREG__
 5066 1c42 F894      		cli
 5067 1c44 DEBF      		out __SP_H__,r29
 5068 1c46 0FBE      		out __SREG__,__tmp_reg__
 5069 1c48 CDBF      		out __SP_L__,r28
 5070               	/* prologue: function */
 5071               	/* frame size = 11 */
 5072               	/* stack size = 29 */
 5073               	.L__stack_usage = 29
 5074 1c4a 5C01      		movw r10,r24
 5075               	.LVL359:
2958:switcherator.c ****     statusMsg[0] = 0;
 5076               		.loc 1 2958 0
 5077 1c4c 1092 0000 		sts statusMsg,__zero_reg__
 5078               	.LVL360:
2961:switcherator.c ****     char tempString[] = "0x00";
 5079               		.loc 1 2961 0
 5080 1c50 85E0      		ldi r24,lo8(5)
 5081               	.LVL361:
 5082 1c52 E0E0      		ldi r30,lo8(.LC6)
 5083 1c54 F0E0      		ldi r31,hi8(.LC6)
 5084 1c56 DE01      		movw r26,r28
 5085 1c58 1796      		adiw r26,7
 5086               		0:
 5087 1c5a 0190      		ld r0,Z+
 5088 1c5c 0D92      		st X+,r0
 5089 1c5e 8A95      		dec r24
 5090 1c60 01F4      		brne 0b
2962:switcherator.c ****     char tempRadioString[] = "00000";
 5091               		.loc 1 2962 0
 5092 1c62 86E0      		ldi r24,lo8(6)
 5093 1c64 E0E0      		ldi r30,lo8(.LC7)
 5094 1c66 F0E0      		ldi r31,hi8(.LC7)
 5095 1c68 DE01      		movw r26,r28
 5096 1c6a 1196      		adiw r26,1
 5097               		0:
 5098 1c6c 0190      		ld r0,Z+
 5099 1c6e 0D92      		st X+,r0
 5100 1c70 8A95      		dec r24
 5101 1c72 01F4      		brne 0b
2956:switcherator.c **** void radioChangeAddress(char * commandReceived) {
 5102               		.loc 1 2956 0
 5103 1c74 6501      		movw r12,r10
 5104 1c76 88E0      		ldi r24,8
 5105 1c78 C80E      		add r12,r24
 5106 1c7a D11C      		adc r13,__zero_reg__
2960:switcherator.c ****     uint64_t newAddress = 0;
 5107               		.loc 1 2960 0
 5108 1c7c 212C      		mov r2,__zero_reg__
 5109 1c7e 312C      		mov r3,__zero_reg__
 5110 1c80 412C      		mov r4,__zero_reg__
 5111 1c82 512C      		mov r5,__zero_reg__
 5112 1c84 612C      		mov r6,__zero_reg__
 5113 1c86 712C      		mov r7,__zero_reg__
 5114 1c88 812C      		mov r8,__zero_reg__
 5115 1c8a 912C      		mov r9,__zero_reg__
2963:switcherator.c ****     for (x = 0; x < 5; x++) {
 5116               		.loc 1 2963 0
 5117 1c8c E12C      		mov r14,__zero_reg__
 5118 1c8e F12C      		mov r15,__zero_reg__
 5119               	.LVL362:
 5120               	.L400:
2956:switcherator.c **** void radioChangeAddress(char * commandReceived) {
 5121               		.loc 1 2956 0
 5122 1c90 F601      		movw r30,r12
 5123 1c92 3197      		sbiw r30,1
2964:switcherator.c ****         tempString[2] = commandReceived[((x * 2) + 7)];
 5124               		.loc 1 2964 0
 5125 1c94 8081      		ld r24,Z
 5126 1c96 8987      		std Y+9,r24
2965:switcherator.c ****         tempString[3] = commandReceived[((x * 2) + 8)];
 5127               		.loc 1 2965 0
 5128 1c98 F601      		movw r30,r12
 5129 1c9a 8081      		ld r24,Z
 5130 1c9c 8A87      		std Y+10,r24
2966:switcherator.c ****         tempInt = strtol(tempString, 0, 0);
 5131               		.loc 1 2966 0
 5132 1c9e 40E0      		ldi r20,0
 5133 1ca0 50E0      		ldi r21,0
 5134 1ca2 60E0      		ldi r22,0
 5135 1ca4 70E0      		ldi r23,0
 5136 1ca6 CE01      		movw r24,r28
 5137 1ca8 0796      		adiw r24,7
 5138 1caa 0E94 0000 		call strtol
 5139               	.LVL363:
2967:switcherator.c ****         newAddress |= tempInt;
 5140               		.loc 1 2967 0
 5141 1cae 872F      		mov r24,r23
 5142 1cb0 880F      		lsl r24
 5143 1cb2 880B      		sbc r24,r24
 5144 1cb4 262A      		or r2,r22
 5145 1cb6 372A      		or r3,r23
 5146 1cb8 482A      		or r4,r24
 5147 1cba 582A      		or r5,r24
 5148 1cbc 682A      		or r6,r24
 5149 1cbe 782A      		or r7,r24
 5150 1cc0 882A      		or r8,r24
 5151 1cc2 982A      		or r9,r24
 5152               	.LVL364:
2968:switcherator.c ****         if (x < 4)
 5153               		.loc 1 2968 0
 5154 1cc4 F4E0      		ldi r31,4
 5155 1cc6 EF16      		cp r14,r31
 5156 1cc8 F104      		cpc r15,__zero_reg__
 5157 1cca 01F0      		breq .L399
2969:switcherator.c ****             newAddress <<= 8;
 5158               		.loc 1 2969 0
 5159 1ccc 9101      		movw r18,r2
 5160 1cce A201      		movw r20,r4
 5161 1cd0 B301      		movw r22,r6
 5162 1cd2 C401      		movw r24,r8
 5163 1cd4 08E0      		ldi r16,lo8(8)
 5164 1cd6 0E94 0000 		call __ashldi3
 5165 1cda 1901      		movw r2,r18
 5166               	.LVL365:
 5167 1cdc 2A01      		movw r4,r20
 5168 1cde 3B01      		movw r6,r22
 5169 1ce0 4C01      		movw r8,r24
 5170               	.LVL366:
 5171               	.L399:
2963:switcherator.c ****     for (x = 0; x < 5; x++) {
 5172               		.loc 1 2963 0
 5173 1ce2 8FEF      		ldi r24,-1
 5174 1ce4 E81A      		sub r14,r24
 5175 1ce6 F80A      		sbc r15,r24
 5176               	.LVL367:
 5177 1ce8 E2E0      		ldi r30,2
 5178 1cea CE0E      		add r12,r30
 5179 1cec D11C      		adc r13,__zero_reg__
 5180 1cee F5E0      		ldi r31,5
 5181 1cf0 EF16      		cp r14,r31
 5182 1cf2 F104      		cpc r15,__zero_reg__
 5183 1cf4 01F4      		brne .L400
2971:switcherator.c ****     switch (commandReceived[3]) {
 5184               		.loc 1 2971 0
 5185 1cf6 F501      		movw r30,r10
 5186 1cf8 8381      		ldd r24,Z+3
 5187 1cfa 8333      		cpi r24,lo8(51)
 5188 1cfc 01F4      		brne .+2
 5189 1cfe 00C0      		rjmp .L405
 5190 1d00 00F4      		brsh .L409
 5191 1d02 8133      		cpi r24,lo8(49)
 5192 1d04 01F0      		breq .L403
 5193 1d06 00F0      		brlo .+2
 5194 1d08 00C0      		rjmp .L404
 5195 1d0a 8033      		cpi r24,lo8(48)
 5196 1d0c 01F0      		breq .+2
 5197 1d0e 00C0      		rjmp .L401
 5198 1d10 00C0      		rjmp .L402
 5199               	.L409:
 5200 1d12 8533      		cpi r24,lo8(53)
 5201 1d14 01F4      		brne .+2
 5202 1d16 00C0      		rjmp .L407
 5203 1d18 00F4      		brsh .+2
 5204 1d1a 00C0      		rjmp .L406
 5205 1d1c 8435      		cpi r24,lo8(84)
 5206 1d1e 01F0      		breq .+2
 5207 1d20 00C0      		rjmp .L401
 5208 1d22 00C0      		rjmp .L408
 5209               	.L402:
2973:switcherator.c ****             rx_addr_p0 = newAddress;
 5210               		.loc 1 2973 0
 5211 1d24 2092 0000 		sts rx_addr_p0,r2
 5212 1d28 3092 0000 		sts rx_addr_p0+1,r3
 5213 1d2c 4092 0000 		sts rx_addr_p0+2,r4
 5214 1d30 5092 0000 		sts rx_addr_p0+3,r5
 5215 1d34 6092 0000 		sts rx_addr_p0+4,r6
 5216 1d38 7092 0000 		sts rx_addr_p0+5,r7
 5217 1d3c 8092 0000 		sts rx_addr_p0+6,r8
 5218 1d40 9092 0000 		sts rx_addr_p0+7,r9
2974:switcherator.c ****             strcat(statusMsg, "r0 0x");
 5219               		.loc 1 2974 0
 5220 1d44 60E0      		ldi r22,lo8(.LC8)
 5221 1d46 70E0      		ldi r23,hi8(.LC8)
 5222 1d48 80E0      		ldi r24,lo8(statusMsg)
 5223 1d4a 90E0      		ldi r25,hi8(statusMsg)
 5224 1d4c 0E94 0000 		call strcat
 5225               	.LVL368:
2975:switcherator.c ****             writeAddr(RX_ADDR_P0, newAddress);
 5226               		.loc 1 2975 0
 5227 1d50 8101      		movw r16,r2
 5228 1d52 9201      		movw r18,r4
 5229 1d54 A301      		movw r20,r6
 5230 1d56 B401      		movw r22,r8
 5231 1d58 8AE0      		ldi r24,lo8(10)
 5232 1d5a 00C0      		rjmp .L416
 5233               	.L403:
2978:switcherator.c ****             rx_addr_p1 = newAddress;
 5234               		.loc 1 2978 0
 5235 1d5c 2092 0000 		sts rx_addr_p1,r2
 5236 1d60 3092 0000 		sts rx_addr_p1+1,r3
 5237 1d64 4092 0000 		sts rx_addr_p1+2,r4
 5238 1d68 5092 0000 		sts rx_addr_p1+3,r5
 5239 1d6c 6092 0000 		sts rx_addr_p1+4,r6
 5240 1d70 7092 0000 		sts rx_addr_p1+5,r7
 5241 1d74 8092 0000 		sts rx_addr_p1+6,r8
 5242 1d78 9092 0000 		sts rx_addr_p1+7,r9
2979:switcherator.c ****             strcat(statusMsg, "r1 0x");
 5243               		.loc 1 2979 0
 5244 1d7c 60E0      		ldi r22,lo8(.LC9)
 5245 1d7e 70E0      		ldi r23,hi8(.LC9)
 5246 1d80 80E0      		ldi r24,lo8(statusMsg)
 5247 1d82 90E0      		ldi r25,hi8(statusMsg)
 5248 1d84 0E94 0000 		call strcat
 5249               	.LVL369:
2980:switcherator.c ****             writeAddr(RX_ADDR_P1, newAddress);
 5250               		.loc 1 2980 0
 5251 1d88 8101      		movw r16,r2
 5252 1d8a 9201      		movw r18,r4
 5253 1d8c A301      		movw r20,r6
 5254 1d8e B401      		movw r22,r8
 5255 1d90 8BE0      		ldi r24,lo8(11)
 5256 1d92 00C0      		rjmp .L416
 5257               	.L404:
2983:switcherator.c ****             rx_addr_p2 = newAddress;
 5258               		.loc 1 2983 0
 5259 1d94 2092 0000 		sts rx_addr_p2,r2
 5260 1d98 3092 0000 		sts rx_addr_p2+1,r3
 5261 1d9c 4092 0000 		sts rx_addr_p2+2,r4
 5262 1da0 5092 0000 		sts rx_addr_p2+3,r5
 5263 1da4 6092 0000 		sts rx_addr_p2+4,r6
 5264 1da8 7092 0000 		sts rx_addr_p2+5,r7
 5265 1dac 8092 0000 		sts rx_addr_p2+6,r8
 5266 1db0 9092 0000 		sts rx_addr_p2+7,r9
2984:switcherator.c ****             strcat(statusMsg, "r2 0x");
 5267               		.loc 1 2984 0
 5268 1db4 60E0      		ldi r22,lo8(.LC10)
 5269 1db6 70E0      		ldi r23,hi8(.LC10)
 5270 1db8 80E0      		ldi r24,lo8(statusMsg)
 5271 1dba 90E0      		ldi r25,hi8(statusMsg)
 5272 1dbc 0E94 0000 		call strcat
 5273               	.LVL370:
2985:switcherator.c ****             writeAddr(RX_ADDR_P2, newAddress);
 5274               		.loc 1 2985 0
 5275 1dc0 8101      		movw r16,r2
 5276 1dc2 9201      		movw r18,r4
 5277 1dc4 A301      		movw r20,r6
 5278 1dc6 B401      		movw r22,r8
 5279 1dc8 8CE0      		ldi r24,lo8(12)
 5280 1dca 00C0      		rjmp .L416
 5281               	.L405:
2988:switcherator.c ****             rx_addr_p3 = newAddress;
 5282               		.loc 1 2988 0
 5283 1dcc 2092 0000 		sts rx_addr_p3,r2
 5284 1dd0 3092 0000 		sts rx_addr_p3+1,r3
 5285 1dd4 4092 0000 		sts rx_addr_p3+2,r4
 5286 1dd8 5092 0000 		sts rx_addr_p3+3,r5
 5287 1ddc 6092 0000 		sts rx_addr_p3+4,r6
 5288 1de0 7092 0000 		sts rx_addr_p3+5,r7
 5289 1de4 8092 0000 		sts rx_addr_p3+6,r8
 5290 1de8 9092 0000 		sts rx_addr_p3+7,r9
2989:switcherator.c ****             strcat(statusMsg, "r3 0x");
 5291               		.loc 1 2989 0
 5292 1dec 60E0      		ldi r22,lo8(.LC11)
 5293 1dee 70E0      		ldi r23,hi8(.LC11)
 5294 1df0 80E0      		ldi r24,lo8(statusMsg)
 5295 1df2 90E0      		ldi r25,hi8(statusMsg)
 5296 1df4 0E94 0000 		call strcat
 5297               	.LVL371:
2990:switcherator.c ****             writeAddr(RX_ADDR_P3, newAddress);
 5298               		.loc 1 2990 0
 5299 1df8 8101      		movw r16,r2
 5300 1dfa 9201      		movw r18,r4
 5301 1dfc A301      		movw r20,r6
 5302 1dfe B401      		movw r22,r8
 5303 1e00 8DE0      		ldi r24,lo8(13)
 5304 1e02 00C0      		rjmp .L416
 5305               	.L406:
2993:switcherator.c ****             rx_addr_p4 = newAddress;
 5306               		.loc 1 2993 0
 5307 1e04 2092 0000 		sts rx_addr_p4,r2
 5308 1e08 3092 0000 		sts rx_addr_p4+1,r3
 5309 1e0c 4092 0000 		sts rx_addr_p4+2,r4
 5310 1e10 5092 0000 		sts rx_addr_p4+3,r5
 5311 1e14 6092 0000 		sts rx_addr_p4+4,r6
 5312 1e18 7092 0000 		sts rx_addr_p4+5,r7
 5313 1e1c 8092 0000 		sts rx_addr_p4+6,r8
 5314 1e20 9092 0000 		sts rx_addr_p4+7,r9
2994:switcherator.c ****             strcat(statusMsg, "r4 0x");
 5315               		.loc 1 2994 0
 5316 1e24 60E0      		ldi r22,lo8(.LC12)
 5317 1e26 70E0      		ldi r23,hi8(.LC12)
 5318 1e28 80E0      		ldi r24,lo8(statusMsg)
 5319 1e2a 90E0      		ldi r25,hi8(statusMsg)
 5320 1e2c 0E94 0000 		call strcat
 5321               	.LVL372:
2995:switcherator.c ****             writeAddr(RX_ADDR_P4, newAddress);
 5322               		.loc 1 2995 0
 5323 1e30 8101      		movw r16,r2
 5324 1e32 9201      		movw r18,r4
 5325 1e34 A301      		movw r20,r6
 5326 1e36 B401      		movw r22,r8
 5327 1e38 8EE0      		ldi r24,lo8(14)
 5328 1e3a 00C0      		rjmp .L416
 5329               	.L407:
2998:switcherator.c ****             rx_addr_p5 = newAddress;
 5330               		.loc 1 2998 0
 5331 1e3c 2092 0000 		sts rx_addr_p5,r2
 5332 1e40 3092 0000 		sts rx_addr_p5+1,r3
 5333 1e44 4092 0000 		sts rx_addr_p5+2,r4
 5334 1e48 5092 0000 		sts rx_addr_p5+3,r5
 5335 1e4c 6092 0000 		sts rx_addr_p5+4,r6
 5336 1e50 7092 0000 		sts rx_addr_p5+5,r7
 5337 1e54 8092 0000 		sts rx_addr_p5+6,r8
 5338 1e58 9092 0000 		sts rx_addr_p5+7,r9
2999:switcherator.c ****             strcat(statusMsg, "r5 0x");
 5339               		.loc 1 2999 0
 5340 1e5c 60E0      		ldi r22,lo8(.LC13)
 5341 1e5e 70E0      		ldi r23,hi8(.LC13)
 5342 1e60 80E0      		ldi r24,lo8(statusMsg)
 5343 1e62 90E0      		ldi r25,hi8(statusMsg)
 5344 1e64 0E94 0000 		call strcat
 5345               	.LVL373:
3000:switcherator.c ****             writeAddr(RX_ADDR_P5, newAddress);
 5346               		.loc 1 3000 0
 5347 1e68 8101      		movw r16,r2
 5348 1e6a 9201      		movw r18,r4
 5349 1e6c A301      		movw r20,r6
 5350 1e6e B401      		movw r22,r8
 5351 1e70 8FE0      		ldi r24,lo8(15)
 5352 1e72 00C0      		rjmp .L416
 5353               	.L408:
3003:switcherator.c ****             tx_addr = newAddress;
 5354               		.loc 1 3003 0
 5355 1e74 2092 0000 		sts tx_addr,r2
 5356 1e78 3092 0000 		sts tx_addr+1,r3
 5357 1e7c 4092 0000 		sts tx_addr+2,r4
 5358 1e80 5092 0000 		sts tx_addr+3,r5
 5359 1e84 6092 0000 		sts tx_addr+4,r6
 5360 1e88 7092 0000 		sts tx_addr+5,r7
 5361 1e8c 8092 0000 		sts tx_addr+6,r8
 5362 1e90 9092 0000 		sts tx_addr+7,r9
3004:switcherator.c ****             strcat(statusMsg, "t 0x");
 5363               		.loc 1 3004 0
 5364 1e94 60E0      		ldi r22,lo8(.LC14)
 5365 1e96 70E0      		ldi r23,hi8(.LC14)
 5366 1e98 80E0      		ldi r24,lo8(statusMsg)
 5367 1e9a 90E0      		ldi r25,hi8(statusMsg)
 5368 1e9c 0E94 0000 		call strcat
 5369               	.LVL374:
3005:switcherator.c ****             writeAddr(TX_ADDR, newAddress);
 5370               		.loc 1 3005 0
 5371 1ea0 8101      		movw r16,r2
 5372 1ea2 9201      		movw r18,r4
 5373 1ea4 A301      		movw r20,r6
 5374 1ea6 B401      		movw r22,r8
 5375 1ea8 80E1      		ldi r24,lo8(16)
 5376               	.L416:
 5377 1eaa 0E94 0000 		call writeAddr
 5378               	.LVL375:
 5379               	.L401:
3008:switcherator.c ****     unformatAddress(newAddress, tempRadioString);
 5380               		.loc 1 3008 0
 5381 1eae 8E01      		movw r16,r28
 5382 1eb0 0F5F      		subi r16,-1
 5383 1eb2 1F4F      		sbci r17,-1
 5384 1eb4 9101      		movw r18,r2
 5385 1eb6 A201      		movw r20,r4
 5386 1eb8 B301      		movw r22,r6
 5387 1eba C401      		movw r24,r8
 5388 1ebc 0E94 0000 		call unformatAddress
 5389               	.LVL376:
 5390 1ec0 7801      		movw r14,r16
2956:switcherator.c **** void radioChangeAddress(char * commandReceived) {
 5391               		.loc 1 2956 0
 5392 1ec2 6E01      		movw r12,r28
 5393 1ec4 F6E0      		ldi r31,6
 5394 1ec6 CF0E      		add r12,r31
 5395 1ec8 D11C      		adc r13,__zero_reg__
 5396               	.LVL377:
 5397               	.L410:
3010:switcherator.c ****         returnHexWithout(tempRadioString[x], tempLongString);
 5398               		.loc 1 3010 0 discriminator 2
 5399 1eca 60E0      		ldi r22,lo8(tempLongString)
 5400 1ecc 70E0      		ldi r23,hi8(tempLongString)
 5401 1ece F701      		movw r30,r14
 5402 1ed0 8191      		ld r24,Z+
 5403 1ed2 7F01      		movw r14,r30
 5404 1ed4 90E0      		ldi r25,0
 5405 1ed6 0E94 0000 		call returnHexWithout
 5406               	.LVL378:
3011:switcherator.c ****         strcat(statusMsg, tempLongString);
 5407               		.loc 1 3011 0 discriminator 2
 5408 1eda 60E0      		ldi r22,lo8(tempLongString)
 5409 1edc 70E0      		ldi r23,hi8(tempLongString)
 5410 1ede 80E0      		ldi r24,lo8(statusMsg)
 5411 1ee0 90E0      		ldi r25,hi8(statusMsg)
 5412 1ee2 0E94 0000 		call strcat
 5413               	.LVL379:
3009:switcherator.c ****     for (x = 0; x < 5; x++) {
 5414               		.loc 1 3009 0 discriminator 2
 5415 1ee6 EC14      		cp r14,r12
 5416 1ee8 FD04      		cpc r15,r13
 5417 1eea 01F4      		brne .L410
3013:switcherator.c ****     sendMessage(statusMsg);
 5418               		.loc 1 3013 0
 5419 1eec 80E0      		ldi r24,lo8(statusMsg)
 5420 1eee 90E0      		ldi r25,hi8(statusMsg)
 5421 1ef0 0E94 0000 		call sendMessage
 5422               	.LVL380:
 5423               	/* epilogue start */
3014:switcherator.c **** }
 5424               		.loc 1 3014 0
 5425 1ef4 2B96      		adiw r28,11
 5426 1ef6 0FB6      		in __tmp_reg__,__SREG__
 5427 1ef8 F894      		cli
 5428 1efa DEBF      		out __SP_H__,r29
 5429 1efc 0FBE      		out __SREG__,__tmp_reg__
 5430 1efe CDBF      		out __SP_L__,r28
 5431 1f00 DF91      		pop r29
 5432 1f02 CF91      		pop r28
 5433 1f04 1F91      		pop r17
 5434 1f06 0F91      		pop r16
 5435 1f08 FF90      		pop r15
 5436 1f0a EF90      		pop r14
 5437 1f0c DF90      		pop r13
 5438 1f0e CF90      		pop r12
 5439 1f10 BF90      		pop r11
 5440 1f12 AF90      		pop r10
 5441               	.LVL381:
 5442 1f14 9F90      		pop r9
 5443               	.LVL382:
 5444 1f16 8F90      		pop r8
 5445 1f18 7F90      		pop r7
 5446 1f1a 6F90      		pop r6
 5447 1f1c 5F90      		pop r5
 5448 1f1e 4F90      		pop r4
 5449 1f20 3F90      		pop r3
 5450 1f22 2F90      		pop r2
 5451 1f24 0895      		ret
 5452               	.LFE74:
 5454               		.section	.rodata.str1.1
 5455               	.LC15:
 5456 003f 7231 2D30 		.string	"r1-0x"
 5456      7800 
 5457               	.LC16:
 5458 0045 7232 2D30 		.string	"r2-0x"
 5458      7800 
 5459               	.LC17:
 5460 004b 7233 2D30 		.string	"r3-0x"
 5460      7800 
 5461               	.LC18:
 5462 0051 7234 2D30 		.string	"r4-0x"
 5462      7800 
 5463               	.LC19:
 5464 0057 7235 2D30 		.string	"r5-0x"
 5464      7800 
 5465               	.LC20:
 5466 005d 742D 3078 		.string	"t-0x"
 5466      00
 5467               	.LC21:
 5468 0062 7230 2D30 		.string	"r0-0x"
 5468      7800 
 5469               		.text
 5470               	.global	radioDisplayAddress
 5472               	radioDisplayAddress:
 5473               	.LFB73:
2916:switcherator.c **** void radioDisplayAddress(char * commandReceived) {
 5474               		.loc 1 2916 0
 5475               	.LVL383:
 5476 1f26 EF92      		push r14
 5477               	.LCFI138:
 5478 1f28 FF92      		push r15
 5479               	.LCFI139:
 5480 1f2a 0F93      		push r16
 5481               	.LCFI140:
 5482 1f2c 1F93      		push r17
 5483               	.LCFI141:
 5484 1f2e CF93      		push r28
 5485               	.LCFI142:
 5486 1f30 DF93      		push r29
 5487               	.LCFI143:
 5488 1f32 00D0      		rcall .
 5489 1f34 00D0      		rcall .
 5490 1f36 00D0      		rcall .
 5491               	.LCFI144:
 5492 1f38 CDB7      		in r28,__SP_L__
 5493 1f3a DEB7      		in r29,__SP_H__
 5494               	.LCFI145:
 5495               	/* prologue: function */
 5496               	/* frame size = 6 */
 5497               	/* stack size = 12 */
 5498               	.L__stack_usage = 12
 5499               	.LVL384:
2919:switcherator.c ****     statusMsg[0] = 0;
 5500               		.loc 1 2919 0
 5501 1f3c 1092 0000 		sts statusMsg,__zero_reg__
2920:switcherator.c ****     if(commandReceived[3] == '1') {
 5502               		.loc 1 2920 0
 5503 1f40 FC01      		movw r30,r24
 5504 1f42 8381      		ldd r24,Z+3
 5505               	.LVL385:
 5506 1f44 8133      		cpi r24,lo8(49)
 5507 1f46 01F4      		brne .L418
2921:switcherator.c ****         unformatAddress(rx_addr_p1, tempRadioString);
 5508               		.loc 1 2921 0
 5509 1f48 2091 0000 		lds r18,rx_addr_p1
 5510 1f4c 3091 0000 		lds r19,rx_addr_p1+1
 5511 1f50 4091 0000 		lds r20,rx_addr_p1+2
 5512 1f54 5091 0000 		lds r21,rx_addr_p1+3
 5513 1f58 6091 0000 		lds r22,rx_addr_p1+4
 5514 1f5c 7091 0000 		lds r23,rx_addr_p1+5
 5515 1f60 8E01      		movw r16,r28
 5516 1f62 0F5F      		subi r16,-1
 5517 1f64 1F4F      		sbci r17,-1
 5518 1f66 8091 0000 		lds r24,rx_addr_p1+6
 5519 1f6a 9091 0000 		lds r25,rx_addr_p1+7
 5520 1f6e 0E94 0000 		call unformatAddress
 5521               	.LVL386:
2922:switcherator.c ****         strcat(statusMsg, "r1-0x");
 5522               		.loc 1 2922 0
 5523 1f72 60E0      		ldi r22,lo8(.LC15)
 5524 1f74 70E0      		ldi r23,hi8(.LC15)
 5525               	.L427:
 5526 1f76 80E0      		ldi r24,lo8(statusMsg)
 5527 1f78 90E0      		ldi r25,hi8(statusMsg)
 5528 1f7a 0E94 0000 		call strcat
 5529               	.LVL387:
 5530 1f7e 8E01      		movw r16,r28
 5531 1f80 0F5F      		subi r16,-1
 5532 1f82 1F4F      		sbci r17,-1
2916:switcherator.c **** void radioDisplayAddress(char * commandReceived) {
 5533               		.loc 1 2916 0
 5534 1f84 7E01      		movw r14,r28
 5535 1f86 F6E0      		ldi r31,6
 5536 1f88 EF0E      		add r14,r31
 5537 1f8a F11C      		adc r15,__zero_reg__
 5538 1f8c 00C0      		rjmp .L419
 5539               	.LVL388:
 5540               	.L418:
2923:switcherator.c ****     } else if(commandReceived[3] == '2') {
 5541               		.loc 1 2923 0
 5542 1f8e 8233      		cpi r24,lo8(50)
 5543 1f90 01F4      		brne .L420
2924:switcherator.c ****         unformatAddress(rx_addr_p2, tempRadioString);
 5544               		.loc 1 2924 0
 5545 1f92 2091 0000 		lds r18,rx_addr_p2
 5546 1f96 3091 0000 		lds r19,rx_addr_p2+1
 5547 1f9a 4091 0000 		lds r20,rx_addr_p2+2
 5548 1f9e 5091 0000 		lds r21,rx_addr_p2+3
 5549 1fa2 6091 0000 		lds r22,rx_addr_p2+4
 5550 1fa6 7091 0000 		lds r23,rx_addr_p2+5
 5551 1faa 8E01      		movw r16,r28
 5552 1fac 0F5F      		subi r16,-1
 5553 1fae 1F4F      		sbci r17,-1
 5554 1fb0 8091 0000 		lds r24,rx_addr_p2+6
 5555 1fb4 9091 0000 		lds r25,rx_addr_p2+7
 5556 1fb8 0E94 0000 		call unformatAddress
 5557               	.LVL389:
2925:switcherator.c ****         strcat(statusMsg, "r2-0x");
 5558               		.loc 1 2925 0
 5559 1fbc 60E0      		ldi r22,lo8(.LC16)
 5560 1fbe 70E0      		ldi r23,hi8(.LC16)
 5561 1fc0 00C0      		rjmp .L427
 5562               	.LVL390:
 5563               	.L420:
2926:switcherator.c ****     } else if(commandReceived[3] == '3') {
 5564               		.loc 1 2926 0
 5565 1fc2 8333      		cpi r24,lo8(51)
 5566 1fc4 01F4      		brne .L422
2927:switcherator.c ****         unformatAddress(rx_addr_p3, tempRadioString);
 5567               		.loc 1 2927 0
 5568 1fc6 2091 0000 		lds r18,rx_addr_p3
 5569 1fca 3091 0000 		lds r19,rx_addr_p3+1
 5570 1fce 4091 0000 		lds r20,rx_addr_p3+2
 5571 1fd2 5091 0000 		lds r21,rx_addr_p3+3
 5572 1fd6 6091 0000 		lds r22,rx_addr_p3+4
 5573 1fda 7091 0000 		lds r23,rx_addr_p3+5
 5574 1fde 8E01      		movw r16,r28
 5575 1fe0 0F5F      		subi r16,-1
 5576 1fe2 1F4F      		sbci r17,-1
 5577 1fe4 8091 0000 		lds r24,rx_addr_p3+6
 5578 1fe8 9091 0000 		lds r25,rx_addr_p3+7
 5579 1fec 0E94 0000 		call unformatAddress
 5580               	.LVL391:
2928:switcherator.c ****         strcat(statusMsg, "r3-0x");
 5581               		.loc 1 2928 0
 5582 1ff0 60E0      		ldi r22,lo8(.LC17)
 5583 1ff2 70E0      		ldi r23,hi8(.LC17)
 5584 1ff4 00C0      		rjmp .L427
 5585               	.LVL392:
 5586               	.L422:
2929:switcherator.c ****     } else if(commandReceived[3] == '4') {
 5587               		.loc 1 2929 0
 5588 1ff6 8433      		cpi r24,lo8(52)
 5589 1ff8 01F4      		brne .L423
2930:switcherator.c ****         unformatAddress(rx_addr_p4, tempRadioString);
 5590               		.loc 1 2930 0
 5591 1ffa 2091 0000 		lds r18,rx_addr_p4
 5592 1ffe 3091 0000 		lds r19,rx_addr_p4+1
 5593 2002 4091 0000 		lds r20,rx_addr_p4+2
 5594 2006 5091 0000 		lds r21,rx_addr_p4+3
 5595 200a 6091 0000 		lds r22,rx_addr_p4+4
 5596 200e 7091 0000 		lds r23,rx_addr_p4+5
 5597 2012 8E01      		movw r16,r28
 5598 2014 0F5F      		subi r16,-1
 5599 2016 1F4F      		sbci r17,-1
 5600 2018 8091 0000 		lds r24,rx_addr_p4+6
 5601 201c 9091 0000 		lds r25,rx_addr_p4+7
 5602 2020 0E94 0000 		call unformatAddress
 5603               	.LVL393:
2931:switcherator.c ****         strcat(statusMsg, "r4-0x");
 5604               		.loc 1 2931 0
 5605 2024 60E0      		ldi r22,lo8(.LC18)
 5606 2026 70E0      		ldi r23,hi8(.LC18)
 5607 2028 00C0      		rjmp .L427
 5608               	.LVL394:
 5609               	.L423:
2932:switcherator.c ****     } else if (commandReceived[3] == '5') {
 5610               		.loc 1 2932 0
 5611 202a 8533      		cpi r24,lo8(53)
 5612 202c 01F4      		brne .L424
2933:switcherator.c ****         unformatAddress(rx_addr_p5, tempRadioString);
 5613               		.loc 1 2933 0
 5614 202e 2091 0000 		lds r18,rx_addr_p5
 5615 2032 3091 0000 		lds r19,rx_addr_p5+1
 5616 2036 4091 0000 		lds r20,rx_addr_p5+2
 5617 203a 5091 0000 		lds r21,rx_addr_p5+3
 5618 203e 6091 0000 		lds r22,rx_addr_p5+4
 5619 2042 7091 0000 		lds r23,rx_addr_p5+5
 5620 2046 8E01      		movw r16,r28
 5621 2048 0F5F      		subi r16,-1
 5622 204a 1F4F      		sbci r17,-1
 5623 204c 8091 0000 		lds r24,rx_addr_p5+6
 5624 2050 9091 0000 		lds r25,rx_addr_p5+7
 5625 2054 0E94 0000 		call unformatAddress
 5626               	.LVL395:
2934:switcherator.c ****         strcat(statusMsg, "r5-0x");
 5627               		.loc 1 2934 0
 5628 2058 60E0      		ldi r22,lo8(.LC19)
 5629 205a 70E0      		ldi r23,hi8(.LC19)
 5630 205c 00C0      		rjmp .L427
 5631               	.LVL396:
 5632               	.L424:
2935:switcherator.c ****     } else if (commandReceived[3] == 'T') {
 5633               		.loc 1 2935 0
 5634 205e 8435      		cpi r24,lo8(84)
 5635 2060 01F4      		brne .L425
2936:switcherator.c ****         unformatAddress(tx_addr, tempRadioString);
 5636               		.loc 1 2936 0
 5637 2062 2091 0000 		lds r18,tx_addr
 5638 2066 3091 0000 		lds r19,tx_addr+1
 5639 206a 4091 0000 		lds r20,tx_addr+2
 5640 206e 5091 0000 		lds r21,tx_addr+3
 5641 2072 6091 0000 		lds r22,tx_addr+4
 5642 2076 7091 0000 		lds r23,tx_addr+5
 5643 207a 8E01      		movw r16,r28
 5644 207c 0F5F      		subi r16,-1
 5645 207e 1F4F      		sbci r17,-1
 5646 2080 8091 0000 		lds r24,tx_addr+6
 5647 2084 9091 0000 		lds r25,tx_addr+7
 5648 2088 0E94 0000 		call unformatAddress
 5649               	.LVL397:
2937:switcherator.c ****         strcat(statusMsg, "t-0x");
 5650               		.loc 1 2937 0
 5651 208c 60E0      		ldi r22,lo8(.LC20)
 5652 208e 70E0      		ldi r23,hi8(.LC20)
 5653 2090 00C0      		rjmp .L427
 5654               	.LVL398:
 5655               	.L425:
2939:switcherator.c ****         unformatAddress(rx_addr_p0, tempRadioString);
 5656               		.loc 1 2939 0
 5657 2092 2091 0000 		lds r18,rx_addr_p0
 5658 2096 3091 0000 		lds r19,rx_addr_p0+1
 5659 209a 4091 0000 		lds r20,rx_addr_p0+2
 5660 209e 5091 0000 		lds r21,rx_addr_p0+3
 5661 20a2 6091 0000 		lds r22,rx_addr_p0+4
 5662 20a6 7091 0000 		lds r23,rx_addr_p0+5
 5663 20aa 8E01      		movw r16,r28
 5664 20ac 0F5F      		subi r16,-1
 5665 20ae 1F4F      		sbci r17,-1
 5666 20b0 8091 0000 		lds r24,rx_addr_p0+6
 5667 20b4 9091 0000 		lds r25,rx_addr_p0+7
 5668 20b8 0E94 0000 		call unformatAddress
 5669               	.LVL399:
2940:switcherator.c ****         strcat(statusMsg, "r0-0x");
 5670               		.loc 1 2940 0
 5671 20bc 60E0      		ldi r22,lo8(.LC21)
 5672 20be 70E0      		ldi r23,hi8(.LC21)
 5673 20c0 00C0      		rjmp .L427
 5674               	.LVL400:
 5675               	.L419:
2943:switcherator.c ****         returnHexWithout(tempRadioString[x], tempLongString);
 5676               		.loc 1 2943 0 discriminator 2
 5677 20c2 60E0      		ldi r22,lo8(tempLongString)
 5678 20c4 70E0      		ldi r23,hi8(tempLongString)
 5679 20c6 F801      		movw r30,r16
 5680 20c8 8191      		ld r24,Z+
 5681 20ca 8F01      		movw r16,r30
 5682 20cc 90E0      		ldi r25,0
 5683 20ce 0E94 0000 		call returnHexWithout
 5684               	.LVL401:
2944:switcherator.c ****         strcat(statusMsg, tempLongString);
 5685               		.loc 1 2944 0 discriminator 2
 5686 20d2 60E0      		ldi r22,lo8(tempLongString)
 5687 20d4 70E0      		ldi r23,hi8(tempLongString)
 5688 20d6 80E0      		ldi r24,lo8(statusMsg)
 5689 20d8 90E0      		ldi r25,hi8(statusMsg)
 5690 20da 0E94 0000 		call strcat
 5691               	.LVL402:
2942:switcherator.c ****     for (x = 0; x < 5; x++) {
 5692               		.loc 1 2942 0 discriminator 2
 5693 20de 0E15      		cp r16,r14
 5694 20e0 1F05      		cpc r17,r15
 5695 20e2 01F4      		brne .L419
2946:switcherator.c ****     sendMessage(statusMsg);
 5696               		.loc 1 2946 0
 5697 20e4 80E0      		ldi r24,lo8(statusMsg)
 5698 20e6 90E0      		ldi r25,hi8(statusMsg)
 5699 20e8 0E94 0000 		call sendMessage
 5700               	.LVL403:
 5701               	/* epilogue start */
2947:switcherator.c **** }
 5702               		.loc 1 2947 0
 5703 20ec 2696      		adiw r28,6
 5704 20ee 0FB6      		in __tmp_reg__,__SREG__
 5705 20f0 F894      		cli
 5706 20f2 DEBF      		out __SP_H__,r29
 5707 20f4 0FBE      		out __SREG__,__tmp_reg__
 5708 20f6 CDBF      		out __SP_L__,r28
 5709 20f8 DF91      		pop r29
 5710 20fa CF91      		pop r28
 5711 20fc 1F91      		pop r17
 5712 20fe 0F91      		pop r16
 5713 2100 FF90      		pop r15
 5714 2102 EF90      		pop r14
 5715 2104 0895      		ret
 5716               	.LFE73:
 5718               		.section	.rodata.str1.1
 5719               	.LC22:
 5720 0068 5377 4F6E 		.string	"SwOn:"
 5720      3A00 
 5721               	.LC23:
 5722 006e 7900      		.string	"y"
 5723               	.LC24:
 5724 0070 6E00      		.string	"n"
 5725               		.text
 5726               	.global	switchesOn
 5728               	switchesOn:
 5729               	.LFB66:
2794:switcherator.c **** void switchesOn(void) {
 5730               		.loc 1 2794 0
 5731 2106 CF93      		push r28
 5732               	.LCFI146:
 5733 2108 DF93      		push r29
 5734               	.LCFI147:
 5735               	/* prologue: function */
 5736               	/* frame size = 0 */
 5737               	/* stack size = 2 */
 5738               	.L__stack_usage = 2
2795:switcherator.c ****     statusMsg[0] = 0;
 5739               		.loc 1 2795 0
 5740 210a 1092 0000 		sts statusMsg,__zero_reg__
2796:switcherator.c ****     strcat(statusMsg, "SwOn:");
 5741               		.loc 1 2796 0
 5742 210e 60E0      		ldi r22,lo8(.LC22)
 5743 2110 70E0      		ldi r23,hi8(.LC22)
 5744 2112 80E0      		ldi r24,lo8(statusMsg)
 5745 2114 90E0      		ldi r25,hi8(statusMsg)
 5746 2116 0E94 0000 		call strcat
 5747               	.LVL404:
 5748 211a C0E0      		ldi r28,lo8(switchStatus)
 5749 211c D0E0      		ldi r29,hi8(switchStatus)
 5750               	.LVL405:
 5751               	.L432:
2799:switcherator.c ****         if (switchStatus[x] > 0) {
 5752               		.loc 1 2799 0
 5753 211e 8991      		ld r24,Y+
 5754 2120 9991      		ld r25,Y+
 5755 2122 A991      		ld r26,Y+
 5756 2124 B991      		ld r27,Y+
 5757 2126 892B      		or r24,r25
 5758 2128 8A2B      		or r24,r26
 5759 212a 8B2B      		or r24,r27
 5760 212c 01F0      		breq .L429
2800:switcherator.c ****             strcat(statusMsg, "y");
 5761               		.loc 1 2800 0
 5762 212e 60E0      		ldi r22,lo8(.LC23)
 5763 2130 70E0      		ldi r23,hi8(.LC23)
 5764 2132 00C0      		rjmp .L434
 5765               	.L429:
2802:switcherator.c ****             strcat(statusMsg, "n");
 5766               		.loc 1 2802 0
 5767 2134 60E0      		ldi r22,lo8(.LC24)
 5768 2136 70E0      		ldi r23,hi8(.LC24)
 5769               	.L434:
 5770 2138 80E0      		ldi r24,lo8(statusMsg)
 5771 213a 90E0      		ldi r25,hi8(statusMsg)
 5772 213c 0E94 0000 		call strcat
 5773               	.LVL406:
2804:switcherator.c ****         if (strlen(statusMsg) > 30) {
 5774               		.loc 1 2804 0
 5775 2140 E0E0      		ldi r30,lo8(statusMsg)
 5776 2142 F0E0      		ldi r31,hi8(statusMsg)
 5777               		0:
 5778 2144 0190      		ld __tmp_reg__,Z+
 5779 2146 0020      		tst __tmp_reg__
 5780 2148 01F4      		brne 0b
 5781 214a 3197      		sbiw r30,1
 5782 214c E050      		subi r30,lo8(statusMsg)
 5783 214e F040      		sbci r31,hi8(statusMsg)
 5784 2150 7F97      		sbiw r30,31
 5785 2152 00F0      		brlo .L431
2805:switcherator.c ****             sendMessage(statusMsg);
 5786               		.loc 1 2805 0
 5787 2154 80E0      		ldi r24,lo8(statusMsg)
 5788 2156 90E0      		ldi r25,hi8(statusMsg)
 5789 2158 0E94 0000 		call sendMessage
 5790               	.LVL407:
2806:switcherator.c ****             statusMsg[5] = 0;
 5791               		.loc 1 2806 0
 5792 215c 1092 0000 		sts statusMsg+5,__zero_reg__
 5793               	.L431:
2798:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 5794               		.loc 1 2798 0
 5795 2160 80E0      		ldi r24,hi8(switchStatus+64)
 5796 2162 C030      		cpi r28,lo8(switchStatus+64)
 5797 2164 D807      		cpc r29,r24
 5798 2166 01F4      		brne .L432
2809:switcherator.c ****     sendMessage(statusMsg);
 5799               		.loc 1 2809 0
 5800 2168 80E0      		ldi r24,lo8(statusMsg)
 5801 216a 90E0      		ldi r25,hi8(statusMsg)
 5802               	/* epilogue start */
2810:switcherator.c **** }
 5803               		.loc 1 2810 0
 5804 216c DF91      		pop r29
 5805 216e CF91      		pop r28
2809:switcherator.c ****     sendMessage(statusMsg);
 5806               		.loc 1 2809 0
 5807 2170 0C94 0000 		jmp sendMessage
 5808               	.LVL408:
 5809               	.LFE66:
 5811               		.section	.rodata.str1.1
 5812               	.LC25:
 5813 0072 496E 703A 		.string	"Inp:"
 5813      00
 5814               		.text
 5815               	.global	inputsProgrammed
 5817               	inputsProgrammed:
 5818               	.LFB65:
2774:switcherator.c **** void inputsProgrammed(void) {
 5819               		.loc 1 2774 0
 5820 2174 CF93      		push r28
 5821               	.LCFI148:
 5822 2176 DF93      		push r29
 5823               	.LCFI149:
 5824               	/* prologue: function */
 5825               	/* frame size = 0 */
 5826               	/* stack size = 2 */
 5827               	.L__stack_usage = 2
2775:switcherator.c ****     statusMsg[0] = 0;
 5828               		.loc 1 2775 0
 5829 2178 1092 0000 		sts statusMsg,__zero_reg__
2776:switcherator.c ****     strcat(statusMsg, "Inp:");
 5830               		.loc 1 2776 0
 5831 217c 60E0      		ldi r22,lo8(.LC25)
 5832 217e 70E0      		ldi r23,hi8(.LC25)
 5833 2180 80E0      		ldi r24,lo8(statusMsg)
 5834 2182 90E0      		ldi r25,hi8(statusMsg)
 5835 2184 0E94 0000 		call strcat
 5836               	.LVL409:
 5837 2188 C0E0      		ldi r28,lo8(inputs)
 5838 218a D0E0      		ldi r29,hi8(inputs)
 5839               	.LVL410:
 5840               	.L439:
2779:switcherator.c ****         if (inputs[x][0] == 255) {
 5841               		.loc 1 2779 0
 5842 218c 8881      		ld r24,Y
 5843 218e 8F3F      		cpi r24,lo8(-1)
 5844 2190 01F4      		brne .L436
2780:switcherator.c ****             strcat(statusMsg, "n");
 5845               		.loc 1 2780 0
 5846 2192 60E0      		ldi r22,lo8(.LC24)
 5847 2194 70E0      		ldi r23,hi8(.LC24)
 5848 2196 00C0      		rjmp .L441
 5849               	.L436:
2782:switcherator.c ****             strcat(statusMsg, "y");
 5850               		.loc 1 2782 0
 5851 2198 60E0      		ldi r22,lo8(.LC23)
 5852 219a 70E0      		ldi r23,hi8(.LC23)
 5853               	.L441:
 5854 219c 80E0      		ldi r24,lo8(statusMsg)
 5855 219e 90E0      		ldi r25,hi8(statusMsg)
 5856 21a0 0E94 0000 		call strcat
 5857               	.LVL411:
2785:switcherator.c ****         if (strlen(statusMsg) > 30) {
 5858               		.loc 1 2785 0
 5859 21a4 E0E0      		ldi r30,lo8(statusMsg)
 5860 21a6 F0E0      		ldi r31,hi8(statusMsg)
 5861               		0:
 5862 21a8 0190      		ld __tmp_reg__,Z+
 5863 21aa 0020      		tst __tmp_reg__
 5864 21ac 01F4      		brne 0b
 5865 21ae 3197      		sbiw r30,1
 5866 21b0 E050      		subi r30,lo8(statusMsg)
 5867 21b2 F040      		sbci r31,hi8(statusMsg)
 5868 21b4 7F97      		sbiw r30,31
 5869 21b6 00F0      		brlo .L438
2786:switcherator.c ****             sendMessage(statusMsg);
 5870               		.loc 1 2786 0
 5871 21b8 80E0      		ldi r24,lo8(statusMsg)
 5872 21ba 90E0      		ldi r25,hi8(statusMsg)
 5873 21bc 0E94 0000 		call sendMessage
 5874               	.LVL412:
2787:switcherator.c ****             statusMsg[4] = 0;
 5875               		.loc 1 2787 0
 5876 21c0 1092 0000 		sts statusMsg+4,__zero_reg__
 5877               	.L438:
 5878 21c4 2896      		adiw r28,8
2778:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 5879               		.loc 1 2778 0
 5880 21c6 80E0      		ldi r24,hi8(inputs+32)
 5881 21c8 C030      		cpi r28,lo8(inputs+32)
 5882 21ca D807      		cpc r29,r24
 5883 21cc 01F4      		brne .L439
2790:switcherator.c ****     sendMessage(statusMsg);
 5884               		.loc 1 2790 0
 5885 21ce 80E0      		ldi r24,lo8(statusMsg)
 5886 21d0 90E0      		ldi r25,hi8(statusMsg)
 5887               	/* epilogue start */
2791:switcherator.c **** }
 5888               		.loc 1 2791 0
 5889 21d2 DF91      		pop r29
 5890 21d4 CF91      		pop r28
2790:switcherator.c ****     sendMessage(statusMsg);
 5891               		.loc 1 2790 0
 5892 21d6 0C94 0000 		jmp sendMessage
 5893               	.LVL413:
 5894               	.LFE65:
 5896               		.section	.rodata.str1.1
 5897               	.LC26:
 5898 0077 5377 693A 		.string	"Swi:"
 5898      00
 5899               		.text
 5900               	.global	switchesProgrammed
 5902               	switchesProgrammed:
 5903               	.LFB64:
2753:switcherator.c **** void switchesProgrammed(void) {
 5904               		.loc 1 2753 0
 5905 21da CF93      		push r28
 5906               	.LCFI150:
 5907 21dc DF93      		push r29
 5908               	.LCFI151:
 5909               	/* prologue: function */
 5910               	/* frame size = 0 */
 5911               	/* stack size = 2 */
 5912               	.L__stack_usage = 2
2754:switcherator.c ****     statusMsg[0] = 0;
 5913               		.loc 1 2754 0
 5914 21de 1092 0000 		sts statusMsg,__zero_reg__
2755:switcherator.c ****     strcat(statusMsg, "Swi:");
 5915               		.loc 1 2755 0
 5916 21e2 60E0      		ldi r22,lo8(.LC26)
 5917 21e4 70E0      		ldi r23,hi8(.LC26)
 5918 21e6 80E0      		ldi r24,lo8(statusMsg)
 5919 21e8 90E0      		ldi r25,hi8(statusMsg)
 5920 21ea 0E94 0000 		call strcat
 5921               	.LVL414:
 5922 21ee C0E0      		ldi r28,lo8(switchStuff)
 5923 21f0 D0E0      		ldi r29,hi8(switchStuff)
 5924               	.LVL415:
 5925               	.L446:
2759:switcherator.c ****         if (switchStuff[x] == 255) {
 5926               		.loc 1 2759 0
 5927 21f2 8991      		ld r24,Y+
 5928 21f4 8F3F      		cpi r24,lo8(-1)
 5929 21f6 01F4      		brne .L443
2760:switcherator.c ****             strcat(statusMsg, "n");
 5930               		.loc 1 2760 0
 5931 21f8 60E0      		ldi r22,lo8(.LC24)
 5932 21fa 70E0      		ldi r23,hi8(.LC24)
 5933 21fc 00C0      		rjmp .L448
 5934               	.L443:
2762:switcherator.c ****             strcat(statusMsg, "y");
 5935               		.loc 1 2762 0
 5936 21fe 60E0      		ldi r22,lo8(.LC23)
 5937 2200 70E0      		ldi r23,hi8(.LC23)
 5938               	.L448:
 5939 2202 80E0      		ldi r24,lo8(statusMsg)
 5940 2204 90E0      		ldi r25,hi8(statusMsg)
 5941 2206 0E94 0000 		call strcat
 5942               	.LVL416:
2765:switcherator.c ****         if (strlen(statusMsg) > 30) {
 5943               		.loc 1 2765 0
 5944 220a E0E0      		ldi r30,lo8(statusMsg)
 5945 220c F0E0      		ldi r31,hi8(statusMsg)
 5946               		0:
 5947 220e 0190      		ld __tmp_reg__,Z+
 5948 2210 0020      		tst __tmp_reg__
 5949 2212 01F4      		brne 0b
 5950 2214 3197      		sbiw r30,1
 5951 2216 E050      		subi r30,lo8(statusMsg)
 5952 2218 F040      		sbci r31,hi8(statusMsg)
 5953 221a 7F97      		sbiw r30,31
 5954 221c 00F0      		brlo .L445
2766:switcherator.c ****             sendMessage(statusMsg);
 5955               		.loc 1 2766 0
 5956 221e 80E0      		ldi r24,lo8(statusMsg)
 5957 2220 90E0      		ldi r25,hi8(statusMsg)
 5958 2222 0E94 0000 		call sendMessage
 5959               	.LVL417:
2767:switcherator.c ****             statusMsg[4] = 0;
 5960               		.loc 1 2767 0
 5961 2226 1092 0000 		sts statusMsg+4,__zero_reg__
 5962               	.L445:
2757:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 5963               		.loc 1 2757 0
 5964 222a 80E0      		ldi r24,hi8(switchStuff+16)
 5965 222c C030      		cpi r28,lo8(switchStuff+16)
 5966 222e D807      		cpc r29,r24
 5967 2230 01F4      		brne .L446
2770:switcherator.c ****     sendMessage(statusMsg);
 5968               		.loc 1 2770 0
 5969 2232 80E0      		ldi r24,lo8(statusMsg)
 5970 2234 90E0      		ldi r25,hi8(statusMsg)
 5971               	/* epilogue start */
2771:switcherator.c **** }
 5972               		.loc 1 2771 0
 5973 2236 DF91      		pop r29
 5974 2238 CF91      		pop r28
2770:switcherator.c ****     sendMessage(statusMsg);
 5975               		.loc 1 2770 0
 5976 223a 0C94 0000 		jmp sendMessage
 5977               	.LVL418:
 5978               	.LFE64:
 5980               		.section	.rodata.str1.1
 5981               	.LC27:
 5982 007c 5072 6F67 		.string	"Progs:"
 5982      733A 00
 5983               		.text
 5984               	.global	programsProgrammed
 5986               	programsProgrammed:
 5987               	.LFB63:
2734:switcherator.c **** void programsProgrammed(void) {
 5988               		.loc 1 2734 0
 5989 223e CF93      		push r28
 5990               	.LCFI152:
 5991 2240 DF93      		push r29
 5992               	.LCFI153:
 5993               	/* prologue: function */
 5994               	/* frame size = 0 */
 5995               	/* stack size = 2 */
 5996               	.L__stack_usage = 2
2735:switcherator.c ****     statusMsg[0] = 0;
 5997               		.loc 1 2735 0
 5998 2242 1092 0000 		sts statusMsg,__zero_reg__
2736:switcherator.c ****     strcat(statusMsg, "Progs:");
 5999               		.loc 1 2736 0
 6000 2246 60E0      		ldi r22,lo8(.LC27)
 6001 2248 70E0      		ldi r23,hi8(.LC27)
 6002 224a 80E0      		ldi r24,lo8(statusMsg)
 6003 224c 90E0      		ldi r25,hi8(statusMsg)
 6004 224e 0E94 0000 		call strcat
 6005               	.LVL419:
 6006 2252 C0E0      		ldi r28,lo8(weeklyProgram+1)
 6007 2254 D0E0      		ldi r29,hi8(weeklyProgram+1)
 6008               	.LVL420:
 6009               	.L453:
2734:switcherator.c **** void programsProgrammed(void) {
 6010               		.loc 1 2734 0
 6011 2256 FE01      		movw r30,r28
 6012 2258 3197      		sbiw r30,1
2739:switcherator.c ****         if (weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) {
 6013               		.loc 1 2739 0
 6014 225a 8081      		ld r24,Z
 6015 225c 8F3F      		cpi r24,lo8(-1)
 6016 225e 01F4      		brne .L450
2739:switcherator.c ****         if (weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) {
 6017               		.loc 1 2739 0 is_stmt 0 discriminator 1
 6018 2260 8881      		ld r24,Y
 6019 2262 8F3F      		cpi r24,lo8(-1)
 6020 2264 01F4      		brne .L450
2740:switcherator.c ****             strcat(statusMsg, "n");
 6021               		.loc 1 2740 0 is_stmt 1
 6022 2266 60E0      		ldi r22,lo8(.LC24)
 6023 2268 70E0      		ldi r23,hi8(.LC24)
 6024 226a 00C0      		rjmp .L455
 6025               	.L450:
2742:switcherator.c ****             strcat(statusMsg, "y");
 6026               		.loc 1 2742 0
 6027 226c 60E0      		ldi r22,lo8(.LC23)
 6028 226e 70E0      		ldi r23,hi8(.LC23)
 6029               	.L455:
 6030 2270 80E0      		ldi r24,lo8(statusMsg)
 6031 2272 90E0      		ldi r25,hi8(statusMsg)
 6032 2274 0E94 0000 		call strcat
 6033               	.LVL421:
2745:switcherator.c ****         if (strlen(statusMsg) > 30) {
 6034               		.loc 1 2745 0
 6035 2278 E0E0      		ldi r30,lo8(statusMsg)
 6036 227a F0E0      		ldi r31,hi8(statusMsg)
 6037               		0:
 6038 227c 0190      		ld __tmp_reg__,Z+
 6039 227e 0020      		tst __tmp_reg__
 6040 2280 01F4      		brne 0b
 6041 2282 3197      		sbiw r30,1
 6042 2284 E050      		subi r30,lo8(statusMsg)
 6043 2286 F040      		sbci r31,hi8(statusMsg)
 6044 2288 7F97      		sbiw r30,31
 6045 228a 00F0      		brlo .L452
2746:switcherator.c ****             sendMessage(statusMsg);
 6046               		.loc 1 2746 0
 6047 228c 80E0      		ldi r24,lo8(statusMsg)
 6048 228e 90E0      		ldi r25,hi8(statusMsg)
 6049 2290 0E94 0000 		call sendMessage
 6050               	.LVL422:
2747:switcherator.c ****             statusMsg[6] = 0;
 6051               		.loc 1 2747 0
 6052 2294 1092 0000 		sts statusMsg+6,__zero_reg__
 6053               	.L452:
 6054 2298 2A96      		adiw r28,10
2738:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 6055               		.loc 1 2738 0
 6056 229a 80E0      		ldi r24,hi8(weeklyProgram+201)
 6057 229c C030      		cpi r28,lo8(weeklyProgram+201)
 6058 229e D807      		cpc r29,r24
 6059 22a0 01F4      		brne .L453
2750:switcherator.c ****     sendMessage(statusMsg);    
 6060               		.loc 1 2750 0
 6061 22a2 80E0      		ldi r24,lo8(statusMsg)
 6062 22a4 90E0      		ldi r25,hi8(statusMsg)
 6063               	/* epilogue start */
2751:switcherator.c **** }
 6064               		.loc 1 2751 0
 6065 22a6 DF91      		pop r29
 6066 22a8 CF91      		pop r28
2750:switcherator.c ****     sendMessage(statusMsg);    
 6067               		.loc 1 2750 0
 6068 22aa 0C94 0000 		jmp sendMessage
 6069               	.LVL423:
 6070               	.LFE63:
 6072               		.section	.rodata.str1.1
 6073               	.LC28:
 6074 0083 5072 2C00 		.string	"Pr,"
 6075               	.LC29:
 6076 0087 2C53 772C 		.string	",Sw,"
 6076      00
 6077               	.LC30:
 6078 008c 2C49 6E2C 		.string	",In,"
 6078      00
 6079               	.LC31:
 6080 0091 2C4C 692C 		.string	",Li,"
 6080      00
 6081               	.LC32:
 6082 0096 2C43 432C 		.string	",CC,"
 6082      00
 6083               		.text
 6084               	.global	generalInformation
 6086               	generalInformation:
 6087               	.LFB62:
2670:switcherator.c **** void generalInformation(void) {
 6088               		.loc 1 2670 0
 6089               	/* prologue: function */
 6090               	/* frame size = 0 */
 6091               	/* stack size = 0 */
 6092               	.L__stack_usage = 0
2671:switcherator.c ****     statusMsg[0] = 0;
 6093               		.loc 1 2671 0
 6094 22ae 1092 0000 		sts statusMsg,__zero_reg__
2672:switcherator.c ****     strcat(statusMsg,"Pr,");
 6095               		.loc 1 2672 0
 6096 22b2 60E0      		ldi r22,lo8(.LC28)
 6097 22b4 70E0      		ldi r23,hi8(.LC28)
 6098 22b6 80E0      		ldi r24,lo8(statusMsg)
 6099 22b8 90E0      		ldi r25,hi8(statusMsg)
 6100 22ba 0E94 0000 		call strcat
 6101               	.LVL424:
 6102 22be E0E0      		ldi r30,lo8(weeklyProgram+1)
 6103 22c0 F0E0      		ldi r31,hi8(weeklyProgram+1)
2673:switcherator.c ****     int count = 0;
 6104               		.loc 1 2673 0
 6105 22c2 80E0      		ldi r24,0
 6106 22c4 90E0      		ldi r25,0
 6107               	.LVL425:
 6108               	.L459:
2670:switcherator.c **** void generalInformation(void) {
 6109               		.loc 1 2670 0
 6110 22c6 DF01      		movw r26,r30
 6111 22c8 1197      		sbiw r26,1
2676:switcherator.c ****         if(weeklyProgram[x][0] < 255 || weeklyProgram[x][1] < 255) 
 6112               		.loc 1 2676 0
 6113 22ca 2C91      		ld r18,X
 6114 22cc 2F3F      		cpi r18,lo8(-1)
 6115 22ce 01F4      		brne .L457
2676:switcherator.c ****         if(weeklyProgram[x][0] < 255 || weeklyProgram[x][1] < 255) 
 6116               		.loc 1 2676 0 is_stmt 0 discriminator 1
 6117 22d0 2081      		ld r18,Z
 6118 22d2 2F3F      		cpi r18,lo8(-1)
 6119 22d4 01F0      		breq .L458
 6120               	.L457:
2677:switcherator.c ****             count++;
 6121               		.loc 1 2677 0 is_stmt 1
 6122 22d6 0196      		adiw r24,1
 6123               	.LVL426:
 6124               	.L458:
 6125 22d8 3A96      		adiw r30,10
2675:switcherator.c ****     for(x=0;x<MAX_PROGRAM;x++) {
 6126               		.loc 1 2675 0
 6127 22da 20E0      		ldi r18,hi8(weeklyProgram+201)
 6128 22dc E030      		cpi r30,lo8(weeklyProgram+201)
 6129 22de F207      		cpc r31,r18
 6130 22e0 01F4      		brne .L459
2679:switcherator.c ****     returnInt(count,tempLongString);
 6131               		.loc 1 2679 0
 6132 22e2 60E0      		ldi r22,lo8(tempLongString)
 6133 22e4 70E0      		ldi r23,hi8(tempLongString)
 6134 22e6 0E94 0000 		call returnInt
 6135               	.LVL427:
2680:switcherator.c ****     strcat(statusMsg,tempLongString);
 6136               		.loc 1 2680 0
 6137 22ea 60E0      		ldi r22,lo8(tempLongString)
 6138 22ec 70E0      		ldi r23,hi8(tempLongString)
 6139 22ee 80E0      		ldi r24,lo8(statusMsg)
 6140 22f0 90E0      		ldi r25,hi8(statusMsg)
 6141 22f2 0E94 0000 		call strcat
 6142               	.LVL428:
2681:switcherator.c ****     strcat(statusMsg,"/");
 6143               		.loc 1 2681 0
 6144 22f6 60E0      		ldi r22,lo8(.LC3)
 6145 22f8 70E0      		ldi r23,hi8(.LC3)
 6146 22fa 80E0      		ldi r24,lo8(statusMsg)
 6147 22fc 90E0      		ldi r25,hi8(statusMsg)
 6148 22fe 0E94 0000 		call strcat
 6149               	.LVL429:
2682:switcherator.c ****     returnInt(MAX_PROGRAM,tempLongString);
 6150               		.loc 1 2682 0
 6151 2302 60E0      		ldi r22,lo8(tempLongString)
 6152 2304 70E0      		ldi r23,hi8(tempLongString)
 6153 2306 84E1      		ldi r24,lo8(20)
 6154 2308 90E0      		ldi r25,0
 6155 230a 0E94 0000 		call returnInt
 6156               	.LVL430:
2683:switcherator.c ****     strcat(statusMsg,tempLongString);
 6157               		.loc 1 2683 0
 6158 230e 60E0      		ldi r22,lo8(tempLongString)
 6159 2310 70E0      		ldi r23,hi8(tempLongString)
 6160 2312 80E0      		ldi r24,lo8(statusMsg)
 6161 2314 90E0      		ldi r25,hi8(statusMsg)
 6162 2316 0E94 0000 		call strcat
 6163               	.LVL431:
2684:switcherator.c ****     strcat(statusMsg,",Sw,");
 6164               		.loc 1 2684 0
 6165 231a 60E0      		ldi r22,lo8(.LC29)
 6166 231c 70E0      		ldi r23,hi8(.LC29)
 6167 231e 80E0      		ldi r24,lo8(statusMsg)
 6168 2320 90E0      		ldi r25,hi8(statusMsg)
 6169 2322 0E94 0000 		call strcat
 6170               	.LVL432:
 6171 2326 E0E0      		ldi r30,lo8(switchStuff)
 6172 2328 F0E0      		ldi r31,hi8(switchStuff)
2685:switcherator.c ****     count = 0;
 6173               		.loc 1 2685 0
 6174 232a 80E0      		ldi r24,0
 6175 232c 90E0      		ldi r25,0
 6176               	.LVL433:
 6177               	.L461:
2687:switcherator.c ****         if (switchStuff[x] < 255)
 6178               		.loc 1 2687 0
 6179 232e 2191      		ld r18,Z+
 6180 2330 2F3F      		cpi r18,lo8(-1)
 6181 2332 01F0      		breq .L460
2688:switcherator.c ****             count ++;
 6182               		.loc 1 2688 0
 6183 2334 0196      		adiw r24,1
 6184               	.LVL434:
 6185               	.L460:
2686:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 6186               		.loc 1 2686 0
 6187 2336 20E0      		ldi r18,hi8(switchStuff+16)
 6188 2338 E030      		cpi r30,lo8(switchStuff+16)
 6189 233a F207      		cpc r31,r18
 6190 233c 01F4      		brne .L461
2690:switcherator.c ****     returnInt(count,tempLongString);
 6191               		.loc 1 2690 0
 6192 233e 60E0      		ldi r22,lo8(tempLongString)
 6193 2340 70E0      		ldi r23,hi8(tempLongString)
 6194 2342 0E94 0000 		call returnInt
 6195               	.LVL435:
2691:switcherator.c ****     strcat(statusMsg,tempLongString);
 6196               		.loc 1 2691 0
 6197 2346 60E0      		ldi r22,lo8(tempLongString)
 6198 2348 70E0      		ldi r23,hi8(tempLongString)
 6199 234a 80E0      		ldi r24,lo8(statusMsg)
 6200 234c 90E0      		ldi r25,hi8(statusMsg)
 6201 234e 0E94 0000 		call strcat
 6202               	.LVL436:
2692:switcherator.c ****     strcat(statusMsg,"/");
 6203               		.loc 1 2692 0
 6204 2352 60E0      		ldi r22,lo8(.LC3)
 6205 2354 70E0      		ldi r23,hi8(.LC3)
 6206 2356 80E0      		ldi r24,lo8(statusMsg)
 6207 2358 90E0      		ldi r25,hi8(statusMsg)
 6208 235a 0E94 0000 		call strcat
 6209               	.LVL437:
2693:switcherator.c ****     returnInt(NUM_SWITCHES,tempLongString);
 6210               		.loc 1 2693 0
 6211 235e 60E0      		ldi r22,lo8(tempLongString)
 6212 2360 70E0      		ldi r23,hi8(tempLongString)
 6213 2362 80E1      		ldi r24,lo8(16)
 6214 2364 90E0      		ldi r25,0
 6215 2366 0E94 0000 		call returnInt
 6216               	.LVL438:
2694:switcherator.c ****     strcat(statusMsg,tempLongString);
 6217               		.loc 1 2694 0
 6218 236a 60E0      		ldi r22,lo8(tempLongString)
 6219 236c 70E0      		ldi r23,hi8(tempLongString)
 6220 236e 80E0      		ldi r24,lo8(statusMsg)
 6221 2370 90E0      		ldi r25,hi8(statusMsg)
 6222 2372 0E94 0000 		call strcat
 6223               	.LVL439:
2695:switcherator.c ****     sendMessage(statusMsg);
 6224               		.loc 1 2695 0
 6225 2376 80E0      		ldi r24,lo8(statusMsg)
 6226 2378 90E0      		ldi r25,hi8(statusMsg)
 6227 237a 0E94 0000 		call sendMessage
 6228               	.LVL440:
2696:switcherator.c ****     statusMsg[0] = 0;
 6229               		.loc 1 2696 0
 6230 237e 1092 0000 		sts statusMsg,__zero_reg__
2697:switcherator.c ****     strcat(statusMsg,",In,");
 6231               		.loc 1 2697 0
 6232 2382 60E0      		ldi r22,lo8(.LC30)
 6233 2384 70E0      		ldi r23,hi8(.LC30)
 6234 2386 80E0      		ldi r24,lo8(statusMsg)
 6235 2388 90E0      		ldi r25,hi8(statusMsg)
 6236 238a 0E94 0000 		call strcat
 6237               	.LVL441:
 6238 238e E0E0      		ldi r30,lo8(inputs)
 6239 2390 F0E0      		ldi r31,hi8(inputs)
2698:switcherator.c ****     count = 0;
 6240               		.loc 1 2698 0
 6241 2392 80E0      		ldi r24,0
 6242 2394 90E0      		ldi r25,0
 6243               	.LVL442:
 6244               	.L463:
2700:switcherator.c ****         if (inputs[x][0] < 255)
 6245               		.loc 1 2700 0
 6246 2396 2081      		ld r18,Z
 6247 2398 2F3F      		cpi r18,lo8(-1)
 6248 239a 01F0      		breq .L462
2701:switcherator.c ****             count ++;
 6249               		.loc 1 2701 0
 6250 239c 0196      		adiw r24,1
 6251               	.LVL443:
 6252               	.L462:
 6253 239e 3896      		adiw r30,8
2699:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 6254               		.loc 1 2699 0
 6255 23a0 20E0      		ldi r18,hi8(inputs+32)
 6256 23a2 E030      		cpi r30,lo8(inputs+32)
 6257 23a4 F207      		cpc r31,r18
 6258 23a6 01F4      		brne .L463
2703:switcherator.c ****     returnInt(count,tempLongString);
 6259               		.loc 1 2703 0
 6260 23a8 60E0      		ldi r22,lo8(tempLongString)
 6261 23aa 70E0      		ldi r23,hi8(tempLongString)
 6262 23ac 0E94 0000 		call returnInt
 6263               	.LVL444:
2704:switcherator.c ****     strcat(statusMsg,tempLongString);
 6264               		.loc 1 2704 0
 6265 23b0 60E0      		ldi r22,lo8(tempLongString)
 6266 23b2 70E0      		ldi r23,hi8(tempLongString)
 6267 23b4 80E0      		ldi r24,lo8(statusMsg)
 6268 23b6 90E0      		ldi r25,hi8(statusMsg)
 6269 23b8 0E94 0000 		call strcat
 6270               	.LVL445:
2705:switcherator.c ****     strcat(statusMsg,"/");
 6271               		.loc 1 2705 0
 6272 23bc 60E0      		ldi r22,lo8(.LC3)
 6273 23be 70E0      		ldi r23,hi8(.LC3)
 6274 23c0 80E0      		ldi r24,lo8(statusMsg)
 6275 23c2 90E0      		ldi r25,hi8(statusMsg)
 6276 23c4 0E94 0000 		call strcat
 6277               	.LVL446:
2706:switcherator.c ****     returnInt(NUM_INPUTS,tempLongString);
 6278               		.loc 1 2706 0
 6279 23c8 60E0      		ldi r22,lo8(tempLongString)
 6280 23ca 70E0      		ldi r23,hi8(tempLongString)
 6281 23cc 84E0      		ldi r24,lo8(4)
 6282 23ce 90E0      		ldi r25,0
 6283 23d0 0E94 0000 		call returnInt
 6284               	.LVL447:
2707:switcherator.c ****     strcat(statusMsg,tempLongString);
 6285               		.loc 1 2707 0
 6286 23d4 60E0      		ldi r22,lo8(tempLongString)
 6287 23d6 70E0      		ldi r23,hi8(tempLongString)
 6288 23d8 80E0      		ldi r24,lo8(statusMsg)
 6289 23da 90E0      		ldi r25,hi8(statusMsg)
 6290 23dc 0E94 0000 		call strcat
 6291               	.LVL448:
2708:switcherator.c ****     strcat(statusMsg,",Li,");
 6292               		.loc 1 2708 0
 6293 23e0 60E0      		ldi r22,lo8(.LC31)
 6294 23e2 70E0      		ldi r23,hi8(.LC31)
 6295 23e4 80E0      		ldi r24,lo8(statusMsg)
 6296 23e6 90E0      		ldi r25,hi8(statusMsg)
 6297 23e8 0E94 0000 		call strcat
 6298               	.LVL449:
 6299 23ec E0E0      		ldi r30,lo8(inputs+2)
 6300 23ee F0E0      		ldi r31,hi8(inputs+2)
2709:switcherator.c ****     count = 0;
 6301               		.loc 1 2709 0
 6302 23f0 80E0      		ldi r24,0
 6303 23f2 90E0      		ldi r25,0
 6304               	.LVL450:
 6305               	.L465:
2711:switcherator.c ****         if (inputs[x][2] > 0)
 6306               		.loc 1 2711 0
 6307 23f4 2081      		ld r18,Z
 6308 23f6 2111      		cpse r18,__zero_reg__
2712:switcherator.c ****             count ++;
 6309               		.loc 1 2712 0
 6310 23f8 0196      		adiw r24,1
 6311               	.LVL451:
 6312               	.L464:
 6313 23fa 3896      		adiw r30,8
2710:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++) {
 6314               		.loc 1 2710 0
 6315 23fc 20E0      		ldi r18,hi8(inputs+34)
 6316 23fe E030      		cpi r30,lo8(inputs+34)
 6317 2400 F207      		cpc r31,r18
 6318 2402 01F4      		brne .L465
2714:switcherator.c ****     returnInt(count,tempLongString);
 6319               		.loc 1 2714 0
 6320 2404 60E0      		ldi r22,lo8(tempLongString)
 6321 2406 70E0      		ldi r23,hi8(tempLongString)
 6322 2408 0E94 0000 		call returnInt
 6323               	.LVL452:
2715:switcherator.c ****     strcat(statusMsg,tempLongString);
 6324               		.loc 1 2715 0
 6325 240c 60E0      		ldi r22,lo8(tempLongString)
 6326 240e 70E0      		ldi r23,hi8(tempLongString)
 6327 2410 80E0      		ldi r24,lo8(statusMsg)
 6328 2412 90E0      		ldi r25,hi8(statusMsg)
 6329 2414 0E94 0000 		call strcat
 6330               	.LVL453:
2716:switcherator.c ****     strcat(statusMsg,"/");
 6331               		.loc 1 2716 0
 6332 2418 60E0      		ldi r22,lo8(.LC3)
 6333 241a 70E0      		ldi r23,hi8(.LC3)
 6334 241c 80E0      		ldi r24,lo8(statusMsg)
 6335 241e 90E0      		ldi r25,hi8(statusMsg)
 6336 2420 0E94 0000 		call strcat
 6337               	.LVL454:
2717:switcherator.c ****     returnInt(NUM_LIMITS,tempLongString);
 6338               		.loc 1 2717 0
 6339 2424 60E0      		ldi r22,lo8(tempLongString)
 6340 2426 70E0      		ldi r23,hi8(tempLongString)
 6341 2428 84E0      		ldi r24,lo8(4)
 6342 242a 90E0      		ldi r25,0
 6343 242c 0E94 0000 		call returnInt
 6344               	.LVL455:
2718:switcherator.c ****     strcat(statusMsg,tempLongString);
 6345               		.loc 1 2718 0
 6346 2430 60E0      		ldi r22,lo8(tempLongString)
 6347 2432 70E0      		ldi r23,hi8(tempLongString)
 6348 2434 80E0      		ldi r24,lo8(statusMsg)
 6349 2436 90E0      		ldi r25,hi8(statusMsg)
 6350 2438 0E94 0000 		call strcat
 6351               	.LVL456:
2719:switcherator.c ****     strcat(statusMsg,",CC,");
 6352               		.loc 1 2719 0
 6353 243c 60E0      		ldi r22,lo8(.LC32)
 6354 243e 70E0      		ldi r23,hi8(.LC32)
 6355 2440 80E0      		ldi r24,lo8(statusMsg)
 6356 2442 90E0      		ldi r25,hi8(statusMsg)
 6357 2444 0E94 0000 		call strcat
 6358               	.LVL457:
 6359 2448 E0E0      		ldi r30,lo8(colorChanges+2)
 6360 244a F0E0      		ldi r31,hi8(colorChanges+2)
2720:switcherator.c ****     count = 0;
 6361               		.loc 1 2720 0
 6362 244c 80E0      		ldi r24,0
 6363 244e 90E0      		ldi r25,0
 6364               	.LVL458:
 6365               	.L468:
2670:switcherator.c **** void generalInformation(void) {
 6366               		.loc 1 2670 0
 6367 2450 DF01      		movw r26,r30
 6368 2452 1297      		sbiw r26,2
2722:switcherator.c ****         if (colorChanges[x][0] != 0 || colorChanges[x][1] != 1 || colorChanges[x][2] != 0)
 6369               		.loc 1 2722 0
 6370 2454 2C91      		ld r18,X
 6371 2456 2111      		cpse r18,__zero_reg__
 6372 2458 00C0      		rjmp .L466
2670:switcherator.c **** void generalInformation(void) {
 6373               		.loc 1 2670 0 discriminator 1
 6374 245a DF01      		movw r26,r30
 6375 245c 1197      		sbiw r26,1
2722:switcherator.c ****         if (colorChanges[x][0] != 0 || colorChanges[x][1] != 1 || colorChanges[x][2] != 0)
 6376               		.loc 1 2722 0 discriminator 1
 6377 245e 2C91      		ld r18,X
 6378 2460 2130      		cpi r18,lo8(1)
 6379 2462 01F4      		brne .L466
 6380 2464 2081      		ld r18,Z
 6381 2466 2111      		cpse r18,__zero_reg__
 6382               	.L466:
2723:switcherator.c ****             count ++;
 6383               		.loc 1 2723 0
 6384 2468 0196      		adiw r24,1
 6385               	.LVL459:
 6386               	.L467:
 6387 246a 3396      		adiw r30,3
2721:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 6388               		.loc 1 2721 0
 6389 246c 20E0      		ldi r18,hi8(colorChanges+20)
 6390 246e E030      		cpi r30,lo8(colorChanges+20)
 6391 2470 F207      		cpc r31,r18
 6392 2472 01F4      		brne .L468
2725:switcherator.c ****     returnInt(count,tempLongString);
 6393               		.loc 1 2725 0
 6394 2474 60E0      		ldi r22,lo8(tempLongString)
 6395 2476 70E0      		ldi r23,hi8(tempLongString)
 6396 2478 0E94 0000 		call returnInt
 6397               	.LVL460:
2726:switcherator.c ****     strcat(statusMsg,tempLongString);
 6398               		.loc 1 2726 0
 6399 247c 60E0      		ldi r22,lo8(tempLongString)
 6400 247e 70E0      		ldi r23,hi8(tempLongString)
 6401 2480 80E0      		ldi r24,lo8(statusMsg)
 6402 2482 90E0      		ldi r25,hi8(statusMsg)
 6403 2484 0E94 0000 		call strcat
 6404               	.LVL461:
2727:switcherator.c ****     strcat(statusMsg,"/");
 6405               		.loc 1 2727 0
 6406 2488 60E0      		ldi r22,lo8(.LC3)
 6407 248a 70E0      		ldi r23,hi8(.LC3)
 6408 248c 80E0      		ldi r24,lo8(statusMsg)
 6409 248e 90E0      		ldi r25,hi8(statusMsg)
 6410 2490 0E94 0000 		call strcat
 6411               	.LVL462:
2728:switcherator.c ****     returnInt(NUM_COLOR_CHANGES,tempLongString);
 6412               		.loc 1 2728 0
 6413 2494 60E0      		ldi r22,lo8(tempLongString)
 6414 2496 70E0      		ldi r23,hi8(tempLongString)
 6415 2498 86E0      		ldi r24,lo8(6)
 6416 249a 90E0      		ldi r25,0
 6417 249c 0E94 0000 		call returnInt
 6418               	.LVL463:
2729:switcherator.c ****     strcat(statusMsg,tempLongString);
 6419               		.loc 1 2729 0
 6420 24a0 60E0      		ldi r22,lo8(tempLongString)
 6421 24a2 70E0      		ldi r23,hi8(tempLongString)
 6422 24a4 80E0      		ldi r24,lo8(statusMsg)
 6423 24a6 90E0      		ldi r25,hi8(statusMsg)
 6424 24a8 0E94 0000 		call strcat
 6425               	.LVL464:
2730:switcherator.c ****     sendMessage(statusMsg);
 6426               		.loc 1 2730 0
 6427 24ac 80E0      		ldi r24,lo8(statusMsg)
 6428 24ae 90E0      		ldi r25,hi8(statusMsg)
 6429 24b0 0C94 0000 		jmp sendMessage
 6430               	.LVL465:
 6431               	.LFE62:
 6433               		.section	.rodata.str1.1
 6434               	.LC33:
 6435 009b 2054 3A78 		.string	" T:xx/xx/xxxx xx:xx:xx"
 6435      782F 7878 
 6435      2F78 7878 
 6435      7820 7878 
 6435      3A78 783A 
 6436               	.LC34:
 6437 00b2 2054 3A00 		.string	" T:"
 6438               		.text
 6439               	.global	generalStatus
 6441               	generalStatus:
 6442               	.LFB61:
2630:switcherator.c **** void generalStatus(char * commandReceived) {
 6443               		.loc 1 2630 0
 6444               	.LVL466:
 6445 24b4 CF93      		push r28
 6446               	.LCFI154:
 6447 24b6 DF93      		push r29
 6448               	.LCFI155:
 6449               	/* prologue: function */
 6450               	/* frame size = 0 */
 6451               	/* stack size = 2 */
 6452               	.L__stack_usage = 2
 6453 24b8 EC01      		movw r28,r24
2631:switcherator.c ****     statusMsg[0] = 0;
 6454               		.loc 1 2631 0
 6455 24ba 1092 0000 		sts statusMsg,__zero_reg__
2632:switcherator.c ****     tempIntString[0] = commandReceived[2];
 6456               		.loc 1 2632 0
 6457 24be 8A81      		ldd r24,Y+2
 6458               	.LVL467:
 6459 24c0 8093 0000 		sts tempIntString,r24
2633:switcherator.c ****     tempIntString[1] = commandReceived[3];
 6460               		.loc 1 2633 0
 6461 24c4 8B81      		ldd r24,Y+3
 6462 24c6 8093 0000 		sts tempIntString+1,r24
2636:switcherator.c ****     if (panicMyClockIsNotSet == 1) {
 6463               		.loc 1 2636 0
 6464 24ca 8091 0000 		lds r24,panicMyClockIsNotSet
 6465 24ce 8130      		cpi r24,lo8(1)
 6466 24d0 01F4      		brne .L490
2637:switcherator.c ****         strcat(statusMsg, " T:xx/xx/xxxx xx:xx:xx");
 6467               		.loc 1 2637 0
 6468 24d2 60E0      		ldi r22,lo8(.LC33)
 6469 24d4 70E0      		ldi r23,hi8(.LC33)
 6470 24d6 00C0      		rjmp .L493
 6471               	.L490:
2639:switcherator.c ****         strcat(statusMsg, " T:");
 6472               		.loc 1 2639 0
 6473 24d8 60E0      		ldi r22,lo8(.LC34)
 6474 24da 70E0      		ldi r23,hi8(.LC34)
 6475 24dc 80E0      		ldi r24,lo8(statusMsg)
 6476 24de 90E0      		ldi r25,hi8(statusMsg)
 6477 24e0 0E94 0000 		call strcat
 6478               	.LVL468:
2640:switcherator.c ****         returnInt(globalMonth, tempLongString);
 6479               		.loc 1 2640 0
 6480 24e4 60E0      		ldi r22,lo8(tempLongString)
 6481 24e6 70E0      		ldi r23,hi8(tempLongString)
 6482 24e8 8091 0000 		lds r24,globalMonth
 6483 24ec 9091 0000 		lds r25,globalMonth+1
 6484 24f0 0E94 0000 		call returnInt
 6485               	.LVL469:
2641:switcherator.c ****         strcat(statusMsg, tempLongString);
 6486               		.loc 1 2641 0
 6487 24f4 60E0      		ldi r22,lo8(tempLongString)
 6488 24f6 70E0      		ldi r23,hi8(tempLongString)
 6489 24f8 80E0      		ldi r24,lo8(statusMsg)
 6490 24fa 90E0      		ldi r25,hi8(statusMsg)
 6491 24fc 0E94 0000 		call strcat
 6492               	.LVL470:
2642:switcherator.c ****         strcat(statusMsg, "/");
 6493               		.loc 1 2642 0
 6494 2500 60E0      		ldi r22,lo8(.LC3)
 6495 2502 70E0      		ldi r23,hi8(.LC3)
 6496 2504 80E0      		ldi r24,lo8(statusMsg)
 6497 2506 90E0      		ldi r25,hi8(statusMsg)
 6498 2508 0E94 0000 		call strcat
 6499               	.LVL471:
2643:switcherator.c ****         returnInt(globalDay, tempLongString);
 6500               		.loc 1 2643 0
 6501 250c 60E0      		ldi r22,lo8(tempLongString)
 6502 250e 70E0      		ldi r23,hi8(tempLongString)
 6503 2510 8091 0000 		lds r24,globalDay
 6504 2514 9091 0000 		lds r25,globalDay+1
 6505 2518 0E94 0000 		call returnInt
 6506               	.LVL472:
2644:switcherator.c ****         strcat(statusMsg, tempLongString);
 6507               		.loc 1 2644 0
 6508 251c 60E0      		ldi r22,lo8(tempLongString)
 6509 251e 70E0      		ldi r23,hi8(tempLongString)
 6510 2520 80E0      		ldi r24,lo8(statusMsg)
 6511 2522 90E0      		ldi r25,hi8(statusMsg)
 6512 2524 0E94 0000 		call strcat
 6513               	.LVL473:
2645:switcherator.c ****         strcat(statusMsg, "/");
 6514               		.loc 1 2645 0
 6515 2528 60E0      		ldi r22,lo8(.LC3)
 6516 252a 70E0      		ldi r23,hi8(.LC3)
 6517 252c 80E0      		ldi r24,lo8(statusMsg)
 6518 252e 90E0      		ldi r25,hi8(statusMsg)
 6519 2530 0E94 0000 		call strcat
 6520               	.LVL474:
2646:switcherator.c ****         returnInt(globalYear, tempLongString);
 6521               		.loc 1 2646 0
 6522 2534 60E0      		ldi r22,lo8(tempLongString)
 6523 2536 70E0      		ldi r23,hi8(tempLongString)
 6524 2538 8091 0000 		lds r24,globalYear
 6525 253c 9091 0000 		lds r25,globalYear+1
 6526 2540 0E94 0000 		call returnInt
 6527               	.LVL475:
2647:switcherator.c ****         strcat(statusMsg, tempLongString);
 6528               		.loc 1 2647 0
 6529 2544 60E0      		ldi r22,lo8(tempLongString)
 6530 2546 70E0      		ldi r23,hi8(tempLongString)
 6531 2548 80E0      		ldi r24,lo8(statusMsg)
 6532 254a 90E0      		ldi r25,hi8(statusMsg)
 6533 254c 0E94 0000 		call strcat
 6534               	.LVL476:
2648:switcherator.c ****         strcat(statusMsg, " ");
 6535               		.loc 1 2648 0
 6536 2550 60E0      		ldi r22,lo8(.LC2)
 6537 2552 70E0      		ldi r23,hi8(.LC2)
 6538 2554 80E0      		ldi r24,lo8(statusMsg)
 6539 2556 90E0      		ldi r25,hi8(statusMsg)
 6540 2558 0E94 0000 		call strcat
 6541               	.LVL477:
2649:switcherator.c ****         returnInt(globalHour, tempLongString);
 6542               		.loc 1 2649 0
 6543 255c 60E0      		ldi r22,lo8(tempLongString)
 6544 255e 70E0      		ldi r23,hi8(tempLongString)
 6545 2560 8091 0000 		lds r24,globalHour
 6546 2564 9091 0000 		lds r25,globalHour+1
 6547 2568 0E94 0000 		call returnInt
 6548               	.LVL478:
2650:switcherator.c ****         strcat(statusMsg, tempLongString);
 6549               		.loc 1 2650 0
 6550 256c 60E0      		ldi r22,lo8(tempLongString)
 6551 256e 70E0      		ldi r23,hi8(tempLongString)
 6552 2570 80E0      		ldi r24,lo8(statusMsg)
 6553 2572 90E0      		ldi r25,hi8(statusMsg)
 6554 2574 0E94 0000 		call strcat
 6555               	.LVL479:
2651:switcherator.c ****         strcat(statusMsg, ":");
 6556               		.loc 1 2651 0
 6557 2578 60E0      		ldi r22,lo8(.LC4)
 6558 257a 70E0      		ldi r23,hi8(.LC4)
 6559 257c 80E0      		ldi r24,lo8(statusMsg)
 6560 257e 90E0      		ldi r25,hi8(statusMsg)
 6561 2580 0E94 0000 		call strcat
 6562               	.LVL480:
2652:switcherator.c ****         returnInt(globalMinute, tempLongString);
 6563               		.loc 1 2652 0
 6564 2584 60E0      		ldi r22,lo8(tempLongString)
 6565 2586 70E0      		ldi r23,hi8(tempLongString)
 6566 2588 8091 0000 		lds r24,globalMinute
 6567 258c 9091 0000 		lds r25,globalMinute+1
 6568 2590 0E94 0000 		call returnInt
 6569               	.LVL481:
2653:switcherator.c ****         strcat(statusMsg, tempLongString);
 6570               		.loc 1 2653 0
 6571 2594 60E0      		ldi r22,lo8(tempLongString)
 6572 2596 70E0      		ldi r23,hi8(tempLongString)
 6573 2598 80E0      		ldi r24,lo8(statusMsg)
 6574 259a 90E0      		ldi r25,hi8(statusMsg)
 6575 259c 0E94 0000 		call strcat
 6576               	.LVL482:
2654:switcherator.c ****         strcat(statusMsg, ":");
 6577               		.loc 1 2654 0
 6578 25a0 60E0      		ldi r22,lo8(.LC4)
 6579 25a2 70E0      		ldi r23,hi8(.LC4)
 6580 25a4 80E0      		ldi r24,lo8(statusMsg)
 6581 25a6 90E0      		ldi r25,hi8(statusMsg)
 6582 25a8 0E94 0000 		call strcat
 6583               	.LVL483:
2655:switcherator.c ****         returnInt(globalSecond, tempLongString);
 6584               		.loc 1 2655 0
 6585 25ac 60E0      		ldi r22,lo8(tempLongString)
 6586 25ae 70E0      		ldi r23,hi8(tempLongString)
 6587 25b0 8091 0000 		lds r24,globalSecond
 6588 25b4 9091 0000 		lds r25,globalSecond+1
 6589 25b8 0E94 0000 		call returnInt
 6590               	.LVL484:
2656:switcherator.c ****         strcat(statusMsg, tempLongString);
 6591               		.loc 1 2656 0
 6592 25bc 60E0      		ldi r22,lo8(tempLongString)
 6593 25be 70E0      		ldi r23,hi8(tempLongString)
 6594               	.L493:
 6595 25c0 80E0      		ldi r24,lo8(statusMsg)
 6596 25c2 90E0      		ldi r25,hi8(statusMsg)
 6597 25c4 0E94 0000 		call strcat
 6598               	.LVL485:
2658:switcherator.c ****     sendMessage(statusMsg);
 6599               		.loc 1 2658 0
 6600 25c8 80E0      		ldi r24,lo8(statusMsg)
 6601 25ca 90E0      		ldi r25,hi8(statusMsg)
 6602 25cc 0E94 0000 		call sendMessage
 6603               	.LVL486:
2659:switcherator.c ****     statusMsg[0] = 0;
 6604               		.loc 1 2659 0
 6605 25d0 1092 0000 		sts statusMsg,__zero_reg__
2660:switcherator.c ****     if (commandReceived[2] == 'q')
 6606               		.loc 1 2660 0
 6607 25d4 8A81      		ldd r24,Y+2
 6608 25d6 8137      		cpi r24,lo8(113)
 6609 25d8 01F0      		breq .L489
2663:switcherator.c ****     programsProgrammed();
 6610               		.loc 1 2663 0
 6611 25da 0E94 0000 		call programsProgrammed
 6612               	.LVL487:
2664:switcherator.c ****     switchesProgrammed();
 6613               		.loc 1 2664 0
 6614 25de 0E94 0000 		call switchesProgrammed
 6615               	.LVL488:
2665:switcherator.c ****     inputsProgrammed();
 6616               		.loc 1 2665 0
 6617 25e2 0E94 0000 		call inputsProgrammed
 6618               	.LVL489:
 6619               	/* epilogue start */
2667:switcherator.c **** }
 6620               		.loc 1 2667 0
 6621 25e6 DF91      		pop r29
 6622 25e8 CF91      		pop r28
 6623               	.LVL490:
2666:switcherator.c ****     switchesOn();
 6624               		.loc 1 2666 0
 6625 25ea 0C94 0000 		jmp switchesOn
 6626               	.LVL491:
 6627               	.L489:
 6628               	/* epilogue start */
2667:switcherator.c **** }
 6629               		.loc 1 2667 0
 6630 25ee DF91      		pop r29
 6631 25f0 CF91      		pop r28
 6632               	.LVL492:
 6633 25f2 0895      		ret
 6634               	.LFE61:
 6636               		.section	.rodata.str1.1
 6637               	.LC35:
 6638 00b6 5072 6F67 		.string	"Prog#"
 6638      2300 
 6639               	.LC36:
 6640 00bc 626C 616E 		.string	"blank."
 6640      6B2E 00
 6641               	.LC37:
 6642 00c3 533A 2D00 		.string	"S:-"
 6643               	.LC38:
 6644 00c7 5300      		.string	"S"
 6645               	.LC39:
 6646 00c9 542D 00   		.string	"T-"
 6647               	.LC40:
 6648 00cc 2044 7572 		.string	" Dur:"
 6648      3A00 
 6649               	.LC41:
 6650 00d2 2044 3A00 		.string	" D:"
 6651               	.LC42:
 6652 00d6 2D2D 2D2D 		.string	"-------"
 6652      2D2D 2D00 
 6653               	.LC43:
 6654 00de 2D00      		.string	"-"
 6655               	.LC44:
 6656 00e0 4D00      		.string	"M"
 6657               	.LC45:
 6658 00e2 5400      		.string	"T"
 6659               	.LC46:
 6660 00e4 5700      		.string	"W"
 6661               	.LC47:
 6662 00e6 4600      		.string	"F"
 6663               		.text
 6664               	.global	programDisplay
 6666               	programDisplay:
 6667               	.LFB37:
1489:switcherator.c **** void programDisplay(char * commandReceived) {
 6668               		.loc 1 1489 0
 6669               	.LVL493:
 6670 25f4 8F92      		push r8
 6671               	.LCFI156:
 6672 25f6 9F92      		push r9
 6673               	.LCFI157:
 6674 25f8 AF92      		push r10
 6675               	.LCFI158:
 6676 25fa BF92      		push r11
 6677               	.LCFI159:
 6678 25fc CF92      		push r12
 6679               	.LCFI160:
 6680 25fe DF92      		push r13
 6681               	.LCFI161:
 6682 2600 EF92      		push r14
 6683               	.LCFI162:
 6684 2602 FF92      		push r15
 6685               	.LCFI163:
 6686 2604 0F93      		push r16
 6687               	.LCFI164:
 6688 2606 1F93      		push r17
 6689               	.LCFI165:
 6690 2608 CF93      		push r28
 6691               	.LCFI166:
 6692 260a DF93      		push r29
 6693               	.LCFI167:
 6694 260c CDB7      		in r28,__SP_L__
 6695 260e DEB7      		in r29,__SP_H__
 6696               	.LCFI168:
 6697 2610 6097      		sbiw r28,16
 6698               	.LCFI169:
 6699 2612 0FB6      		in __tmp_reg__,__SREG__
 6700 2614 F894      		cli
 6701 2616 DEBF      		out __SP_H__,r29
 6702 2618 0FBE      		out __SREG__,__tmp_reg__
 6703 261a CDBF      		out __SP_L__,r28
 6704               	/* prologue: function */
 6705               	/* frame size = 16 */
 6706               	/* stack size = 28 */
 6707               	.L__stack_usage = 28
 6708               	.LVL494:
1492:switcherator.c ****     tempIntString[0] = commandReceived[3];
 6709               		.loc 1 1492 0
 6710 261c FC01      		movw r30,r24
 6711 261e 2381      		ldd r18,Z+3
 6712 2620 2093 0000 		sts tempIntString,r18
1493:switcherator.c ****     tempIntString[1] = commandReceived[4];
 6713               		.loc 1 1493 0
 6714 2624 8481      		ldd r24,Z+4
 6715               	.LVL495:
 6716 2626 8093 0000 		sts tempIntString+1,r24
1494:switcherator.c ****     programNumber = atoi(tempIntString);
 6717               		.loc 1 1494 0
 6718 262a 80E0      		ldi r24,lo8(tempIntString)
 6719 262c 90E0      		ldi r25,hi8(tempIntString)
 6720 262e 0E94 0000 		call atoi
 6721               	.LVL496:
 6722 2632 8C01      		movw r16,r24
 6723               	.LVL497:
1495:switcherator.c ****     statusMsg[0] = 0;
 6724               		.loc 1 1495 0
 6725 2634 1092 0000 		sts statusMsg,__zero_reg__
1496:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 6726               		.loc 1 1496 0
 6727 2638 8AE0      		ldi r24,lo8(10)
 6728 263a 809F      		mul r24,r16
 6729 263c F001      		movw r30,r0
 6730 263e 819F      		mul r24,r17
 6731 2640 F00D      		add r31,r0
 6732 2642 1124      		clr __zero_reg__
 6733 2644 E050      		subi r30,lo8(-(weeklyProgram))
 6734 2646 F040      		sbci r31,hi8(-(weeklyProgram))
 6735 2648 8081      		ld r24,Z
 6736 264a 8F3F      		cpi r24,lo8(-1)
 6737 264c 01F4      		brne .L495
1496:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 6738               		.loc 1 1496 0 is_stmt 0 discriminator 1
 6739 264e 8181      		ldd r24,Z+1
 6740 2650 8F3F      		cpi r24,lo8(-1)
 6741 2652 01F4      		brne .L495
1497:switcherator.c ****         strcat(statusMsg, "Prog#");
 6742               		.loc 1 1497 0 is_stmt 1
 6743 2654 60E0      		ldi r22,lo8(.LC35)
 6744 2656 70E0      		ldi r23,hi8(.LC35)
 6745 2658 80E0      		ldi r24,lo8(statusMsg)
 6746 265a 90E0      		ldi r25,hi8(statusMsg)
 6747 265c 0E94 0000 		call strcat
 6748               	.LVL498:
1498:switcherator.c ****         returnInt(programNumber, tempIntString);
 6749               		.loc 1 1498 0
 6750 2660 60E0      		ldi r22,lo8(tempIntString)
 6751 2662 70E0      		ldi r23,hi8(tempIntString)
 6752 2664 C801      		movw r24,r16
 6753 2666 0E94 0000 		call returnInt
 6754               	.LVL499:
1499:switcherator.c ****         strcat(statusMsg, tempIntString);
 6755               		.loc 1 1499 0
 6756 266a 60E0      		ldi r22,lo8(tempIntString)
 6757 266c 70E0      		ldi r23,hi8(tempIntString)
 6758 266e 80E0      		ldi r24,lo8(statusMsg)
 6759 2670 90E0      		ldi r25,hi8(statusMsg)
 6760 2672 0E94 0000 		call strcat
 6761               	.LVL500:
1500:switcherator.c ****         strcat(statusMsg, "blank.");
 6762               		.loc 1 1500 0
 6763 2676 60E0      		ldi r22,lo8(.LC36)
 6764 2678 70E0      		ldi r23,hi8(.LC36)
 6765 267a 00C0      		rjmp .L524
 6766               	.L495:
1505:switcherator.c ****     switches[0] = 0;
 6767               		.loc 1 1505 0
 6768 267c 1982      		std Y+1,__zero_reg__
 6769               	.LVL501:
1507:switcherator.c ****     switchCount = programGetSwitches(programNumber, switches);
 6770               		.loc 1 1507 0
 6771 267e BE01      		movw r22,r28
 6772 2680 6F5F      		subi r22,-1
 6773 2682 7F4F      		sbci r23,-1
 6774 2684 C801      		movw r24,r16
 6775 2686 0E94 0000 		call programGetSwitches
 6776               	.LVL502:
 6777 268a 6C01      		movw r12,r24
 6778               	.LVL503:
1508:switcherator.c ****     statusMsg[0] = 0;
 6779               		.loc 1 1508 0
 6780 268c 1092 0000 		sts statusMsg,__zero_reg__
1509:switcherator.c ****     strcat(statusMsg, "Prog#");
 6781               		.loc 1 1509 0
 6782 2690 60E0      		ldi r22,lo8(.LC35)
 6783 2692 70E0      		ldi r23,hi8(.LC35)
 6784 2694 80E0      		ldi r24,lo8(statusMsg)
 6785 2696 90E0      		ldi r25,hi8(statusMsg)
 6786 2698 0E94 0000 		call strcat
 6787               	.LVL504:
1510:switcherator.c ****     itoa(programNumber, tempIntString, 10);
 6788               		.loc 1 1510 0
 6789 269c 4AE0      		ldi r20,lo8(10)
 6790 269e 50E0      		ldi r21,0
 6791 26a0 60E0      		ldi r22,lo8(tempIntString)
 6792 26a2 70E0      		ldi r23,hi8(tempIntString)
 6793 26a4 C801      		movw r24,r16
 6794 26a6 0E94 0000 		call itoa
 6795               	.LVL505:
1511:switcherator.c ****     strcat(statusMsg, tempIntString);
 6796               		.loc 1 1511 0
 6797 26aa 60E0      		ldi r22,lo8(tempIntString)
 6798 26ac 70E0      		ldi r23,hi8(tempIntString)
 6799 26ae 80E0      		ldi r24,lo8(statusMsg)
 6800 26b0 90E0      		ldi r25,hi8(statusMsg)
 6801 26b2 0E94 0000 		call strcat
 6802               	.LVL506:
1512:switcherator.c ****     if (switchCount == 0) {
 6803               		.loc 1 1512 0
 6804 26b6 C114      		cp r12,__zero_reg__
 6805 26b8 D104      		cpc r13,__zero_reg__
 6806 26ba 01F4      		brne .L497
1513:switcherator.c ****         strcat(switches, "S:-");
 6807               		.loc 1 1513 0
 6808 26bc 60E0      		ldi r22,lo8(.LC37)
 6809 26be 70E0      		ldi r23,hi8(.LC37)
 6810 26c0 CE01      		movw r24,r28
 6811 26c2 0196      		adiw r24,1
 6812 26c4 0E94 0000 		call strcat
 6813               	.LVL507:
 6814 26c8 00C0      		rjmp .L498
 6815               	.L497:
 6816               	.LVL508:
 6817               	.LBB27:
1516:switcherator.c ****         strcat(statusMsg, "S");
 6818               		.loc 1 1516 0
 6819 26ca 60E0      		ldi r22,lo8(.LC38)
 6820 26cc 70E0      		ldi r23,hi8(.LC38)
 6821 26ce 80E0      		ldi r24,lo8(statusMsg)
 6822 26d0 90E0      		ldi r25,hi8(statusMsg)
 6823 26d2 0E94 0000 		call strcat
 6824               	.LVL509:
 6825 26d6 EE24      		clr r14
 6826 26d8 E394      		inc r14
 6827 26da F12C      		mov r15,__zero_reg__
 6828 26dc EC0E      		add r14,r28
 6829 26de FD1E      		adc r15,r29
1489:switcherator.c **** void programDisplay(char * commandReceived) {
 6830               		.loc 1 1489 0
 6831 26e0 5701      		movw r10,r14
1518:switcherator.c ****             if(strlen(statusMsg)>30) {
 6832               		.loc 1 1518 0
 6833 26e2 70E0      		ldi r23,lo8(statusMsg)
 6834 26e4 872E      		mov r8,r23
 6835 26e6 70E0      		ldi r23,hi8(statusMsg)
 6836 26e8 972E      		mov r9,r23
1517:switcherator.c ****         for (x = 0; x < switchCount; x++) {
 6837               		.loc 1 1517 0
 6838 26ea 00C0      		rjmp .L499
 6839               	.LVL510:
 6840               	.L501:
1518:switcherator.c ****             if(strlen(statusMsg)>30) {
 6841               		.loc 1 1518 0
 6842 26ec F401      		movw r30,r8
 6843               		0:
 6844 26ee 0190      		ld __tmp_reg__,Z+
 6845 26f0 0020      		tst __tmp_reg__
 6846 26f2 01F4      		brne 0b
 6847 26f4 3197      		sbiw r30,1
 6848 26f6 E050      		subi r30,lo8(statusMsg)
 6849 26f8 F040      		sbci r31,hi8(statusMsg)
 6850 26fa 7F97      		sbiw r30,31
 6851 26fc 00F0      		brlo .L500
1519:switcherator.c ****                 sendMessage(statusMsg);
 6852               		.loc 1 1519 0
 6853 26fe 80E0      		ldi r24,lo8(statusMsg)
 6854 2700 90E0      		ldi r25,hi8(statusMsg)
 6855 2702 0E94 0000 		call sendMessage
 6856               	.LVL511:
1520:switcherator.c ****                 statusMsg[6] = 0;
 6857               		.loc 1 1520 0
 6858 2706 1092 0000 		sts statusMsg+6,__zero_reg__
 6859               	.L500:
1522:switcherator.c ****             strcat(statusMsg, ":");
 6860               		.loc 1 1522 0
 6861 270a 60E0      		ldi r22,lo8(.LC4)
 6862 270c 70E0      		ldi r23,hi8(.LC4)
 6863 270e 80E0      		ldi r24,lo8(statusMsg)
 6864 2710 90E0      		ldi r25,hi8(statusMsg)
 6865 2712 0E94 0000 		call strcat
 6866               	.LVL512:
1524:switcherator.c ****             itoa(temp, tempIntString, 10);
 6867               		.loc 1 1524 0
 6868 2716 4AE0      		ldi r20,lo8(10)
 6869 2718 50E0      		ldi r21,0
 6870 271a 60E0      		ldi r22,lo8(tempIntString)
 6871 271c 70E0      		ldi r23,hi8(tempIntString)
 6872 271e F701      		movw r30,r14
 6873 2720 8191      		ld r24,Z+
 6874 2722 7F01      		movw r14,r30
 6875               	.LVL513:
 6876 2724 90E0      		ldi r25,0
 6877 2726 0E94 0000 		call itoa
 6878               	.LVL514:
1525:switcherator.c ****             strcat(statusMsg, tempIntString);
 6879               		.loc 1 1525 0
 6880 272a 60E0      		ldi r22,lo8(tempIntString)
 6881 272c 70E0      		ldi r23,hi8(tempIntString)
 6882 272e 80E0      		ldi r24,lo8(statusMsg)
 6883 2730 90E0      		ldi r25,hi8(statusMsg)
 6884 2732 0E94 0000 		call strcat
 6885               	.LVL515:
 6886               	.L499:
1489:switcherator.c **** void programDisplay(char * commandReceived) {
 6887               		.loc 1 1489 0 discriminator 1
 6888 2736 C701      		movw r24,r14
 6889 2738 8A19      		sub r24,r10
 6890 273a 9B09      		sbc r25,r11
1517:switcherator.c ****         for (x = 0; x < switchCount; x++) {
 6891               		.loc 1 1517 0 discriminator 1
 6892 273c 8C15      		cp r24,r12
 6893 273e 9D05      		cpc r25,r13
 6894 2740 04F0      		brlt .L501
 6895               	.L498:
 6896               	.LBE27:
1528:switcherator.c ****     sendMessage(statusMsg);
 6897               		.loc 1 1528 0
 6898 2742 80E0      		ldi r24,lo8(statusMsg)
 6899 2744 90E0      		ldi r25,hi8(statusMsg)
 6900 2746 0E94 0000 		call sendMessage
 6901               	.LVL516:
1529:switcherator.c ****     statusMsg[0] = 0;
 6902               		.loc 1 1529 0
 6903 274a 1092 0000 		sts statusMsg,__zero_reg__
 6904               	.LVL517:
1531:switcherator.c ****     time = weeklyProgram[programNumber][1];
 6905               		.loc 1 1531 0
 6906 274e 8AE0      		ldi r24,lo8(10)
 6907 2750 809F      		mul r24,r16
 6908 2752 F001      		movw r30,r0
 6909 2754 819F      		mul r24,r17
 6910 2756 F00D      		add r31,r0
 6911 2758 1124      		clr __zero_reg__
 6912 275a E050      		subi r30,lo8(-(weeklyProgram))
 6913 275c F040      		sbci r31,hi8(-(weeklyProgram))
 6914               	.LVL518:
1532:switcherator.c ****     time <<= 8;
 6915               		.loc 1 1532 0
 6916 275e 9181      		ldd r25,Z+1
 6917 2760 80E0      		ldi r24,0
 6918               	.LVL519:
1533:switcherator.c ****     time |= weeklyProgram[programNumber][2];
 6919               		.loc 1 1533 0
 6920 2762 2281      		ldd r18,Z+2
 6921 2764 AC01      		movw r20,r24
 6922 2766 422B      		or r20,r18
 6923 2768 9A01      		movw r18,r20
 6924               	.LVL520:
1534:switcherator.c ****     unsigned int hours = (time / 60);
 6925               		.loc 1 1534 0
 6926 276a 5CE3      		ldi r21,lo8(60)
 6927 276c E52E      		mov r14,r21
 6928 276e F12C      		mov r15,__zero_reg__
 6929 2770 C901      		movw r24,r18
 6930 2772 B701      		movw r22,r14
 6931 2774 0E94 0000 		call __udivmodhi4
 6932 2778 8B01      		movw r16,r22
 6933               	.LVL521:
1535:switcherator.c ****     unsigned int minutes = (time - (hours * 60));
 6934               		.loc 1 1535 0
 6935 277a 4CE3      		ldi r20,lo8(60)
 6936 277c 469F      		mul r20,r22
 6937 277e C001      		movw r24,r0
 6938 2780 479F      		mul r20,r23
 6939 2782 900D      		add r25,r0
 6940 2784 1124      		clr __zero_reg__
 6941 2786 6901      		movw r12,r18
 6942               	.LVL522:
 6943 2788 C81A      		sub r12,r24
 6944 278a D90A      		sbc r13,r25
 6945               	.LVL523:
1537:switcherator.c ****     time <<= 8;
 6946               		.loc 1 1537 0
 6947 278c 3381      		ldd r19,Z+3
 6948 278e 20E0      		ldi r18,0
1538:switcherator.c ****     time |= weeklyProgram[programNumber][4];
 6949               		.loc 1 1538 0
 6950 2790 8481      		ldd r24,Z+4
 6951 2792 A901      		movw r20,r18
 6952 2794 482B      		or r20,r24
 6953 2796 CA01      		movw r24,r20
1539:switcherator.c ****     int duration = (time / 60);
 6954               		.loc 1 1539 0
 6955 2798 B701      		movw r22,r14
 6956 279a 0E94 0000 		call __udivmodhi4
 6957 279e B62E      		mov r11,r22
 6958 27a0 E72E      		mov r14,r23
 6959               	.LVL524:
1541:switcherator.c ****     weekdays = weeklyProgram[programNumber][0];
 6960               		.loc 1 1541 0
 6961 27a2 F080      		ld r15,Z
 6962               	.LVL525:
1542:switcherator.c ****     strcat(statusMsg, "T-");
 6963               		.loc 1 1542 0
 6964 27a4 60E0      		ldi r22,lo8(.LC39)
 6965 27a6 70E0      		ldi r23,hi8(.LC39)
 6966 27a8 80E0      		ldi r24,lo8(statusMsg)
 6967 27aa 90E0      		ldi r25,hi8(statusMsg)
 6968 27ac 0E94 0000 		call strcat
 6969               	.LVL526:
1543:switcherator.c ****     itoa(hours, tempIntString, 10);
 6970               		.loc 1 1543 0
 6971 27b0 4AE0      		ldi r20,lo8(10)
 6972 27b2 50E0      		ldi r21,0
 6973 27b4 60E0      		ldi r22,lo8(tempIntString)
 6974 27b6 70E0      		ldi r23,hi8(tempIntString)
 6975 27b8 C801      		movw r24,r16
 6976 27ba 0E94 0000 		call itoa
 6977               	.LVL527:
1544:switcherator.c ****     strcat(statusMsg, tempIntString);
 6978               		.loc 1 1544 0
 6979 27be 60E0      		ldi r22,lo8(tempIntString)
 6980 27c0 70E0      		ldi r23,hi8(tempIntString)
 6981 27c2 80E0      		ldi r24,lo8(statusMsg)
 6982 27c4 90E0      		ldi r25,hi8(statusMsg)
 6983 27c6 0E94 0000 		call strcat
 6984               	.LVL528:
1545:switcherator.c ****     strcat(statusMsg, ":");
 6985               		.loc 1 1545 0
 6986 27ca 60E0      		ldi r22,lo8(.LC4)
 6987 27cc 70E0      		ldi r23,hi8(.LC4)
 6988 27ce 80E0      		ldi r24,lo8(statusMsg)
 6989 27d0 90E0      		ldi r25,hi8(statusMsg)
 6990 27d2 0E94 0000 		call strcat
 6991               	.LVL529:
1546:switcherator.c ****     itoa(minutes, tempIntString, 10);
 6992               		.loc 1 1546 0
 6993 27d6 4AE0      		ldi r20,lo8(10)
 6994 27d8 50E0      		ldi r21,0
 6995 27da 60E0      		ldi r22,lo8(tempIntString)
 6996 27dc 70E0      		ldi r23,hi8(tempIntString)
 6997 27de C601      		movw r24,r12
 6998 27e0 0E94 0000 		call itoa
 6999               	.LVL530:
1547:switcherator.c ****     strcat(statusMsg, tempIntString);
 7000               		.loc 1 1547 0
 7001 27e4 60E0      		ldi r22,lo8(tempIntString)
 7002 27e6 70E0      		ldi r23,hi8(tempIntString)
 7003 27e8 80E0      		ldi r24,lo8(statusMsg)
 7004 27ea 90E0      		ldi r25,hi8(statusMsg)
 7005 27ec 0E94 0000 		call strcat
 7006               	.LVL531:
1548:switcherator.c ****     strcat(statusMsg, " Dur:");
 7007               		.loc 1 1548 0
 7008 27f0 60E0      		ldi r22,lo8(.LC40)
 7009 27f2 70E0      		ldi r23,hi8(.LC40)
 7010 27f4 80E0      		ldi r24,lo8(statusMsg)
 7011 27f6 90E0      		ldi r25,hi8(statusMsg)
 7012 27f8 0E94 0000 		call strcat
 7013               	.LVL532:
1549:switcherator.c ****     itoa(duration, tempLongString, 10);
 7014               		.loc 1 1549 0
 7015 27fc 4AE0      		ldi r20,lo8(10)
 7016 27fe 50E0      		ldi r21,0
 7017 2800 60E0      		ldi r22,lo8(tempLongString)
 7018 2802 70E0      		ldi r23,hi8(tempLongString)
 7019 2804 8B2D      		mov r24,r11
 7020 2806 9E2D      		mov r25,r14
 7021 2808 0E94 0000 		call itoa
 7022               	.LVL533:
1550:switcherator.c ****     strcat(statusMsg, tempLongString);
 7023               		.loc 1 1550 0
 7024 280c 60E0      		ldi r22,lo8(tempLongString)
 7025 280e 70E0      		ldi r23,hi8(tempLongString)
 7026 2810 80E0      		ldi r24,lo8(statusMsg)
 7027 2812 90E0      		ldi r25,hi8(statusMsg)
 7028 2814 0E94 0000 		call strcat
 7029               	.LVL534:
1551:switcherator.c ****     strcat(statusMsg, " D:");
 7030               		.loc 1 1551 0
 7031 2818 60E0      		ldi r22,lo8(.LC41)
 7032 281a 70E0      		ldi r23,hi8(.LC41)
 7033 281c 80E0      		ldi r24,lo8(statusMsg)
 7034 281e 90E0      		ldi r25,hi8(statusMsg)
 7035 2820 0E94 0000 		call strcat
 7036               	.LVL535:
1552:switcherator.c ****     if (weekdays == 255) {
 7037               		.loc 1 1552 0
 7038 2824 5FEF      		ldi r21,lo8(-1)
 7039 2826 F512      		cpse r15,r21
 7040 2828 00C0      		rjmp .L502
1553:switcherator.c ****         strcat(statusMsg, "-------");
 7041               		.loc 1 1553 0
 7042 282a 60E0      		ldi r22,lo8(.LC42)
 7043 282c 70E0      		ldi r23,hi8(.LC42)
 7044 282e 00C0      		rjmp .L524
 7045               	.L502:
1557:switcherator.c ****     if (weekdays & 0x40) {
 7046               		.loc 1 1557 0
 7047 2830 F6FE      		sbrs r15,6
 7048 2832 00C0      		rjmp .L503
1558:switcherator.c ****         strcat(statusMsg, "S");
 7049               		.loc 1 1558 0
 7050 2834 60E0      		ldi r22,lo8(.LC38)
 7051 2836 70E0      		ldi r23,hi8(.LC38)
 7052 2838 00C0      		rjmp .L518
 7053               	.L503:
1560:switcherator.c ****         strcat(statusMsg, "-");
 7054               		.loc 1 1560 0
 7055 283a 60E0      		ldi r22,lo8(.LC43)
 7056 283c 70E0      		ldi r23,hi8(.LC43)
 7057               	.L518:
 7058 283e 80E0      		ldi r24,lo8(statusMsg)
 7059 2840 90E0      		ldi r25,hi8(statusMsg)
 7060 2842 0E94 0000 		call strcat
 7061               	.LVL536:
1562:switcherator.c ****     if (weekdays & 0x20) {
 7062               		.loc 1 1562 0
 7063 2846 F5FE      		sbrs r15,5
 7064 2848 00C0      		rjmp .L505
1563:switcherator.c ****         strcat(statusMsg, "M");
 7065               		.loc 1 1563 0
 7066 284a 60E0      		ldi r22,lo8(.LC44)
 7067 284c 70E0      		ldi r23,hi8(.LC44)
 7068 284e 00C0      		rjmp .L519
 7069               	.L505:
1565:switcherator.c ****         strcat(statusMsg, "-");
 7070               		.loc 1 1565 0
 7071 2850 60E0      		ldi r22,lo8(.LC43)
 7072 2852 70E0      		ldi r23,hi8(.LC43)
 7073               	.L519:
 7074 2854 80E0      		ldi r24,lo8(statusMsg)
 7075 2856 90E0      		ldi r25,hi8(statusMsg)
 7076 2858 0E94 0000 		call strcat
 7077               	.LVL537:
1567:switcherator.c ****     if (weekdays & 0x10) {
 7078               		.loc 1 1567 0
 7079 285c F4FE      		sbrs r15,4
 7080 285e 00C0      		rjmp .L507
1568:switcherator.c ****         strcat(statusMsg, "T");
 7081               		.loc 1 1568 0
 7082 2860 60E0      		ldi r22,lo8(.LC45)
 7083 2862 70E0      		ldi r23,hi8(.LC45)
 7084 2864 00C0      		rjmp .L520
 7085               	.L507:
1570:switcherator.c ****         strcat(statusMsg, "-");
 7086               		.loc 1 1570 0
 7087 2866 60E0      		ldi r22,lo8(.LC43)
 7088 2868 70E0      		ldi r23,hi8(.LC43)
 7089               	.L520:
 7090 286a 80E0      		ldi r24,lo8(statusMsg)
 7091 286c 90E0      		ldi r25,hi8(statusMsg)
 7092 286e 0E94 0000 		call strcat
 7093               	.LVL538:
1572:switcherator.c ****     if (weekdays & 0x08) {
 7094               		.loc 1 1572 0
 7095 2872 F3FE      		sbrs r15,3
 7096 2874 00C0      		rjmp .L509
1573:switcherator.c ****         strcat(statusMsg, "W");
 7097               		.loc 1 1573 0
 7098 2876 60E0      		ldi r22,lo8(.LC46)
 7099 2878 70E0      		ldi r23,hi8(.LC46)
 7100 287a 00C0      		rjmp .L521
 7101               	.L509:
1575:switcherator.c ****         strcat(statusMsg, "-");
 7102               		.loc 1 1575 0
 7103 287c 60E0      		ldi r22,lo8(.LC43)
 7104 287e 70E0      		ldi r23,hi8(.LC43)
 7105               	.L521:
 7106 2880 80E0      		ldi r24,lo8(statusMsg)
 7107 2882 90E0      		ldi r25,hi8(statusMsg)
 7108 2884 0E94 0000 		call strcat
 7109               	.LVL539:
1577:switcherator.c ****     if (weekdays & 0x04) {
 7110               		.loc 1 1577 0
 7111 2888 F2FE      		sbrs r15,2
 7112 288a 00C0      		rjmp .L511
1578:switcherator.c ****         strcat(statusMsg, "T");
 7113               		.loc 1 1578 0
 7114 288c 60E0      		ldi r22,lo8(.LC45)
 7115 288e 70E0      		ldi r23,hi8(.LC45)
 7116 2890 00C0      		rjmp .L522
 7117               	.L511:
1580:switcherator.c ****         strcat(statusMsg, "-");
 7118               		.loc 1 1580 0
 7119 2892 60E0      		ldi r22,lo8(.LC43)
 7120 2894 70E0      		ldi r23,hi8(.LC43)
 7121               	.L522:
 7122 2896 80E0      		ldi r24,lo8(statusMsg)
 7123 2898 90E0      		ldi r25,hi8(statusMsg)
 7124 289a 0E94 0000 		call strcat
 7125               	.LVL540:
1582:switcherator.c ****     if (weekdays & 0x02) {
 7126               		.loc 1 1582 0
 7127 289e F1FE      		sbrs r15,1
 7128 28a0 00C0      		rjmp .L513
1583:switcherator.c ****         strcat(statusMsg, "F");
 7129               		.loc 1 1583 0
 7130 28a2 60E0      		ldi r22,lo8(.LC47)
 7131 28a4 70E0      		ldi r23,hi8(.LC47)
 7132 28a6 00C0      		rjmp .L523
 7133               	.L513:
1585:switcherator.c ****         strcat(statusMsg, "-");
 7134               		.loc 1 1585 0
 7135 28a8 60E0      		ldi r22,lo8(.LC43)
 7136 28aa 70E0      		ldi r23,hi8(.LC43)
 7137               	.L523:
 7138 28ac 80E0      		ldi r24,lo8(statusMsg)
 7139 28ae 90E0      		ldi r25,hi8(statusMsg)
 7140 28b0 0E94 0000 		call strcat
 7141               	.LVL541:
1587:switcherator.c ****     if (weekdays & 0x01) {
 7142               		.loc 1 1587 0
 7143 28b4 F0FE      		sbrs r15,0
 7144 28b6 00C0      		rjmp .L515
1588:switcherator.c ****         strcat(statusMsg, "S");
 7145               		.loc 1 1588 0
 7146 28b8 60E0      		ldi r22,lo8(.LC38)
 7147 28ba 70E0      		ldi r23,hi8(.LC38)
 7148 28bc 00C0      		rjmp .L524
 7149               	.L515:
1590:switcherator.c ****         strcat(statusMsg, "-");
 7150               		.loc 1 1590 0
 7151 28be 60E0      		ldi r22,lo8(.LC43)
 7152 28c0 70E0      		ldi r23,hi8(.LC43)
 7153               	.LVL542:
 7154               	.L524:
 7155 28c2 80E0      		ldi r24,lo8(statusMsg)
 7156 28c4 90E0      		ldi r25,hi8(statusMsg)
 7157 28c6 0E94 0000 		call strcat
 7158               	.LVL543:
1593:switcherator.c ****     sendMessage(statusMsg);
 7159               		.loc 1 1593 0
 7160 28ca 80E0      		ldi r24,lo8(statusMsg)
 7161 28cc 90E0      		ldi r25,hi8(statusMsg)
 7162 28ce 0E94 0000 		call sendMessage
 7163               	.LVL544:
 7164               	/* epilogue start */
1594:switcherator.c **** }
 7165               		.loc 1 1594 0
 7166 28d2 6096      		adiw r28,16
 7167 28d4 0FB6      		in __tmp_reg__,__SREG__
 7168 28d6 F894      		cli
 7169 28d8 DEBF      		out __SP_H__,r29
 7170 28da 0FBE      		out __SREG__,__tmp_reg__
 7171 28dc CDBF      		out __SP_L__,r28
 7172 28de DF91      		pop r29
 7173 28e0 CF91      		pop r28
 7174 28e2 1F91      		pop r17
 7175 28e4 0F91      		pop r16
 7176 28e6 FF90      		pop r15
 7177 28e8 EF90      		pop r14
 7178 28ea DF90      		pop r13
 7179 28ec CF90      		pop r12
 7180 28ee BF90      		pop r11
 7181 28f0 AF90      		pop r10
 7182 28f2 9F90      		pop r9
 7183 28f4 8F90      		pop r8
 7184 28f6 0895      		ret
 7185               	.LFE37:
 7187               		.section	.rodata.str1.1
 7188               	.LC48:
 7189 00e8 5661 6C20 		.string	"Val 0x"
 7189      3078 00
 7190               	.LC49:
 7191 00ef 2C00      		.string	","
 7192               	.LC50:
 7193 00f1 2064 6972 		.string	" dir "
 7193      2000 
 7194               	.LC51:
 7195 00f7 436F 6C43 		.string	"ColCh:"
 7195      683A 00
 7196               	.LC52:
 7197 00fe 2D2D 00   		.string	"--"
 7198               	.LC53:
 7199 0101 5057 4D20 		.string	"PWM "
 7199      00
 7200               	.LC54:
 7201 0106 7374 6174 		.string	"static"
 7201      6963 00
 7202               	.LC55:
 7203 010d 436F 6C43 		.string	"ColCh"
 7203      6800 
 7204               	.LC56:
 7205 0113 6875 6500 		.string	"hue"
 7206               	.LC57:
 7207 0117 6F6E 2073 		.string	"on sw# "
 7207      7723 2000 
 7208               		.text
 7209               	.global	pwmSummary
 7211               	pwmSummary:
 7212               	.LFB26:
 978:switcherator.c **** void pwmSummary(void) {
 7213               		.loc 1 978 0
 7214 28f8 AF92      		push r10
 7215               	.LCFI170:
 7216 28fa BF92      		push r11
 7217               	.LCFI171:
 7218 28fc CF92      		push r12
 7219               	.LCFI172:
 7220 28fe DF92      		push r13
 7221               	.LCFI173:
 7222 2900 EF92      		push r14
 7223               	.LCFI174:
 7224 2902 FF92      		push r15
 7225               	.LCFI175:
 7226 2904 0F93      		push r16
 7227               	.LCFI176:
 7228 2906 1F93      		push r17
 7229               	.LCFI177:
 7230 2908 CF93      		push r28
 7231               	.LCFI178:
 7232 290a DF93      		push r29
 7233               	.LCFI179:
 7234 290c 1F92      		push __zero_reg__
 7235               	.LCFI180:
 7236 290e CDB7      		in r28,__SP_L__
 7237 2910 DEB7      		in r29,__SP_H__
 7238               	.LCFI181:
 7239               	/* prologue: function */
 7240               	/* frame size = 1 */
 7241               	/* stack size = 11 */
 7242               	.L__stack_usage = 11
 979:switcherator.c ****     statusMsg[0] = 0;
 7243               		.loc 1 979 0
 7244 2912 1092 0000 		sts statusMsg,__zero_reg__
 980:switcherator.c ****     strcat(statusMsg, "Val 0x");
 7245               		.loc 1 980 0
 7246 2916 60E0      		ldi r22,lo8(.LC48)
 7247 2918 70E0      		ldi r23,hi8(.LC48)
 7248 291a 80E0      		ldi r24,lo8(statusMsg)
 7249 291c 90E0      		ldi r25,hi8(statusMsg)
 7250 291e 0E94 0000 		call strcat
 7251               	.LVL545:
 7252 2922 00E0      		ldi r16,lo8(pwmValues)
 7253 2924 10E0      		ldi r17,hi8(pwmValues)
 982:switcherator.c ****     for (x = 0; x < 3; x++) {
 7254               		.loc 1 982 0
 7255 2926 E12C      		mov r14,__zero_reg__
 7256 2928 F12C      		mov r15,__zero_reg__
 7257 292a 00C0      		rjmp .L526
 7258               	.LVL546:
 7259               	.L527:
 984:switcherator.c ****             strcat(statusMsg, ",");
 7260               		.loc 1 984 0
 7261 292c 60E0      		ldi r22,lo8(.LC49)
 7262 292e 70E0      		ldi r23,hi8(.LC49)
 7263 2930 80E0      		ldi r24,lo8(statusMsg)
 7264 2932 90E0      		ldi r25,hi8(statusMsg)
 7265 2934 0E94 0000 		call strcat
 7266               	.LVL547:
 7267               	.L526:
 985:switcherator.c ****         returnHexWithout(pwmValues[x], tempLongString);
 7268               		.loc 1 985 0
 7269 2938 60E0      		ldi r22,lo8(tempLongString)
 7270 293a 70E0      		ldi r23,hi8(tempLongString)
 7271 293c F801      		movw r30,r16
 7272 293e 8191      		ld r24,Z+
 7273 2940 8F01      		movw r16,r30
 7274 2942 90E0      		ldi r25,0
 7275 2944 0E94 0000 		call returnHexWithout
 7276               	.LVL548:
 986:switcherator.c ****         strcat(statusMsg, tempLongString);
 7277               		.loc 1 986 0
 7278 2948 60E0      		ldi r22,lo8(tempLongString)
 7279 294a 70E0      		ldi r23,hi8(tempLongString)
 7280 294c 80E0      		ldi r24,lo8(statusMsg)
 7281 294e 90E0      		ldi r25,hi8(statusMsg)
 7282 2950 0E94 0000 		call strcat
 7283               	.LVL549:
 982:switcherator.c ****     for (x = 0; x < 3; x++) {
 7284               		.loc 1 982 0
 7285 2954 FFEF      		ldi r31,-1
 7286 2956 EF1A      		sub r14,r31
 7287 2958 FF0A      		sbc r15,r31
 7288               	.LVL550:
 7289 295a 83E0      		ldi r24,3
 7290 295c E816      		cp r14,r24
 7291 295e F104      		cpc r15,__zero_reg__
 7292 2960 01F4      		brne .L527
 988:switcherator.c ****     strcat(statusMsg, " dir ");
 7293               		.loc 1 988 0
 7294 2962 60E0      		ldi r22,lo8(.LC50)
 7295 2964 70E0      		ldi r23,hi8(.LC50)
 7296 2966 80E0      		ldi r24,lo8(statusMsg)
 7297 2968 90E0      		ldi r25,hi8(statusMsg)
 7298 296a 0E94 0000 		call strcat
 7299               	.LVL551:
 989:switcherator.c ****     returnInt(pwmdir, tempLongString);
 7300               		.loc 1 989 0
 7301 296e 60E0      		ldi r22,lo8(tempLongString)
 7302 2970 70E0      		ldi r23,hi8(tempLongString)
 7303 2972 8091 0000 		lds r24,pwmdir
 7304 2976 90E0      		ldi r25,0
 7305 2978 0E94 0000 		call returnInt
 7306               	.LVL552:
 990:switcherator.c ****     strcat(statusMsg, tempLongString);
 7307               		.loc 1 990 0
 7308 297c 60E0      		ldi r22,lo8(tempLongString)
 7309 297e 70E0      		ldi r23,hi8(tempLongString)
 7310 2980 80E0      		ldi r24,lo8(statusMsg)
 7311 2982 90E0      		ldi r25,hi8(statusMsg)
 7312 2984 0E94 0000 		call strcat
 7313               	.LVL553:
 991:switcherator.c ****     sendMessage(statusMsg);
 7314               		.loc 1 991 0
 7315 2988 80E0      		ldi r24,lo8(statusMsg)
 7316 298a 90E0      		ldi r25,hi8(statusMsg)
 7317 298c 0E94 0000 		call sendMessage
 7318               	.LVL554:
 992:switcherator.c ****     statusMsg[0] = 0;
 7319               		.loc 1 992 0
 7320 2990 1092 0000 		sts statusMsg,__zero_reg__
 993:switcherator.c ****     strcat(statusMsg, "ColCh:");
 7321               		.loc 1 993 0
 7322 2994 60E0      		ldi r22,lo8(.LC51)
 7323 2996 70E0      		ldi r23,hi8(.LC51)
 7324 2998 80E0      		ldi r24,lo8(statusMsg)
 7325 299a 90E0      		ldi r25,hi8(statusMsg)
 7326 299c 0E94 0000 		call strcat
 7327               	.LVL555:
 7328 29a0 00E0      		ldi r16,lo8(colorChanges)
 7329 29a2 10E0      		ldi r17,hi8(colorChanges)
 7330 29a4 E0E0      		ldi r30,lo8(colorChanges+2)
 7331 29a6 EE2E      		mov r14,r30
 7332 29a8 E0E0      		ldi r30,hi8(colorChanges+2)
 7333 29aa FE2E      		mov r15,r30
 995:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 7334               		.loc 1 995 0
 7335 29ac C12C      		mov r12,__zero_reg__
 7336 29ae D12C      		mov r13,__zero_reg__
 7337 29b0 00C0      		rjmp .L528
 7338               	.LVL556:
 7339               	.L533:
 997:switcherator.c ****             strcat(statusMsg, ",");
 7340               		.loc 1 997 0
 7341 29b2 60E0      		ldi r22,lo8(.LC49)
 7342 29b4 70E0      		ldi r23,hi8(.LC49)
 7343 29b6 80E0      		ldi r24,lo8(statusMsg)
 7344 29b8 90E0      		ldi r25,hi8(statusMsg)
 7345 29ba 0E94 0000 		call strcat
 7346               	.LVL557:
 7347 29be 0D5F      		subi r16,-3
 7348 29c0 1F4F      		sbci r17,-1
 7349 29c2 E3E0      		ldi r30,3
 7350 29c4 EE0E      		add r14,r30
 7351 29c6 F11C      		adc r15,__zero_reg__
 7352               	.LVL558:
 7353               	.L528:
 998:switcherator.c ****         strcat(statusMsg, "0x");
 7354               		.loc 1 998 0
 7355 29c8 60E0      		ldi r22,lo8(.LC5)
 7356 29ca 70E0      		ldi r23,hi8(.LC5)
 7357 29cc 80E0      		ldi r24,lo8(statusMsg)
 7358 29ce 90E0      		ldi r25,hi8(statusMsg)
 7359 29d0 0E94 0000 		call strcat
 7360               	.LVL559:
 999:switcherator.c ****         if(colorChanges[x][0] == 0 && colorChanges[x][1] == 1 &&
 7361               		.loc 1 999 0
 7362 29d4 F801      		movw r30,r16
 7363 29d6 8081      		ld r24,Z
 7364 29d8 8111      		cpse r24,__zero_reg__
 7365 29da 00C0      		rjmp .L542
 978:switcherator.c **** void pwmSummary(void) {
 7366               		.loc 1 978 0 discriminator 1
 7367 29dc F701      		movw r30,r14
 7368 29de 3197      		sbiw r30,1
 999:switcherator.c ****         if(colorChanges[x][0] == 0 && colorChanges[x][1] == 1 &&
 7369               		.loc 1 999 0 discriminator 1
 7370 29e0 8081      		ld r24,Z
 7371 29e2 8130      		cpi r24,lo8(1)
 7372 29e4 01F4      		brne .L542
 7373 29e6 F701      		movw r30,r14
 7374 29e8 8081      		ld r24,Z
 7375 29ea 8111      		cpse r24,__zero_reg__
 7376 29ec 00C0      		rjmp .L542
1001:switcherator.c ****             strcat(statusMsg,"--");
 7377               		.loc 1 1001 0
 7378 29ee 60E0      		ldi r22,lo8(.LC52)
 7379 29f0 70E0      		ldi r23,hi8(.LC52)
 7380 29f2 80E0      		ldi r24,lo8(statusMsg)
 7381 29f4 90E0      		ldi r25,hi8(statusMsg)
 7382 29f6 0E94 0000 		call strcat
 7383               	.LVL560:
 7384 29fa 00C0      		rjmp .L530
 7385               	.LVL561:
 7386               	.L531:
1005:switcherator.c ****                     strcat(statusMsg,",");
 7387               		.loc 1 1005 0
 7388 29fc 60E0      		ldi r22,lo8(.LC49)
 7389 29fe 70E0      		ldi r23,hi8(.LC49)
 7390 2a00 80E0      		ldi r24,lo8(statusMsg)
 7391 2a02 90E0      		ldi r25,hi8(statusMsg)
 7392 2a04 0E94 0000 		call strcat
 7393               	.LVL562:
 7394 2a08 00C0      		rjmp .L544
 7395               	.LVL563:
 7396               	.L542:
 999:switcherator.c ****         if(colorChanges[x][0] == 0 && colorChanges[x][1] == 1 &&
 7397               		.loc 1 999 0
 7398 2a0a A12C      		mov r10,__zero_reg__
 7399 2a0c B12C      		mov r11,__zero_reg__
 7400               	.L544:
 978:switcherator.c **** void pwmSummary(void) {
 7401               		.loc 1 978 0
 7402 2a0e F801      		movw r30,r16
 7403 2a10 EA0D      		add r30,r10
 7404 2a12 FB1D      		adc r31,r11
1006:switcherator.c ****                 returnHexWithout(colorChanges[x][y], tempLongString);
 7405               		.loc 1 1006 0
 7406 2a14 60E0      		ldi r22,lo8(tempLongString)
 7407 2a16 70E0      		ldi r23,hi8(tempLongString)
 7408 2a18 8081      		ld r24,Z
 7409 2a1a 90E0      		ldi r25,0
 7410 2a1c 0E94 0000 		call returnHexWithout
 7411               	.LVL564:
1007:switcherator.c ****                 strcat(statusMsg, tempLongString);
 7412               		.loc 1 1007 0
 7413 2a20 60E0      		ldi r22,lo8(tempLongString)
 7414 2a22 70E0      		ldi r23,hi8(tempLongString)
 7415 2a24 80E0      		ldi r24,lo8(statusMsg)
 7416 2a26 90E0      		ldi r25,hi8(statusMsg)
 7417 2a28 0E94 0000 		call strcat
 7418               	.LVL565:
1003:switcherator.c ****             for (y = 0; y < 3; y++) {
 7419               		.loc 1 1003 0
 7420 2a2c FFEF      		ldi r31,-1
 7421 2a2e AF1A      		sub r10,r31
 7422 2a30 BF0A      		sbc r11,r31
 7423               	.LVL566:
 7424 2a32 83E0      		ldi r24,3
 7425 2a34 A816      		cp r10,r24
 7426 2a36 B104      		cpc r11,__zero_reg__
 7427 2a38 01F4      		brne .L531
 7428               	.LVL567:
 7429               	.L530:
1010:switcherator.c ****         if (strlen(statusMsg) > 20) {
 7430               		.loc 1 1010 0
 7431 2a3a E0E0      		ldi r30,lo8(statusMsg)
 7432 2a3c F0E0      		ldi r31,hi8(statusMsg)
 7433               		0:
 7434 2a3e 0190      		ld __tmp_reg__,Z+
 7435 2a40 0020      		tst __tmp_reg__
 7436 2a42 01F4      		brne 0b
 7437 2a44 3197      		sbiw r30,1
 7438 2a46 E050      		subi r30,lo8(statusMsg)
 7439 2a48 F040      		sbci r31,hi8(statusMsg)
 7440 2a4a 7597      		sbiw r30,21
 7441 2a4c 00F0      		brlo .L532
1011:switcherator.c ****             sendMessage(statusMsg);
 7442               		.loc 1 1011 0
 7443 2a4e 80E0      		ldi r24,lo8(statusMsg)
 7444 2a50 90E0      		ldi r25,hi8(statusMsg)
 7445 2a52 0E94 0000 		call sendMessage
 7446               	.LVL568:
1012:switcherator.c ****             statusMsg[6] = 0;
 7447               		.loc 1 1012 0
 7448 2a56 1092 0000 		sts statusMsg+6,__zero_reg__
 7449               	.L532:
 995:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 7450               		.loc 1 995 0
 7451 2a5a EFEF      		ldi r30,-1
 7452 2a5c CE1A      		sub r12,r30
 7453 2a5e DE0A      		sbc r13,r30
 7454               	.LVL569:
 7455 2a60 F6E0      		ldi r31,6
 7456 2a62 CF16      		cp r12,r31
 7457 2a64 D104      		cpc r13,__zero_reg__
 7458 2a66 01F0      		breq .+2
 7459 2a68 00C0      		rjmp .L533
1015:switcherator.c ****     if(strlen(statusMsg)> 6)
 7460               		.loc 1 1015 0
 7461 2a6a E0E0      		ldi r30,lo8(statusMsg)
 7462 2a6c F0E0      		ldi r31,hi8(statusMsg)
 7463               		0:
 7464 2a6e 0190      		ld __tmp_reg__,Z+
 7465 2a70 0020      		tst __tmp_reg__
 7466 2a72 01F4      		brne 0b
 7467 2a74 3197      		sbiw r30,1
 7468 2a76 E050      		subi r30,lo8(statusMsg)
 7469 2a78 F040      		sbci r31,hi8(statusMsg)
 7470 2a7a 3797      		sbiw r30,7
 7471 2a7c 00F0      		brlo .L534
1016:switcherator.c ****         sendMessage(statusMsg);
 7472               		.loc 1 1016 0
 7473 2a7e 80E0      		ldi r24,lo8(statusMsg)
 7474 2a80 90E0      		ldi r25,hi8(statusMsg)
 7475 2a82 0E94 0000 		call sendMessage
 7476               	.LVL570:
 7477               	.L534:
1017:switcherator.c ****     statusMsg[0] = 0;
 7478               		.loc 1 1017 0
 7479 2a86 1092 0000 		sts statusMsg,__zero_reg__
 7480               	.LVL571:
 7481 2a8a 00E0      		ldi r16,lo8(switchStuff)
 7482 2a8c 10E0      		ldi r17,hi8(switchStuff)
1018:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 7483               		.loc 1 1018 0
 7484 2a8e E12C      		mov r14,__zero_reg__
 7485 2a90 F12C      		mov r15,__zero_reg__
 7486               	.LVL572:
 7487               	.L539:
1019:switcherator.c ****         if ((switchStuff[x] >= 200) && (switchStuff[x] <= 220)) {
 7488               		.loc 1 1019 0
 7489 2a92 F801      		movw r30,r16
 7490 2a94 2191      		ld r18,Z+
 7491 2a96 8F01      		movw r16,r30
 7492 2a98 822F      		mov r24,r18
 7493 2a9a 885C      		subi r24,lo8(-(56))
 7494 2a9c 8531      		cpi r24,lo8(21)
 7495 2a9e 00F4      		brsh .L535
1020:switcherator.c ****             strcat(statusMsg, "PWM ");
 7496               		.loc 1 1020 0
 7497 2aa0 60E0      		ldi r22,lo8(.LC53)
 7498 2aa2 70E0      		ldi r23,hi8(.LC53)
 7499 2aa4 80E0      		ldi r24,lo8(statusMsg)
 7500 2aa6 90E0      		ldi r25,hi8(statusMsg)
 7501 2aa8 2983      		std Y+1,r18
 7502 2aaa 0E94 0000 		call strcat
 7503               	.LVL573:
1021:switcherator.c ****             if (switchStuff[x] == 200) {
 7504               		.loc 1 1021 0
 7505 2aae 2981      		ldd r18,Y+1
 7506 2ab0 283C      		cpi r18,lo8(-56)
 7507 2ab2 01F4      		brne .L536
1022:switcherator.c ****                 strcat(statusMsg, "static");
 7508               		.loc 1 1022 0
 7509 2ab4 60E0      		ldi r22,lo8(.LC54)
 7510 2ab6 70E0      		ldi r23,hi8(.LC54)
 7511 2ab8 00C0      		rjmp .L545
 7512               	.L536:
1023:switcherator.c ****             } else if (switchStuff[x] == 202) {
 7513               		.loc 1 1023 0
 7514 2aba 2A3C      		cpi r18,lo8(-54)
 7515 2abc 01F4      		brne .L538
1024:switcherator.c ****                 strcat(statusMsg, "ColCh");
 7516               		.loc 1 1024 0
 7517 2abe 60E0      		ldi r22,lo8(.LC55)
 7518 2ac0 70E0      		ldi r23,hi8(.LC55)
 7519 2ac2 00C0      		rjmp .L545
 7520               	.L538:
1026:switcherator.c ****                 strcat(statusMsg, "hue");
 7521               		.loc 1 1026 0
 7522 2ac4 60E0      		ldi r22,lo8(.LC56)
 7523 2ac6 70E0      		ldi r23,hi8(.LC56)
 7524               	.L545:
 7525 2ac8 80E0      		ldi r24,lo8(statusMsg)
 7526 2aca 90E0      		ldi r25,hi8(statusMsg)
 7527 2acc 0E94 0000 		call strcat
 7528               	.LVL574:
1028:switcherator.c ****             strcat(statusMsg, "on sw# ");
 7529               		.loc 1 1028 0
 7530 2ad0 60E0      		ldi r22,lo8(.LC57)
 7531 2ad2 70E0      		ldi r23,hi8(.LC57)
 7532 2ad4 80E0      		ldi r24,lo8(statusMsg)
 7533 2ad6 90E0      		ldi r25,hi8(statusMsg)
 7534 2ad8 0E94 0000 		call strcat
 7535               	.LVL575:
1029:switcherator.c ****             returnInt(x, tempLongString);
 7536               		.loc 1 1029 0
 7537 2adc 60E0      		ldi r22,lo8(tempLongString)
 7538 2ade 70E0      		ldi r23,hi8(tempLongString)
 7539 2ae0 C701      		movw r24,r14
 7540 2ae2 0E94 0000 		call returnInt
 7541               	.LVL576:
1030:switcherator.c ****             strcat(statusMsg, tempLongString);
 7542               		.loc 1 1030 0
 7543 2ae6 60E0      		ldi r22,lo8(tempLongString)
 7544 2ae8 70E0      		ldi r23,hi8(tempLongString)
 7545 2aea 80E0      		ldi r24,lo8(statusMsg)
 7546 2aec 90E0      		ldi r25,hi8(statusMsg)
 7547 2aee 0E94 0000 		call strcat
 7548               	.LVL577:
1031:switcherator.c ****             sendMessage(statusMsg);
 7549               		.loc 1 1031 0
 7550 2af2 80E0      		ldi r24,lo8(statusMsg)
 7551 2af4 90E0      		ldi r25,hi8(statusMsg)
 7552 2af6 0E94 0000 		call sendMessage
 7553               	.LVL578:
1032:switcherator.c ****             statusMsg[0] = 0;
 7554               		.loc 1 1032 0
 7555 2afa 1092 0000 		sts statusMsg,__zero_reg__
 7556               	.L535:
1018:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 7557               		.loc 1 1018 0
 7558 2afe FFEF      		ldi r31,-1
 7559 2b00 EF1A      		sub r14,r31
 7560 2b02 FF0A      		sbc r15,r31
 7561               	.LVL579:
 7562 2b04 80E1      		ldi r24,16
 7563 2b06 E816      		cp r14,r24
 7564 2b08 F104      		cpc r15,__zero_reg__
 7565 2b0a 01F4      		brne .L539
 7566               	/* epilogue start */
1035:switcherator.c **** }
 7567               		.loc 1 1035 0
 7568 2b0c 0F90      		pop __tmp_reg__
 7569 2b0e DF91      		pop r29
 7570 2b10 CF91      		pop r28
 7571 2b12 1F91      		pop r17
 7572 2b14 0F91      		pop r16
 7573 2b16 FF90      		pop r15
 7574 2b18 EF90      		pop r14
 7575               	.LVL580:
 7576 2b1a DF90      		pop r13
 7577 2b1c CF90      		pop r12
 7578 2b1e BF90      		pop r11
 7579 2b20 AF90      		pop r10
 7580 2b22 0895      		ret
 7581               	.LFE26:
 7583               		.section	.rodata.str1.1
 7584               	.LC58:
 7585 011f 436F 4300 		.string	"CoC"
 7586               	.LC59:
 7587 0123 4272 7400 		.string	"Brt"
 7588               	.LC60:
 7589 0127 4669 7800 		.string	"Fix"
 7590               	.LC61:
 7591 012b 4875 6500 		.string	"Hue"
 7592               	.LC62:
 7593 012f 4C00      		.string	"L"
 7594               	.LC63:
 7595 0131 4800      		.string	"H"
 7596               		.text
 7597               	.global	switchDisplay
 7599               	switchDisplay:
 7600               	.LFB16:
 601:switcherator.c **** void switchDisplay(char * commandReceived) {
 7601               		.loc 1 601 0
 7602               	.LVL581:
 7603 2b24 CF93      		push r28
 7604               	.LCFI182:
 7605 2b26 DF93      		push r29
 7606               	.LCFI183:
 7607 2b28 CDB7      		in r28,__SP_L__
 7608 2b2a DEB7      		in r29,__SP_H__
 7609               	.LCFI184:
 7610 2b2c A397      		sbiw r28,35
 7611               	.LCFI185:
 7612 2b2e 0FB6      		in __tmp_reg__,__SREG__
 7613 2b30 F894      		cli
 7614 2b32 DEBF      		out __SP_H__,r29
 7615 2b34 0FBE      		out __SREG__,__tmp_reg__
 7616 2b36 CDBF      		out __SP_L__,r28
 7617               	/* prologue: function */
 7618               	/* frame size = 35 */
 7619               	/* stack size = 37 */
 7620               	.L__stack_usage = 37
 602:switcherator.c ****     char port[] = {0};
 7621               		.loc 1 602 0
 7622 2b38 1BA2      		std Y+35,__zero_reg__
 603:switcherator.c ****     char pin[] = {0};
 7623               		.loc 1 603 0
 7624 2b3a 1AA2      		std Y+34,__zero_reg__
 604:switcherator.c ****     char direction[] = {0};
 7625               		.loc 1 604 0
 7626 2b3c 19A2      		std Y+33,__zero_reg__
 7627               	.LVL582:
 608:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 7628               		.loc 1 608 0
 7629 2b3e 0E94 0000 		call getSwitchNumber
 7630               	.LVL583:
 609:switcherator.c ****     statusMsg[0] = 0;
 7631               		.loc 1 609 0
 7632 2b42 1982      		std Y+1,__zero_reg__
 611:switcherator.c ****     if (switchStuff[switchNumber] >= 200 && switchStuff[switchNumber] <= 220) {
 7633               		.loc 1 611 0
 7634 2b44 FC01      		movw r30,r24
 7635 2b46 E050      		subi r30,lo8(-(switchStuff))
 7636 2b48 F040      		sbci r31,hi8(-(switchStuff))
 7637 2b4a 2081      		ld r18,Z
 7638 2b4c 322F      		mov r19,r18
 7639 2b4e 385C      		subi r19,lo8(-(56))
 7640 2b50 3531      		cpi r19,lo8(21)
 7641 2b52 00F4      		brsh .L547
 613:switcherator.c ****         if (switchStuff[switchNumber] % 2 == 0) {
 7642               		.loc 1 613 0
 7643 2b54 20FD      		sbrc r18,0
 7644 2b56 00C0      		rjmp .L548
 614:switcherator.c ****             if (switchStuff[switchNumber] == 202) {
 7645               		.loc 1 614 0
 7646 2b58 2A3C      		cpi r18,lo8(-54)
 7647 2b5a 01F4      		brne .L549
 615:switcherator.c ****                 strcat(statusMsg, "CoC");
 7648               		.loc 1 615 0
 7649 2b5c 60E0      		ldi r22,lo8(.LC58)
 7650 2b5e 70E0      		ldi r23,hi8(.LC58)
 7651 2b60 00C0      		rjmp .L553
 7652               	.L549:
 616:switcherator.c ****             } else if (switchStuff[switchNumber] == 212) {
 7653               		.loc 1 616 0
 7654 2b62 243D      		cpi r18,lo8(-44)
 7655 2b64 01F4      		brne .L551
 617:switcherator.c ****                 strcat(statusMsg, "Brt");
 7656               		.loc 1 617 0
 7657 2b66 60E0      		ldi r22,lo8(.LC59)
 7658 2b68 70E0      		ldi r23,hi8(.LC59)
 7659 2b6a 00C0      		rjmp .L553
 7660               	.L551:
 619:switcherator.c ****                 strcat(statusMsg, "Fix");
 7661               		.loc 1 619 0
 7662 2b6c 60E0      		ldi r22,lo8(.LC60)
 7663 2b6e 70E0      		ldi r23,hi8(.LC60)
 7664 2b70 00C0      		rjmp .L553
 7665               	.L548:
 622:switcherator.c ****             strcat(statusMsg, "Hue");
 7666               		.loc 1 622 0
 7667 2b72 60E0      		ldi r22,lo8(.LC61)
 7668 2b74 70E0      		ldi r23,hi8(.LC61)
 7669 2b76 00C0      		rjmp .L553
 7670               	.L547:
 625:switcherator.c ****         getPort(switchNumber, port, pin, direction);
 7671               		.loc 1 625 0
 7672 2b78 9E01      		movw r18,r28
 7673 2b7a 2F5D      		subi r18,-33
 7674 2b7c 3F4F      		sbci r19,-1
 7675 2b7e AE01      		movw r20,r28
 7676 2b80 4E5D      		subi r20,-34
 7677 2b82 5F4F      		sbci r21,-1
 7678 2b84 BE01      		movw r22,r28
 7679 2b86 6D5D      		subi r22,-35
 7680 2b88 7F4F      		sbci r23,-1
 7681 2b8a 0E94 0000 		call getPort
 7682               	.LVL584:
 626:switcherator.c ****         tempIntString[0] = port[0];
 7683               		.loc 1 626 0
 7684 2b8e 8BA1      		ldd r24,Y+35
 7685 2b90 8093 0000 		sts tempIntString,r24
 627:switcherator.c ****         tempIntString[1] = 0;
 7686               		.loc 1 627 0
 7687 2b94 1092 0000 		sts tempIntString+1,__zero_reg__
 628:switcherator.c ****         strcat(statusMsg, tempIntString);
 7688               		.loc 1 628 0
 7689 2b98 60E0      		ldi r22,lo8(tempIntString)
 7690 2b9a 70E0      		ldi r23,hi8(tempIntString)
 7691 2b9c CE01      		movw r24,r28
 7692 2b9e 0196      		adiw r24,1
 7693 2ba0 0E94 0000 		call strcat
 7694               	.LVL585:
 630:switcherator.c ****         itoa(realPin, tempIntString, 10);
 7695               		.loc 1 630 0
 7696 2ba4 4AE0      		ldi r20,lo8(10)
 7697 2ba6 50E0      		ldi r21,0
 7698 2ba8 60E0      		ldi r22,lo8(tempIntString)
 7699 2baa 70E0      		ldi r23,hi8(tempIntString)
 7700 2bac 8AA1      		ldd r24,Y+34
 7701 2bae 90E0      		ldi r25,0
 7702 2bb0 0E94 0000 		call itoa
 7703               	.LVL586:
 631:switcherator.c ****         strcat(statusMsg, tempIntString);
 7704               		.loc 1 631 0
 7705 2bb4 60E0      		ldi r22,lo8(tempIntString)
 7706 2bb6 70E0      		ldi r23,hi8(tempIntString)
 7707 2bb8 CE01      		movw r24,r28
 7708 2bba 0196      		adiw r24,1
 7709 2bbc 0E94 0000 		call strcat
 7710               	.LVL587:
 632:switcherator.c ****         if (direction[0] == 0) {
 7711               		.loc 1 632 0
 7712 2bc0 89A1      		ldd r24,Y+33
 7713 2bc2 8111      		cpse r24,__zero_reg__
 7714 2bc4 00C0      		rjmp .L552
 633:switcherator.c ****             strcat(statusMsg, "L");
 7715               		.loc 1 633 0
 7716 2bc6 60E0      		ldi r22,lo8(.LC62)
 7717 2bc8 70E0      		ldi r23,hi8(.LC62)
 7718 2bca 00C0      		rjmp .L553
 7719               	.L552:
 635:switcherator.c ****             strcat(statusMsg, "H");
 7720               		.loc 1 635 0
 7721 2bcc 60E0      		ldi r22,lo8(.LC63)
 7722 2bce 70E0      		ldi r23,hi8(.LC63)
 7723               	.L553:
 7724 2bd0 CE01      		movw r24,r28
 7725 2bd2 0196      		adiw r24,1
 7726 2bd4 0E94 0000 		call strcat
 7727               	.LVL588:
 638:switcherator.c ****     sendMessage(statusMsg);
 7728               		.loc 1 638 0
 7729 2bd8 CE01      		movw r24,r28
 7730 2bda 0196      		adiw r24,1
 7731 2bdc 0E94 0000 		call sendMessage
 7732               	.LVL589:
 7733               	/* epilogue start */
 640:switcherator.c **** }
 7734               		.loc 1 640 0
 7735 2be0 A396      		adiw r28,35
 7736 2be2 0FB6      		in __tmp_reg__,__SREG__
 7737 2be4 F894      		cli
 7738 2be6 DEBF      		out __SP_H__,r29
 7739 2be8 0FBE      		out __SREG__,__tmp_reg__
 7740 2bea CDBF      		out __SP_L__,r28
 7741 2bec DF91      		pop r29
 7742 2bee CF91      		pop r28
 7743 2bf0 0895      		ret
 7744               	.LFE16:
 7746               		.section	.rodata.str1.1
 7747               	.LC64:
 7748 0133 6F6B 00   		.string	"ok"
 7749               		.text
 7750               	.global	ok
 7752               	ok:
 7753               	.LFB11:
 390:switcherator.c **** void ok(void) {
 7754               		.loc 1 390 0
 7755               	/* prologue: function */
 7756               	/* frame size = 0 */
 7757               	/* stack size = 0 */
 7758               	.L__stack_usage = 0
 391:switcherator.c ****     sendMessage("ok");
 7759               		.loc 1 391 0
 7760 2bf2 80E0      		ldi r24,lo8(.LC64)
 7761 2bf4 90E0      		ldi r25,hi8(.LC64)
 7762 2bf6 0C94 0000 		jmp sendMessage
 7763               	.LVL590:
 7764               	.LFE11:
 7766               	.global	clearInput
 7768               	clearInput:
 7769               	.LFB82:
3604:switcherator.c **** void clearInput(char * commandReceived) {
 7770               		.loc 1 3604 0
 7771               	.LVL591:
 7772               	/* prologue: function */
 7773               	/* frame size = 0 */
 7774               	/* stack size = 0 */
 7775               	.L__stack_usage = 0
3607:switcherator.c ****     tempIntString[0] = commandReceived[3];
 7776               		.loc 1 3607 0
 7777 2bfa FC01      		movw r30,r24
 7778 2bfc 2381      		ldd r18,Z+3
 7779 2bfe 2093 0000 		sts tempIntString,r18
3608:switcherator.c ****     tempIntString[1] = commandReceived[4];
 7780               		.loc 1 3608 0
 7781 2c02 8481      		ldd r24,Z+4
 7782               	.LVL592:
 7783 2c04 8093 0000 		sts tempIntString+1,r24
3609:switcherator.c ****     inputNumber = atoi(tempIntString);
 7784               		.loc 1 3609 0
 7785 2c08 80E0      		ldi r24,lo8(tempIntString)
 7786 2c0a 90E0      		ldi r25,hi8(tempIntString)
 7787 2c0c 0E94 0000 		call atoi
 7788               	.LVL593:
3610:switcherator.c ****     int temp = inputs[inputNumber][0];
 7789               		.loc 1 3610 0
 7790 2c10 F3E0      		ldi r31,3
 7791               		1:
 7792 2c12 880F      		lsl r24
 7793 2c14 991F      		rol r25
 7794 2c16 FA95      		dec r31
 7795 2c18 01F4      		brne 1b
 7796               	.LVL594:
 7797 2c1a FC01      		movw r30,r24
 7798 2c1c E050      		subi r30,lo8(-(inputs))
 7799 2c1e F040      		sbci r31,hi8(-(inputs))
 7800 2c20 2081      		ld r18,Z
 7801 2c22 30E0      		ldi r19,0
 7802               	.LVL595:
3611:switcherator.c ****     if (temp > 15 && temp < 32) {
 7803               		.loc 1 3611 0
 7804 2c24 A901      		movw r20,r18
 7805 2c26 4051      		subi r20,16
 7806 2c28 5109      		sbc r21,__zero_reg__
 7807 2c2a 4031      		cpi r20,16
 7808 2c2c 5105      		cpc r21,__zero_reg__
 7809 2c2e 00F4      		brsh .L556
 7810               	.LVL596:
3613:switcherator.c ****         temp -= 16;
 7811               		.loc 1 3613 0
 7812 2c30 9A01      		movw r18,r20
 7813               	.LVL597:
3612:switcherator.c ****         thisPort = &PINB;
 7814               		.loc 1 3612 0
 7815 2c32 E3E2      		ldi r30,lo8(35)
 7816 2c34 F0E0      		ldi r31,0
 7817 2c36 00C0      		rjmp .L557
 7818               	.LVL598:
 7819               	.L556:
3620:switcherator.c ****     } else if (temp < 48) {
 7820               		.loc 1 3620 0
 7821 2c38 2033      		cpi r18,48
 7822 2c3a 3105      		cpc r19,__zero_reg__
 7823 2c3c 04F4      		brge .L558
 7824               	.LVL599:
3622:switcherator.c ****         temp -= 32;
 7825               		.loc 1 3622 0
 7826 2c3e 2052      		subi r18,32
 7827 2c40 3109      		sbc r19,__zero_reg__
 7828               	.LVL600:
3621:switcherator.c ****         thisPort = &PINC;
 7829               		.loc 1 3621 0
 7830 2c42 E6E2      		ldi r30,lo8(38)
 7831 2c44 F0E0      		ldi r31,0
 7832 2c46 00C0      		rjmp .L557
 7833               	.LVL601:
 7834               	.L558:
3625:switcherator.c ****     } else if (temp < 64) {
 7835               		.loc 1 3625 0
 7836 2c48 2034      		cpi r18,64
 7837 2c4a 3105      		cpc r19,__zero_reg__
 7838 2c4c 04F4      		brge .L560
 7839               	.LVL602:
3627:switcherator.c ****         temp -= 48;
 7840               		.loc 1 3627 0
 7841 2c4e 2053      		subi r18,48
 7842 2c50 3109      		sbc r19,__zero_reg__
 7843               	.LVL603:
3626:switcherator.c ****         thisPort = &PIND;
 7844               		.loc 1 3626 0
 7845 2c52 E9E2      		ldi r30,lo8(41)
 7846 2c54 F0E0      		ldi r31,0
 7847               	.LVL604:
 7848               	.L557:
3659:switcherator.c ****     *thisPort &= ~(1 << temp);
 7849               		.loc 1 3659 0
 7850 2c56 3081      		ld r19,Z
 7851 2c58 41E0      		ldi r20,lo8(1)
 7852 2c5a 50E0      		ldi r21,0
 7853 2c5c 00C0      		rjmp 2f
 7854               		1:
 7855 2c5e 440F      		lsl r20
 7856               		2:
 7857 2c60 2A95      		dec r18
 7858 2c62 02F4      		brpl 1b
 7859 2c64 4095      		com r20
 7860 2c66 4323      		and r20,r19
 7861 2c68 4083      		st Z,r20
3660:switcherator.c ****     inputs[inputNumber][0] = 255;
 7862               		.loc 1 3660 0
 7863 2c6a FC01      		movw r30,r24
 7864               	.LVL605:
 7865 2c6c E050      		subi r30,lo8(-(inputs))
 7866 2c6e F040      		sbci r31,hi8(-(inputs))
 7867 2c70 2FEF      		ldi r18,lo8(-1)
 7868 2c72 2083      		st Z,r18
 7869               	.L560:
3661:switcherator.c ****     ok();
 7870               		.loc 1 3661 0
 7871 2c74 0C94 0000 		jmp ok
 7872               	.LVL606:
 7873               	.LFE82:
 7875               	.global	setDaylightSavings
 7877               	setDaylightSavings:
 7878               	.LFB54:
2225:switcherator.c **** void setDaylightSavings(char * commandReceived) {
 7879               		.loc 1 2225 0
 7880               	.LVL607:
 7881 2c78 EF92      		push r14
 7882               	.LCFI186:
 7883 2c7a FF92      		push r15
 7884               	.LCFI187:
 7885 2c7c 0F93      		push r16
 7886               	.LCFI188:
 7887 2c7e 1F93      		push r17
 7888               	.LCFI189:
 7889 2c80 CF93      		push r28
 7890               	.LCFI190:
 7891 2c82 DF93      		push r29
 7892               	.LCFI191:
 7893               	/* prologue: function */
 7894               	/* frame size = 0 */
 7895               	/* stack size = 6 */
 7896               	.L__stack_usage = 6
 7897 2c84 EC01      		movw r28,r24
2227:switcherator.c ****     tempIntString[0] = commandReceived[3];
 7898               		.loc 1 2227 0
 7899 2c86 A0E0      		ldi r26,lo8(tempIntString)
 7900 2c88 EA2E      		mov r14,r26
 7901 2c8a A0E0      		ldi r26,hi8(tempIntString)
 7902 2c8c FA2E      		mov r15,r26
 7903 2c8e 8B81      		ldd r24,Y+3
 7904               	.LVL608:
 7905 2c90 F701      		movw r30,r14
 7906 2c92 8083      		st Z,r24
2228:switcherator.c ****     tempIntString[1] = commandReceived[4];
 7907               		.loc 1 2228 0
 7908 2c94 00E0      		ldi r16,lo8(tempIntString+1)
 7909 2c96 10E0      		ldi r17,hi8(tempIntString+1)
 7910 2c98 8C81      		ldd r24,Y+4
 7911 2c9a F801      		movw r30,r16
 7912 2c9c 8083      		st Z,r24
2229:switcherator.c ****     dlInt = atoi(tempIntString);
 7913               		.loc 1 2229 0
 7914 2c9e C701      		movw r24,r14
 7915 2ca0 0E94 0000 		call atoi
 7916               	.LVL609:
2230:switcherator.c ****     daylightSavings[0][0] = dlInt;
 7917               		.loc 1 2230 0
 7918 2ca4 9093 0000 		sts daylightSavings+1,r25
 7919 2ca8 8093 0000 		sts daylightSavings,r24
2231:switcherator.c ****     tempIntString[0] = commandReceived[5];
 7920               		.loc 1 2231 0
 7921 2cac 8D81      		ldd r24,Y+5
 7922               	.LVL610:
 7923 2cae F701      		movw r30,r14
 7924 2cb0 8083      		st Z,r24
2232:switcherator.c ****     tempIntString[1] = commandReceived[6];
 7925               		.loc 1 2232 0
 7926 2cb2 8E81      		ldd r24,Y+6
 7927 2cb4 F801      		movw r30,r16
 7928 2cb6 8083      		st Z,r24
2233:switcherator.c ****     dlInt = atoi(tempIntString);
 7929               		.loc 1 2233 0
 7930 2cb8 C701      		movw r24,r14
 7931 2cba 0E94 0000 		call atoi
 7932               	.LVL611:
2234:switcherator.c ****     daylightSavings[0][1] = dlInt;
 7933               		.loc 1 2234 0
 7934 2cbe 9093 0000 		sts daylightSavings+2+1,r25
 7935 2cc2 8093 0000 		sts daylightSavings+2,r24
2235:switcherator.c ****     tempIntString[0] = commandReceived[8];
 7936               		.loc 1 2235 0
 7937 2cc6 8885      		ldd r24,Y+8
 7938               	.LVL612:
 7939 2cc8 F701      		movw r30,r14
 7940 2cca 8083      		st Z,r24
2236:switcherator.c ****     tempIntString[1] = commandReceived[9];
 7941               		.loc 1 2236 0
 7942 2ccc 8985      		ldd r24,Y+9
 7943 2cce F801      		movw r30,r16
 7944 2cd0 8083      		st Z,r24
2237:switcherator.c ****     dlInt = atoi(tempIntString);
 7945               		.loc 1 2237 0
 7946 2cd2 C701      		movw r24,r14
 7947 2cd4 0E94 0000 		call atoi
 7948               	.LVL613:
2238:switcherator.c ****     daylightSavings[1][0] = dlInt;
 7949               		.loc 1 2238 0
 7950 2cd8 9093 0000 		sts daylightSavings+4+1,r25
 7951 2cdc 8093 0000 		sts daylightSavings+4,r24
2239:switcherator.c ****     tempIntString[0] = commandReceived[10];
 7952               		.loc 1 2239 0
 7953 2ce0 8A85      		ldd r24,Y+10
 7954               	.LVL614:
 7955 2ce2 F701      		movw r30,r14
 7956 2ce4 8083      		st Z,r24
2240:switcherator.c ****     tempIntString[1] = commandReceived[11];
 7957               		.loc 1 2240 0
 7958 2ce6 8B85      		ldd r24,Y+11
 7959 2ce8 F801      		movw r30,r16
 7960 2cea 8083      		st Z,r24
2241:switcherator.c ****     dlInt = atoi(tempIntString);
 7961               		.loc 1 2241 0
 7962 2cec C701      		movw r24,r14
 7963 2cee 0E94 0000 		call atoi
 7964               	.LVL615:
2242:switcherator.c ****     daylightSavings[1][1] = dlInt;
 7965               		.loc 1 2242 0
 7966 2cf2 9093 0000 		sts daylightSavings+6+1,r25
 7967 2cf6 8093 0000 		sts daylightSavings+6,r24
 7968               	/* epilogue start */
2244:switcherator.c **** }
 7969               		.loc 1 2244 0
 7970 2cfa DF91      		pop r29
 7971 2cfc CF91      		pop r28
 7972               	.LVL616:
 7973 2cfe 1F91      		pop r17
 7974 2d00 0F91      		pop r16
 7975 2d02 FF90      		pop r15
 7976 2d04 EF90      		pop r14
2243:switcherator.c ****     ok();
 7977               		.loc 1 2243 0
 7978 2d06 0C94 0000 		jmp ok
 7979               	.LVL617:
 7980               	.LFE54:
 7982               	.global	clearToEEPROM
 7984               	clearToEEPROM:
 7985               	.LFB46:
2056:switcherator.c **** void clearToEEPROM(void) {
 7986               		.loc 1 2056 0
 7987 2d0a CF93      		push r28
 7988               	.LCFI192:
 7989 2d0c DF93      		push r29
 7990               	.LCFI193:
 7991               	/* prologue: function */
 7992               	/* frame size = 0 */
 7993               	/* stack size = 2 */
 7994               	.L__stack_usage = 2
 7995               	.LVL618:
2058:switcherator.c ****     clearEEPROM(DAYLIGHT_SAVE);
 7996               		.loc 1 2058 0
 7997 2d0e 86E0      		ldi r24,lo8(6)
 7998 2d10 90E0      		ldi r25,0
 7999 2d12 0E94 0000 		call clearEEPROM
 8000               	.LVL619:
2059:switcherator.c ****     clearEEPROM(RADIO_ADDR_TX);
 8001               		.loc 1 2059 0
 8002 2d16 8EE0      		ldi r24,lo8(14)
 8003 2d18 90E0      		ldi r25,0
 8004 2d1a 0E94 0000 		call clearEEPROM
 8005               	.LVL620:
2060:switcherator.c ****     clearEEPROM(RADIO_ADDR_R0);
 8006               		.loc 1 2060 0
 8007 2d1e 85E1      		ldi r24,lo8(21)
 8008 2d20 90E0      		ldi r25,0
 8009 2d22 0E94 0000 		call clearEEPROM
 8010               	.LVL621:
2061:switcherator.c ****     clearEEPROM(RADIO_ADDR_R1);
 8011               		.loc 1 2061 0
 8012 2d26 8CE1      		ldi r24,lo8(28)
 8013 2d28 90E0      		ldi r25,0
 8014 2d2a 0E94 0000 		call clearEEPROM
 8015               	.LVL622:
2062:switcherator.c ****     clearEEPROM(RADIO_ADDR_R2);
 8016               		.loc 1 2062 0
 8017 2d2e 83E2      		ldi r24,lo8(35)
 8018 2d30 90E0      		ldi r25,0
 8019 2d32 0E94 0000 		call clearEEPROM
 8020               	.LVL623:
2063:switcherator.c ****     clearEEPROM(RADIO_ADDR_R3);
 8021               		.loc 1 2063 0
 8022 2d36 86E2      		ldi r24,lo8(38)
 8023 2d38 90E0      		ldi r25,0
 8024 2d3a 0E94 0000 		call clearEEPROM
 8025               	.LVL624:
2064:switcherator.c ****     clearEEPROM(RADIO_ADDR_R4);
 8026               		.loc 1 2064 0
 8027 2d3e 89E2      		ldi r24,lo8(41)
 8028 2d40 90E0      		ldi r25,0
 8029 2d42 0E94 0000 		call clearEEPROM
 8030               	.LVL625:
2065:switcherator.c ****     clearEEPROM(RADIO_ADDR_R5);
 8031               		.loc 1 2065 0
 8032 2d46 8CE2      		ldi r24,lo8(44)
 8033 2d48 90E0      		ldi r25,0
 8034 2d4a 0E94 0000 		call clearEEPROM
 8035               	.LVL626:
2066:switcherator.c ****     clearEEPROM(SWITCH_STUFF);
 8036               		.loc 1 2066 0
 8037 2d4e 80E3      		ldi r24,lo8(48)
 8038 2d50 90E0      		ldi r25,0
 8039 2d52 0E94 0000 		call clearEEPROM
 8040               	.LVL627:
2067:switcherator.c ****     clearEEPROM(PWM_DIR);
 8041               		.loc 1 2067 0
 8042 2d56 85E9      		ldi r24,lo8(-107)
 8043 2d58 91E0      		ldi r25,lo8(1)
 8044 2d5a 0E94 0000 		call clearEEPROM
 8045               	.LVL628:
2068:switcherator.c ****     clearEEPROM(BRIGHTNESS);
 8046               		.loc 1 2068 0
 8047 2d5e 88E9      		ldi r24,lo8(-104)
 8048 2d60 91E0      		ldi r25,lo8(1)
 8049 2d62 0E94 0000 		call clearEEPROM
 8050               	.LVL629:
2070:switcherator.c ****         clearEEPROM((INPUT + (x * INPUT_BYTES)));
 8051               		.loc 1 2070 0
 8052 2d66 82E4      		ldi r24,lo8(66)
 8053 2d68 90E0      		ldi r25,0
 8054 2d6a 0E94 0000 		call clearEEPROM
 8055               	.LVL630:
 8056 2d6e 8CE4      		ldi r24,lo8(76)
 8057 2d70 90E0      		ldi r25,0
 8058 2d72 0E94 0000 		call clearEEPROM
 8059               	.LVL631:
 8060 2d76 86E5      		ldi r24,lo8(86)
 8061 2d78 90E0      		ldi r25,0
 8062 2d7a 0E94 0000 		call clearEEPROM
 8063               	.LVL632:
 8064 2d7e 80E6      		ldi r24,lo8(96)
 8065 2d80 90E0      		ldi r25,0
 8066 2d82 0E94 0000 		call clearEEPROM
 8067               	.LVL633:
2072:switcherator.c ****         clearEEPROM((LIMIT + (x * LIMIT_BYTES)));
 8068               		.loc 1 2072 0
 8069 2d86 8AE6      		ldi r24,lo8(106)
 8070 2d88 90E0      		ldi r25,0
 8071 2d8a 0E94 0000 		call clearEEPROM
 8072               	.LVL634:
 8073 2d8e 8FE6      		ldi r24,lo8(111)
 8074 2d90 90E0      		ldi r25,0
 8075 2d92 0E94 0000 		call clearEEPROM
 8076               	.LVL635:
 8077 2d96 84E7      		ldi r24,lo8(116)
 8078 2d98 90E0      		ldi r25,0
 8079 2d9a 0E94 0000 		call clearEEPROM
 8080               	.LVL636:
 8081 2d9e 89E7      		ldi r24,lo8(121)
 8082 2da0 90E0      		ldi r25,0
 8083 2da2 0E94 0000 		call clearEEPROM
 8084               	.LVL637:
2073:switcherator.c ****     clearEEPROM(PWM_VALUE);
 8085               		.loc 1 2073 0
 8086 2da6 8EE7      		ldi r24,lo8(126)
 8087 2da8 90E0      		ldi r25,0
 8088 2daa 0E94 0000 		call clearEEPROM
 8089               	.LVL638:
2075:switcherator.c ****         clearEEPROM((COLOR_CHANGE + (x * COLOR_CHANGE_BYTES)));
 8090               		.loc 1 2075 0
 8091 2dae 83E8      		ldi r24,lo8(-125)
 8092 2db0 90E0      		ldi r25,0
 8093 2db2 0E94 0000 		call clearEEPROM
 8094               	.LVL639:
 8095 2db6 88E8      		ldi r24,lo8(-120)
 8096 2db8 90E0      		ldi r25,0
 8097 2dba 0E94 0000 		call clearEEPROM
 8098               	.LVL640:
 8099 2dbe 8DE8      		ldi r24,lo8(-115)
 8100 2dc0 90E0      		ldi r25,0
 8101 2dc2 0E94 0000 		call clearEEPROM
 8102               	.LVL641:
 8103 2dc6 82E9      		ldi r24,lo8(-110)
 8104 2dc8 90E0      		ldi r25,0
 8105 2dca 0E94 0000 		call clearEEPROM
 8106               	.LVL642:
 8107 2dce 87E9      		ldi r24,lo8(-105)
 8108 2dd0 90E0      		ldi r25,0
 8109 2dd2 0E94 0000 		call clearEEPROM
 8110               	.LVL643:
 8111 2dd6 8CE9      		ldi r24,lo8(-100)
 8112 2dd8 90E0      		ldi r25,0
 8113 2dda 0E94 0000 		call clearEEPROM
 8114               	.LVL644:
 8115 2dde C1EA      		ldi r28,lo8(-95)
 8116 2de0 D0E0      		ldi r29,0
 8117               	.LVL645:
 8118               	.L563:
2077:switcherator.c ****         clearEEPROM((WEEKLY_PROGRAM + (x * WEEKLY_PROGRAM_BYTES)));
 8119               		.loc 1 2077 0 discriminator 2
 8120 2de2 CE01      		movw r24,r28
 8121 2de4 0E94 0000 		call clearEEPROM
 8122               	.LVL646:
 8123 2de8 2C96      		adiw r28,12
2076:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++)
 8124               		.loc 1 2076 0 discriminator 2
 8125 2dea C139      		cpi r28,-111
 8126 2dec 81E0      		ldi r24,1
 8127 2dee D807      		cpc r29,r24
 8128 2df0 01F4      		brne .L563
2078:switcherator.c ****     clearEEPROM(TWEAK_TIMER);
 8129               		.loc 1 2078 0
 8130 2df2 81E9      		ldi r24,lo8(-111)
 8131 2df4 91E0      		ldi r25,lo8(1)
 8132 2df6 0E94 0000 		call clearEEPROM
 8133               	.LVL647:
 8134               	/* epilogue start */
2080:switcherator.c **** }
 8135               		.loc 1 2080 0
 8136 2dfa DF91      		pop r29
 8137 2dfc CF91      		pop r28
2079:switcherator.c ****     ok();
 8138               		.loc 1 2079 0
 8139 2dfe 0C94 0000 		jmp ok
 8140               	.LVL648:
 8141               	.LFE46:
 8143               	.global	saveToEEPROM
 8145               	saveToEEPROM:
 8146               	.LFB45:
1926:switcherator.c **** void saveToEEPROM(void) {
 8147               		.loc 1 1926 0
 8148 2e02 BF92      		push r11
 8149               	.LCFI194:
 8150 2e04 CF92      		push r12
 8151               	.LCFI195:
 8152 2e06 DF92      		push r13
 8153               	.LCFI196:
 8154 2e08 EF92      		push r14
 8155               	.LCFI197:
 8156 2e0a FF92      		push r15
 8157               	.LCFI198:
 8158 2e0c 0F93      		push r16
 8159               	.LCFI199:
 8160 2e0e 1F93      		push r17
 8161               	.LCFI200:
 8162 2e10 CF93      		push r28
 8163               	.LCFI201:
 8164 2e12 DF93      		push r29
 8165               	.LCFI202:
 8166 2e14 CDB7      		in r28,__SP_L__
 8167 2e16 DEB7      		in r29,__SP_H__
 8168               	.LCFI203:
 8169 2e18 2E97      		sbiw r28,14
 8170               	.LCFI204:
 8171 2e1a 0FB6      		in __tmp_reg__,__SREG__
 8172 2e1c F894      		cli
 8173 2e1e DEBF      		out __SP_H__,r29
 8174 2e20 0FBE      		out __SREG__,__tmp_reg__
 8175 2e22 CDBF      		out __SP_L__,r28
 8176               	/* prologue: function */
 8177               	/* frame size = 14 */
 8178               	/* stack size = 23 */
 8179               	.L__stack_usage = 23
 8180               	.LVL649:
1930:switcherator.c ****     if (tx_addr > 0) {
 8181               		.loc 1 1930 0
 8182 2e24 B090 0000 		lds r11,tx_addr
 8183 2e28 C090 0000 		lds r12,tx_addr+1
 8184 2e2c D090 0000 		lds r13,tx_addr+2
 8185 2e30 E090 0000 		lds r14,tx_addr+3
 8186 2e34 F090 0000 		lds r15,tx_addr+4
 8187 2e38 B091 0000 		lds r27,tx_addr+5
 8188 2e3c F091 0000 		lds r31,tx_addr+6
 8189 2e40 E091 0000 		lds r30,tx_addr+7
 8190 2e44 2B2D      		mov r18,r11
 8191 2e46 3C2D      		mov r19,r12
 8192 2e48 4D2D      		mov r20,r13
 8193 2e4a 5E2D      		mov r21,r14
 8194 2e4c 6F2D      		mov r22,r15
 8195 2e4e 7B2F      		mov r23,r27
 8196 2e50 8F2F      		mov r24,r31
 8197 2e52 9E2F      		mov r25,r30
 8198 2e54 A0E0      		ldi r26,0
 8199 2e56 0E94 0000 		call __cmpdi2_s8
 8200 2e5a 01F0      		breq .L566
1931:switcherator.c ****         unformatAddress(tx_addr, tempStuff);
 8201               		.loc 1 1931 0
 8202 2e5c 8E01      		movw r16,r28
 8203 2e5e 0F5F      		subi r16,-1
 8204 2e60 1F4F      		sbci r17,-1
 8205 2e62 0E94 0000 		call unformatAddress
 8206               	.LVL650:
1932:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_TX, RADIO_ADDR_TX_BYTES);
 8207               		.loc 1 1932 0
 8208 2e66 47E0      		ldi r20,lo8(7)
 8209 2e68 50E0      		ldi r21,0
 8210 2e6a 6EE0      		ldi r22,lo8(14)
 8211 2e6c 70E0      		ldi r23,0
 8212 2e6e C801      		movw r24,r16
 8213 2e70 0E94 0000 		call writeEEPROM
 8214               	.LVL651:
 8215               	.L566:
1934:switcherator.c ****     if (rx_addr_p0 > 0) {
 8216               		.loc 1 1934 0
 8217 2e74 B090 0000 		lds r11,rx_addr_p0
 8218 2e78 C090 0000 		lds r12,rx_addr_p0+1
 8219 2e7c D090 0000 		lds r13,rx_addr_p0+2
 8220 2e80 E090 0000 		lds r14,rx_addr_p0+3
 8221 2e84 F090 0000 		lds r15,rx_addr_p0+4
 8222 2e88 B091 0000 		lds r27,rx_addr_p0+5
 8223 2e8c F091 0000 		lds r31,rx_addr_p0+6
 8224 2e90 E091 0000 		lds r30,rx_addr_p0+7
 8225 2e94 2B2D      		mov r18,r11
 8226 2e96 3C2D      		mov r19,r12
 8227 2e98 4D2D      		mov r20,r13
 8228 2e9a 5E2D      		mov r21,r14
 8229 2e9c 6F2D      		mov r22,r15
 8230 2e9e 7B2F      		mov r23,r27
 8231 2ea0 8F2F      		mov r24,r31
 8232 2ea2 9E2F      		mov r25,r30
 8233 2ea4 A0E0      		ldi r26,0
 8234 2ea6 0E94 0000 		call __cmpdi2_s8
 8235 2eaa 01F0      		breq .L567
1935:switcherator.c ****         unformatAddress(rx_addr_p0, tempStuff);
 8236               		.loc 1 1935 0
 8237 2eac 8E01      		movw r16,r28
 8238 2eae 0F5F      		subi r16,-1
 8239 2eb0 1F4F      		sbci r17,-1
 8240 2eb2 0E94 0000 		call unformatAddress
 8241               	.LVL652:
1936:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R0, RADIO_ADDR_R0_BYTES);
 8242               		.loc 1 1936 0
 8243 2eb6 47E0      		ldi r20,lo8(7)
 8244 2eb8 50E0      		ldi r21,0
 8245 2eba 65E1      		ldi r22,lo8(21)
 8246 2ebc 70E0      		ldi r23,0
 8247 2ebe C801      		movw r24,r16
 8248 2ec0 0E94 0000 		call writeEEPROM
 8249               	.LVL653:
 8250               	.L567:
1938:switcherator.c ****     if (rx_addr_p1 > 0) {
 8251               		.loc 1 1938 0
 8252 2ec4 B090 0000 		lds r11,rx_addr_p1
 8253 2ec8 C090 0000 		lds r12,rx_addr_p1+1
 8254 2ecc D090 0000 		lds r13,rx_addr_p1+2
 8255 2ed0 E090 0000 		lds r14,rx_addr_p1+3
 8256 2ed4 F090 0000 		lds r15,rx_addr_p1+4
 8257 2ed8 B091 0000 		lds r27,rx_addr_p1+5
 8258 2edc F091 0000 		lds r31,rx_addr_p1+6
 8259 2ee0 E091 0000 		lds r30,rx_addr_p1+7
 8260 2ee4 2B2D      		mov r18,r11
 8261 2ee6 3C2D      		mov r19,r12
 8262 2ee8 4D2D      		mov r20,r13
 8263 2eea 5E2D      		mov r21,r14
 8264 2eec 6F2D      		mov r22,r15
 8265 2eee 7B2F      		mov r23,r27
 8266 2ef0 8F2F      		mov r24,r31
 8267 2ef2 9E2F      		mov r25,r30
 8268 2ef4 A0E0      		ldi r26,0
 8269 2ef6 0E94 0000 		call __cmpdi2_s8
 8270 2efa 01F0      		breq .L568
1939:switcherator.c ****         unformatAddress(rx_addr_p1, tempStuff);
 8271               		.loc 1 1939 0
 8272 2efc 8E01      		movw r16,r28
 8273 2efe 0F5F      		subi r16,-1
 8274 2f00 1F4F      		sbci r17,-1
 8275 2f02 0E94 0000 		call unformatAddress
 8276               	.LVL654:
1940:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R1, RADIO_ADDR_R1_BYTES);
 8277               		.loc 1 1940 0
 8278 2f06 47E0      		ldi r20,lo8(7)
 8279 2f08 50E0      		ldi r21,0
 8280 2f0a 6CE1      		ldi r22,lo8(28)
 8281 2f0c 70E0      		ldi r23,0
 8282 2f0e C801      		movw r24,r16
 8283 2f10 0E94 0000 		call writeEEPROM
 8284               	.LVL655:
 8285               	.L568:
1942:switcherator.c ****     if (rx_addr_p2 > 0) {
 8286               		.loc 1 1942 0
 8287 2f14 E091 0000 		lds r30,rx_addr_p2
 8288 2f18 3091 0000 		lds r19,rx_addr_p2+1
 8289 2f1c 4091 0000 		lds r20,rx_addr_p2+2
 8290 2f20 5091 0000 		lds r21,rx_addr_p2+3
 8291 2f24 6091 0000 		lds r22,rx_addr_p2+4
 8292 2f28 7091 0000 		lds r23,rx_addr_p2+5
 8293 2f2c 2E2F      		mov r18,r30
 8294 2f2e 8091 0000 		lds r24,rx_addr_p2+6
 8295 2f32 9091 0000 		lds r25,rx_addr_p2+7
 8296 2f36 A0E0      		ldi r26,0
 8297 2f38 0E94 0000 		call __cmpdi2_s8
 8298 2f3c 01F0      		breq .L569
1943:switcherator.c ****         tempStuff[0] = rx_addr_p2;
 8299               		.loc 1 1943 0
 8300 2f3e E983      		std Y+1,r30
1944:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R2, RADIO_ADDR_R2_BYTES);
 8301               		.loc 1 1944 0
 8302 2f40 43E0      		ldi r20,lo8(3)
 8303 2f42 50E0      		ldi r21,0
 8304 2f44 63E2      		ldi r22,lo8(35)
 8305 2f46 70E0      		ldi r23,0
 8306 2f48 CE01      		movw r24,r28
 8307 2f4a 0196      		adiw r24,1
 8308 2f4c 0E94 0000 		call writeEEPROM
 8309               	.LVL656:
 8310               	.L569:
1946:switcherator.c ****     if (rx_addr_p3 > 0) {
 8311               		.loc 1 1946 0
 8312 2f50 E091 0000 		lds r30,rx_addr_p3
 8313 2f54 3091 0000 		lds r19,rx_addr_p3+1
 8314 2f58 4091 0000 		lds r20,rx_addr_p3+2
 8315 2f5c 5091 0000 		lds r21,rx_addr_p3+3
 8316 2f60 6091 0000 		lds r22,rx_addr_p3+4
 8317 2f64 7091 0000 		lds r23,rx_addr_p3+5
 8318 2f68 2E2F      		mov r18,r30
 8319 2f6a 8091 0000 		lds r24,rx_addr_p3+6
 8320 2f6e 9091 0000 		lds r25,rx_addr_p3+7
 8321 2f72 A0E0      		ldi r26,0
 8322 2f74 0E94 0000 		call __cmpdi2_s8
 8323 2f78 01F0      		breq .L570
1947:switcherator.c ****         tempStuff[0] = rx_addr_p3;
 8324               		.loc 1 1947 0
 8325 2f7a E983      		std Y+1,r30
1948:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R3, RADIO_ADDR_R3_BYTES);
 8326               		.loc 1 1948 0
 8327 2f7c 43E0      		ldi r20,lo8(3)
 8328 2f7e 50E0      		ldi r21,0
 8329 2f80 66E2      		ldi r22,lo8(38)
 8330 2f82 70E0      		ldi r23,0
 8331 2f84 CE01      		movw r24,r28
 8332 2f86 0196      		adiw r24,1
 8333 2f88 0E94 0000 		call writeEEPROM
 8334               	.LVL657:
 8335               	.L570:
1950:switcherator.c ****     if (rx_addr_p4 > 0) {
 8336               		.loc 1 1950 0
 8337 2f8c E091 0000 		lds r30,rx_addr_p4
 8338 2f90 3091 0000 		lds r19,rx_addr_p4+1
 8339 2f94 4091 0000 		lds r20,rx_addr_p4+2
 8340 2f98 5091 0000 		lds r21,rx_addr_p4+3
 8341 2f9c 6091 0000 		lds r22,rx_addr_p4+4
 8342 2fa0 7091 0000 		lds r23,rx_addr_p4+5
 8343 2fa4 2E2F      		mov r18,r30
 8344 2fa6 8091 0000 		lds r24,rx_addr_p4+6
 8345 2faa 9091 0000 		lds r25,rx_addr_p4+7
 8346 2fae A0E0      		ldi r26,0
 8347 2fb0 0E94 0000 		call __cmpdi2_s8
 8348 2fb4 01F0      		breq .L571
1951:switcherator.c ****         tempStuff[0] = rx_addr_p4;
 8349               		.loc 1 1951 0
 8350 2fb6 E983      		std Y+1,r30
1952:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R4, RADIO_ADDR_R4_BYTES);
 8351               		.loc 1 1952 0
 8352 2fb8 43E0      		ldi r20,lo8(3)
 8353 2fba 50E0      		ldi r21,0
 8354 2fbc 69E2      		ldi r22,lo8(41)
 8355 2fbe 70E0      		ldi r23,0
 8356 2fc0 CE01      		movw r24,r28
 8357 2fc2 0196      		adiw r24,1
 8358 2fc4 0E94 0000 		call writeEEPROM
 8359               	.LVL658:
 8360               	.L571:
1954:switcherator.c ****     if (rx_addr_p5 > 0) {
 8361               		.loc 1 1954 0
 8362 2fc8 E091 0000 		lds r30,rx_addr_p5
 8363 2fcc 3091 0000 		lds r19,rx_addr_p5+1
 8364 2fd0 4091 0000 		lds r20,rx_addr_p5+2
 8365 2fd4 5091 0000 		lds r21,rx_addr_p5+3
 8366 2fd8 6091 0000 		lds r22,rx_addr_p5+4
 8367 2fdc 7091 0000 		lds r23,rx_addr_p5+5
 8368 2fe0 2E2F      		mov r18,r30
 8369 2fe2 8091 0000 		lds r24,rx_addr_p5+6
 8370 2fe6 9091 0000 		lds r25,rx_addr_p5+7
 8371 2fea A0E0      		ldi r26,0
 8372 2fec 0E94 0000 		call __cmpdi2_s8
 8373 2ff0 01F0      		breq .L572
1955:switcherator.c ****         tempStuff[0] = rx_addr_p5;
 8374               		.loc 1 1955 0
 8375 2ff2 E983      		std Y+1,r30
1956:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R5, RADIO_ADDR_R5_BYTES);
 8376               		.loc 1 1956 0
 8377 2ff4 43E0      		ldi r20,lo8(3)
 8378 2ff6 50E0      		ldi r21,0
 8379 2ff8 6CE2      		ldi r22,lo8(44)
 8380 2ffa 70E0      		ldi r23,0
 8381 2ffc CE01      		movw r24,r28
 8382 2ffe 0196      		adiw r24,1
 8383 3000 0E94 0000 		call writeEEPROM
 8384               	.LVL659:
 8385               	.L572:
1959:switcherator.c ****     if (tweakTimer != 0) {
 8386               		.loc 1 1959 0
 8387 3004 8091 0000 		lds r24,tweakTimer
 8388 3008 9091 0000 		lds r25,tweakTimer+1
 8389 300c A091 0000 		lds r26,tweakTimer+2
 8390 3010 B091 0000 		lds r27,tweakTimer+3
 8391 3014 0097      		sbiw r24,0
 8392 3016 A105      		cpc r26,__zero_reg__
 8393 3018 B105      		cpc r27,__zero_reg__
 8394 301a 01F0      		breq .L573
1960:switcherator.c ****         tempStuff[0] = tweakTimer >> 8;
 8395               		.loc 1 1960 0
 8396 301c 9983      		std Y+1,r25
1961:switcherator.c ****         tempStuff[1] = (tweakTimer & 0xff);
 8397               		.loc 1 1961 0
 8398 301e 8A83      		std Y+2,r24
1962:switcherator.c ****         writeEEPROM(tempStuff, TWEAK_TIMER, TWEAK_TIMER_BYTES);
 8399               		.loc 1 1962 0
 8400 3020 44E0      		ldi r20,lo8(4)
 8401 3022 50E0      		ldi r21,0
 8402 3024 61E9      		ldi r22,lo8(-111)
 8403 3026 71E0      		ldi r23,lo8(1)
 8404 3028 CE01      		movw r24,r28
 8405 302a 0196      		adiw r24,1
 8406 302c 0E94 0000 		call writeEEPROM
 8407               	.LVL660:
 8408               	.L573:
1967:switcherator.c ****     if (daylightSavings[0][0] > 0) {
 8409               		.loc 1 1967 0
 8410 3030 8091 0000 		lds r24,daylightSavings
 8411 3034 9091 0000 		lds r25,daylightSavings+1
 8412 3038 0097      		sbiw r24,0
 8413 303a 01F0      		breq .L574
1968:switcherator.c ****         tempStuff[0] = (daylightSavings[0][0] >> 8);
 8414               		.loc 1 1968 0
 8415 303c 9983      		std Y+1,r25
1969:switcherator.c ****         tempStuff[1] = (daylightSavings[0][0] & 0xff);
 8416               		.loc 1 1969 0
 8417 303e 8A83      		std Y+2,r24
1970:switcherator.c ****         tempStuff[2] = (daylightSavings[0][1] >> 8);
 8418               		.loc 1 1970 0
 8419 3040 8091 0000 		lds r24,daylightSavings+2
 8420 3044 9091 0000 		lds r25,daylightSavings+3
 8421 3048 9B83      		std Y+3,r25
1971:switcherator.c ****         tempStuff[3] = (daylightSavings[0][1] & 0xff);
 8422               		.loc 1 1971 0
 8423 304a 8C83      		std Y+4,r24
1972:switcherator.c ****         tempStuff[4] = (daylightSavings[1][0] >> 8);
 8424               		.loc 1 1972 0
 8425 304c 8091 0000 		lds r24,daylightSavings+4
 8426 3050 9091 0000 		lds r25,daylightSavings+5
 8427 3054 9D83      		std Y+5,r25
1973:switcherator.c ****         tempStuff[5] = (daylightSavings[1][0] & 0xff);
 8428               		.loc 1 1973 0
 8429 3056 8E83      		std Y+6,r24
1974:switcherator.c ****         tempStuff[6] = (daylightSavings[1][1] >> 8);
 8430               		.loc 1 1974 0
 8431 3058 8091 0000 		lds r24,daylightSavings+6
 8432 305c 9091 0000 		lds r25,daylightSavings+7
 8433 3060 9F83      		std Y+7,r25
1975:switcherator.c ****         tempStuff[7] = (daylightSavings[1][1] & 0xff);
 8434               		.loc 1 1975 0
 8435 3062 8887      		std Y+8,r24
1976:switcherator.c ****         writeEEPROM(tempStuff, DAYLIGHT_SAVE, DAYLIGHT_SAVE_BYTES);
 8436               		.loc 1 1976 0
 8437 3064 4AE0      		ldi r20,lo8(10)
 8438 3066 50E0      		ldi r21,0
 8439 3068 66E0      		ldi r22,lo8(6)
 8440 306a 70E0      		ldi r23,0
 8441 306c CE01      		movw r24,r28
 8442 306e 0196      		adiw r24,1
 8443 3070 0E94 0000 		call writeEEPROM
 8444               	.LVL661:
 8445               	.L574:
 8446 3074 E0E0      		ldi r30,lo8(switchStuff)
 8447 3076 F0E0      		ldi r31,hi8(switchStuff)
1979:switcherator.c ****     char setupPWM = 0;
 8448               		.loc 1 1979 0
 8449 3078 10E0      		ldi r17,0
1978:switcherator.c ****     char setupaSwitch = 0;
 8450               		.loc 1 1978 0
 8451 307a 80E0      		ldi r24,0
 8452               	.LVL662:
 8453               	.L577:
1982:switcherator.c ****         if (switchStuff[x] < 255)
 8454               		.loc 1 1982 0
 8455 307c 9191      		ld r25,Z+
 8456 307e 9F3F      		cpi r25,lo8(-1)
 8457 3080 01F0      		breq .L575
1983:switcherator.c ****             setupaSwitch = 1;
 8458               		.loc 1 1983 0
 8459 3082 81E0      		ldi r24,lo8(1)
 8460               	.L575:
 8461               	.LVL663:
1984:switcherator.c ****         if (switchStuff[x] >= 200 && switchStuff[x] <= 230)
 8462               		.loc 1 1984 0
 8463 3084 985C      		subi r25,lo8(-(56))
 8464 3086 9F31      		cpi r25,lo8(31)
 8465 3088 00F4      		brsh .L576
1985:switcherator.c ****             setupPWM = 1;
 8466               		.loc 1 1985 0
 8467 308a 11E0      		ldi r17,lo8(1)
 8468               	.L576:
 8469               	.LVL664:
1981:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 8470               		.loc 1 1981 0
 8471 308c 90E0      		ldi r25,hi8(switchStuff+16)
 8472 308e E030      		cpi r30,lo8(switchStuff+16)
 8473 3090 F907      		cpc r31,r25
 8474 3092 01F4      		brne .L577
1987:switcherator.c ****     if (setupaSwitch == 1) {
 8475               		.loc 1 1987 0
 8476 3094 8130      		cpi r24,lo8(1)
 8477 3096 01F4      		brne .L578
1988:switcherator.c ****         writeEEPROM(switchStuff, SWITCH_STUFF, SWITCH_STUFF_BYTES);
 8478               		.loc 1 1988 0
 8479 3098 42E1      		ldi r20,lo8(18)
 8480 309a 50E0      		ldi r21,0
 8481 309c 60E3      		ldi r22,lo8(48)
 8482 309e 70E0      		ldi r23,0
 8483 30a0 80E0      		ldi r24,lo8(switchStuff)
 8484 30a2 90E0      		ldi r25,hi8(switchStuff)
 8485               	.LVL665:
 8486 30a4 0E94 0000 		call writeEEPROM
 8487               	.LVL666:
1989:switcherator.c ****         writeEEPROM(switchBright, BRIGHTNESS, BRIGHTNESS_BYTES);
 8488               		.loc 1 1989 0
 8489 30a8 42E1      		ldi r20,lo8(18)
 8490 30aa 50E0      		ldi r21,0
 8491 30ac 68E9      		ldi r22,lo8(-104)
 8492 30ae 71E0      		ldi r23,lo8(1)
 8493 30b0 80E0      		ldi r24,lo8(switchBright)
 8494 30b2 90E0      		ldi r25,hi8(switchBright)
 8495 30b4 0E94 0000 		call writeEEPROM
 8496               	.LVL667:
 8497               	.L578:
1991:switcherator.c ****     tempStuff[0] = pwmdir;
 8498               		.loc 1 1991 0
 8499 30b8 8091 0000 		lds r24,pwmdir
 8500 30bc 8983      		std Y+1,r24
1992:switcherator.c ****     if (setupPWM == 1)
 8501               		.loc 1 1992 0
 8502 30be 1130      		cpi r17,lo8(1)
 8503 30c0 01F4      		brne .L579
1993:switcherator.c ****         writeEEPROM(tempStuff, PWM_DIR, PWM_DIR_BYTES);
 8504               		.loc 1 1993 0
 8505 30c2 43E0      		ldi r20,lo8(3)
 8506 30c4 50E0      		ldi r21,0
 8507 30c6 65E9      		ldi r22,lo8(-107)
 8508 30c8 71E0      		ldi r23,lo8(1)
 8509 30ca CE01      		movw r24,r28
 8510 30cc 0196      		adiw r24,1
 8511 30ce 0E94 0000 		call writeEEPROM
 8512               	.LVL668:
 8513               	.L579:
 8514 30d2 20E0      		ldi r18,lo8(weeklyProgram)
 8515 30d4 E22E      		mov r14,r18
 8516 30d6 20E0      		ldi r18,hi8(weeklyProgram)
 8517 30d8 F22E      		mov r15,r18
 8518 30da 30E0      		ldi r19,lo8(weeklyProgram+1)
 8519 30dc C32E      		mov r12,r19
 8520 30de 30E0      		ldi r19,hi8(weeklyProgram+1)
 8521 30e0 D32E      		mov r13,r19
1985:switcherator.c ****             setupPWM = 1;
 8522               		.loc 1 1985 0 discriminator 1
 8523 30e2 01EA      		ldi r16,lo8(-95)
 8524 30e4 10E0      		ldi r17,0
 8525               	.LVL669:
 8526               	.L583:
2003:switcherator.c ****         memoryMarker = (WEEKLY_PROGRAM + (x * WEEKLY_PROGRAM_BYTES));
 8527               		.loc 1 2003 0
 8528 30e6 B801      		movw r22,r16
 8529               	.LVL670:
2004:switcherator.c ****         if (weeklyProgram[x][0] != 255 || weeklyProgram[x][1] != 255) {
 8530               		.loc 1 2004 0
 8531 30e8 F701      		movw r30,r14
 8532 30ea 8081      		ld r24,Z
 8533 30ec 8F3F      		cpi r24,lo8(-1)
 8534 30ee 01F4      		brne .L580
2004:switcherator.c ****         if (weeklyProgram[x][0] != 255 || weeklyProgram[x][1] != 255) {
 8535               		.loc 1 2004 0 is_stmt 0 discriminator 1
 8536 30f0 F601      		movw r30,r12
 8537 30f2 8081      		ld r24,Z
 8538 30f4 8F3F      		cpi r24,lo8(-1)
 8539 30f6 01F0      		breq .L581
 8540               	.L580:
 8541 30f8 FE01      		movw r30,r28
 8542 30fa 3196      		adiw r30,1
1985:switcherator.c ****             setupPWM = 1;
 8543               		.loc 1 1985 0 is_stmt 1 discriminator 2
 8544 30fc 80E0      		ldi r24,0
 8545 30fe 90E0      		ldi r25,0
 8546               	.L582:
1926:switcherator.c **** void saveToEEPROM(void) {
 8547               		.loc 1 1926 0 discriminator 2
 8548 3100 D701      		movw r26,r14
 8549 3102 A80F      		add r26,r24
 8550 3104 B91F      		adc r27,r25
2006:switcherator.c ****                 tempStuff[y] = weeklyProgram[x][y];
 8551               		.loc 1 2006 0 discriminator 2
 8552 3106 2C91      		ld r18,X
 8553 3108 2193      		st Z+,r18
2005:switcherator.c ****             for (y = 0; y < 10; y++)
 8554               		.loc 1 2005 0 discriminator 2
 8555 310a 0196      		adiw r24,1
 8556               	.LVL671:
 8557 310c 8A30      		cpi r24,10
 8558 310e 9105      		cpc r25,__zero_reg__
 8559 3110 01F4      		brne .L582
2007:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, WEEKLY_PROGRAM_BYTES);
 8560               		.loc 1 2007 0
 8561 3112 4CE0      		ldi r20,lo8(12)
 8562 3114 50E0      		ldi r21,0
 8563 3116 CE01      		movw r24,r28
 8564               	.LVL672:
 8565 3118 0196      		adiw r24,1
 8566 311a 0E94 0000 		call writeEEPROM
 8567               	.LVL673:
 8568               	.L581:
 8569 311e FAE0      		ldi r31,10
 8570 3120 EF0E      		add r14,r31
 8571 3122 F11C      		adc r15,__zero_reg__
 8572 3124 8AE0      		ldi r24,10
 8573 3126 C80E      		add r12,r24
 8574 3128 D11C      		adc r13,__zero_reg__
 8575 312a 045F      		subi r16,-12
 8576 312c 1F4F      		sbci r17,-1
2002:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 8577               		.loc 1 2002 0
 8578 312e 0139      		cpi r16,-111
 8579 3130 91E0      		ldi r25,1
 8580 3132 1907      		cpc r17,r25
 8581 3134 01F4      		brne .L583
 8582 3136 90E0      		ldi r25,lo8(inputs)
 8583 3138 E92E      		mov r14,r25
 8584 313a 90E0      		ldi r25,hi8(inputs)
 8585 313c F92E      		mov r15,r25
 8586 313e 02E4      		ldi r16,lo8(66)
 8587 3140 10E0      		ldi r17,0
 8588               	.L586:
2014:switcherator.c ****         if (inputs[x][0] != 255) {
 8589               		.loc 1 2014 0
 8590 3142 F701      		movw r30,r14
 8591 3144 8081      		ld r24,Z
 8592 3146 8F3F      		cpi r24,lo8(-1)
 8593 3148 01F0      		breq .L584
 8594 314a FE01      		movw r30,r28
 8595 314c 3196      		adiw r30,1
 8596 314e 80E0      		ldi r24,0
 8597 3150 90E0      		ldi r25,0
 8598               	.L585:
1926:switcherator.c **** void saveToEEPROM(void) {
 8599               		.loc 1 1926 0 discriminator 2
 8600 3152 D701      		movw r26,r14
 8601 3154 A80F      		add r26,r24
 8602 3156 B91F      		adc r27,r25
2016:switcherator.c ****                 tempStuff[y] = inputs[x][y];
 8603               		.loc 1 2016 0 discriminator 2
 8604 3158 2C91      		ld r18,X
 8605 315a 2193      		st Z+,r18
2015:switcherator.c ****             for (y = 0; y < 8; y++) {
 8606               		.loc 1 2015 0 discriminator 2
 8607 315c 0196      		adiw r24,1
 8608               	.LVL674:
 8609 315e 8830      		cpi r24,8
 8610 3160 9105      		cpc r25,__zero_reg__
 8611 3162 01F4      		brne .L585
2018:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, INPUT_BYTES);
 8612               		.loc 1 2018 0
 8613 3164 4AE0      		ldi r20,lo8(10)
 8614 3166 50E0      		ldi r21,0
 8615 3168 B801      		movw r22,r16
 8616 316a CE01      		movw r24,r28
 8617               	.LVL675:
 8618 316c 0196      		adiw r24,1
 8619 316e 0E94 0000 		call writeEEPROM
 8620               	.LVL676:
 8621               	.L584:
 8622 3172 F8E0      		ldi r31,8
 8623 3174 EF0E      		add r14,r31
 8624 3176 F11C      		adc r15,__zero_reg__
 8625 3178 065F      		subi r16,-10
 8626 317a 1F4F      		sbci r17,-1
2012:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 8627               		.loc 1 2012 0
 8628 317c 0A36      		cpi r16,106
 8629 317e 1105      		cpc r17,__zero_reg__
 8630 3180 01F4      		brne .L586
 8631 3182 00E0      		ldi r16,lo8(timeLimits)
 8632 3184 10E0      		ldi r17,hi8(timeLimits)
 8633 3186 8AE6      		ldi r24,lo8(106)
 8634 3188 E82E      		mov r14,r24
 8635 318a F12C      		mov r15,__zero_reg__
 8636               	.L588:
2025:switcherator.c ****         if (timeLimits[x][2] > 0) {
 8637               		.loc 1 2025 0
 8638 318c F801      		movw r30,r16
 8639 318e 8085      		ldd r24,Z+8
 8640 3190 9185      		ldd r25,Z+9
 8641 3192 A285      		ldd r26,Z+10
 8642 3194 B385      		ldd r27,Z+11
 8643 3196 0097      		sbiw r24,0
 8644 3198 A105      		cpc r26,__zero_reg__
 8645 319a B105      		cpc r27,__zero_reg__
 8646 319c 01F0      		breq .L587
 8647               	.LVL677:
2027:switcherator.c ****                 tempStuff[y] = timeLimits[x][y];
 8648               		.loc 1 2027 0 discriminator 1
 8649 319e 2081      		ld r18,Z
 8650 31a0 2983      		std Y+1,r18
 8651               	.LVL678:
 8652 31a2 2481      		ldd r18,Z+4
 8653 31a4 2A83      		std Y+2,r18
 8654               	.LVL679:
 8655 31a6 8B83      		std Y+3,r24
 8656               	.LVL680:
2029:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, INPUT_BYTES);
 8657               		.loc 1 2029 0 discriminator 1
 8658 31a8 4AE0      		ldi r20,lo8(10)
 8659 31aa 50E0      		ldi r21,0
 8660 31ac B701      		movw r22,r14
 8661 31ae CE01      		movw r24,r28
 8662 31b0 0196      		adiw r24,1
 8663 31b2 0E94 0000 		call writeEEPROM
 8664               	.LVL681:
 8665               	.L587:
 8666 31b6 045F      		subi r16,-12
 8667 31b8 1F4F      		sbci r17,-1
 8668 31ba F5E0      		ldi r31,5
 8669 31bc EF0E      		add r14,r31
 8670 31be F11C      		adc r15,__zero_reg__
2023:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++) {
 8671               		.loc 1 2023 0
 8672 31c0 8EE7      		ldi r24,126
 8673 31c2 E816      		cp r14,r24
 8674 31c4 F104      		cpc r15,__zero_reg__
 8675 31c6 01F4      		brne .L588
 8676               	.LVL682:
2036:switcherator.c ****     if (pwmValues[0] != 0 || pwmValues[1] != 0 || pwmValues[2] != 0) {
 8677               		.loc 1 2036 0
 8678 31c8 8091 0000 		lds r24,pwmValues
 8679 31cc 8111      		cpse r24,__zero_reg__
 8680 31ce 00C0      		rjmp .L589
2036:switcherator.c ****     if (pwmValues[0] != 0 || pwmValues[1] != 0 || pwmValues[2] != 0) {
 8681               		.loc 1 2036 0 is_stmt 0 discriminator 1
 8682 31d0 9091 0000 		lds r25,pwmValues+1
 8683 31d4 9923      		tst r25
 8684 31d6 01F0      		breq .L590
 8685               	.L589:
 8686               	.LVL683:
2038:switcherator.c ****             tempStuff[y] = pwmValues[y];
 8687               		.loc 1 2038 0 is_stmt 1 discriminator 1
 8688 31d8 8983      		std Y+1,r24
 8689               	.LVL684:
 8690 31da 8091 0000 		lds r24,pwmValues+1
 8691 31de 8A83      		std Y+2,r24
 8692               	.LVL685:
 8693 31e0 8091 0000 		lds r24,pwmValues+2
 8694 31e4 8B83      		std Y+3,r24
 8695               	.LVL686:
2040:switcherator.c ****         writeEEPROM(tempStuff, memoryMarker, PWM_VALUE_BYTES);
 8696               		.loc 1 2040 0 discriminator 1
 8697 31e6 45E0      		ldi r20,lo8(5)
 8698 31e8 50E0      		ldi r21,0
 8699 31ea 6EE7      		ldi r22,lo8(126)
 8700 31ec 70E0      		ldi r23,0
 8701 31ee CE01      		movw r24,r28
 8702 31f0 0196      		adiw r24,1
 8703 31f2 0E94 0000 		call writeEEPROM
 8704               	.LVL687:
 8705               	.L592:
 8706 31f6 B0E0      		ldi r27,lo8(inputs+2)
 8707 31f8 EB2E      		mov r14,r27
 8708 31fa B0E0      		ldi r27,hi8(inputs+2)
 8709 31fc FB2E      		mov r15,r27
2012:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 8710               		.loc 1 2012 0 discriminator 1
 8711 31fe 03E8      		ldi r16,lo8(-125)
 8712 3200 10E0      		ldi r17,0
 8713 3202 00C0      		rjmp .L591
 8714               	.LVL688:
 8715               	.L590:
2036:switcherator.c ****     if (pwmValues[0] != 0 || pwmValues[1] != 0 || pwmValues[2] != 0) {
 8716               		.loc 1 2036 0 discriminator 1
 8717 3204 9091 0000 		lds r25,pwmValues+2
 8718 3208 9111      		cpse r25,__zero_reg__
 8719 320a 00C0      		rjmp .L589
 8720 320c 00C0      		rjmp .L592
 8721               	.LVL689:
 8722               	.L591:
2045:switcherator.c ****         memoryMarker = (COLOR_CHANGE + (x * COLOR_CHANGE_BYTES));
 8723               		.loc 1 2045 0
 8724 320e B801      		movw r22,r16
 8725               	.LVL690:
2046:switcherator.c ****         if (colorChanges[0][0] != 0 || colorChanges[0][1] != 1 || colorChanges[0][2] != 0) {
 8726               		.loc 1 2046 0
 8727 3210 8091 0000 		lds r24,colorChanges
 8728 3214 8111      		cpse r24,__zero_reg__
 8729 3216 00C0      		rjmp .L593
2046:switcherator.c ****         if (colorChanges[0][0] != 0 || colorChanges[0][1] != 1 || colorChanges[0][2] != 0) {
 8730               		.loc 1 2046 0 is_stmt 0 discriminator 1
 8731 3218 8091 0000 		lds r24,colorChanges+1
 8732 321c 8130      		cpi r24,lo8(1)
 8733 321e 01F0      		breq .L594
 8734               	.L593:
 8735               	.LVL691:
1926:switcherator.c **** void saveToEEPROM(void) {
 8736               		.loc 1 1926 0 is_stmt 1 discriminator 1
 8737 3220 F701      		movw r30,r14
 8738 3222 3297      		sbiw r30,2
2048:switcherator.c ****                 tempStuff[y] = inputs[x][y];
 8739               		.loc 1 2048 0 discriminator 1
 8740 3224 8081      		ld r24,Z
 8741 3226 8983      		std Y+1,r24
 8742               	.LVL692:
1926:switcherator.c **** void saveToEEPROM(void) {
 8743               		.loc 1 1926 0 discriminator 1
 8744 3228 F701      		movw r30,r14
 8745 322a 3197      		sbiw r30,1
2048:switcherator.c ****                 tempStuff[y] = inputs[x][y];
 8746               		.loc 1 2048 0 discriminator 1
 8747 322c 8081      		ld r24,Z
 8748 322e 8A83      		std Y+2,r24
 8749               	.LVL693:
 8750 3230 F701      		movw r30,r14
 8751 3232 8081      		ld r24,Z
 8752 3234 8B83      		std Y+3,r24
 8753               	.LVL694:
2050:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, COLOR_CHANGE_BYTES);
 8754               		.loc 1 2050 0 discriminator 1
 8755 3236 45E0      		ldi r20,lo8(5)
 8756 3238 50E0      		ldi r21,0
 8757 323a CE01      		movw r24,r28
 8758 323c 0196      		adiw r24,1
 8759 323e 0E94 0000 		call writeEEPROM
 8760               	.LVL695:
 8761 3242 00C0      		rjmp .L595
 8762               	.LVL696:
 8763               	.L594:
2046:switcherator.c ****         if (colorChanges[0][0] != 0 || colorChanges[0][1] != 1 || colorChanges[0][2] != 0) {
 8764               		.loc 1 2046 0 discriminator 1
 8765 3244 8091 0000 		lds r24,colorChanges+2
 8766 3248 8111      		cpse r24,__zero_reg__
 8767 324a 00C0      		rjmp .L593
 8768               	.LVL697:
 8769               	.L595:
 8770 324c F8E0      		ldi r31,8
 8771 324e EF0E      		add r14,r31
 8772 3250 F11C      		adc r15,__zero_reg__
 8773 3252 0B5F      		subi r16,-5
 8774 3254 1F4F      		sbci r17,-1
2044:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 8775               		.loc 1 2044 0
 8776 3256 013A      		cpi r16,-95
 8777 3258 1105      		cpc r17,__zero_reg__
 8778 325a 01F4      		brne .L591
2053:switcherator.c ****     ok();
 8779               		.loc 1 2053 0
 8780 325c 0E94 0000 		call ok
 8781               	.LVL698:
 8782               	/* epilogue start */
2054:switcherator.c **** }
 8783               		.loc 1 2054 0
 8784 3260 2E96      		adiw r28,14
 8785 3262 0FB6      		in __tmp_reg__,__SREG__
 8786 3264 F894      		cli
 8787 3266 DEBF      		out __SP_H__,r29
 8788 3268 0FBE      		out __SREG__,__tmp_reg__
 8789 326a CDBF      		out __SP_L__,r28
 8790 326c DF91      		pop r29
 8791 326e CF91      		pop r28
 8792 3270 1F91      		pop r17
 8793               	.LVL699:
 8794 3272 0F91      		pop r16
 8795 3274 FF90      		pop r15
 8796 3276 EF90      		pop r14
 8797 3278 DF90      		pop r13
 8798 327a CF90      		pop r12
 8799 327c BF90      		pop r11
 8800 327e 0895      		ret
 8801               	.LFE45:
 8803               	.global	pwmValueSet
 8805               	pwmValueSet:
 8806               	.LFB24:
 932:switcherator.c **** void pwmValueSet(char * commandReceived) {
 8807               		.loc 1 932 0
 8808               	.LVL700:
 8809 3280 CF92      		push r12
 8810               	.LCFI205:
 8811 3282 DF92      		push r13
 8812               	.LCFI206:
 8813 3284 EF92      		push r14
 8814               	.LCFI207:
 8815 3286 FF92      		push r15
 8816               	.LCFI208:
 8817 3288 0F93      		push r16
 8818               	.LCFI209:
 8819 328a 1F93      		push r17
 8820               	.LCFI210:
 8821 328c CF93      		push r28
 8822               	.LCFI211:
 8823 328e DF93      		push r29
 8824               	.LCFI212:
 8825               	/* prologue: function */
 8826               	/* frame size = 0 */
 8827               	/* stack size = 8 */
 8828               	.L__stack_usage = 8
 8829 3290 EC01      		movw r28,r24
 933:switcherator.c ****     tempLongString[3] = 0;
 8830               		.loc 1 933 0
 8831 3292 1092 0000 		sts tempLongString+3,__zero_reg__
 934:switcherator.c ****     tempLongString[0] = commandReceived[6];
 8832               		.loc 1 934 0
 8833 3296 40E0      		ldi r20,lo8(tempLongString)
 8834 3298 C42E      		mov r12,r20
 8835 329a 40E0      		ldi r20,hi8(tempLongString)
 8836 329c D42E      		mov r13,r20
 8837 329e 8E81      		ldd r24,Y+6
 8838               	.LVL701:
 8839 32a0 F601      		movw r30,r12
 8840 32a2 8083      		st Z,r24
 935:switcherator.c ****     tempLongString[1] = commandReceived[7];
 8841               		.loc 1 935 0
 8842 32a4 50E0      		ldi r21,lo8(tempLongString+1)
 8843 32a6 E52E      		mov r14,r21
 8844 32a8 50E0      		ldi r21,hi8(tempLongString+1)
 8845 32aa F52E      		mov r15,r21
 8846 32ac 8F81      		ldd r24,Y+7
 8847 32ae F701      		movw r30,r14
 8848 32b0 8083      		st Z,r24
 936:switcherator.c ****     tempLongString[2] = commandReceived[8];
 8849               		.loc 1 936 0
 8850 32b2 00E0      		ldi r16,lo8(tempLongString+2)
 8851 32b4 10E0      		ldi r17,hi8(tempLongString+2)
 8852 32b6 8885      		ldd r24,Y+8
 8853 32b8 F801      		movw r30,r16
 8854 32ba 8083      		st Z,r24
 937:switcherator.c ****     pwmValues[0] = atoi(tempLongString);
 8855               		.loc 1 937 0
 8856 32bc C601      		movw r24,r12
 8857 32be 0E94 0000 		call atoi
 8858               	.LVL702:
 8859 32c2 8093 0000 		sts pwmValues,r24
 938:switcherator.c ****     tempLongString[0] = commandReceived[10];
 8860               		.loc 1 938 0
 8861 32c6 8A85      		ldd r24,Y+10
 8862 32c8 F601      		movw r30,r12
 8863 32ca 8083      		st Z,r24
 939:switcherator.c ****     tempLongString[1] = commandReceived[11];
 8864               		.loc 1 939 0
 8865 32cc 8B85      		ldd r24,Y+11
 8866 32ce F701      		movw r30,r14
 8867 32d0 8083      		st Z,r24
 940:switcherator.c ****     tempLongString[2] = commandReceived[12];
 8868               		.loc 1 940 0
 8869 32d2 8C85      		ldd r24,Y+12
 8870 32d4 F801      		movw r30,r16
 8871 32d6 8083      		st Z,r24
 941:switcherator.c ****     pwmValues[1] = atoi(tempLongString);
 8872               		.loc 1 941 0
 8873 32d8 C601      		movw r24,r12
 8874 32da 0E94 0000 		call atoi
 8875               	.LVL703:
 8876 32de 8093 0000 		sts pwmValues+1,r24
 942:switcherator.c ****     tempLongString[0] = commandReceived[14];
 8877               		.loc 1 942 0
 8878 32e2 8E85      		ldd r24,Y+14
 8879 32e4 F601      		movw r30,r12
 8880 32e6 8083      		st Z,r24
 943:switcherator.c ****     tempLongString[1] = commandReceived[15];
 8881               		.loc 1 943 0
 8882 32e8 8F85      		ldd r24,Y+15
 8883 32ea F701      		movw r30,r14
 8884 32ec 8083      		st Z,r24
 944:switcherator.c ****     tempLongString[2] = commandReceived[16];
 8885               		.loc 1 944 0
 8886 32ee 8889      		ldd r24,Y+16
 8887 32f0 F801      		movw r30,r16
 8888 32f2 8083      		st Z,r24
 945:switcherator.c ****     pwmValues[2] = atoi(tempLongString);
 8889               		.loc 1 945 0
 8890 32f4 C601      		movw r24,r12
 8891 32f6 0E94 0000 		call atoi
 8892               	.LVL704:
 8893 32fa 8093 0000 		sts pwmValues+2,r24
 946:switcherator.c ****     statusMsg[0] = 0;
 8894               		.loc 1 946 0
 8895 32fe 1092 0000 		sts statusMsg,__zero_reg__
 8896               	/* epilogue start */
 948:switcherator.c **** }
 8897               		.loc 1 948 0
 8898 3302 DF91      		pop r29
 8899 3304 CF91      		pop r28
 8900               	.LVL705:
 8901 3306 1F91      		pop r17
 8902 3308 0F91      		pop r16
 8903 330a FF90      		pop r15
 8904 330c EF90      		pop r14
 8905 330e DF90      		pop r13
 8906 3310 CF90      		pop r12
 947:switcherator.c ****     ok();
 8907               		.loc 1 947 0
 8908 3312 0C94 0000 		jmp ok
 8909               	.LVL706:
 8910               	.LFE24:
 8912               	.global	setHueSpeed
 8914               	setHueSpeed:
 8915               	.LFB23:
 917:switcherator.c **** void setHueSpeed(char * commandReceived) {
 8916               		.loc 1 917 0
 8917               	.LVL707:
 8918               	/* prologue: function */
 8919               	/* frame size = 0 */
 8920               	/* stack size = 0 */
 8921               	.L__stack_usage = 0
 918:switcherator.c ****     tempIntString[0] = commandReceived[3];
 8922               		.loc 1 918 0
 8923 3316 FC01      		movw r30,r24
 8924 3318 2381      		ldd r18,Z+3
 8925 331a 2093 0000 		sts tempIntString,r18
 919:switcherator.c ****     tempIntString[1] = commandReceived[4];
 8926               		.loc 1 919 0
 8927 331e 8481      		ldd r24,Z+4
 8928               	.LVL708:
 8929 3320 8093 0000 		sts tempIntString+1,r24
 8930               	.LVL709:
 921:switcherator.c ****     programNumber = atoi(tempIntString);
 8931               		.loc 1 921 0
 8932 3324 80E0      		ldi r24,lo8(tempIntString)
 8933 3326 90E0      		ldi r25,hi8(tempIntString)
 8934 3328 0E94 0000 		call atoi
 8935               	.LVL710:
 922:switcherator.c ****     if (programNumber > 0)
 8936               		.loc 1 922 0
 8937 332c 1816      		cp __zero_reg__,r24
 8938 332e 1906      		cpc __zero_reg__,r25
 8939 3330 04F4      		brge .L622
 923:switcherator.c ****         hueSpeed = programNumber;
 8940               		.loc 1 923 0
 8941 3332 9093 0000 		sts hueSpeed+1,r25
 8942 3336 8093 0000 		sts hueSpeed,r24
 8943               	.L622:
 924:switcherator.c ****     ok();
 8944               		.loc 1 924 0
 8945 333a 0C94 0000 		jmp ok
 8946               	.LVL711:
 8947               	.LFE23:
 8949               	.global	cycleHue
 8951               	cycleHue:
 8952               	.LFB22:
 901:switcherator.c **** void cycleHue(char * commandReceived) {
 8953               		.loc 1 901 0
 8954               	.LVL712:
 8955               	/* prologue: function */
 8956               	/* frame size = 0 */
 8957               	/* stack size = 0 */
 8958               	.L__stack_usage = 0
 8959 333e FC01      		movw r30,r24
 903:switcherator.c ****     tempLongString[0] = commandReceived[5];
 8960               		.loc 1 903 0
 8961 3340 8581      		ldd r24,Z+5
 8962               	.LVL713:
 8963 3342 8093 0000 		sts tempLongString,r24
 904:switcherator.c ****     tempLongString[1] = commandReceived[6];
 8964               		.loc 1 904 0
 8965 3346 8681      		ldd r24,Z+6
 8966 3348 8093 0000 		sts tempLongString+1,r24
 905:switcherator.c ****     tempLongString[2] = commandReceived[7];
 8967               		.loc 1 905 0
 8968 334c 8781      		ldd r24,Z+7
 8969 334e 8093 0000 		sts tempLongString+2,r24
 906:switcherator.c ****     tempLongString[3] = commandReceived[8];
 8970               		.loc 1 906 0
 8971 3352 8085      		ldd r24,Z+8
 8972 3354 8093 0000 		sts tempLongString+3,r24
 8973               	.LVL714:
 908:switcherator.c ****     programNumber = atoi(tempLongString);
 8974               		.loc 1 908 0
 8975 3358 80E0      		ldi r24,lo8(tempLongString)
 8976 335a 90E0      		ldi r25,hi8(tempLongString)
 8977 335c 0E94 0000 		call atoi
 8978               	.LVL715:
 909:switcherator.c ****     if (programNumber > 0)
 8979               		.loc 1 909 0
 8980 3360 1816      		cp __zero_reg__,r24
 8981 3362 1906      		cpc __zero_reg__,r25
 8982 3364 04F4      		brge .L624
 910:switcherator.c ****         colorChangeSpeed = programNumber;
 8983               		.loc 1 910 0
 8984 3366 9093 0000 		sts colorChangeSpeed+1,r25
 8985 336a 8093 0000 		sts colorChangeSpeed,r24
 8986               	.L624:
 911:switcherator.c ****     ok();
 8987               		.loc 1 911 0
 8988 336e 0C94 0000 		jmp ok
 8989               	.LVL716:
 8990               	.LFE22:
 8992               	.global	switchClear
 8994               	switchClear:
 8995               	.LFB14:
 524:switcherator.c **** void switchClear(char * commandReceived) {
 8996               		.loc 1 524 0
 8997               	.LVL717:
 8998               	/* prologue: function */
 8999               	/* frame size = 0 */
 9000               	/* stack size = 0 */
 9001               	.L__stack_usage = 0
 527:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 9002               		.loc 1 527 0
 9003 3372 0E94 0000 		call getSwitchNumber
 9004               	.LVL718:
 528:switcherator.c ****     clearTheSwitch(switchNumber);
 9005               		.loc 1 528 0
 9006 3376 0E94 0000 		call clearTheSwitch
 9007               	.LVL719:
 529:switcherator.c ****     ok();
 9008               		.loc 1 529 0
 9009 337a 0C94 0000 		jmp ok
 9010               	.LVL720:
 9011               	.LFE14:
 9013               		.section	.rodata.str1.1
 9014               	.LC65:
 9015 0136 4375 7272 		.string	"Curr Tweak:"
 9015      2054 7765 
 9015      616B 3A00 
 9016               		.text
 9017               	.global	clockTweak
 9019               	clockTweak:
 9020               	.LFB60:
2598:switcherator.c **** void clockTweak(char * commandReceived) {
 9021               		.loc 1 2598 0
 9022               	.LVL721:
 9023               	/* prologue: function */
 9024               	/* frame size = 0 */
 9025               	/* stack size = 0 */
 9026               	.L__stack_usage = 0
 9027 337e FC01      		movw r30,r24
 9028               	.LVL722:
2601:switcherator.c ****         tempLongString[x] = commandReceived[(x + 3)];
 9029               		.loc 1 2601 0
 9030 3380 8381      		ldd r24,Z+3
 9031               	.LVL723:
 9032 3382 8093 0000 		sts tempLongString,r24
 9033               	.LVL724:
 9034 3386 8481      		ldd r24,Z+4
 9035 3388 8093 0000 		sts tempLongString+1,r24
 9036               	.LVL725:
 9037 338c 8581      		ldd r24,Z+5
 9038 338e 8093 0000 		sts tempLongString+2,r24
 9039               	.LVL726:
 9040 3392 8681      		ldd r24,Z+6
 9041 3394 8093 0000 		sts tempLongString+3,r24
 9042               	.LVL727:
2603:switcherator.c ****     int adjustment = atoi(tempLongString);
 9043               		.loc 1 2603 0
 9044 3398 80E0      		ldi r24,lo8(tempLongString)
 9045 339a 90E0      		ldi r25,hi8(tempLongString)
 9046 339c 0E94 0000 		call atoi
 9047               	.LVL728:
2604:switcherator.c ****     if (adjustment == 0) {
 9048               		.loc 1 2604 0
 9049 33a0 0097      		sbiw r24,0
 9050 33a2 01F4      		brne .L627
2605:switcherator.c ****         itoa(tweakTimer, tempLongString, 10);
 9051               		.loc 1 2605 0
 9052 33a4 4AE0      		ldi r20,lo8(10)
 9053 33a6 50E0      		ldi r21,0
 9054 33a8 60E0      		ldi r22,lo8(tempLongString)
 9055 33aa 70E0      		ldi r23,hi8(tempLongString)
 9056 33ac 8091 0000 		lds r24,tweakTimer
 9057 33b0 9091 0000 		lds r25,tweakTimer+1
 9058               	.LVL729:
 9059 33b4 0E94 0000 		call itoa
 9060               	.LVL730:
2606:switcherator.c ****         statusMsg[0] = 0;
 9061               		.loc 1 2606 0
 9062 33b8 1092 0000 		sts statusMsg,__zero_reg__
2607:switcherator.c ****         strcat(statusMsg, "Curr Tweak:");
 9063               		.loc 1 2607 0
 9064 33bc 60E0      		ldi r22,lo8(.LC65)
 9065 33be 70E0      		ldi r23,hi8(.LC65)
 9066 33c0 80E0      		ldi r24,lo8(statusMsg)
 9067 33c2 90E0      		ldi r25,hi8(statusMsg)
 9068 33c4 0E94 0000 		call strcat
 9069               	.LVL731:
2608:switcherator.c ****         strcat(statusMsg, tempLongString);
 9070               		.loc 1 2608 0
 9071 33c8 60E0      		ldi r22,lo8(tempLongString)
 9072 33ca 70E0      		ldi r23,hi8(tempLongString)
 9073 33cc 80E0      		ldi r24,lo8(statusMsg)
 9074 33ce 90E0      		ldi r25,hi8(statusMsg)
 9075 33d0 0E94 0000 		call strcat
 9076               	.LVL732:
2609:switcherator.c ****         sendMessage(statusMsg);
 9077               		.loc 1 2609 0
 9078 33d4 80E0      		ldi r24,lo8(statusMsg)
 9079 33d6 90E0      		ldi r25,hi8(statusMsg)
 9080 33d8 0C94 0000 		jmp sendMessage
 9081               	.LVL733:
 9082               	.L627:
2612:switcherator.c ****     tweakTimer += adjustment;
 9083               		.loc 1 2612 0
 9084 33dc AA27      		clr r26
 9085 33de 97FD      		sbrc r25,7
 9086 33e0 A095      		com r26
 9087 33e2 BA2F      		mov r27,r26
 9088 33e4 4091 0000 		lds r20,tweakTimer
 9089 33e8 5091 0000 		lds r21,tweakTimer+1
 9090 33ec 6091 0000 		lds r22,tweakTimer+2
 9091 33f0 7091 0000 		lds r23,tweakTimer+3
 9092 33f4 480F      		add r20,r24
 9093 33f6 591F      		adc r21,r25
 9094 33f8 6A1F      		adc r22,r26
 9095 33fa 7B1F      		adc r23,r27
 9096 33fc 4093 0000 		sts tweakTimer,r20
 9097 3400 5093 0000 		sts tweakTimer+1,r21
 9098 3404 6093 0000 		sts tweakTimer+2,r22
 9099 3408 7093 0000 		sts tweakTimer+3,r23
2613:switcherator.c ****     ok();
 9100               		.loc 1 2613 0
 9101 340c 0C94 0000 		jmp ok
 9102               	.LVL734:
 9103               	.LFE60:
 9105               		.section	.rodata.str1.1
 9106               	.LC66:
 9107 0142 5365 7420 		.string	"Set @"
 9107      4000 
 9108               	.LC67:
 9109 0148 4240 00   		.string	"B@"
 9110               		.text
 9111               	.global	brightnessSet
 9113               	brightnessSet:
 9114               	.LFB29:
1138:switcherator.c **** void brightnessSet(char * commandReceived) {
 9115               		.loc 1 1138 0
 9116               	.LVL735:
 9117               	/* prologue: function */
 9118               	/* frame size = 0 */
 9119               	/* stack size = 0 */
 9120               	.L__stack_usage = 0
1139:switcherator.c ****     int brightValue = getSwitchNumber(commandReceived);
 9121               		.loc 1 1139 0
 9122 3410 0E94 0000 		call getSwitchNumber
 9123               	.LVL736:
 9124 3414 9C01      		movw r18,r24
 9125               	.LVL737:
 9126 3416 8091 0000 		lds r24,oldBright
1140:switcherator.c ****     if (brightValue == 0) {
 9127               		.loc 1 1140 0
 9128 341a 2115      		cp r18,__zero_reg__
 9129 341c 3105      		cpc r19,__zero_reg__
 9130 341e 01F4      		brne .L629
1142:switcherator.c ****         itoa(oldBright, tempIntString, 10);
 9131               		.loc 1 1142 0
 9132 3420 4AE0      		ldi r20,lo8(10)
 9133 3422 50E0      		ldi r21,0
 9134 3424 60E0      		ldi r22,lo8(tempIntString)
 9135 3426 70E0      		ldi r23,hi8(tempIntString)
 9136 3428 90E0      		ldi r25,0
 9137 342a 0E94 0000 		call itoa
 9138               	.LVL738:
1143:switcherator.c ****         statusMsg[0] = 0;
 9139               		.loc 1 1143 0
 9140 342e 1092 0000 		sts statusMsg,__zero_reg__
1144:switcherator.c ****         strcat(statusMsg, "Set @");
 9141               		.loc 1 1144 0
 9142 3432 60E0      		ldi r22,lo8(.LC66)
 9143 3434 70E0      		ldi r23,hi8(.LC66)
 9144 3436 80E0      		ldi r24,lo8(statusMsg)
 9145 3438 90E0      		ldi r25,hi8(statusMsg)
 9146 343a 0E94 0000 		call strcat
 9147               	.LVL739:
1145:switcherator.c ****         strcat(statusMsg, tempIntString);
 9148               		.loc 1 1145 0
 9149 343e 60E0      		ldi r22,lo8(tempIntString)
 9150 3440 70E0      		ldi r23,hi8(tempIntString)
 9151 3442 80E0      		ldi r24,lo8(statusMsg)
 9152 3444 90E0      		ldi r25,hi8(statusMsg)
 9153 3446 0E94 0000 		call strcat
 9154               	.LVL740:
1146:switcherator.c ****         strcat(statusMsg, "B@");
 9155               		.loc 1 1146 0
 9156 344a 60E0      		ldi r22,lo8(.LC67)
 9157 344c 70E0      		ldi r23,hi8(.LC67)
 9158 344e 80E0      		ldi r24,lo8(statusMsg)
 9159 3450 90E0      		ldi r25,hi8(statusMsg)
 9160 3452 0E94 0000 		call strcat
 9161               	.LVL741:
1147:switcherator.c ****         itoa(bright, tempIntString, 10);
 9162               		.loc 1 1147 0
 9163 3456 4AE0      		ldi r20,lo8(10)
 9164 3458 50E0      		ldi r21,0
 9165 345a 60E0      		ldi r22,lo8(tempIntString)
 9166 345c 70E0      		ldi r23,hi8(tempIntString)
 9167 345e 8091 0000 		lds r24,bright
 9168 3462 9091 0000 		lds r25,bright+1
 9169 3466 0E94 0000 		call itoa
 9170               	.LVL742:
1148:switcherator.c ****         strcat(statusMsg, tempIntString);
 9171               		.loc 1 1148 0
 9172 346a 60E0      		ldi r22,lo8(tempIntString)
 9173 346c 70E0      		ldi r23,hi8(tempIntString)
 9174 346e 80E0      		ldi r24,lo8(statusMsg)
 9175 3470 90E0      		ldi r25,hi8(statusMsg)
 9176 3472 0E94 0000 		call strcat
 9177               	.LVL743:
1149:switcherator.c ****         sendMessage(statusMsg);
 9178               		.loc 1 1149 0
 9179 3476 80E0      		ldi r24,lo8(statusMsg)
 9180 3478 90E0      		ldi r25,hi8(statusMsg)
 9181 347a 0C94 0000 		jmp sendMessage
 9182               	.LVL744:
 9183               	.L629:
 9184 347e 2131      		cpi r18,17
 9185 3480 3105      		cpc r19,__zero_reg__
 9186 3482 04F0      		brlt .L630
 9187 3484 20E1      		ldi r18,lo8(16)
 9188 3486 30E0      		ldi r19,0
 9189               	.LVL745:
 9190               	.L630:
1153:switcherator.c ****         if (oldBright == bright) {
 9191               		.loc 1 1153 0
 9192 3488 90E0      		ldi r25,0
 9193 348a 4091 0000 		lds r20,bright
 9194 348e 5091 0000 		lds r21,bright+1
 9195 3492 8417      		cp r24,r20
 9196 3494 9507      		cpc r25,r21
 9197 3496 01F4      		brne .L631
1155:switcherator.c ****             bright = brightValue;
 9198               		.loc 1 1155 0
 9199 3498 3093 0000 		sts bright+1,r19
 9200 349c 2093 0000 		sts bright,r18
 9201               	.L631:
1157:switcherator.c ****         oldBright = brightValue;
 9202               		.loc 1 1157 0
 9203 34a0 2093 0000 		sts oldBright,r18
1158:switcherator.c ****         switchChanged = 1;
 9204               		.loc 1 1158 0
 9205 34a4 81E0      		ldi r24,lo8(1)
 9206 34a6 8093 0000 		sts switchChanged,r24
1159:switcherator.c ****         ok();
 9207               		.loc 1 1159 0
 9208 34aa 0C94 0000 		jmp ok
 9209               	.LVL746:
 9210               	.LFE29:
 9212               		.section	.rodata.str1.1
 9213               	.LC68:
 9214 014b 6661 696C 		.string	"fail:"
 9214      3A00 
 9215               		.text
 9216               	.global	fail
 9218               	fail:
 9219               	.LFB10:
 382:switcherator.c **** void fail(int failCode) {
 9220               		.loc 1 382 0
 9221               	.LVL747:
 9222 34ae CF93      		push r28
 9223               	.LCFI213:
 9224 34b0 DF93      		push r29
 9225               	.LCFI214:
 9226               	/* prologue: function */
 9227               	/* frame size = 0 */
 9228               	/* stack size = 2 */
 9229               	.L__stack_usage = 2
 9230 34b2 EC01      		movw r28,r24
 383:switcherator.c ****     statusMsg[0] = 0;
 9231               		.loc 1 383 0
 9232 34b4 1092 0000 		sts statusMsg,__zero_reg__
 384:switcherator.c ****     strcat(statusMsg, "fail:");
 9233               		.loc 1 384 0
 9234 34b8 60E0      		ldi r22,lo8(.LC68)
 9235 34ba 70E0      		ldi r23,hi8(.LC68)
 9236 34bc 80E0      		ldi r24,lo8(statusMsg)
 9237 34be 90E0      		ldi r25,hi8(statusMsg)
 9238               	.LVL748:
 9239 34c0 0E94 0000 		call strcat
 9240               	.LVL749:
 385:switcherator.c ****     returnHex(failCode, tempLongString);
 9241               		.loc 1 385 0
 9242 34c4 60E0      		ldi r22,lo8(tempLongString)
 9243 34c6 70E0      		ldi r23,hi8(tempLongString)
 9244 34c8 CE01      		movw r24,r28
 9245 34ca 0E94 0000 		call returnHex
 9246               	.LVL750:
 386:switcherator.c ****     strcat(statusMsg, tempLongString);
 9247               		.loc 1 386 0
 9248 34ce 60E0      		ldi r22,lo8(tempLongString)
 9249 34d0 70E0      		ldi r23,hi8(tempLongString)
 9250 34d2 80E0      		ldi r24,lo8(statusMsg)
 9251 34d4 90E0      		ldi r25,hi8(statusMsg)
 9252 34d6 0E94 0000 		call strcat
 9253               	.LVL751:
 387:switcherator.c ****     sendMessage(statusMsg);
 9254               		.loc 1 387 0
 9255 34da 80E0      		ldi r24,lo8(statusMsg)
 9256 34dc 90E0      		ldi r25,hi8(statusMsg)
 9257               	/* epilogue start */
 388:switcherator.c **** }
 9258               		.loc 1 388 0
 9259 34de DF91      		pop r29
 9260 34e0 CF91      		pop r28
 9261               	.LVL752:
 387:switcherator.c ****     sendMessage(statusMsg);
 9262               		.loc 1 387 0
 9263 34e2 0C94 0000 		jmp sendMessage
 9264               	.LVL753:
 9265               	.LFE10:
 9267               	.global	setDigitalInput
 9269               	setDigitalInput:
 9270               	.LFB78:
3184:switcherator.c **** void setDigitalInput(char * commandReceived) {
 9271               		.loc 1 3184 0
 9272               	.LVL754:
 9273 34e6 5F92      		push r5
 9274               	.LCFI215:
 9275 34e8 6F92      		push r6
 9276               	.LCFI216:
 9277 34ea 7F92      		push r7
 9278               	.LCFI217:
 9279 34ec 8F92      		push r8
 9280               	.LCFI218:
 9281 34ee 9F92      		push r9
 9282               	.LCFI219:
 9283 34f0 AF92      		push r10
 9284               	.LCFI220:
 9285 34f2 BF92      		push r11
 9286               	.LCFI221:
 9287 34f4 CF92      		push r12
 9288               	.LCFI222:
 9289 34f6 DF92      		push r13
 9290               	.LCFI223:
 9291 34f8 EF92      		push r14
 9292               	.LCFI224:
 9293 34fa FF92      		push r15
 9294               	.LCFI225:
 9295 34fc 0F93      		push r16
 9296               	.LCFI226:
 9297 34fe 1F93      		push r17
 9298               	.LCFI227:
 9299 3500 CF93      		push r28
 9300               	.LCFI228:
 9301 3502 DF93      		push r29
 9302               	.LCFI229:
 9303               	/* prologue: function */
 9304               	/* frame size = 0 */
 9305               	/* stack size = 15 */
 9306               	.L__stack_usage = 15
 9307 3504 EC01      		movw r28,r24
 9308               	.LVL755:
3193:switcherator.c ****     tempIntString[0] = commandReceived[3];
 9309               		.loc 1 3193 0
 9310 3506 8B81      		ldd r24,Y+3
 9311               	.LVL756:
 9312 3508 8093 0000 		sts tempIntString,r24
3194:switcherator.c ****     tempIntString[1] = commandReceived[4];
 9313               		.loc 1 3194 0
 9314 350c 8C81      		ldd r24,Y+4
 9315 350e 8093 0000 		sts tempIntString+1,r24
3195:switcherator.c ****     inputNumber = atoi(tempIntString);
 9316               		.loc 1 3195 0
 9317 3512 80E0      		ldi r24,lo8(tempIntString)
 9318 3514 90E0      		ldi r25,hi8(tempIntString)
 9319 3516 0E94 0000 		call atoi
 9320               	.LVL757:
 9321 351a 7C01      		movw r14,r24
 9322               	.LVL758:
3196:switcherator.c ****     if (inputNumber >= NUM_INPUTS) {
 9323               		.loc 1 3196 0
 9324 351c 84E0      		ldi r24,4
 9325 351e E816      		cp r14,r24
 9326 3520 F104      		cpc r15,__zero_reg__
 9327 3522 04F0      		brlt .L634
3197:switcherator.c ****         fail(0x11);
 9328               		.loc 1 3197 0
 9329 3524 81E1      		ldi r24,lo8(17)
 9330 3526 90E0      		ldi r25,0
 9331 3528 00C0      		rjmp .L671
 9332               	.L634:
3200:switcherator.c ****     tempIntString[0] = '0';
 9333               		.loc 1 3200 0
 9334 352a 80E3      		ldi r24,lo8(48)
 9335 352c 8093 0000 		sts tempIntString,r24
3201:switcherator.c ****     tempIntString[1] = commandReceived[6];
 9336               		.loc 1 3201 0
 9337 3530 8E81      		ldd r24,Y+6
 9338 3532 8093 0000 		sts tempIntString+1,r24
3202:switcherator.c ****     pin = atoi(tempIntString);
 9339               		.loc 1 3202 0
 9340 3536 80E0      		ldi r24,lo8(tempIntString)
 9341 3538 90E0      		ldi r25,hi8(tempIntString)
 9342 353a 0E94 0000 		call atoi
 9343               	.LVL759:
 9344 353e 6C01      		movw r12,r24
 9345               	.LVL760:
3203:switcherator.c ****     if (pin > 7) {
 9346               		.loc 1 3203 0
 9347 3540 E7E0      		ldi r30,lo8(7)
 9348 3542 E817      		cp r30,r24
 9349 3544 00F4      		brsh .L635
3204:switcherator.c ****         fail(0x04);
 9350               		.loc 1 3204 0
 9351 3546 84E0      		ldi r24,lo8(4)
 9352 3548 90E0      		ldi r25,0
 9353               	.LVL761:
 9354               	.L671:
 9355               	/* epilogue start */
3318:switcherator.c **** }
 9356               		.loc 1 3318 0
 9357 354a DF91      		pop r29
 9358 354c CF91      		pop r28
 9359               	.LVL762:
 9360 354e 1F91      		pop r17
 9361 3550 0F91      		pop r16
 9362 3552 FF90      		pop r15
 9363 3554 EF90      		pop r14
 9364               	.LVL763:
 9365 3556 DF90      		pop r13
 9366 3558 CF90      		pop r12
 9367 355a BF90      		pop r11
 9368 355c AF90      		pop r10
 9369 355e 9F90      		pop r9
 9370 3560 8F90      		pop r8
 9371 3562 7F90      		pop r7
 9372 3564 6F90      		pop r6
 9373 3566 5F90      		pop r5
3204:switcherator.c ****         fail(0x04);
 9374               		.loc 1 3204 0
 9375 3568 0C94 0000 		jmp fail
 9376               	.LVL764:
 9377               	.L635:
3208:switcherator.c ****     tempIntString[0] = commandReceived[9];
 9378               		.loc 1 3208 0
 9379 356c 8985      		ldd r24,Y+9
 9380 356e 8093 0000 		sts tempIntString,r24
3209:switcherator.c ****     tempIntString[1] = commandReceived[10];
 9381               		.loc 1 3209 0
 9382 3572 8A85      		ldd r24,Y+10
 9383 3574 8093 0000 		sts tempIntString+1,r24
3210:switcherator.c ****     switchNumber = atoi(tempIntString);
 9384               		.loc 1 3210 0
 9385 3578 80E0      		ldi r24,lo8(tempIntString)
 9386 357a 90E0      		ldi r25,hi8(tempIntString)
 9387 357c 0E94 0000 		call atoi
 9388               	.LVL765:
 9389 3580 8C01      		movw r16,r24
 9390               	.LVL766:
3212:switcherator.c ****     tempIntString[0] = commandReceived[15];
 9391               		.loc 1 3212 0
 9392 3582 8F85      		ldd r24,Y+15
 9393 3584 8093 0000 		sts tempIntString,r24
3213:switcherator.c ****     tempIntString[1] = commandReceived[16];
 9394               		.loc 1 3213 0
 9395 3588 8889      		ldd r24,Y+16
 9396 358a 8093 0000 		sts tempIntString+1,r24
3214:switcherator.c ****     pollTime = atoi(tempIntString);
 9397               		.loc 1 3214 0
 9398 358e 80E0      		ldi r24,lo8(tempIntString)
 9399 3590 90E0      		ldi r25,hi8(tempIntString)
 9400 3592 0E94 0000 		call atoi
 9401               	.LVL767:
 9402 3596 4C01      		movw r8,r24
 9403               	.LVL768:
3216:switcherator.c ****     tempLongString[0] = commandReceived[11];
 9404               		.loc 1 3216 0
 9405 3598 8B85      		ldd r24,Y+11
 9406 359a 8093 0000 		sts tempLongString,r24
3217:switcherator.c ****     tempLongString[1] = commandReceived[12];
 9407               		.loc 1 3217 0
 9408 359e 8C85      		ldd r24,Y+12
 9409 35a0 8093 0000 		sts tempLongString+1,r24
3218:switcherator.c ****     tempLongString[2] = commandReceived[13];
 9410               		.loc 1 3218 0
 9411 35a4 8D85      		ldd r24,Y+13
 9412 35a6 8093 0000 		sts tempLongString+2,r24
3219:switcherator.c ****     tempLongString[3] = commandReceived[14];
 9413               		.loc 1 3219 0
 9414 35aa 8E85      		ldd r24,Y+14
 9415 35ac 8093 0000 		sts tempLongString+3,r24
3220:switcherator.c ****     duration = atoi(tempLongString);
 9416               		.loc 1 3220 0
 9417 35b0 80E0      		ldi r24,lo8(tempLongString)
 9418 35b2 90E0      		ldi r25,hi8(tempLongString)
 9419 35b4 0E94 0000 		call atoi
 9420               	.LVL769:
 9421 35b8 582E      		mov r5,r24
 9422               	.LVL770:
3222:switcherator.c ****     if (commandReceived[8] == 'P' || commandReceived[8] == 'p') {
 9423               		.loc 1 3222 0
 9424 35ba 2885      		ldd r18,Y+8
 9425 35bc 2035      		cpi r18,lo8(80)
 9426 35be 01F0      		breq .L636
3222:switcherator.c ****     if (commandReceived[8] == 'P' || commandReceived[8] == 'p') {
 9427               		.loc 1 3222 0 is_stmt 0 discriminator 1
 9428 35c0 2037      		cpi r18,lo8(112)
 9429 35c2 01F4      		brne .L637
 9430               	.L636:
3223:switcherator.c ****         switchNumber += 128;
 9431               		.loc 1 3223 0 is_stmt 1
 9432 35c4 0058      		subi r16,-128
 9433 35c6 1F4F      		sbci r17,-1
 9434               	.LVL771:
 9435               	.L637:
3225:switcherator.c ****     temp = pin * 2;
 9436               		.loc 1 3225 0
 9437 35c8 B601      		movw r22,r12
 9438 35ca 7727      		clr r23
 9439 35cc 9B01      		movw r18,r22
 9440 35ce 220F      		lsl r18
 9441 35d0 331F      		rol r19
 9442               	.LVL772:
3226:switcherator.c ****     if (commandReceived[5] == 'B' || commandReceived[5] == 'b') {
 9443               		.loc 1 3226 0
 9444 35d2 4D81      		ldd r20,Y+5
 9445 35d4 4234      		cpi r20,lo8(66)
 9446 35d6 01F0      		breq .L638
3226:switcherator.c ****     if (commandReceived[5] == 'B' || commandReceived[5] == 'b') {
 9447               		.loc 1 3226 0 is_stmt 0 discriminator 1
 9448 35d8 4236      		cpi r20,lo8(98)
 9449 35da 01F4      		brne .L639
 9450               	.L638:
 9451               	.LVL773:
3229:switcherator.c ****         temp += 16;
 9452               		.loc 1 3229 0 is_stmt 1
 9453 35dc 205F      		subi r18,-16
 9454 35de 3F4F      		sbci r19,-1
 9455               	.LVL774:
3228:switcherator.c ****         realPort = &PORTB;
 9456               		.loc 1 3228 0
 9457 35e0 B5E2      		ldi r27,lo8(37)
 9458 35e2 6B2E      		mov r6,r27
 9459 35e4 712C      		mov r7,__zero_reg__
3227:switcherator.c ****         realDDR = &DDRB;
 9460               		.loc 1 3227 0
 9461 35e6 A4E2      		ldi r26,lo8(36)
 9462 35e8 B0E0      		ldi r27,0
3229:switcherator.c ****         temp += 16;
 9463               		.loc 1 3229 0
 9464 35ea 00C0      		rjmp .L640
 9465               	.LVL775:
 9466               	.L639:
3237:switcherator.c ****     } else if (commandReceived[5] == 'C' || commandReceived[5] == 'c') {
 9467               		.loc 1 3237 0
 9468 35ec 4334      		cpi r20,lo8(67)
 9469 35ee 01F0      		breq .L641
3237:switcherator.c ****     } else if (commandReceived[5] == 'C' || commandReceived[5] == 'c') {
 9470               		.loc 1 3237 0 is_stmt 0 discriminator 1
 9471 35f0 4336      		cpi r20,lo8(99)
 9472 35f2 01F4      		brne .L642
 9473               	.L641:
 9474               	.LVL776:
3240:switcherator.c ****         temp += 32;
 9475               		.loc 1 3240 0 is_stmt 1
 9476 35f4 205E      		subi r18,-32
 9477 35f6 3F4F      		sbci r19,-1
 9478               	.LVL777:
3239:switcherator.c ****         realPort = &PORTC;
 9479               		.loc 1 3239 0
 9480 35f8 A8E2      		ldi r26,lo8(40)
 9481 35fa 6A2E      		mov r6,r26
 9482 35fc 712C      		mov r7,__zero_reg__
3238:switcherator.c ****         realDDR = &DDRC;
 9483               		.loc 1 3238 0
 9484 35fe A7E2      		ldi r26,lo8(39)
 9485 3600 B0E0      		ldi r27,0
3240:switcherator.c ****         temp += 32;
 9486               		.loc 1 3240 0
 9487 3602 00C0      		rjmp .L640
 9488               	.LVL778:
 9489               	.L642:
3243:switcherator.c ****     } else if (commandReceived[5] == 'D' || commandReceived[5] == 'd') {
 9490               		.loc 1 3243 0
 9491 3604 4434      		cpi r20,lo8(68)
 9492 3606 01F0      		breq .L643
3243:switcherator.c ****     } else if (commandReceived[5] == 'D' || commandReceived[5] == 'd') {
 9493               		.loc 1 3243 0 is_stmt 0 discriminator 1
 9494 3608 4436      		cpi r20,lo8(100)
 9495 360a 01F4      		brne .L651
 9496               	.L643:
 9497               	.LVL779:
3246:switcherator.c ****         temp += 48;
 9498               		.loc 1 3246 0 is_stmt 1
 9499 360c 205D      		subi r18,-48
 9500 360e 3F4F      		sbci r19,-1
 9501               	.LVL780:
3245:switcherator.c ****         realPort = &PORTD;
 9502               		.loc 1 3245 0
 9503 3610 FBE2      		ldi r31,lo8(43)
 9504 3612 6F2E      		mov r6,r31
 9505 3614 712C      		mov r7,__zero_reg__
3244:switcherator.c ****         realDDR = &DDRD;
 9506               		.loc 1 3244 0
 9507 3616 AAE2      		ldi r26,lo8(42)
 9508 3618 B0E0      		ldi r27,0
 9509 361a 00C0      		rjmp .L640
 9510               	.LVL781:
 9511               	.L651:
3188:switcherator.c ****     volatile unsigned char *realPort = 0;
 9512               		.loc 1 3188 0
 9513 361c 612C      		mov r6,__zero_reg__
 9514 361e 712C      		mov r7,__zero_reg__
3187:switcherator.c ****     volatile unsigned char *realDDR = 0;
 9515               		.loc 1 3187 0
 9516 3620 A0E0      		ldi r26,0
 9517 3622 B0E0      		ldi r27,0
 9518               	.LVL782:
 9519               	.L640:
 9520 3624 40E0      		ldi r20,lo8(switchStuff)
 9521 3626 50E0      		ldi r21,hi8(switchStuff)
3286:switcherator.c ****         if (switchStuff[x] == temp || switchStuff[x] == (temp + 1)) {
 9522               		.loc 1 3286 0
 9523 3628 5901      		movw r10,r18
 9524 362a FFEF      		ldi r31,-1
 9525 362c AF1A      		sub r10,r31
 9526 362e BF0A      		sbc r11,r31
 9527               	.LVL783:
 9528               	.L646:
 9529 3630 FA01      		movw r30,r20
 9530 3632 C190      		ld r12,Z+
 9531 3634 AF01      		movw r20,r30
 9532 3636 D12C      		mov r13,__zero_reg__
 9533 3638 C216      		cp r12,r18
 9534 363a D306      		cpc r13,r19
 9535 363c 01F0      		breq .L644
3286:switcherator.c ****         if (switchStuff[x] == temp || switchStuff[x] == (temp + 1)) {
 9536               		.loc 1 3286 0 is_stmt 0 discriminator 1
 9537 363e CA14      		cp r12,r10
 9538 3640 DB04      		cpc r13,r11
 9539 3642 01F4      		brne .L645
 9540               	.L644:
3287:switcherator.c ****             fail(0x12);
 9541               		.loc 1 3287 0 is_stmt 1
 9542 3644 82E1      		ldi r24,lo8(18)
 9543 3646 90E0      		ldi r25,0
 9544 3648 00C0      		rjmp .L671
 9545               	.L645:
3285:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 9546               		.loc 1 3285 0
 9547 364a F0E0      		ldi r31,hi8(switchStuff+16)
 9548 364c 4030      		cpi r20,lo8(switchStuff+16)
 9549 364e 5F07      		cpc r21,r31
 9550 3650 01F4      		brne .L646
3292:switcherator.c ****     inputs[inputNumber][0] = temp;
 9551               		.loc 1 3292 0
 9552 3652 A701      		movw r20,r14
 9553 3654 73E0      		ldi r23,3
 9554               		1:
 9555 3656 440F      		lsl r20
 9556 3658 551F      		rol r21
 9557 365a 7A95      		dec r23
 9558 365c 01F4      		brne 1b
 9559 365e E0E0      		ldi r30,lo8(inputs)
 9560 3660 EE2E      		mov r14,r30
 9561 3662 E0E0      		ldi r30,hi8(inputs)
 9562 3664 FE2E      		mov r15,r30
 9563               	.LVL784:
 9564 3666 E40E      		add r14,r20
 9565 3668 F51E      		adc r15,r21
 9566 366a F701      		movw r30,r14
 9567 366c 2083      		st Z,r18
3294:switcherator.c ****     if (commandReceived[7] == 'H' || commandReceived[7] == 'h' ||
 9568               		.loc 1 3294 0
 9569 366e 2F81      		ldd r18,Y+7
 9570               	.LVL785:
 9571 3670 2834      		cpi r18,lo8(72)
 9572 3672 01F0      		breq .L647
3294:switcherator.c ****     if (commandReceived[7] == 'H' || commandReceived[7] == 'h' ||
 9573               		.loc 1 3294 0 is_stmt 0 discriminator 1
 9574 3674 2836      		cpi r18,lo8(104)
 9575 3676 01F0      		breq .L647
 9576 3678 2133      		cpi r18,lo8(49)
 9577 367a 01F4      		brne .L648
 9578               	.L647:
3296:switcherator.c ****         inputs[inputNumber][1] = 0;
 9579               		.loc 1 3296 0 is_stmt 1
 9580 367c EA01      		movw r28,r20
 9581               	.LVL786:
 9582 367e C050      		subi r28,lo8(-(inputs))
 9583 3680 D040      		sbci r29,hi8(-(inputs))
 9584 3682 1982      		std Y+1,__zero_reg__
3297:switcherator.c ****         inputs[inputNumber][2] = 255;
 9585               		.loc 1 3297 0
 9586 3684 2FEF      		ldi r18,lo8(-1)
 9587 3686 2A83      		std Y+2,r18
 9588 3688 00C0      		rjmp .L649
 9589               	.LVL787:
 9590               	.L648:
3299:switcherator.c ****         inputs[inputNumber][1] = 255;
 9591               		.loc 1 3299 0
 9592 368a 2FEF      		ldi r18,lo8(-1)
 9593 368c F701      		movw r30,r14
 9594 368e 2183      		std Z+1,r18
3300:switcherator.c ****         inputs[inputNumber][2] = 0;
 9595               		.loc 1 3300 0
 9596 3690 1282      		std Z+2,__zero_reg__
 9597               	.LVL788:
 9598               	.L649:
3302:switcherator.c ****     inputs[inputNumber][3] = switchNumber;
 9599               		.loc 1 3302 0
 9600 3692 EA01      		movw r28,r20
 9601 3694 C050      		subi r28,lo8(-(inputs))
 9602 3696 D040      		sbci r29,hi8(-(inputs))
 9603 3698 0B83      		std Y+3,r16
 9604               	.LVL789:
3304:switcherator.c ****     inputs[inputNumber][4] = temp;
 9605               		.loc 1 3304 0
 9606 369a 9C83      		std Y+4,r25
 9607               	.LVL790:
3306:switcherator.c ****     inputs[inputNumber][5] = temp;
 9608               		.loc 1 3306 0
 9609 369c 5D82      		std Y+5,r5
 9610               	.LVL791:
3310:switcherator.c ****     inputs[inputNumber][6] = pollTime;
 9611               		.loc 1 3310 0
 9612 369e 9401      		movw r18,r8
 9613 36a0 2F3F      		cpi r18,-1
 9614 36a2 3105      		cpc r19,__zero_reg__
 9615 36a4 01F0      		breq .L650
 9616 36a6 04F0      		brlt .L650
 9617 36a8 2FEF      		ldi r18,lo8(-1)
 9618 36aa 30E0      		ldi r19,0
 9619               	.L650:
 9620 36ac 2E83      		std Y+6,r18
3312:switcherator.c ****     *realDDR &= ~(1 << pin);
 9621               		.loc 1 3312 0
 9622 36ae 8C91      		ld r24,X
 9623 36b0 21E0      		ldi r18,lo8(1)
 9624 36b2 30E0      		ldi r19,0
 9625 36b4 00C0      		rjmp 2f
 9626               		1:
 9627 36b6 220F      		lsl r18
 9628               		2:
 9629 36b8 6A95      		dec r22
 9630 36ba 02F4      		brpl 1b
 9631 36bc 922F      		mov r25,r18
 9632               	.LVL792:
 9633 36be 9095      		com r25
 9634 36c0 8923      		and r24,r25
 9635 36c2 8C93      		st X,r24
3313:switcherator.c ****     *realPort |= (1 << pin);
 9636               		.loc 1 3313 0
 9637 36c4 F301      		movw r30,r6
 9638 36c6 8081      		ld r24,Z
 9639 36c8 822B      		or r24,r18
 9640 36ca 8083      		st Z,r24
 9641               	/* epilogue start */
3318:switcherator.c **** }
 9642               		.loc 1 3318 0
 9643 36cc DF91      		pop r29
 9644 36ce CF91      		pop r28
 9645               	.LVL793:
 9646 36d0 1F91      		pop r17
 9647 36d2 0F91      		pop r16
 9648 36d4 FF90      		pop r15
 9649 36d6 EF90      		pop r14
 9650 36d8 DF90      		pop r13
 9651 36da CF90      		pop r12
 9652 36dc BF90      		pop r11
 9653 36de AF90      		pop r10
 9654 36e0 9F90      		pop r9
 9655               	.LVL794:
 9656 36e2 8F90      		pop r8
 9657 36e4 7F90      		pop r7
 9658 36e6 6F90      		pop r6
 9659               	.LVL795:
 9660 36e8 5F90      		pop r5
 9661               	.LVL796:
3315:switcherator.c ****     ok();
 9662               		.loc 1 3315 0
 9663 36ea 0C94 0000 		jmp ok
 9664               	.LVL797:
 9665               	.LFE78:
 9667               	.global	setAnalogInput
 9669               	setAnalogInput:
 9670               	.LFB77:
3059:switcherator.c **** void setAnalogInput(char * commandReceived) {
 9671               		.loc 1 3059 0
 9672               	.LVL798:
 9673 36ee 2F92      		push r2
 9674               	.LCFI230:
 9675 36f0 3F92      		push r3
 9676               	.LCFI231:
 9677 36f2 4F92      		push r4
 9678               	.LCFI232:
 9679 36f4 5F92      		push r5
 9680               	.LCFI233:
 9681 36f6 6F92      		push r6
 9682               	.LCFI234:
 9683 36f8 7F92      		push r7
 9684               	.LCFI235:
 9685 36fa 8F92      		push r8
 9686               	.LCFI236:
 9687 36fc 9F92      		push r9
 9688               	.LCFI237:
 9689 36fe AF92      		push r10
 9690               	.LCFI238:
 9691 3700 BF92      		push r11
 9692               	.LCFI239:
 9693 3702 CF92      		push r12
 9694               	.LCFI240:
 9695 3704 DF92      		push r13
 9696               	.LCFI241:
 9697 3706 EF92      		push r14
 9698               	.LCFI242:
 9699 3708 FF92      		push r15
 9700               	.LCFI243:
 9701 370a 0F93      		push r16
 9702               	.LCFI244:
 9703 370c 1F93      		push r17
 9704               	.LCFI245:
 9705 370e CF93      		push r28
 9706               	.LCFI246:
 9707 3710 DF93      		push r29
 9708               	.LCFI247:
 9709 3712 00D0      		rcall .
 9710 3714 1F92      		push __zero_reg__
 9711               	.LCFI248:
 9712 3716 CDB7      		in r28,__SP_L__
 9713 3718 DEB7      		in r29,__SP_H__
 9714               	.LCFI249:
 9715               	/* prologue: function */
 9716               	/* frame size = 3 */
 9717               	/* stack size = 21 */
 9718               	.L__stack_usage = 21
 9719 371a 9B83      		std Y+3,r25
 9720 371c 8A83      		std Y+2,r24
 9721               	.LVL799:
3067:switcherator.c ****     tempIntString[0] = commandReceived[3];
 9722               		.loc 1 3067 0
 9723 371e DC01      		movw r26,r24
 9724 3720 1396      		adiw r26,3
 9725 3722 8C91      		ld r24,X
 9726 3724 1397      		sbiw r26,3
 9727               	.LVL800:
 9728 3726 8093 0000 		sts tempIntString,r24
3068:switcherator.c ****     tempIntString[1] = commandReceived[4];
 9729               		.loc 1 3068 0
 9730 372a 1496      		adiw r26,4
 9731 372c 8C91      		ld r24,X
 9732 372e 8093 0000 		sts tempIntString+1,r24
3069:switcherator.c ****     inputNumber = atoi(tempIntString);
 9733               		.loc 1 3069 0
 9734 3732 80E0      		ldi r24,lo8(tempIntString)
 9735 3734 90E0      		ldi r25,hi8(tempIntString)
 9736 3736 0E94 0000 		call atoi
 9737               	.LVL801:
 9738 373a 8C01      		movw r16,r24
 9739               	.LVL802:
3070:switcherator.c ****     if (inputNumber >= NUM_INPUTS) {
 9740               		.loc 1 3070 0
 9741 373c 8430      		cpi r24,4
 9742 373e 9105      		cpc r25,__zero_reg__
 9743 3740 04F0      		brlt .L673
3071:switcherator.c ****         fail(0x11);
 9744               		.loc 1 3071 0
 9745 3742 81E1      		ldi r24,lo8(17)
 9746 3744 90E0      		ldi r25,0
 9747 3746 00C0      		rjmp .L694
 9748               	.L673:
3074:switcherator.c ****     tempIntString[0] = '0';
 9749               		.loc 1 3074 0
 9750 3748 50E3      		ldi r21,lo8(48)
 9751 374a B52E      		mov r11,r21
 9752 374c B092 0000 		sts tempIntString,r11
3075:switcherator.c ****     tempIntString[1] = commandReceived[6];
 9753               		.loc 1 3075 0
 9754 3750 EA81      		ldd r30,Y+2
 9755 3752 FB81      		ldd r31,Y+3
 9756 3754 8681      		ldd r24,Z+6
 9757 3756 8093 0000 		sts tempIntString+1,r24
3076:switcherator.c ****     pin = atoi(tempIntString);
 9758               		.loc 1 3076 0
 9759 375a 80E0      		ldi r24,lo8(tempIntString)
 9760 375c 90E0      		ldi r25,hi8(tempIntString)
 9761 375e 0E94 0000 		call atoi
 9762               	.LVL803:
 9763 3762 6C01      		movw r12,r24
 9764               	.LVL804:
3077:switcherator.c ****     if (pin > 7) {
 9765               		.loc 1 3077 0
 9766 3764 F7E0      		ldi r31,lo8(7)
 9767 3766 F817      		cp r31,r24
 9768 3768 00F4      		brsh .L674
3078:switcherator.c ****         fail(0x04);
 9769               		.loc 1 3078 0
 9770 376a 84E0      		ldi r24,lo8(4)
 9771 376c 90E0      		ldi r25,0
 9772               	.LVL805:
 9773               	.L694:
 9774               	/* epilogue start */
3176:switcherator.c **** }
 9775               		.loc 1 3176 0
 9776 376e 0F90      		pop __tmp_reg__
 9777 3770 0F90      		pop __tmp_reg__
 9778 3772 0F90      		pop __tmp_reg__
 9779 3774 DF91      		pop r29
 9780 3776 CF91      		pop r28
 9781 3778 1F91      		pop r17
 9782 377a 0F91      		pop r16
 9783               	.LVL806:
 9784 377c FF90      		pop r15
 9785 377e EF90      		pop r14
 9786 3780 DF90      		pop r13
 9787 3782 CF90      		pop r12
 9788 3784 BF90      		pop r11
 9789 3786 AF90      		pop r10
 9790 3788 9F90      		pop r9
 9791 378a 8F90      		pop r8
 9792 378c 7F90      		pop r7
 9793 378e 6F90      		pop r6
 9794 3790 5F90      		pop r5
 9795 3792 4F90      		pop r4
 9796 3794 3F90      		pop r3
 9797 3796 2F90      		pop r2
3078:switcherator.c ****         fail(0x04);
 9798               		.loc 1 3078 0
 9799 3798 0C94 0000 		jmp fail
 9800               	.LVL807:
 9801               	.L674:
3082:switcherator.c ****     tempIntString[0] = commandReceived[14];
 9802               		.loc 1 3082 0
 9803 379c AA81      		ldd r26,Y+2
 9804 379e BB81      		ldd r27,Y+3
 9805 37a0 1E96      		adiw r26,14
 9806 37a2 8C91      		ld r24,X
 9807 37a4 1E97      		sbiw r26,14
 9808 37a6 8093 0000 		sts tempIntString,r24
3083:switcherator.c ****     tempIntString[1] = commandReceived[15];
 9809               		.loc 1 3083 0
 9810 37aa 1F96      		adiw r26,15
 9811 37ac 8C91      		ld r24,X
 9812 37ae 8093 0000 		sts tempIntString+1,r24
3084:switcherator.c ****     switchNumber = atoi(tempIntString);
 9813               		.loc 1 3084 0
 9814 37b2 80E0      		ldi r24,lo8(tempIntString)
 9815 37b4 90E0      		ldi r25,hi8(tempIntString)
 9816 37b6 0E94 0000 		call atoi
 9817               	.LVL808:
 9818 37ba 7C01      		movw r14,r24
 9819               	.LVL809:
3086:switcherator.c ****     tempIntString[0] = commandReceived[20];
 9820               		.loc 1 3086 0
 9821 37bc EA81      		ldd r30,Y+2
 9822 37be FB81      		ldd r31,Y+3
 9823 37c0 8489      		ldd r24,Z+20
 9824 37c2 8093 0000 		sts tempIntString,r24
3087:switcherator.c ****     tempIntString[1] = commandReceived[21];
 9825               		.loc 1 3087 0
 9826 37c6 8589      		ldd r24,Z+21
 9827 37c8 8093 0000 		sts tempIntString+1,r24
3088:switcherator.c ****     pollTime = atoi(tempIntString);
 9828               		.loc 1 3088 0
 9829 37cc 80E0      		ldi r24,lo8(tempIntString)
 9830 37ce 90E0      		ldi r25,hi8(tempIntString)
 9831 37d0 0E94 0000 		call atoi
 9832               	.LVL810:
 9833 37d4 782E      		mov r7,r24
 9834 37d6 892E      		mov r8,r25
 9835               	.LVL811:
3090:switcherator.c ****     tempIntString[0] = '0';
 9836               		.loc 1 3090 0
 9837 37d8 B092 0000 		sts tempIntString,r11
3091:switcherator.c ****     tempIntString[1] = commandReceived[22];
 9838               		.loc 1 3091 0
 9839 37dc AA81      		ldd r26,Y+2
 9840 37de BB81      		ldd r27,Y+3
 9841 37e0 5696      		adiw r26,22
 9842 37e2 8C91      		ld r24,X
 9843 37e4 8093 0000 		sts tempIntString+1,r24
3092:switcherator.c ****     whichRGB = atoi(tempIntString);
 9844               		.loc 1 3092 0
 9845 37e8 80E0      		ldi r24,lo8(tempIntString)
 9846 37ea 90E0      		ldi r25,hi8(tempIntString)
 9847 37ec 0E94 0000 		call atoi
 9848               	.LVL812:
 9849 37f0 982E      		mov r9,r24
 9850               	.LVL813:
3094:switcherator.c ****     tempLongString[0] = '0';
 9851               		.loc 1 3094 0
 9852 37f2 B092 0000 		sts tempLongString,r11
3095:switcherator.c ****     tempLongString[1] = commandReceived[7];
 9853               		.loc 1 3095 0
 9854 37f6 EA81      		ldd r30,Y+2
 9855 37f8 FB81      		ldd r31,Y+3
 9856 37fa 8781      		ldd r24,Z+7
 9857 37fc 8093 0000 		sts tempLongString+1,r24
3096:switcherator.c ****     tempLongString[2] = commandReceived[8];
 9858               		.loc 1 3096 0
 9859 3800 8085      		ldd r24,Z+8
 9860 3802 8093 0000 		sts tempLongString+2,r24
3097:switcherator.c ****     tempLongString[3] = commandReceived[9];
 9861               		.loc 1 3097 0
 9862 3806 8185      		ldd r24,Z+9
 9863 3808 8093 0000 		sts tempLongString+3,r24
3098:switcherator.c ****     lowPercent = atoi(tempLongString);
 9864               		.loc 1 3098 0
 9865 380c 80E0      		ldi r24,lo8(tempLongString)
 9866 380e 90E0      		ldi r25,hi8(tempLongString)
 9867 3810 0E94 0000 		call atoi
 9868               	.LVL814:
 9869 3814 5C01      		movw r10,r24
 9870               	.LVL815:
3099:switcherator.c ****     tempLongString[1] = commandReceived[10];
 9871               		.loc 1 3099 0
 9872 3816 AA81      		ldd r26,Y+2
 9873 3818 BB81      		ldd r27,Y+3
 9874 381a 1A96      		adiw r26,10
 9875 381c 8C91      		ld r24,X
 9876 381e 1A97      		sbiw r26,10
 9877 3820 8093 0000 		sts tempLongString+1,r24
3100:switcherator.c ****     tempLongString[2] = commandReceived[11];
 9878               		.loc 1 3100 0
 9879 3824 1B96      		adiw r26,11
 9880 3826 8C91      		ld r24,X
 9881 3828 1B97      		sbiw r26,11
 9882 382a 8093 0000 		sts tempLongString+2,r24
3101:switcherator.c ****     tempLongString[3] = commandReceived[12];
 9883               		.loc 1 3101 0
 9884 382e 1C96      		adiw r26,12
 9885 3830 8C91      		ld r24,X
 9886 3832 8093 0000 		sts tempLongString+3,r24
3102:switcherator.c ****     highPercent = atoi(tempLongString);
 9887               		.loc 1 3102 0
 9888 3836 80E0      		ldi r24,lo8(tempLongString)
 9889 3838 90E0      		ldi r25,hi8(tempLongString)
 9890 383a 0E94 0000 		call atoi
 9891               	.LVL816:
 9892 383e 2C01      		movw r4,r24
 9893               	.LVL817:
3104:switcherator.c ****     tempLongString[0] = commandReceived[16];
 9894               		.loc 1 3104 0
 9895 3840 EA81      		ldd r30,Y+2
 9896 3842 FB81      		ldd r31,Y+3
 9897 3844 8089      		ldd r24,Z+16
 9898 3846 8093 0000 		sts tempLongString,r24
3105:switcherator.c ****     tempLongString[1] = commandReceived[17];
 9899               		.loc 1 3105 0
 9900 384a 8189      		ldd r24,Z+17
 9901 384c 8093 0000 		sts tempLongString+1,r24
3106:switcherator.c ****     tempLongString[2] = commandReceived[18];
 9902               		.loc 1 3106 0
 9903 3850 8289      		ldd r24,Z+18
 9904 3852 8093 0000 		sts tempLongString+2,r24
3107:switcherator.c ****     tempLongString[3] = commandReceived[19];
 9905               		.loc 1 3107 0
 9906 3856 8389      		ldd r24,Z+19
 9907 3858 8093 0000 		sts tempLongString+3,r24
3108:switcherator.c ****     duration = atoi(tempLongString);
 9908               		.loc 1 3108 0
 9909 385c 80E0      		ldi r24,lo8(tempLongString)
 9910 385e 90E0      		ldi r25,hi8(tempLongString)
 9911 3860 0E94 0000 		call atoi
 9912               	.LVL818:
 9913 3864 682E      		mov r6,r24
 9914 3866 9983      		std Y+1,r25
 9915               	.LVL819:
3115:switcherator.c ****     if (commandReceived[5] != 'C' && commandReceived[5] != 'c') {
 9916               		.loc 1 3115 0
 9917 3868 AA81      		ldd r26,Y+2
 9918 386a BB81      		ldd r27,Y+3
 9919 386c 1596      		adiw r26,5
 9920 386e 8C91      		ld r24,X
 9921 3870 8334      		cpi r24,lo8(67)
 9922 3872 01F0      		breq .L675
3115:switcherator.c ****     if (commandReceived[5] != 'C' && commandReceived[5] != 'c') {
 9923               		.loc 1 3115 0 is_stmt 0 discriminator 1
 9924 3874 8336      		cpi r24,lo8(99)
 9925 3876 01F0      		breq .L675
3116:switcherator.c ****         fail(0x03);
 9926               		.loc 1 3116 0 is_stmt 1
 9927 3878 83E0      		ldi r24,lo8(3)
 9928 387a 90E0      		ldi r25,0
 9929 387c 00C0      		rjmp .L694
 9930               	.L675:
3126:switcherator.c ****     temp = pin * 2;
 9931               		.loc 1 3126 0
 9932 387e DD24      		clr r13
 9933               	.LVL820:
 9934 3880 C601      		movw r24,r12
 9935 3882 880F      		lsl r24
 9936 3884 991F      		rol r25
 9937 3886 AA27      		clr r26
 9938 3888 97FD      		sbrc r25,7
 9939 388a A095      		com r26
 9940 388c BA2F      		mov r27,r26
 9941               	.LVL821:
3128:switcherator.c ****     temp += 32;
 9942               		.loc 1 3128 0
 9943 388e 8096      		adiw r24,32
 9944 3890 A11D      		adc r26,__zero_reg__
 9945 3892 B11D      		adc r27,__zero_reg__
 9946               	.LVL822:
 9947 3894 E0E0      		ldi r30,lo8(switchStuff)
 9948 3896 F0E0      		ldi r31,hi8(switchStuff)
 9949               	.LVL823:
 9950               	.L677:
3130:switcherator.c ****         if (switchStuff[x] == temp) {
 9951               		.loc 1 3130 0
 9952 3898 4191      		ld r20,Z+
 9953 389a 50E0      		ldi r21,0
 9954 389c 60E0      		ldi r22,0
 9955 389e 70E0      		ldi r23,0
 9956 38a0 4817      		cp r20,r24
 9957 38a2 5907      		cpc r21,r25
 9958 38a4 6A07      		cpc r22,r26
 9959 38a6 7B07      		cpc r23,r27
 9960 38a8 01F4      		brne .L676
3132:switcherator.c ****             fail(0x12);
 9961               		.loc 1 3132 0
 9962 38aa 82E1      		ldi r24,lo8(18)
 9963 38ac 90E0      		ldi r25,0
 9964               	.LVL824:
 9965 38ae 00C0      		rjmp .L694
 9966               	.LVL825:
 9967               	.L676:
3129:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 9968               		.loc 1 3129 0
 9969 38b0 20E0      		ldi r18,hi8(switchStuff+16)
 9970 38b2 E030      		cpi r30,lo8(switchStuff+16)
 9971 38b4 F207      		cpc r31,r18
 9972 38b6 01F4      		brne .L677
3136:switcherator.c ****     inputs[inputNumber][0] = temp;
 9973               		.loc 1 3136 0
 9974 38b8 93E0      		ldi r25,3
 9975               		1:
 9976 38ba 000F      		lsl r16
 9977 38bc 111F      		rol r17
 9978 38be 9A95      		dec r25
 9979 38c0 01F4      		brne 1b
 9980               	.LVL826:
 9981 38c2 20E0      		ldi r18,lo8(inputs)
 9982 38c4 222E      		mov r2,r18
 9983 38c6 20E0      		ldi r18,hi8(inputs)
 9984 38c8 322E      		mov r3,r18
 9985 38ca 200E      		add r2,r16
 9986 38cc 311E      		adc r3,r17
 9987 38ce F101      		movw r30,r2
 9988 38d0 8083      		st Z,r24
3137:switcherator.c ****     DDRC &= ~(1 << pin);
 9989               		.loc 1 3137 0
 9990 38d2 27B1      		in r18,0x7
 9991 38d4 81E0      		ldi r24,lo8(1)
 9992 38d6 90E0      		ldi r25,0
 9993               	.LVL827:
 9994 38d8 00C0      		rjmp 2f
 9995               		1:
 9996 38da 880F      		lsl r24
 9997               		2:
 9998 38dc CA94      		dec r12
 9999 38de 02F4      		brpl 1b
 10000 38e0 8095      		com r24
 10001 38e2 8223      		and r24,r18
 10002 38e4 87B9      		out 0x7,r24
 10003               	.LVL828:
3139:switcherator.c ****     temp = temp * 255;
 10004               		.loc 1 3139 0
 10005 38e6 2FEF      		ldi r18,lo8(-1)
 10006 38e8 30E0      		ldi r19,0
 10007 38ea D501      		movw r26,r10
 10008 38ec 0E94 0000 		call __usmulhisi3
 10009               	.LVL829:
3140:switcherator.c ****     temp = temp / 100;
 10010               		.loc 1 3140 0
 10011 38f0 34E6      		ldi r19,lo8(100)
 10012 38f2 A32E      		mov r10,r19
 10013 38f4 B12C      		mov r11,__zero_reg__
 10014 38f6 C12C      		mov r12,__zero_reg__
 10015 38f8 D12C      		mov r13,__zero_reg__
 10016               	.LVL830:
 10017 38fa A601      		movw r20,r12
 10018 38fc 9501      		movw r18,r10
 10019 38fe 0E94 0000 		call __divmodsi4
 10020               	.LVL831:
3141:switcherator.c ****     inputs[inputNumber][1] = temp;
 10021               		.loc 1 3141 0
 10022 3902 D101      		movw r26,r2
 10023 3904 1196      		adiw r26,1
 10024 3906 2C93      		st X,r18
 10025               	.LVL832:
3143:switcherator.c ****     temp = temp * 255;
 10026               		.loc 1 3143 0
 10027 3908 2FEF      		ldi r18,lo8(-1)
 10028 390a 30E0      		ldi r19,0
 10029 390c D201      		movw r26,r4
 10030 390e 0E94 0000 		call __usmulhisi3
 10031               	.LVL833:
3144:switcherator.c ****     temp = temp / 100;
 10032               		.loc 1 3144 0
 10033 3912 A601      		movw r20,r12
 10034 3914 9501      		movw r18,r10
 10035 3916 0E94 0000 		call __divmodsi4
 10036               	.LVL834:
3145:switcherator.c ****     if (temp == 255) // if the top is 255 we need it to be 254 so its not digital
 10037               		.loc 1 3145 0
 10038 391a 2F3F      		cpi r18,-1
 10039 391c 3105      		cpc r19,__zero_reg__
 10040 391e 4105      		cpc r20,__zero_reg__
 10041 3920 5105      		cpc r21,__zero_reg__
 10042 3922 01F4      		brne .L678
3146:switcherator.c ****         temp = 254;
 10043               		.loc 1 3146 0
 10044 3924 2EEF      		ldi r18,lo8(-2)
 10045 3926 30E0      		ldi r19,0
 10046 3928 40E0      		ldi r20,0
 10047 392a 50E0      		ldi r21,0
 10048               	.LVL835:
 10049               	.L678:
3148:switcherator.c ****     inputs[inputNumber][2] = temp;
 10050               		.loc 1 3148 0
 10051 392c F801      		movw r30,r16
 10052 392e E050      		subi r30,lo8(-(inputs))
 10053 3930 F040      		sbci r31,hi8(-(inputs))
 10054 3932 2283      		std Z+2,r18
3150:switcherator.c ****     if (commandReceived[13] == 'P' || commandReceived[13] == 'p') {
 10055               		.loc 1 3150 0
 10056 3934 EA81      		ldd r30,Y+2
 10057 3936 FB81      		ldd r31,Y+3
 10058 3938 8585      		ldd r24,Z+13
 10059 393a 8035      		cpi r24,lo8(80)
 10060 393c 01F0      		breq .L679
3150:switcherator.c ****     if (commandReceived[13] == 'P' || commandReceived[13] == 'p') {
 10061               		.loc 1 3150 0 is_stmt 0 discriminator 1
 10062 393e 8037      		cpi r24,lo8(112)
 10063 3940 01F4      		brne .L680
 10064               	.L679:
3151:switcherator.c ****         switchNumber += 128;
 10065               		.loc 1 3151 0 is_stmt 1
 10066 3942 F0E8      		ldi r31,-128
 10067 3944 EF0E      		add r14,r31
 10068 3946 F11C      		adc r15,__zero_reg__
 10069               	.LVL836:
 10070               	.L680:
3153:switcherator.c ****     inputs[inputNumber][3] = switchNumber;
 10071               		.loc 1 3153 0
 10072 3948 F801      		movw r30,r16
 10073 394a E050      		subi r30,lo8(-(inputs))
 10074 394c F040      		sbci r31,hi8(-(inputs))
 10075 394e E382      		std Z+3,r14
 10076               	.LVL837:
3155:switcherator.c ****     inputs[inputNumber][4] = temp;
 10077               		.loc 1 3155 0
 10078 3950 2981      		ldd r18,Y+1
 10079 3952 2483      		std Z+4,r18
 10080               	.LVL838:
3157:switcherator.c ****     inputs[inputNumber][5] = temp;
 10081               		.loc 1 3157 0
 10082 3954 6582      		std Z+5,r6
 10083               	.LVL839:
3162:switcherator.c ****     inputs[inputNumber][6] = pollTime;
 10084               		.loc 1 3162 0
 10085 3956 872D      		mov r24,r7
 10086 3958 982D      		mov r25,r8
 10087 395a 8F3F      		cpi r24,-1
 10088 395c 9105      		cpc r25,__zero_reg__
 10089 395e 01F0      		breq .L681
 10090 3960 04F0      		brlt .L681
 10091 3962 8FEF      		ldi r24,lo8(-1)
 10092 3964 90E0      		ldi r25,0
 10093               	.L681:
 10094 3966 8683      		std Z+6,r24
 10095               	.LVL840:
3167:switcherator.c ****     inputs[inputNumber][7] = whichRGB;
 10096               		.loc 1 3167 0
 10097 3968 F801      		movw r30,r16
 10098 396a E050      		subi r30,lo8(-(inputs))
 10099 396c F040      		sbci r31,hi8(-(inputs))
 10100 396e 892D      		mov r24,r9
 10101 3970 8830      		cpi r24,lo8(8)
 10102 3972 00F0      		brlo .L682
 10103 3974 87E0      		ldi r24,lo8(7)
 10104               	.L682:
 10105 3976 8783      		std Z+7,r24
3172:switcherator.c ****     ADCSRA |= (1 << ADPS2) || (1 << ADPS0);
 10106               		.loc 1 3172 0
 10107 3978 8091 7A00 		lds r24,122
 10108 397c 8160      		ori r24,lo8(1)
 10109 397e 8093 7A00 		sts 122,r24
 10110               	/* epilogue start */
3176:switcherator.c **** }
 10111               		.loc 1 3176 0
 10112 3982 0F90      		pop __tmp_reg__
 10113 3984 0F90      		pop __tmp_reg__
 10114 3986 0F90      		pop __tmp_reg__
 10115 3988 DF91      		pop r29
 10116 398a CF91      		pop r28
 10117 398c 1F91      		pop r17
 10118 398e 0F91      		pop r16
 10119 3990 FF90      		pop r15
 10120 3992 EF90      		pop r14
 10121 3994 DF90      		pop r13
 10122 3996 CF90      		pop r12
 10123 3998 BF90      		pop r11
 10124 399a AF90      		pop r10
 10125 399c 9F90      		pop r9
 10126               	.LVL841:
 10127 399e 8F90      		pop r8
 10128               	.LVL842:
 10129 39a0 7F90      		pop r7
 10130               	.LVL843:
 10131 39a2 6F90      		pop r6
 10132               	.LVL844:
 10133 39a4 5F90      		pop r5
 10134 39a6 4F90      		pop r4
 10135               	.LVL845:
 10136 39a8 3F90      		pop r3
 10137 39aa 2F90      		pop r2
3175:switcherator.c ****     ok();
 10138               		.loc 1 3175 0
 10139 39ac 0C94 0000 		jmp ok
 10140               	.LVL846:
 10141               	.LFE77:
 10143               	.global	startProgram
 10145               	startProgram:
 10146               	.LFB39:
1629:switcherator.c **** void startProgram(char * commandReceived) {
 10147               		.loc 1 1629 0
 10148               	.LVL847:
 10149 39b0 0F93      		push r16
 10150               	.LCFI250:
 10151 39b2 1F93      		push r17
 10152               	.LCFI251:
 10153 39b4 CF93      		push r28
 10154               	.LCFI252:
 10155 39b6 DF93      		push r29
 10156               	.LCFI253:
 10157               	/* prologue: function */
 10158               	/* frame size = 0 */
 10159               	/* stack size = 4 */
 10160               	.L__stack_usage = 4
 10161 39b8 EC01      		movw r28,r24
 10162               	.LVL848:
1633:switcherator.c ****     tempIntString[0] = commandReceived[3];
 10163               		.loc 1 1633 0
 10164 39ba 8B81      		ldd r24,Y+3
 10165               	.LVL849:
 10166 39bc 8093 0000 		sts tempIntString,r24
1634:switcherator.c ****     tempIntString[1] = commandReceived[4];
 10167               		.loc 1 1634 0
 10168 39c0 8C81      		ldd r24,Y+4
 10169 39c2 8093 0000 		sts tempIntString+1,r24
1635:switcherator.c ****     programNumber = atoi(tempIntString);
 10170               		.loc 1 1635 0
 10171 39c6 80E0      		ldi r24,lo8(tempIntString)
 10172 39c8 90E0      		ldi r25,hi8(tempIntString)
 10173 39ca 0E94 0000 		call atoi
 10174               	.LVL850:
 10175 39ce 8C01      		movw r16,r24
 10176               	.LVL851:
1636:switcherator.c ****     if (programNumber >= MAX_PROGRAM) {
 10177               		.loc 1 1636 0
 10178 39d0 8431      		cpi r24,20
 10179 39d2 9105      		cpc r25,__zero_reg__
 10180 39d4 04F0      		brlt .L696
1637:switcherator.c ****         fail(2);
 10181               		.loc 1 1637 0
 10182 39d6 82E0      		ldi r24,lo8(2)
 10183 39d8 90E0      		ldi r25,0
 10184               	/* epilogue start */
1650:switcherator.c **** }
 10185               		.loc 1 1650 0
 10186 39da DF91      		pop r29
 10187 39dc CF91      		pop r28
 10188               	.LVL852:
 10189 39de 1F91      		pop r17
 10190 39e0 0F91      		pop r16
 10191               	.LVL853:
1637:switcherator.c ****         fail(2);
 10192               		.loc 1 1637 0
 10193 39e2 0C94 0000 		jmp fail
 10194               	.LVL854:
 10195               	.L696:
1641:switcherator.c ****     tempHugeString[0] = commandReceived[5];
 10196               		.loc 1 1641 0
 10197 39e6 8D81      		ldd r24,Y+5
 10198 39e8 8093 0000 		sts tempHugeString,r24
1642:switcherator.c ****     tempHugeString[1] = commandReceived[6];
 10199               		.loc 1 1642 0
 10200 39ec 8E81      		ldd r24,Y+6
 10201 39ee 8093 0000 		sts tempHugeString+1,r24
1643:switcherator.c ****     tempHugeString[2] = commandReceived[7];
 10202               		.loc 1 1643 0
 10203 39f2 8F81      		ldd r24,Y+7
 10204 39f4 8093 0000 		sts tempHugeString+2,r24
1644:switcherator.c ****     tempHugeString[3] = commandReceived[8];
 10205               		.loc 1 1644 0
 10206 39f8 8885      		ldd r24,Y+8
 10207 39fa 8093 0000 		sts tempHugeString+3,r24
1645:switcherator.c ****     tempHugeString[4] = commandReceived[9];
 10208               		.loc 1 1645 0
 10209 39fe 8985      		ldd r24,Y+9
 10210 3a00 8093 0000 		sts tempHugeString+4,r24
1646:switcherator.c ****     tempHugeString[5] = commandReceived[10];
 10211               		.loc 1 1646 0
 10212 3a04 8A85      		ldd r24,Y+10
 10213 3a06 8093 0000 		sts tempHugeString+5,r24
1647:switcherator.c ****     duration = atol(tempHugeString);
 10214               		.loc 1 1647 0
 10215 3a0a 80E0      		ldi r24,lo8(tempHugeString)
 10216 3a0c 90E0      		ldi r25,hi8(tempHugeString)
 10217 3a0e 0E94 0000 		call atol
 10218               	.LVL855:
1648:switcherator.c ****     startTheProgram(programNumber, duration, 0);
 10219               		.loc 1 1648 0
 10220 3a12 20E0      		ldi r18,0
 10221 3a14 30E0      		ldi r19,0
 10222 3a16 A901      		movw r20,r18
 10223 3a18 C801      		movw r24,r16
 10224 3a1a 0E94 0000 		call startTheProgram
 10225               	.LVL856:
 10226               	/* epilogue start */
1650:switcherator.c **** }
 10227               		.loc 1 1650 0
 10228 3a1e DF91      		pop r29
 10229 3a20 CF91      		pop r28
 10230               	.LVL857:
 10231 3a22 1F91      		pop r17
 10232 3a24 0F91      		pop r16
 10233               	.LVL858:
1649:switcherator.c ****     ok();
 10234               		.loc 1 1649 0
 10235 3a26 0C94 0000 		jmp ok
 10236               	.LVL859:
 10237               	.LFE39:
 10239               	.global	programSetTime
 10241               	programSetTime:
 10242               	.LFB36:
1430:switcherator.c **** void programSetTime(char * commandReceived) {
 10243               		.loc 1 1430 0
 10244               	.LVL860:
 10245 3a2a AF92      		push r10
 10246               	.LCFI254:
 10247 3a2c BF92      		push r11
 10248               	.LCFI255:
 10249 3a2e CF92      		push r12
 10250               	.LCFI256:
 10251 3a30 DF92      		push r13
 10252               	.LCFI257:
 10253 3a32 EF92      		push r14
 10254               	.LCFI258:
 10255 3a34 FF92      		push r15
 10256               	.LCFI259:
 10257 3a36 0F93      		push r16
 10258               	.LCFI260:
 10259 3a38 1F93      		push r17
 10260               	.LCFI261:
 10261 3a3a CF93      		push r28
 10262               	.LCFI262:
 10263 3a3c DF93      		push r29
 10264               	.LCFI263:
 10265               	/* prologue: function */
 10266               	/* frame size = 0 */
 10267               	/* stack size = 10 */
 10268               	.L__stack_usage = 10
 10269 3a3e EC01      		movw r28,r24
 10270               	.LVL861:
1436:switcherator.c ****     tempIntString[0] = commandReceived[3];
 10271               		.loc 1 1436 0
 10272 3a40 8B81      		ldd r24,Y+3
 10273               	.LVL862:
 10274 3a42 8093 0000 		sts tempIntString,r24
1437:switcherator.c ****     tempIntString[1] = commandReceived[4];
 10275               		.loc 1 1437 0
 10276 3a46 FC80      		ldd r15,Y+4
 10277 3a48 F092 0000 		sts tempIntString+1,r15
1438:switcherator.c ****     programNumber = atoi(tempIntString);
 10278               		.loc 1 1438 0
 10279 3a4c 80E0      		ldi r24,lo8(tempIntString)
 10280 3a4e 90E0      		ldi r25,hi8(tempIntString)
 10281 3a50 0E94 0000 		call atoi
 10282               	.LVL863:
 10283 3a54 8C01      		movw r16,r24
 10284               	.LVL864:
1439:switcherator.c ****     if (programNumber >= MAX_PROGRAM || (programNumber == 0 && commandReceived[4] != '0')) {
 10285               		.loc 1 1439 0
 10286 3a56 8431      		cpi r24,20
 10287 3a58 9105      		cpc r25,__zero_reg__
 10288 3a5a 04F4      		brge .L698
1439:switcherator.c ****     if (programNumber >= MAX_PROGRAM || (programNumber == 0 && commandReceived[4] != '0')) {
 10289               		.loc 1 1439 0 is_stmt 0 discriminator 1
 10290 3a5c 0097      		sbiw r24,0
 10291 3a5e 01F4      		brne .L699
 10292 3a60 20E3      		ldi r18,lo8(48)
 10293 3a62 F216      		cp r15,r18
 10294 3a64 01F0      		breq .L699
 10295               	.L698:
1440:switcherator.c ****         fail(2);
 10296               		.loc 1 1440 0 is_stmt 1
 10297 3a66 82E0      		ldi r24,lo8(2)
 10298 3a68 90E0      		ldi r25,0
 10299 3a6a 00C0      		rjmp .L715
 10300               	.L699:
1447:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 10301               		.loc 1 1447 0
 10302 3a6c 8AE0      		ldi r24,lo8(10)
 10303 3a6e 809F      		mul r24,r16
 10304 3a70 F001      		movw r30,r0
 10305 3a72 819F      		mul r24,r17
 10306 3a74 F00D      		add r31,r0
 10307 3a76 1124      		clr __zero_reg__
 10308 3a78 E050      		subi r30,lo8(-(weeklyProgram))
 10309 3a7a F040      		sbci r31,hi8(-(weeklyProgram))
 10310 3a7c 8081      		ld r24,Z
 10311 3a7e 8F3F      		cpi r24,lo8(-1)
 10312 3a80 01F4      		brne .L700
1447:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 10313               		.loc 1 1447 0 is_stmt 0 discriminator 1
 10314 3a82 8181      		ldd r24,Z+1
 10315 3a84 8F3F      		cpi r24,lo8(-1)
 10316 3a86 01F4      		brne .L700
1448:switcherator.c ****         fail(0x0d);
 10317               		.loc 1 1448 0 is_stmt 1
 10318 3a88 8DE0      		ldi r24,lo8(13)
 10319 3a8a 90E0      		ldi r25,0
 10320               	.LVL865:
 10321               	.L715:
 10322               	/* epilogue start */
1487:switcherator.c **** }
 10323               		.loc 1 1487 0
 10324 3a8c DF91      		pop r29
 10325 3a8e CF91      		pop r28
 10326               	.LVL866:
 10327 3a90 1F91      		pop r17
 10328 3a92 0F91      		pop r16
 10329               	.LVL867:
 10330 3a94 FF90      		pop r15
 10331 3a96 EF90      		pop r14
 10332 3a98 DF90      		pop r13
 10333 3a9a CF90      		pop r12
 10334 3a9c BF90      		pop r11
 10335 3a9e AF90      		pop r10
1448:switcherator.c ****         fail(0x0d);
 10336               		.loc 1 1448 0
 10337 3aa0 0C94 0000 		jmp fail
 10338               	.LVL868:
 10339               	.L700:
1451:switcherator.c ****     tempIntString[0] = commandReceived[5];
 10340               		.loc 1 1451 0
 10341 3aa4 8D81      		ldd r24,Y+5
 10342 3aa6 8093 0000 		sts tempIntString,r24
1452:switcherator.c ****     tempIntString[1] = commandReceived[6];
 10343               		.loc 1 1452 0
 10344 3aaa AE80      		ldd r10,Y+6
 10345 3aac A092 0000 		sts tempIntString+1,r10
1453:switcherator.c ****     hours = atoi(tempIntString);
 10346               		.loc 1 1453 0
 10347 3ab0 80E0      		ldi r24,lo8(tempIntString)
 10348 3ab2 90E0      		ldi r25,hi8(tempIntString)
 10349 3ab4 0E94 0000 		call atoi
 10350               	.LVL869:
 10351 3ab8 6C01      		movw r12,r24
 10352               	.LVL870:
1454:switcherator.c ****     tempIntString[0] = commandReceived[7];
 10353               		.loc 1 1454 0
 10354 3aba 8F81      		ldd r24,Y+7
 10355 3abc 8093 0000 		sts tempIntString,r24
1455:switcherator.c ****     tempIntString[1] = commandReceived[8];
 10356               		.loc 1 1455 0
 10357 3ac0 B884      		ldd r11,Y+8
 10358 3ac2 B092 0000 		sts tempIntString+1,r11
1456:switcherator.c ****     minutes = atoi(tempIntString);
 10359               		.loc 1 1456 0
 10360 3ac6 80E0      		ldi r24,lo8(tempIntString)
 10361 3ac8 90E0      		ldi r25,hi8(tempIntString)
 10362 3aca 0E94 0000 		call atoi
 10363               	.LVL871:
 10364 3ace 7C01      		movw r14,r24
 10365               	.LVL872:
1457:switcherator.c ****     tempLongString[0] = commandReceived[9];
 10366               		.loc 1 1457 0
 10367 3ad0 8985      		ldd r24,Y+9
 10368 3ad2 8093 0000 		sts tempLongString,r24
1458:switcherator.c ****     tempLongString[1] = commandReceived[10];
 10369               		.loc 1 1458 0
 10370 3ad6 8A85      		ldd r24,Y+10
 10371 3ad8 8093 0000 		sts tempLongString+1,r24
1459:switcherator.c ****     tempLongString[2] = commandReceived[11];
 10372               		.loc 1 1459 0
 10373 3adc 8B85      		ldd r24,Y+11
 10374 3ade 8093 0000 		sts tempLongString+2,r24
1460:switcherator.c ****     tempLongString[3] = commandReceived[12];
 10375               		.loc 1 1460 0
 10376 3ae2 8C85      		ldd r24,Y+12
 10377 3ae4 8093 0000 		sts tempLongString+3,r24
1461:switcherator.c ****     duration = atoi(tempLongString);
 10378               		.loc 1 1461 0
 10379 3ae8 80E0      		ldi r24,lo8(tempLongString)
 10380 3aea 90E0      		ldi r25,hi8(tempLongString)
 10381 3aec 0E94 0000 		call atoi
 10382               	.LVL873:
1462:switcherator.c ****     if (hours >= 24 || (hours == 0 && commandReceived[6] != '0')) {
 10383               		.loc 1 1462 0
 10384 3af0 28E1      		ldi r18,24
 10385 3af2 C216      		cp r12,r18
 10386 3af4 D104      		cpc r13,__zero_reg__
 10387 3af6 04F4      		brge .L701
1462:switcherator.c ****     if (hours >= 24 || (hours == 0 && commandReceived[6] != '0')) {
 10388               		.loc 1 1462 0 is_stmt 0 discriminator 1
 10389 3af8 C114      		cp r12,__zero_reg__
 10390 3afa D104      		cpc r13,__zero_reg__
 10391 3afc 01F4      		brne .L702
 10392 3afe 20E3      		ldi r18,lo8(48)
 10393 3b00 A216      		cp r10,r18
 10394 3b02 01F0      		breq .L702
 10395               	.L701:
1463:switcherator.c ****         fail(9);
 10396               		.loc 1 1463 0 is_stmt 1
 10397 3b04 89E0      		ldi r24,lo8(9)
 10398 3b06 90E0      		ldi r25,0
 10399               	.LVL874:
 10400 3b08 00C0      		rjmp .L715
 10401               	.LVL875:
 10402               	.L702:
1466:switcherator.c ****     if (minutes >= 60 || (minutes == 0 && commandReceived[8] != '0')) {
 10403               		.loc 1 1466 0
 10404 3b0a 2CE3      		ldi r18,60
 10405 3b0c E216      		cp r14,r18
 10406 3b0e F104      		cpc r15,__zero_reg__
 10407 3b10 04F4      		brge .L703
1466:switcherator.c ****     if (minutes >= 60 || (minutes == 0 && commandReceived[8] != '0')) {
 10408               		.loc 1 1466 0 is_stmt 0 discriminator 1
 10409 3b12 E114      		cp r14,__zero_reg__
 10410 3b14 F104      		cpc r15,__zero_reg__
 10411 3b16 01F4      		brne .L704
 10412 3b18 20E3      		ldi r18,lo8(48)
 10413 3b1a B216      		cp r11,r18
 10414 3b1c 01F0      		breq .L704
 10415               	.L703:
1467:switcherator.c ****         fail(0x0a);
 10416               		.loc 1 1467 0 is_stmt 1
 10417 3b1e 8AE0      		ldi r24,lo8(10)
 10418 3b20 90E0      		ldi r25,0
 10419               	.LVL876:
 10420 3b22 00C0      		rjmp .L715
 10421               	.LVL877:
 10422               	.L704:
1470:switcherator.c ****     if (duration == 0) {
 10423               		.loc 1 1470 0
 10424 3b24 0097      		sbiw r24,0
 10425 3b26 01F4      		brne .L705
1471:switcherator.c ****         fail(0x0b);
 10426               		.loc 1 1471 0
 10427 3b28 8BE0      		ldi r24,lo8(11)
 10428 3b2a 90E0      		ldi r25,0
 10429               	.LVL878:
 10430 3b2c 00C0      		rjmp .L715
 10431               	.LVL879:
 10432               	.L705:
1474:switcherator.c ****     duration *= 60; // convert to seconds
 10433               		.loc 1 1474 0
 10434 3b2e 6CE3      		ldi r22,lo8(60)
 10435 3b30 689F      		mul r22,r24
 10436 3b32 A001      		movw r20,r0
 10437 3b34 699F      		mul r22,r25
 10438 3b36 500D      		add r21,r0
 10439 3b38 1124      		clr __zero_reg__
 10440               	.LVL880:
1475:switcherator.c ****     startTime = (hours * 60);
 10441               		.loc 1 1475 0
 10442 3b3a 6C9D      		mul r22,r12
 10443 3b3c 9001      		movw r18,r0
 10444 3b3e 6D9D      		mul r22,r13
 10445 3b40 300D      		add r19,r0
 10446 3b42 1124      		clr __zero_reg__
 10447               	.LVL881:
1476:switcherator.c ****     startTime += minutes; // stored in minutes
 10448               		.loc 1 1476 0
 10449 3b44 2E0D      		add r18,r14
 10450 3b46 3F1D      		adc r19,r15
 10451               	.LVL882:
1479:switcherator.c ****     weeklyProgram[programNumber][1] = temp;
 10452               		.loc 1 1479 0
 10453 3b48 8AE0      		ldi r24,lo8(10)
 10454 3b4a 809F      		mul r24,r16
 10455 3b4c F001      		movw r30,r0
 10456 3b4e 819F      		mul r24,r17
 10457 3b50 F00D      		add r31,r0
 10458 3b52 1124      		clr __zero_reg__
 10459 3b54 E050      		subi r30,lo8(-(weeklyProgram))
 10460 3b56 F040      		sbci r31,hi8(-(weeklyProgram))
 10461 3b58 3183      		std Z+1,r19
 10462               	.LVL883:
1481:switcherator.c ****     weeklyProgram[programNumber][2] = temp;
 10463               		.loc 1 1481 0
 10464 3b5a 2283      		std Z+2,r18
 10465               	.LVL884:
1483:switcherator.c ****     weeklyProgram[programNumber][3] = temp;
 10466               		.loc 1 1483 0
 10467 3b5c 5383      		std Z+3,r21
 10468               	.LVL885:
1484:switcherator.c ****     temp = (duration & 0xff);
 10469               		.loc 1 1484 0
 10470 3b5e 5527      		clr r21
 10471               	.LVL886:
1485:switcherator.c ****     weeklyProgram[programNumber][4] = temp;
 10472               		.loc 1 1485 0
 10473 3b60 4483      		std Z+4,r20
 10474               	/* epilogue start */
1487:switcherator.c **** }
 10475               		.loc 1 1487 0
 10476 3b62 DF91      		pop r29
 10477 3b64 CF91      		pop r28
 10478               	.LVL887:
 10479 3b66 1F91      		pop r17
 10480 3b68 0F91      		pop r16
 10481               	.LVL888:
 10482 3b6a FF90      		pop r15
 10483 3b6c EF90      		pop r14
 10484               	.LVL889:
 10485 3b6e DF90      		pop r13
 10486 3b70 CF90      		pop r12
 10487               	.LVL890:
 10488 3b72 BF90      		pop r11
 10489 3b74 AF90      		pop r10
1486:switcherator.c ****     ok();
 10490               		.loc 1 1486 0
 10491 3b76 0C94 0000 		jmp ok
 10492               	.LVL891:
 10493               	.LFE36:
 10495               		.section	.rodata.str1.1
 10496               	.LC69:
 10497 0151 3030 3030 		.string	"0000000"
 10497      3030 3000 
 10498               		.text
 10499               	.global	programSetDays
 10501               	programSetDays:
 10502               	.LFB35:
1389:switcherator.c **** void programSetDays(char * commandReceived) {
 10503               		.loc 1 1389 0
 10504               	.LVL892:
 10505 3b7a EF92      		push r14
 10506               	.LCFI264:
 10507 3b7c FF92      		push r15
 10508               	.LCFI265:
 10509 3b7e 0F93      		push r16
 10510               	.LCFI266:
 10511 3b80 1F93      		push r17
 10512               	.LCFI267:
 10513 3b82 CF93      		push r28
 10514               	.LCFI268:
 10515 3b84 DF93      		push r29
 10516               	.LCFI269:
 10517 3b86 CDB7      		in r28,__SP_L__
 10518 3b88 DEB7      		in r29,__SP_H__
 10519               	.LCFI270:
 10520 3b8a 2897      		sbiw r28,8
 10521               	.LCFI271:
 10522 3b8c 0FB6      		in __tmp_reg__,__SREG__
 10523 3b8e F894      		cli
 10524 3b90 DEBF      		out __SP_H__,r29
 10525 3b92 0FBE      		out __SREG__,__tmp_reg__
 10526 3b94 CDBF      		out __SP_L__,r28
 10527               	/* prologue: function */
 10528               	/* frame size = 8 */
 10529               	/* stack size = 14 */
 10530               	.L__stack_usage = 14
 10531 3b96 7C01      		movw r14,r24
1390:switcherator.c ****     char tempReallyLongString[] = "0000000";
 10532               		.loc 1 1390 0
 10533 3b98 88E0      		ldi r24,lo8(8)
 10534               	.LVL893:
 10535 3b9a E0E0      		ldi r30,lo8(.LC69)
 10536 3b9c F0E0      		ldi r31,hi8(.LC69)
 10537 3b9e DE01      		movw r26,r28
 10538 3ba0 1196      		adiw r26,1
 10539               		0:
 10540 3ba2 0190      		ld r0,Z+
 10541 3ba4 0D92      		st X+,r0
 10542 3ba6 8A95      		dec r24
 10543 3ba8 01F4      		brne 0b
 10544               	.LVL894:
1393:switcherator.c ****     tempIntString[0] = commandReceived[3];
 10545               		.loc 1 1393 0
 10546 3baa F701      		movw r30,r14
 10547 3bac 8381      		ldd r24,Z+3
 10548 3bae 8093 0000 		sts tempIntString,r24
1394:switcherator.c ****     tempIntString[1] = commandReceived[4];
 10549               		.loc 1 1394 0
 10550 3bb2 8481      		ldd r24,Z+4
 10551 3bb4 8093 0000 		sts tempIntString+1,r24
1395:switcherator.c ****     programNumber = atoi(tempIntString);
 10552               		.loc 1 1395 0
 10553 3bb8 80E0      		ldi r24,lo8(tempIntString)
 10554 3bba 90E0      		ldi r25,hi8(tempIntString)
 10555 3bbc 0E94 0000 		call atoi
 10556               	.LVL895:
 10557 3bc0 8C01      		movw r16,r24
 10558               	.LVL896:
1396:switcherator.c ****     tempReallyLongString[0] = commandReceived[5];
 10559               		.loc 1 1396 0
 10560 3bc2 F701      		movw r30,r14
 10561 3bc4 8581      		ldd r24,Z+5
 10562 3bc6 8983      		std Y+1,r24
1397:switcherator.c ****     tempReallyLongString[1] = commandReceived[6];
 10563               		.loc 1 1397 0
 10564 3bc8 8681      		ldd r24,Z+6
 10565 3bca 8A83      		std Y+2,r24
1398:switcherator.c ****     tempReallyLongString[2] = commandReceived[7];
 10566               		.loc 1 1398 0
 10567 3bcc 8781      		ldd r24,Z+7
 10568 3bce 8B83      		std Y+3,r24
1399:switcherator.c ****     tempReallyLongString[3] = commandReceived[8];
 10569               		.loc 1 1399 0
 10570 3bd0 8085      		ldd r24,Z+8
 10571 3bd2 8C83      		std Y+4,r24
1400:switcherator.c ****     tempReallyLongString[4] = commandReceived[9];
 10572               		.loc 1 1400 0
 10573 3bd4 8185      		ldd r24,Z+9
 10574 3bd6 8D83      		std Y+5,r24
1401:switcherator.c ****     tempReallyLongString[5] = commandReceived[10];
 10575               		.loc 1 1401 0
 10576 3bd8 8285      		ldd r24,Z+10
 10577 3bda 8E83      		std Y+6,r24
1402:switcherator.c ****     tempReallyLongString[6] = commandReceived[11];
 10578               		.loc 1 1402 0
 10579 3bdc 8385      		ldd r24,Z+11
 10580 3bde 8F83      		std Y+7,r24
1403:switcherator.c ****     weekLong = strtol(tempReallyLongString, 0, 2);
 10581               		.loc 1 1403 0
 10582 3be0 42E0      		ldi r20,lo8(2)
 10583 3be2 50E0      		ldi r21,0
 10584 3be4 60E0      		ldi r22,0
 10585 3be6 70E0      		ldi r23,0
 10586 3be8 CE01      		movw r24,r28
 10587 3bea 0196      		adiw r24,1
 10588 3bec 0E94 0000 		call strtol
 10589               	.LVL897:
1404:switcherator.c ****     if ((programNumber >= MAX_PROGRAM) || (programNumber == 0 && commandReceived[4] != '0')) {
 10590               		.loc 1 1404 0
 10591 3bf0 0431      		cpi r16,20
 10592 3bf2 1105      		cpc r17,__zero_reg__
 10593 3bf4 04F4      		brge .L717
1404:switcherator.c ****     if ((programNumber >= MAX_PROGRAM) || (programNumber == 0 && commandReceived[4] != '0')) {
 10594               		.loc 1 1404 0 is_stmt 0 discriminator 1
 10595 3bf6 0115      		cp r16,__zero_reg__
 10596 3bf8 1105      		cpc r17,__zero_reg__
 10597 3bfa 01F4      		brne .L718
 10598 3bfc F701      		movw r30,r14
 10599 3bfe 2481      		ldd r18,Z+4
 10600 3c00 2033      		cpi r18,lo8(48)
 10601 3c02 01F0      		breq .L718
 10602               	.L717:
1405:switcherator.c ****         fail(2);
 10603               		.loc 1 1405 0 is_stmt 1
 10604 3c04 82E0      		ldi r24,lo8(2)
 10605 3c06 90E0      		ldi r25,0
 10606 3c08 00C0      		rjmp .L726
 10607               	.L718:
1412:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 10608               		.loc 1 1412 0
 10609 3c0a 2AE0      		ldi r18,lo8(10)
 10610 3c0c 209F      		mul r18,r16
 10611 3c0e F001      		movw r30,r0
 10612 3c10 219F      		mul r18,r17
 10613 3c12 F00D      		add r31,r0
 10614 3c14 1124      		clr __zero_reg__
 10615 3c16 E050      		subi r30,lo8(-(weeklyProgram))
 10616 3c18 F040      		sbci r31,hi8(-(weeklyProgram))
 10617 3c1a 2081      		ld r18,Z
 10618 3c1c 2F3F      		cpi r18,lo8(-1)
 10619 3c1e 01F4      		brne .L720
1412:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 10620               		.loc 1 1412 0 is_stmt 0 discriminator 1
 10621 3c20 2181      		ldd r18,Z+1
 10622 3c22 2F3F      		cpi r18,lo8(-1)
 10623 3c24 01F4      		brne .L720
1413:switcherator.c ****         fail(0x0d);
 10624               		.loc 1 1413 0 is_stmt 1
 10625 3c26 8DE0      		ldi r24,lo8(13)
 10626 3c28 90E0      		ldi r25,0
 10627 3c2a 00C0      		rjmp .L726
 10628               	.L720:
1416:switcherator.c ****     if ((weekLong & 0x7f) == 0) {
 10629               		.loc 1 1416 0
 10630 3c2c AB01      		movw r20,r22
 10631 3c2e BC01      		movw r22,r24
 10632 3c30 4F77      		andi r20,127
 10633 3c32 5527      		clr r21
 10634 3c34 6627      		clr r22
 10635 3c36 7727      		clr r23
 10636 3c38 4115      		cp r20,__zero_reg__
 10637 3c3a 5105      		cpc r21,__zero_reg__
 10638 3c3c 6105      		cpc r22,__zero_reg__
 10639 3c3e 7105      		cpc r23,__zero_reg__
 10640 3c40 01F4      		brne .L721
1417:switcherator.c ****         fail(0x0f);
 10641               		.loc 1 1417 0
 10642 3c42 8FE0      		ldi r24,lo8(15)
 10643 3c44 90E0      		ldi r25,0
 10644               	.L726:
 10645 3c46 0E94 0000 		call fail
 10646               	.LVL898:
 10647 3c4a 00C0      		rjmp .L716
 10648               	.LVL899:
 10649               	.L721:
1421:switcherator.c ****     weeklyProgram[programNumber][0] = weekdays;
 10650               		.loc 1 1421 0
 10651 3c4c 8AE0      		ldi r24,lo8(10)
 10652 3c4e 809F      		mul r24,r16
 10653 3c50 F001      		movw r30,r0
 10654 3c52 819F      		mul r24,r17
 10655 3c54 F00D      		add r31,r0
 10656 3c56 1124      		clr __zero_reg__
 10657 3c58 E050      		subi r30,lo8(-(weeklyProgram))
 10658 3c5a F040      		sbci r31,hi8(-(weeklyProgram))
1420:switcherator.c ****     char weekdays = (weekLong & 0x7f);
 10659               		.loc 1 1420 0
 10660 3c5c 4083      		st Z,r20
1422:switcherator.c ****     ok();
 10661               		.loc 1 1422 0
 10662 3c5e 0E94 0000 		call ok
 10663               	.LVL900:
 10664               	.L716:
 10665               	/* epilogue start */
1423:switcherator.c **** }
 10666               		.loc 1 1423 0
 10667 3c62 2896      		adiw r28,8
 10668 3c64 0FB6      		in __tmp_reg__,__SREG__
 10669 3c66 F894      		cli
 10670 3c68 DEBF      		out __SP_H__,r29
 10671 3c6a 0FBE      		out __SREG__,__tmp_reg__
 10672 3c6c CDBF      		out __SP_L__,r28
 10673 3c6e DF91      		pop r29
 10674 3c70 CF91      		pop r28
 10675 3c72 1F91      		pop r17
 10676 3c74 0F91      		pop r16
 10677               	.LVL901:
 10678 3c76 FF90      		pop r15
 10679 3c78 EF90      		pop r14
 10680               	.LVL902:
 10681 3c7a 0895      		ret
 10682               	.LFE35:
 10684               	.global	programAddSwitch
 10686               	programAddSwitch:
 10687               	.LFB33:
1284:switcherator.c **** void programAddSwitch(char * commandReceived) {
 10688               		.loc 1 1284 0
 10689               	.LVL903:
 10690 3c7c CF92      		push r12
 10691               	.LCFI272:
 10692 3c7e DF92      		push r13
 10693               	.LCFI273:
 10694 3c80 EF92      		push r14
 10695               	.LCFI274:
 10696 3c82 FF92      		push r15
 10697               	.LCFI275:
 10698 3c84 0F93      		push r16
 10699               	.LCFI276:
 10700 3c86 1F93      		push r17
 10701               	.LCFI277:
 10702 3c88 CF93      		push r28
 10703               	.LCFI278:
 10704 3c8a DF93      		push r29
 10705               	.LCFI279:
 10706 3c8c CDB7      		in r28,__SP_L__
 10707 3c8e DEB7      		in r29,__SP_H__
 10708               	.LCFI280:
 10709 3c90 6097      		sbiw r28,16
 10710               	.LCFI281:
 10711 3c92 0FB6      		in __tmp_reg__,__SREG__
 10712 3c94 F894      		cli
 10713 3c96 DEBF      		out __SP_H__,r29
 10714 3c98 0FBE      		out __SREG__,__tmp_reg__
 10715 3c9a CDBF      		out __SP_L__,r28
 10716               	/* prologue: function */
 10717               	/* frame size = 16 */
 10718               	/* stack size = 24 */
 10719               	.L__stack_usage = 24
 10720 3c9c 7C01      		movw r14,r24
 10721               	.LVL904:
1287:switcherator.c ****     tempIntString[0] = commandReceived[3];
 10722               		.loc 1 1287 0
 10723 3c9e FC01      		movw r30,r24
 10724 3ca0 8381      		ldd r24,Z+3
 10725               	.LVL905:
 10726 3ca2 8093 0000 		sts tempIntString,r24
1288:switcherator.c ****     tempIntString[1] = commandReceived[4];
 10727               		.loc 1 1288 0
 10728 3ca6 8481      		ldd r24,Z+4
 10729 3ca8 8093 0000 		sts tempIntString+1,r24
1289:switcherator.c ****     programNumber = atoi(tempIntString);
 10730               		.loc 1 1289 0
 10731 3cac 80E0      		ldi r24,lo8(tempIntString)
 10732 3cae 90E0      		ldi r25,hi8(tempIntString)
 10733 3cb0 0E94 0000 		call atoi
 10734               	.LVL906:
 10735 3cb4 8C01      		movw r16,r24
 10736               	.LVL907:
1290:switcherator.c ****     tempIntString[0] = commandReceived[5];
 10737               		.loc 1 1290 0
 10738 3cb6 F701      		movw r30,r14
 10739 3cb8 8581      		ldd r24,Z+5
 10740 3cba 8093 0000 		sts tempIntString,r24
1291:switcherator.c ****     tempIntString[1] = commandReceived[6];
 10741               		.loc 1 1291 0
 10742 3cbe 8681      		ldd r24,Z+6
 10743 3cc0 8093 0000 		sts tempIntString+1,r24
1292:switcherator.c ****     switchNumber = atoi(tempIntString);
 10744               		.loc 1 1292 0
 10745 3cc4 80E0      		ldi r24,lo8(tempIntString)
 10746 3cc6 90E0      		ldi r25,hi8(tempIntString)
 10747 3cc8 0E94 0000 		call atoi
 10748               	.LVL908:
 10749 3ccc 6C01      		movw r12,r24
 10750               	.LVL909:
1294:switcherator.c ****     switches[0] = 0;
 10751               		.loc 1 1294 0
 10752 3cce 1982      		std Y+1,__zero_reg__
1295:switcherator.c ****     int switchCount = programGetSwitches(programNumber, switches);
 10753               		.loc 1 1295 0
 10754 3cd0 BE01      		movw r22,r28
 10755 3cd2 6F5F      		subi r22,-1
 10756 3cd4 7F4F      		sbci r23,-1
 10757 3cd6 C801      		movw r24,r16
 10758 3cd8 0E94 0000 		call programGetSwitches
 10759               	.LVL910:
 10760 3cdc FE01      		movw r30,r28
 10761 3cde 3196      		adiw r30,1
1284:switcherator.c **** void programAddSwitch(char * commandReceived) {
 10762               		.loc 1 1284 0
 10763 3ce0 AF01      		movw r20,r30
1298:switcherator.c ****     for (x = 0; x < switchCount; x++) {
 10764               		.loc 1 1298 0
 10765 3ce2 00C0      		rjmp .L728
 10766               	.LVL911:
 10767               	.L730:
1299:switcherator.c ****         if (switches[x] == switchNumber) {
 10768               		.loc 1 1299 0
 10769 3ce4 2191      		ld r18,Z+
 10770 3ce6 30E0      		ldi r19,0
 10771 3ce8 2C15      		cp r18,r12
 10772 3cea 3D05      		cpc r19,r13
 10773 3cec 01F4      		brne .L728
1300:switcherator.c ****             fail(0x0c);
 10774               		.loc 1 1300 0
 10775 3cee 8CE0      		ldi r24,lo8(12)
 10776 3cf0 90E0      		ldi r25,0
 10777               	.LVL912:
 10778 3cf2 00C0      		rjmp .L754
 10779               	.LVL913:
 10780               	.L728:
1284:switcherator.c **** void programAddSwitch(char * commandReceived) {
 10781               		.loc 1 1284 0 discriminator 1
 10782 3cf4 9F01      		movw r18,r30
 10783 3cf6 241B      		sub r18,r20
 10784 3cf8 350B      		sbc r19,r21
1298:switcherator.c ****     for (x = 0; x < switchCount; x++) {
 10785               		.loc 1 1298 0 discriminator 1
 10786 3cfa 2817      		cp r18,r24
 10787 3cfc 3907      		cpc r19,r25
 10788 3cfe 04F0      		brlt .L730
1306:switcherator.c ****     if ((programNumber >= MAX_PROGRAM) || (programNumber == 0 && commandReceived[4] != '0')) {
 10789               		.loc 1 1306 0
 10790 3d00 0431      		cpi r16,20
 10791 3d02 1105      		cpc r17,__zero_reg__
 10792 3d04 04F4      		brge .L731
1306:switcherator.c ****     if ((programNumber >= MAX_PROGRAM) || (programNumber == 0 && commandReceived[4] != '0')) {
 10793               		.loc 1 1306 0 is_stmt 0 discriminator 1
 10794 3d06 0115      		cp r16,__zero_reg__
 10795 3d08 1105      		cpc r17,__zero_reg__
 10796 3d0a 01F4      		brne .L732
 10797 3d0c F701      		movw r30,r14
 10798 3d0e 8481      		ldd r24,Z+4
 10799               	.LVL914:
 10800 3d10 8033      		cpi r24,lo8(48)
 10801 3d12 01F0      		breq .L732
 10802               	.L731:
1307:switcherator.c ****         fail(2);
 10803               		.loc 1 1307 0 is_stmt 1
 10804 3d14 82E0      		ldi r24,lo8(2)
 10805 3d16 90E0      		ldi r25,0
 10806 3d18 00C0      		rjmp .L754
 10807               	.L732:
1310:switcherator.c ****     if ((switchNumber >= NUM_SWITCHES) || (switchNumber == 0 && commandReceived[6] != '0')) {
 10808               		.loc 1 1310 0
 10809 3d1a F0E1      		ldi r31,16
 10810 3d1c CF16      		cp r12,r31
 10811 3d1e D104      		cpc r13,__zero_reg__
 10812 3d20 04F4      		brge .L733
1310:switcherator.c ****     if ((switchNumber >= NUM_SWITCHES) || (switchNumber == 0 && commandReceived[6] != '0')) {
 10813               		.loc 1 1310 0 is_stmt 0 discriminator 1
 10814 3d22 C114      		cp r12,__zero_reg__
 10815 3d24 D104      		cpc r13,__zero_reg__
 10816 3d26 01F4      		brne .L734
 10817 3d28 F701      		movw r30,r14
 10818 3d2a 8681      		ldd r24,Z+6
 10819 3d2c 8033      		cpi r24,lo8(48)
 10820 3d2e 01F0      		breq .L734
 10821               	.L733:
1311:switcherator.c ****         fail(1);
 10822               		.loc 1 1311 0 is_stmt 1
 10823 3d30 81E0      		ldi r24,lo8(1)
 10824 3d32 90E0      		ldi r25,0
 10825 3d34 00C0      		rjmp .L754
 10826               	.L734:
1318:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 10827               		.loc 1 1318 0
 10828 3d36 8AE0      		ldi r24,lo8(10)
 10829 3d38 809F      		mul r24,r16
 10830 3d3a F001      		movw r30,r0
 10831 3d3c 819F      		mul r24,r17
 10832 3d3e F00D      		add r31,r0
 10833 3d40 1124      		clr __zero_reg__
 10834 3d42 E050      		subi r30,lo8(-(weeklyProgram))
 10835 3d44 F040      		sbci r31,hi8(-(weeklyProgram))
 10836 3d46 8081      		ld r24,Z
 10837 3d48 8F3F      		cpi r24,lo8(-1)
 10838 3d4a 01F4      		brne .L735
1318:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 10839               		.loc 1 1318 0 is_stmt 0 discriminator 1
 10840 3d4c 8181      		ldd r24,Z+1
 10841 3d4e 8F3F      		cpi r24,lo8(-1)
 10842 3d50 01F4      		brne .L735
1319:switcherator.c ****         fail(0x0d);
 10843               		.loc 1 1319 0 is_stmt 1
 10844 3d52 8DE0      		ldi r24,lo8(13)
 10845 3d54 90E0      		ldi r25,0
 10846 3d56 00C0      		rjmp .L754
 10847               	.L735:
 10848               	.LVL915:
1326:switcherator.c ****     itoa(programNumber, tempIntString, 10);
 10849               		.loc 1 1326 0
 10850 3d58 4AE0      		ldi r20,lo8(10)
 10851 3d5a 50E0      		ldi r21,0
 10852 3d5c 60E0      		ldi r22,lo8(tempIntString)
 10853 3d5e 70E0      		ldi r23,hi8(tempIntString)
 10854 3d60 C801      		movw r24,r16
 10855 3d62 0E94 0000 		call itoa
 10856               	.LVL916:
1328:switcherator.c ****     blankSwitch = findOpenSwitch(programNumber);
 10857               		.loc 1 1328 0
 10858 3d66 C801      		movw r24,r16
 10859 3d68 0E94 0000 		call findOpenSwitch
 10860               	.LVL917:
1330:switcherator.c ****         if (blankSwitch == 0) {
 10861               		.loc 1 1330 0
 10862 3d6c 0097      		sbiw r24,0
 10863 3d6e 01F4      		brne .L736
1333:switcherator.c ****             overflowProgram = weeklyProgram[programNumber][9];
 10864               		.loc 1 1333 0
 10865 3d70 4AE0      		ldi r20,lo8(10)
 10866               	.LVL918:
 10867               	.L753:
 10868 3d72 409F      		mul r20,r16
 10869 3d74 F001      		movw r30,r0
 10870 3d76 419F      		mul r20,r17
 10871 3d78 F00D      		add r31,r0
 10872 3d7a 1124      		clr __zero_reg__
 10873 3d7c E050      		subi r30,lo8(-(weeklyProgram))
 10874 3d7e F040      		sbci r31,hi8(-(weeklyProgram))
 10875 3d80 8185      		ldd r24,Z+9
 10876 3d82 90E0      		ldi r25,0
 10877               	.LVL919:
1334:switcherator.c ****             if (overflowProgram == 255) {
 10878               		.loc 1 1334 0
 10879 3d84 8F3F      		cpi r24,-1
 10880 3d86 9105      		cpc r25,__zero_reg__
 10881 3d88 01F4      		brne .L743
 10882 3d8a 2FEF      		ldi r18,lo8(-1)
 10883 3d8c 30E0      		ldi r19,0
 10884 3d8e 83E1      		ldi r24,lo8(19)
 10885 3d90 90E0      		ldi r25,0
 10886               	.LVL920:
 10887               	.L739:
 10888               	.LBB28:
1341:switcherator.c ****                     if (weeklyProgram[x][0] == 255 && weeklyProgram[x][5] == 255) {
 10889               		.loc 1 1341 0
 10890 3d92 489F      		mul r20,r24
 10891 3d94 F001      		movw r30,r0
 10892 3d96 499F      		mul r20,r25
 10893 3d98 F00D      		add r31,r0
 10894 3d9a 1124      		clr __zero_reg__
 10895 3d9c E050      		subi r30,lo8(-(weeklyProgram))
 10896 3d9e F040      		sbci r31,hi8(-(weeklyProgram))
 10897 3da0 5081      		ld r21,Z
 10898 3da2 5F3F      		cpi r21,lo8(-1)
 10899 3da4 01F4      		brne .L738
1341:switcherator.c ****                     if (weeklyProgram[x][0] == 255 && weeklyProgram[x][5] == 255) {
 10900               		.loc 1 1341 0 is_stmt 0 discriminator 1
 10901 3da6 5581      		ldd r21,Z+5
 10902 3da8 5F3F      		cpi r21,lo8(-1)
 10903 3daa 01F4      		brne .L738
1341:switcherator.c ****                     if (weeklyProgram[x][0] == 255 && weeklyProgram[x][5] == 255) {
 10904               		.loc 1 1341 0
 10905 3dac 9C01      		movw r18,r24
1345:switcherator.c ****                         x = 0;
 10906               		.loc 1 1345 0 is_stmt 1
 10907 3dae 80E0      		ldi r24,0
 10908 3db0 90E0      		ldi r25,0
 10909               	.L738:
 10910               	.LVL921:
1339:switcherator.c ****                 for (x = (MAX_PROGRAM - 1); x > 0; x--) {
 10911               		.loc 1 1339 0
 10912 3db2 0197      		sbiw r24,1
 10913               	.LVL922:
 10914 3db4 1816      		cp __zero_reg__,r24
 10915 3db6 1906      		cpc __zero_reg__,r25
 10916 3db8 04F0      		brlt .L739
1348:switcherator.c ****                 if (possibleBlank == 255) {
 10917               		.loc 1 1348 0
 10918 3dba 2F3F      		cpi r18,-1
 10919 3dbc 3105      		cpc r19,__zero_reg__
 10920 3dbe 01F4      		brne .L740
1350:switcherator.c ****                     fail(0x0e);
 10921               		.loc 1 1350 0
 10922 3dc0 8EE0      		ldi r24,lo8(14)
 10923 3dc2 90E0      		ldi r25,0
 10924               	.LVL923:
 10925               	.L754:
 10926 3dc4 0E94 0000 		call fail
 10927               	.LVL924:
 10928 3dc8 00C0      		rjmp .L727
 10929               	.LVL925:
 10930               	.L740:
1354:switcherator.c ****                 weeklyProgram[programNumber][9] = possibleBlank;
 10931               		.loc 1 1354 0
 10932 3dca 409F      		mul r20,r16
 10933 3dcc F001      		movw r30,r0
 10934 3dce 419F      		mul r20,r17
 10935 3dd0 F00D      		add r31,r0
 10936 3dd2 1124      		clr __zero_reg__
 10937 3dd4 E050      		subi r30,lo8(-(weeklyProgram))
 10938 3dd6 F040      		sbci r31,hi8(-(weeklyProgram))
 10939 3dd8 2187      		std Z+9,r18
 10940               	.LVL926:
 10941 3dda 8901      		movw r16,r18
 10942 3ddc 00C0      		rjmp .L753
 10943               	.LVL927:
 10944               	.L743:
 10945               	.LBE28:
1334:switcherator.c ****             if (overflowProgram == 255) {
 10946               		.loc 1 1334 0
 10947 3dde 8C01      		movw r16,r24
 10948               	.LVL928:
 10949 3de0 00C0      		rjmp .L753
 10950               	.LVL929:
 10951               	.L736:
1366:switcherator.c ****     weeklyProgram[programNumber][blankSwitch] = switchNumber;
 10952               		.loc 1 1366 0 discriminator 1
 10953 3de2 2AE0      		ldi r18,lo8(10)
 10954 3de4 209F      		mul r18,r16
 10955 3de6 F001      		movw r30,r0
 10956 3de8 219F      		mul r18,r17
 10957 3dea F00D      		add r31,r0
 10958 3dec 1124      		clr __zero_reg__
 10959 3dee E80F      		add r30,r24
 10960 3df0 F91F      		adc r31,r25
 10961 3df2 E050      		subi r30,lo8(-(weeklyProgram))
 10962 3df4 F040      		sbci r31,hi8(-(weeklyProgram))
 10963 3df6 C082      		st Z,r12
1367:switcherator.c ****     ok();
 10964               		.loc 1 1367 0 discriminator 1
 10965 3df8 0E94 0000 		call ok
 10966               	.LVL930:
 10967               	.L727:
 10968               	/* epilogue start */
1368:switcherator.c **** }
 10969               		.loc 1 1368 0
 10970 3dfc 6096      		adiw r28,16
 10971 3dfe 0FB6      		in __tmp_reg__,__SREG__
 10972 3e00 F894      		cli
 10973 3e02 DEBF      		out __SP_H__,r29
 10974 3e04 0FBE      		out __SREG__,__tmp_reg__
 10975 3e06 CDBF      		out __SP_L__,r28
 10976 3e08 DF91      		pop r29
 10977 3e0a CF91      		pop r28
 10978 3e0c 1F91      		pop r17
 10979 3e0e 0F91      		pop r16
 10980               	.LVL931:
 10981 3e10 FF90      		pop r15
 10982 3e12 EF90      		pop r14
 10983               	.LVL932:
 10984 3e14 DF90      		pop r13
 10985 3e16 CF90      		pop r12
 10986               	.LVL933:
 10987 3e18 0895      		ret
 10988               	.LFE33:
 10990               	.global	clearProgram
 10992               	clearProgram:
 10993               	.LFB31:
1254:switcherator.c **** void clearProgram(char * commandReceived) {
 10994               		.loc 1 1254 0
 10995               	.LVL934:
 10996 3e1a 0F93      		push r16
 10997               	.LCFI282:
 10998 3e1c 1F93      		push r17
 10999               	.LCFI283:
 11000 3e1e CF93      		push r28
 11001               	.LCFI284:
 11002 3e20 DF93      		push r29
 11003               	.LCFI285:
 11004               	/* prologue: function */
 11005               	/* frame size = 0 */
 11006               	/* stack size = 4 */
 11007               	.L__stack_usage = 4
 11008 3e22 8C01      		movw r16,r24
1255:switcherator.c ****     int programNumber = getSwitchNumber(commandReceived);
 11009               		.loc 1 1255 0
 11010 3e24 0E94 0000 		call getSwitchNumber
 11011               	.LVL935:
 11012 3e28 EC01      		movw r28,r24
 11013               	.LVL936:
1256:switcherator.c ****     if (programNumber >= MAX_PROGRAM || (programNumber == 0 && commandReceived[4] != '0')) {
 11014               		.loc 1 1256 0
 11015 3e2a 8431      		cpi r24,20
 11016 3e2c 9105      		cpc r25,__zero_reg__
 11017 3e2e 04F4      		brge .L756
1256:switcherator.c ****     if (programNumber >= MAX_PROGRAM || (programNumber == 0 && commandReceived[4] != '0')) {
 11018               		.loc 1 1256 0 is_stmt 0 discriminator 1
 11019 3e30 0097      		sbiw r24,0
 11020 3e32 01F4      		brne .L757
 11021 3e34 F801      		movw r30,r16
 11022 3e36 8481      		ldd r24,Z+4
 11023               	.LVL937:
 11024 3e38 8033      		cpi r24,lo8(48)
 11025 3e3a 01F0      		breq .L757
 11026               	.L756:
1257:switcherator.c ****         fail(2);
 11027               		.loc 1 1257 0 is_stmt 1
 11028 3e3c 82E0      		ldi r24,lo8(2)
 11029 3e3e 90E0      		ldi r25,0
 11030               	/* epilogue start */
1263:switcherator.c **** }
 11031               		.loc 1 1263 0
 11032 3e40 DF91      		pop r29
 11033 3e42 CF91      		pop r28
 11034               	.LVL938:
 11035 3e44 1F91      		pop r17
 11036 3e46 0F91      		pop r16
 11037               	.LVL939:
1257:switcherator.c ****         fail(2);
 11038               		.loc 1 1257 0
 11039 3e48 0C94 0000 		jmp fail
 11040               	.LVL940:
 11041               	.L757:
1259:switcherator.c ****         itoa(programNumber, tempIntString, 10);
 11042               		.loc 1 1259 0
 11043 3e4c 4AE0      		ldi r20,lo8(10)
 11044 3e4e 50E0      		ldi r21,0
 11045 3e50 60E0      		ldi r22,lo8(tempIntString)
 11046 3e52 70E0      		ldi r23,hi8(tempIntString)
 11047 3e54 CE01      		movw r24,r28
 11048 3e56 0E94 0000 		call itoa
 11049               	.LVL941:
1260:switcherator.c ****         ok();
 11050               		.loc 1 1260 0
 11051 3e5a 0E94 0000 		call ok
 11052               	.LVL942:
1261:switcherator.c ****         clearTheProgram(programNumber);
 11053               		.loc 1 1261 0
 11054 3e5e CE01      		movw r24,r28
 11055               	/* epilogue start */
1263:switcherator.c **** }
 11056               		.loc 1 1263 0
 11057 3e60 DF91      		pop r29
 11058 3e62 CF91      		pop r28
 11059               	.LVL943:
 11060 3e64 1F91      		pop r17
 11061 3e66 0F91      		pop r16
 11062               	.LVL944:
1261:switcherator.c ****         clearTheProgram(programNumber);
 11063               		.loc 1 1261 0
 11064 3e68 0C94 0000 		jmp clearTheProgram
 11065               	.LVL945:
 11066               	.LFE31:
 11068               	.global	colorChangeSet
 11070               	colorChangeSet:
 11071               	.LFB25:
 954:switcherator.c **** void colorChangeSet(char * commandReceived) {
 11072               		.loc 1 954 0
 11073               	.LVL946:
 11074 3e6c EF92      		push r14
 11075               	.LCFI286:
 11076 3e6e FF92      		push r15
 11077               	.LCFI287:
 11078 3e70 0F93      		push r16
 11079               	.LCFI288:
 11080 3e72 1F93      		push r17
 11081               	.LCFI289:
 11082 3e74 CF93      		push r28
 11083               	.LCFI290:
 11084 3e76 DF93      		push r29
 11085               	.LCFI291:
 11086               	/* prologue: function */
 11087               	/* frame size = 0 */
 11088               	/* stack size = 6 */
 11089               	.L__stack_usage = 6
 11090 3e78 EC01      		movw r28,r24
 955:switcherator.c ****     int programNumber = getSwitchNumber(commandReceived);
 11091               		.loc 1 955 0
 11092 3e7a 0E94 0000 		call getSwitchNumber
 11093               	.LVL947:
 11094 3e7e 7C01      		movw r14,r24
 11095               	.LVL948:
 956:switcherator.c ****     if (programNumber >= NUM_COLOR_CHANGES) {
 11096               		.loc 1 956 0
 11097 3e80 86E0      		ldi r24,6
 11098 3e82 E816      		cp r14,r24
 11099 3e84 F104      		cpc r15,__zero_reg__
 11100 3e86 04F0      		brlt .L762
 957:switcherator.c ****         fail(7);
 11101               		.loc 1 957 0
 11102 3e88 87E0      		ldi r24,lo8(7)
 11103 3e8a 90E0      		ldi r25,0
 11104               	/* epilogue start */
 974:switcherator.c **** }
 11105               		.loc 1 974 0
 11106 3e8c DF91      		pop r29
 11107 3e8e CF91      		pop r28
 11108               	.LVL949:
 11109 3e90 1F91      		pop r17
 11110 3e92 0F91      		pop r16
 11111 3e94 FF90      		pop r15
 11112 3e96 EF90      		pop r14
 11113               	.LVL950:
 957:switcherator.c ****         fail(7);
 11114               		.loc 1 957 0
 11115 3e98 0C94 0000 		jmp fail
 11116               	.LVL951:
 11117               	.L762:
 960:switcherator.c ****     tempLongString[3] = 0;
 11118               		.loc 1 960 0
 11119 3e9c 1092 0000 		sts tempLongString+3,__zero_reg__
 961:switcherator.c ****     tempLongString[0] = commandReceived[6];
 11120               		.loc 1 961 0
 11121 3ea0 8E81      		ldd r24,Y+6
 11122 3ea2 8093 0000 		sts tempLongString,r24
 962:switcherator.c ****     tempLongString[1] = commandReceived[7];
 11123               		.loc 1 962 0
 11124 3ea6 8F81      		ldd r24,Y+7
 11125 3ea8 8093 0000 		sts tempLongString+1,r24
 963:switcherator.c ****     tempLongString[2] = commandReceived[8];
 11126               		.loc 1 963 0
 11127 3eac 8885      		ldd r24,Y+8
 11128 3eae 8093 0000 		sts tempLongString+2,r24
 964:switcherator.c ****     colorChanges[programNumber][0] = atoi(tempLongString);
 11129               		.loc 1 964 0
 11130 3eb2 80E0      		ldi r24,lo8(tempLongString)
 11131 3eb4 90E0      		ldi r25,hi8(tempLongString)
 11132 3eb6 0E94 0000 		call atoi
 11133               	.LVL952:
 11134 3eba 8701      		movw r16,r14
 11135 3ebc 000F      		lsl r16
 11136 3ebe 111F      		rol r17
 11137 3ec0 0E0D      		add r16,r14
 11138 3ec2 1F1D      		adc r17,r15
 11139 3ec4 0050      		subi r16,lo8(-(colorChanges))
 11140 3ec6 1040      		sbci r17,hi8(-(colorChanges))
 11141 3ec8 F801      		movw r30,r16
 11142 3eca 8083      		st Z,r24
 965:switcherator.c ****     tempLongString[0] = commandReceived[10];
 11143               		.loc 1 965 0
 11144 3ecc 8A85      		ldd r24,Y+10
 11145 3ece 8093 0000 		sts tempLongString,r24
 966:switcherator.c ****     tempLongString[1] = commandReceived[11];
 11146               		.loc 1 966 0
 11147 3ed2 8B85      		ldd r24,Y+11
 11148 3ed4 8093 0000 		sts tempLongString+1,r24
 967:switcherator.c ****     tempLongString[2] = commandReceived[12];
 11149               		.loc 1 967 0
 11150 3ed8 8C85      		ldd r24,Y+12
 11151 3eda 8093 0000 		sts tempLongString+2,r24
 968:switcherator.c ****     colorChanges[programNumber][1] = atoi(tempLongString);
 11152               		.loc 1 968 0
 11153 3ede 80E0      		ldi r24,lo8(tempLongString)
 11154 3ee0 90E0      		ldi r25,hi8(tempLongString)
 11155 3ee2 0E94 0000 		call atoi
 11156               	.LVL953:
 11157 3ee6 F801      		movw r30,r16
 11158 3ee8 8183      		std Z+1,r24
 969:switcherator.c ****     tempLongString[0] = commandReceived[14];
 11159               		.loc 1 969 0
 11160 3eea 8E85      		ldd r24,Y+14
 11161 3eec 8093 0000 		sts tempLongString,r24
 970:switcherator.c ****     tempLongString[1] = commandReceived[15];
 11162               		.loc 1 970 0
 11163 3ef0 8F85      		ldd r24,Y+15
 11164 3ef2 8093 0000 		sts tempLongString+1,r24
 971:switcherator.c ****     tempLongString[2] = commandReceived[16];
 11165               		.loc 1 971 0
 11166 3ef6 8889      		ldd r24,Y+16
 11167 3ef8 8093 0000 		sts tempLongString+2,r24
 972:switcherator.c ****     colorChanges[programNumber][2] = atoi(tempLongString);
 11168               		.loc 1 972 0
 11169 3efc 80E0      		ldi r24,lo8(tempLongString)
 11170 3efe 90E0      		ldi r25,hi8(tempLongString)
 11171 3f00 0E94 0000 		call atoi
 11172               	.LVL954:
 11173 3f04 F801      		movw r30,r16
 11174 3f06 8283      		std Z+2,r24
 11175               	/* epilogue start */
 974:switcherator.c **** }
 11176               		.loc 1 974 0
 11177 3f08 DF91      		pop r29
 11178 3f0a CF91      		pop r28
 11179               	.LVL955:
 11180 3f0c 1F91      		pop r17
 11181 3f0e 0F91      		pop r16
 11182 3f10 FF90      		pop r15
 11183 3f12 EF90      		pop r14
 11184               	.LVL956:
 973:switcherator.c ****     ok();
 11185               		.loc 1 973 0
 11186 3f14 0C94 0000 		jmp ok
 11187               	.LVL957:
 11188               	.LFE25:
 11190               	.global	pwmSetup
 11192               	pwmSetup:
 11193               	.LFB20:
 831:switcherator.c **** void pwmSetup(char * commandReceived) {
 11194               		.loc 1 831 0
 11195               	.LVL958:
 11196 3f18 0F93      		push r16
 11197               	.LCFI292:
 11198 3f1a 1F93      		push r17
 11199               	.LCFI293:
 11200 3f1c CF93      		push r28
 11201               	.LCFI294:
 11202 3f1e DF93      		push r29
 11203               	.LCFI295:
 11204               	/* prologue: function */
 11205               	/* frame size = 0 */
 11206               	/* stack size = 4 */
 11207               	.L__stack_usage = 4
 11208 3f20 EC01      		movw r28,r24
 11209               	.LVL959:
 11210 3f22 E0E0      		ldi r30,lo8(switchStuff)
 11211 3f24 F0E0      		ldi r31,hi8(switchStuff)
 11212               	.LVL960:
 11213               	.L766:
 834:switcherator.c ****         if (switchStuff[x] == 70 || switchStuff[x] == 71 || switchStuff[x] == 74 ||
 11214               		.loc 1 834 0
 11215 3f26 8191      		ld r24,Z+
 11216 3f28 982F      		mov r25,r24
 11217 3f2a 9654      		subi r25,lo8(-(-70))
 11218 3f2c 9230      		cpi r25,lo8(2)
 11219 3f2e 00F0      		brlo .L764
 834:switcherator.c ****         if (switchStuff[x] == 70 || switchStuff[x] == 71 || switchStuff[x] == 74 ||
 11220               		.loc 1 834 0 is_stmt 0 discriminator 1
 11221 3f30 8A34      		cpi r24,lo8(74)
 11222 3f32 01F0      		breq .L764
 11223 3f34 8B34      		cpi r24,lo8(75)
 11224 3f36 01F0      		breq .L764
 835:switcherator.c ****                 switchStuff[x] == 75 || switchStuff[x] == 76 || switchStuff[x] == 77) {
 11225               		.loc 1 835 0 is_stmt 1
 11226 3f38 8C34      		cpi r24,lo8(76)
 11227 3f3a 01F0      		breq .L764
 835:switcherator.c ****                 switchStuff[x] == 75 || switchStuff[x] == 76 || switchStuff[x] == 77) {
 11228               		.loc 1 835 0 is_stmt 0 discriminator 1
 11229 3f3c 8D34      		cpi r24,lo8(77)
 11230 3f3e 01F4      		brne .L765
 11231               	.L764:
 836:switcherator.c ****             fail(6);
 11232               		.loc 1 836 0 is_stmt 1
 11233 3f40 86E0      		ldi r24,lo8(6)
 11234 3f42 90E0      		ldi r25,0
 11235               	/* epilogue start */
 876:switcherator.c **** }
 11236               		.loc 1 876 0
 11237 3f44 DF91      		pop r29
 11238 3f46 CF91      		pop r28
 11239               	.LVL961:
 11240 3f48 1F91      		pop r17
 11241 3f4a 0F91      		pop r16
 836:switcherator.c ****             fail(6);
 11242               		.loc 1 836 0
 11243 3f4c 0C94 0000 		jmp fail
 11244               	.LVL962:
 11245               	.L765:
 833:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 11246               		.loc 1 833 0
 11247 3f50 80E0      		ldi r24,hi8(switchStuff+16)
 11248 3f52 E030      		cpi r30,lo8(switchStuff+16)
 11249 3f54 F807      		cpc r31,r24
 11250 3f56 01F4      		brne .L766
 11251               	.LVL963:
 842:switcherator.c ****     tempIntString[0] = commandReceived[5];
 11252               		.loc 1 842 0
 11253 3f58 8D81      		ldd r24,Y+5
 11254 3f5a 8093 0000 		sts tempIntString,r24
 843:switcherator.c ****     tempIntString[1] = commandReceived[6];
 11255               		.loc 1 843 0
 11256 3f5e 8E81      		ldd r24,Y+6
 11257 3f60 8093 0000 		sts tempIntString+1,r24
 844:switcherator.c ****     switchNumber = atoi(tempIntString);
 11258               		.loc 1 844 0
 11259 3f64 80E0      		ldi r24,lo8(tempIntString)
 11260 3f66 90E0      		ldi r25,hi8(tempIntString)
 11261 3f68 0E94 0000 		call atoi
 11262               	.LVL964:
 11263 3f6c 8C01      		movw r16,r24
 11264               	.LVL965:
 845:switcherator.c ****     clearTheSwitch(switchNumber);
 11265               		.loc 1 845 0
 11266 3f6e 0E94 0000 		call clearTheSwitch
 11267               	.LVL966:
 847:switcherator.c ****     if (commandReceived[8] == 'H' || commandReceived[8] == 'h' || commandReceived[8] == '1') {
 11268               		.loc 1 847 0
 11269 3f72 8885      		ldd r24,Y+8
 11270 3f74 8834      		cpi r24,lo8(72)
 11271 3f76 01F0      		breq .L767
 847:switcherator.c ****     if (commandReceived[8] == 'H' || commandReceived[8] == 'h' || commandReceived[8] == '1') {
 11272               		.loc 1 847 0 is_stmt 0 discriminator 1
 11273 3f78 8836      		cpi r24,lo8(104)
 11274 3f7a 01F0      		breq .L767
 11275 3f7c 8133      		cpi r24,lo8(49)
 11276 3f7e 01F4      		brne .L768
 11277               	.L767:
 848:switcherator.c ****         switchStuff[switchNumber] = 201;
 11278               		.loc 1 848 0 is_stmt 1
 11279 3f80 F801      		movw r30,r16
 11280 3f82 E050      		subi r30,lo8(-(switchStuff))
 11281 3f84 F040      		sbci r31,hi8(-(switchStuff))
 11282 3f86 89EC      		ldi r24,lo8(-55)
 11283 3f88 00C0      		rjmp .L793
 11284               	.L768:
 11285 3f8a F801      		movw r30,r16
 11286 3f8c E050      		subi r30,lo8(-(switchStuff))
 11287 3f8e F040      		sbci r31,hi8(-(switchStuff))
 849:switcherator.c ****     } else if (commandReceived[8] == 'C' || commandReceived[8] == 'c') {
 11288               		.loc 1 849 0
 11289 3f90 8334      		cpi r24,lo8(67)
 11290 3f92 01F0      		breq .L770
 849:switcherator.c ****     } else if (commandReceived[8] == 'C' || commandReceived[8] == 'c') {
 11291               		.loc 1 849 0 is_stmt 0 discriminator 1
 11292 3f94 8336      		cpi r24,lo8(99)
 11293 3f96 01F4      		brne .L771
 11294               	.L770:
 850:switcherator.c ****         switchStuff[switchNumber] = 202;
 11295               		.loc 1 850 0 is_stmt 1
 11296 3f98 8AEC      		ldi r24,lo8(-54)
 11297 3f9a 00C0      		rjmp .L793
 11298               	.L771:
 852:switcherator.c ****         switchStuff[switchNumber] = 200;
 11299               		.loc 1 852 0
 11300 3f9c 88EC      		ldi r24,lo8(-56)
 11301               	.L793:
 11302 3f9e 8083      		st Z,r24
 854:switcherator.c ****     DDRD |= (1 << PIND3) | (1 << PIND5) | (1 << PIND6);
 11303               		.loc 1 854 0
 11304 3fa0 8AB1      		in r24,0xa
 11305 3fa2 8866      		ori r24,lo8(104)
 11306 3fa4 8AB9      		out 0xa,r24
 856:switcherator.c ****     Red = 0;
 11307               		.loc 1 856 0
 11308 3fa6 1092 B400 		sts 180,__zero_reg__
 857:switcherator.c ****     Green = 0;
 11309               		.loc 1 857 0
 11310 3faa 18BC      		out 0x28,__zero_reg__
 858:switcherator.c ****     Blue = 0;
 11311               		.loc 1 858 0
 11312 3fac 17BC      		out 0x27,__zero_reg__
 861:switcherator.c ****     if (commandReceived[7] == '0') {
 11313               		.loc 1 861 0
 11314 3fae 8F81      		ldd r24,Y+7
 11315 3fb0 8033      		cpi r24,lo8(48)
 11316 3fb2 01F4      		brne .L772
 862:switcherator.c ****         pwmdir = 0;
 11317               		.loc 1 862 0
 11318 3fb4 1092 0000 		sts pwmdir,__zero_reg__
 863:switcherator.c ****         TCCR0A = (1 << COM0A0) | (1 << COM0A1) | (1 << COM0B0) | (1 << COM0B1) | (1 << WGM00);
 11319               		.loc 1 863 0
 11320 3fb8 81EF      		ldi r24,lo8(-15)
 11321 3fba 84BD      		out 0x24,r24
 864:switcherator.c ****         TCCR2A = (1 << COM2B0) | (1 << COM2B1) | (1 << WGM20);
 11322               		.loc 1 864 0
 11323 3fbc 81E3      		ldi r24,lo8(49)
 11324 3fbe 00C0      		rjmp .L794
 11325               	.L772:
 866:switcherator.c ****         pwmdir = 1;
 11326               		.loc 1 866 0
 11327 3fc0 81E0      		ldi r24,lo8(1)
 11328 3fc2 8093 0000 		sts pwmdir,r24
 867:switcherator.c ****         TCCR0A = (1 << COM0A1) | (1 << COM0B1) | (1 << WGM00);
 11329               		.loc 1 867 0
 11330 3fc6 81EA      		ldi r24,lo8(-95)
 11331 3fc8 84BD      		out 0x24,r24
 868:switcherator.c ****         TCCR2A = (1 << COM2B1) | (1 << WGM20);
 11332               		.loc 1 868 0
 11333 3fca 81E2      		ldi r24,lo8(33)
 11334               	.L794:
 11335 3fcc 8093 B000 		sts 176,r24
 871:switcherator.c ****     TCCR0B = (1 << CS01) | (1 << CS00);
 11336               		.loc 1 871 0
 11337 3fd0 83E0      		ldi r24,lo8(3)
 11338 3fd2 85BD      		out 0x25,r24
 873:switcherator.c ****     TCCR2B = (1 << CS22); // F_CPU/64
 11339               		.loc 1 873 0
 11340 3fd4 84E0      		ldi r24,lo8(4)
 11341 3fd6 8093 B100 		sts 177,r24
 11342               	/* epilogue start */
 876:switcherator.c **** }
 11343               		.loc 1 876 0
 11344 3fda DF91      		pop r29
 11345 3fdc CF91      		pop r28
 11346               	.LVL967:
 11347 3fde 1F91      		pop r17
 11348 3fe0 0F91      		pop r16
 11349               	.LVL968:
 875:switcherator.c ****     ok();
 11350               		.loc 1 875 0
 11351 3fe2 0C94 0000 		jmp ok
 11352               	.LVL969:
 11353               	.LFE20:
 11355               	.global	startSwitch
 11357               	startSwitch:
 11358               	.LFB17:
 646:switcherator.c **** void startSwitch(char * commandReceived) {
 11359               		.loc 1 646 0
 11360               	.LVL970:
 11361 3fe6 EF92      		push r14
 11362               	.LCFI296:
 11363 3fe8 FF92      		push r15
 11364               	.LCFI297:
 11365 3fea 0F93      		push r16
 11366               	.LCFI298:
 11367 3fec 1F93      		push r17
 11368               	.LCFI299:
 11369 3fee CF93      		push r28
 11370               	.LCFI300:
 11371 3ff0 DF93      		push r29
 11372               	.LCFI301:
 11373 3ff2 00D0      		rcall .
 11374 3ff4 00D0      		rcall .
 11375               	.LCFI302:
 11376 3ff6 CDB7      		in r28,__SP_L__
 11377 3ff8 DEB7      		in r29,__SP_H__
 11378               	.LCFI303:
 11379               	/* prologue: function */
 11380               	/* frame size = 4 */
 11381               	/* stack size = 10 */
 11382               	.L__stack_usage = 10
 11383 3ffa 7C01      		movw r14,r24
 11384               	.LVL971:
 650:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 11385               		.loc 1 650 0
 11386 3ffc 0E94 0000 		call getSwitchNumber
 11387               	.LVL972:
 11388 4000 8C01      		movw r16,r24
 11389               	.LVL973:
 651:switcherator.c ****     if ((switchNumber >= NUM_SWITCHES) || (switchStuff[switchNumber] == 255)) {
 11390               		.loc 1 651 0
 11391 4002 8031      		cpi r24,16
 11392 4004 9105      		cpc r25,__zero_reg__
 11393 4006 04F4      		brge .L796
 651:switcherator.c ****     if ((switchNumber >= NUM_SWITCHES) || (switchStuff[switchNumber] == 255)) {
 11394               		.loc 1 651 0 is_stmt 0 discriminator 1
 11395 4008 FC01      		movw r30,r24
 11396 400a E050      		subi r30,lo8(-(switchStuff))
 11397 400c F040      		sbci r31,hi8(-(switchStuff))
 11398 400e 2081      		ld r18,Z
 11399 4010 2F3F      		cpi r18,lo8(-1)
 11400 4012 01F4      		brne .L797
 11401               	.L796:
 652:switcherator.c ****         fail(1);
 11402               		.loc 1 652 0 is_stmt 1
 11403 4014 81E0      		ldi r24,lo8(1)
 11404 4016 90E0      		ldi r25,0
 11405 4018 00C0      		rjmp .L813
 11406               	.L797:
 656:switcherator.c ****     tempHugeString[0] = commandReceived[5];
 11407               		.loc 1 656 0
 11408 401a F701      		movw r30,r14
 11409 401c 8581      		ldd r24,Z+5
 11410 401e 8093 0000 		sts tempHugeString,r24
 657:switcherator.c ****     tempHugeString[1] = commandReceived[6];
 11411               		.loc 1 657 0
 11412 4022 8681      		ldd r24,Z+6
 11413 4024 8093 0000 		sts tempHugeString+1,r24
 658:switcherator.c ****     tempHugeString[2] = commandReceived[7];
 11414               		.loc 1 658 0
 11415 4028 8781      		ldd r24,Z+7
 11416 402a 8093 0000 		sts tempHugeString+2,r24
 659:switcherator.c ****     tempHugeString[3] = commandReceived[8];
 11417               		.loc 1 659 0
 11418 402e 8085      		ldd r24,Z+8
 11419 4030 8093 0000 		sts tempHugeString+3,r24
 660:switcherator.c ****     tempHugeString[4] = commandReceived[9];
 11420               		.loc 1 660 0
 11421 4034 8185      		ldd r24,Z+9
 11422 4036 8093 0000 		sts tempHugeString+4,r24
 661:switcherator.c ****     tempHugeString[5] = commandReceived[10];
 11423               		.loc 1 661 0
 11424 403a 8285      		ldd r24,Z+10
 11425 403c 8093 0000 		sts tempHugeString+5,r24
 662:switcherator.c ****     duration = atol(tempHugeString);
 11426               		.loc 1 662 0
 11427 4040 80E0      		ldi r24,lo8(tempHugeString)
 11428 4042 90E0      		ldi r25,hi8(tempHugeString)
 11429 4044 2C83      		std Y+4,r18
 11430 4046 0E94 0000 		call atol
 11431               	.LVL974:
 11432 404a 462F      		mov r20,r22
 11433 404c 572F      		mov r21,r23
 11434 404e BC01      		movw r22,r24
 11435               	.LVL975:
 663:switcherator.c ****     if (duration == 0) {
 11436               		.loc 1 663 0
 11437 4050 2C81      		ldd r18,Y+4
 11438 4052 4115      		cp r20,__zero_reg__
 11439 4054 5105      		cpc r21,__zero_reg__
 11440 4056 6105      		cpc r22,__zero_reg__
 11441 4058 7105      		cpc r23,__zero_reg__
 11442 405a 01F4      		brne .L799
 664:switcherator.c ****         fail(5);
 11443               		.loc 1 664 0
 11444 405c 85E0      		ldi r24,lo8(5)
 11445 405e 90E0      		ldi r25,0
 11446               	.LVL976:
 11447               	.L813:
 11448 4060 0E94 0000 		call fail
 11449               	.LVL977:
 665:switcherator.c ****         return;
 11450               		.loc 1 665 0
 11451 4064 00C0      		rjmp .L795
 11452               	.LVL978:
 11453               	.L799:
 668:switcherator.c ****     if ((weeklySeconds + duration) > switchStatus[switchNumber])
 11454               		.loc 1 668 0
 11455 4066 8091 0000 		lds r24,weeklySeconds
 11456 406a 9091 0000 		lds r25,weeklySeconds+1
 11457 406e A091 0000 		lds r26,weeklySeconds+2
 11458 4072 B091 0000 		lds r27,weeklySeconds+3
 11459 4076 840F      		add r24,r20
 11460 4078 951F      		adc r25,r21
 11461 407a A61F      		adc r26,r22
 11462 407c B71F      		adc r27,r23
 11463 407e F801      		movw r30,r16
 11464 4080 EE0F      		lsl r30
 11465 4082 FF1F      		rol r31
 11466 4084 EE0F      		lsl r30
 11467 4086 FF1F      		rol r31
 11468 4088 E050      		subi r30,lo8(-(switchStatus))
 11469 408a F040      		sbci r31,hi8(-(switchStatus))
 11470 408c 4081      		ld r20,Z
 11471 408e 5181      		ldd r21,Z+1
 11472 4090 6281      		ldd r22,Z+2
 11473 4092 7381      		ldd r23,Z+3
 11474               	.LVL979:
 11475 4094 4817      		cp r20,r24
 11476 4096 5907      		cpc r21,r25
 11477 4098 6A07      		cpc r22,r26
 11478 409a 7B07      		cpc r23,r27
 11479 409c 00F4      		brsh .L800
 669:switcherator.c ****         switchStatus[switchNumber] = (weeklySeconds + duration);
 11480               		.loc 1 669 0
 11481 409e 8083      		st Z,r24
 11482 40a0 9183      		std Z+1,r25
 11483 40a2 A283      		std Z+2,r26
 11484 40a4 B383      		std Z+3,r27
 11485               	.L800:
 672:switcherator.c ****     if (switchStuff[switchNumber] >= 200 && switchStuff[switchNumber] <= 220) {
 11486               		.loc 1 672 0
 11487 40a6 822F      		mov r24,r18
 11488 40a8 885C      		subi r24,lo8(-(56))
 11489 40aa 8531      		cpi r24,lo8(21)
 11490 40ac 00F0      		brlo .+2
 11491 40ae 00C0      		rjmp .L801
 674:switcherator.c ****         if (switchStuff[switchNumber] == 200) {
 11492               		.loc 1 674 0
 11493 40b0 283C      		cpi r18,lo8(-56)
 11494 40b2 01F4      		brne .L802
 677:switcherator.c ****             green = pwmValues[1];
 11495               		.loc 1 677 0
 11496 40b4 8091 0000 		lds r24,pwmValues+1
 678:switcherator.c ****             blue = pwmValues[2];
 11497               		.loc 1 678 0
 11498 40b8 E091 0000 		lds r30,pwmValues+2
 679:switcherator.c ****             red = red * bright / 16;
 11499               		.loc 1 679 0
 11500 40bc 6091 0000 		lds r22,bright
 11501 40c0 7091 0000 		lds r23,bright+1
 676:switcherator.c ****             red = pwmValues[0];
 11502               		.loc 1 676 0
 11503 40c4 9091 0000 		lds r25,pwmValues
 679:switcherator.c ****             red = red * bright / 16;
 11504               		.loc 1 679 0
 11505 40c8 969F      		mul r25,r22
 11506 40ca A001      		movw r20,r0
 11507 40cc 979F      		mul r25,r23
 11508 40ce 500D      		add r21,r0
 11509 40d0 1124      		clr __zero_reg__
 11510 40d2 F4E0      		ldi r31,4
 11511               		1:
 11512 40d4 5695      		lsr r21
 11513 40d6 4795      		ror r20
 11514 40d8 FA95      		dec r31
 11515 40da 01F4      		brne 1b
 11516 40dc 5093 0000 		sts red+1,r21
 11517 40e0 4093 0000 		sts red,r20
 680:switcherator.c ****             green = green * bright / 16;
 11518               		.loc 1 680 0
 11519 40e4 869F      		mul r24,r22
 11520 40e6 9001      		movw r18,r0
 11521 40e8 879F      		mul r24,r23
 11522 40ea 300D      		add r19,r0
 11523 40ec 1124      		clr __zero_reg__
 11524 40ee A4E0      		ldi r26,4
 11525               		1:
 11526 40f0 3695      		lsr r19
 11527 40f2 2795      		ror r18
 11528 40f4 AA95      		dec r26
 11529 40f6 01F4      		brne 1b
 11530 40f8 3093 0000 		sts green+1,r19
 11531 40fc 2093 0000 		sts green,r18
 681:switcherator.c ****             blue = blue * bright / 16;
 11532               		.loc 1 681 0
 11533 4100 E69F      		mul r30,r22
 11534 4102 C001      		movw r24,r0
 11535 4104 E79F      		mul r30,r23
 11536 4106 900D      		add r25,r0
 11537 4108 1124      		clr __zero_reg__
 11538 410a B4E0      		ldi r27,4
 11539               		1:
 11540 410c 9695      		lsr r25
 11541 410e 8795      		ror r24
 11542 4110 BA95      		dec r27
 11543 4112 01F4      		brne 1b
 11544 4114 9093 0000 		sts blue+1,r25
 11545 4118 8093 0000 		sts blue,r24
 682:switcherator.c ****             Red = red;
 11546               		.loc 1 682 0
 11547 411c 4093 B400 		sts 180,r20
 683:switcherator.c ****             Green = green;
 11548               		.loc 1 683 0
 11549 4120 28BD      		out 0x28,r18
 684:switcherator.c ****             Blue = blue;
 11550               		.loc 1 684 0
 11551 4122 87BD      		out 0x27,r24
 11552 4124 00C0      		rjmp .L803
 11553               	.L802:
 685:switcherator.c ****         } else if (switchStuff[switchNumber] == 202) {
 11554               		.loc 1 685 0
 11555 4126 2A3C      		cpi r18,lo8(-54)
 11556 4128 01F4      		brne .L804
 686:switcherator.c ****             runColorChanges = 1;
 11557               		.loc 1 686 0
 11558 412a 81E0      		ldi r24,lo8(1)
 11559 412c 8093 0000 		sts runColorChanges,r24
 11560 4130 00C0      		rjmp .L803
 11561               	.L804:
 687:switcherator.c ****         } else if (switchStuff[switchNumber] == 212) {
 11562               		.loc 1 687 0
 11563 4132 243D      		cpi r18,lo8(-44)
 11564 4134 01F4      		brne .L805
 688:switcherator.c ****             bright = switchBright[switchNumber];
 11565               		.loc 1 688 0
 11566 4136 F801      		movw r30,r16
 11567 4138 E050      		subi r30,lo8(-(switchBright))
 11568 413a F040      		sbci r31,hi8(-(switchBright))
 11569 413c 8081      		ld r24,Z
 11570 413e 8093 0000 		sts bright,r24
 11571 4142 1092 0000 		sts bright+1,__zero_reg__
 11572 4146 00C0      		rjmp .L803
 11573               	.L805:
 690:switcherator.c ****             runHue = 1;
 11574               		.loc 1 690 0
 11575 4148 81E0      		ldi r24,lo8(1)
 11576 414a 8093 0000 		sts runHue,r24
 11577 414e 00C0      		rjmp .L803
 11578               	.L801:
 11579               	.LVL980:
 11580               	.LBB29:
 701:switcherator.c ****         getPort(switchNumber, port, pin, direction);
 11581               		.loc 1 701 0
 11582 4150 9E01      		movw r18,r28
 11583 4152 2F5F      		subi r18,-1
 11584 4154 3F4F      		sbci r19,-1
 11585 4156 AE01      		movw r20,r28
 11586 4158 4E5F      		subi r20,-2
 11587 415a 5F4F      		sbci r21,-1
 11588 415c BE01      		movw r22,r28
 11589 415e 6D5F      		subi r22,-3
 11590 4160 7F4F      		sbci r23,-1
 11591 4162 C801      		movw r24,r16
 11592 4164 0E94 0000 		call getPort
 11593               	.LVL981:
 703:switcherator.c ****         realPin = pin[0];
 11594               		.loc 1 703 0
 11595 4168 3A81      		ldd r19,Y+2
 11596               	.LVL982:
 704:switcherator.c ****         if (port[0] == 'B')
 11597               		.loc 1 704 0
 11598 416a 8B81      		ldd r24,Y+3
 11599 416c 8234      		cpi r24,lo8(66)
 11600 416e 01F0      		breq .L809
 711:switcherator.c ****         else if (port[0] == 'C')
 11601               		.loc 1 711 0
 11602 4170 8334      		cpi r24,lo8(67)
 11603 4172 01F0      		breq .L810
 715:switcherator.c ****         else if (port[0] == 'D')
 11604               		.loc 1 715 0
 11605 4174 8434      		cpi r24,lo8(68)
 11606 4176 01F0      		breq .L811
 700:switcherator.c ****         volatile unsigned char *thisPort = 0;
 11607               		.loc 1 700 0
 11608 4178 E0E0      		ldi r30,0
 11609 417a F0E0      		ldi r31,0
 11610 417c 00C0      		rjmp .L806
 11611               	.L809:
 705:switcherator.c ****             thisPort = &PORTB;
 11612               		.loc 1 705 0
 11613 417e E5E2      		ldi r30,lo8(37)
 11614 4180 F0E0      		ldi r31,0
 11615 4182 00C0      		rjmp .L806
 11616               	.L810:
 712:switcherator.c ****             thisPort = &PORTC;
 11617               		.loc 1 712 0
 11618 4184 E8E2      		ldi r30,lo8(40)
 11619 4186 F0E0      		ldi r31,0
 11620 4188 00C0      		rjmp .L806
 11621               	.L811:
 716:switcherator.c ****             thisPort = &PORTD;
 11622               		.loc 1 716 0
 11623 418a EBE2      		ldi r30,lo8(43)
 11624 418c F0E0      		ldi r31,0
 11625               	.L806:
 11626               	.LVL983:
 740:switcherator.c ****         if (direction[0] == 0) {
 11627               		.loc 1 740 0
 11628 418e 8981      		ldd r24,Y+1
 741:switcherator.c ****             *thisPort &= ~(1 << realPin);
 11629               		.loc 1 741 0
 11630 4190 2081      		ld r18,Z
 740:switcherator.c ****         if (direction[0] == 0) {
 11631               		.loc 1 740 0
 11632 4192 8111      		cpse r24,__zero_reg__
 11633 4194 00C0      		rjmp .L807
 741:switcherator.c ****             *thisPort &= ~(1 << realPin);
 11634               		.loc 1 741 0
 11635 4196 81E0      		ldi r24,lo8(1)
 11636 4198 90E0      		ldi r25,0
 11637 419a 032E      		mov r0,r19
 11638 419c 00C0      		rjmp 2f
 11639               		1:
 11640 419e 880F      		lsl r24
 11641               		2:
 11642 41a0 0A94      		dec r0
 11643 41a2 02F4      		brpl 1b
 11644 41a4 8095      		com r24
 11645 41a6 2823      		and r18,r24
 11646 41a8 00C0      		rjmp .L812
 11647               	.L807:
 743:switcherator.c ****             *thisPort |= (1 << realPin);
 11648               		.loc 1 743 0
 11649 41aa 81E0      		ldi r24,lo8(1)
 11650 41ac 90E0      		ldi r25,0
 11651 41ae 00C0      		rjmp 2f
 11652               		1:
 11653 41b0 880F      		lsl r24
 11654               		2:
 11655 41b2 3A95      		dec r19
 11656 41b4 02F4      		brpl 1b
 11657 41b6 282B      		or r18,r24
 11658               	.L812:
 11659 41b8 2083      		st Z,r18
 11660               	.LVL984:
 11661               	.L803:
 11662               	.LBE29:
 746:switcherator.c ****     ok();
 11663               		.loc 1 746 0
 11664 41ba 0E94 0000 		call ok
 11665               	.LVL985:
 11666               	.L795:
 11667               	/* epilogue start */
 747:switcherator.c **** }
 11668               		.loc 1 747 0
 11669 41be 0F90      		pop __tmp_reg__
 11670 41c0 0F90      		pop __tmp_reg__
 11671 41c2 0F90      		pop __tmp_reg__
 11672 41c4 0F90      		pop __tmp_reg__
 11673 41c6 DF91      		pop r29
 11674 41c8 CF91      		pop r28
 11675 41ca 1F91      		pop r17
 11676 41cc 0F91      		pop r16
 11677               	.LVL986:
 11678 41ce FF90      		pop r15
 11679 41d0 EF90      		pop r14
 11680               	.LVL987:
 11681 41d2 0895      		ret
 11682               	.LFE17:
 11684               	.global	setNewSwitch
 11686               	setNewSwitch:
 11687               	.LFB13:
 416:switcherator.c **** void setNewSwitch(char * commandReceived) {
 11688               		.loc 1 416 0
 11689               	.LVL988:
 11690 41d4 AF92      		push r10
 11691               	.LCFI304:
 11692 41d6 BF92      		push r11
 11693               	.LCFI305:
 11694 41d8 CF92      		push r12
 11695               	.LCFI306:
 11696 41da DF92      		push r13
 11697               	.LCFI307:
 11698 41dc EF92      		push r14
 11699               	.LCFI308:
 11700 41de FF92      		push r15
 11701               	.LCFI309:
 11702 41e0 0F93      		push r16
 11703               	.LCFI310:
 11704 41e2 1F93      		push r17
 11705               	.LCFI311:
 11706 41e4 CF93      		push r28
 11707               	.LCFI312:
 11708 41e6 DF93      		push r29
 11709               	.LCFI313:
 11710 41e8 1F92      		push __zero_reg__
 11711               	.LCFI314:
 11712 41ea CDB7      		in r28,__SP_L__
 11713 41ec DEB7      		in r29,__SP_H__
 11714               	.LCFI315:
 11715               	/* prologue: function */
 11716               	/* frame size = 1 */
 11717               	/* stack size = 11 */
 11718               	.L__stack_usage = 11
 11719 41ee 6C01      		movw r12,r24
 11720               	.LVL989:
 426:switcherator.c ****     tempIntString[0] = '0';
 11721               		.loc 1 426 0
 11722 41f0 80E3      		ldi r24,lo8(48)
 11723               	.LVL990:
 11724 41f2 8093 0000 		sts tempIntString,r24
 427:switcherator.c ****     tempIntString[1] = commandReceived[6];
 11725               		.loc 1 427 0
 11726 41f6 D601      		movw r26,r12
 11727 41f8 1696      		adiw r26,6
 11728 41fa 8C91      		ld r24,X
 11729 41fc 8093 0000 		sts tempIntString+1,r24
 428:switcherator.c ****     pin = atoi(tempIntString);
 11730               		.loc 1 428 0
 11731 4200 80E0      		ldi r24,lo8(tempIntString)
 11732 4202 90E0      		ldi r25,hi8(tempIntString)
 11733 4204 0E94 0000 		call atoi
 11734               	.LVL991:
 11735 4208 F82E      		mov r15,r24
 11736               	.LVL992:
 430:switcherator.c ****     tempIntString[1] = commandReceived[7];
 11737               		.loc 1 430 0
 11738 420a F601      		movw r30,r12
 11739 420c 8781      		ldd r24,Z+7
 11740 420e 8093 0000 		sts tempIntString+1,r24
 431:switcherator.c ****     direction = atoi(tempIntString);
 11741               		.loc 1 431 0
 11742 4212 80E0      		ldi r24,lo8(tempIntString)
 11743 4214 90E0      		ldi r25,hi8(tempIntString)
 11744 4216 0E94 0000 		call atoi
 11745               	.LVL993:
 11746 421a E82E      		mov r14,r24
 11747               	.LVL994:
 432:switcherator.c ****     port = commandReceived[5];
 11748               		.loc 1 432 0
 11749 421c D601      		movw r26,r12
 11750 421e 1596      		adiw r26,5
 11751 4220 2C91      		ld r18,X
 11752               	.LVL995:
 433:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 11753               		.loc 1 433 0
 11754 4222 C601      		movw r24,r12
 11755 4224 2983      		std Y+1,r18
 11756 4226 0E94 0000 		call getSwitchNumber
 11757               	.LVL996:
 11758 422a 8C01      		movw r16,r24
 11759               	.LVL997:
 435:switcherator.c ****     clearTheSwitch(switchNumber);
 11760               		.loc 1 435 0
 11761 422c 0E94 0000 		call clearTheSwitch
 11762               	.LVL998:
 437:switcherator.c ****     if (port == 'B' || port == 'b') {
 11763               		.loc 1 437 0
 11764 4230 2981      		ldd r18,Y+1
 11765 4232 2234      		cpi r18,lo8(66)
 11766 4234 01F4      		brne .+2
 11767 4236 00C0      		rjmp .L825
 437:switcherator.c ****     if (port == 'B' || port == 'b') {
 11768               		.loc 1 437 0 is_stmt 0 discriminator 1
 11769 4238 2236      		cpi r18,lo8(98)
 11770 423a 01F4      		brne .+2
 11771 423c 00C0      		rjmp .L825
 448:switcherator.c ****     } else if (port == 'C' || port == 'c') {
 11772               		.loc 1 448 0 is_stmt 1
 11773 423e 2334      		cpi r18,lo8(67)
 11774 4240 01F4      		brne .+2
 11775 4242 00C0      		rjmp .L827
 448:switcherator.c ****     } else if (port == 'C' || port == 'c') {
 11776               		.loc 1 448 0 is_stmt 0 discriminator 1
 11777 4244 2336      		cpi r18,lo8(99)
 11778 4246 01F4      		brne .+2
 11779 4248 00C0      		rjmp .L827
 454:switcherator.c ****     } else if (port == 'D' || port == 'd') {
 11780               		.loc 1 454 0 is_stmt 1
 11781 424a 2434      		cpi r18,lo8(68)
 11782 424c 01F4      		brne .+2
 11783 424e 00C0      		rjmp .L829
 454:switcherator.c ****     } else if (port == 'D' || port == 'd') {
 11784               		.loc 1 454 0 is_stmt 0 discriminator 1
 11785 4250 2436      		cpi r18,lo8(100)
 11786 4252 01F0      		breq .+2
 11787 4254 00C0      		rjmp .L839
 11788 4256 00C0      		rjmp .L829
 11789               	.LVL999:
 11790               	.L840:
 495:switcherator.c ****     } else if ((switchNumber >= NUM_SWITCHES) ||
 11791               		.loc 1 495 0 is_stmt 1 discriminator 1
 11792 4258 0115      		cp r16,__zero_reg__
 11793 425a 1105      		cpc r17,__zero_reg__
 11794 425c 01F4      		brne .L817
 496:switcherator.c ****             ((switchNumber == 0) && (commandReceived[3] != '0') && (commandReceived[4] != 0))) {
 11795               		.loc 1 496 0
 11796 425e D601      		movw r26,r12
 11797 4260 1396      		adiw r26,3
 11798 4262 8C91      		ld r24,X
 11799 4264 1397      		sbiw r26,3
 11800 4266 8033      		cpi r24,lo8(48)
 11801 4268 01F0      		breq .L817
 496:switcherator.c ****             ((switchNumber == 0) && (commandReceived[3] != '0') && (commandReceived[4] != 0))) {
 11802               		.loc 1 496 0 is_stmt 0 discriminator 1
 11803 426a 1496      		adiw r26,4
 11804 426c 8C91      		ld r24,X
 11805 426e 8823      		tst r24
 11806 4270 01F0      		breq .L817
 11807               	.L822:
 497:switcherator.c ****         fail(1);
 11808               		.loc 1 497 0 is_stmt 1
 11809 4272 81E0      		ldi r24,lo8(1)
 11810 4274 90E0      		ldi r25,0
 11811 4276 00C0      		rjmp .L841
 11812               	.L817:
 428:switcherator.c ****     pin = atoi(tempIntString);
 11813               		.loc 1 428 0
 11814 4278 4F2D      		mov r20,r15
 498:switcherator.c ****     } else if ((pin > 7) || ((pin == 0) && (commandReceived[6] != '0'))) {
 11815               		.loc 1 498 0
 11816 427a 4830      		cpi r20,lo8(8)
 11817 427c 00F4      		brsh .L818
 498:switcherator.c ****     } else if ((pin > 7) || ((pin == 0) && (commandReceived[6] != '0'))) {
 11818               		.loc 1 498 0 is_stmt 0 discriminator 1
 11819 427e F110      		cpse r15,__zero_reg__
 11820 4280 00C0      		rjmp .L819
 11821 4282 D601      		movw r26,r12
 11822 4284 1696      		adiw r26,6
 11823 4286 8C91      		ld r24,X
 11824 4288 8033      		cpi r24,lo8(48)
 11825 428a 01F0      		breq .L819
 11826               	.L818:
 499:switcherator.c ****         fail(4);
 11827               		.loc 1 499 0 is_stmt 1
 11828 428c 84E0      		ldi r24,lo8(4)
 11829 428e 90E0      		ldi r25,0
 11830 4290 00C0      		rjmp .L841
 11831               	.L819:
 502:switcherator.c ****         *realDDR |= (1 << originalPin);
 11832               		.loc 1 502 0
 11833 4292 D501      		movw r26,r10
 11834 4294 5C91      		ld r21,X
 11835 4296 21E0      		ldi r18,lo8(1)
 11836 4298 30E0      		ldi r19,0
 11837 429a 0F2C      		mov r0,r15
 11838 429c 00C0      		rjmp 2f
 11839               		1:
 11840 429e 220F      		lsl r18
 11841               		2:
 11842 42a0 0A94      		dec r0
 11843 42a2 02F4      		brpl 1b
 11844 42a4 522B      		or r21,r18
 11845 42a6 5C93      		st X,r21
 504:switcherator.c ****         pinMultiplied = pin * 2;
 11846               		.loc 1 504 0
 11847 42a8 440F      		lsl r20
 11848               	.LVL1000:
 507:switcherator.c ****         switchStuff[switchNumber] = pin;
 11849               		.loc 1 507 0
 11850 42aa D801      		movw r26,r16
 11851 42ac A050      		subi r26,lo8(-(switchStuff))
 11852 42ae B040      		sbci r27,hi8(-(switchStuff))
 506:switcherator.c ****         pin = pinMultiplied + pinSubtractee;
 11853               		.loc 1 506 0
 11854 42b0 490F      		add r20,r25
 11855               	.LVL1001:
 507:switcherator.c ****         switchStuff[switchNumber] = pin;
 11856               		.loc 1 507 0
 11857 42b2 4C93      		st X,r20
 511:switcherator.c ****             *realPort |= (1 << originalPin);
 11858               		.loc 1 511 0
 11859 42b4 8081      		ld r24,Z
 509:switcherator.c ****         if (direction == 0) {
 11860               		.loc 1 509 0
 11861 42b6 E110      		cpse r14,__zero_reg__
 11862 42b8 00C0      		rjmp .L820
 511:switcherator.c ****             *realPort |= (1 << originalPin);
 11863               		.loc 1 511 0
 11864 42ba 822B      		or r24,r18
 11865 42bc 8083      		st Z,r24
 11866 42be 00C0      		rjmp .L821
 11867               	.L820:
 513:switcherator.c ****             *realPort &= ~(1 << originalPin);
 11868               		.loc 1 513 0
 11869 42c0 2095      		com r18
 11870 42c2 8223      		and r24,r18
 11871 42c4 8083      		st Z,r24
 514:switcherator.c ****             switchStuff[switchNumber]++;
 11872               		.loc 1 514 0
 11873 42c6 8C91      		ld r24,X
 11874 42c8 8F5F      		subi r24,lo8(-(1))
 11875 42ca 8C93      		st X,r24
 11876               	.L821:
 11877               	/* epilogue start */
 518:switcherator.c **** }
 11878               		.loc 1 518 0
 11879 42cc 0F90      		pop __tmp_reg__
 11880 42ce DF91      		pop r29
 11881 42d0 CF91      		pop r28
 11882 42d2 1F91      		pop r17
 11883 42d4 0F91      		pop r16
 11884               	.LVL1002:
 11885 42d6 FF90      		pop r15
 11886               	.LVL1003:
 11887 42d8 EF90      		pop r14
 11888               	.LVL1004:
 11889 42da DF90      		pop r13
 11890 42dc CF90      		pop r12
 11891               	.LVL1005:
 11892 42de BF90      		pop r11
 11893 42e0 AF90      		pop r10
 11894               	.LVL1006:
 516:switcherator.c ****         ok();
 11895               		.loc 1 516 0
 11896 42e2 0C94 0000 		jmp ok
 11897               	.LVL1007:
 11898               	.L839:
 494:switcherator.c ****         fail(2);
 11899               		.loc 1 494 0
 11900 42e6 82E0      		ldi r24,lo8(2)
 11901 42e8 90E0      		ldi r25,0
 11902               	.LVL1008:
 11903               	.L841:
 11904               	/* epilogue start */
 518:switcherator.c **** }
 11905               		.loc 1 518 0
 11906 42ea 0F90      		pop __tmp_reg__
 11907 42ec DF91      		pop r29
 11908 42ee CF91      		pop r28
 11909 42f0 1F91      		pop r17
 11910 42f2 0F91      		pop r16
 11911               	.LVL1009:
 11912 42f4 FF90      		pop r15
 11913               	.LVL1010:
 11914 42f6 EF90      		pop r14
 11915               	.LVL1011:
 11916 42f8 DF90      		pop r13
 11917 42fa CF90      		pop r12
 11918               	.LVL1012:
 11919 42fc BF90      		pop r11
 11920 42fe AF90      		pop r10
 494:switcherator.c ****         fail(2);
 11921               		.loc 1 494 0
 11922 4300 0C94 0000 		jmp fail
 11923               	.LVL1013:
 11924               	.L825:
 439:switcherator.c ****         realDDR = &DDRB;
 11925               		.loc 1 439 0
 11926 4304 64E2      		ldi r22,lo8(36)
 11927 4306 A62E      		mov r10,r22
 11928 4308 B12C      		mov r11,__zero_reg__
 438:switcherator.c ****         realPort = &PORTB;
 11929               		.loc 1 438 0
 11930 430a E5E2      		ldi r30,lo8(37)
 11931 430c F0E0      		ldi r31,0
 440:switcherator.c ****         pinSubtractee = 16;
 11932               		.loc 1 440 0
 11933 430e 90E1      		ldi r25,lo8(16)
 11934 4310 00C0      		rjmp .L815
 11935               	.L827:
 450:switcherator.c ****         realDDR = &DDRC;
 11936               		.loc 1 450 0
 11937 4312 57E2      		ldi r21,lo8(39)
 11938 4314 A52E      		mov r10,r21
 11939 4316 B12C      		mov r11,__zero_reg__
 449:switcherator.c ****         realPort = &PORTC;
 11940               		.loc 1 449 0
 11941 4318 E8E2      		ldi r30,lo8(40)
 11942 431a F0E0      		ldi r31,0
 451:switcherator.c ****         pinSubtractee = 32;
 11943               		.loc 1 451 0
 11944 431c 90E2      		ldi r25,lo8(32)
 11945 431e 00C0      		rjmp .L815
 11946               	.L829:
 456:switcherator.c ****         realDDR = &DDRD;
 11947               		.loc 1 456 0
 11948 4320 4AE2      		ldi r20,lo8(42)
 11949 4322 A42E      		mov r10,r20
 11950 4324 B12C      		mov r11,__zero_reg__
 455:switcherator.c ****         realPort = &PORTD;
 11951               		.loc 1 455 0
 11952 4326 EBE2      		ldi r30,lo8(43)
 11953 4328 F0E0      		ldi r31,0
 457:switcherator.c ****         pinSubtractee = 48;
 11954               		.loc 1 457 0
 11955 432a 90E3      		ldi r25,lo8(48)
 11956               	.L815:
 11957               	.LVL1014:
 495:switcherator.c ****     } else if ((switchNumber >= NUM_SWITCHES) ||
 11958               		.loc 1 495 0
 11959 432c 0031      		cpi r16,16
 11960 432e 1105      		cpc r17,__zero_reg__
 11961 4330 04F4      		brge .+2
 11962 4332 00C0      		rjmp .L840
 11963 4334 00C0      		rjmp .L822
 11964               	.LFE13:
 11966               		.section	.rodata.str1.1
 11967               	.LC70:
 11968 0159 5374 6172 		.string	"Start:"
 11968      743A 00
 11969               	.LC71:
 11970 0160 5374 6F70 		.string	"Stop:"
 11970      3A00 
 11971               		.text
 11972               	.global	setTimeLimits
 11974               	setTimeLimits:
 11975               	.LFB59:
2514:switcherator.c **** void setTimeLimits(char * commandReceived) {
 11976               		.loc 1 2514 0
 11977               	.LVL1015:
 11978 4336 2F92      		push r2
 11979               	.LCFI316:
 11980 4338 3F92      		push r3
 11981               	.LCFI317:
 11982 433a 4F92      		push r4
 11983               	.LCFI318:
 11984 433c 5F92      		push r5
 11985               	.LCFI319:
 11986 433e 6F92      		push r6
 11987               	.LCFI320:
 11988 4340 7F92      		push r7
 11989               	.LCFI321:
 11990 4342 8F92      		push r8
 11991               	.LCFI322:
 11992 4344 9F92      		push r9
 11993               	.LCFI323:
 11994 4346 AF92      		push r10
 11995               	.LCFI324:
 11996 4348 BF92      		push r11
 11997               	.LCFI325:
 11998 434a CF92      		push r12
 11999               	.LCFI326:
 12000 434c DF92      		push r13
 12001               	.LCFI327:
 12002 434e EF92      		push r14
 12003               	.LCFI328:
 12004 4350 FF92      		push r15
 12005               	.LCFI329:
 12006 4352 0F93      		push r16
 12007               	.LCFI330:
 12008 4354 1F93      		push r17
 12009               	.LCFI331:
 12010 4356 CF93      		push r28
 12011               	.LCFI332:
 12012 4358 DF93      		push r29
 12013               	.LCFI333:
 12014 435a CDB7      		in r28,__SP_L__
 12015 435c DEB7      		in r29,__SP_H__
 12016               	.LCFI334:
 12017 435e 2C97      		sbiw r28,12
 12018               	.LCFI335:
 12019 4360 0FB6      		in __tmp_reg__,__SREG__
 12020 4362 F894      		cli
 12021 4364 DEBF      		out __SP_H__,r29
 12022 4366 0FBE      		out __SREG__,__tmp_reg__
 12023 4368 CDBF      		out __SP_L__,r28
 12024               	/* prologue: function */
 12025               	/* frame size = 12 */
 12026               	/* stack size = 30 */
 12027               	.L__stack_usage = 30
 12028 436a 6C01      		movw r12,r24
2515:switcherator.c ****     char tempReallyLongString[] = "0000000";
 12029               		.loc 1 2515 0
 12030 436c 88E0      		ldi r24,lo8(8)
 12031               	.LVL1016:
 12032 436e E0E0      		ldi r30,lo8(.LC69)
 12033 4370 F0E0      		ldi r31,hi8(.LC69)
 12034 4372 DE01      		movw r26,r28
 12035 4374 1196      		adiw r26,1
 12036               		0:
 12037 4376 0190      		ld r0,Z+
 12038 4378 0D92      		st X+,r0
 12039 437a 8A95      		dec r24
 12040 437c 01F4      		brne 0b
 12041               	.LVL1017:
2521:switcherator.c ****     statusMsg[0] = 0;
 12042               		.loc 1 2521 0
 12043 437e 1092 0000 		sts statusMsg,__zero_reg__
2523:switcherator.c ****     tempIntString[0] = commandReceived[3];
 12044               		.loc 1 2523 0
 12045 4382 F601      		movw r30,r12
 12046 4384 8381      		ldd r24,Z+3
 12047 4386 8093 0000 		sts tempIntString,r24
2524:switcherator.c ****     tempIntString[1] = commandReceived[4];
 12048               		.loc 1 2524 0
 12049 438a 8481      		ldd r24,Z+4
 12050 438c 8093 0000 		sts tempIntString+1,r24
2525:switcherator.c ****     programNumber = atoi(tempIntString);
 12051               		.loc 1 2525 0
 12052 4390 80E0      		ldi r24,lo8(tempIntString)
 12053 4392 90E0      		ldi r25,hi8(tempIntString)
 12054 4394 0E94 0000 		call atoi
 12055               	.LVL1018:
 12056 4398 8C01      		movw r16,r24
 12057               	.LVL1019:
2526:switcherator.c ****     if (programNumber > NUM_LIMITS) {
 12058               		.loc 1 2526 0
 12059 439a 8530      		cpi r24,5
 12060 439c 9105      		cpc r25,__zero_reg__
 12061 439e 04F0      		brlt .L843
2527:switcherator.c ****         fail(0x10);
 12062               		.loc 1 2527 0
 12063 43a0 80E1      		ldi r24,lo8(16)
 12064 43a2 90E0      		ldi r25,0
 12065 43a4 00C0      		rjmp .L854
 12066               	.L843:
2530:switcherator.c ****     if (commandReceived[5] == 'x' || commandReceived[5] == 'x') {
 12067               		.loc 1 2530 0
 12068 43a6 F601      		movw r30,r12
 12069 43a8 8581      		ldd r24,Z+5
 12070 43aa 8837      		cpi r24,lo8(120)
 12071 43ac 01F4      		brne .L845
2531:switcherator.c ****         timeLimits[programNumber][2] = 0;
 12072               		.loc 1 2531 0
 12073 43ae 8CE0      		ldi r24,lo8(12)
 12074 43b0 809F      		mul r24,r16
 12075 43b2 F001      		movw r30,r0
 12076 43b4 819F      		mul r24,r17
 12077 43b6 F00D      		add r31,r0
 12078 43b8 1124      		clr __zero_reg__
 12079 43ba E050      		subi r30,lo8(-(timeLimits))
 12080 43bc F040      		sbci r31,hi8(-(timeLimits))
 12081 43be 1086      		std Z+8,__zero_reg__
 12082 43c0 1186      		std Z+9,__zero_reg__
 12083 43c2 1286      		std Z+10,__zero_reg__
 12084 43c4 1386      		std Z+11,__zero_reg__
 12085 43c6 00C0      		rjmp .L855
 12086               	.L845:
2535:switcherator.c ****     if (commandReceived[5] == '?') {
 12087               		.loc 1 2535 0
 12088 43c8 8F33      		cpi r24,lo8(63)
 12089 43ca 01F0      		breq .+2
 12090 43cc 00C0      		rjmp .L846
2537:switcherator.c ****         startTime = timeLimits[programNumber][0];
 12091               		.loc 1 2537 0
 12092 43ce 8CE0      		ldi r24,lo8(12)
 12093 43d0 809F      		mul r24,r16
 12094 43d2 F001      		movw r30,r0
 12095 43d4 819F      		mul r24,r17
 12096 43d6 F00D      		add r31,r0
 12097 43d8 1124      		clr __zero_reg__
 12098 43da E050      		subi r30,lo8(-(timeLimits))
 12099 43dc F040      		sbci r31,hi8(-(timeLimits))
 12100 43de 8080      		ld r8,Z
 12101 43e0 9180      		ldd r9,Z+1
 12102 43e2 A280      		ldd r10,Z+2
 12103 43e4 B380      		ldd r11,Z+3
 12104               	.LVL1020:
2539:switcherator.c ****         strcat(statusMsg, "Start:");
 12105               		.loc 1 2539 0
 12106 43e6 60E0      		ldi r22,lo8(.LC70)
 12107 43e8 70E0      		ldi r23,hi8(.LC70)
 12108 43ea 80E0      		ldi r24,lo8(statusMsg)
 12109 43ec 90E0      		ldi r25,hi8(statusMsg)
 12110 43ee 0E94 0000 		call strcat
 12111               	.LVL1021:
2540:switcherator.c ****         startHour = (startTime / 60 / 60);
 12112               		.loc 1 2540 0
 12113 43f2 C501      		movw r24,r10
 12114 43f4 B401      		movw r22,r8
 12115 43f6 20E1      		ldi r18,lo8(16)
 12116 43f8 3EE0      		ldi r19,lo8(14)
 12117 43fa 40E0      		ldi r20,0
 12118 43fc 50E0      		ldi r21,0
 12119 43fe 0E94 0000 		call __divmodsi4
 12120 4402 6901      		movw r12,r18
 12121 4404 7A01      		movw r14,r20
 12122               	.LVL1022:
2541:switcherator.c ****         returnInt(startHour, tempLongString);
 12123               		.loc 1 2541 0
 12124 4406 60E0      		ldi r22,lo8(tempLongString)
 12125 4408 70E0      		ldi r23,hi8(tempLongString)
 12126 440a C901      		movw r24,r18
 12127 440c 0E94 0000 		call returnInt
 12128               	.LVL1023:
2542:switcherator.c ****         strcat(statusMsg, tempLongString);
 12129               		.loc 1 2542 0
 12130 4410 60E0      		ldi r22,lo8(tempLongString)
 12131 4412 70E0      		ldi r23,hi8(tempLongString)
 12132 4414 80E0      		ldi r24,lo8(statusMsg)
 12133 4416 90E0      		ldi r25,hi8(statusMsg)
 12134 4418 0E94 0000 		call strcat
 12135               	.LVL1024:
2544:switcherator.c ****         strcat(statusMsg, ":");
 12136               		.loc 1 2544 0
 12137 441c 60E0      		ldi r22,lo8(.LC4)
 12138 441e 70E0      		ldi r23,hi8(.LC4)
 12139 4420 80E0      		ldi r24,lo8(statusMsg)
 12140 4422 90E0      		ldi r25,hi8(statusMsg)
 12141 4424 0E94 0000 		call strcat
 12142               	.LVL1025:
2543:switcherator.c ****         startMinute = ((startTime - (startHour * 60 * 60)) / 60);
 12143               		.loc 1 2543 0
 12144 4428 20E1      		ldi r18,lo8(16)
 12145 442a 3EE0      		ldi r19,lo8(14)
 12146 442c C29E      		mul r12,r18
 12147 442e C001      		movw r24,r0
 12148 4430 C39E      		mul r12,r19
 12149 4432 900D      		add r25,r0
 12150 4434 D29E      		mul r13,r18
 12151 4436 900D      		add r25,r0
 12152 4438 1124      		clr r1
 12153 443a A501      		movw r20,r10
 12154 443c 9401      		movw r18,r8
 12155 443e 281B      		sub r18,r24
 12156 4440 390B      		sbc r19,r25
 12157 4442 4109      		sbc r20,__zero_reg__
 12158 4444 5109      		sbc r21,__zero_reg__
 12159 4446 CA01      		movw r24,r20
 12160 4448 B901      		movw r22,r18
 12161 444a 2CE3      		ldi r18,lo8(60)
 12162 444c 30E0      		ldi r19,0
 12163 444e 40E0      		ldi r20,0
 12164 4450 50E0      		ldi r21,0
 12165 4452 0E94 0000 		call __divmodsi4
2545:switcherator.c ****         returnInt(startMinute, tempLongString);
 12166               		.loc 1 2545 0
 12167 4456 60E0      		ldi r22,lo8(tempLongString)
 12168 4458 70E0      		ldi r23,hi8(tempLongString)
 12169 445a C901      		movw r24,r18
 12170 445c 2987      		std Y+9,r18
 12171 445e 3A87      		std Y+10,r19
 12172 4460 4B87      		std Y+11,r20
 12173 4462 5C87      		std Y+12,r21
 12174 4464 0E94 0000 		call returnInt
 12175               	.LVL1026:
2546:switcherator.c ****         strcat(statusMsg, tempLongString);
 12176               		.loc 1 2546 0
 12177 4468 60E0      		ldi r22,lo8(tempLongString)
 12178 446a 70E0      		ldi r23,hi8(tempLongString)
 12179 446c 80E0      		ldi r24,lo8(statusMsg)
 12180 446e 90E0      		ldi r25,hi8(statusMsg)
 12181 4470 0E94 0000 		call strcat
 12182               	.LVL1027:
2547:switcherator.c ****         strcat(statusMsg, "Stop:");
 12183               		.loc 1 2547 0
 12184 4474 60E0      		ldi r22,lo8(.LC71)
 12185 4476 70E0      		ldi r23,hi8(.LC71)
 12186 4478 80E0      		ldi r24,lo8(statusMsg)
 12187 447a 90E0      		ldi r25,hi8(statusMsg)
 12188 447c 0E94 0000 		call strcat
 12189               	.LVL1028:
2549:switcherator.c ****         returnInt(stopHour, tempLongString);
 12190               		.loc 1 2549 0
 12191 4480 60E0      		ldi r22,lo8(tempLongString)
 12192 4482 70E0      		ldi r23,hi8(tempLongString)
 12193 4484 C601      		movw r24,r12
 12194 4486 0E94 0000 		call returnInt
 12195               	.LVL1029:
2550:switcherator.c ****         strcat(statusMsg, tempLongString);
 12196               		.loc 1 2550 0
 12197 448a 60E0      		ldi r22,lo8(tempLongString)
 12198 448c 70E0      		ldi r23,hi8(tempLongString)
 12199 448e 80E0      		ldi r24,lo8(statusMsg)
 12200 4490 90E0      		ldi r25,hi8(statusMsg)
 12201 4492 0E94 0000 		call strcat
 12202               	.LVL1030:
2552:switcherator.c ****         strcat(statusMsg, ":");
 12203               		.loc 1 2552 0
 12204 4496 60E0      		ldi r22,lo8(.LC4)
 12205 4498 70E0      		ldi r23,hi8(.LC4)
 12206 449a 80E0      		ldi r24,lo8(statusMsg)
 12207 449c 90E0      		ldi r25,hi8(statusMsg)
 12208 449e 0E94 0000 		call strcat
 12209               	.LVL1031:
2553:switcherator.c ****         returnInt(stopMinute, tempLongString);
 12210               		.loc 1 2553 0
 12211 44a2 60E0      		ldi r22,lo8(tempLongString)
 12212 44a4 70E0      		ldi r23,hi8(tempLongString)
 12213 44a6 2985      		ldd r18,Y+9
 12214 44a8 3A85      		ldd r19,Y+10
 12215 44aa C901      		movw r24,r18
 12216 44ac 0E94 0000 		call returnInt
 12217               	.LVL1032:
2554:switcherator.c ****         strcat(statusMsg, tempLongString);
 12218               		.loc 1 2554 0
 12219 44b0 60E0      		ldi r22,lo8(tempLongString)
 12220 44b2 70E0      		ldi r23,hi8(tempLongString)
 12221 44b4 80E0      		ldi r24,lo8(statusMsg)
 12222 44b6 90E0      		ldi r25,hi8(statusMsg)
 12223 44b8 0E94 0000 		call strcat
 12224               	.LVL1033:
2555:switcherator.c ****         sendMessage(statusMsg);
 12225               		.loc 1 2555 0
 12226 44bc 80E0      		ldi r24,lo8(statusMsg)
 12227 44be 90E0      		ldi r25,hi8(statusMsg)
 12228 44c0 0E94 0000 		call sendMessage
 12229               	.LVL1034:
 12230 44c4 00C0      		rjmp .L842
 12231               	.LVL1035:
 12232               	.L846:
2514:switcherator.c **** void setTimeLimits(char * commandReceived) {
 12233               		.loc 1 2514 0
 12234 44c6 D601      		movw r26,r12
 12235 44c8 1D96      		adiw r26,13
 12236 44ca FE01      		movw r30,r28
 12237 44cc 3196      		adiw r30,1
 12238 44ce CE01      		movw r24,r28
 12239 44d0 0896      		adiw r24,8
 12240               	.LVL1036:
 12241               	.L847:
2559:switcherator.c ****         tempReallyLongString[x] = commandReceived[x + 13];
 12242               		.loc 1 2559 0 discriminator 2
 12243 44d2 2D91      		ld r18,X+
 12244 44d4 2193      		st Z+,r18
2558:switcherator.c ****     for (x = 0; x < 7; x++) {
 12245               		.loc 1 2558 0 discriminator 2
 12246 44d6 E817      		cp r30,r24
 12247 44d8 F907      		cpc r31,r25
 12248 44da 01F4      		brne .L847
2561:switcherator.c ****     weekLong = strtol(tempReallyLongString, 0, 2);
 12249               		.loc 1 2561 0
 12250 44dc 42E0      		ldi r20,lo8(2)
 12251 44de 50E0      		ldi r21,0
 12252 44e0 60E0      		ldi r22,0
 12253 44e2 70E0      		ldi r23,0
 12254 44e4 CE01      		movw r24,r28
 12255 44e6 0196      		adiw r24,1
 12256 44e8 0E94 0000 		call strtol
 12257               	.LVL1037:
 12258 44ec 2B01      		movw r4,r22
 12259 44ee 3C01      		movw r6,r24
 12260               	.LVL1038:
2562:switcherator.c ****     tempIntString[0] = commandReceived[5];
 12261               		.loc 1 2562 0
 12262 44f0 F601      		movw r30,r12
 12263 44f2 8581      		ldd r24,Z+5
 12264 44f4 8093 0000 		sts tempIntString,r24
2563:switcherator.c ****     tempIntString[1] = commandReceived[6];
 12265               		.loc 1 2563 0
 12266 44f8 8681      		ldd r24,Z+6
 12267 44fa 8093 0000 		sts tempIntString+1,r24
2564:switcherator.c ****     startHour = atoi(tempIntString);
 12268               		.loc 1 2564 0
 12269 44fe 80E0      		ldi r24,lo8(tempIntString)
 12270 4500 90E0      		ldi r25,hi8(tempIntString)
 12271 4502 0E94 0000 		call atoi
 12272               	.LVL1039:
 12273 4506 7C01      		movw r14,r24
 12274               	.LVL1040:
2565:switcherator.c ****     tempIntString[0] = commandReceived[7];
 12275               		.loc 1 2565 0
 12276 4508 F601      		movw r30,r12
 12277 450a 8781      		ldd r24,Z+7
 12278 450c 8093 0000 		sts tempIntString,r24
2566:switcherator.c ****     tempIntString[1] = commandReceived[8];
 12279               		.loc 1 2566 0
 12280 4510 8085      		ldd r24,Z+8
 12281 4512 8093 0000 		sts tempIntString+1,r24
2567:switcherator.c ****     startMinute = atoi(tempIntString);
 12282               		.loc 1 2567 0
 12283 4516 80E0      		ldi r24,lo8(tempIntString)
 12284 4518 90E0      		ldi r25,hi8(tempIntString)
 12285 451a 0E94 0000 		call atoi
 12286               	.LVL1041:
 12287 451e 4C01      		movw r8,r24
 12288               	.LVL1042:
2568:switcherator.c ****     tempIntString[0] = commandReceived[9];
 12289               		.loc 1 2568 0
 12290 4520 F601      		movw r30,r12
 12291 4522 8185      		ldd r24,Z+9
 12292 4524 8093 0000 		sts tempIntString,r24
2569:switcherator.c ****     tempIntString[1] = commandReceived[10];
 12293               		.loc 1 2569 0
 12294 4528 8285      		ldd r24,Z+10
 12295 452a 8093 0000 		sts tempIntString+1,r24
2570:switcherator.c ****     stopHour = atoi(tempIntString);
 12296               		.loc 1 2570 0
 12297 452e 80E0      		ldi r24,lo8(tempIntString)
 12298 4530 90E0      		ldi r25,hi8(tempIntString)
 12299 4532 0E94 0000 		call atoi
 12300               	.LVL1043:
 12301 4536 1C01      		movw r2,r24
 12302               	.LVL1044:
2571:switcherator.c ****     tempIntString[0] = commandReceived[11];
 12303               		.loc 1 2571 0
 12304 4538 F601      		movw r30,r12
 12305 453a 8385      		ldd r24,Z+11
 12306 453c 8093 0000 		sts tempIntString,r24
2572:switcherator.c ****     tempIntString[1] = commandReceived[12];
 12307               		.loc 1 2572 0
 12308 4540 8485      		ldd r24,Z+12
 12309 4542 8093 0000 		sts tempIntString+1,r24
2573:switcherator.c ****     stopMinute = atoi(tempIntString);
 12310               		.loc 1 2573 0
 12311 4546 80E0      		ldi r24,lo8(tempIntString)
 12312 4548 90E0      		ldi r25,hi8(tempIntString)
 12313 454a 0E94 0000 		call atoi
 12314               	.LVL1045:
2574:switcherator.c ****     if (startHour > 23 || stopHour > 23) {
 12315               		.loc 1 2574 0
 12316 454e F8E1      		ldi r31,24
 12317 4550 EF16      		cp r14,r31
 12318 4552 F104      		cpc r15,__zero_reg__
 12319 4554 00F4      		brsh .L848
2574:switcherator.c ****     if (startHour > 23 || stopHour > 23) {
 12320               		.loc 1 2574 0 is_stmt 0 discriminator 1
 12321 4556 28E1      		ldi r18,24
 12322 4558 2216      		cp r2,r18
 12323 455a 3104      		cpc r3,__zero_reg__
 12324 455c 00F0      		brlo .L849
 12325               	.L848:
2575:switcherator.c ****         fail(0x09);
 12326               		.loc 1 2575 0 is_stmt 1
 12327 455e 89E0      		ldi r24,lo8(9)
 12328 4560 90E0      		ldi r25,0
 12329               	.LVL1046:
 12330 4562 00C0      		rjmp .L854
 12331               	.LVL1047:
 12332               	.L849:
2567:switcherator.c ****     startMinute = atoi(tempIntString);
 12333               		.loc 1 2567 0
 12334 4564 F401      		movw r30,r8
2578:switcherator.c ****     if (startMinute > 59 || stopMinute > 59) {
 12335               		.loc 1 2578 0
 12336 4566 EC33      		cpi r30,60
 12337 4568 F105      		cpc r31,__zero_reg__
 12338 456a 00F4      		brsh .L850
2573:switcherator.c ****     stopMinute = atoi(tempIntString);
 12339               		.loc 1 2573 0 discriminator 1
 12340 456c AC01      		movw r20,r24
2578:switcherator.c ****     if (startMinute > 59 || stopMinute > 59) {
 12341               		.loc 1 2578 0 discriminator 1
 12342 456e 8C33      		cpi r24,60
 12343 4570 9105      		cpc r25,__zero_reg__
 12344 4572 00F0      		brlo .L851
 12345               	.L850:
2579:switcherator.c ****         fail(0x0A);
 12346               		.loc 1 2579 0
 12347 4574 8AE0      		ldi r24,lo8(10)
 12348 4576 90E0      		ldi r25,0
 12349               	.LVL1048:
 12350               	.L854:
 12351 4578 0E94 0000 		call fail
 12352               	.LVL1049:
 12353 457c 00C0      		rjmp .L842
 12354               	.LVL1050:
 12355               	.L851:
2583:switcherator.c ****     startTime = startTime * 60 * 60;
 12356               		.loc 1 2583 0
 12357 457e 9701      		movw r18,r14
 12358 4580 A0E1      		ldi r26,lo8(16)
 12359 4582 BEE0      		ldi r27,lo8(14)
 12360 4584 0E94 0000 		call __umulhisi3
 12361 4588 6B01      		movw r12,r22
 12362 458a 7C01      		movw r14,r24
 12363               	.LVL1051:
2586:switcherator.c ****     stopTime = stopTime * 60 * 60;
 12364               		.loc 1 2586 0
 12365 458c 9101      		movw r18,r2
 12366 458e 0E94 0000 		call __umulhisi3
 12367               	.LVL1052:
2588:switcherator.c ****     timeLimits[programNumber][0] = startTime;
 12368               		.loc 1 2588 0
 12369 4592 2CE0      		ldi r18,lo8(12)
 12370 4594 209F      		mul r18,r16
 12371 4596 D001      		movw r26,r0
 12372 4598 219F      		mul r18,r17
 12373 459a B00D      		add r27,r0
 12374 459c 1124      		clr __zero_reg__
 12375 459e A050      		subi r26,lo8(-(timeLimits))
 12376 45a0 B040      		sbci r27,hi8(-(timeLimits))
2584:switcherator.c ****     startTime += (startMinute * 60);
 12377               		.loc 1 2584 0
 12378 45a2 2CE3      		ldi r18,lo8(60)
 12379 45a4 289D      		mul r18,r8
 12380 45a6 8001      		movw r16,r0
 12381 45a8 299D      		mul r18,r9
 12382 45aa 100D      		add r17,r0
 12383 45ac 1124      		clr __zero_reg__
 12384               	.LVL1053:
 12385 45ae C00E      		add r12,r16
 12386 45b0 D11E      		adc r13,r17
 12387 45b2 E11C      		adc r14,__zero_reg__
 12388 45b4 F11C      		adc r15,__zero_reg__
 12389               	.LVL1054:
2588:switcherator.c ****     timeLimits[programNumber][0] = startTime;
 12390               		.loc 1 2588 0
 12391 45b6 CD92      		st X+,r12
 12392 45b8 DD92      		st X+,r13
 12393 45ba ED92      		st X+,r14
 12394 45bc FC92      		st X,r15
 12395 45be 1397      		sbiw r26,3
2587:switcherator.c ****     stopTime += (stopMinute * 60);
 12396               		.loc 1 2587 0
 12397 45c0 249F      		mul r18,r20
 12398 45c2 F001      		movw r30,r0
 12399 45c4 259F      		mul r18,r21
 12400 45c6 F00D      		add r31,r0
 12401 45c8 1124      		clr __zero_reg__
 12402 45ca 6E0F      		add r22,r30
 12403 45cc 7F1F      		adc r23,r31
 12404 45ce 811D      		adc r24,__zero_reg__
 12405 45d0 911D      		adc r25,__zero_reg__
 12406               	.LVL1055:
2589:switcherator.c ****     timeLimits[programNumber][1] = stopTime;
 12407               		.loc 1 2589 0
 12408 45d2 1496      		adiw r26,4
 12409 45d4 6D93      		st X+,r22
 12410 45d6 7D93      		st X+,r23
 12411 45d8 8D93      		st X+,r24
 12412 45da 9C93      		st X,r25
 12413 45dc 1797      		sbiw r26,4+3
2590:switcherator.c ****     timeLimits[programNumber][2] = weekLong;
 12414               		.loc 1 2590 0
 12415 45de 1896      		adiw r26,8
 12416 45e0 4D92      		st X+,r4
 12417 45e2 5D92      		st X+,r5
 12418 45e4 6D92      		st X+,r6
 12419 45e6 7C92      		st X,r7
 12420 45e8 1B97      		sbiw r26,8+3
 12421               	.LVL1056:
 12422               	.L855:
2591:switcherator.c ****     ok();
 12423               		.loc 1 2591 0
 12424 45ea 0E94 0000 		call ok
 12425               	.LVL1057:
 12426               	.L842:
 12427               	/* epilogue start */
2593:switcherator.c **** }
 12428               		.loc 1 2593 0
 12429 45ee 2C96      		adiw r28,12
 12430 45f0 0FB6      		in __tmp_reg__,__SREG__
 12431 45f2 F894      		cli
 12432 45f4 DEBF      		out __SP_H__,r29
 12433 45f6 0FBE      		out __SREG__,__tmp_reg__
 12434 45f8 CDBF      		out __SP_L__,r28
 12435 45fa DF91      		pop r29
 12436 45fc CF91      		pop r28
 12437 45fe 1F91      		pop r17
 12438 4600 0F91      		pop r16
 12439 4602 FF90      		pop r15
 12440 4604 EF90      		pop r14
 12441 4606 DF90      		pop r13
 12442 4608 CF90      		pop r12
 12443 460a BF90      		pop r11
 12444 460c AF90      		pop r10
 12445 460e 9F90      		pop r9
 12446 4610 8F90      		pop r8
 12447 4612 7F90      		pop r7
 12448 4614 6F90      		pop r6
 12449 4616 5F90      		pop r5
 12450 4618 4F90      		pop r4
 12451 461a 3F90      		pop r3
 12452 461c 2F90      		pop r2
 12453 461e 0895      		ret
 12454               	.LFE59:
 12456               		.section	.rodata.str1.1
 12457               	.LC72:
 12458 0166 4E65 7720 		.string	"New prog#"
 12458      7072 6F67 
 12458      2300 
 12459               		.text
 12460               	.global	newProgram
 12462               	newProgram:
 12463               	.LFB30:
1185:switcherator.c **** void newProgram(char * commandReceived) {
 12464               		.loc 1 1185 0
 12465               	.LVL1058:
 12466 4620 AF92      		push r10
 12467               	.LCFI336:
 12468 4622 BF92      		push r11
 12469               	.LCFI337:
 12470 4624 CF92      		push r12
 12471               	.LCFI338:
 12472 4626 DF92      		push r13
 12473               	.LCFI339:
 12474 4628 EF92      		push r14
 12475               	.LCFI340:
 12476 462a FF92      		push r15
 12477               	.LCFI341:
 12478 462c 0F93      		push r16
 12479               	.LCFI342:
 12480 462e 1F93      		push r17
 12481               	.LCFI343:
 12482 4630 CF93      		push r28
 12483               	.LCFI344:
 12484 4632 DF93      		push r29
 12485               	.LCFI345:
 12486               	/* prologue: function */
 12487               	/* frame size = 0 */
 12488               	/* stack size = 10 */
 12489               	.L__stack_usage = 10
 12490 4634 EC01      		movw r28,r24
 12491               	.LVL1059:
 12492 4636 E0E0      		ldi r30,lo8(weeklyProgram+1)
 12493 4638 F0E0      		ldi r31,hi8(weeklyProgram+1)
1193:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 12494               		.loc 1 1193 0
 12495 463a 00E0      		ldi r16,0
 12496 463c 10E0      		ldi r17,0
 12497               	.LVL1060:
 12498               	.L859:
1185:switcherator.c **** void newProgram(char * commandReceived) {
 12499               		.loc 1 1185 0
 12500 463e DF01      		movw r26,r30
 12501 4640 1197      		sbiw r26,1
1195:switcherator.c ****         if (weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) {
 12502               		.loc 1 1195 0
 12503 4642 8C91      		ld r24,X
 12504 4644 8F3F      		cpi r24,lo8(-1)
 12505 4646 01F4      		brne .L857
1195:switcherator.c ****         if (weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) {
 12506               		.loc 1 1195 0 is_stmt 0 discriminator 1
 12507 4648 8081      		ld r24,Z
 12508 464a 8F3F      		cpi r24,lo8(-1)
 12509 464c 01F4      		brne .+2
 12510 464e 00C0      		rjmp .L858
 12511               	.L857:
1193:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 12512               		.loc 1 1193 0 is_stmt 1
 12513 4650 0F5F      		subi r16,-1
 12514 4652 1F4F      		sbci r17,-1
 12515               	.LVL1061:
 12516 4654 3A96      		adiw r30,10
 12517 4656 0431      		cpi r16,20
 12518 4658 1105      		cpc r17,__zero_reg__
 12519 465a 01F4      		brne .L859
 12520 465c 00C0      		rjmp .L874
 12521               	.LVL1062:
 12522               	.L875:
1218:switcherator.c ****     if (hours >= 24 || (hours == 0 && commandReceived[4] != '0')) {
 12523               		.loc 1 1218 0 discriminator 1
 12524 465e E114      		cp r14,__zero_reg__
 12525 4660 F104      		cpc r15,__zero_reg__
 12526 4662 01F4      		brne .L861
 12527 4664 20E3      		ldi r18,lo8(48)
 12528 4666 A216      		cp r10,r18
 12529 4668 01F0      		breq .L861
 12530               	.L865:
1219:switcherator.c ****         fail(9);
 12531               		.loc 1 1219 0
 12532 466a 89E0      		ldi r24,lo8(9)
 12533 466c 90E0      		ldi r25,0
 12534               	.LVL1063:
 12535 466e 00C0      		rjmp .L876
 12536               	.LVL1064:
 12537               	.L861:
1222:switcherator.c ****     if (minutes >= 60 || (minutes == 0 && commandReceived[6] != '0')) {
 12538               		.loc 1 1222 0
 12539 4670 2CE3      		ldi r18,60
 12540 4672 C216      		cp r12,r18
 12541 4674 D104      		cpc r13,__zero_reg__
 12542 4676 04F4      		brge .L862
1222:switcherator.c ****     if (minutes >= 60 || (minutes == 0 && commandReceived[6] != '0')) {
 12543               		.loc 1 1222 0 is_stmt 0 discriminator 1
 12544 4678 C114      		cp r12,__zero_reg__
 12545 467a D104      		cpc r13,__zero_reg__
 12546 467c 01F4      		brne .L863
 12547 467e 20E3      		ldi r18,lo8(48)
 12548 4680 B216      		cp r11,r18
 12549 4682 01F0      		breq .L863
 12550               	.L862:
1223:switcherator.c ****         fail(0x0a);
 12551               		.loc 1 1223 0 is_stmt 1
 12552 4684 8AE0      		ldi r24,lo8(10)
 12553 4686 90E0      		ldi r25,0
 12554               	.LVL1065:
 12555 4688 00C0      		rjmp .L876
 12556               	.LVL1066:
 12557               	.L863:
1226:switcherator.c ****     if (duration == 0) {
 12558               		.loc 1 1226 0
 12559 468a 0097      		sbiw r24,0
 12560 468c 01F4      		brne .L864
1227:switcherator.c ****         fail(0x0b);
 12561               		.loc 1 1227 0
 12562 468e 8BE0      		ldi r24,lo8(11)
 12563 4690 90E0      		ldi r25,0
 12564               	.LVL1067:
 12565 4692 00C0      		rjmp .L876
 12566               	.LVL1068:
 12567               	.L864:
1230:switcherator.c ****     duration *= 60; // convert to seconds
 12568               		.loc 1 1230 0
 12569 4694 6CE3      		ldi r22,lo8(60)
 12570 4696 689F      		mul r22,r24
 12571 4698 A001      		movw r20,r0
 12572 469a 699F      		mul r22,r25
 12573 469c 500D      		add r21,r0
 12574 469e 1124      		clr __zero_reg__
 12575               	.LVL1069:
1231:switcherator.c ****     startTime = (hours * 60);
 12576               		.loc 1 1231 0
 12577 46a0 6E9D      		mul r22,r14
 12578 46a2 9001      		movw r18,r0
 12579 46a4 6F9D      		mul r22,r15
 12580 46a6 300D      		add r19,r0
 12581 46a8 1124      		clr __zero_reg__
 12582               	.LVL1070:
1232:switcherator.c ****     startTime += minutes; // stored in minutes
 12583               		.loc 1 1232 0
 12584 46aa 2C0D      		add r18,r12
 12585 46ac 3D1D      		adc r19,r13
 12586               	.LVL1071:
1235:switcherator.c ****     weeklyProgram[programNumber][1] = temp;
 12587               		.loc 1 1235 0
 12588 46ae 8AE0      		ldi r24,lo8(10)
 12589 46b0 809F      		mul r24,r16
 12590 46b2 F001      		movw r30,r0
 12591 46b4 819F      		mul r24,r17
 12592 46b6 F00D      		add r31,r0
 12593 46b8 1124      		clr __zero_reg__
 12594 46ba E050      		subi r30,lo8(-(weeklyProgram))
 12595 46bc F040      		sbci r31,hi8(-(weeklyProgram))
 12596 46be 3183      		std Z+1,r19
 12597               	.LVL1072:
1237:switcherator.c ****     weeklyProgram[programNumber][2] = temp;
 12598               		.loc 1 1237 0
 12599 46c0 2283      		std Z+2,r18
 12600               	.LVL1073:
1239:switcherator.c ****     weeklyProgram[programNumber][3] = temp;
 12601               		.loc 1 1239 0
 12602 46c2 5383      		std Z+3,r21
 12603               	.LVL1074:
1240:switcherator.c ****     temp = (duration & 0xff);
 12604               		.loc 1 1240 0
 12605 46c4 5527      		clr r21
 12606               	.LVL1075:
1241:switcherator.c ****     weeklyProgram[programNumber][4] = temp;
 12607               		.loc 1 1241 0
 12608 46c6 4483      		std Z+4,r20
1242:switcherator.c ****     statusMsg[0] = 0;
 12609               		.loc 1 1242 0
 12610 46c8 1092 0000 		sts statusMsg,__zero_reg__
1243:switcherator.c ****     strcat(statusMsg, "New prog#");
 12611               		.loc 1 1243 0
 12612 46cc 60E0      		ldi r22,lo8(.LC72)
 12613 46ce 70E0      		ldi r23,hi8(.LC72)
 12614 46d0 80E0      		ldi r24,lo8(statusMsg)
 12615 46d2 90E0      		ldi r25,hi8(statusMsg)
 12616 46d4 0E94 0000 		call strcat
 12617               	.LVL1076:
1244:switcherator.c ****     returnInt(programNumber, tempIntString);
 12618               		.loc 1 1244 0
 12619 46d8 60E0      		ldi r22,lo8(tempIntString)
 12620 46da 70E0      		ldi r23,hi8(tempIntString)
 12621 46dc C801      		movw r24,r16
 12622 46de 0E94 0000 		call returnInt
 12623               	.LVL1077:
1245:switcherator.c ****     strcat(statusMsg, tempIntString);
 12624               		.loc 1 1245 0
 12625 46e2 60E0      		ldi r22,lo8(tempIntString)
 12626 46e4 70E0      		ldi r23,hi8(tempIntString)
 12627 46e6 80E0      		ldi r24,lo8(statusMsg)
 12628 46e8 90E0      		ldi r25,hi8(statusMsg)
 12629 46ea 0E94 0000 		call strcat
 12630               	.LVL1078:
1246:switcherator.c ****     sendMessage(statusMsg);
 12631               		.loc 1 1246 0
 12632 46ee 80E0      		ldi r24,lo8(statusMsg)
 12633 46f0 90E0      		ldi r25,hi8(statusMsg)
 12634               	/* epilogue start */
1247:switcherator.c **** }
 12635               		.loc 1 1247 0
 12636 46f2 DF91      		pop r29
 12637 46f4 CF91      		pop r28
 12638               	.LVL1079:
 12639 46f6 1F91      		pop r17
 12640 46f8 0F91      		pop r16
 12641               	.LVL1080:
 12642 46fa FF90      		pop r15
 12643 46fc EF90      		pop r14
 12644               	.LVL1081:
 12645 46fe DF90      		pop r13
 12646 4700 CF90      		pop r12
 12647               	.LVL1082:
 12648 4702 BF90      		pop r11
 12649 4704 AF90      		pop r10
1246:switcherator.c ****     sendMessage(statusMsg);
 12650               		.loc 1 1246 0
 12651 4706 0C94 0000 		jmp sendMessage
 12652               	.LVL1083:
 12653               	.L874:
1203:switcherator.c ****         fail(8);
 12654               		.loc 1 1203 0
 12655 470a 88E0      		ldi r24,lo8(8)
 12656 470c 90E0      		ldi r25,0
 12657               	.LVL1084:
 12658               	.L876:
 12659               	/* epilogue start */
1247:switcherator.c **** }
 12660               		.loc 1 1247 0
 12661 470e DF91      		pop r29
 12662 4710 CF91      		pop r28
 12663               	.LVL1085:
 12664 4712 1F91      		pop r17
 12665 4714 0F91      		pop r16
 12666 4716 FF90      		pop r15
 12667 4718 EF90      		pop r14
 12668 471a DF90      		pop r13
 12669 471c CF90      		pop r12
 12670 471e BF90      		pop r11
 12671 4720 AF90      		pop r10
1203:switcherator.c ****         fail(8);
 12672               		.loc 1 1203 0
 12673 4722 0C94 0000 		jmp fail
 12674               	.LVL1086:
 12675               	.L858:
1206:switcherator.c ****     clearTheProgram(programNumber);
 12676               		.loc 1 1206 0
 12677 4726 C801      		movw r24,r16
 12678 4728 0E94 0000 		call clearTheProgram
 12679               	.LVL1087:
1207:switcherator.c ****     tempIntString[0] = commandReceived[3];
 12680               		.loc 1 1207 0
 12681 472c 8B81      		ldd r24,Y+3
 12682 472e 8093 0000 		sts tempIntString,r24
1208:switcherator.c ****     tempIntString[1] = commandReceived[4];
 12683               		.loc 1 1208 0
 12684 4732 AC80      		ldd r10,Y+4
 12685 4734 A092 0000 		sts tempIntString+1,r10
1209:switcherator.c ****     hours = atoi(tempIntString);
 12686               		.loc 1 1209 0
 12687 4738 80E0      		ldi r24,lo8(tempIntString)
 12688 473a 90E0      		ldi r25,hi8(tempIntString)
 12689 473c 0E94 0000 		call atoi
 12690               	.LVL1088:
 12691 4740 7C01      		movw r14,r24
 12692               	.LVL1089:
1210:switcherator.c ****     tempIntString[0] = commandReceived[5];
 12693               		.loc 1 1210 0
 12694 4742 8D81      		ldd r24,Y+5
 12695 4744 8093 0000 		sts tempIntString,r24
1211:switcherator.c ****     tempIntString[1] = commandReceived[6];
 12696               		.loc 1 1211 0
 12697 4748 BE80      		ldd r11,Y+6
 12698 474a B092 0000 		sts tempIntString+1,r11
1212:switcherator.c ****     minutes = atoi(tempIntString);
 12699               		.loc 1 1212 0
 12700 474e 80E0      		ldi r24,lo8(tempIntString)
 12701 4750 90E0      		ldi r25,hi8(tempIntString)
 12702 4752 0E94 0000 		call atoi
 12703               	.LVL1090:
 12704 4756 6C01      		movw r12,r24
 12705               	.LVL1091:
1213:switcherator.c ****     tempLongString[0] = commandReceived[7];
 12706               		.loc 1 1213 0
 12707 4758 8F81      		ldd r24,Y+7
 12708 475a 8093 0000 		sts tempLongString,r24
1214:switcherator.c ****     tempLongString[1] = commandReceived[8];
 12709               		.loc 1 1214 0
 12710 475e 8885      		ldd r24,Y+8
 12711 4760 8093 0000 		sts tempLongString+1,r24
1215:switcherator.c ****     tempLongString[2] = commandReceived[9];
 12712               		.loc 1 1215 0
 12713 4764 8985      		ldd r24,Y+9
 12714 4766 8093 0000 		sts tempLongString+2,r24
1216:switcherator.c ****     tempLongString[3] = commandReceived[10];
 12715               		.loc 1 1216 0
 12716 476a 8A85      		ldd r24,Y+10
 12717 476c 8093 0000 		sts tempLongString+3,r24
1217:switcherator.c ****     duration = atoi(tempLongString);
 12718               		.loc 1 1217 0
 12719 4770 80E0      		ldi r24,lo8(tempLongString)
 12720 4772 90E0      		ldi r25,hi8(tempLongString)
 12721 4774 0E94 0000 		call atoi
 12722               	.LVL1092:
1218:switcherator.c ****     if (hours >= 24 || (hours == 0 && commandReceived[4] != '0')) {
 12723               		.loc 1 1218 0
 12724 4778 28E1      		ldi r18,24
 12725 477a E216      		cp r14,r18
 12726 477c F104      		cpc r15,__zero_reg__
 12727 477e 04F4      		brge .+2
 12728 4780 00C0      		rjmp .L875
 12729 4782 00C0      		rjmp .L865
 12730               	.LFE30:
 12732               	.global	switchBrightness
 12734               	switchBrightness:
 12735               	.LFB19:
 792:switcherator.c **** void switchBrightness(char * commandReceived) {
 12736               		.loc 1 792 0
 12737               	.LVL1093:
 12738 4784 FF92      		push r15
 12739               	.LCFI346:
 12740 4786 0F93      		push r16
 12741               	.LCFI347:
 12742 4788 1F93      		push r17
 12743               	.LCFI348:
 12744 478a CF93      		push r28
 12745               	.LCFI349:
 12746 478c DF93      		push r29
 12747               	.LCFI350:
 12748               	/* prologue: function */
 12749               	/* frame size = 0 */
 12750               	/* stack size = 5 */
 12751               	.L__stack_usage = 5
 12752 478e 8C01      		movw r16,r24
 793:switcherator.c ****     int switchNumber = getSwitchNumber(commandReceived);
 12753               		.loc 1 793 0
 12754 4790 0E94 0000 		call getSwitchNumber
 12755               	.LVL1094:
 12756 4794 EC01      		movw r28,r24
 12757               	.LVL1095:
 795:switcherator.c ****     if (switchNumber >= NUM_SWITCHES) {
 12758               		.loc 1 795 0
 12759 4796 8031      		cpi r24,16
 12760 4798 9105      		cpc r25,__zero_reg__
 12761 479a 04F0      		brlt .L878
 796:switcherator.c ****         fail(1);
 12762               		.loc 1 796 0
 12763 479c 81E0      		ldi r24,lo8(1)
 12764 479e 90E0      		ldi r25,0
 12765               	.LVL1096:
 12766               	/* epilogue start */
 818:switcherator.c **** }
 12767               		.loc 1 818 0
 12768 47a0 DF91      		pop r29
 12769 47a2 CF91      		pop r28
 12770               	.LVL1097:
 12771 47a4 1F91      		pop r17
 12772 47a6 0F91      		pop r16
 12773               	.LVL1098:
 12774 47a8 FF90      		pop r15
 796:switcherator.c ****         fail(1);
 12775               		.loc 1 796 0
 12776 47aa 0C94 0000 		jmp fail
 12777               	.LVL1099:
 12778               	.L878:
 799:switcherator.c ****     tempIntString[0] = commandReceived[5];
 12779               		.loc 1 799 0
 12780 47ae F801      		movw r30,r16
 12781 47b0 8581      		ldd r24,Z+5
 12782               	.LVL1100:
 12783 47b2 8093 0000 		sts tempIntString,r24
 800:switcherator.c ****     tempIntString[1] = commandReceived[6];
 12784               		.loc 1 800 0
 12785 47b6 8681      		ldd r24,Z+6
 12786 47b8 8093 0000 		sts tempIntString+1,r24
 801:switcherator.c ****     char brightValue = atoi(tempIntString);
 12787               		.loc 1 801 0
 12788 47bc 80E0      		ldi r24,lo8(tempIntString)
 12789 47be 90E0      		ldi r25,hi8(tempIntString)
 12790 47c0 0E94 0000 		call atoi
 12791               	.LVL1101:
 12792 47c4 F82E      		mov r15,r24
 12793               	.LVL1102:
 12794 47c6 8E01      		movw r16,r28
 12795               	.LVL1103:
 12796 47c8 0050      		subi r16,lo8(-(switchBright))
 12797 47ca 1040      		sbci r17,hi8(-(switchBright))
 802:switcherator.c ****     if (brightValue == 0) {
 12798               		.loc 1 802 0
 12799 47cc 8111      		cpse r24,__zero_reg__
 12800 47ce 00C0      		rjmp .L879
 12801               	.LVL1104:
 804:switcherator.c ****         itoa(tempBright, tempIntString, 10);
 12802               		.loc 1 804 0
 12803 47d0 4AE0      		ldi r20,lo8(10)
 12804 47d2 50E0      		ldi r21,0
 12805 47d4 60E0      		ldi r22,lo8(tempIntString)
 12806 47d6 70E0      		ldi r23,hi8(tempIntString)
 12807 47d8 F801      		movw r30,r16
 12808 47da 8081      		ld r24,Z
 12809 47dc 90E0      		ldi r25,0
 12810 47de 0E94 0000 		call itoa
 12811               	.LVL1105:
 805:switcherator.c ****         statusMsg[0] = 0;
 12812               		.loc 1 805 0
 12813 47e2 1092 0000 		sts statusMsg,__zero_reg__
 806:switcherator.c ****         strcat(statusMsg, "Set @");
 12814               		.loc 1 806 0
 12815 47e6 60E0      		ldi r22,lo8(.LC66)
 12816 47e8 70E0      		ldi r23,hi8(.LC66)
 12817 47ea 80E0      		ldi r24,lo8(statusMsg)
 12818 47ec 90E0      		ldi r25,hi8(statusMsg)
 12819 47ee 0E94 0000 		call strcat
 12820               	.LVL1106:
 807:switcherator.c ****         strcat(statusMsg, tempIntString);
 12821               		.loc 1 807 0
 12822 47f2 60E0      		ldi r22,lo8(tempIntString)
 12823 47f4 70E0      		ldi r23,hi8(tempIntString)
 12824 47f6 80E0      		ldi r24,lo8(statusMsg)
 12825 47f8 90E0      		ldi r25,hi8(statusMsg)
 12826 47fa 0E94 0000 		call strcat
 12827               	.LVL1107:
 808:switcherator.c ****         sendMessage(statusMsg);
 12828               		.loc 1 808 0
 12829 47fe 80E0      		ldi r24,lo8(statusMsg)
 12830 4800 90E0      		ldi r25,hi8(statusMsg)
 12831               	/* epilogue start */
 818:switcherator.c **** }
 12832               		.loc 1 818 0
 12833 4802 DF91      		pop r29
 12834 4804 CF91      		pop r28
 12835               	.LVL1108:
 12836 4806 1F91      		pop r17
 12837 4808 0F91      		pop r16
 12838               	.LVL1109:
 12839 480a FF90      		pop r15
 12840               	.LVL1110:
 808:switcherator.c ****         sendMessage(statusMsg);
 12841               		.loc 1 808 0
 12842 480c 0C94 0000 		jmp sendMessage
 12843               	.LVL1111:
 12844               	.L879:
 812:switcherator.c ****         clearTheSwitch(switchNumber);
 12845               		.loc 1 812 0
 12846 4810 CE01      		movw r24,r28
 12847 4812 0E94 0000 		call clearTheSwitch
 12848               	.LVL1112:
 814:switcherator.c ****         switchStuff[switchNumber] = 212;
 12849               		.loc 1 814 0
 12850 4816 C050      		subi r28,lo8(-(switchStuff))
 12851 4818 D040      		sbci r29,hi8(-(switchStuff))
 12852               	.LVL1113:
 12853 481a 84ED      		ldi r24,lo8(-44)
 12854 481c 8883      		st Y,r24
 815:switcherator.c ****         switchBright[switchNumber] = brightValue;
 12855               		.loc 1 815 0
 12856 481e 8F2D      		mov r24,r15
 12857 4820 8131      		cpi r24,lo8(17)
 12858 4822 00F0      		brlo .L880
 12859 4824 80E1      		ldi r24,lo8(16)
 12860               	.L880:
 12861 4826 F801      		movw r30,r16
 12862 4828 8083      		st Z,r24
 12863               	/* epilogue start */
 818:switcherator.c **** }
 12864               		.loc 1 818 0
 12865 482a DF91      		pop r29
 12866 482c CF91      		pop r28
 12867 482e 1F91      		pop r17
 12868 4830 0F91      		pop r16
 12869               	.LVL1114:
 12870 4832 FF90      		pop r15
 12871               	.LVL1115:
 816:switcherator.c ****         ok();
 12872               		.loc 1 816 0
 12873 4834 0C94 0000 		jmp ok
 12874               	.LVL1116:
 12875               	.LFE19:
 12877               	.global	radioTest
 12879               	radioTest:
 12880               	.LFB71:
2879:switcherator.c **** int radioTest(void) {
 12881               		.loc 1 2879 0
 12882 4838 AF92      		push r10
 12883               	.LCFI351:
 12884 483a BF92      		push r11
 12885               	.LCFI352:
 12886 483c CF92      		push r12
 12887               	.LCFI353:
 12888 483e DF92      		push r13
 12889               	.LCFI354:
 12890 4840 EF92      		push r14
 12891               	.LCFI355:
 12892 4842 FF92      		push r15
 12893               	.LCFI356:
 12894 4844 0F93      		push r16
 12895               	.LCFI357:
 12896 4846 1F93      		push r17
 12897               	.LCFI358:
 12898               	/* prologue: function */
 12899               	/* frame size = 0 */
 12900               	/* stack size = 8 */
 12901               	.L__stack_usage = 8
2881:switcherator.c ****     test_addr = readAddr(RX_ADDR_P0);    
 12902               		.loc 1 2881 0
 12903 4848 8AE0      		ldi r24,lo8(10)
 12904 484a 0E94 0000 		call readAddr
 12905               	.LVL1117:
2882:switcherator.c ****     if (test_addr != rx_addr_p0) {
 12906               		.loc 1 2882 0
 12907 484e A090 0000 		lds r10,rx_addr_p0
 12908 4852 B090 0000 		lds r11,rx_addr_p0+1
 12909 4856 C090 0000 		lds r12,rx_addr_p0+2
 12910 485a D090 0000 		lds r13,rx_addr_p0+3
 12911 485e E090 0000 		lds r14,rx_addr_p0+4
 12912 4862 F090 0000 		lds r15,rx_addr_p0+5
 12913 4866 0091 0000 		lds r16,rx_addr_p0+6
 12914 486a 1091 0000 		lds r17,rx_addr_p0+7
 12915 486e 0E94 0000 		call __cmpdi2
 12916 4872 01F0      		breq .L882
2884:switcherator.c ****         failCondition = 1;
 12917               		.loc 1 2884 0
 12918 4874 81E0      		ldi r24,lo8(1)
 12919               	.LVL1118:
 12920 4876 8093 0000 		sts failCondition,r24
2885:switcherator.c ****         return -1;
 12921               		.loc 1 2885 0
 12922 487a 2FEF      		ldi r18,lo8(-1)
 12923 487c 3FEF      		ldi r19,lo8(-1)
 12924 487e 00C0      		rjmp .L883
 12925               	.LVL1119:
 12926               	.L882:
2887:switcherator.c ****     if(failCondition == 1 || failCondition == 2)
 12927               		.loc 1 2887 0
 12928 4880 8091 0000 		lds r24,failCondition
 12929               	.LVL1120:
 12930 4884 8150      		subi r24,lo8(-(-1))
 12931 4886 8230      		cpi r24,lo8(2)
 12932 4888 00F4      		brsh .L884
2888:switcherator.c ****         clearFail();
 12933               		.loc 1 2888 0
 12934 488a 0E94 0000 		call clearFail
 12935               	.LVL1121:
 12936               	.L884:
2889:switcherator.c ****     return 1;
 12937               		.loc 1 2889 0
 12938 488e 21E0      		ldi r18,lo8(1)
 12939 4890 30E0      		ldi r19,0
 12940               	.L883:
2890:switcherator.c **** }
 12941               		.loc 1 2890 0
 12942 4892 C901      		movw r24,r18
 12943               	/* epilogue start */
 12944 4894 1F91      		pop r17
 12945 4896 0F91      		pop r16
 12946 4898 FF90      		pop r15
 12947 489a EF90      		pop r14
 12948 489c DF90      		pop r13
 12949 489e CF90      		pop r12
 12950 48a0 BF90      		pop r11
 12951 48a2 AF90      		pop r10
 12952 48a4 0895      		ret
 12953               	.LFE71:
 12955               	.global	radioInit
 12957               	radioInit:
 12958               	.LFB70:
2851:switcherator.c **** void radioInit(void) {
 12959               		.loc 1 2851 0
 12960 48a6 0F93      		push r16
 12961               	.LCFI359:
 12962 48a8 1F93      		push r17
 12963               	.LCFI360:
 12964               	/* prologue: function */
 12965               	/* frame size = 0 */
 12966               	/* stack size = 2 */
 12967               	.L__stack_usage = 2
2852:switcherator.c ****     nrfInit();
 12968               		.loc 1 2852 0
 12969 48aa 0E94 0000 		call nrfInit
 12970               	.LVL1122:
2853:switcherator.c ****     rx_addr_p0 = SET_RX_ADDR_P0;
 12971               		.loc 1 2853 0
 12972 48ae 91E0      		ldi r25,lo8(1)
 12973 48b0 9093 0000 		sts rx_addr_p0,r25
 12974 48b4 80EF      		ldi r24,lo8(-16)
 12975 48b6 8093 0000 		sts rx_addr_p0+1,r24
 12976 48ba 8093 0000 		sts rx_addr_p0+2,r24
 12977 48be 8093 0000 		sts rx_addr_p0+3,r24
 12978 48c2 8093 0000 		sts rx_addr_p0+4,r24
 12979 48c6 1092 0000 		sts rx_addr_p0+5,__zero_reg__
 12980 48ca 1092 0000 		sts rx_addr_p0+6,__zero_reg__
 12981 48ce 1092 0000 		sts rx_addr_p0+7,__zero_reg__
2854:switcherator.c ****     tx_addr = SET_TX_ADDR;
 12982               		.loc 1 2854 0
 12983 48d2 9093 0000 		sts tx_addr,r25
 12984 48d6 8093 0000 		sts tx_addr+1,r24
 12985 48da 8093 0000 		sts tx_addr+2,r24
 12986 48de 8093 0000 		sts tx_addr+3,r24
 12987 48e2 8093 0000 		sts tx_addr+4,r24
 12988 48e6 1092 0000 		sts tx_addr+5,__zero_reg__
 12989 48ea 1092 0000 		sts tx_addr+6,__zero_reg__
 12990 48ee 1092 0000 		sts tx_addr+7,__zero_reg__
2856:switcherator.c ****     rx_addr_p1 = readAddr(RX_ADDR_P1);
 12991               		.loc 1 2856 0
 12992 48f2 8BE0      		ldi r24,lo8(11)
 12993 48f4 0E94 0000 		call readAddr
 12994               	.LVL1123:
 12995 48f8 2093 0000 		sts rx_addr_p1,r18
 12996 48fc 3093 0000 		sts rx_addr_p1+1,r19
 12997 4900 4093 0000 		sts rx_addr_p1+2,r20
 12998 4904 5093 0000 		sts rx_addr_p1+3,r21
 12999 4908 6093 0000 		sts rx_addr_p1+4,r22
 13000 490c 7093 0000 		sts rx_addr_p1+5,r23
 13001 4910 8093 0000 		sts rx_addr_p1+6,r24
 13002 4914 9093 0000 		sts rx_addr_p1+7,r25
2857:switcherator.c ****     rx_addr_p2 = readAddr(RX_ADDR_P2);
 13003               		.loc 1 2857 0
 13004 4918 8CE0      		ldi r24,lo8(12)
 13005 491a 0E94 0000 		call readAddr
 13006               	.LVL1124:
 13007 491e 2093 0000 		sts rx_addr_p2,r18
 13008 4922 3093 0000 		sts rx_addr_p2+1,r19
 13009 4926 4093 0000 		sts rx_addr_p2+2,r20
 13010 492a 5093 0000 		sts rx_addr_p2+3,r21
 13011 492e 6093 0000 		sts rx_addr_p2+4,r22
 13012 4932 7093 0000 		sts rx_addr_p2+5,r23
 13013 4936 8093 0000 		sts rx_addr_p2+6,r24
 13014 493a 9093 0000 		sts rx_addr_p2+7,r25
2858:switcherator.c ****     rx_addr_p3 = readAddr(RX_ADDR_P3);
 13015               		.loc 1 2858 0
 13016 493e 8DE0      		ldi r24,lo8(13)
 13017 4940 0E94 0000 		call readAddr
 13018               	.LVL1125:
 13019 4944 2093 0000 		sts rx_addr_p3,r18
 13020 4948 3093 0000 		sts rx_addr_p3+1,r19
 13021 494c 4093 0000 		sts rx_addr_p3+2,r20
 13022 4950 5093 0000 		sts rx_addr_p3+3,r21
 13023 4954 6093 0000 		sts rx_addr_p3+4,r22
 13024 4958 7093 0000 		sts rx_addr_p3+5,r23
 13025 495c 8093 0000 		sts rx_addr_p3+6,r24
 13026 4960 9093 0000 		sts rx_addr_p3+7,r25
2859:switcherator.c ****     rx_addr_p4 = readAddr(RX_ADDR_P4);
 13027               		.loc 1 2859 0
 13028 4964 8EE0      		ldi r24,lo8(14)
 13029 4966 0E94 0000 		call readAddr
 13030               	.LVL1126:
 13031 496a 2093 0000 		sts rx_addr_p4,r18
 13032 496e 3093 0000 		sts rx_addr_p4+1,r19
 13033 4972 4093 0000 		sts rx_addr_p4+2,r20
 13034 4976 5093 0000 		sts rx_addr_p4+3,r21
 13035 497a 6093 0000 		sts rx_addr_p4+4,r22
 13036 497e 7093 0000 		sts rx_addr_p4+5,r23
 13037 4982 8093 0000 		sts rx_addr_p4+6,r24
 13038 4986 9093 0000 		sts rx_addr_p4+7,r25
2860:switcherator.c ****     rx_addr_p5 = readAddr(RX_ADDR_P5);
 13039               		.loc 1 2860 0
 13040 498a 8FE0      		ldi r24,lo8(15)
 13041 498c 0E94 0000 		call readAddr
 13042               	.LVL1127:
 13043 4990 2093 0000 		sts rx_addr_p5,r18
 13044 4994 3093 0000 		sts rx_addr_p5+1,r19
 13045 4998 4093 0000 		sts rx_addr_p5+2,r20
 13046 499c 5093 0000 		sts rx_addr_p5+3,r21
 13047 49a0 6093 0000 		sts rx_addr_p5+4,r22
 13048 49a4 7093 0000 		sts rx_addr_p5+5,r23
 13049 49a8 8093 0000 		sts rx_addr_p5+6,r24
 13050 49ac 9093 0000 		sts rx_addr_p5+7,r25
2862:switcherator.c ****     writeReg(RF_SETUP, SET_RF_SETUP);
 13051               		.loc 1 2862 0
 13052 49b0 66E0      		ldi r22,lo8(6)
 13053 49b2 86E0      		ldi r24,lo8(6)
 13054 49b4 0E94 0000 		call writeReg
 13055               	.LVL1128:
2863:switcherator.c ****     writeAddr(RX_ADDR_P0, rx_addr_p0);
 13056               		.loc 1 2863 0
 13057 49b8 0091 0000 		lds r16,rx_addr_p0
 13058 49bc 1091 0000 		lds r17,rx_addr_p0+1
 13059 49c0 2091 0000 		lds r18,rx_addr_p0+2
 13060 49c4 3091 0000 		lds r19,rx_addr_p0+3
 13061 49c8 4091 0000 		lds r20,rx_addr_p0+4
 13062 49cc 5091 0000 		lds r21,rx_addr_p0+5
 13063 49d0 6091 0000 		lds r22,rx_addr_p0+6
 13064 49d4 7091 0000 		lds r23,rx_addr_p0+7
 13065 49d8 8AE0      		ldi r24,lo8(10)
 13066 49da 0E94 0000 		call writeAddr
 13067               	.LVL1129:
2864:switcherator.c ****     writeAddr(TX_ADDR, tx_addr);
 13068               		.loc 1 2864 0
 13069 49de 0091 0000 		lds r16,tx_addr
 13070 49e2 1091 0000 		lds r17,tx_addr+1
 13071 49e6 2091 0000 		lds r18,tx_addr+2
 13072 49ea 3091 0000 		lds r19,tx_addr+3
 13073 49ee 4091 0000 		lds r20,tx_addr+4
 13074 49f2 5091 0000 		lds r21,tx_addr+5
 13075 49f6 6091 0000 		lds r22,tx_addr+6
 13076 49fa 7091 0000 		lds r23,tx_addr+7
 13077 49fe 80E1      		ldi r24,lo8(16)
 13078 4a00 0E94 0000 		call writeAddr
 13079               	.LVL1130:
2865:switcherator.c ****     writeReg(DYNPD, SET_DYNPD);
 13080               		.loc 1 2865 0
 13081 4a04 6FE3      		ldi r22,lo8(63)
 13082 4a06 8CE1      		ldi r24,lo8(28)
 13083 4a08 0E94 0000 		call writeReg
 13084               	.LVL1131:
2866:switcherator.c ****     writeReg(FEATURE, SET_FEATURE);
 13085               		.loc 1 2866 0
 13086 4a0c 64E0      		ldi r22,lo8(4)
 13087 4a0e 8DE1      		ldi r24,lo8(29)
 13088 4a10 0E94 0000 		call writeReg
 13089               	.LVL1132:
2867:switcherator.c ****     writeReg(RF_CH, SET_RF_CH);
 13090               		.loc 1 2867 0
 13091 4a14 6AE2      		ldi r22,lo8(42)
 13092 4a16 85E0      		ldi r24,lo8(5)
 13093 4a18 0E94 0000 		call writeReg
 13094               	.LVL1133:
2868:switcherator.c ****     writeReg(CONFIG, SET_CONFIG);
 13095               		.loc 1 2868 0
 13096 4a1c 68E0      		ldi r22,lo8(8)
 13097 4a1e 80E0      		ldi r24,0
 13098 4a20 0E94 0000 		call writeReg
 13099               	.LVL1134:
2869:switcherator.c ****     writeReg(SETUP_RETR, SET_SETUP_RETR);
 13100               		.loc 1 2869 0
 13101 4a24 6FE0      		ldi r22,lo8(15)
 13102 4a26 84E0      		ldi r24,lo8(4)
 13103 4a28 0E94 0000 		call writeReg
 13104               	.LVL1135:
2872:switcherator.c ****     radioTest();
 13105               		.loc 1 2872 0
 13106 4a2c 0E94 0000 		call radioTest
 13107               	.LVL1136:
 13108               	/* epilogue start */
2876:switcherator.c **** }
 13109               		.loc 1 2876 0
 13110 4a30 1F91      		pop r17
 13111 4a32 0F91      		pop r16
2874:switcherator.c ****     startRadio();
 13112               		.loc 1 2874 0
 13113 4a34 0C94 0000 		jmp startRadio
 13114               	.LVL1137:
 13115               	.LFE70:
 13117               	.global	setClock
 13119               	setClock:
 13120               	.LFB48:
2104:switcherator.c **** void setClock(char * commandReceived) {
 13121               		.loc 1 2104 0
 13122               	.LVL1138:
 13123 4a38 6F92      		push r6
 13124               	.LCFI361:
 13125 4a3a 7F92      		push r7
 13126               	.LCFI362:
 13127 4a3c 8F92      		push r8
 13128               	.LCFI363:
 13129 4a3e 9F92      		push r9
 13130               	.LCFI364:
 13131 4a40 AF92      		push r10
 13132               	.LCFI365:
 13133 4a42 BF92      		push r11
 13134               	.LCFI366:
 13135 4a44 CF92      		push r12
 13136               	.LCFI367:
 13137 4a46 DF92      		push r13
 13138               	.LCFI368:
 13139 4a48 EF92      		push r14
 13140               	.LCFI369:
 13141 4a4a FF92      		push r15
 13142               	.LCFI370:
 13143 4a4c 0F93      		push r16
 13144               	.LCFI371:
 13145 4a4e 1F93      		push r17
 13146               	.LCFI372:
 13147 4a50 CF93      		push r28
 13148               	.LCFI373:
 13149 4a52 DF93      		push r29
 13150               	.LCFI374:
 13151               	/* prologue: function */
 13152               	/* frame size = 0 */
 13153               	/* stack size = 14 */
 13154               	.L__stack_usage = 14
 13155 4a54 EC01      		movw r28,r24
2107:switcherator.c ****     tempLongString[0] = '0';
 13156               		.loc 1 2107 0
 13157 4a56 80E3      		ldi r24,lo8(48)
 13158               	.LVL1139:
 13159 4a58 8093 0000 		sts tempLongString,r24
2108:switcherator.c ****     tempLongString[1] = '0';
 13160               		.loc 1 2108 0
 13161 4a5c 8093 0000 		sts tempLongString+1,r24
2111:switcherator.c ****     tempLongString[2] = commandReceived[3];
 13162               		.loc 1 2111 0
 13163 4a60 8B81      		ldd r24,Y+3
 13164 4a62 8093 0000 		sts tempLongString+2,r24
2112:switcherator.c ****     tempLongString[3] = commandReceived[4];
 13165               		.loc 1 2112 0
 13166 4a66 8C81      		ldd r24,Y+4
 13167 4a68 8093 0000 		sts tempLongString+3,r24
2113:switcherator.c ****     globalMonth = atoi(tempLongString);
 13168               		.loc 1 2113 0
 13169 4a6c 80E0      		ldi r24,lo8(tempLongString)
 13170 4a6e 90E0      		ldi r25,hi8(tempLongString)
 13171 4a70 0E94 0000 		call atoi
 13172               	.LVL1140:
 13173 4a74 6C01      		movw r12,r24
 13174 4a76 9093 0000 		sts globalMonth+1,r25
 13175 4a7a 8093 0000 		sts globalMonth,r24
2115:switcherator.c ****     tempLongString[2] = commandReceived[5];
 13176               		.loc 1 2115 0
 13177 4a7e 8D81      		ldd r24,Y+5
 13178 4a80 8093 0000 		sts tempLongString+2,r24
2116:switcherator.c ****     tempLongString[3] = commandReceived[6];
 13179               		.loc 1 2116 0
 13180 4a84 8E81      		ldd r24,Y+6
 13181 4a86 8093 0000 		sts tempLongString+3,r24
2117:switcherator.c ****     globalDay = atoi(tempLongString);
 13182               		.loc 1 2117 0
 13183 4a8a 80E0      		ldi r24,lo8(tempLongString)
 13184 4a8c 90E0      		ldi r25,hi8(tempLongString)
 13185 4a8e 0E94 0000 		call atoi
 13186               	.LVL1141:
 13187 4a92 8C01      		movw r16,r24
 13188 4a94 9093 0000 		sts globalDay+1,r25
 13189 4a98 8093 0000 		sts globalDay,r24
2119:switcherator.c ****     tempLongString[2] = commandReceived[11];
 13190               		.loc 1 2119 0
 13191 4a9c 8B85      		ldd r24,Y+11
 13192 4a9e 8093 0000 		sts tempLongString+2,r24
2120:switcherator.c ****     tempLongString[3] = commandReceived[12];
 13193               		.loc 1 2120 0
 13194 4aa2 8C85      		ldd r24,Y+12
 13195 4aa4 8093 0000 		sts tempLongString+3,r24
2121:switcherator.c ****     globalHour = atoi(tempLongString);
 13196               		.loc 1 2121 0
 13197 4aa8 80E0      		ldi r24,lo8(tempLongString)
 13198 4aaa 90E0      		ldi r25,hi8(tempLongString)
 13199 4aac 0E94 0000 		call atoi
 13200               	.LVL1142:
 13201 4ab0 4C01      		movw r8,r24
 13202 4ab2 8093 0000 		sts globalHour,r24
 13203 4ab6 9092 0000 		sts globalHour+1,r9
2123:switcherator.c ****     tempLongString[2] = commandReceived[13];
 13204               		.loc 1 2123 0
 13205 4aba 8D85      		ldd r24,Y+13
 13206 4abc 8093 0000 		sts tempLongString+2,r24
2124:switcherator.c ****     tempLongString[3] = commandReceived[14];
 13207               		.loc 1 2124 0
 13208 4ac0 8E85      		ldd r24,Y+14
 13209 4ac2 8093 0000 		sts tempLongString+3,r24
2125:switcherator.c ****     globalMinute = atoi(tempLongString);
 13210               		.loc 1 2125 0
 13211 4ac6 80E0      		ldi r24,lo8(tempLongString)
 13212 4ac8 90E0      		ldi r25,hi8(tempLongString)
 13213 4aca 0E94 0000 		call atoi
 13214               	.LVL1143:
 13215 4ace 5C01      		movw r10,r24
 13216 4ad0 8093 0000 		sts globalMinute,r24
 13217 4ad4 B092 0000 		sts globalMinute+1,r11
2127:switcherator.c ****     tempLongString[2] = commandReceived[15];
 13218               		.loc 1 2127 0
 13219 4ad8 8F85      		ldd r24,Y+15
 13220 4ada 8093 0000 		sts tempLongString+2,r24
2128:switcherator.c ****     tempLongString[3] = commandReceived[16];
 13221               		.loc 1 2128 0
 13222 4ade 8889      		ldd r24,Y+16
 13223 4ae0 8093 0000 		sts tempLongString+3,r24
2129:switcherator.c ****     globalSecond = atoi(tempLongString);
 13224               		.loc 1 2129 0
 13225 4ae4 80E0      		ldi r24,lo8(tempLongString)
 13226 4ae6 90E0      		ldi r25,hi8(tempLongString)
 13227 4ae8 0E94 0000 		call atoi
 13228               	.LVL1144:
 13229 4aec 3C01      		movw r6,r24
 13230 4aee 9093 0000 		sts globalSecond+1,r25
 13231 4af2 8093 0000 		sts globalSecond,r24
2131:switcherator.c ****     tempLongString[0] = commandReceived[7];
 13232               		.loc 1 2131 0
 13233 4af6 8F81      		ldd r24,Y+7
 13234 4af8 8093 0000 		sts tempLongString,r24
2132:switcherator.c ****     tempLongString[1] = commandReceived[8];
 13235               		.loc 1 2132 0
 13236 4afc 8885      		ldd r24,Y+8
 13237 4afe 8093 0000 		sts tempLongString+1,r24
2133:switcherator.c ****     tempLongString[2] = commandReceived[9];
 13238               		.loc 1 2133 0
 13239 4b02 8985      		ldd r24,Y+9
 13240 4b04 8093 0000 		sts tempLongString+2,r24
2134:switcherator.c ****     tempLongString[3] = commandReceived[10];
 13241               		.loc 1 2134 0
 13242 4b08 8A85      		ldd r24,Y+10
 13243 4b0a 8093 0000 		sts tempLongString+3,r24
2135:switcherator.c ****     globalYear = atoi(tempLongString);
 13244               		.loc 1 2135 0
 13245 4b0e 80E0      		ldi r24,lo8(tempLongString)
 13246 4b10 90E0      		ldi r25,hi8(tempLongString)
 13247 4b12 0E94 0000 		call atoi
 13248               	.LVL1145:
 13249 4b16 9093 0000 		sts globalYear+1,r25
 13250 4b1a 8093 0000 		sts globalYear,r24
2136:switcherator.c ****     dow = getWeekday(globalYear, globalMonth, globalDay); // get day of week
 13251               		.loc 1 2136 0
 13252 4b1e A801      		movw r20,r16
 13253 4b20 B601      		movw r22,r12
 13254 4b22 0E94 0000 		call getWeekday
 13255               	.LVL1146:
 13256 4b26 DC01      		movw r26,r24
 13257 4b28 8093 0000 		sts dow,r24
 13258 4b2c B093 0000 		sts dow+1,r27
 13259               	.LVL1147:
2138:switcherator.c ****     tempInt = tempInt * 24 * 60 * 60;
 13260               		.loc 1 2138 0
 13261 4b30 20E8      		ldi r18,lo8(-128)
 13262 4b32 31E5      		ldi r19,lo8(81)
 13263 4b34 41E0      		ldi r20,lo8(1)
 13264 4b36 50E0      		ldi r21,0
 13265 4b38 0E94 0000 		call __muluhisi3
 13266 4b3c 6B01      		movw r12,r22
 13267 4b3e 7C01      		movw r14,r24
2141:switcherator.c ****     tempInt = tempInt * 60 * 60;
 13268               		.loc 1 2141 0
 13269 4b40 9401      		movw r18,r8
 13270 4b42 A0E1      		ldi r26,lo8(16)
 13271 4b44 BEE0      		ldi r27,lo8(14)
 13272 4b46 0E94 0000 		call __umulhisi3
2142:switcherator.c ****     weeklySeconds += tempInt;
 13273               		.loc 1 2142 0
 13274 4b4a C60E      		add r12,r22
 13275 4b4c D71E      		adc r13,r23
 13276 4b4e E81E      		adc r14,r24
 13277 4b50 F91E      		adc r15,r25
2145:switcherator.c ****     weeklySeconds += tempInt;
 13278               		.loc 1 2145 0
 13279 4b52 C60C      		add r12,r6
 13280 4b54 D71C      		adc r13,r7
 13281 4b56 E11C      		adc r14,__zero_reg__
 13282 4b58 F11C      		adc r15,__zero_reg__
2144:switcherator.c ****     tempInt = tempInt * 60;
 13283               		.loc 1 2144 0
 13284 4b5a 9501      		movw r18,r10
 13285 4b5c ACE3      		ldi r26,lo8(60)
 13286 4b5e B0E0      		ldi r27,0
 13287 4b60 0E94 0000 		call __umulhisi3
2146:switcherator.c ****     weeklySeconds += globalSecond;
 13288               		.loc 1 2146 0
 13289 4b64 C60E      		add r12,r22
 13290 4b66 D71E      		adc r13,r23
 13291 4b68 E81E      		adc r14,r24
 13292 4b6a F91E      		adc r15,r25
 13293 4b6c C092 0000 		sts weeklySeconds,r12
 13294 4b70 D092 0000 		sts weeklySeconds+1,r13
 13295 4b74 E092 0000 		sts weeklySeconds+2,r14
 13296 4b78 F092 0000 		sts weeklySeconds+3,r15
2147:switcherator.c ****     clockString();
 13297               		.loc 1 2147 0
 13298 4b7c 0E94 0000 		call clockString
 13299               	.LVL1148:
2148:switcherator.c ****     sendMessage(statusMsg);
 13300               		.loc 1 2148 0
 13301 4b80 80E0      		ldi r24,lo8(statusMsg)
 13302 4b82 90E0      		ldi r25,hi8(statusMsg)
 13303 4b84 0E94 0000 		call sendMessage
 13304               	.LVL1149:
2149:switcherator.c ****     stopClock();
 13305               		.loc 1 2149 0
 13306 4b88 0E94 0000 		call stopClock
 13307               	.LVL1150:
2150:switcherator.c ****     startClock();
 13308               		.loc 1 2150 0
 13309 4b8c 0E94 0000 		call startClock
 13310               	.LVL1151:
2151:switcherator.c ****     panicMyClockIsNotSet = 0;
 13311               		.loc 1 2151 0
 13312 4b90 1092 0000 		sts panicMyClockIsNotSet,__zero_reg__
2152:switcherator.c ****     if(failCondition == 3) {
 13313               		.loc 1 2152 0
 13314 4b94 8091 0000 		lds r24,failCondition
 13315 4b98 8330      		cpi r24,lo8(3)
 13316 4b9a 01F4      		brne .L886
 13317               	/* epilogue start */
2155:switcherator.c **** }
 13318               		.loc 1 2155 0
 13319 4b9c DF91      		pop r29
 13320 4b9e CF91      		pop r28
 13321               	.LVL1152:
 13322 4ba0 1F91      		pop r17
 13323 4ba2 0F91      		pop r16
 13324 4ba4 FF90      		pop r15
 13325 4ba6 EF90      		pop r14
 13326 4ba8 DF90      		pop r13
 13327 4baa CF90      		pop r12
 13328 4bac BF90      		pop r11
 13329               	.LVL1153:
 13330 4bae AF90      		pop r10
 13331 4bb0 9F90      		pop r9
 13332 4bb2 8F90      		pop r8
 13333 4bb4 7F90      		pop r7
 13334 4bb6 6F90      		pop r6
2153:switcherator.c ****         clearFail();      
 13335               		.loc 1 2153 0
 13336 4bb8 0C94 0000 		jmp clearFail
 13337               	.LVL1154:
 13338               	.L886:
 13339               	/* epilogue start */
2155:switcherator.c **** }
 13340               		.loc 1 2155 0
 13341 4bbc DF91      		pop r29
 13342 4bbe CF91      		pop r28
 13343               	.LVL1155:
 13344 4bc0 1F91      		pop r17
 13345 4bc2 0F91      		pop r16
 13346 4bc4 FF90      		pop r15
 13347 4bc6 EF90      		pop r14
 13348 4bc8 DF90      		pop r13
 13349 4bca CF90      		pop r12
 13350 4bcc BF90      		pop r11
 13351               	.LVL1156:
 13352 4bce AF90      		pop r10
 13353 4bd0 9F90      		pop r9
 13354 4bd2 8F90      		pop r8
 13355 4bd4 7F90      		pop r7
 13356 4bd6 6F90      		pop r6
 13357 4bd8 0895      		ret
 13358               	.LFE48:
 13360               	.global	checkCommand
 13362               	checkCommand:
 13363               	.LFB8:
 233:switcherator.c **** void checkCommand(char * commandReceived) {
 13364               		.loc 1 233 0
 13365               	.LVL1157:
 13366               	/* prologue: function */
 13367               	/* frame size = 0 */
 13368               	/* stack size = 0 */
 13369               	.L__stack_usage = 0
 234:switcherator.c ****     if (commandReceived[0] > 0x60)
 13370               		.loc 1 234 0
 13371 4bda FC01      		movw r30,r24
 13372 4bdc 2081      		ld r18,Z
 13373 4bde 2136      		cpi r18,lo8(97)
 13374 4be0 00F0      		brlo .L889
 235:switcherator.c ****         commandReceived[0] -= 0x20;
 13375               		.loc 1 235 0
 13376 4be2 2052      		subi r18,lo8(-(-32))
 13377 4be4 2083      		st Z,r18
 13378               	.L889:
 236:switcherator.c ****     if (commandReceived[1] > 0x60)
 13379               		.loc 1 236 0
 13380 4be6 FC01      		movw r30,r24
 13381 4be8 2181      		ldd r18,Z+1
 13382 4bea 2136      		cpi r18,lo8(97)
 13383 4bec 00F0      		brlo .L890
 237:switcherator.c ****         commandReceived[1] -= 0x20;
 13384               		.loc 1 237 0
 13385 4bee 2052      		subi r18,lo8(-(-32))
 13386 4bf0 2183      		std Z+1,r18
 13387               	.L890:
 239:switcherator.c ****     switchme <<= 8;
 13388               		.loc 1 239 0
 13389 4bf2 FC01      		movw r30,r24
 13390 4bf4 3081      		ld r19,Z
 13391 4bf6 20E0      		ldi r18,0
 13392               	.LVL1158:
 240:switcherator.c ****     switchme |= commandReceived[1];
 13393               		.loc 1 240 0
 13394 4bf8 4181      		ldd r20,Z+1
 13395 4bfa 242B      		or r18,r20
 13396               	.LVL1159:
 241:switcherator.c ****     switch (switchme) {
 13397               		.loc 1 241 0
 13398 4bfc 2434      		cpi r18,68
 13399 4bfe F0E5      		ldi r31,80
 13400 4c00 3F07      		cpc r19,r31
 13401 4c02 01F4      		brne .+2
 13402 4c04 00C0      		rjmp .L909
 13403 4c06 04F0      		brlt .+2
 13404 4c08 00C0      		rjmp .L928
 13405 4c0a 2934      		cpi r18,73
 13406 4c0c E4E4      		ldi r30,68
 13407 4c0e 3E07      		cpc r19,r30
 13408 4c10 01F4      		brne .+2
 13409 4c12 00C0      		rjmp .L900
 13410 4c14 04F4      		brge .L929
 13411 4c16 2834      		cpi r18,72
 13412 4c18 43E4      		ldi r20,67
 13413 4c1a 3407      		cpc r19,r20
 13414 4c1c 01F4      		brne .+2
 13415 4c1e 00C0      		rjmp .L895
 13416 4c20 04F4      		brge .L930
 13417 4c22 2335      		cpi r18,83
 13418 4c24 F2E4      		ldi r31,66
 13419 4c26 3F07      		cpc r19,r31
 13420 4c28 01F4      		brne .+2
 13421 4c2a 00C0      		rjmp .L893
 13422 4c2c 2334      		cpi r18,67
 13423 4c2e 43E4      		ldi r20,67
 13424 4c30 3407      		cpc r19,r20
 13425 4c32 01F4      		brne .+2
 13426 4c34 00C0      		rjmp .L894
 13427 4c36 2934      		cpi r18,73
 13428 4c38 3144      		sbci r19,65
 13429 4c3a 01F0      		breq .+2
 13430 4c3c 00C0      		rjmp .L888
 13431 4c3e 00C0      		rjmp .L892
 13432               	.L930:
 13433 4c40 2C34      		cpi r18,76
 13434 4c42 F3E4      		ldi r31,67
 13435 4c44 3F07      		cpc r19,r31
 13436 4c46 01F4      		brne .+2
 13437 4c48 00C0      		rjmp .L897
 13438 4c4a 04F4      		brge .L931
 13439 4c4c 2934      		cpi r18,73
 13440 4c4e 3344      		sbci r19,67
 13441 4c50 01F0      		breq .+2
 13442 4c52 00C0      		rjmp .L888
 13443 4c54 00C0      		rjmp .L896
 13444               	.L931:
 13445 4c56 2035      		cpi r18,80
 13446 4c58 F3E4      		ldi r31,67
 13447 4c5a 3F07      		cpc r19,r31
 13448 4c5c 01F4      		brne .+2
 13449 4c5e 00C0      		rjmp .L898
 13450 4c60 2435      		cpi r18,84
 13451 4c62 3344      		sbci r19,67
 13452 4c64 01F0      		breq .+2
 13453 4c66 00C0      		rjmp .L888
 13454 4c68 00C0      		rjmp .L899
 13455               	.L929:
 13456 4c6a 2436      		cpi r18,100
 13457 4c6c E8E4      		ldi r30,72
 13458 4c6e 3E07      		cpc r19,r30
 13459 4c70 01F4      		brne .+2
 13460 4c72 00C0      		rjmp .L904
 13461 4c74 04F4      		brge .L932
 13462 4c76 2934      		cpi r18,73
 13463 4c78 47E4      		ldi r20,71
 13464 4c7a 3407      		cpc r19,r20
 13465 4c7c 01F4      		brne .+2
 13466 4c7e 00C0      		rjmp .L902
 13467 4c80 2335      		cpi r18,83
 13468 4c82 E7E4      		ldi r30,71
 13469 4c84 3E07      		cpc r19,r30
 13470 4c86 01F4      		brne .+2
 13471 4c88 00C0      		rjmp .L903
 13472 4c8a 2335      		cpi r18,83
 13473 4c8c 3444      		sbci r19,68
 13474 4c8e 01F0      		breq .+2
 13475 4c90 00C0      		rjmp .L888
 13476 4c92 00C0      		rjmp .L901
 13477               	.L932:
 13478 4c94 2035      		cpi r18,80
 13479 4c96 4EE4      		ldi r20,78
 13480 4c98 3407      		cpc r19,r20
 13481 4c9a 01F4      		brne .+2
 13482 4c9c 00C0      		rjmp .L906
 13483 4c9e 04F4      		brge .L933
 13484 4ca0 2035      		cpi r18,80
 13485 4ca2 3944      		sbci r19,73
 13486 4ca4 01F0      		breq .+2
 13487 4ca6 00C0      		rjmp .L888
 13488 4ca8 00C0      		rjmp .L905
 13489               	.L933:
 13490 4caa 2335      		cpi r18,83
 13491 4cac 4EE4      		ldi r20,78
 13492 4cae 3407      		cpc r19,r20
 13493 4cb0 01F4      		brne .+2
 13494 4cb2 00C0      		rjmp .L907
 13495 4cb4 2134      		cpi r18,65
 13496 4cb6 3045      		sbci r19,80
 13497 4cb8 01F0      		breq .+2
 13498 4cba 00C0      		rjmp .L888
 13499 4cbc 00C0      		rjmp .L908
 13500               	.L928:
 13501 4cbe 2134      		cpi r18,65
 13502 4cc0 F3E5      		ldi r31,83
 13503 4cc2 3F07      		cpc r19,r31
 13504 4cc4 01F4      		brne .+2
 13505 4cc6 00C0      		rjmp .L918
 13506 4cc8 04F4      		brge .L934
 13507 4cca 2435      		cpi r18,84
 13508 4ccc E0E5      		ldi r30,80
 13509 4cce 3E07      		cpc r19,r30
 13510 4cd0 01F4      		brne .+2
 13511 4cd2 00C0      		rjmp .L913
 13512 4cd4 04F4      		brge .L935
 13513 4cd6 2035      		cpi r18,80
 13514 4cd8 40E5      		ldi r20,80
 13515 4cda 3407      		cpc r19,r20
 13516 4cdc 01F4      		brne .+2
 13517 4cde 00C0      		rjmp .L911
 13518 4ce0 2335      		cpi r18,83
 13519 4ce2 E0E5      		ldi r30,80
 13520 4ce4 3E07      		cpc r19,r30
 13521 4ce6 01F4      		brne .+2
 13522 4ce8 00C0      		rjmp .L912
 13523 4cea 2934      		cpi r18,73
 13524 4cec 3045      		sbci r19,80
 13525 4cee 01F0      		breq .+2
 13526 4cf0 00C0      		rjmp .L888
 13527 4cf2 00C0      		rjmp .L910
 13528               	.L935:
 13529 4cf4 2735      		cpi r18,87
 13530 4cf6 40E5      		ldi r20,80
 13531 4cf8 3407      		cpc r19,r20
 13532 4cfa 01F4      		brne .+2
 13533 4cfc 00C0      		rjmp .L915
 13534 4cfe 04F4      		brge .L936
 13535 4d00 2635      		cpi r18,86
 13536 4d02 3045      		sbci r19,80
 13537 4d04 01F0      		breq .+2
 13538 4d06 00C0      		rjmp .L888
 13539 4d08 00C0      		rjmp .L914
 13540               	.L936:
 13541 4d0a 2334      		cpi r18,67
 13542 4d0c 42E5      		ldi r20,82
 13543 4d0e 3407      		cpc r19,r20
 13544 4d10 01F4      		brne .+2
 13545 4d12 00C0      		rjmp .L916
 13546 4d14 2434      		cpi r18,68
 13547 4d16 3245      		sbci r19,82
 13548 4d18 01F0      		breq .+2
 13549 4d1a 00C0      		rjmp .L888
 13550 4d1c 00C0      		rjmp .L917
 13551               	.L934:
 13552 4d1e 2035      		cpi r18,80
 13553 4d20 F3E5      		ldi r31,83
 13554 4d22 3F07      		cpc r19,r31
 13555 4d24 01F4      		brne .+2
 13556 4d26 00C0      		rjmp .L923
 13557 4d28 04F4      		brge .L937
 13558 4d2a 2334      		cpi r18,67
 13559 4d2c E3E5      		ldi r30,83
 13560 4d2e 3E07      		cpc r19,r30
 13561 4d30 01F0      		breq .L920
 13562 4d32 04F4      		brge .+2
 13563 4d34 00C0      		rjmp .L919
 13564 4d36 2434      		cpi r18,68
 13565 4d38 43E5      		ldi r20,83
 13566 4d3a 3407      		cpc r19,r20
 13567 4d3c 01F0      		breq .L921
 13568 4d3e 2F34      		cpi r18,79
 13569 4d40 3345      		sbci r19,83
 13570               	.LVL1160:
 13571 4d42 01F0      		breq .+2
 13572 4d44 00C0      		rjmp .L888
 13573 4d46 00C0      		rjmp .L922
 13574               	.LVL1161:
 13575               	.L937:
 13576 4d48 2735      		cpi r18,87
 13577 4d4a E3E5      		ldi r30,83
 13578 4d4c 3E07      		cpc r19,r30
 13579 4d4e 01F4      		brne .+2
 13580 4d50 00C0      		rjmp .L925
 13581 4d52 04F4      		brge .L938
 13582 4d54 2335      		cpi r18,83
 13583 4d56 3345      		sbci r19,83
 13584 4d58 01F0      		breq .+2
 13585 4d5a 00C0      		rjmp .L888
 13586 4d5c 00C0      		rjmp .L924
 13587               	.L938:
 13588 4d5e 2934      		cpi r18,73
 13589 4d60 E4E5      		ldi r30,84
 13590 4d62 3E07      		cpc r19,r30
 13591 4d64 01F0      		breq .L926
 13592 4d66 2C34      		cpi r18,76
 13593 4d68 3445      		sbci r19,84
 13594 4d6a 01F0      		breq .+2
 13595 4d6c 00C0      		rjmp .L888
 13596 4d6e 00C0      		rjmp .L927
 13597               	.L926:
 243:switcherator.c ****             setClock(commandReceived);
 13598               		.loc 1 243 0
 13599 4d70 0C94 0000 		jmp setClock
 13600               	.LVL1162:
 13601               	.L901:
 246:switcherator.c ****             setDaylightSavings(commandReceived);
 13602               		.loc 1 246 0
 13603 4d74 0C94 0000 		jmp setDaylightSavings
 13604               	.LVL1163:
 13605               	.L927:
 249:switcherator.c ****             setTimeLimits(commandReceived);
 13606               		.loc 1 249 0
 13607 4d78 0C94 0000 		jmp setTimeLimits
 13608               	.LVL1164:
 13609               	.L907:
 252:switcherator.c ****             setNewSwitch(commandReceived);
 13610               		.loc 1 252 0
 13611 4d7c 0C94 0000 		jmp setNewSwitch
 13612               	.LVL1165:
 13613               	.L920:
 255:switcherator.c ****             switchClear(commandReceived);
 13614               		.loc 1 255 0
 13615 4d80 0C94 0000 		jmp switchClear
 13616               	.LVL1166:
 13617               	.L921:
 258:switcherator.c ****             switchDisplay(commandReceived);
 13618               		.loc 1 258 0
 13619 4d84 0C94 0000 		jmp switchDisplay
 13620               	.LVL1167:
 13621               	.L912:
 261:switcherator.c ****             pwmSetup(commandReceived);
 13622               		.loc 1 261 0
 13623 4d88 0C94 0000 		jmp pwmSetup
 13624               	.LVL1168:
 13625               	.L895:
 264:switcherator.c ****             cycleHue(commandReceived);
 13626               		.loc 1 264 0
 13627 4d8c 0C94 0000 		jmp cycleHue
 13628               	.LVL1169:
 13629               	.L904:
 267:switcherator.c ****             setHueSpeed(commandReceived);
 13630               		.loc 1 267 0
 13631 4d90 0C94 0000 		jmp setHueSpeed
 13632               	.LVL1170:
 13633               	.L914:
 270:switcherator.c ****             pwmValueSet(commandReceived);
 13634               		.loc 1 270 0
 13635 4d94 0C94 0000 		jmp pwmValueSet
 13636               	.LVL1171:
 13637               	.L906:
 273:switcherator.c ****             newProgram(commandReceived);
 13638               		.loc 1 273 0
 13639 4d98 0C94 0000 		jmp newProgram
 13640               	.LVL1172:
 13641               	.L898:
 276:switcherator.c ****             clearProgram(commandReceived);
 13642               		.loc 1 276 0
 13643 4d9c 0C94 0000 		jmp clearProgram
 13644               	.LVL1173:
 13645               	.L908:
 279:switcherator.c ****             programAddSwitch(commandReceived);
 13646               		.loc 1 279 0
 13647 4da0 0C94 0000 		jmp programAddSwitch
 13648               	.LVL1174:
 13649               	.L909:
 282:switcherator.c ****             programSetDays(commandReceived);
 13650               		.loc 1 282 0
 13651 4da4 0C94 0000 		jmp programSetDays
 13652               	.LVL1175:
 13653               	.L913:
 285:switcherator.c ****             programSetTime(commandReceived);
 13654               		.loc 1 285 0
 13655 4da8 0C94 0000 		jmp programSetTime
 13656               	.LVL1176:
 13657               	.L910:
 288:switcherator.c ****             programDisplay(commandReceived);
 13658               		.loc 1 288 0
 13659 4dac 0C94 0000 		jmp programDisplay
 13660               	.LVL1177:
 13661               	.L924:
 291:switcherator.c ****             startSwitch(commandReceived);
 13662               		.loc 1 291 0
 13663 4db0 0C94 0000 		jmp startSwitch
 13664               	.LVL1178:
 13665               	.L923:
 294:switcherator.c ****             startProgram(commandReceived);
 13666               		.loc 1 294 0
 13667 4db4 0C94 0000 		jmp startProgram
 13668               	.LVL1179:
 13669               	.L918:
 297:switcherator.c ****             saveToEEPROM();
 13670               		.loc 1 297 0
 13671 4db8 0C94 0000 		jmp saveToEEPROM
 13672               	.LVL1180:
 13673               	.L897:
 300:switcherator.c ****             clearToEEPROM();
 13674               		.loc 1 300 0
 13675 4dbc 0C94 0000 		jmp clearToEEPROM
 13676               	.LVL1181:
 13677               	.L917:
 303:switcherator.c ****             radioDisplayAddress(commandReceived);
 13678               		.loc 1 303 0
 13679 4dc0 0C94 0000 		jmp radioDisplayAddress
 13680               	.LVL1182:
 13681               	.L916:
 306:switcherator.c ****             radioChangeAddress(commandReceived);
 13682               		.loc 1 306 0
 13683 4dc4 0C94 0000 		jmp radioChangeAddress
 13684               	.LVL1183:
 13685               	.L892:
 309:switcherator.c ****             setAnalogInput(commandReceived);
 13686               		.loc 1 309 0
 13687 4dc8 0C94 0000 		jmp setAnalogInput
 13688               	.LVL1184:
 13689               	.L900:
 312:switcherator.c ****             setDigitalInput(commandReceived);
 13690               		.loc 1 312 0
 13691 4dcc 0C94 0000 		jmp setDigitalInput
 13692               	.LVL1185:
 13693               	.L896:
 315:switcherator.c ****             clearInput(commandReceived);
 13694               		.loc 1 315 0
 13695 4dd0 0C94 0000 		jmp clearInput
 13696               	.LVL1186:
 13697               	.L899:
 318:switcherator.c ****             clockTweak(commandReceived);
 13698               		.loc 1 318 0
 13699 4dd4 0C94 0000 		jmp clockTweak
 13700               	.LVL1187:
 13701               	.L915:
 321:switcherator.c ****             pwmSummary();
 13702               		.loc 1 321 0
 13703 4dd8 0C94 0000 		jmp pwmSummary
 13704               	.LVL1188:
 13705               	.L903:
 327:switcherator.c ****             generalStatus(commandReceived);
 13706               		.loc 1 327 0
 13707 4ddc 0C94 0000 		jmp generalStatus
 13708               	.LVL1189:
 13709               	.L894:
 333:switcherator.c ****             colorChangeSet(commandReceived);
 13710               		.loc 1 333 0
 13711 4de0 0C94 0000 		jmp colorChangeSet
 13712               	.LVL1190:
 13713               	.L919:
 336:switcherator.c ****             switchBrightness(commandReceived);
 13714               		.loc 1 336 0
 13715 4de4 0C94 0000 		jmp switchBrightness
 13716               	.LVL1191:
 13717               	.L893:
 339:switcherator.c ****             brightnessSet(commandReceived);
 13718               		.loc 1 339 0
 13719 4de8 0C94 0000 		jmp brightnessSet
 13720               	.LVL1192:
 13721               	.L902:
 342:switcherator.c ****             generalInformation();
 13722               		.loc 1 342 0
 13723 4dec 0C94 0000 		jmp generalInformation
 13724               	.LVL1193:
 13725               	.L911:
 345:switcherator.c ****             programsProgrammed();
 13726               		.loc 1 345 0
 13727 4df0 0C94 0000 		jmp programsProgrammed
 13728               	.LVL1194:
 13729               	.L925:
 348:switcherator.c ****             switchesProgrammed();
 13730               		.loc 1 348 0
 13731 4df4 0C94 0000 		jmp switchesProgrammed
 13732               	.LVL1195:
 13733               	.L905:
 351:switcherator.c ****             inputsProgrammed();
 13734               		.loc 1 351 0
 13735 4df8 0C94 0000 		jmp inputsProgrammed
 13736               	.LVL1196:
 13737               	.L922:
 354:switcherator.c ****             switchesOn();
 13738               		.loc 1 354 0
 13739 4dfc 0C94 0000 		jmp switchesOn
 13740               	.LVL1197:
 13741               	.L888:
 13742 4e00 0895      		ret
 13743               	.LFE8:
 13745               		.section	.rodata.str1.1
 13746               	.LC73:
 13747 0170 6773 7100 		.string	"gsq"
 13748               		.section	.text.startup,"ax",@progbits
 13749               	.global	main
 13751               	main:
 13752               	.LFB7:
 121:switcherator.c **** int main(void) {
 13753               		.loc 1 121 0
 13754               	/* prologue: function */
 13755               	/* frame size = 0 */
 13756               	/* stack size = 0 */
 13757               	.L__stack_usage = 0
 122:switcherator.c ****     receiveBuffer[0] = 0;
 13758               		.loc 1 122 0
 13759 0000 1092 0000 		sts receiveBuffer,__zero_reg__
 123:switcherator.c ****     radioReceiveBuffer[0] = 0;
 13760               		.loc 1 123 0
 13761 0004 1092 0000 		sts radioReceiveBuffer,__zero_reg__
 13762               	.LVL1198:
 126:switcherator.c ****     INDICATOR_DDR |= INDICATOR_PIN;
 13763               		.loc 1 126 0
 13764 0008 529A      		sbi 0xa,2
 13765 000a 84E0      		ldi r24,lo8(4)
 13766 000c 90E0      		ldi r25,0
 13767               	.LVL1199:
 13768               	.L940:
 128:switcherator.c ****         INDICATOR_PORT |= INDICATOR_PIN;
 13769               		.loc 1 128 0 discriminator 2
 13770 000e 5A9A      		sbi 0xb,2
 13771               	.LVL1200:
 13772               	.LBB30:
 13773               	.LBB31:
 164:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 13774               		.loc 2 164 0 discriminator 2
 13775 0010 2FEF      		ldi r18,lo8(159999)
 13776 0012 30E7      		ldi r19,hi8(159999)
 13777 0014 42E0      		ldi r20,hlo8(159999)
 13778 0016 2150      		1: subi r18,1
 13779 0018 3040      		sbci r19,0
 13780 001a 4040      		sbci r20,0
 13781 001c 01F4      		brne 1b
 13782 001e 00C0      		rjmp .
 13783 0020 0000      		nop
 13784               	.LBE31:
 13785               	.LBE30:
 130:switcherator.c ****         INDICATOR_PORT &= ~(INDICATOR_PIN);
 13786               		.loc 1 130 0 discriminator 2
 13787 0022 5A98      		cbi 0xb,2
 13788               	.LVL1201:
 13789               	.LBB32:
 13790               	.LBB33:
 164:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 13791               		.loc 2 164 0 discriminator 2
 13792 0024 2FEF      		ldi r18,lo8(319999)
 13793 0026 31EE      		ldi r19,hi8(319999)
 13794 0028 44E0      		ldi r20,hlo8(319999)
 13795 002a 2150      		1: subi r18,1
 13796 002c 3040      		sbci r19,0
 13797 002e 4040      		sbci r20,0
 13798 0030 01F4      		brne 1b
 13799 0032 00C0      		rjmp .
 13800 0034 0000      		nop
 13801 0036 0197      		sbiw r24,1
 13802               	.LBE33:
 13803               	.LBE32:
 127:switcherator.c ****     for (x = 0; x < 4; x++) {
 13804               		.loc 1 127 0 discriminator 2
 13805 0038 01F4      		brne .L940
 133:switcherator.c ****     INDICATOR_PORT |= INDICATOR_PIN;
 13806               		.loc 1 133 0
 13807 003a 5A9A      		sbi 0xb,2
 13808               	.LVL1202:
 13809 003c E0E0      		ldi r30,lo8(colorChanges+2)
 13810 003e F0E0      		ldi r31,hi8(colorChanges+2)
 139:switcherator.c ****         colorChanges[x][1] = 1;
 13811               		.loc 1 139 0
 13812 0040 81E0      		ldi r24,lo8(1)
 13813               	.LVL1203:
 13814               	.L941:
 121:switcherator.c **** int main(void) {
 13815               		.loc 1 121 0 discriminator 2
 13816 0042 DF01      		movw r26,r30
 13817 0044 1297      		sbiw r26,2
 138:switcherator.c ****         colorChanges[x][0] = 0;
 13818               		.loc 1 138 0 discriminator 2
 13819 0046 1C92      		st X,__zero_reg__
 121:switcherator.c **** int main(void) {
 13820               		.loc 1 121 0 discriminator 2
 13821 0048 DF01      		movw r26,r30
 13822 004a 1197      		sbiw r26,1
 139:switcherator.c ****         colorChanges[x][1] = 1;
 13823               		.loc 1 139 0 discriminator 2
 13824 004c 8C93      		st X,r24
 140:switcherator.c ****         colorChanges[x][2] = 0;
 13825               		.loc 1 140 0 discriminator 2
 13826 004e 1082      		st Z,__zero_reg__
 13827 0050 3396      		adiw r30,3
 137:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 13828               		.loc 1 137 0 discriminator 2
 13829 0052 90E0      		ldi r25,hi8(colorChanges+20)
 13830 0054 E030      		cpi r30,lo8(colorChanges+20)
 13831 0056 F907      		cpc r31,r25
 13832 0058 01F4      		brne .L941
 144:switcherator.c ****     globalYear = globalMonth = globalDay = globalHour = globalMinute = globalSecond = dow = 0;
 13833               		.loc 1 144 0
 13834 005a 1092 0000 		sts dow+1,__zero_reg__
 13835 005e 1092 0000 		sts dow,__zero_reg__
 13836 0062 1092 0000 		sts globalSecond+1,__zero_reg__
 13837 0066 1092 0000 		sts globalSecond,__zero_reg__
 13838 006a 1092 0000 		sts globalMinute+1,__zero_reg__
 13839 006e 1092 0000 		sts globalMinute,__zero_reg__
 13840 0072 1092 0000 		sts globalHour+1,__zero_reg__
 13841 0076 1092 0000 		sts globalHour,__zero_reg__
 13842 007a 1092 0000 		sts globalDay+1,__zero_reg__
 13843 007e 1092 0000 		sts globalDay,__zero_reg__
 13844 0082 1092 0000 		sts globalMonth+1,__zero_reg__
 13845 0086 1092 0000 		sts globalMonth,__zero_reg__
 13846 008a 1092 0000 		sts globalYear+1,__zero_reg__
 13847 008e 1092 0000 		sts globalYear,__zero_reg__
 13848               	.LVL1204:
 13849 0092 E0E0      		ldi r30,lo8(switchStatus)
 13850 0094 F0E0      		ldi r31,hi8(switchStatus)
 13851 0096 C0E0      		ldi r28,lo8(switchStuff)
 13852 0098 D0E0      		ldi r29,hi8(switchStuff)
 13853 009a A0E0      		ldi r26,lo8(switchBright)
 13854 009c B0E0      		ldi r27,hi8(switchBright)
 147:switcherator.c ****         switchStuff[x] = 255;
 13855               		.loc 1 147 0
 13856 009e 2FEF      		ldi r18,lo8(-1)
 148:switcherator.c ****         switchBright[x] = 16;
 13857               		.loc 1 148 0
 13858 00a0 90E1      		ldi r25,lo8(16)
 13859               	.LVL1205:
 13860               	.L942:
 146:switcherator.c ****         switchStatus[x] = 0;
 13861               		.loc 1 146 0 discriminator 2
 13862 00a2 1192      		st Z+,__zero_reg__
 13863 00a4 1192      		st Z+,__zero_reg__
 13864 00a6 1192      		st Z+,__zero_reg__
 13865 00a8 1192      		st Z+,__zero_reg__
 147:switcherator.c ****         switchStuff[x] = 255;
 13866               		.loc 1 147 0 discriminator 2
 13867 00aa 8FEF      		ldi r24,lo8(-1)
 13868 00ac 2993      		st Y+,r18
 148:switcherator.c ****         switchBright[x] = 16;
 13869               		.loc 1 148 0 discriminator 2
 13870 00ae 9D93      		st X+,r25
 145:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 13871               		.loc 1 145 0 discriminator 2
 13872 00b0 30E0      		ldi r19,hi8(switchStatus+64)
 13873 00b2 E030      		cpi r30,lo8(switchStatus+64)
 13874 00b4 F307      		cpc r31,r19
 13875 00b6 01F4      		brne .L942
 13876               	.LVL1206:
 151:switcherator.c ****         inputs[x][0] = 255;
 13877               		.loc 1 151 0 discriminator 1
 13878 00b8 8093 0000 		sts inputs,r24
 13879               	.LVL1207:
 13880 00bc 8093 0000 		sts inputs+8,r24
 13881               	.LVL1208:
 13882 00c0 8093 0000 		sts inputs+16,r24
 13883               	.LVL1209:
 13884 00c4 8093 0000 		sts inputs+24,r24
 13885               	.LVL1210:
 153:switcherator.c ****     sei();
 13886               		.loc 1 153 0 discriminator 1
 13887               	/* #APP */
 13888               	 ;  153 "switcherator.c" 1
 13889 00c8 7894      		sei
 13890               	 ;  0 "" 2
 13891               	.LVL1211:
 156:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 13892               		.loc 1 156 0 discriminator 1
 13893               	/* #NOAPP */
 13894 00ca C0E0      		ldi r28,0
 13895 00cc D0E0      		ldi r29,0
 13896               	.LVL1212:
 13897               	.L943:
 157:switcherator.c ****         clearTheProgram(x);
 13898               		.loc 1 157 0 discriminator 2
 13899 00ce CE01      		movw r24,r28
 13900 00d0 0E94 0000 		call clearTheProgram
 13901               	.LVL1213:
 156:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 13902               		.loc 1 156 0 discriminator 2
 13903 00d4 2196      		adiw r28,1
 13904               	.LVL1214:
 13905 00d6 C431      		cpi r28,20
 13906 00d8 D105      		cpc r29,__zero_reg__
 13907 00da 01F4      		brne .L943
 162:switcherator.c ****     clockInit();
 13908               		.loc 1 162 0
 13909 00dc 0E94 0000 		call clockInit
 13910               	.LVL1215:
 163:switcherator.c ****     radioInit();
 13911               		.loc 1 163 0
 13912 00e0 0E94 0000 		call radioInit
 13913               	.LVL1216:
 164:switcherator.c ****     startRx();
 13914               		.loc 1 164 0
 13915 00e4 0E94 0000 		call startRx
 13916               	.LVL1217:
 166:switcherator.c ****     generalInit();
 13917               		.loc 1 166 0
 13918 00e8 0E94 0000 		call generalInit
 13919               	.LVL1218:
 167:switcherator.c ****     startClock();
 13920               		.loc 1 167 0
 13921 00ec 0E94 0000 		call startClock
 13922               	.LVL1219:
 13923               	.L967:
 178:switcherator.c ****         if (newSecond == 1) {
 13924               		.loc 1 178 0
 13925 00f0 8091 0000 		lds r24,newSecond
 13926 00f4 8130      		cpi r24,lo8(1)
 13927 00f6 01F4      		brne .L944
 179:switcherator.c ****             newSecond = 0;
 13928               		.loc 1 179 0
 13929 00f8 1092 0000 		sts newSecond,__zero_reg__
 180:switcherator.c ****             timerCheck();
 13930               		.loc 1 180 0
 13931 00fc 0E94 0000 		call timerCheck
 13932               	.LVL1220:
 181:switcherator.c ****             inputCheck();
 13933               		.loc 1 181 0
 13934 0100 0E94 0000 		call inputCheck
 13935               	.LVL1221:
 13936               	.L944:
 184:switcherator.c ****         if (switchChanged == 1) {
 13937               		.loc 1 184 0
 13938 0104 8091 0000 		lds r24,switchChanged
 13939 0108 8130      		cpi r24,lo8(1)
 13940 010a 01F4      		brne .L945
 185:switcherator.c ****             switchChanged = 0;
 13941               		.loc 1 185 0
 13942 010c 1092 0000 		sts switchChanged,__zero_reg__
 186:switcherator.c ****             switchOnOff();
 13943               		.loc 1 186 0
 13944 0110 0E94 0000 		call switchOnOff
 13945               	.LVL1222:
 13946               	.L945:
 188:switcherator.c ****         if (runHue == 1) {
 13947               		.loc 1 188 0
 13948 0114 8091 0000 		lds r24,runHue
 13949 0118 8130      		cpi r24,lo8(1)
 13950 011a 01F4      		brne .L946
 189:switcherator.c ****             runHueFunction();
 13951               		.loc 1 189 0
 13952 011c 0E94 0000 		call runHueFunction
 13953               	.LVL1223:
 13954               	.L946:
 191:switcherator.c ****         if (runColorChanges == 1) {
 13955               		.loc 1 191 0
 13956 0120 C091 0000 		lds r28,runColorChanges
 13957 0124 C130      		cpi r28,lo8(1)
 13958 0126 01F4      		brne .L947
 192:switcherator.c ****             runColorFunction();
 13959               		.loc 1 192 0
 13960 0128 0E94 0000 		call runColorFunction
 13961               	.LVL1224:
 13962               	.L947:
 194:switcherator.c ****         if (tenthFlag == 1) {
 13963               		.loc 1 194 0
 13964 012c 8091 0000 		lds r24,tenthFlag
 13965 0130 8130      		cpi r24,lo8(1)
 13966 0132 01F4      		brne .L949
 195:switcherator.c ****             tenthFlag = 0;
 13967               		.loc 1 195 0
 13968 0134 1092 0000 		sts tenthFlag,__zero_reg__
 196:switcherator.c ****             inputTenthCheck();
 13969               		.loc 1 196 0
 13970 0138 0E94 0000 		call inputTenthCheck
 13971               	.LVL1225:
 197:switcherator.c ****             if (failCondition > 0) {
 13972               		.loc 1 197 0
 13973 013c 8091 0000 		lds r24,failCondition
 13974 0140 8111      		cpse r24,__zero_reg__
 198:switcherator.c ****                 flashFail();
 13975               		.loc 1 198 0
 13976 0142 0E94 0000 		call flashFail
 13977               	.LVL1226:
 13978               	.L950:
 200:switcherator.c ****             if (runColorChanges == 1) {
 13979               		.loc 1 200 0
 13980 0146 C130      		cpi r28,lo8(1)
 13981 0148 01F4      		brne .L949
 201:switcherator.c ****                 runColorFunction();
 13982               		.loc 1 201 0
 13983 014a 0E94 0000 		call runColorFunction
 13984               	.LVL1227:
 13985               	.L949:
 204:switcherator.c ****         if (newMinute == 1) {
 13986               		.loc 1 204 0
 13987 014e 8091 0000 		lds r24,newMinute
 13988 0152 8130      		cpi r24,lo8(1)
 13989 0154 01F4      		brne .L952
 205:switcherator.c ****             newMinute = 0;
 13990               		.loc 1 205 0
 13991 0156 1092 0000 		sts newMinute,__zero_reg__
 206:switcherator.c ****             if (panicMyClockIsNotSet == 1) {
 13992               		.loc 1 206 0
 13993 015a 8091 0000 		lds r24,panicMyClockIsNotSet
 13994 015e 8130      		cpi r24,lo8(1)
 13995 0160 01F4      		brne .L953
 207:switcherator.c ****                 generalStatus("gsq");
 13996               		.loc 1 207 0
 13997 0162 80E0      		ldi r24,lo8(.LC73)
 13998 0164 90E0      		ldi r25,hi8(.LC73)
 13999 0166 0E94 0000 		call generalStatus
 14000               	.LVL1228:
 14001               	.L953:
 209:switcherator.c ****             radioTest();
 14002               		.loc 1 209 0
 14003 016a 0E94 0000 		call radioTest
 14004               	.LVL1229:
 14005               	.L952:
 212:switcherator.c ****         payloadLength = dynReceive(radioReceiveBuffer);
 14006               		.loc 1 212 0
 14007 016e 80E0      		ldi r24,lo8(radioReceiveBuffer)
 14008 0170 90E0      		ldi r25,hi8(radioReceiveBuffer)
 14009 0172 0E94 0000 		call dynReceive
 14010               	.LVL1230:
 14011 0176 90E0      		ldi r25,0
 213:switcherator.c ****         if (payloadLength > 1) {
 14012               		.loc 1 213 0
 14013 0178 0297      		sbiw r24,2
 14014 017a 04F4      		brge .+2
 14015 017c 00C0      		rjmp .L967
 14016               	.LVL1231:
 14017               	.LBB34:
 14018               	.LBB35:
 164:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 14019               		.loc 2 164 0
 14020 017e 4FEF      		ldi r20,lo8(287999)
 14021 0180 84E6      		ldi r24,hi8(287999)
 14022 0182 94E0      		ldi r25,hlo8(287999)
 14023 0184 4150      		1: subi r20,1
 14024 0186 8040      		sbci r24,0
 14025 0188 9040      		sbci r25,0
 14026 018a 01F4      		brne 1b
 14027               	.LVL1232:
 14028 018c 00C0      		rjmp .
 14029 018e 0000      		nop
 14030               	.LBE35:
 14031               	.LBE34:
 216:switcherator.c ****             checkCommand(radioReceiveBuffer);
 14032               		.loc 1 216 0
 14033 0190 80E0      		ldi r24,lo8(radioReceiveBuffer)
 14034 0192 90E0      		ldi r25,hi8(radioReceiveBuffer)
 14035 0194 0E94 0000 		call checkCommand
 14036               	.LVL1233:
 14037 0198 E0E0      		ldi r30,lo8(radioReceiveBuffer)
 14038 019a F0E0      		ldi r31,hi8(radioReceiveBuffer)
 14039 019c A0E0      		ldi r26,lo8(receiveBuffer)
 14040 019e B0E0      		ldi r27,hi8(receiveBuffer)
 14041               	.LVL1234:
 14042               	.L955:
 220:switcherator.c ****                 radioReceiveBuffer[x] = 0;
 14043               		.loc 1 220 0 discriminator 2
 14044 01a0 1192      		st Z+,__zero_reg__
 221:switcherator.c ****                 receiveBuffer[x] = 0;
 14045               		.loc 1 221 0 discriminator 2
 14046 01a2 1D92      		st X+,__zero_reg__
 219:switcherator.c ****             for (x = 0; x < 30; x++) {
 14047               		.loc 1 219 0 discriminator 2
 14048 01a4 20E0      		ldi r18,hi8(radioReceiveBuffer+30)
 14049 01a6 E030      		cpi r30,lo8(radioReceiveBuffer+30)
 14050 01a8 F207      		cpc r31,r18
 14051 01aa 01F4      		brne .L955
 14052 01ac 00C0      		rjmp .L967
 14053               	.LFE7:
 14055               		.text
 14056               	.global	__vector_11
 14058               	__vector_11:
 14059               	.LFB85:
3718:switcherator.c **** }
3719:switcherator.c **** 
3720:switcherator.c **** ISR(TIMER1_COMPA_vect) {
 14060               		.loc 1 3720 0
 14061 4e02 1F92      		push r1
 14062               	.LCFI375:
 14063 4e04 0F92      		push r0
 14064               	.LCFI376:
 14065 4e06 0FB6      		in r0,__SREG__
 14066 4e08 0F92      		push r0
 14067 4e0a 1124      		clr __zero_reg__
 14068 4e0c 2F93      		push r18
 14069               	.LCFI377:
 14070 4e0e 3F93      		push r19
 14071               	.LCFI378:
 14072 4e10 4F93      		push r20
 14073               	.LCFI379:
 14074 4e12 5F93      		push r21
 14075               	.LCFI380:
 14076 4e14 6F93      		push r22
 14077               	.LCFI381:
 14078 4e16 7F93      		push r23
 14079               	.LCFI382:
 14080 4e18 8F93      		push r24
 14081               	.LCFI383:
 14082 4e1a 9F93      		push r25
 14083               	.LCFI384:
 14084 4e1c AF93      		push r26
 14085               	.LCFI385:
 14086 4e1e BF93      		push r27
 14087               	.LCFI386:
 14088 4e20 EF93      		push r30
 14089               	.LCFI387:
 14090 4e22 FF93      		push r31
 14091               	.LCFI388:
 14092               	/* prologue: Signal */
 14093               	/* frame size = 0 */
 14094               	/* stack size = 15 */
 14095               	.L__stack_usage = 15
3721:switcherator.c ****     int tenthTicks;
3722:switcherator.c ****     ticks++;
 14096               		.loc 1 3722 0
 14097 4e24 4091 0000 		lds r20,ticks
 14098 4e28 5091 0000 		lds r21,ticks+1
 14099 4e2c 4F5F      		subi r20,-1
 14100 4e2e 5F4F      		sbci r21,-1
 14101 4e30 5093 0000 		sts ticks+1,r21
 14102 4e34 4093 0000 		sts ticks,r20
3723:switcherator.c ****     // if its been a second
3724:switcherator.c ****     if (ticks >= tweakTimer) {
 14103               		.loc 1 3724 0
 14104 4e38 60E0      		ldi r22,0
 14105 4e3a 70E0      		ldi r23,0
 14106 4e3c 8091 0000 		lds r24,tweakTimer
 14107 4e40 9091 0000 		lds r25,tweakTimer+1
 14108 4e44 A091 0000 		lds r26,tweakTimer+2
 14109 4e48 B091 0000 		lds r27,tweakTimer+3
 14110 4e4c 4817      		cp r20,r24
 14111 4e4e 5907      		cpc r21,r25
 14112 4e50 6A07      		cpc r22,r26
 14113 4e52 7B07      		cpc r23,r27
 14114 4e54 04F4      		brge .+2
 14115 4e56 00C0      		rjmp .L970
3725:switcherator.c ****         ticks = 0;
 14116               		.loc 1 3725 0
 14117 4e58 1092 0000 		sts ticks+1,__zero_reg__
 14118 4e5c 1092 0000 		sts ticks,__zero_reg__
3726:switcherator.c ****         globalSecond++;
 14119               		.loc 1 3726 0
 14120 4e60 2091 0000 		lds r18,globalSecond
 14121 4e64 3091 0000 		lds r19,globalSecond+1
 14122 4e68 2F5F      		subi r18,-1
 14123 4e6a 3F4F      		sbci r19,-1
 14124 4e6c 3093 0000 		sts globalSecond+1,r19
 14125 4e70 2093 0000 		sts globalSecond,r18
3727:switcherator.c ****         weeklySeconds++;
 14126               		.loc 1 3727 0
 14127 4e74 8091 0000 		lds r24,weeklySeconds
 14128 4e78 9091 0000 		lds r25,weeklySeconds+1
 14129 4e7c A091 0000 		lds r26,weeklySeconds+2
 14130 4e80 B091 0000 		lds r27,weeklySeconds+3
 14131 4e84 0196      		adiw r24,1
 14132 4e86 A11D      		adc r26,__zero_reg__
 14133 4e88 B11D      		adc r27,__zero_reg__
 14134 4e8a 8093 0000 		sts weeklySeconds,r24
 14135 4e8e 9093 0000 		sts weeklySeconds+1,r25
 14136 4e92 A093 0000 		sts weeklySeconds+2,r26
 14137 4e96 B093 0000 		sts weeklySeconds+3,r27
3728:switcherator.c ****         newSecond = 1;
 14138               		.loc 1 3728 0
 14139 4e9a 41E0      		ldi r20,lo8(1)
 14140 4e9c 4093 0000 		sts newSecond,r20
3729:switcherator.c ****         if (globalSecond == 60) {
 14141               		.loc 1 3729 0
 14142 4ea0 2C33      		cpi r18,60
 14143 4ea2 3105      		cpc r19,__zero_reg__
 14144 4ea4 01F4      		brne .L970
3730:switcherator.c ****             globalMinute++;
 14145               		.loc 1 3730 0
 14146 4ea6 8091 0000 		lds r24,globalMinute
 14147 4eaa 9091 0000 		lds r25,globalMinute+1
 14148 4eae 0196      		adiw r24,1
 14149 4eb0 9093 0000 		sts globalMinute+1,r25
 14150 4eb4 8093 0000 		sts globalMinute,r24
3731:switcherator.c ****             globalSecond = 0;
 14151               		.loc 1 3731 0
 14152 4eb8 1092 0000 		sts globalSecond+1,__zero_reg__
 14153 4ebc 1092 0000 		sts globalSecond,__zero_reg__
3732:switcherator.c ****             newMinute = 1;
 14154               		.loc 1 3732 0
 14155 4ec0 4093 0000 		sts newMinute,r20
3733:switcherator.c ****             if (globalMinute == 60) {
 14156               		.loc 1 3733 0
 14157 4ec4 CC97      		sbiw r24,60
 14158 4ec6 01F4      		brne .L970
3734:switcherator.c ****                 globalHour++;
 14159               		.loc 1 3734 0
 14160 4ec8 8091 0000 		lds r24,globalHour
 14161 4ecc 9091 0000 		lds r25,globalHour+1
 14162 4ed0 0196      		adiw r24,1
 14163 4ed2 9093 0000 		sts globalHour+1,r25
 14164 4ed6 8093 0000 		sts globalHour,r24
3735:switcherator.c ****                 globalMinute = 0;
 14165               		.loc 1 3735 0
 14166 4eda 1092 0000 		sts globalMinute+1,__zero_reg__
 14167 4ede 1092 0000 		sts globalMinute,__zero_reg__
3736:switcherator.c ****                 // daylight savings is always at 3am
3737:switcherator.c ****                 if (globalHour == 3)
 14168               		.loc 1 3737 0
 14169 4ee2 0397      		sbiw r24,3
 14170 4ee4 01F4      		brne .L972
3738:switcherator.c ****                     checkDaylightSavings();
 14171               		.loc 1 3738 0
 14172 4ee6 0E94 0000 		call checkDaylightSavings
 14173               	.LVL1235:
 14174               	.L972:
3739:switcherator.c ****                 if (globalHour == 24) {
 14175               		.loc 1 3739 0
 14176 4eea 8091 0000 		lds r24,globalHour
 14177 4eee 9091 0000 		lds r25,globalHour+1
 14178 4ef2 4897      		sbiw r24,24
 14179 4ef4 01F4      		brne .L970
3740:switcherator.c ****                     globalHour = 0;
 14180               		.loc 1 3740 0
 14181 4ef6 1092 0000 		sts globalHour+1,__zero_reg__
 14182 4efa 1092 0000 		sts globalHour,__zero_reg__
3741:switcherator.c ****                     advanceDay();
 14183               		.loc 1 3741 0
 14184 4efe 0E94 0000 		call advanceDay
 14185               	.LVL1236:
 14186               	.L970:
3742:switcherator.c ****                 }
3743:switcherator.c ****             }
3744:switcherator.c ****         }
3745:switcherator.c ****     }
3746:switcherator.c ****     tenthTicks = ticks % TIMER_TENTH;
 14187               		.loc 1 3746 0
 14188 4f02 8091 0000 		lds r24,ticks
 14189 4f06 9091 0000 		lds r25,ticks+1
 14190 4f0a 68E1      		ldi r22,lo8(24)
 14191 4f0c 76E0      		ldi r23,lo8(6)
 14192 4f0e 0E94 0000 		call __udivmodhi4
 14193               	.LVL1237:
3747:switcherator.c ****     if (tenthTicks == 0) {
 14194               		.loc 1 3747 0
 14195 4f12 892B      		or r24,r25
 14196 4f14 01F4      		brne .L968
3748:switcherator.c ****         tenthFlag = 1;
 14197               		.loc 1 3748 0
 14198 4f16 81E0      		ldi r24,lo8(1)
 14199               	.LVL1238:
 14200 4f18 8093 0000 		sts tenthFlag,r24
 14201               	.L968:
 14202               	/* epilogue start */
3749:switcherator.c ****         // set flags for whatever functions we want to do every 10th of a second here
3750:switcherator.c ****     }
3751:switcherator.c **** }
 14203               		.loc 1 3751 0
 14204 4f1c FF91      		pop r31
 14205 4f1e EF91      		pop r30
 14206 4f20 BF91      		pop r27
 14207 4f22 AF91      		pop r26
 14208 4f24 9F91      		pop r25
 14209 4f26 8F91      		pop r24
 14210 4f28 7F91      		pop r23
 14211 4f2a 6F91      		pop r22
 14212 4f2c 5F91      		pop r21
 14213 4f2e 4F91      		pop r20
 14214 4f30 3F91      		pop r19
 14215 4f32 2F91      		pop r18
 14216 4f34 0F90      		pop r0
 14217 4f36 0FBE      		out __SREG__,r0
 14218 4f38 0F90      		pop r0
 14219 4f3a 1F90      		pop r1
 14220 4f3c 1895      		reti
 14221               	.LFE85:
 14223               		.local	receiveBuffer
 14224               		.comm	receiveBuffer,30,1
 14225               		.local	radioReceiveBuffer
 14226               		.comm	radioReceiveBuffer,30,1
 14227               		.local	colorChanges
 14228               		.comm	colorChanges,18,1
 14229               		.local	dow
 14230               		.comm	dow,2,1
 14231               		.local	globalSecond
 14232               		.comm	globalSecond,2,1
 14233               		.local	globalMinute
 14234               		.comm	globalMinute,2,1
 14235               		.local	globalHour
 14236               		.comm	globalHour,2,1
 14237               		.local	globalDay
 14238               		.comm	globalDay,2,1
 14239               		.local	globalMonth
 14240               		.comm	globalMonth,2,1
 14241               		.local	globalYear
 14242               		.comm	globalYear,2,1
 14243               		.local	switchStatus
 14244               		.comm	switchStatus,64,1
 14245               		.local	switchStuff
 14246               		.comm	switchStuff,16,1
 14247               		.local	switchBright
 14248               		.comm	switchBright,16,1
 14249               		.local	inputs
 14250               		.comm	inputs,32,1
 14251               		.local	newSecond
 14252               		.comm	newSecond,1,1
 14253               		.local	switchChanged
 14254               		.comm	switchChanged,1,1
 14255               		.local	runHue
 14256               		.comm	runHue,1,1
 14257               		.local	runColorChanges
 14258               		.comm	runColorChanges,1,1
 14259               		.local	tenthFlag
 14260               		.comm	tenthFlag,1,1
 14261               		.data
 14264               	failCondition:
 14265 0000 03        		.byte	3
 14266               		.local	newMinute
 14267               		.comm	newMinute,1,1
 14270               	panicMyClockIsNotSet:
 14271 0001 01        		.byte	1
 14272               		.local	statusMsg
 14273               		.comm	statusMsg,32,1
 14276               	tempLongString:
 14277 0002 3030 3030 		.string	"0000"
 14277      00
 14280               	tempIntString:
 14281 0007 3030 00   		.string	"00"
 14284               	tempHugeString:
 14285 000a 3030 3030 		.string	"000000"
 14285      3030 00
 14286               		.local	weeklySeconds
 14287               		.comm	weeklySeconds,4,1
 14288               		.local	pwmValues
 14289               		.comm	pwmValues,3,1
 14290               		.local	red
 14291               		.comm	red,2,1
 14292               		.local	green
 14293               		.comm	green,2,1
 14294               		.local	blue
 14295               		.comm	blue,2,1
 14298               	bright:
 14299 0011 1000      		.word	16
 14300               		.local	pwmdir
 14301               		.comm	pwmdir,1,1
 14304               	oldBright:
 14305 0013 10        		.byte	16
 14308               	colorChangeSpeed:
 14309 0014 0A00      		.word	10
 14312               	hueSpeed:
 14313 0016 1000      		.word	16
 14314               		.local	colorChangeCount
 14315               		.comm	colorChangeCount,2,1
 14316               		.local	currentColor
 14317               		.comm	currentColor,1,1
 14318               		.local	littleCount
 14319               		.comm	littleCount,1,1
 14320               		.local	hueCount
 14321               		.comm	hueCount,2,1
 14322               		.local	currentHue
 14323               		.comm	currentHue,2,1
 14324               		.local	weeklyProgram
 14325               		.comm	weeklyProgram,200,1
 14326               		.local	tx_addr
 14327               		.comm	tx_addr,8,1
 14328               		.local	rx_addr_p0
 14329               		.comm	rx_addr_p0,8,1
 14330               		.local	rx_addr_p1
 14331               		.comm	rx_addr_p1,8,1
 14332               		.local	rx_addr_p2
 14333               		.comm	rx_addr_p2,8,1
 14334               		.local	rx_addr_p3
 14335               		.comm	rx_addr_p3,8,1
 14336               		.local	rx_addr_p4
 14337               		.comm	rx_addr_p4,8,1
 14338               		.local	rx_addr_p5
 14339               		.comm	rx_addr_p5,8,1
 14342               	tweakTimer:
 14343 0018 09        		.byte	9
 14344 0019 3D        		.byte	61
 14345 001a 00        		.byte	0
 14346 001b 00        		.byte	0
 14347               		.local	daylightSavings
 14348               		.comm	daylightSavings,8,1
 14349               		.local	timeLimits
 14350               		.comm	timeLimits,48,1
 14351               		.local	wasDaylightSavings
 14352               		.comm	wasDaylightSavings,1,1
 14353               		.local	failTimer
 14354               		.comm	failTimer,1,1
 14355               		.local	ticks
 14356               		.comm	ticks,2,1
 17265               	.Letext0:
 17266               		.file 3 "/usr/lib/gcc/avr/4.7.2/include/stddef.h"
 17267               		.file 4 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/stdint.h"
 17268               		.file 5 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/stdlib.h"
 17269               		.file 6 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/eeprom.h"
 17270               		.file 7 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/string.h"
 17271               		.file 8 "../myavrnrflib/nrf.h"
DEFINED SYMBOLS
                            *ABS*:00000000 switcherator.c
     /tmp/ccFkNBar.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccFkNBar.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccFkNBar.s:4      *ABS*:0000003f __SREG__
     /tmp/ccFkNBar.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccFkNBar.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccFkNBar.s:11     .text:00000000 drawInterface
     /tmp/ccFkNBar.s:24     .text:00000002 getSwitchNumber
     /tmp/ccFkNBar.s:14280  .data:00000007 tempIntString
     /tmp/ccFkNBar.s:49     .text:00000018 getPort
     /tmp/ccFkNBar.s:14244  .bss:0000009c switchStuff
     /tmp/ccFkNBar.s:208    .text:000000bc pwmClear
     /tmp/ccFkNBar.s:14304  .data:00000013 oldBright
     /tmp/ccFkNBar.s:14298  .data:00000011 bright
     /tmp/ccFkNBar.s:14254  .bss:000000de runHue
     /tmp/ccFkNBar.s:14256  .bss:000000df runColorChanges
     /tmp/ccFkNBar.s:257    .text:000000f8 clearTheSwitch
     /tmp/ccFkNBar.s:413    .text:000001be runColorFunction
     /tmp/ccFkNBar.s:14301  .bss:00000110 colorChangeCount
     /tmp/ccFkNBar.s:14308  .data:00000014 colorChangeSpeed
     /tmp/ccFkNBar.s:14315  .bss:00000112 currentColor
     /tmp/ccFkNBar.s:14226  .bss:0000003c colorChanges
     /tmp/ccFkNBar.s:14289  .bss:00000109 red
     /tmp/ccFkNBar.s:14291  .bss:0000010b green
     /tmp/ccFkNBar.s:14293  .bss:0000010d blue
     /tmp/ccFkNBar.s:555    .text:000002ae runHueFunction
     /tmp/ccFkNBar.s:14317  .bss:00000113 littleCount
     /tmp/ccFkNBar.s:14319  .bss:00000114 hueCount
     /tmp/ccFkNBar.s:14312  .data:00000016 hueSpeed
     /tmp/ccFkNBar.s:14321  .bss:00000116 currentHue
     /tmp/ccFkNBar.s:792    .text:00000492 clearTheProgram
     /tmp/ccFkNBar.s:14323  .bss:00000118 weeklyProgram
     /tmp/ccFkNBar.s:838    .text:000004be findOpenSwitch
     /tmp/ccFkNBar.s:889    .text:000004f2 programGetSwitches
     /tmp/ccFkNBar.s:973    .text:00000552 startTheProgram
     /tmp/ccFkNBar.s:14273  .bss:00000102 weeklySeconds
     /tmp/ccFkNBar.s:14242  .bss:0000005c switchStatus
     /tmp/ccFkNBar.s:14252  .bss:000000dd switchChanged
     /tmp/ccFkNBar.s:1148   .text:0000064e readEEPROM
     /tmp/ccFkNBar.s:1238   .text:000006aa writeEEPROM
     /tmp/ccFkNBar.s:1277   .text:000006ca clearEEPROM
     /tmp/ccFkNBar.s:1294   .text:000006d2 clockInit
     /tmp/ccFkNBar.s:1317   .text:000006ec startClock
     /tmp/ccFkNBar.s:1340   .text:00000704 stopClock
     /tmp/ccFkNBar.s:1358   .text:00000710 getWeekday
     /tmp/ccFkNBar.s:14240  .bss:0000005a globalYear
     /tmp/ccFkNBar.s:1469   .text:000007a4 getDayofYear
     /tmp/ccFkNBar.s:1557   .text:0000080a checkDaylightSavings
     /tmp/ccFkNBar.s:14350  .bss:00000250 wasDaylightSavings
     /tmp/ccFkNBar.s:14238  .bss:00000058 globalMonth
     /tmp/ccFkNBar.s:14339  .bss:00000218 daylightSavings
     /tmp/ccFkNBar.s:14236  .bss:00000056 globalDay
     /tmp/ccFkNBar.s:14234  .bss:00000054 globalHour
     /tmp/ccFkNBar.s:1623   .text:0000088e advanceDay
     /tmp/ccFkNBar.s:14228  .bss:0000004e dow
     /tmp/ccFkNBar.s:1810   .text:000009da timerCheck
     /tmp/ccFkNBar.s:2050   .text:00000b42 switchOnOff
     /tmp/ccFkNBar.s:14287  .bss:00000106 pwmValues
     /tmp/ccFkNBar.s:14246  .bss:000000ac switchBright
     /tmp/ccFkNBar.s:2404   .text:00000d40 returnInt
     /tmp/ccFkNBar.s:14284  .data:0000000a tempHugeString
     /tmp/ccFkNBar.s:2468   .text:00000d7c clockString
     /tmp/ccFkNBar.s:14267  .bss:000000e2 statusMsg
     /tmp/ccFkNBar.s:14232  .bss:00000052 globalMinute
     /tmp/ccFkNBar.s:14230  .bss:00000050 globalSecond
     /tmp/ccFkNBar.s:2613   .text:00000e74 returnHex
     /tmp/ccFkNBar.s:2692   .text:00000ed0 returnHexWithout
     /tmp/ccFkNBar.s:2755   .text:00000f16 formatAddress
     /tmp/ccFkNBar.s:2815   .text:00000f50 generalInit
     /tmp/ccFkNBar.s:14325  .bss:000001e0 tx_addr
     /tmp/ccFkNBar.s:14327  .bss:000001e8 rx_addr_p0
     /tmp/ccFkNBar.s:14329  .bss:000001f0 rx_addr_p1
     /tmp/ccFkNBar.s:14331  .bss:000001f8 rx_addr_p2
     /tmp/ccFkNBar.s:14333  .bss:00000200 rx_addr_p3
     /tmp/ccFkNBar.s:14335  .bss:00000208 rx_addr_p4
     /tmp/ccFkNBar.s:14337  .bss:00000210 rx_addr_p5
     /tmp/ccFkNBar.s:14342  .data:00000018 tweakTimer
     /tmp/ccFkNBar.s:14248  .bss:000000bc inputs
     /tmp/ccFkNBar.s:14348  .bss:00000220 timeLimits
     /tmp/ccFkNBar.s:14295  .bss:0000010f pwmdir
     /tmp/ccFkNBar.s:3602   .text:0000147a unformatAddress
     /tmp/ccFkNBar.s:3650   .text:000014a2 getInput
     /tmp/ccFkNBar.s:4654   .text:00001a92 inputTenthCheck
     /tmp/ccFkNBar.s:4714   .text:00001ad0 inputCheck
     /tmp/ccFkNBar.s:4793   .text:00001b32 flashFail
     /tmp/ccFkNBar.s:14352  .bss:00000251 failTimer
     /tmp/ccFkNBar.s:14264  .data:00000000 failCondition
     /tmp/ccFkNBar.s:4904   .text:00001bb0 clearFail
     /tmp/ccFkNBar.s:4922   .text:00001bba sendMessage
     /tmp/ccFkNBar.s:5020   .text:00001c16 radioChangeAddress
     /tmp/ccFkNBar.s:14276  .data:00000002 tempLongString
     /tmp/ccFkNBar.s:5472   .text:00001f26 radioDisplayAddress
     /tmp/ccFkNBar.s:5728   .text:00002106 switchesOn
     /tmp/ccFkNBar.s:5817   .text:00002174 inputsProgrammed
     /tmp/ccFkNBar.s:5902   .text:000021da switchesProgrammed
     /tmp/ccFkNBar.s:5986   .text:0000223e programsProgrammed
     /tmp/ccFkNBar.s:6086   .text:000022ae generalInformation
     /tmp/ccFkNBar.s:6441   .text:000024b4 generalStatus
     /tmp/ccFkNBar.s:14270  .data:00000001 panicMyClockIsNotSet
     /tmp/ccFkNBar.s:6666   .text:000025f4 programDisplay
     /tmp/ccFkNBar.s:7211   .text:000028f8 pwmSummary
     /tmp/ccFkNBar.s:7599   .text:00002b24 switchDisplay
     /tmp/ccFkNBar.s:7752   .text:00002bf2 ok
     /tmp/ccFkNBar.s:7768   .text:00002bfa clearInput
     /tmp/ccFkNBar.s:7877   .text:00002c78 setDaylightSavings
     /tmp/ccFkNBar.s:7984   .text:00002d0a clearToEEPROM
     /tmp/ccFkNBar.s:8145   .text:00002e02 saveToEEPROM
     /tmp/ccFkNBar.s:8805   .text:00003280 pwmValueSet
     /tmp/ccFkNBar.s:8914   .text:00003316 setHueSpeed
     /tmp/ccFkNBar.s:8951   .text:0000333e cycleHue
     /tmp/ccFkNBar.s:8994   .text:00003372 switchClear
     /tmp/ccFkNBar.s:9019   .text:0000337e clockTweak
     /tmp/ccFkNBar.s:9113   .text:00003410 brightnessSet
     /tmp/ccFkNBar.s:9218   .text:000034ae fail
     /tmp/ccFkNBar.s:9269   .text:000034e6 setDigitalInput
     /tmp/ccFkNBar.s:9669   .text:000036ee setAnalogInput
     /tmp/ccFkNBar.s:10145  .text:000039b0 startProgram
     /tmp/ccFkNBar.s:10241  .text:00003a2a programSetTime
     /tmp/ccFkNBar.s:10501  .text:00003b7a programSetDays
     /tmp/ccFkNBar.s:10686  .text:00003c7c programAddSwitch
     /tmp/ccFkNBar.s:10992  .text:00003e1a clearProgram
     /tmp/ccFkNBar.s:11070  .text:00003e6c colorChangeSet
     /tmp/ccFkNBar.s:11192  .text:00003f18 pwmSetup
     /tmp/ccFkNBar.s:11357  .text:00003fe6 startSwitch
     /tmp/ccFkNBar.s:11686  .text:000041d4 setNewSwitch
     /tmp/ccFkNBar.s:11974  .text:00004336 setTimeLimits
     /tmp/ccFkNBar.s:12462  .text:00004620 newProgram
     /tmp/ccFkNBar.s:12734  .text:00004784 switchBrightness
     /tmp/ccFkNBar.s:12879  .text:00004838 radioTest
     /tmp/ccFkNBar.s:12957  .text:000048a6 radioInit
     /tmp/ccFkNBar.s:13119  .text:00004a38 setClock
     /tmp/ccFkNBar.s:13362  .text:00004bda checkCommand
     /tmp/ccFkNBar.s:13751  .text.startup:00000000 main
                             .bss:00000000 receiveBuffer
     /tmp/ccFkNBar.s:14224  .bss:0000001e radioReceiveBuffer
     /tmp/ccFkNBar.s:14250  .bss:000000dc newSecond
     /tmp/ccFkNBar.s:14258  .bss:000000e0 tenthFlag
     /tmp/ccFkNBar.s:14260  .bss:000000e1 newMinute
     /tmp/ccFkNBar.s:14058  .text:00004e02 __vector_11
     /tmp/ccFkNBar.s:14354  .bss:00000252 ticks

UNDEFINED SYMBOLS
atoi
__eerd_word_m328
__eerd_block_m328
__eeupd_block_m328
__eeupd_word_m328
__divmodhi4
__muluhisi3
itoa
strcat
__ashldi3
writeAddr
__lshrdi3
__mulsi3
__umulhisi3
__divmodsi4
__udivmodsi4
stopRx
transmit
startRx
strtol
__udivmodhi4
__cmpdi2_s8
__usmulhisi3
atol
readAddr
__cmpdi2
nrfInit
writeReg
startRadio
dynReceive
__do_copy_data
__do_clear_bss
