   1               		.file	"switcherator.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               	.global	drawInterface
  11               	drawInterface:
  12               	.LFB9:
  13               		.file 1 "switcherator.c"
   1:switcherator.c **** #ifndef __AVR_ATmega328__
   2:switcherator.c **** #define __AVR_ATmega328__
   3:switcherator.c **** #endif
   4:switcherator.c **** #ifndef F_CPU
   5:switcherator.c **** #define F_CPU 16000000
   6:switcherator.c **** #endif
   7:switcherator.c **** 
   8:switcherator.c **** 
   9:switcherator.c **** #include "switcherator.h"
  10:switcherator.c **** 
  11:switcherator.c **** // Uncomment if you want the print variables command available (costs 1K in program memory)
  12:switcherator.c **** // warning - probably way to big.
  13:switcherator.c **** //#define debug
  14:switcherator.c **** //#define help
  15:switcherator.c **** 
  16:switcherator.c **** // globals and such
  17:switcherator.c **** 
  18:switcherator.c **** // First time we are turned on and we have the wrong time
  19:switcherator.c **** static char panicMyClockIsNotSet = 1;
  20:switcherator.c **** 
  21:switcherator.c **** 
  22:switcherator.c **** // clock related
  23:switcherator.c **** static unsigned int ticks = 0; // ticks for the clock
  24:switcherator.c **** static unsigned int globalYear, globalMonth, globalDay, globalHour, globalMinute, globalSecond, dow
  25:switcherator.c **** // dow - Sunday = 0
  26:switcherator.c **** static unsigned long weeklySeconds = 0;
  27:switcherator.c **** // This is 1 on daylight savings day so I don't do it twice
  28:switcherator.c **** static char wasDaylightSavings = 0;
  29:switcherator.c **** static unsigned int daylightSavings[2][2]; // [0][0] = spring month, [0][1] = spring day, etc...
  30:switcherator.c **** 
  31:switcherator.c **** // flags
  32:switcherator.c **** static char newSecond = 0;
  33:switcherator.c **** static char newMinute = 0;
  34:switcherator.c **** static char switchChanged = 0;
  35:switcherator.c **** static char tenthFlag = 0; // 10th of a second(ish) has passed
  36:switcherator.c **** static char failCondition = 3;
  37:switcherator.c **** static char failTimer = 0;
  38:switcherator.c **** #define INDICATOR_PORT PORTD
  39:switcherator.c **** #define INDICATOR_PIN (1 << PIND2)
  40:switcherator.c **** #define INDICATOR_DDR DDRD
  41:switcherator.c **** 
  42:switcherator.c **** // When the switch will turn off (weekly seconds))
  43:switcherator.c **** static unsigned long switchStatus[NUM_SWITCHES];
  44:switcherator.c **** // Coded information for the switches
  45:switcherator.c **** // value of 255 (default) means nothing programmed
  46:switcherator.c **** // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
  47:switcherator.c **** // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
  48:switcherator.c **** // pin is abs(value/2)-the base - PINB3 = (22-16)/2  PINB3 (22-16)%2 = 0 - low (23-16)%2 = 1 - high
  49:switcherator.c **** // 200 = PWM, 201 = PWM rotating hue. PWM always uses PORTD3,PORTD5,PORTD6 for RGB
  50:switcherator.c **** // 202 = Color changing PWM
  51:switcherator.c **** // future - 202 - PWM with other ports. Can't on 328p since radio overlaps pwm pins
  52:switcherator.c **** static char switchStuff[NUM_SWITCHES];
  53:switcherator.c **** 
  54:switcherator.c **** // serial number
  55:switcherator.c **** static char stringSerial[] = "000000";
  56:switcherator.c **** static long serial = 0;
  57:switcherator.c **** 
  58:switcherator.c **** // strings
  59:switcherator.c **** static char receiveBuffer[30];
  60:switcherator.c **** static char radioReceiveBuffer[30];
  61:switcherator.c **** static char tempIntString[] = "00";
  62:switcherator.c **** static char tempLongString[] = "0000";
  63:switcherator.c **** static char tempHugeString[] = "000000";
  64:switcherator.c **** static char statusMsg[32];
  65:switcherator.c **** 
  66:switcherator.c **** // HardwarePWM
  67:switcherator.c **** static char runHue = 0;
  68:switcherator.c **** static char runColorChanges = 0;
  69:switcherator.c **** // PD3, PD5, PD6 or red,green,blue
  70:switcherator.c **** static char pwmValues[] = {0, 0, 0};
  71:switcherator.c **** static char colorChanges[NUM_COLOR_CHANGES][3];
  72:switcherator.c **** 
  73:switcherator.c **** 
  74:switcherator.c **** // rotating hue
  75:switcherator.c **** static unsigned int currentHue = 0;
  76:switcherator.c **** static unsigned int hueSpeed = 16;
  77:switcherator.c **** static unsigned int hueCount = 0;
  78:switcherator.c **** static unsigned char littleCount = 0;
  79:switcherator.c **** static unsigned int colorChangeSpeed = 10; // how many 1/10 seconds in each color change
  80:switcherator.c **** static unsigned int colorChangeCount = 0;
  81:switcherator.c **** static unsigned char currentColor = 0;
  82:switcherator.c **** #define Red OCR2B
  83:switcherator.c **** #define Green OCR0B
  84:switcherator.c **** #define Blue OCR0A
  85:switcherator.c **** static unsigned int red = 0;
  86:switcherator.c **** static unsigned int green = 0;
  87:switcherator.c **** static unsigned int blue = 0;
  88:switcherator.c **** static unsigned int bright = 16;
  89:switcherator.c **** static unsigned char oldBright = 16;
  90:switcherator.c **** static char switchBright[NUM_SWITCHES];
  91:switcherator.c **** static unsigned char pwmdir = 0;
  92:switcherator.c **** 
  93:switcherator.c **** 
  94:switcherator.c **** // programs and such kept in EEPROM
  95:switcherator.c **** // 1 byte day of week mask or 0 for everyday
  96:switcherator.c **** // 2 byte start time (seconds in day), 2 bytes duration (seconds), 1 byte additional program
  97:switcherator.c **** // If more than 4 switches are desired it will roll over to an additional program
  98:switcherator.c **** // DssddSSSSP
  99:switcherator.c **** // 0123456789   
 100:switcherator.c **** static unsigned char weeklyProgram[MAX_PROGRAM][10];
 101:switcherator.c **** 
 102:switcherator.c **** // input information
 103:switcherator.c **** // Pp - value of 255 (default) means nothing programmed
 104:switcherator.c **** // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
 105:switcherator.c **** // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
 106:switcherator.c **** // pin is abs(value/2)-the base - PINB3 = (22-16)/2  PINB3 (22-16)%2 = 0 - low (23-16)%2 = 1 - high
 107:switcherator.c **** // pLHsDDPw Pp int pin/port like sw, L%,H% (0,255 - digital), s - 0-127=switch, 128-255 = prog
 108:switcherator.c **** // dur in seconds, poll time in secs or  0 for continuous. w = which rgb (mask);)
 109:switcherator.c **** static unsigned char inputs[NUM_INPUTS][8];
 110:switcherator.c **** 
 111:switcherator.c **** // Times that the PROGRAMS will react to a switch (eg dusk to dawn)
 112:switcherator.c **** // [0]=start,[1]=stop,[2]=days
 113:switcherator.c **** static unsigned long timeLimits[NUM_LIMITS][3];
 114:switcherator.c **** 
 115:switcherator.c **** 
 116:switcherator.c **** // adjust the timer so it can be accurate
 117:switcherator.c **** static long tweakTimer = TIMER_TOTAL;
 118:switcherator.c **** 
 119:switcherator.c **** 
 120:switcherator.c **** 
 121:switcherator.c **** // send receive addresses
 122:switcherator.c **** static uint64_t rx_addr_p0, rx_addr_p1, rx_addr_p2, rx_addr_p3, rx_addr_p4, rx_addr_p5, tx_addr;
 123:switcherator.c **** 
 124:switcherator.c **** int main(void) {
 125:switcherator.c ****     receiveBuffer[0] = 0;
 126:switcherator.c ****     radioReceiveBuffer[0] = 0;
 127:switcherator.c ****     int x = 0;
 128:switcherator.c **** 
 129:switcherator.c ****     INDICATOR_DDR |= INDICATOR_PIN;
 130:switcherator.c ****     for (x = 0; x < 4; x++) {
 131:switcherator.c ****         INDICATOR_PORT |= INDICATOR_PIN;
 132:switcherator.c ****         _delay_ms(50);
 133:switcherator.c ****         INDICATOR_PORT &= ~(INDICATOR_PIN);
 134:switcherator.c ****         _delay_ms(100);
 135:switcherator.c ****     }
 136:switcherator.c ****     INDICATOR_PORT |= INDICATOR_PIN;
 137:switcherator.c **** 
 138:switcherator.c **** 
 139:switcherator.c ****     // set color changes to blank
 140:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 141:switcherator.c ****         colorChanges[x][0] = 0;
 142:switcherator.c ****         colorChanges[x][1] = 1;
 143:switcherator.c ****         colorChanges[x][2] = 0;
 144:switcherator.c ****     }
 145:switcherator.c **** 
 146:switcherator.c ****     // just initializing memory
 147:switcherator.c ****     globalYear = globalMonth = globalDay = globalHour = globalMinute = globalSecond = dow = 0;
 148:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 149:switcherator.c ****         switchStatus[x] = 0;
 150:switcherator.c ****         switchStuff[x] = 255;
 151:switcherator.c ****         switchBright[x] = 16;
 152:switcherator.c ****     }
 153:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 154:switcherator.c ****         inputs[x][0] = 255;
 155:switcherator.c ****     }
 156:switcherator.c ****     sei();
 157:switcherator.c **** 
 158:switcherator.c ****     // initialize programs
 159:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 160:switcherator.c ****         clearTheProgram(x);
 161:switcherator.c ****     }
 162:switcherator.c **** 
 163:switcherator.c **** 
 164:switcherator.c **** 
 165:switcherator.c ****     clockInit();
 166:switcherator.c ****     radioInit();
 167:switcherator.c ****     startRx();
 168:switcherator.c ****     // make sure general init is after radioinit
 169:switcherator.c ****     generalInit();
 170:switcherator.c ****     startClock();
 171:switcherator.c **** 
 172:switcherator.c **** 
 173:switcherator.c **** 
 174:switcherator.c ****     // radio related
 175:switcherator.c ****     char radioCommand[32];
 176:switcherator.c ****     radioCommand[0] = 0;
 177:switcherator.c ****     char tempRadioSerialIn[] = "000000";
 178:switcherator.c ****     int payloadLength = 0;
 179:switcherator.c **** 
 180:switcherator.c ****     
 181:switcherator.c **** 
 182:switcherator.c ****     while (1) {
 183:switcherator.c ****         // what to run every second
 184:switcherator.c ****         if (newSecond == 1) {
 185:switcherator.c ****             newSecond = 0;
 186:switcherator.c ****             timerCheck();
 187:switcherator.c ****             inputCheck();
 188:switcherator.c ****         }
 189:switcherator.c ****         // runs only if a switch changed
 190:switcherator.c ****         if (switchChanged == 1) {
 191:switcherator.c ****             switchChanged = 0;
 192:switcherator.c ****             switchOnOff();
 193:switcherator.c ****         }
 194:switcherator.c ****         if (runHue == 1) {
 195:switcherator.c ****             runHueFunction();
 196:switcherator.c ****         }
 197:switcherator.c ****         if (runColorChanges == 1) {
 198:switcherator.c ****             runColorFunction();
 199:switcherator.c ****         }
 200:switcherator.c ****         if (tenthFlag == 1) {
 201:switcherator.c ****             tenthFlag = 0;
 202:switcherator.c ****             inputTenthCheck();
 203:switcherator.c ****             if (failCondition > 0) {
 204:switcherator.c ****                 flashFail();
 205:switcherator.c ****             }
 206:switcherator.c ****             if (runColorChanges == 1) {
 207:switcherator.c ****                 runColorFunction();
 208:switcherator.c ****             }
 209:switcherator.c ****         }
 210:switcherator.c ****         if (newMinute == 1) {
 211:switcherator.c ****             newMinute = 0;
 212:switcherator.c ****             if (panicMyClockIsNotSet == 1) {
 213:switcherator.c ****                 generalStatus("gsq");
 214:switcherator.c ****             }
 215:switcherator.c ****             radioTest();
 216:switcherator.c ****         }
 217:switcherator.c ****         // check for radio instructions
 218:switcherator.c ****         payloadLength = dynReceive(radioReceiveBuffer);
 219:switcherator.c ****         if (payloadLength > 2) {
 220:switcherator.c ****             // wait so the receiver won't miss our response
 221:switcherator.c ****             _delay_ms(90);
 222:switcherator.c ****             // just a command to preceed the serial number
 223:switcherator.c ****             if (radioReceiveBuffer[0] == 'z') {
 224:switcherator.c ****                 // radio is sending a serial number to compare to
 225:switcherator.c ****                 for (x = 0; x < 6; x++) {
 226:switcherator.c ****                     tempRadioSerialIn[x] = radioReceiveBuffer[(x + 1)];
 227:switcherator.c ****                 }
 228:switcherator.c ****                 // compare the strings
 229:switcherator.c ****                 if (strcmp(tempRadioSerialIn, stringSerial) == 0) {
 230:switcherator.c ****                     for (x = 7; x < payloadLength; x++) {
 231:switcherator.c ****                         radioCommand[(x - 7)] = radioReceiveBuffer[x];
 232:switcherator.c ****                     }
 233:switcherator.c ****                     // command is from the radio
 234:switcherator.c ****                     checkCommand(radioCommand);
 235:switcherator.c ****                 } // endif - serial doesn't match so ignore it
 236:switcherator.c ****             } else if (radioReceiveBuffer[0] == 'b') { // radio isn't sending a serial number b=bro
 237:switcherator.c ****                 for (x = 1; x < payloadLength; x++) {
 238:switcherator.c ****                     radioCommand[(x - 1)] = radioReceiveBuffer[x];
 239:switcherator.c ****                 }
 240:switcherator.c ****                 // we are only going to set the serial number in a broadcast if we don't have one
 241:switcherator.c ****                 if (strncmp(radioCommand, "SE", 2) == 0 || strncmp(radioCommand, "se", 2) == 0) {
 242:switcherator.c ****                     if (serial == 0) {
 243:switcherator.c ****                         checkCommand(radioCommand);
 244:switcherator.c ****                     }
 245:switcherator.c ****                 } else {
 246:switcherator.c ****                     checkCommand(radioCommand);
 247:switcherator.c ****                 }
 248:switcherator.c ****             }
 249:switcherator.c ****             // nothing we care about so do nothing
 250:switcherator.c ****             for (x = 0; x < 30; x++) {
 251:switcherator.c ****                 radioReceiveBuffer[x] = 0;
 252:switcherator.c ****                 receiveBuffer[x] = 0;
 253:switcherator.c ****                 radioCommand[x] = 0;
 254:switcherator.c ****             }
 255:switcherator.c ****         }
 256:switcherator.c ****     }
 257:switcherator.c **** }
 258:switcherator.c **** 
 259:switcherator.c **** /****************************************************************
 260:switcherator.c ****  *
 261:switcherator.c ****  *              All Things Command and Interface Related
 262:switcherator.c ****  *
 263:switcherator.c ****  ****************************************************************/
 264:switcherator.c **** 
 265:switcherator.c **** void checkCommand(char * commandReceived) {
 266:switcherator.c ****     if (commandReceived[0] > 0x60)
 267:switcherator.c ****         commandReceived[0] -= 0x20;
 268:switcherator.c ****     if (commandReceived[1] > 0x60)
 269:switcherator.c ****         commandReceived[1] -= 0x20;
 270:switcherator.c ****     int switchme = commandReceived[0];
 271:switcherator.c ****     switchme <<= 8;
 272:switcherator.c ****     switchme |= commandReceived[1];
 273:switcherator.c ****     switch (switchme) {
 274:switcherator.c ****         case 0x5449: //TI
 275:switcherator.c ****             setClock(commandReceived);
 276:switcherator.c ****             break;
 277:switcherator.c ****         case 0x4453: //DS
 278:switcherator.c ****             setDaylightSavings(commandReceived);
 279:switcherator.c ****             break;
 280:switcherator.c ****         case 0x544C: //TL
 281:switcherator.c ****             setTimeLimits(commandReceived);
 282:switcherator.c ****             break;
 283:switcherator.c ****         case 0x4E53: //NS
 284:switcherator.c ****             setNewSwitch(commandReceived);
 285:switcherator.c ****             break;
 286:switcherator.c ****         case 0x5343: //SC
 287:switcherator.c ****             switchClear(commandReceived);
 288:switcherator.c ****             break;
 289:switcherator.c ****         case 0x5344: //SD
 290:switcherator.c ****             switchDisplay(commandReceived);
 291:switcherator.c ****             break;
 292:switcherator.c ****         case 0x5053: //PS
 293:switcherator.c ****             pwmSetup(commandReceived);
 294:switcherator.c ****             break;
 295:switcherator.c ****         case 0x4348: //CH
 296:switcherator.c ****             cycleHue(commandReceived);
 297:switcherator.c ****             break;
 298:switcherator.c ****         case 0x4864: //HS
 299:switcherator.c ****             setHueSpeed(commandReceived);
 300:switcherator.c ****             break;
 301:switcherator.c ****         case 0x5056: //PV
 302:switcherator.c ****             pwmValueSet(commandReceived);
 303:switcherator.c ****             break;
 304:switcherator.c ****         case 0x4E50: //NP
 305:switcherator.c ****             newProgram(commandReceived);
 306:switcherator.c ****             break;
 307:switcherator.c ****         case 0x4350: //CP
 308:switcherator.c ****             clearProgram(commandReceived);
 309:switcherator.c ****             break;
 310:switcherator.c ****         case 0x5041: //PA
 311:switcherator.c ****             programAddSwitch(commandReceived);
 312:switcherator.c ****             break;
 313:switcherator.c ****         case 0x5044: //PD
 314:switcherator.c ****             programSetDays(commandReceived);
 315:switcherator.c ****             break;
 316:switcherator.c ****         case 0x5054: //PT
 317:switcherator.c ****             programSetTime(commandReceived);
 318:switcherator.c ****             break;
 319:switcherator.c ****         case 0x5049: //PI
 320:switcherator.c ****             programDisplay(commandReceived);
 321:switcherator.c ****             break;
 322:switcherator.c ****         case 0x5353: //SS
 323:switcherator.c ****             startSwitch(commandReceived);
 324:switcherator.c ****             break;
 325:switcherator.c ****         case 0x5350: //SP
 326:switcherator.c ****             startProgram(commandReceived);
 327:switcherator.c ****             break;
 328:switcherator.c ****         case 0x5345: //SE
 329:switcherator.c ****             serialNumber(commandReceived);
 330:switcherator.c ****             break;
 331:switcherator.c ****         case 0x5341: //SA
 332:switcherator.c ****             saveToEEPROM();
 333:switcherator.c ****             break;
 334:switcherator.c ****         case 0x434C: //CL
 335:switcherator.c ****             clearToEEPROM();
 336:switcherator.c ****             break;
 337:switcherator.c ****         case 0x5244: //RD
 338:switcherator.c ****             radioDisplayAddress(commandReceived);
 339:switcherator.c ****             break;
 340:switcherator.c ****         case 0x5243: //RC
 341:switcherator.c ****             radioChangeAddress(commandReceived);
 342:switcherator.c ****             break;
 343:switcherator.c ****         case 0x4149: //AI
 344:switcherator.c ****             setAnalogInput(commandReceived);
 345:switcherator.c ****             break;
 346:switcherator.c ****         case 0x4449: //DI
 347:switcherator.c ****             setDigitalInput(commandReceived);
 348:switcherator.c ****             break;
 349:switcherator.c ****         case 0x4349: //CI
 350:switcherator.c ****             clearInput(commandReceived);
 351:switcherator.c ****             break;
 352:switcherator.c ****         case 0x4354: //CT
 353:switcherator.c ****             clockTweak(commandReceived);
 354:switcherator.c ****             break;
 355:switcherator.c ****         case 0x5057: //PW
 356:switcherator.c ****             pwmSummary();
 357:switcherator.c ****             break;
 358:switcherator.c ****         case 0x4845: //HE
 359:switcherator.c ****             drawInterface();
 360:switcherator.c ****             break;
 361:switcherator.c ****         case 0x4753: //GS
 362:switcherator.c ****             generalStatus(commandReceived);
 363:switcherator.c ****             break;
 364:switcherator.c ****         case 0x5248: //RH
 365:switcherator.c ****             drawInterface();
 366:switcherator.c ****             break;
 367:switcherator.c ****         case 0x4343: //CC
 368:switcherator.c ****             colorChangeSet(commandReceived);
 369:switcherator.c ****             break;
 370:switcherator.c ****         case 0x5342: //sb
 371:switcherator.c ****             switchBrightness(commandReceived);
 372:switcherator.c ****             break;
 373:switcherator.c ****         case 0x4253: //bs
 374:switcherator.c ****             brightnessSet(commandReceived);
 375:switcherator.c ****             break;
 376:switcherator.c ****         case 0x4749: //GI
 377:switcherator.c ****             generalInformation();
 378:switcherator.c ****             break;
 379:switcherator.c ****         case 0x5050: //PP
 380:switcherator.c ****             programsProgrammed();
 381:switcherator.c ****             break;
 382:switcherator.c ****         case 0x5357: //SW
 383:switcherator.c ****             switchesProgrammed();
 384:switcherator.c ****             break;
 385:switcherator.c ****         case 0x4950: //IP
 386:switcherator.c ****             inputsProgrammed();
 387:switcherator.c ****             break;
 388:switcherator.c ****         case 0x534F: //SO
 389:switcherator.c ****             switchesOn();
 390:switcherator.c ****             break;
 391:switcherator.c ****         default:
 392:switcherator.c ****             break;
 393:switcherator.c ****     }
 394:switcherator.c **** }
 395:switcherator.c **** 
 396:switcherator.c **** void drawInterface(void) {
  14               		.loc 1 396 0
  15               	/* prologue: function */
  16               	/* frame size = 0 */
  17               	/* stack size = 0 */
  18               	.L__stack_usage = 0
  19 0000 0895      		ret
  20               	.LFE9:
  22               	.global	getSwitchNumber
  24               	getSwitchNumber:
  25               	.LFB12:
 397:switcherator.c **** #ifdef help
 398:switcherator.c ****     sendMessage("TI:MMDDYYYYHHMMSS");
 399:switcherator.c ****     sendMessage("DS:MMDD MMDD");
 400:switcherator.c ****     sendMessage("TL:##HHMMHHMMdddddd");
 401:switcherator.c ****     sendMessage("NS:S#PpD,SC:S# SD NP:HHMMDur.");
 402:switcherator.c ****     sendMessage("CP:P# PA:P#S# PD:P#SMTWTFS");
 403:switcherator.c ****     sendMessage("PT:P#HHMMDur. PI:P#");
 404:switcherator.c ****     sendMessage("PS:P#S#DH CH:P#vvvv ");
 405:switcherator.c ****     sendMessage("PV:P#,vvv,vvv,vvv PW");
 406:switcherator.c ****     sendMessage("CC:##,vvv,vvv,vvv PW (sum)");
 407:switcherator.c ****     sendMessage("BS:16 SB S#16 HS:16");
 408:switcherator.c ****     sendMessage("SS S#Durat. SP P#Durat.");
 409:switcherator.c ****     sendMessage("SE nnnnnn SA CL CTvvv");
 410:switcherator.c ****     sendMessage("RD:N RC:N 0xnnnnnnnnnn");
 411:switcherator.c ****     sendMessage("AI:##PpLLLHHH?##DuraPO");
 412:switcherator.c ****     sendMessage("DI:##Ppx?##DuraPO  CI xx");
 413:switcherator.c ****     sendMessage("HE RH GS");
 414:switcherator.c **** #endif
 415:switcherator.c **** }
 416:switcherator.c **** 
 417:switcherator.c **** void fail(int failCode) {
 418:switcherator.c ****     statusMsg[0] = 0;
 419:switcherator.c ****     strcat(statusMsg, "fail 0x");
 420:switcherator.c ****     returnHex(failCode, tempIntString);
 421:switcherator.c ****     strcat(statusMsg, tempIntString);
 422:switcherator.c ****     sendMessage(statusMsg);
 423:switcherator.c **** }
 424:switcherator.c **** 
 425:switcherator.c **** void ok(void) {
 426:switcherator.c ****     sendMessage("ok");
 427:switcherator.c **** }
 428:switcherator.c **** 
 429:switcherator.c **** 
 430:switcherator.c **** // Helper function to get the switch number from char 3 and 4 of an array
 431:switcherator.c **** 
 432:switcherator.c **** int getSwitchNumber(char * commandReceived) {
  26               		.loc 1 432 0
  27               	.LVL0:
  28               	/* prologue: function */
  29               	/* frame size = 0 */
  30               	/* stack size = 0 */
  31               	.L__stack_usage = 0
 433:switcherator.c ****     int switchNumber = 0;
 434:switcherator.c ****     // get switch number
 435:switcherator.c ****     tempIntString[0] = commandReceived[3];
  32               		.loc 1 435 0
  33 0002 FC01      		movw r30,r24
  34 0004 2381      		ldd r18,Z+3
  35 0006 2093 0000 		sts tempIntString,r18
 436:switcherator.c ****     tempIntString[1] = commandReceived[4];
  36               		.loc 1 436 0
  37 000a 8481      		ldd r24,Z+4
  38               	.LVL1:
  39 000c 8093 0000 		sts tempIntString+1,r24
 437:switcherator.c ****     switchNumber = atoi(tempIntString);
  40               		.loc 1 437 0
  41 0010 80E0      		ldi r24,lo8(tempIntString)
  42 0012 90E0      		ldi r25,hi8(tempIntString)
  43 0014 0C94 0000 		jmp atoi
  44               	.LVL2:
  45               	.LFE12:
  47               	.global	getPort
  49               	getPort:
  50               	.LFB18:
 438:switcherator.c ****     return switchNumber;
 439:switcherator.c **** }
 440:switcherator.c **** 
 441:switcherator.c **** 
 442:switcherator.c **** /****************************************************************
 443:switcherator.c ****  *
 444:switcherator.c ****  *              All Things Switch Related
 445:switcherator.c ****  *
 446:switcherator.c ****  ****************************************************************/
 447:switcherator.c **** // Setup a new switch
 448:switcherator.c **** // NS:S#PpD
 449:switcherator.c **** // 01234567
 450:switcherator.c **** 
 451:switcherator.c **** void setNewSwitch(char * commandReceived) {
 452:switcherator.c ****     int switchNumber = 0;
 453:switcherator.c ****     char port = 0;
 454:switcherator.c ****     unsigned char pinMultiplied = 0;
 455:switcherator.c ****     unsigned char pinSubtractee = 0;
 456:switcherator.c ****     volatile unsigned char *realPort = 0;
 457:switcherator.c ****     volatile unsigned char *realDDR = 0;
 458:switcherator.c ****     char pin = 0;
 459:switcherator.c ****     char originalPin = 0;
 460:switcherator.c ****     char direction = 0;
 461:switcherator.c ****     tempIntString[0] = '0';
 462:switcherator.c ****     tempIntString[1] = commandReceived[6];
 463:switcherator.c ****     pin = atoi(tempIntString);
 464:switcherator.c ****     originalPin = pin;
 465:switcherator.c ****     tempIntString[1] = commandReceived[7];
 466:switcherator.c ****     direction = atoi(tempIntString);
 467:switcherator.c ****     port = commandReceived[5];
 468:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 469:switcherator.c ****     // make sure it is off before doing a new one.
 470:switcherator.c ****     clearTheSwitch(switchNumber);
 471:switcherator.c ****     // get the pin string ready for below
 472:switcherator.c ****     if (port == 'B' || port == 'b') {
 473:switcherator.c ****         realPort = &PORTB;
 474:switcherator.c ****         realDDR = &DDRB;
 475:switcherator.c ****         pinSubtractee = 16;
 476:switcherator.c **** #ifdef PORTA
 477:switcherator.c ****     } else if (port == 'A' || port == 'a') {
 478:switcherator.c ****         realPort = &PORTA;
 479:switcherator.c ****         realDDR = &DDRA;
 480:switcherator.c ****         pinSubtractee = 0;
 481:switcherator.c **** #endif
 482:switcherator.c **** #ifdef PORTC
 483:switcherator.c ****     } else if (port == 'C' || port == 'c') {
 484:switcherator.c ****         realPort = &PORTC;
 485:switcherator.c ****         realDDR = &DDRC;
 486:switcherator.c ****         pinSubtractee = 32;
 487:switcherator.c **** #endif
 488:switcherator.c **** #ifdef PORTD
 489:switcherator.c ****     } else if (port == 'D' || port == 'd') {
 490:switcherator.c ****         realPort = &PORTD;
 491:switcherator.c ****         realDDR = &DDRD;
 492:switcherator.c ****         pinSubtractee = 48;
 493:switcherator.c **** #endif
 494:switcherator.c **** #ifdef PORTE
 495:switcherator.c ****     } else if (port == 'E' || port == 'e') {
 496:switcherator.c ****         realPort = &PORTE;
 497:switcherator.c ****         realDDR = &DDRE;
 498:switcherator.c ****         pinSubtractee = 64;
 499:switcherator.c **** #endif
 500:switcherator.c **** #ifdef PORTF
 501:switcherator.c ****     } else if (port == 'F' || port == 'f') {
 502:switcherator.c ****         realPort = &PORTF;
 503:switcherator.c ****         realDDR = &DDRF;
 504:switcherator.c ****         pinSubtractee = 80;
 505:switcherator.c **** #endif
 506:switcherator.c **** #ifdef PORTG
 507:switcherator.c ****     } else if (port == 'G' || port == 'g') {
 508:switcherator.c ****         realPort = &PORTG;
 509:switcherator.c ****         realDDR = &DDRG;
 510:switcherator.c ****         pinSubtractee = 96;
 511:switcherator.c **** #endif
 512:switcherator.c **** #ifdef PORTH
 513:switcherator.c ****     } else if (port == 'H' || port == 'h') {
 514:switcherator.c ****         realPort = &PORTH;
 515:switcherator.c ****         realDDR = &DDRH;
 516:switcherator.c ****         pinSubtractee = 112;
 517:switcherator.c **** #endif
 518:switcherator.c **** #ifdef PORTI
 519:switcherator.c ****     } else if (port == 'I' || port == 'i') {
 520:switcherator.c ****         realPort = &PORTI;
 521:switcherator.c ****         realDDR = &DDRI;
 522:switcherator.c ****         pinSubtractee = 128;
 523:switcherator.c **** #endif
 524:switcherator.c **** 
 525:switcherator.c ****     }
 526:switcherator.c **** 
 527:switcherator.c **** 
 528:switcherator.c ****     if (realPort == 0) {
 529:switcherator.c ****         fail(2);
 530:switcherator.c ****     } else if ((switchNumber >= NUM_SWITCHES) ||
 531:switcherator.c ****             ((switchNumber == 0) && (commandReceived[3] != '0') && (commandReceived[4] != 0))) {
 532:switcherator.c ****         fail(1);
 533:switcherator.c ****     } else if ((pin > 7) || ((pin == 0) && (commandReceived[6] != '0'))) {
 534:switcherator.c ****         fail(4);
 535:switcherator.c ****     } else {
 536:switcherator.c ****         // set DDR out
 537:switcherator.c ****         *realDDR |= (1 << originalPin);
 538:switcherator.c ****         // double the pin and add 1 if it is high
 539:switcherator.c ****         pinMultiplied = pin * 2;
 540:switcherator.c ****         // turn switch off
 541:switcherator.c ****         pin = pinMultiplied + pinSubtractee;
 542:switcherator.c ****         switchStuff[switchNumber] = pin;
 543:switcherator.c **** 
 544:switcherator.c ****         if (direction == 0) {
 545:switcherator.c ****             // 0 = low is on  1 = high is on
 546:switcherator.c ****             *realPort |= (1 << originalPin);
 547:switcherator.c ****         } else {
 548:switcherator.c ****             *realPort &= ~(1 << originalPin);
 549:switcherator.c ****             switchStuff[switchNumber]++;
 550:switcherator.c ****         }
 551:switcherator.c ****         ok();
 552:switcherator.c ****     }
 553:switcherator.c **** }
 554:switcherator.c **** 
 555:switcherator.c **** // get rid of a switch and turn it off
 556:switcherator.c **** // SC:S#
 557:switcherator.c **** // 01234
 558:switcherator.c **** 
 559:switcherator.c **** void switchClear(char * commandReceived) {
 560:switcherator.c ****     int switchNumber = 0;
 561:switcherator.c ****     // get switch number
 562:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 563:switcherator.c ****     clearTheSwitch(switchNumber);
 564:switcherator.c ****     ok();
 565:switcherator.c **** }
 566:switcherator.c **** 
 567:switcherator.c **** // actual turning switch off (called with new switch as well)
 568:switcherator.c **** 
 569:switcherator.c **** void clearTheSwitch(int switchNumber) {
 570:switcherator.c ****     char port[] = {0};
 571:switcherator.c ****     char pin[] = {0};
 572:switcherator.c ****     char direction[] = {0};
 573:switcherator.c ****     volatile unsigned char *thisPort = 0;
 574:switcherator.c ****     volatile unsigned char *thisDDR = 0;
 575:switcherator.c ****     int realPin = 0;
 576:switcherator.c ****     // Figure out if it is pwm
 577:switcherator.c ****     if (switchStuff[switchNumber] >= 200 && switchStuff[switchNumber] <= 220) {
 578:switcherator.c ****         // if it is something else
 579:switcherator.c ****         pwmClear(switchNumber);
 580:switcherator.c ****         switchStuff[switchNumber] = 255;
 581:switcherator.c ****         return;
 582:switcherator.c ****     }
 583:switcherator.c ****     getPort(switchNumber, port, pin, direction);
 584:switcherator.c ****     if (port[0] == 'B') {
 585:switcherator.c ****         thisPort = &PORTB;
 586:switcherator.c ****         thisDDR = &DDRB;
 587:switcherator.c **** #ifdef PORTA
 588:switcherator.c ****     } else if (port[0] == 'A') {
 589:switcherator.c ****         thisPort = &PORTA;
 590:switcherator.c ****         thisDDR = &DDRA;
 591:switcherator.c **** #endif        
 592:switcherator.c **** #ifdef PORTC
 593:switcherator.c ****     } else if (port[0] == 'C') {
 594:switcherator.c ****         thisPort = &PORTC;
 595:switcherator.c ****         thisDDR = &DDRC;
 596:switcherator.c **** #endif        
 597:switcherator.c **** #ifdef PORTD
 598:switcherator.c ****     } else if (port[0] == 'D') {
 599:switcherator.c ****         thisPort = &PORTD;
 600:switcherator.c ****         thisDDR = &DDRD;
 601:switcherator.c **** #endif        
 602:switcherator.c **** #ifdef PORTE
 603:switcherator.c ****     } else if (port[0] == 'E') {
 604:switcherator.c ****         thisPort = &PORTE;
 605:switcherator.c ****         thisDDR = &DDRE;
 606:switcherator.c **** #endif        
 607:switcherator.c **** #ifdef PORTF
 608:switcherator.c ****     } else if (port[0] == 'F') {
 609:switcherator.c ****         thisPort = &PORTF;
 610:switcherator.c ****         thisDDR = &DDRF;
 611:switcherator.c **** #endif        
 612:switcherator.c **** #ifdef PORTG
 613:switcherator.c ****     } else if (port[0] == 'G') {
 614:switcherator.c ****         thisPort = &PORTG;
 615:switcherator.c ****         thisDDR = &DDRG;
 616:switcherator.c **** #endif        
 617:switcherator.c **** #ifdef PORTH
 618:switcherator.c ****     } else if (port[0] == 'H') {
 619:switcherator.c ****         thisPort = &PORTH;
 620:switcherator.c ****         thisDDR = &DDRH;
 621:switcherator.c **** #endif        
 622:switcherator.c **** #ifdef PORTI
 623:switcherator.c ****     } else if (port[0] == 'I') {
 624:switcherator.c ****         thisPort = &PORTI;
 625:switcherator.c ****         thisDDR = &DDRI;
 626:switcherator.c **** #endif        
 627:switcherator.c ****     }
 628:switcherator.c ****     realPin = pin[0];
 629:switcherator.c ****     *thisDDR &= ~(1 << realPin);
 630:switcherator.c ****     *thisPort &= ~(1 << realPin);
 631:switcherator.c ****     switchStuff[switchNumber] = 255;
 632:switcherator.c **** }
 633:switcherator.c **** 
 634:switcherator.c **** // show a summary of the switches
 635:switcherator.c **** 
 636:switcherator.c **** void switchDisplay(char * commandReceived) {
 637:switcherator.c ****     char port[] = {0};
 638:switcherator.c ****     char pin[] = {0};
 639:switcherator.c ****     char direction[] = {0};
 640:switcherator.c ****     int switchNumber = 0;
 641:switcherator.c ****     int realPin = 0;
 642:switcherator.c ****     char statusMsg[32];
 643:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 644:switcherator.c ****     statusMsg[0] = 0;
 645:switcherator.c ****     // see if this is a pwm switch
 646:switcherator.c ****     if (switchStuff[switchNumber] >= 200 && switchStuff[switchNumber] <= 220) {
 647:switcherator.c ****         // yes pwm
 648:switcherator.c ****         if (switchStuff[switchNumber] % 2 == 0) {
 649:switcherator.c ****             if (switchStuff[switchNumber] == 202) {
 650:switcherator.c ****                 strcat(statusMsg, "CoC");
 651:switcherator.c ****             } else if (switchStuff[switchNumber] == 212) {
 652:switcherator.c ****                 strcat(statusMsg, "Brt");
 653:switcherator.c ****             } else {
 654:switcherator.c ****                 strcat(statusMsg, "Fix");
 655:switcherator.c ****             }
 656:switcherator.c ****         } else {
 657:switcherator.c ****             strcat(statusMsg, "Hue");
 658:switcherator.c ****         }
 659:switcherator.c ****     } else {
 660:switcherator.c ****         getPort(switchNumber, port, pin, direction);
 661:switcherator.c ****         tempIntString[0] = port[0];
 662:switcherator.c ****         tempIntString[1] = 0;
 663:switcherator.c ****         strcat(statusMsg, tempIntString);
 664:switcherator.c ****         realPin = pin[0];
 665:switcherator.c ****         itoa(realPin, tempIntString, 10);
 666:switcherator.c ****         strcat(statusMsg, tempIntString);
 667:switcherator.c ****         if (direction[0] == 0) {
 668:switcherator.c ****             strcat(statusMsg, "L");
 669:switcherator.c ****         } else {
 670:switcherator.c ****             strcat(statusMsg, "H");
 671:switcherator.c ****         }
 672:switcherator.c ****     }
 673:switcherator.c ****     sendMessage(statusMsg);
 674:switcherator.c **** 
 675:switcherator.c **** }
 676:switcherator.c **** 
 677:switcherator.c **** // takes in a switch number and time and turns on the switch
 678:switcherator.c **** // SS S#Durat.
 679:switcherator.c **** // 01234567890
 680:switcherator.c **** 
 681:switcherator.c **** void startSwitch(char * commandReceived) {
 682:switcherator.c ****     unsigned long duration;
 683:switcherator.c ****     int switchNumber = 0;
 684:switcherator.c ****     // get switch number
 685:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 686:switcherator.c ****     if ((switchNumber >= NUM_SWITCHES) || (switchStuff[switchNumber] == 255)) {
 687:switcherator.c ****         fail(1);
 688:switcherator.c ****         return;
 689:switcherator.c ****     }
 690:switcherator.c ****     // get duration
 691:switcherator.c ****     tempHugeString[0] = commandReceived[5];
 692:switcherator.c ****     tempHugeString[1] = commandReceived[6];
 693:switcherator.c ****     tempHugeString[2] = commandReceived[7];
 694:switcherator.c ****     tempHugeString[3] = commandReceived[8];
 695:switcherator.c ****     tempHugeString[4] = commandReceived[9];
 696:switcherator.c ****     tempHugeString[5] = commandReceived[10];
 697:switcherator.c ****     duration = atol(tempHugeString);
 698:switcherator.c ****     if (duration == 0) {
 699:switcherator.c ****         fail(5);
 700:switcherator.c ****         return;
 701:switcherator.c ****     }
 702:switcherator.c ****     // only update the time if it is longer than what the switch is already turned on to
 703:switcherator.c ****     if ((weeklySeconds + duration) > switchStatus[switchNumber])
 704:switcherator.c ****         switchStatus[switchNumber] = (weeklySeconds + duration);
 705:switcherator.c **** 
 706:switcherator.c ****     // see if it is PWM
 707:switcherator.c ****     if (switchStuff[switchNumber] >= 200 && switchStuff[switchNumber] <= 220) {
 708:switcherator.c ****         // k it is PWM.  See if it is hue
 709:switcherator.c ****         if (switchStuff[switchNumber] == 200) {
 710:switcherator.c ****             // even number so values, not hue
 711:switcherator.c ****             red = pwmValues[0];
 712:switcherator.c ****             green = pwmValues[1];
 713:switcherator.c ****             blue = pwmValues[2];
 714:switcherator.c ****             red = red * bright / 16;
 715:switcherator.c ****             green = green * bright / 16;
 716:switcherator.c ****             blue = blue * bright / 16;
 717:switcherator.c ****             Red = red;
 718:switcherator.c ****             Green = green;
 719:switcherator.c ****             Blue = blue;
 720:switcherator.c ****         } else if (switchStuff[switchNumber] == 202) {
 721:switcherator.c ****             runColorChanges = 1;
 722:switcherator.c ****         } else if (switchStuff[switchNumber] == 212) {
 723:switcherator.c ****             bright = switchBright[switchNumber];
 724:switcherator.c ****         } else {
 725:switcherator.c ****             runHue = 1;
 726:switcherator.c ****         }
 727:switcherator.c **** 
 728:switcherator.c ****     } else {
 729:switcherator.c **** 
 730:switcherator.c ****         // get the port and turn it on
 731:switcherator.c ****         char port[1];
 732:switcherator.c ****         char pin[1];
 733:switcherator.c ****         int realPin = 0;
 734:switcherator.c ****         char direction[1];
 735:switcherator.c ****         volatile unsigned char *thisPort = 0;
 736:switcherator.c ****         getPort(switchNumber, port, pin, direction);
 737:switcherator.c ****         // yeah pointers and casts and whatevers. this fixes it
 738:switcherator.c ****         realPin = pin[0];
 739:switcherator.c ****         if (port[0] == 'B')
 740:switcherator.c ****             thisPort = &PORTB;
 741:switcherator.c **** #ifdef PORTA
 742:switcherator.c ****         else if (port[0] == 'A')
 743:switcherator.c ****             thisPort = &PORTA;
 744:switcherator.c **** #endif
 745:switcherator.c **** #ifdef PORTC
 746:switcherator.c ****         else if (port[0] == 'C')
 747:switcherator.c ****             thisPort = &PORTC;
 748:switcherator.c **** #endif
 749:switcherator.c **** #ifdef PORTD
 750:switcherator.c ****         else if (port[0] == 'D')
 751:switcherator.c ****             thisPort = &PORTD;
 752:switcherator.c **** #endif
 753:switcherator.c **** #ifdef PORTE
 754:switcherator.c ****         else if (port[0] == 'E')
 755:switcherator.c ****             thisPort = &PORTE;
 756:switcherator.c **** #endif
 757:switcherator.c **** #ifdef PORTF
 758:switcherator.c ****         else if (port[0] == 'F')
 759:switcherator.c ****             thisPort = &PORTF;
 760:switcherator.c **** #endif
 761:switcherator.c **** #ifdef PORTG
 762:switcherator.c ****         else if (port[0] == 'G')
 763:switcherator.c ****             thisPort = &PORTG;
 764:switcherator.c **** #endif
 765:switcherator.c **** #ifdef PORTH
 766:switcherator.c ****         else if (port[0] == 'H')
 767:switcherator.c ****             thisPort = &PORTH;
 768:switcherator.c **** #endif
 769:switcherator.c **** #ifdef PORTI
 770:switcherator.c ****         else if (port[0] == 'I')
 771:switcherator.c ****             thisPort = &PORTI;
 772:switcherator.c **** #endif
 773:switcherator.c **** 
 774:switcherator.c ****         // turn it on based on what direction
 775:switcherator.c ****         if (direction[0] == 0) {
 776:switcherator.c ****             *thisPort &= ~(1 << realPin);
 777:switcherator.c ****         } else {
 778:switcherator.c ****             *thisPort |= (1 << realPin);
 779:switcherator.c ****         }
 780:switcherator.c ****     }
 781:switcherator.c ****     ok();
 782:switcherator.c **** }
 783:switcherator.c **** // Takes in a switch number and returns the port (as a letter), pin, direction 0,1, and actual PORT
 784:switcherator.c **** 
 785:switcherator.c **** void getPort(int switchNumber, char * port, char * pin, char * direction) {
  51               		.loc 1 785 0
  52               	.LVL3:
  53               	/* prologue: function */
  54               	/* frame size = 0 */
  55               	/* stack size = 0 */
  56               	.L__stack_usage = 0
  57 0018 FB01      		movw r30,r22
 786:switcherator.c ****     char switchInfo = switchStuff[switchNumber];
  58               		.loc 1 786 0
  59 001a 8050      		subi r24,lo8(-(switchStuff))
  60 001c 9040      		sbci r25,hi8(-(switchStuff))
  61               	.LVL4:
  62 001e DC01      		movw r26,r24
  63 0020 8C91      		ld r24,X
  64               	.LVL5:
 787:switcherator.c ****     if ((switchInfo >= 16 && switchInfo < 32)) {
  65               		.loc 1 787 0
  66 0022 982F      		mov r25,r24
  67 0024 9051      		subi r25,lo8(-(-16))
  68 0026 9031      		cpi r25,lo8(16)
  69 0028 00F4      		brsh .L4
 788:switcherator.c ****         port[0] = 'B';
  70               		.loc 1 788 0
  71 002a 82E4      		ldi r24,lo8(66)
  72               	.LVL6:
  73 002c 8083      		st Z,r24
  74               	.LVL7:
  75 002e 00C0      		rjmp .L5
  76               	.LVL8:
  77               	.L4:
 789:switcherator.c ****         switchInfo -= 16;
 790:switcherator.c ****     } else if (switchInfo < 16) {
  78               		.loc 1 790 0
  79 0030 8031      		cpi r24,lo8(16)
  80 0032 00F4      		brsh .L6
 791:switcherator.c ****         port[0] = 'A';
  81               		.loc 1 791 0
  82 0034 91E4      		ldi r25,lo8(65)
  83 0036 9083      		st Z,r25
  84 0038 982F      		mov r25,r24
  85 003a 00C0      		rjmp .L5
  86               	.L6:
 792:switcherator.c ****         switchInfo -= 0;
 793:switcherator.c ****     } else if (switchInfo < 48) {
  87               		.loc 1 793 0
  88 003c 8033      		cpi r24,lo8(48)
  89 003e 00F4      		brsh .L7
 794:switcherator.c ****         port[0] = 'C';
  90               		.loc 1 794 0
  91 0040 93E4      		ldi r25,lo8(67)
  92 0042 9083      		st Z,r25
 795:switcherator.c ****         switchInfo -= 32;
  93               		.loc 1 795 0
  94 0044 982F      		mov r25,r24
  95 0046 9052      		subi r25,lo8(-(-32))
  96               	.LVL9:
  97 0048 00C0      		rjmp .L5
  98               	.LVL10:
  99               	.L7:
 796:switcherator.c ****     } else if (switchInfo < 64) {
 100               		.loc 1 796 0
 101 004a 8034      		cpi r24,lo8(64)
 102 004c 00F4      		brsh .L8
 797:switcherator.c ****         port[0] = 'D';
 103               		.loc 1 797 0
 104 004e 94E4      		ldi r25,lo8(68)
 105 0050 9083      		st Z,r25
 798:switcherator.c ****         switchInfo -= 48;
 106               		.loc 1 798 0
 107 0052 982F      		mov r25,r24
 108 0054 9053      		subi r25,lo8(-(-48))
 109               	.LVL11:
 110 0056 00C0      		rjmp .L5
 111               	.LVL12:
 112               	.L8:
 799:switcherator.c ****     } else if (switchInfo < 80) {
 113               		.loc 1 799 0
 114 0058 8035      		cpi r24,lo8(80)
 115 005a 00F4      		brsh .L9
 800:switcherator.c ****         port[0] = 'E';
 116               		.loc 1 800 0
 117 005c 95E4      		ldi r25,lo8(69)
 118 005e 9083      		st Z,r25
 801:switcherator.c ****         switchInfo -= 64;
 119               		.loc 1 801 0
 120 0060 982F      		mov r25,r24
 121 0062 9054      		subi r25,lo8(-(-64))
 122               	.LVL13:
 123 0064 00C0      		rjmp .L5
 124               	.LVL14:
 125               	.L9:
 802:switcherator.c ****     } else if (switchInfo < 96) {
 126               		.loc 1 802 0
 127 0066 8036      		cpi r24,lo8(96)
 128 0068 00F4      		brsh .L10
 803:switcherator.c ****         port[0] = 'F';
 129               		.loc 1 803 0
 130 006a 96E4      		ldi r25,lo8(70)
 131 006c 9083      		st Z,r25
 804:switcherator.c ****         switchInfo -= 80;
 132               		.loc 1 804 0
 133 006e 982F      		mov r25,r24
 134 0070 9055      		subi r25,lo8(-(-80))
 135               	.LVL15:
 136 0072 00C0      		rjmp .L5
 137               	.LVL16:
 138               	.L10:
 805:switcherator.c ****     } else if (switchInfo < 112) {
 139               		.loc 1 805 0
 140 0074 8037      		cpi r24,lo8(112)
 141 0076 00F4      		brsh .L11
 806:switcherator.c ****         port[0] = 'G';
 142               		.loc 1 806 0
 143 0078 97E4      		ldi r25,lo8(71)
 144 007a 9083      		st Z,r25
 807:switcherator.c ****         switchInfo -= 96;
 145               		.loc 1 807 0
 146 007c 982F      		mov r25,r24
 147 007e 9056      		subi r25,lo8(-(-96))
 148               	.LVL17:
 149 0080 00C0      		rjmp .L5
 150               	.LVL18:
 151               	.L11:
 808:switcherator.c ****     } else if (switchInfo < 128) {
 152               		.loc 1 808 0
 153 0082 87FD      		sbrc r24,7
 154 0084 00C0      		rjmp .L12
 809:switcherator.c ****         port[0] = 'H';
 155               		.loc 1 809 0
 156 0086 98E4      		ldi r25,lo8(72)
 157 0088 9083      		st Z,r25
 810:switcherator.c ****         switchInfo -= 112;
 158               		.loc 1 810 0
 159 008a 982F      		mov r25,r24
 160 008c 9057      		subi r25,lo8(-(-112))
 161               	.LVL19:
 162 008e 00C0      		rjmp .L5
 163               	.LVL20:
 164               	.L12:
 811:switcherator.c ****     } else if (switchInfo < 144) {
 165               		.loc 1 811 0
 166 0090 8039      		cpi r24,lo8(-112)
 167 0092 00F4      		brsh .L13
 812:switcherator.c ****         port[0] = 'I';
 168               		.loc 1 812 0
 169 0094 99E4      		ldi r25,lo8(73)
 170 0096 9083      		st Z,r25
 813:switcherator.c ****         switchInfo -= 128;
 171               		.loc 1 813 0
 172 0098 982F      		mov r25,r24
 173 009a 9058      		subi r25,lo8(-(-128))
 174               	.LVL21:
 175 009c 00C0      		rjmp .L5
 176               	.LVL22:
 177               	.L13:
 814:switcherator.c ****     } else {
 815:switcherator.c ****         port[0] = '?';
 178               		.loc 1 815 0
 179 009e 8FE3      		ldi r24,lo8(63)
 180               	.LVL23:
 181 00a0 8083      		st Z,r24
 816:switcherator.c ****         pin[0] = 0;
 182               		.loc 1 816 0
 183 00a2 FA01      		movw r30,r20
 184 00a4 1082      		st Z,__zero_reg__
 817:switcherator.c ****         direction[0] = 0;
 185               		.loc 1 817 0
 186 00a6 D901      		movw r26,r18
 187               	.LVL24:
 188 00a8 1C92      		st X,__zero_reg__
 818:switcherator.c ****         return;
 189               		.loc 1 818 0
 190 00aa 0895      		ret
 191               	.LVL25:
 192               	.L5:
 819:switcherator.c ****     }
 820:switcherator.c ****     pin[0] = switchInfo / 2;
 193               		.loc 1 820 0
 194 00ac 892F      		mov r24,r25
 195 00ae 8695      		lsr r24
 196 00b0 FA01      		movw r30,r20
 197 00b2 8083      		st Z,r24
 821:switcherator.c ****     direction[0] = switchInfo % 2;
 198               		.loc 1 821 0
 199 00b4 9170      		andi r25,lo8(1)
 200               	.LVL26:
 201 00b6 D901      		movw r26,r18
 202 00b8 9C93      		st X,r25
 203 00ba 0895      		ret
 204               	.LFE18:
 206               	.global	pwmClear
 208               	pwmClear:
 209               	.LFB21:
 822:switcherator.c **** }
 823:switcherator.c **** 
 824:switcherator.c **** // assign a secondary brightness to a switch
 825:switcherator.c **** // sb s#16
 826:switcherator.c **** 
 827:switcherator.c **** void switchBrightness(char * commandReceived) {
 828:switcherator.c ****     int switchNumber = getSwitchNumber(commandReceived);
 829:switcherator.c ****     char tempBright = 0;
 830:switcherator.c ****     if (switchNumber >= NUM_SWITCHES) {
 831:switcherator.c ****         fail(1);
 832:switcherator.c ****         return;
 833:switcherator.c ****     }
 834:switcherator.c ****     tempIntString[0] = commandReceived[5];
 835:switcherator.c ****     tempIntString[1] = commandReceived[6];
 836:switcherator.c ****     char brightValue = atoi(tempIntString);
 837:switcherator.c ****     if (brightValue == 0) {
 838:switcherator.c ****         tempBright = switchBright[switchNumber];
 839:switcherator.c ****         itoa(tempBright, tempIntString, 10);
 840:switcherator.c ****         statusMsg[0] = 0;
 841:switcherator.c ****         strcat(statusMsg, "Set @");
 842:switcherator.c ****         strcat(statusMsg, tempIntString);
 843:switcherator.c ****         sendMessage(statusMsg);
 844:switcherator.c ****     } else {
 845:switcherator.c ****         if (brightValue > 16)
 846:switcherator.c ****             brightValue = 16;
 847:switcherator.c ****         clearTheSwitch(switchNumber);
 848:switcherator.c ****         // value to indicate this is brightness
 849:switcherator.c ****         switchStuff[switchNumber] = 212;
 850:switcherator.c ****         switchBright[switchNumber] = brightValue;
 851:switcherator.c ****         ok();
 852:switcherator.c ****     }
 853:switcherator.c **** }
 854:switcherator.c **** 
 855:switcherator.c **** /****************************************************************
 856:switcherator.c ****  *
 857:switcherator.c ****  *              All Things PWM Related
 858:switcherator.c ****  *
 859:switcherator.c ****  ****************************************************************/
 860:switcherator.c **** 
 861:switcherator.c **** // PWM setup.  This is initially  geared for the 328p but the framework
 862:switcherator.c **** // exists for other chips
 863:switcherator.c **** // PS:P#S#DH
 864:switcherator.c **** // 012345678
 865:switcherator.c **** 
 866:switcherator.c **** void pwmSetup(char * commandReceived) {
 867:switcherator.c ****     int x = 0;
 868:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 869:switcherator.c ****         if (switchStuff[x] == 70 || switchStuff[x] == 71 || switchStuff[x] == 74 ||
 870:switcherator.c ****                 switchStuff[x] == 75 || switchStuff[x] == 76 || switchStuff[x] == 77) {
 871:switcherator.c ****             fail(6);
 872:switcherator.c ****             return;
 873:switcherator.c ****         }
 874:switcherator.c ****     }
 875:switcherator.c ****     int switchNumber = 0;
 876:switcherator.c ****     // get switch number
 877:switcherator.c ****     tempIntString[0] = commandReceived[5];
 878:switcherator.c ****     tempIntString[1] = commandReceived[6];
 879:switcherator.c ****     switchNumber = atoi(tempIntString);
 880:switcherator.c ****     clearTheSwitch(switchNumber);
 881:switcherator.c ****     // set up a hue pwm
 882:switcherator.c ****     if (commandReceived[8] == 'H' || commandReceived[8] == 'h' || commandReceived[8] == '1') {
 883:switcherator.c ****         switchStuff[switchNumber] = 201;
 884:switcherator.c ****     } else if (commandReceived[8] == 'C' || commandReceived[8] == 'c') {
 885:switcherator.c ****         switchStuff[switchNumber] = 202;
 886:switcherator.c ****     } else {
 887:switcherator.c ****         switchStuff[switchNumber] = 200;
 888:switcherator.c ****     }
 889:switcherator.c ****     DDRD |= (1 << PIND3) | (1 << PIND5) | (1 << PIND6);
 890:switcherator.c ****     // make sure initial values are 0
 891:switcherator.c ****     Red = 0;
 892:switcherator.c ****     Green = 0;
 893:switcherator.c ****     Blue = 0;
 894:switcherator.c ****     // Set output phase correct whatevers
 895:switcherator.c ****     // set it to inverted if the direction is 0
 896:switcherator.c ****     if (commandReceived[7] == '0') {
 897:switcherator.c ****         pwmdir = 0;
 898:switcherator.c ****         TCCR0A = (1 << COM0A0) | (1 << COM0A1) | (1 << COM0B0) | (1 << COM0B1) | (1 << WGM00);
 899:switcherator.c ****         TCCR2A = (1 << COM2B0) | (1 << COM2B1) | (1 << WGM20);
 900:switcherator.c ****     } else {
 901:switcherator.c ****         pwmdir = 1;
 902:switcherator.c ****         TCCR0A = (1 << COM0A1) | (1 << COM0B1) | (1 << WGM00);
 903:switcherator.c ****         TCCR2A = (1 << COM2B1) | (1 << WGM20);
 904:switcherator.c ****     }
 905:switcherator.c ****     // F_CPU/64 timers
 906:switcherator.c ****     TCCR0B = (1 << CS01) | (1 << CS00);
 907:switcherator.c **** 
 908:switcherator.c ****     TCCR2B = (1 << CS22); // F_CPU/64
 909:switcherator.c ****     // pwm to output
 910:switcherator.c ****     ok();
 911:switcherator.c **** }
 912:switcherator.c **** 
 913:switcherator.c **** // Turn off the PWM - called by clearing the switch
 914:switcherator.c **** 
 915:switcherator.c **** void pwmClear(int switchNumber) {
 210               		.loc 1 915 0
 211               	.LVL27:
 212               	/* prologue: function */
 213               	/* frame size = 0 */
 214               	/* stack size = 0 */
 215               	.L__stack_usage = 0
 916:switcherator.c ****     if (switchStuff[switchNumber] == 212) {
 216               		.loc 1 916 0
 217 00bc 8050      		subi r24,lo8(-(switchStuff))
 218 00be 9040      		sbci r25,hi8(-(switchStuff))
 219               	.LVL28:
 220 00c0 FC01      		movw r30,r24
 221 00c2 8081      		ld r24,Z
 222               	.LVL29:
 223 00c4 843D      		cpi r24,lo8(-44)
 224 00c6 01F4      		brne .L16
 917:switcherator.c ****         bright = oldBright;
 225               		.loc 1 917 0
 226 00c8 8091 0000 		lds r24,oldBright
 227 00cc 8093 0000 		sts bright,r24
 228 00d0 1092 0000 		sts bright+1,__zero_reg__
 229 00d4 0895      		ret
 230               	.L16:
 918:switcherator.c ****     } else {
 919:switcherator.c ****         TCCR0A = 0;
 231               		.loc 1 919 0
 232 00d6 14BC      		out 0x24,__zero_reg__
 920:switcherator.c ****         TCCR0B = 0;
 233               		.loc 1 920 0
 234 00d8 15BC      		out 0x25,__zero_reg__
 921:switcherator.c ****         TCCR2A = 0;
 235               		.loc 1 921 0
 236 00da 1092 B000 		sts 176,__zero_reg__
 922:switcherator.c ****         TCCR2B = 0;
 237               		.loc 1 922 0
 238 00de 1092 B100 		sts 177,__zero_reg__
 923:switcherator.c ****         Red = 0;
 239               		.loc 1 923 0
 240 00e2 1092 B400 		sts 180,__zero_reg__
 924:switcherator.c ****         Green = 0;
 241               		.loc 1 924 0
 242 00e6 18BC      		out 0x28,__zero_reg__
 925:switcherator.c ****         Blue = 0;
 243               		.loc 1 925 0
 244 00e8 17BC      		out 0x27,__zero_reg__
 926:switcherator.c ****         DDRD &= ~((1 << PIND3)&(1 << PIND5)&(1 << PIND6));
 245               		.loc 1 926 0
 246 00ea 8AB1      		in r24,0xa
 247 00ec 8AB9      		out 0xa,r24
 927:switcherator.c ****         runHue = 0;
 248               		.loc 1 927 0
 249 00ee 1092 0000 		sts runHue,__zero_reg__
 928:switcherator.c ****         runColorChanges = 0;
 250               		.loc 1 928 0
 251 00f2 1092 0000 		sts runColorChanges,__zero_reg__
 252 00f6 0895      		ret
 253               	.LFE21:
 255               	.global	clearTheSwitch
 257               	clearTheSwitch:
 258               	.LFB15:
 569:switcherator.c **** void clearTheSwitch(int switchNumber) {
 259               		.loc 1 569 0
 260               	.LVL30:
 261 00f8 EF92      		push r14
 262               	.LCFI0:
 263 00fa FF92      		push r15
 264               	.LCFI1:
 265 00fc 0F93      		push r16
 266               	.LCFI2:
 267 00fe 1F93      		push r17
 268               	.LCFI3:
 269 0100 CF93      		push r28
 270               	.LCFI4:
 271 0102 DF93      		push r29
 272               	.LCFI5:
 273 0104 00D0      		rcall .
 274 0106 1F92      		push __zero_reg__
 275               	.LCFI6:
 276 0108 CDB7      		in r28,__SP_L__
 277 010a DEB7      		in r29,__SP_H__
 278               	.LCFI7:
 279               	/* prologue: function */
 280               	/* frame size = 3 */
 281               	/* stack size = 9 */
 282               	.L__stack_usage = 9
 283 010c 8C01      		movw r16,r24
 570:switcherator.c ****     char port[] = {0};
 284               		.loc 1 570 0
 285 010e 1B82      		std Y+3,__zero_reg__
 571:switcherator.c ****     char pin[] = {0};
 286               		.loc 1 571 0
 287 0110 1A82      		std Y+2,__zero_reg__
 572:switcherator.c ****     char direction[] = {0};
 288               		.loc 1 572 0
 289 0112 1982      		std Y+1,__zero_reg__
 290               	.LVL31:
 577:switcherator.c ****     if (switchStuff[switchNumber] >= 200 && switchStuff[switchNumber] <= 220) {
 291               		.loc 1 577 0
 292 0114 80E0      		ldi r24,lo8(switchStuff)
 293 0116 E82E      		mov r14,r24
 294 0118 80E0      		ldi r24,hi8(switchStuff)
 295 011a F82E      		mov r15,r24
 296               	.LVL32:
 297 011c E00E      		add r14,r16
 298 011e F11E      		adc r15,r17
 299 0120 F701      		movw r30,r14
 300 0122 8081      		ld r24,Z
 301 0124 885C      		subi r24,lo8(-(56))
 302 0126 8531      		cpi r24,lo8(21)
 303 0128 00F4      		brsh .L19
 579:switcherator.c ****         pwmClear(switchNumber);
 304               		.loc 1 579 0
 305 012a C801      		movw r24,r16
 306 012c 0E94 0000 		call pwmClear
 307               	.LVL33:
 580:switcherator.c ****         switchStuff[switchNumber] = 255;
 308               		.loc 1 580 0
 309 0130 8FEF      		ldi r24,lo8(-1)
 310 0132 F701      		movw r30,r14
 311 0134 00C0      		rjmp .L25
 312               	.L19:
 583:switcherator.c ****     getPort(switchNumber, port, pin, direction);
 313               		.loc 1 583 0
 314 0136 9E01      		movw r18,r28
 315 0138 2F5F      		subi r18,-1
 316 013a 3F4F      		sbci r19,-1
 317 013c AE01      		movw r20,r28
 318 013e 4E5F      		subi r20,-2
 319 0140 5F4F      		sbci r21,-1
 320 0142 BE01      		movw r22,r28
 321 0144 6D5F      		subi r22,-3
 322 0146 7F4F      		sbci r23,-1
 323 0148 C801      		movw r24,r16
 324 014a 0E94 0000 		call getPort
 325               	.LVL34:
 584:switcherator.c ****     if (port[0] == 'B') {
 326               		.loc 1 584 0
 327 014e 8B81      		ldd r24,Y+3
 328 0150 8234      		cpi r24,lo8(66)
 329 0152 01F0      		breq .L22
 593:switcherator.c ****     } else if (port[0] == 'C') {
 330               		.loc 1 593 0
 331 0154 8334      		cpi r24,lo8(67)
 332 0156 01F0      		breq .L23
 598:switcherator.c ****     } else if (port[0] == 'D') {
 333               		.loc 1 598 0
 334 0158 8434      		cpi r24,lo8(68)
 335 015a 01F0      		breq .L24
 574:switcherator.c ****     volatile unsigned char *thisDDR = 0;
 336               		.loc 1 574 0
 337 015c A0E0      		ldi r26,0
 338 015e B0E0      		ldi r27,0
 573:switcherator.c ****     volatile unsigned char *thisPort = 0;
 339               		.loc 1 573 0
 340 0160 E0E0      		ldi r30,0
 341 0162 F0E0      		ldi r31,0
 342 0164 00C0      		rjmp .L21
 343               	.L22:
 586:switcherator.c ****         thisDDR = &DDRB;
 344               		.loc 1 586 0
 345 0166 A4E2      		ldi r26,lo8(36)
 346 0168 B0E0      		ldi r27,0
 585:switcherator.c ****         thisPort = &PORTB;
 347               		.loc 1 585 0
 348 016a E5E2      		ldi r30,lo8(37)
 349 016c F0E0      		ldi r31,0
 350 016e 00C0      		rjmp .L21
 351               	.L23:
 595:switcherator.c ****         thisDDR = &DDRC;
 352               		.loc 1 595 0
 353 0170 A7E2      		ldi r26,lo8(39)
 354 0172 B0E0      		ldi r27,0
 594:switcherator.c ****         thisPort = &PORTC;
 355               		.loc 1 594 0
 356 0174 E8E2      		ldi r30,lo8(40)
 357 0176 F0E0      		ldi r31,0
 358 0178 00C0      		rjmp .L21
 359               	.L24:
 600:switcherator.c ****         thisDDR = &DDRD;
 360               		.loc 1 600 0
 361 017a AAE2      		ldi r26,lo8(42)
 362 017c B0E0      		ldi r27,0
 599:switcherator.c ****         thisPort = &PORTD;
 363               		.loc 1 599 0
 364 017e EBE2      		ldi r30,lo8(43)
 365 0180 F0E0      		ldi r31,0
 366               	.L21:
 367               	.LVL35:
 629:switcherator.c ****     *thisDDR &= ~(1 << realPin);
 368               		.loc 1 629 0
 369 0182 2C91      		ld r18,X
 370 0184 81E0      		ldi r24,lo8(1)
 371 0186 90E0      		ldi r25,0
 372 0188 0A80      		ldd r0,Y+2
 373 018a 00C0      		rjmp 2f
 374               		1:
 375 018c 880F      		lsl r24
 376 018e 991F      		rol r25
 377               		2:
 378 0190 0A94      		dec r0
 379 0192 02F4      		brpl 1b
 380 0194 8095      		com r24
 381 0196 2823      		and r18,r24
 382 0198 2C93      		st X,r18
 630:switcherator.c ****     *thisPort &= ~(1 << realPin);
 383               		.loc 1 630 0
 384 019a 9081      		ld r25,Z
 385 019c 9823      		and r25,r24
 386 019e 9083      		st Z,r25
 631:switcherator.c ****     switchStuff[switchNumber] = 255;
 387               		.loc 1 631 0
 388 01a0 F801      		movw r30,r16
 389               	.LVL36:
 390 01a2 E050      		subi r30,lo8(-(switchStuff))
 391 01a4 F040      		sbci r31,hi8(-(switchStuff))
 392 01a6 8FEF      		ldi r24,lo8(-1)
 393               	.LVL37:
 394               	.L25:
 395 01a8 8083      		st Z,r24
 396               	/* epilogue start */
 632:switcherator.c **** }
 397               		.loc 1 632 0
 398 01aa 0F90      		pop __tmp_reg__
 399 01ac 0F90      		pop __tmp_reg__
 400 01ae 0F90      		pop __tmp_reg__
 401 01b0 DF91      		pop r29
 402 01b2 CF91      		pop r28
 403 01b4 1F91      		pop r17
 404 01b6 0F91      		pop r16
 405               	.LVL38:
 406 01b8 FF90      		pop r15
 407 01ba EF90      		pop r14
 408 01bc 0895      		ret
 409               	.LFE15:
 411               	.global	runColorFunction
 413               	runColorFunction:
 414               	.LFB27:
 929:switcherator.c ****     }
 930:switcherator.c **** }
 931:switcherator.c **** 
 932:switcherator.c **** // This just sets up the times for the PWM hues
 933:switcherator.c **** // CH:P#TTTTT 
 934:switcherator.c **** // 0123456789
 935:switcherator.c **** 
 936:switcherator.c **** void cycleHue(char * commandReceived) {
 937:switcherator.c ****     // right now we just have 1 pwm but I could add more
 938:switcherator.c ****     tempLongString[0] = commandReceived[5];
 939:switcherator.c ****     tempLongString[1] = commandReceived[6];
 940:switcherator.c ****     tempLongString[2] = commandReceived[7];
 941:switcherator.c ****     tempLongString[3] = commandReceived[8];
 942:switcherator.c ****     int programNumber = 0;
 943:switcherator.c ****     programNumber = atoi(tempLongString);
 944:switcherator.c ****     if (programNumber > 0)
 945:switcherator.c ****         colorChangeSpeed = programNumber;
 946:switcherator.c ****     ok();
 947:switcherator.c **** }
 948:switcherator.c **** 
 949:switcherator.c **** // Changes the hue speed
 950:switcherator.c **** // HS:xx
 951:switcherator.c **** 
 952:switcherator.c **** void setHueSpeed(char * commandReceived) {
 953:switcherator.c ****     tempIntString[0] = commandReceived[3];
 954:switcherator.c ****     tempIntString[1] = commandReceived[4];
 955:switcherator.c ****     int programNumber = 0;
 956:switcherator.c ****     programNumber = atoi(tempIntString);
 957:switcherator.c ****     if (programNumber > 0)
 958:switcherator.c ****         hueSpeed = programNumber;
 959:switcherator.c ****     ok();
 960:switcherator.c **** }
 961:switcherator.c **** 
 962:switcherator.c **** 
 963:switcherator.c **** // set up the values for a solid pwm
 964:switcherator.c **** // PV:P#,vvv,vvv,vvv
 965:switcherator.c **** // 01234567890123456
 966:switcherator.c **** 
 967:switcherator.c **** void pwmValueSet(char * commandReceived) {
 968:switcherator.c ****     tempLongString[3] = 0;
 969:switcherator.c ****     tempLongString[0] = commandReceived[6];
 970:switcherator.c ****     tempLongString[1] = commandReceived[7];
 971:switcherator.c ****     tempLongString[2] = commandReceived[8];
 972:switcherator.c ****     pwmValues[0] = atoi(tempLongString);
 973:switcherator.c ****     tempLongString[0] = commandReceived[10];
 974:switcherator.c ****     tempLongString[1] = commandReceived[11];
 975:switcherator.c ****     tempLongString[2] = commandReceived[12];
 976:switcherator.c ****     pwmValues[1] = atoi(tempLongString);
 977:switcherator.c ****     tempLongString[0] = commandReceived[14];
 978:switcherator.c ****     tempLongString[1] = commandReceived[15];
 979:switcherator.c ****     tempLongString[2] = commandReceived[16];
 980:switcherator.c ****     pwmValues[2] = atoi(tempLongString);
 981:switcherator.c ****     statusMsg[0] = 0;
 982:switcherator.c ****     ok();
 983:switcherator.c **** }
 984:switcherator.c **** 
 985:switcherator.c **** // add a color to the color change
 986:switcherator.c **** // CC:##,vvv,vvv,vvv
 987:switcherator.c **** // 01234567890123456
 988:switcherator.c **** 
 989:switcherator.c **** void colorChangeSet(char * commandReceived) {
 990:switcherator.c ****     int programNumber = getSwitchNumber(commandReceived);
 991:switcherator.c ****     if (programNumber >= NUM_COLOR_CHANGES) {
 992:switcherator.c ****         fail(7);
 993:switcherator.c ****         return;
 994:switcherator.c ****     }
 995:switcherator.c ****     tempLongString[3] = 0;
 996:switcherator.c ****     tempLongString[0] = commandReceived[6];
 997:switcherator.c ****     tempLongString[1] = commandReceived[7];
 998:switcherator.c ****     tempLongString[2] = commandReceived[8];
 999:switcherator.c ****     colorChanges[programNumber][0] = atoi(tempLongString);
1000:switcherator.c ****     tempLongString[0] = commandReceived[10];
1001:switcherator.c ****     tempLongString[1] = commandReceived[11];
1002:switcherator.c ****     tempLongString[2] = commandReceived[12];
1003:switcherator.c ****     colorChanges[programNumber][1] = atoi(tempLongString);
1004:switcherator.c ****     tempLongString[0] = commandReceived[14];
1005:switcherator.c ****     tempLongString[1] = commandReceived[15];
1006:switcherator.c ****     tempLongString[2] = commandReceived[16];
1007:switcherator.c ****     colorChanges[programNumber][2] = atoi(tempLongString);
1008:switcherator.c ****     ok();
1009:switcherator.c **** }
1010:switcherator.c **** 
1011:switcherator.c **** // show the pwm values & color change values
1012:switcherator.c **** 
1013:switcherator.c **** void pwmSummary(void) {
1014:switcherator.c ****     statusMsg[0] = 0;
1015:switcherator.c ****     strcat(statusMsg, "Val 0x");
1016:switcherator.c ****     int x = 0;
1017:switcherator.c ****     for (x = 0; x < 3; x++) {
1018:switcherator.c ****         if (x > 0)
1019:switcherator.c ****             strcat(statusMsg, ",");
1020:switcherator.c ****         returnHexWithout(pwmValues[x], tempLongString);
1021:switcherator.c ****         strcat(statusMsg, tempLongString);
1022:switcherator.c ****     }
1023:switcherator.c ****     strcat(statusMsg, " dir ");
1024:switcherator.c ****     returnInt(pwmdir, tempLongString);
1025:switcherator.c ****     strcat(statusMsg, tempLongString);
1026:switcherator.c ****     sendMessage(statusMsg);
1027:switcherator.c ****     statusMsg[0] = 0;
1028:switcherator.c ****     strcat(statusMsg, "Col Ch");
1029:switcherator.c ****     int y = 0;
1030:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
1031:switcherator.c ****         if (x > 0)
1032:switcherator.c ****             strcat(statusMsg, ",");
1033:switcherator.c ****         strcat(statusMsg, "0x");
1034:switcherator.c ****         for (y = 0; y < 3; y++) {
1035:switcherator.c ****             returnHexWithout(colorChanges[x][y], tempLongString);
1036:switcherator.c ****             strcat(statusMsg, tempLongString);
1037:switcherator.c ****         }
1038:switcherator.c ****         if (strlen(statusMsg) > 25 && (x + 1) < NUM_COLOR_CHANGES) {
1039:switcherator.c ****             sendMessage(statusMsg);
1040:switcherator.c ****             statusMsg[6] = 0;
1041:switcherator.c ****         }
1042:switcherator.c ****     }
1043:switcherator.c ****     sendMessage(statusMsg);
1044:switcherator.c ****     statusMsg[0] = 0;
1045:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
1046:switcherator.c ****         if ((switchStuff[x] >= 200) && (switchStuff[x] <= 220)) {
1047:switcherator.c ****             strcat(statusMsg, "PWM ");
1048:switcherator.c ****             if (switchStuff[x] == 200) {
1049:switcherator.c ****                 strcat(statusMsg, "static");
1050:switcherator.c ****             } else if (switchStuff[x] == 202) {
1051:switcherator.c ****                 strcat(statusMsg, "ColCh");
1052:switcherator.c ****             } else {
1053:switcherator.c ****                 strcat(statusMsg, "hue");
1054:switcherator.c ****             }
1055:switcherator.c ****             strcat(statusMsg, "on sw# ");
1056:switcherator.c ****             returnInt(x, tempLongString);
1057:switcherator.c ****             strcat(statusMsg, tempLongString);
1058:switcherator.c ****             sendMessage(statusMsg);
1059:switcherator.c ****             statusMsg[0] = 0;
1060:switcherator.c ****         }
1061:switcherator.c ****     }
1062:switcherator.c **** }
1063:switcherator.c **** // HardwarePWM
1064:switcherator.c **** //static char runHue = 0;
1065:switcherator.c **** // PD3, PD5, PD6 or red,green,blue
1066:switcherator.c **** //static char pwmValues[] = {0 , 0 , 0};
1067:switcherator.c **** 
1068:switcherator.c **** // Run color function
1069:switcherator.c **** // goes through the colors and switches them.
1070:switcherator.c **** 
1071:switcherator.c **** void runColorFunction(void) {
 415               		.loc 1 1071 0
 416               	/* prologue: function */
 417               	/* frame size = 0 */
 418               	/* stack size = 0 */
 419               	.L__stack_usage = 0
1072:switcherator.c ****     // delay
1073:switcherator.c ****     colorChangeCount++;
 420               		.loc 1 1073 0
 421 01be 8091 0000 		lds r24,colorChangeCount
 422 01c2 9091 0000 		lds r25,colorChangeCount+1
 423 01c6 0196      		adiw r24,1
 424 01c8 9093 0000 		sts colorChangeCount+1,r25
 425 01cc 8093 0000 		sts colorChangeCount,r24
1074:switcherator.c ****     if (colorChangeCount < colorChangeSpeed)
 426               		.loc 1 1074 0
 427 01d0 2091 0000 		lds r18,colorChangeSpeed
 428 01d4 3091 0000 		lds r19,colorChangeSpeed+1
 429 01d8 8217      		cp r24,r18
 430 01da 9307      		cpc r25,r19
 431 01dc 00F4      		brsh .+2
 432 01de 00C0      		rjmp .L26
1075:switcherator.c ****         return;
1076:switcherator.c ****     colorChangeCount = 0;
 433               		.loc 1 1076 0
 434 01e0 1092 0000 		sts colorChangeCount+1,__zero_reg__
 435 01e4 1092 0000 		sts colorChangeCount,__zero_reg__
1077:switcherator.c ****     currentColor++;
 436               		.loc 1 1077 0
 437 01e8 8091 0000 		lds r24,currentColor
 438 01ec 8F5F      		subi r24,lo8(-(1))
1078:switcherator.c ****     if (currentColor == NUM_COLOR_CHANGES)
 439               		.loc 1 1078 0
 440 01ee 8630      		cpi r24,lo8(6)
 441 01f0 01F0      		breq .L29
1077:switcherator.c ****     currentColor++;
 442               		.loc 1 1077 0
 443 01f2 8093 0000 		sts currentColor,r24
 444 01f6 00C0      		rjmp .L30
 445               	.L29:
1079:switcherator.c ****         currentColor = 0;
 446               		.loc 1 1079 0
 447 01f8 1092 0000 		sts currentColor,__zero_reg__
 448               	.L30:
1080:switcherator.c ****     if (colorChanges[currentColor][0] == 0 &&
 449               		.loc 1 1080 0
 450 01fc 2091 0000 		lds r18,currentColor
 451 0200 822F      		mov r24,r18
 452 0202 90E0      		ldi r25,0
 453 0204 FC01      		movw r30,r24
 454 0206 EE0F      		lsl r30
 455 0208 FF1F      		rol r31
 456 020a E80F      		add r30,r24
 457 020c F91F      		adc r31,r25
 458 020e E050      		subi r30,lo8(-(colorChanges))
 459 0210 F040      		sbci r31,hi8(-(colorChanges))
 460 0212 8081      		ld r24,Z
 461 0214 8111      		cpse r24,__zero_reg__
 462 0216 00C0      		rjmp .L31
 463               		.loc 1 1080 0 is_stmt 0 discriminator 1
 464 0218 8181      		ldd r24,Z+1
 465 021a 8130      		cpi r24,lo8(1)
 466 021c 01F4      		brne .L31
1081:switcherator.c ****             colorChanges[currentColor][1] == 1 &&
 467               		.loc 1 1081 0 is_stmt 1
 468 021e 8281      		ldd r24,Z+2
 469 0220 8111      		cpse r24,__zero_reg__
 470 0222 00C0      		rjmp .L31
1082:switcherator.c ****             colorChanges[currentColor][2] == 0) {
1083:switcherator.c ****         // this one is blank.
1084:switcherator.c ****         if (currentColor == 0)
 471               		.loc 1 1084 0
 472 0224 2223      		tst r18
 473 0226 01F4      		brne .+2
 474 0228 00C0      		rjmp .L26
1085:switcherator.c ****             return;
1086:switcherator.c ****         currentColor = 0;
 475               		.loc 1 1086 0
 476 022a 1092 0000 		sts currentColor,__zero_reg__
 477               	.L31:
 478               	.LBB16:
 479               	.LBB17:
1087:switcherator.c ****     }
1088:switcherator.c ****     red = colorChanges[currentColor][0];
 480               		.loc 1 1088 0
 481 022e 8091 0000 		lds r24,currentColor
 482 0232 90E0      		ldi r25,0
1089:switcherator.c ****     green = colorChanges[currentColor][1];
 483               		.loc 1 1089 0
 484 0234 FC01      		movw r30,r24
 485 0236 EE0F      		lsl r30
 486 0238 FF1F      		rol r31
 487 023a E80F      		add r30,r24
 488 023c F91F      		adc r31,r25
 489 023e E050      		subi r30,lo8(-(colorChanges))
 490 0240 F040      		sbci r31,hi8(-(colorChanges))
 491 0242 8181      		ldd r24,Z+1
1090:switcherator.c ****     blue = colorChanges[currentColor][2];
 492               		.loc 1 1090 0
 493 0244 A281      		ldd r26,Z+2
1091:switcherator.c ****     red = red * bright / 16;
 494               		.loc 1 1091 0
 495 0246 6091 0000 		lds r22,bright
 496 024a 7091 0000 		lds r23,bright+1
1088:switcherator.c ****     red = colorChanges[currentColor][0];
 497               		.loc 1 1088 0
 498 024e 9081      		ld r25,Z
 499               		.loc 1 1091 0
 500 0250 969F      		mul r25,r22
 501 0252 A001      		movw r20,r0
 502 0254 979F      		mul r25,r23
 503 0256 500D      		add r21,r0
 504 0258 1124      		clr __zero_reg__
 505 025a 34E0      		ldi r19,4
 506               		1:
 507 025c 5695      		lsr r21
 508 025e 4795      		ror r20
 509 0260 3A95      		dec r19
 510 0262 01F4      		brne 1b
 511 0264 5093 0000 		sts red+1,r21
 512 0268 4093 0000 		sts red,r20
1092:switcherator.c ****     green = green * bright / 16;
 513               		.loc 1 1092 0
 514 026c 869F      		mul r24,r22
 515 026e 9001      		movw r18,r0
 516 0270 879F      		mul r24,r23
 517 0272 300D      		add r19,r0
 518 0274 1124      		clr __zero_reg__
 519 0276 54E0      		ldi r21,4
 520               		1:
 521 0278 3695      		lsr r19
 522 027a 2795      		ror r18
 523 027c 5A95      		dec r21
 524 027e 01F4      		brne 1b
 525 0280 3093 0000 		sts green+1,r19
 526 0284 2093 0000 		sts green,r18
1093:switcherator.c ****     blue = blue * bright / 16;
 527               		.loc 1 1093 0
 528 0288 A69F      		mul r26,r22
 529 028a C001      		movw r24,r0
 530 028c A79F      		mul r26,r23
 531 028e 900D      		add r25,r0
 532 0290 1124      		clr __zero_reg__
 533 0292 64E0      		ldi r22,4
 534               		1:
 535 0294 9695      		lsr r25
 536 0296 8795      		ror r24
 537 0298 6A95      		dec r22
 538 029a 01F4      		brne 1b
 539 029c 9093 0000 		sts blue+1,r25
 540 02a0 8093 0000 		sts blue,r24
1094:switcherator.c ****     Red = red;
 541               		.loc 1 1094 0
 542 02a4 4093 B400 		sts 180,r20
1095:switcherator.c ****     Green = green;
 543               		.loc 1 1095 0
 544 02a8 28BD      		out 0x28,r18
1096:switcherator.c ****     Blue = blue;
 545               		.loc 1 1096 0
 546 02aa 87BD      		out 0x27,r24
 547               	.L26:
 548 02ac 0895      		ret
 549               	.LBE17:
 550               	.LBE16:
 551               	.LFE27:
 553               	.global	runHueFunction
 555               	runHueFunction:
 556               	.LFB28:
1097:switcherator.c **** }
1098:switcherator.c **** // rotating hue
1099:switcherator.c **** //static int currentHue = 0;
1100:switcherator.c **** //static int hueSpeed = 0;
1101:switcherator.c **** //static char hueCount = 0;
1102:switcherator.c **** //#define Red OCR2B
1103:switcherator.c **** //#define Green OCR0B
1104:switcherator.c **** //#define Blue OCR0A
1105:switcherator.c **** 
1106:switcherator.c **** // go through and rotate the hue based color rotation
1107:switcherator.c **** // static int currentHue = 0;
1108:switcherator.c **** // static char hueSpeed = 0;
1109:switcherator.c **** // static char hueCount = 0;
1110:switcherator.c **** 
1111:switcherator.c **** void runHueFunction(void) {
 557               		.loc 1 1111 0
 558               	/* prologue: function */
 559               	/* frame size = 0 */
 560               	/* stack size = 0 */
 561               	.L__stack_usage = 0
1112:switcherator.c ****     // extra fixed delay
1113:switcherator.c ****     littleCount++;
 562               		.loc 1 1113 0
 563 02ae 8091 0000 		lds r24,littleCount
 564 02b2 8F5F      		subi r24,lo8(-(1))
 565 02b4 8093 0000 		sts littleCount,r24
1114:switcherator.c ****     if (littleCount != 2)
 566               		.loc 1 1114 0
 567 02b8 8230      		cpi r24,lo8(2)
 568 02ba 01F0      		breq .+2
 569 02bc 00C0      		rjmp .L36
1115:switcherator.c ****         return;
1116:switcherator.c ****     littleCount = 0;
 570               		.loc 1 1116 0
 571 02be 1092 0000 		sts littleCount,__zero_reg__
1117:switcherator.c ****     hueCount++;
 572               		.loc 1 1117 0
 573 02c2 8091 0000 		lds r24,hueCount
 574 02c6 9091 0000 		lds r25,hueCount+1
 575 02ca 0196      		adiw r24,1
 576 02cc 9093 0000 		sts hueCount+1,r25
 577 02d0 8093 0000 		sts hueCount,r24
1118:switcherator.c ****     // only run if the count is higher than the "speed"
1119:switcherator.c ****     if (hueCount < hueSpeed) {
 578               		.loc 1 1119 0
 579 02d4 2091 0000 		lds r18,hueSpeed
 580 02d8 3091 0000 		lds r19,hueSpeed+1
 581 02dc 8217      		cp r24,r18
 582 02de 9307      		cpc r25,r19
 583 02e0 00F4      		brsh .+2
 584 02e2 00C0      		rjmp .L36
1120:switcherator.c ****         return;
1121:switcherator.c ****     }
1122:switcherator.c ****     hueCount = 0;
 585               		.loc 1 1122 0
 586 02e4 1092 0000 		sts hueCount+1,__zero_reg__
 587 02e8 1092 0000 		sts hueCount,__zero_reg__
1123:switcherator.c ****     if (currentHue < 0x00ff) {
 588               		.loc 1 1123 0
 589 02ec 8091 0000 		lds r24,currentHue
 590 02f0 9091 0000 		lds r25,currentHue+1
 591 02f4 8F3F      		cpi r24,-1
 592 02f6 9105      		cpc r25,__zero_reg__
 593 02f8 00F4      		brsh .L40
1124:switcherator.c ****         red = 255;
 594               		.loc 1 1124 0
 595 02fa 2FEF      		ldi r18,lo8(-1)
 596 02fc 30E0      		ldi r19,0
 597 02fe 3093 0000 		sts red+1,r19
 598 0302 2093 0000 		sts red,r18
 599 0306 00C0      		rjmp .L47
 600               	.L40:
1125:switcherator.c ****         green = currentHue;
1126:switcherator.c ****         blue = 0;
1127:switcherator.c ****     } else if (currentHue < 0x01ff) {
 601               		.loc 1 1127 0
 602 0308 8F3F      		cpi r24,-1
 603 030a 21E0      		ldi r18,1
 604 030c 9207      		cpc r25,r18
 605 030e 00F4      		brsh .L42
1128:switcherator.c ****         red = 255 - (currentHue - 0xff);
 606               		.loc 1 1128 0
 607 0310 2EEF      		ldi r18,lo8(-2)
 608 0312 31E0      		ldi r19,lo8(1)
 609 0314 281B      		sub r18,r24
 610 0316 390B      		sbc r19,r25
 611 0318 3093 0000 		sts red+1,r19
 612 031c 2093 0000 		sts red,r18
1129:switcherator.c ****         green = 255;
 613               		.loc 1 1129 0
 614 0320 8FEF      		ldi r24,lo8(-1)
 615 0322 90E0      		ldi r25,0
 616               	.L47:
 617 0324 9093 0000 		sts green+1,r25
 618 0328 8093 0000 		sts green,r24
1130:switcherator.c ****         blue = 0;
 619               		.loc 1 1130 0
 620 032c 1092 0000 		sts blue+1,__zero_reg__
 621 0330 1092 0000 		sts blue,__zero_reg__
 622 0334 00C0      		rjmp .L41
 623               	.L42:
1131:switcherator.c ****     } else if (currentHue < 0x02ff) {
 624               		.loc 1 1131 0
 625 0336 8F3F      		cpi r24,-1
 626 0338 22E0      		ldi r18,2
 627 033a 9207      		cpc r25,r18
 628 033c 00F4      		brsh .L43
1132:switcherator.c ****         red = 0;
 629               		.loc 1 1132 0
 630 033e 1092 0000 		sts red+1,__zero_reg__
 631 0342 1092 0000 		sts red,__zero_reg__
1133:switcherator.c ****         green = 255;
 632               		.loc 1 1133 0
 633 0346 2FEF      		ldi r18,lo8(-1)
 634 0348 30E0      		ldi r19,0
 635 034a 3093 0000 		sts green+1,r19
 636 034e 2093 0000 		sts green,r18
1134:switcherator.c ****         blue = (currentHue - 0x1ff);
 637               		.loc 1 1134 0
 638 0352 8F5F      		subi r24,-1
 639 0354 9140      		sbci r25,1
 640 0356 00C0      		rjmp .L48
 641               	.L43:
1135:switcherator.c ****     } else if (currentHue < 0x03ff) {
 642               		.loc 1 1135 0
 643 0358 8F3F      		cpi r24,-1
 644 035a 23E0      		ldi r18,3
 645 035c 9207      		cpc r25,r18
 646 035e 00F4      		brsh .L44
1136:switcherator.c ****         red = 0;
 647               		.loc 1 1136 0
 648 0360 1092 0000 		sts red+1,__zero_reg__
 649 0364 1092 0000 		sts red,__zero_reg__
1137:switcherator.c ****         green = 255 - (currentHue - 0x2ff);
 650               		.loc 1 1137 0
 651 0368 2EEF      		ldi r18,lo8(-2)
 652 036a 33E0      		ldi r19,lo8(3)
 653 036c 281B      		sub r18,r24
 654 036e 390B      		sbc r19,r25
 655 0370 3093 0000 		sts green+1,r19
 656 0374 2093 0000 		sts green,r18
 657               	.L49:
1138:switcherator.c ****         blue = 255;
 658               		.loc 1 1138 0
 659 0378 8FEF      		ldi r24,lo8(-1)
 660 037a 90E0      		ldi r25,0
 661               	.L48:
 662 037c 9093 0000 		sts blue+1,r25
 663 0380 8093 0000 		sts blue,r24
 664 0384 00C0      		rjmp .L41
 665               	.L44:
1139:switcherator.c ****     } else if (currentHue < 0x04ff) {
 666               		.loc 1 1139 0
 667 0386 8F3F      		cpi r24,-1
 668 0388 24E0      		ldi r18,4
 669 038a 9207      		cpc r25,r18
 670 038c 00F4      		brsh .L45
1140:switcherator.c ****         red = (currentHue - 0x3ff);
 671               		.loc 1 1140 0
 672 038e 8F5F      		subi r24,-1
 673 0390 9340      		sbci r25,3
 674 0392 9093 0000 		sts red+1,r25
 675 0396 8093 0000 		sts red,r24
1141:switcherator.c ****         green = 0;
 676               		.loc 1 1141 0
 677 039a 1092 0000 		sts green+1,__zero_reg__
 678 039e 1092 0000 		sts green,__zero_reg__
 679 03a2 00C0      		rjmp .L49
 680               	.L45:
1142:switcherator.c ****         blue = 255;
1143:switcherator.c ****     } else if (currentHue < 0x05ff) {
 681               		.loc 1 1143 0
 682 03a4 8F3F      		cpi r24,-1
 683 03a6 25E0      		ldi r18,5
 684 03a8 9207      		cpc r25,r18
 685 03aa 00F4      		brsh .L46
1144:switcherator.c ****         red = 255;
 686               		.loc 1 1144 0
 687 03ac 2FEF      		ldi r18,lo8(-1)
 688 03ae 30E0      		ldi r19,0
 689 03b0 3093 0000 		sts red+1,r19
 690 03b4 2093 0000 		sts red,r18
1145:switcherator.c ****         green = 0;
 691               		.loc 1 1145 0
 692 03b8 1092 0000 		sts green+1,__zero_reg__
 693 03bc 1092 0000 		sts green,__zero_reg__
1146:switcherator.c ****         blue = 255 - (currentHue - 0x4ff);
 694               		.loc 1 1146 0
 695 03c0 2EEF      		ldi r18,lo8(-2)
 696 03c2 35E0      		ldi r19,lo8(5)
 697 03c4 281B      		sub r18,r24
 698 03c6 390B      		sbc r19,r25
 699 03c8 3093 0000 		sts blue+1,r19
 700 03cc 2093 0000 		sts blue,r18
 701 03d0 00C0      		rjmp .L41
 702               	.L46:
1147:switcherator.c ****     } else {
1148:switcherator.c ****         red = 255;
 703               		.loc 1 1148 0
 704 03d2 8FEF      		ldi r24,lo8(-1)
 705 03d4 90E0      		ldi r25,0
 706 03d6 9093 0000 		sts red+1,r25
 707 03da 8093 0000 		sts red,r24
1149:switcherator.c ****         green = 0;
 708               		.loc 1 1149 0
 709 03de 1092 0000 		sts green+1,__zero_reg__
 710 03e2 1092 0000 		sts green,__zero_reg__
1150:switcherator.c ****         blue = 0;
 711               		.loc 1 1150 0
 712 03e6 1092 0000 		sts blue+1,__zero_reg__
 713 03ea 1092 0000 		sts blue,__zero_reg__
1151:switcherator.c ****         currentHue = 0;
 714               		.loc 1 1151 0
 715 03ee 1092 0000 		sts currentHue+1,__zero_reg__
 716 03f2 1092 0000 		sts currentHue,__zero_reg__
 717               	.L41:
1152:switcherator.c ****     }
1153:switcherator.c ****     red = red * bright / 16;
 718               		.loc 1 1153 0
 719 03f6 6091 0000 		lds r22,bright
 720 03fa 7091 0000 		lds r23,bright+1
 721 03fe 8091 0000 		lds r24,red
 722 0402 9091 0000 		lds r25,red+1
 723 0406 689F      		mul r22,r24
 724 0408 A001      		movw r20,r0
 725 040a 699F      		mul r22,r25
 726 040c 500D      		add r21,r0
 727 040e 789F      		mul r23,r24
 728 0410 500D      		add r21,r0
 729 0412 1124      		clr r1
 730 0414 E4E0      		ldi r30,4
 731               		1:
 732 0416 5695      		lsr r21
 733 0418 4795      		ror r20
 734 041a EA95      		dec r30
 735 041c 01F4      		brne 1b
 736 041e 5093 0000 		sts red+1,r21
 737 0422 4093 0000 		sts red,r20
1154:switcherator.c ****     green = green * bright / 16;
 738               		.loc 1 1154 0
 739 0426 8091 0000 		lds r24,green
 740 042a 9091 0000 		lds r25,green+1
 741 042e 689F      		mul r22,r24
 742 0430 9001      		movw r18,r0
 743 0432 699F      		mul r22,r25
 744 0434 300D      		add r19,r0
 745 0436 789F      		mul r23,r24
 746 0438 300D      		add r19,r0
 747 043a 1124      		clr r1
 748 043c F4E0      		ldi r31,4
 749               		1:
 750 043e 3695      		lsr r19
 751 0440 2795      		ror r18
 752 0442 FA95      		dec r31
 753 0444 01F4      		brne 1b
 754 0446 3093 0000 		sts green+1,r19
 755 044a 2093 0000 		sts green,r18
1155:switcherator.c ****     blue = blue * bright / 16;
 756               		.loc 1 1155 0
 757 044e E091 0000 		lds r30,blue
 758 0452 F091 0000 		lds r31,blue+1
 759 0456 6E9F      		mul r22,r30
 760 0458 C001      		movw r24,r0
 761 045a 6F9F      		mul r22,r31
 762 045c 900D      		add r25,r0
 763 045e 7E9F      		mul r23,r30
 764 0460 900D      		add r25,r0
 765 0462 1124      		clr r1
 766 0464 A4E0      		ldi r26,4
 767               		1:
 768 0466 9695      		lsr r25
 769 0468 8795      		ror r24
 770 046a AA95      		dec r26
 771 046c 01F4      		brne 1b
 772 046e 9093 0000 		sts blue+1,r25
 773 0472 8093 0000 		sts blue,r24
1156:switcherator.c ****     Red = red;
 774               		.loc 1 1156 0
 775 0476 4093 B400 		sts 180,r20
1157:switcherator.c ****     Green = green;
 776               		.loc 1 1157 0
 777 047a 28BD      		out 0x28,r18
1158:switcherator.c ****     Blue = blue;
 778               		.loc 1 1158 0
 779 047c 87BD      		out 0x27,r24
1159:switcherator.c ****     currentHue++;
 780               		.loc 1 1159 0
 781 047e 8091 0000 		lds r24,currentHue
 782 0482 9091 0000 		lds r25,currentHue+1
 783 0486 0196      		adiw r24,1
 784 0488 9093 0000 		sts currentHue+1,r25
 785 048c 8093 0000 		sts currentHue,r24
 786               	.L36:
 787 0490 0895      		ret
 788               	.LFE28:
 790               	.global	clearTheProgram
 792               	clearTheProgram:
 793               	.LFB32:
1160:switcherator.c **** }
1161:switcherator.c **** 
1162:switcherator.c **** // sets the pwm brightness value
1163:switcherator.c **** // bs 16
1164:switcherator.c **** 
1165:switcherator.c **** void brightnessSet(char * commandReceived) {
1166:switcherator.c ****     int brightValue = getSwitchNumber(commandReceived);
1167:switcherator.c ****     if (brightValue == 0) {
1168:switcherator.c ****         // display the brightness
1169:switcherator.c ****         itoa(oldBright, tempIntString, 10);
1170:switcherator.c ****         statusMsg[0] = 0;
1171:switcherator.c ****         strcat(statusMsg, "Set @");
1172:switcherator.c ****         strcat(statusMsg, tempIntString);
1173:switcherator.c ****         strcat(statusMsg, "B@");
1174:switcherator.c ****         itoa(bright, tempIntString, 10);
1175:switcherator.c ****         strcat(statusMsg, tempIntString);
1176:switcherator.c ****         sendMessage(statusMsg);
1177:switcherator.c ****     } else {
1178:switcherator.c ****         if (brightValue > 16)
1179:switcherator.c ****             brightValue = 16;
1180:switcherator.c ****         if (oldBright == bright) {
1181:switcherator.c ****             // currently not being overridden
1182:switcherator.c ****             bright = brightValue;
1183:switcherator.c ****         }
1184:switcherator.c ****         oldBright = brightValue;
1185:switcherator.c ****         switchChanged = 1;
1186:switcherator.c ****         ok();
1187:switcherator.c ****     }
1188:switcherator.c **** }
1189:switcherator.c **** 
1190:switcherator.c **** 
1191:switcherator.c **** /****************************************************************
1192:switcherator.c ****  *
1193:switcherator.c ****  *              All Things Program Related
1194:switcherator.c ****  *
1195:switcherator.c ****  ****************************************************************/
1196:switcherator.c **** 
1197:switcherator.c **** // programs and such kept in EEPROM
1198:switcherator.c **** // 1 byte day of week mask or 0 for everyday
1199:switcherator.c **** // 2 byte start time (minutes), 2 bytes duration (seconds), 1 byte additional program
1200:switcherator.c **** // If more than 4 switches are desired it will roll over to an additional program
1201:switcherator.c **** // DssddSSSSP
1202:switcherator.c **** // 0123456789   
1203:switcherator.c **** //static unsigned char weeklyProgram[MAX_PROGRAM][10];
1204:switcherator.c **** //uart_puts_P("NewProgram, ClearProg, ProgAddSwitch, ProgDays, ProgTime, ProgDispln PN\r\n");
1205:switcherator.c **** //uart_puts_P("NP:P#HHMMDur. - CP:P# - PA:P#S# PD:P#SMTWTFS-PT:P#HHMMDur. PI:P#\r\n");
1206:switcherator.c **** //uart_puts_P("P#=Prog Num,HH=Hour,MM=Min,Dur.=Duration(min) SMTWTFS=1010000=Sun/Tue\r\n");
1207:switcherator.c **** 
1208:switcherator.c **** // Create a new program
1209:switcherator.c **** // NP:HHMMDur.
1210:switcherator.c **** // 0123456789012
1211:switcherator.c **** 
1212:switcherator.c **** void newProgram(char * commandReceived) {
1213:switcherator.c ****     int programNumber = 255;
1214:switcherator.c ****     int hours = 0;
1215:switcherator.c ****     int minutes = 0;
1216:switcherator.c ****     int startTime = 0;
1217:switcherator.c ****     int duration = 0;
1218:switcherator.c ****     int x = 0;
1219:switcherator.c ****     // find an open program;
1220:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
1221:switcherator.c ****         // dont want it to wrap though 0 is a valid program
1222:switcherator.c ****         if (weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) {
1223:switcherator.c ****             // Use this one
1224:switcherator.c ****             programNumber = x;
1225:switcherator.c ****             // end the loop
1226:switcherator.c ****             break;
1227:switcherator.c ****         }
1228:switcherator.c ****     }
1229:switcherator.c ****     if (programNumber == 255) {
1230:switcherator.c ****         fail(8);
1231:switcherator.c ****         return;
1232:switcherator.c ****     }
1233:switcherator.c ****     clearTheProgram(programNumber);
1234:switcherator.c ****     tempIntString[0] = commandReceived[3];
1235:switcherator.c ****     tempIntString[1] = commandReceived[4];
1236:switcherator.c ****     hours = atoi(tempIntString);
1237:switcherator.c ****     tempIntString[0] = commandReceived[5];
1238:switcherator.c ****     tempIntString[1] = commandReceived[6];
1239:switcherator.c ****     minutes = atoi(tempIntString);
1240:switcherator.c ****     tempLongString[0] = commandReceived[7];
1241:switcherator.c ****     tempLongString[1] = commandReceived[8];
1242:switcherator.c ****     tempLongString[2] = commandReceived[9];
1243:switcherator.c ****     tempLongString[3] = commandReceived[10];
1244:switcherator.c ****     duration = atoi(tempLongString);
1245:switcherator.c ****     if (hours >= 24 || (hours == 0 && commandReceived[4] != '0')) {
1246:switcherator.c ****         fail(9);
1247:switcherator.c ****         return;
1248:switcherator.c ****     }
1249:switcherator.c ****     if (minutes >= 60 || (minutes == 0 && commandReceived[6] != '0')) {
1250:switcherator.c ****         fail(0x0a);
1251:switcherator.c ****         return;
1252:switcherator.c ****     }
1253:switcherator.c ****     if (duration == 0) {
1254:switcherator.c ****         fail(0x0b);
1255:switcherator.c ****         return;
1256:switcherator.c ****     }
1257:switcherator.c ****     duration *= 60; // convert to seconds
1258:switcherator.c ****     startTime = (hours * 60);
1259:switcherator.c ****     startTime += minutes; // stored in minutes
1260:switcherator.c ****     int temp = 0;
1261:switcherator.c ****     temp = (startTime >> 8);
1262:switcherator.c ****     weeklyProgram[programNumber][1] = temp;
1263:switcherator.c ****     temp = (startTime & 0xff);
1264:switcherator.c ****     weeklyProgram[programNumber][2] = temp;
1265:switcherator.c ****     temp = (duration >> 8);
1266:switcherator.c ****     weeklyProgram[programNumber][3] = temp;
1267:switcherator.c ****     temp = (duration & 0xff);
1268:switcherator.c ****     weeklyProgram[programNumber][4] = temp;
1269:switcherator.c ****     statusMsg[0] = 0;
1270:switcherator.c ****     strcat(statusMsg, "New prog#");
1271:switcherator.c ****     returnInt(programNumber, tempIntString);
1272:switcherator.c ****     strcat(statusMsg, tempIntString);
1273:switcherator.c ****     sendMessage(statusMsg);
1274:switcherator.c **** }
1275:switcherator.c **** 
1276:switcherator.c **** // clears an existing program
1277:switcherator.c **** // the clearTheProgram does the work so this is the interface
1278:switcherator.c **** // CP:P#
1279:switcherator.c **** // 01234
1280:switcherator.c **** 
1281:switcherator.c **** void clearProgram(char * commandReceived) {
1282:switcherator.c ****     int programNumber = getSwitchNumber(commandReceived);
1283:switcherator.c ****     if (programNumber >= MAX_PROGRAM || (programNumber == 0 && commandReceived[4] != '0')) {
1284:switcherator.c ****         fail(2);
1285:switcherator.c ****     } else {
1286:switcherator.c ****         itoa(programNumber, tempIntString, 10);
1287:switcherator.c ****         ok();
1288:switcherator.c ****         clearTheProgram(programNumber);
1289:switcherator.c ****     }
1290:switcherator.c **** }
1291:switcherator.c **** 
1292:switcherator.c **** // zeros out the program
1293:switcherator.c **** 
1294:switcherator.c **** void clearTheProgram(int programNumber) {
 794               		.loc 1 1294 0
 795               	.LVL39:
 796               	/* prologue: function */
 797               	/* frame size = 0 */
 798               	/* stack size = 0 */
 799               	.L__stack_usage = 0
 800               		.loc 1 1294 0
 801 0492 2AE0      		ldi r18,lo8(10)
 802 0494 AC01      		movw r20,r24
 803 0496 249F      		mul r18,r20
 804 0498 C001      		movw r24,r0
 805 049a 259F      		mul r18,r21
 806 049c 900D      		add r25,r0
 807 049e 1124      		clr __zero_reg__
 808               	.LVL40:
 809 04a0 8050      		subi r24,lo8(-(weeklyProgram))
 810 04a2 9040      		sbci r25,hi8(-(weeklyProgram))
1295:switcherator.c ****     int x = 0;
1296:switcherator.c ****     // some of these "0" is a valid option so make it 255
1297:switcherator.c ****     for (x = 0; x < 10; x++) {
 811               		.loc 1 1297 0
 812 04a4 20E0      		ldi r18,0
 813 04a6 30E0      		ldi r19,0
1298:switcherator.c ****         weeklyProgram[programNumber][x] = 255;
 814               		.loc 1 1298 0
 815 04a8 4FEF      		ldi r20,lo8(-1)
 816               	.LVL41:
 817               	.L51:
1294:switcherator.c **** void clearTheProgram(int programNumber) {
 818               		.loc 1 1294 0 discriminator 2
 819 04aa FC01      		movw r30,r24
 820 04ac E20F      		add r30,r18
 821 04ae F31F      		adc r31,r19
 822               		.loc 1 1298 0 discriminator 2
 823 04b0 4083      		st Z,r20
1297:switcherator.c ****     for (x = 0; x < 10; x++) {
 824               		.loc 1 1297 0 discriminator 2
 825 04b2 2F5F      		subi r18,-1
 826 04b4 3F4F      		sbci r19,-1
 827               	.LVL42:
 828 04b6 2A30      		cpi r18,10
 829 04b8 3105      		cpc r19,__zero_reg__
 830 04ba 01F4      		brne .L51
 831               	/* epilogue start */
1299:switcherator.c ****     }
1300:switcherator.c **** }
 832               		.loc 1 1300 0
 833 04bc 0895      		ret
 834               	.LFE32:
 836               	.global	findOpenSwitch
 838               	findOpenSwitch:
 839               	.LFB34:
1301:switcherator.c **** 
1302:switcherator.c **** // there are multiple switches per program.  This adds them.
1303:switcherator.c **** // For memory constraints each program natively has up to 4
1304:switcherator.c **** // switches.  For more than that another program will be linked
1305:switcherator.c **** // Program in memory:
1306:switcherator.c **** // DssddSSSSP
1307:switcherator.c **** // 0123456789
1308:switcherator.c **** // PA:P#S#
1309:switcherator.c **** // 0123456
1310:switcherator.c **** 
1311:switcherator.c **** void programAddSwitch(char * commandReceived) {
1312:switcherator.c ****     int programNumber = 0;
1313:switcherator.c ****     int switchNumber = 0;
1314:switcherator.c ****     tempIntString[0] = commandReceived[3];
1315:switcherator.c ****     tempIntString[1] = commandReceived[4];
1316:switcherator.c ****     programNumber = atoi(tempIntString);
1317:switcherator.c ****     tempIntString[0] = commandReceived[5];
1318:switcherator.c ****     tempIntString[1] = commandReceived[6];
1319:switcherator.c ****     switchNumber = atoi(tempIntString);
1320:switcherator.c ****     char switches[NUM_SWITCHES];
1321:switcherator.c ****     switches[0] = 0;
1322:switcherator.c ****     int switchCount = programGetSwitches(programNumber, switches);
1323:switcherator.c ****     int x = 0;
1324:switcherator.c ****     // see if the switch is already there
1325:switcherator.c ****     for (x = 0; x < switchCount; x++) {
1326:switcherator.c ****         if (switches[x] == switchNumber) {
1327:switcherator.c ****             fail(0x0c);
1328:switcherator.c ****             return;
1329:switcherator.c ****         }
1330:switcherator.c ****     }
1331:switcherator.c **** 
1332:switcherator.c ****     // check validity 
1333:switcherator.c ****     if ((programNumber >= MAX_PROGRAM) || (programNumber == 0 && commandReceived[4] != '0')) {
1334:switcherator.c ****         fail(2);
1335:switcherator.c ****         return;
1336:switcherator.c ****     }
1337:switcherator.c ****     if ((switchNumber >= NUM_SWITCHES) || (switchNumber == 0 && commandReceived[6] != '0')) {
1338:switcherator.c ****         fail(1);
1339:switcherator.c ****         return;
1340:switcherator.c ****     }
1341:switcherator.c ****     // check for valid program
1342:switcherator.c ****     // The day mask maxes out at 127 - the high but shouldn't be set if it is valid
1343:switcherator.c ****     // unless it is a overflow program in which case the first switch will be set
1344:switcherator.c ****     // 255 = not set
1345:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
1346:switcherator.c ****         fail(0x0d);
1347:switcherator.c ****         return;
1348:switcherator.c ****     }
1349:switcherator.c ****     int noSwitchYet = 1;
1350:switcherator.c ****     int blankSwitch = 0;
1351:switcherator.c ****     int overflowProgram = 255;
1352:switcherator.c ****     // prepare number string for output later
1353:switcherator.c ****     itoa(programNumber, tempIntString, 10);
1354:switcherator.c ****     // see if our program has a valid switch
1355:switcherator.c ****     blankSwitch = findOpenSwitch(programNumber);
1356:switcherator.c ****     while (noSwitchYet == 1) {
1357:switcherator.c ****         if (blankSwitch == 0) {
1358:switcherator.c ****             // our program is full.  Find or make another one
1359:switcherator.c ****             // first check if we already are overflowing.
1360:switcherator.c ****             overflowProgram = weeklyProgram[programNumber][9];
1361:switcherator.c ****             if (overflowProgram == 255) {
1362:switcherator.c ****                 // no overflow.  Need to create one.
1363:switcherator.c ****                 // find blank program slot
1364:switcherator.c ****                 int possibleBlank = 255;
1365:switcherator.c ****                 // yeah I know but programNumber 0 won't be an overflow so there
1366:switcherator.c ****                 for (x = (MAX_PROGRAM - 1); x > 0; x--) {
1367:switcherator.c ****                     // dont want it to wrap though 0 is a valid program
1368:switcherator.c ****                     if (weeklyProgram[x][0] == 255 && weeklyProgram[x][5] == 255) {
1369:switcherator.c ****                         // this is blank
1370:switcherator.c ****                         possibleBlank = x;
1371:switcherator.c ****                         // end the loop
1372:switcherator.c ****                         x = 0;
1373:switcherator.c ****                     }
1374:switcherator.c ****                 }
1375:switcherator.c ****                 if (possibleBlank == 255) {
1376:switcherator.c ****                     // oh oh, no room
1377:switcherator.c ****                     fail(0x0e);
1378:switcherator.c ****                     return;
1379:switcherator.c ****                 }
1380:switcherator.c ****                 // now record the overflow and move forward
1381:switcherator.c ****                 weeklyProgram[programNumber][9] = possibleBlank;
1382:switcherator.c ****                 programNumber = possibleBlank;
1383:switcherator.c ****                 // and now we loop again...
1384:switcherator.c ****             } else {
1385:switcherator.c ****                 // move to overflow program and try again
1386:switcherator.c ****                 programNumber = overflowProgram;
1387:switcherator.c ****             }
1388:switcherator.c ****         } else { // if(blankSwitch == 0)
1389:switcherator.c ****             // we have a program and a slot.  move on.
1390:switcherator.c ****             noSwitchYet = 0;
1391:switcherator.c ****         }
1392:switcherator.c ****     }
1393:switcherator.c ****     weeklyProgram[programNumber][blankSwitch] = switchNumber;
1394:switcherator.c ****     ok();
1395:switcherator.c **** }
1396:switcherator.c **** 
1397:switcherator.c **** // iterates through a program and returns the index of an open switch or 0 if none
1398:switcherator.c **** 
1399:switcherator.c **** int findOpenSwitch(int programNumber) {
 840               		.loc 1 1399 0
 841               	.LVL43:
 842               	/* prologue: function */
 843               	/* frame size = 0 */
 844               	/* stack size = 0 */
 845               	.L__stack_usage = 0
 846               		.loc 1 1399 0
 847 04be 2AE0      		ldi r18,lo8(10)
 848 04c0 AC01      		movw r20,r24
 849 04c2 249F      		mul r18,r20
 850 04c4 C001      		movw r24,r0
 851 04c6 259F      		mul r18,r21
 852 04c8 900D      		add r25,r0
 853 04ca 1124      		clr __zero_reg__
 854               	.LVL44:
 855 04cc 8050      		subi r24,lo8(-(weeklyProgram))
 856 04ce 9040      		sbci r25,hi8(-(weeklyProgram))
1400:switcherator.c ****     int switchIndex = 0;
1401:switcherator.c ****     int x = 0;
1402:switcherator.c ****     for (x = 5; x < 9; x++) {
 857               		.loc 1 1402 0
 858 04d0 25E0      		ldi r18,lo8(5)
 859 04d2 30E0      		ldi r19,0
 860               	.LVL45:
 861               	.L55:
1399:switcherator.c **** int findOpenSwitch(int programNumber) {
 862               		.loc 1 1399 0
 863 04d4 FC01      		movw r30,r24
 864 04d6 E20F      		add r30,r18
 865 04d8 F31F      		adc r31,r19
1403:switcherator.c ****         if (weeklyProgram[programNumber][x] == 255) {
 866               		.loc 1 1403 0
 867 04da 4081      		ld r20,Z
 868 04dc 4F3F      		cpi r20,lo8(-1)
 869 04de 01F0      		breq .L54
1402:switcherator.c ****     for (x = 5; x < 9; x++) {
 870               		.loc 1 1402 0
 871 04e0 2F5F      		subi r18,-1
 872 04e2 3F4F      		sbci r19,-1
 873               	.LVL46:
 874 04e4 2930      		cpi r18,9
 875 04e6 3105      		cpc r19,__zero_reg__
 876 04e8 01F4      		brne .L55
1404:switcherator.c ****             // blank switch
1405:switcherator.c ****             switchIndex = x;
1406:switcherator.c ****             return switchIndex;
1407:switcherator.c ****         }
1408:switcherator.c ****     }
1409:switcherator.c ****     return 0;
 877               		.loc 1 1409 0
 878 04ea 20E0      		ldi r18,0
 879 04ec 30E0      		ldi r19,0
 880               	.LVL47:
 881               	.L54:
1410:switcherator.c **** }
 882               		.loc 1 1410 0
 883 04ee C901      		movw r24,r18
 884 04f0 0895      		ret
 885               	.LFE34:
 887               	.global	programGetSwitches
 889               	programGetSwitches:
 890               	.LFB38:
1411:switcherator.c **** 
1412:switcherator.c **** // Sets the days a program will run
1413:switcherator.c **** // PD:P#SMTWTFS
1414:switcherator.c **** // 012345678901
1415:switcherator.c **** 
1416:switcherator.c **** void programSetDays(char * commandReceived) {
1417:switcherator.c ****     char tempReallyLongString[] = "0000000";
1418:switcherator.c ****     int programNumber = 0;
1419:switcherator.c ****     long weekLong = 0;
1420:switcherator.c ****     tempIntString[0] = commandReceived[3];
1421:switcherator.c ****     tempIntString[1] = commandReceived[4];
1422:switcherator.c ****     programNumber = atoi(tempIntString);
1423:switcherator.c ****     tempReallyLongString[0] = commandReceived[5];
1424:switcherator.c ****     tempReallyLongString[1] = commandReceived[6];
1425:switcherator.c ****     tempReallyLongString[2] = commandReceived[7];
1426:switcherator.c ****     tempReallyLongString[3] = commandReceived[8];
1427:switcherator.c ****     tempReallyLongString[4] = commandReceived[9];
1428:switcherator.c ****     tempReallyLongString[5] = commandReceived[10];
1429:switcherator.c ****     tempReallyLongString[6] = commandReceived[11];
1430:switcherator.c ****     weekLong = strtol(tempReallyLongString, 0, 2);
1431:switcherator.c ****     if ((programNumber >= MAX_PROGRAM) || (programNumber == 0 && commandReceived[4] != '0')) {
1432:switcherator.c ****         fail(2);
1433:switcherator.c ****         return;
1434:switcherator.c ****     }
1435:switcherator.c ****     // check for valid program
1436:switcherator.c ****     // The day mask maxes out at 127 - the high but shouldn't be set if it is valid
1437:switcherator.c ****     // unless it is a overflow program in which case the first switch will be set
1438:switcherator.c ****     // 255 = not set
1439:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
1440:switcherator.c ****         fail(0x0d);
1441:switcherator.c ****         return;
1442:switcherator.c ****     }
1443:switcherator.c ****     if ((weekLong & 0x7f) == 0) {
1444:switcherator.c ****         fail(0x0f);
1445:switcherator.c ****         return;
1446:switcherator.c ****     }
1447:switcherator.c ****     char weekdays = (weekLong & 0x7f);
1448:switcherator.c ****     weeklyProgram[programNumber][0] = weekdays;
1449:switcherator.c ****     ok();
1450:switcherator.c **** }
1451:switcherator.c **** 
1452:switcherator.c **** // DssddSSSSP
1453:switcherator.c **** // 0123456789   
1454:switcherator.c **** // PT:P#HHMMDur.
1455:switcherator.c **** // 0123456789012
1456:switcherator.c **** 
1457:switcherator.c **** void programSetTime(char * commandReceived) {
1458:switcherator.c ****     int programNumber = 0;
1459:switcherator.c ****     int hours = 0;
1460:switcherator.c ****     int minutes = 0;
1461:switcherator.c ****     int startTime = 0;
1462:switcherator.c ****     int duration = 0;
1463:switcherator.c ****     tempIntString[0] = commandReceived[3];
1464:switcherator.c ****     tempIntString[1] = commandReceived[4];
1465:switcherator.c ****     programNumber = atoi(tempIntString);
1466:switcherator.c ****     if (programNumber >= MAX_PROGRAM || (programNumber == 0 && commandReceived[4] != '0')) {
1467:switcherator.c ****         fail(2);
1468:switcherator.c ****         return;
1469:switcherator.c ****     }
1470:switcherator.c ****     // check for valid program
1471:switcherator.c ****     // The day mask maxes out at 127 - the high but shouldn't be set if it is valid
1472:switcherator.c ****     // unless it is a overflow program in which case the first switch will be set
1473:switcherator.c ****     // 255 = not set
1474:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
1475:switcherator.c ****         fail(0x0d);
1476:switcherator.c ****         return;
1477:switcherator.c ****     }
1478:switcherator.c ****     tempIntString[0] = commandReceived[5];
1479:switcherator.c ****     tempIntString[1] = commandReceived[6];
1480:switcherator.c ****     hours = atoi(tempIntString);
1481:switcherator.c ****     tempIntString[0] = commandReceived[7];
1482:switcherator.c ****     tempIntString[1] = commandReceived[8];
1483:switcherator.c ****     minutes = atoi(tempIntString);
1484:switcherator.c ****     tempLongString[0] = commandReceived[9];
1485:switcherator.c ****     tempLongString[1] = commandReceived[10];
1486:switcherator.c ****     tempLongString[2] = commandReceived[11];
1487:switcherator.c ****     tempLongString[3] = commandReceived[12];
1488:switcherator.c ****     duration = atoi(tempLongString);
1489:switcherator.c ****     if (hours >= 24 || (hours == 0 && commandReceived[6] != '0')) {
1490:switcherator.c ****         fail(9);
1491:switcherator.c ****         return;
1492:switcherator.c ****     }
1493:switcherator.c ****     if (minutes >= 60 || (minutes == 0 && commandReceived[8] != '0')) {
1494:switcherator.c ****         fail(0x0a);
1495:switcherator.c ****         return;
1496:switcherator.c ****     }
1497:switcherator.c ****     if (duration == 0) {
1498:switcherator.c ****         fail(0x0b);
1499:switcherator.c ****         return;
1500:switcherator.c ****     }
1501:switcherator.c ****     duration *= 60; // convert to seconds
1502:switcherator.c ****     startTime = (hours * 60);
1503:switcherator.c ****     startTime += minutes; // stored in minutes
1504:switcherator.c ****     int temp = 0;
1505:switcherator.c ****     temp = (startTime >> 8);
1506:switcherator.c ****     weeklyProgram[programNumber][1] = temp;
1507:switcherator.c ****     temp = (startTime & 0xff);
1508:switcherator.c ****     weeklyProgram[programNumber][2] = temp;
1509:switcherator.c ****     temp = (duration >> 8);
1510:switcherator.c ****     weeklyProgram[programNumber][3] = temp;
1511:switcherator.c ****     temp = (duration & 0xff);
1512:switcherator.c ****     weeklyProgram[programNumber][4] = temp;
1513:switcherator.c ****     ok();
1514:switcherator.c **** }
1515:switcherator.c **** 
1516:switcherator.c **** void programDisplay(char * commandReceived) {
1517:switcherator.c ****     int x = 0;
1518:switcherator.c ****     int programNumber = 0;
1519:switcherator.c ****     tempIntString[0] = commandReceived[3];
1520:switcherator.c ****     tempIntString[1] = commandReceived[4];
1521:switcherator.c ****     programNumber = atoi(tempIntString);
1522:switcherator.c ****     statusMsg[0] = 0;
1523:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
1524:switcherator.c ****         strcat(statusMsg, "P#");
1525:switcherator.c ****         returnInt(programNumber, tempIntString);
1526:switcherator.c ****         strcat(statusMsg, tempIntString);
1527:switcherator.c ****         strcat(statusMsg, "blank.");
1528:switcherator.c ****         sendMessage(statusMsg);
1529:switcherator.c ****         return;
1530:switcherator.c ****     }
1531:switcherator.c ****     char switches[NUM_SWITCHES];
1532:switcherator.c ****     switches[0] = 0;
1533:switcherator.c ****     int switchCount = 0;
1534:switcherator.c ****     switchCount = programGetSwitches(programNumber, switches);
1535:switcherator.c ****     statusMsg[0] = 0;
1536:switcherator.c ****     strcat(statusMsg, "Prog#");
1537:switcherator.c ****     itoa(programNumber, tempIntString, 10);
1538:switcherator.c ****     strcat(statusMsg, tempIntString);
1539:switcherator.c ****     if (switchCount == 0) {
1540:switcherator.c ****         strcat(switches, "S:-");
1541:switcherator.c ****     } else {
1542:switcherator.c ****         int temp = 0;
1543:switcherator.c ****         strcat(statusMsg, "S");
1544:switcherator.c ****         for (x = 0; x < switchCount; x++) {
1545:switcherator.c ****             strcat(statusMsg, ":");
1546:switcherator.c ****             temp = switches[x];
1547:switcherator.c ****             itoa(temp, tempIntString, 10);
1548:switcherator.c ****             strcat(statusMsg, tempIntString);
1549:switcherator.c ****         }
1550:switcherator.c ****     }
1551:switcherator.c ****     sendMessage(statusMsg);
1552:switcherator.c ****     statusMsg[0] = 0;
1553:switcherator.c ****     unsigned int time = 0;
1554:switcherator.c ****     time = weeklyProgram[programNumber][1];
1555:switcherator.c ****     time <<= 8;
1556:switcherator.c ****     time |= weeklyProgram[programNumber][2];
1557:switcherator.c ****     unsigned int hours = (time / 60);
1558:switcherator.c ****     unsigned int minutes = (time - (hours * 60));
1559:switcherator.c ****     time = weeklyProgram[programNumber][3];
1560:switcherator.c ****     time <<= 8;
1561:switcherator.c ****     time |= weeklyProgram[programNumber][4];
1562:switcherator.c ****     int duration = (time / 60);
1563:switcherator.c ****     char weekdays = 0;
1564:switcherator.c ****     weekdays = weeklyProgram[programNumber][0];
1565:switcherator.c ****     strcat(statusMsg, "T:");
1566:switcherator.c ****     itoa(hours, tempIntString, 10);
1567:switcherator.c ****     strcat(statusMsg, tempIntString);
1568:switcherator.c ****     strcat(statusMsg, ":");
1569:switcherator.c ****     itoa(minutes, tempIntString, 10);
1570:switcherator.c ****     strcat(statusMsg, tempIntString);
1571:switcherator.c ****     strcat(statusMsg, " Dur:");
1572:switcherator.c ****     itoa(duration, tempLongString, 10);
1573:switcherator.c ****     strcat(statusMsg, tempLongString);
1574:switcherator.c ****     strcat(statusMsg, "Days:");
1575:switcherator.c ****     if (weekdays == 255) {
1576:switcherator.c ****         strcat(statusMsg, "-------");
1577:switcherator.c ****         sendMessage(statusMsg);
1578:switcherator.c ****         return;
1579:switcherator.c ****     }
1580:switcherator.c ****     if (weekdays & 0x40) {
1581:switcherator.c ****         strcat(statusMsg, "S");
1582:switcherator.c ****     } else {
1583:switcherator.c ****         strcat(statusMsg, "-");
1584:switcherator.c ****     }
1585:switcherator.c ****     if (weekdays & 0x20) {
1586:switcherator.c ****         strcat(statusMsg, "M");
1587:switcherator.c ****     } else {
1588:switcherator.c ****         strcat(statusMsg, "-");
1589:switcherator.c ****     }
1590:switcherator.c ****     if (weekdays & 0x10) {
1591:switcherator.c ****         strcat(statusMsg, "T");
1592:switcherator.c ****     } else {
1593:switcherator.c ****         strcat(statusMsg, "-");
1594:switcherator.c ****     }
1595:switcherator.c ****     if (weekdays & 0x08) {
1596:switcherator.c ****         strcat(statusMsg, "W");
1597:switcherator.c ****     } else {
1598:switcherator.c ****         strcat(statusMsg, "-");
1599:switcherator.c ****     }
1600:switcherator.c ****     if (weekdays & 0x04) {
1601:switcherator.c ****         strcat(statusMsg, "T");
1602:switcherator.c ****     } else {
1603:switcherator.c ****         strcat(statusMsg, "-");
1604:switcherator.c ****     }
1605:switcherator.c ****     if (weekdays & 0x02) {
1606:switcherator.c ****         strcat(statusMsg, "F");
1607:switcherator.c ****     } else {
1608:switcherator.c ****         strcat(statusMsg, "-");
1609:switcherator.c ****     }
1610:switcherator.c ****     if (weekdays & 0x01) {
1611:switcherator.c ****         strcat(statusMsg, "S");
1612:switcherator.c ****     } else {
1613:switcherator.c ****         strcat(statusMsg, "-");
1614:switcherator.c ****     }
1615:switcherator.c **** 
1616:switcherator.c ****     sendMessage(statusMsg);
1617:switcherator.c **** }
1618:switcherator.c **** 
1619:switcherator.c **** // get the switches for a program
1620:switcherator.c **** // char * switches should be set as large as NUM_SWITCHES
1621:switcherator.c **** // so you don't overflow
1622:switcherator.c **** 
1623:switcherator.c **** int programGetSwitches(int programNumber, char * switches) {
 891               		.loc 1 1623 0
 892               	.LVL48:
 893 04f2 CF93      		push r28
 894               	.LCFI8:
 895 04f4 DF93      		push r29
 896               	.LCFI9:
 897               	/* prologue: function */
 898               	/* frame size = 0 */
 899               	/* stack size = 2 */
 900               	.L__stack_usage = 2
 901               	.LVL49:
1624:switcherator.c ****     int element = 0;
 902               		.loc 1 1624 0
 903 04f6 20E0      		ldi r18,0
 904 04f8 30E0      		ldi r19,0
1623:switcherator.c **** int programGetSwitches(int programNumber, char * switches) {
 905               		.loc 1 1623 0
 906 04fa CAE0      		ldi r28,lo8(10)
 907               	.LVL50:
 908               	.L61:
 909 04fc F901      		movw r30,r18
 910 04fe 3496      		adiw r30,4
 911 0500 C89F      		mul r28,r24
 912 0502 A001      		movw r20,r0
 913 0504 C99F      		mul r28,r25
 914 0506 500D      		add r21,r0
 915 0508 1124      		clr __zero_reg__
 916 050a 421B      		sub r20,r18
 917 050c 530B      		sbc r21,r19
 918 050e 4050      		subi r20,lo8(-(weeklyProgram))
 919 0510 5040      		sbci r21,hi8(-(weeklyProgram))
 920               	.LVL51:
 921               	.L60:
 922 0512 DA01      		movw r26,r20
 923 0514 A20F      		add r26,r18
 924 0516 B31F      		adc r27,r19
1625:switcherator.c ****     int x = 0;
1626:switcherator.c ****     // start loading the switch array
1627:switcherator.c ****     while (1) {
1628:switcherator.c ****         for (x = 5; x < 9; x++) {
1629:switcherator.c ****             if (weeklyProgram[programNumber][x] == 255) {
 925               		.loc 1 1629 0
 926 0518 1596      		adiw r26,5
 927 051a DC91      		ld r29,X
 928 051c DF3F      		cpi r29,lo8(-1)
 929 051e 01F0      		breq .L59
1623:switcherator.c **** int programGetSwitches(int programNumber, char * switches) {
 930               		.loc 1 1623 0
 931 0520 DB01      		movw r26,r22
 932 0522 A20F      		add r26,r18
 933 0524 B31F      		adc r27,r19
1630:switcherator.c ****                 // blank switch we are done
1631:switcherator.c ****                 return element;
1632:switcherator.c ****             } else {
1633:switcherator.c ****                 switches[element] = weeklyProgram[programNumber][x];
 934               		.loc 1 1633 0
 935 0526 DC93      		st X,r29
1634:switcherator.c ****                 element++;
 936               		.loc 1 1634 0
 937 0528 2F5F      		subi r18,-1
 938 052a 3F4F      		sbci r19,-1
 939               	.LVL52:
1628:switcherator.c ****         for (x = 5; x < 9; x++) {
 940               		.loc 1 1628 0
 941 052c 2E17      		cp r18,r30
 942 052e 3F07      		cpc r19,r31
 943 0530 01F4      		brne .L60
1635:switcherator.c ****             }
1636:switcherator.c ****         } // for x=5-9
1637:switcherator.c ****         // see if this program iterates around
1638:switcherator.c ****         if (weeklyProgram[programNumber][9] == 255) {
 944               		.loc 1 1638 0
 945 0532 C89F      		mul r28,r24
 946 0534 F001      		movw r30,r0
 947 0536 C99F      		mul r28,r25
 948 0538 F00D      		add r31,r0
 949 053a 1124      		clr __zero_reg__
 950 053c E050      		subi r30,lo8(-(weeklyProgram))
 951 053e F040      		sbci r31,hi8(-(weeklyProgram))
 952 0540 8185      		ldd r24,Z+9
 953               	.LVL53:
 954 0542 8F3F      		cpi r24,lo8(-1)
 955 0544 01F0      		breq .L59
1639:switcherator.c ****             // we are done;
1640:switcherator.c ****             return element;
1641:switcherator.c ****         } else {
1642:switcherator.c ****             // move to the next programNumber and continue
1643:switcherator.c ****             programNumber = weeklyProgram[programNumber][9];
 956               		.loc 1 1643 0
 957 0546 90E0      		ldi r25,0
 958               	.LVL54:
1644:switcherator.c ****         }
1645:switcherator.c ****     }
 959               		.loc 1 1645 0
 960 0548 00C0      		rjmp .L61
 961               	.LVL55:
 962               	.L59:
1646:switcherator.c **** }
 963               		.loc 1 1646 0
 964 054a C901      		movw r24,r18
 965               	/* epilogue start */
 966 054c DF91      		pop r29
 967 054e CF91      		pop r28
 968 0550 0895      		ret
 969               	.LFE38:
 971               	.global	startTheProgram
 973               	startTheProgram:
 974               	.LFB40:
1647:switcherator.c **** 
1648:switcherator.c **** // takes in a program number and time and turns on the program
1649:switcherator.c **** // SP P#Durat.
1650:switcherator.c **** // 01234567890
1651:switcherator.c **** 
1652:switcherator.c **** void startProgram(char * commandReceived) {
1653:switcherator.c ****     unsigned long duration;
1654:switcherator.c ****     int programNumber = 0;
1655:switcherator.c ****     // get switch number
1656:switcherator.c ****     tempIntString[0] = commandReceived[3];
1657:switcherator.c ****     tempIntString[1] = commandReceived[4];
1658:switcherator.c ****     programNumber = atoi(tempIntString);
1659:switcherator.c ****     if (programNumber >= MAX_PROGRAM) {
1660:switcherator.c ****         fail(2);
1661:switcherator.c ****         return;
1662:switcherator.c ****     }
1663:switcherator.c ****     // get duration
1664:switcherator.c ****     tempHugeString[0] = commandReceived[5];
1665:switcherator.c ****     tempHugeString[1] = commandReceived[6];
1666:switcherator.c ****     tempHugeString[2] = commandReceived[7];
1667:switcherator.c ****     tempHugeString[3] = commandReceived[8];
1668:switcherator.c ****     tempHugeString[4] = commandReceived[9];
1669:switcherator.c ****     tempHugeString[5] = commandReceived[10];
1670:switcherator.c ****     duration = atol(tempHugeString);
1671:switcherator.c ****     startTheProgram(programNumber, duration, 0);
1672:switcherator.c ****     ok();
1673:switcherator.c **** }
1674:switcherator.c **** 
1675:switcherator.c **** void startTheProgram(int programNumber, int duration, long time) {
 975               		.loc 1 1675 0
 976               	.LVL56:
 977 0552 8F92      		push r8
 978               	.LCFI10:
 979 0554 9F92      		push r9
 980               	.LCFI11:
 981 0556 AF92      		push r10
 982               	.LCFI12:
 983 0558 BF92      		push r11
 984               	.LCFI13:
 985 055a CF92      		push r12
 986               	.LCFI14:
 987 055c DF92      		push r13
 988               	.LCFI15:
 989 055e EF92      		push r14
 990               	.LCFI16:
 991 0560 FF92      		push r15
 992               	.LCFI17:
 993 0562 1F93      		push r17
 994               	.LCFI18:
 995 0564 CF93      		push r28
 996               	.LCFI19:
 997 0566 DF93      		push r29
 998               	.LCFI20:
 999 0568 CDB7      		in r28,__SP_L__
 1000 056a DEB7      		in r29,__SP_H__
 1001               	.LCFI21:
 1002 056c 6497      		sbiw r28,20
 1003               	.LCFI22:
 1004 056e 0FB6      		in __tmp_reg__,__SREG__
 1005 0570 F894      		cli
 1006 0572 DEBF      		out __SP_H__,r29
 1007 0574 0FBE      		out __SREG__,__tmp_reg__
 1008 0576 CDBF      		out __SP_L__,r28
 1009               	/* prologue: function */
 1010               	/* frame size = 20 */
 1011               	/* stack size = 31 */
 1012               	.L__stack_usage = 31
 1013 0578 4B01      		movw r8,r22
 1014               	.LVL57:
1676:switcherator.c ****     char switches[NUM_SWITCHES];
1677:switcherator.c ****     int switchCount = 0;
1678:switcherator.c ****     int thisSwitch = 0;
1679:switcherator.c ****     int x = 0;
1680:switcherator.c **** 
1681:switcherator.c ****     if (duration == 0) {
 1015               		.loc 1 1681 0
 1016 057a 6115      		cp r22,__zero_reg__
 1017 057c 7105      		cpc r23,__zero_reg__
 1018 057e 01F4      		brne .L70
 1019               	.LVL58:
1682:switcherator.c ****         // get the duration since we weren't fed it
1683:switcherator.c ****         duration = weeklyProgram[programNumber][3];
1684:switcherator.c ****         duration <<= 8;
1685:switcherator.c ****         duration = weeklyProgram[programNumber][4];
 1020               		.loc 1 1685 0
 1021 0580 6AE0      		ldi r22,lo8(10)
 1022 0582 689F      		mul r22,r24
 1023 0584 F001      		movw r30,r0
 1024 0586 699F      		mul r22,r25
 1025 0588 F00D      		add r31,r0
 1026 058a 1124      		clr __zero_reg__
 1027 058c E050      		subi r30,lo8(-(weeklyProgram))
 1028 058e F040      		sbci r31,hi8(-(weeklyProgram))
 1029 0590 8480      		ldd r8,Z+4
 1030 0592 912C      		mov r9,__zero_reg__
 1031               	.LVL59:
 1032               	.L70:
1686:switcherator.c ****     }
1687:switcherator.c ****     switchCount = programGetSwitches(programNumber, switches);
 1033               		.loc 1 1687 0
 1034 0594 BE01      		movw r22,r28
 1035 0596 6F5F      		subi r22,-1
 1036 0598 7F4F      		sbci r23,-1
 1037 059a 298B      		std Y+17,r18
 1038 059c 3A8B      		std Y+18,r19
 1039 059e 4B8B      		std Y+19,r20
 1040 05a0 5C8B      		std Y+20,r21
 1041 05a2 0E94 0000 		call programGetSwitches
 1042               	.LVL60:
 1043 05a6 AA24      		clr r10
 1044 05a8 97FC      		sbrc r9,7
 1045 05aa A094      		com r10
 1046 05ac BA2C      		mov r11,r10
 1047 05ae C090 0000 		lds r12,weeklySeconds
 1048 05b2 D090 0000 		lds r13,weeklySeconds+1
 1049 05b6 E090 0000 		lds r14,weeklySeconds+2
 1050 05ba F090 0000 		lds r15,weeklySeconds+3
1688:switcherator.c ****     // see if we were fed the start time so we don't go too long
1689:switcherator.c ****     // this may run multiple times
1690:switcherator.c ****     if (time == 0) {
 1051               		.loc 1 1690 0
 1052 05be 2989      		ldd r18,Y+17
 1053 05c0 3A89      		ldd r19,Y+18
 1054 05c2 4B89      		ldd r20,Y+19
 1055 05c4 5C89      		ldd r21,Y+20
 1056 05c6 2115      		cp r18,__zero_reg__
 1057 05c8 3105      		cpc r19,__zero_reg__
 1058 05ca 4105      		cpc r20,__zero_reg__
 1059 05cc 5105      		cpc r21,__zero_reg__
 1060 05ce 01F4      		brne .L71
1691:switcherator.c ****         time = weeklySeconds + duration;
 1061               		.loc 1 1691 0
 1062 05d0 A501      		movw r20,r10
 1063 05d2 9401      		movw r18,r8
 1064 05d4 2C0D      		add r18,r12
 1065 05d6 3D1D      		adc r19,r13
 1066 05d8 4E1D      		adc r20,r14
 1067 05da 5F1D      		adc r21,r15
 1068               	.LVL61:
 1069               	.L71:
1692:switcherator.c ****     }
1693:switcherator.c ****     for (x = 0; x < switchCount; x++) {
1694:switcherator.c ****         thisSwitch = switches[x];
1695:switcherator.c ****         // only update the time if it is longer than what the switch is already turned on to
1696:switcherator.c ****         if ((weeklySeconds + duration) > switchStatus[thisSwitch])
 1070               		.loc 1 1696 0
 1071 05dc C80C      		add r12,r8
 1072 05de D91C      		adc r13,r9
 1073 05e0 EA1C      		adc r14,r10
 1074 05e2 FB1C      		adc r15,r11
 1075 05e4 FE01      		movw r30,r28
 1076 05e6 3196      		adiw r30,1
1675:switcherator.c **** void startTheProgram(int programNumber, int duration, long time) {
 1077               		.loc 1 1675 0
 1078 05e8 BF01      		movw r22,r30
1693:switcherator.c ****     for (x = 0; x < switchCount; x++) {
 1079               		.loc 1 1693 0
 1080 05ea 00C0      		rjmp .L77
 1081               	.LVL62:
 1082               	.L74:
1694:switcherator.c ****         thisSwitch = switches[x];
 1083               		.loc 1 1694 0
 1084 05ec A191      		ld r26,Z+
 1085               	.LVL63:
 1086               		.loc 1 1696 0
 1087 05ee 14E0      		ldi r17,lo8(4)
 1088 05f0 A19F      		mul r26,r17
 1089 05f2 D001      		movw r26,r0
 1090 05f4 1124      		clr __zero_reg__
 1091               	.LVL64:
 1092 05f6 A050      		subi r26,lo8(-(switchStatus))
 1093 05f8 B040      		sbci r27,hi8(-(switchStatus))
 1094 05fa 8D90      		ld r8,X+
 1095 05fc 9D90      		ld r9,X+
 1096 05fe AD90      		ld r10,X+
 1097 0600 BC90      		ld r11,X
 1098 0602 1397      		sbiw r26,3
 1099 0604 8C14      		cp r8,r12
 1100 0606 9D04      		cpc r9,r13
 1101 0608 AE04      		cpc r10,r14
 1102 060a BF04      		cpc r11,r15
 1103 060c 00F4      		brsh .L77
1697:switcherator.c ****             switchStatus[thisSwitch] = time;
 1104               		.loc 1 1697 0
 1105 060e 2D93      		st X+,r18
 1106 0610 3D93      		st X+,r19
 1107 0612 4D93      		st X+,r20
 1108 0614 5C93      		st X,r21
 1109 0616 1397      		sbiw r26,3
 1110               	.LVL65:
 1111               	.L77:
1675:switcherator.c **** void startTheProgram(int programNumber, int duration, long time) {
 1112               		.loc 1 1675 0 discriminator 1
 1113 0618 DF01      		movw r26,r30
 1114 061a A61B      		sub r26,r22
 1115 061c B70B      		sbc r27,r23
1693:switcherator.c ****     for (x = 0; x < switchCount; x++) {
 1116               		.loc 1 1693 0 discriminator 1
 1117 061e A817      		cp r26,r24
 1118 0620 B907      		cpc r27,r25
 1119 0622 04F0      		brlt .L74
1698:switcherator.c ****     }
1699:switcherator.c ****     switchChanged = 1;
 1120               		.loc 1 1699 0
 1121 0624 81E0      		ldi r24,lo8(1)
 1122               	.LVL66:
 1123 0626 8093 0000 		sts switchChanged,r24
 1124               	/* epilogue start */
1700:switcherator.c **** }
 1125               		.loc 1 1700 0
 1126 062a 6496      		adiw r28,20
 1127 062c 0FB6      		in __tmp_reg__,__SREG__
 1128 062e F894      		cli
 1129 0630 DEBF      		out __SP_H__,r29
 1130 0632 0FBE      		out __SREG__,__tmp_reg__
 1131 0634 CDBF      		out __SP_L__,r28
 1132 0636 DF91      		pop r29
 1133 0638 CF91      		pop r28
 1134 063a 1F91      		pop r17
 1135 063c FF90      		pop r15
 1136 063e EF90      		pop r14
 1137 0640 DF90      		pop r13
 1138 0642 CF90      		pop r12
 1139 0644 BF90      		pop r11
 1140 0646 AF90      		pop r10
 1141 0648 9F90      		pop r9
 1142 064a 8F90      		pop r8
 1143 064c 0895      		ret
 1144               	.LFE40:
 1146               	.global	readEEPROM
 1148               	readEEPROM:
 1149               	.LFB42:
1701:switcherator.c **** 
1702:switcherator.c **** 
1703:switcherator.c **** /****************************************************************
1704:switcherator.c ****  *
1705:switcherator.c ****  *              All Things EEPROM Related
1706:switcherator.c ****  *
1707:switcherator.c ****  ****************************************************************/
1708:switcherator.c **** 
1709:switcherator.c **** // Get variables out of EEPROM and set things up
1710:switcherator.c **** 
1711:switcherator.c **** void generalInit(void) {
1712:switcherator.c ****     // read the program info
1713:switcherator.c ****     char tempStuff[14];
1714:switcherator.c ****     int x = 0;
1715:switcherator.c ****     // Go through the addresses and assign them if set
1716:switcherator.c ****     // decided later that this is a really bad idea. gets corrupted.  use default
1717:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_TX, RADIO_ADDR_TX_BYTES) == 1) {
1718:switcherator.c ****         tx_addr = formatAddress(tempStuff);
1719:switcherator.c ****         writeAddr(TX_ADDR, tx_addr);
1720:switcherator.c ****     }
1721:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R0, RADIO_ADDR_R0_BYTES) == 1) {
1722:switcherator.c ****         rx_addr_p0 = formatAddress(tempStuff);
1723:switcherator.c ****         writeAddr(RX_ADDR_P0, rx_addr_p0);
1724:switcherator.c ****     }
1725:switcherator.c ****      
1726:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R1, RADIO_ADDR_R1_BYTES) == 1) {
1727:switcherator.c ****         rx_addr_p1 = formatAddress(tempStuff);
1728:switcherator.c ****         writeAddr(RX_ADDR_P1, rx_addr_p1);
1729:switcherator.c ****     }
1730:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R2, RADIO_ADDR_R2_BYTES) == 1) {
1731:switcherator.c ****         rx_addr_p2 = tempStuff[0];
1732:switcherator.c ****         writeAddr(RX_ADDR_P2, rx_addr_p2);
1733:switcherator.c ****     }
1734:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R3, RADIO_ADDR_R3_BYTES) == 1) {
1735:switcherator.c ****         rx_addr_p3 = tempStuff[0];
1736:switcherator.c ****         writeAddr(RX_ADDR_P3, rx_addr_p3);
1737:switcherator.c ****     }
1738:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R4, RADIO_ADDR_R4_BYTES) == 1) {
1739:switcherator.c ****         rx_addr_p4 = tempStuff[0];
1740:switcherator.c ****         writeAddr(RX_ADDR_P4, rx_addr_p4);
1741:switcherator.c ****     }
1742:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R5, RADIO_ADDR_R5_BYTES) == 1) {
1743:switcherator.c ****         rx_addr_p5 = tempStuff[0];
1744:switcherator.c ****         writeAddr(RX_ADDR_P5, rx_addr_p5);
1745:switcherator.c ****     }
1746:switcherator.c ****     if (readEEPROM(tempStuff, TWEAK_TIMER, TWEAK_TIMER_BYTES) == 1) {
1747:switcherator.c ****         tweakTimer = tempStuff[0];
1748:switcherator.c ****         tweakTimer <<= 8;
1749:switcherator.c ****         tweakTimer |= tempStuff[1];
1750:switcherator.c ****     }
1751:switcherator.c **** 
1752:switcherator.c **** 
1753:switcherator.c ****     // process daylight savings
1754:switcherator.c ****     if (readEEPROM(tempStuff, DAYLIGHT_SAVE, DAYLIGHT_SAVE_BYTES) == 1) {
1755:switcherator.c ****         // Spring month
1756:switcherator.c ****         daylightSavings[0][0] = ((tempStuff[0] << 8) | (tempStuff[1]));
1757:switcherator.c ****         // Spring day
1758:switcherator.c ****         daylightSavings[0][1] = ((tempStuff[2] << 8) | (tempStuff[3]));
1759:switcherator.c ****         // Fall month
1760:switcherator.c ****         daylightSavings[1][0] = ((tempStuff[4] << 8) | (tempStuff[5]));
1761:switcherator.c ****         // Fall day
1762:switcherator.c ****         daylightSavings[1][1] = ((tempStuff[6] << 8) | (tempStuff[7]));
1763:switcherator.c ****     }
1764:switcherator.c **** 
1765:switcherator.c ****     if (readEEPROM(tempStuff, SERIAL_NUM, SERIAL_NUM_BYTES) == 1) {
1766:switcherator.c ****         serial = atol(tempStuff);
1767:switcherator.c ****         ltoa(serial, stringSerial, 10);
1768:switcherator.c ****     }
1769:switcherator.c **** 
1770:switcherator.c ****     // switches
1771:switcherator.c ****     if (readEEPROM(switchStuff, SWITCH_STUFF, SWITCH_STUFF_BYTES) == 1) {
1772:switcherator.c ****         readEEPROM(switchBright, BRIGHTNESS, BRIGHTNESS_BYTES);
1773:switcherator.c ****         volatile unsigned char *realPort = 0;
1774:switcherator.c ****         volatile unsigned char *realDDR = 0;
1775:switcherator.c ****         char realPin = 0;
1776:switcherator.c ****         char temp = 0;
1777:switcherator.c ****         // Pp - value of 255 (default) means nothing programmed
1778:switcherator.c ****         // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
1779:switcherator.c ****         // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
1780:switcherator.c ****         for (x = 0; x < NUM_SWITCHES; x++) {
1781:switcherator.c ****             temp = switchStuff[x];
1782:switcherator.c ****             if (temp > 15 && temp < 32) {
1783:switcherator.c ****                 realPort = &PORTB;
1784:switcherator.c ****                 realDDR = &DDRB;
1785:switcherator.c ****                 temp -= 16;
1786:switcherator.c **** #ifdef PINA
1787:switcherator.c ****             } else if (temp < 16) {
1788:switcherator.c ****                 realPort = &PORTA;
1789:switcherator.c ****                 realDDR = &DDRA;
1790:switcherator.c ****                 temp -= 0;
1791:switcherator.c **** #endif
1792:switcherator.c **** #ifdef PINC
1793:switcherator.c ****             } else if (temp < 48) {
1794:switcherator.c ****                 realPort = &PORTC;
1795:switcherator.c ****                 realDDR = &DDRC;
1796:switcherator.c ****                 temp -= 32;
1797:switcherator.c **** #endif
1798:switcherator.c **** #ifdef PIND
1799:switcherator.c ****             } else if (temp < 64) {
1800:switcherator.c ****                 realPort = &PORTD;
1801:switcherator.c ****                 realDDR = &DDRD;
1802:switcherator.c ****                 temp -= 48;
1803:switcherator.c **** #endif
1804:switcherator.c **** #ifdef PINE
1805:switcherator.c ****             } else if (temp < 80) {
1806:switcherator.c ****                 realPort = &PORTE;
1807:switcherator.c ****                 realDDR = &DDRE;
1808:switcherator.c ****                 temp -= 64;
1809:switcherator.c **** #endif
1810:switcherator.c **** #ifdef PINF
1811:switcherator.c ****             } else if (temp < 96) {
1812:switcherator.c ****                 realPort = &PORTF;
1813:switcherator.c ****                 realDDR = &DDRF;
1814:switcherator.c ****                 temp -= 80;
1815:switcherator.c **** #endif
1816:switcherator.c **** #ifdef PING
1817:switcherator.c ****             } else if (temp < 112) {
1818:switcherator.c ****                 realPort = &PORTG;
1819:switcherator.c ****                 realDDR = &DDRG;
1820:switcherator.c ****                 temp -= 96;
1821:switcherator.c **** #endif
1822:switcherator.c **** #ifdef PINH
1823:switcherator.c ****             } else if (temp < 128) {
1824:switcherator.c ****                 realPort = &PORTH;
1825:switcherator.c ****                 realDDR = &DDRH;
1826:switcherator.c ****                 temp -= 112;
1827:switcherator.c **** #endif
1828:switcherator.c **** #ifdef PINI
1829:switcherator.c ****             } else if (temp < 144) {
1830:switcherator.c ****                 realPort = &PORTI;
1831:switcherator.c ****                 realDDR = &DDRI;
1832:switcherator.c ****                 temp -= 128;
1833:switcherator.c **** #endif
1834:switcherator.c ****                 // pwm setup
1835:switcherator.c ****             } else {
1836:switcherator.c ****                 continue;
1837:switcherator.c ****             }
1838:switcherator.c ****             realPin = (temp / 2);
1839:switcherator.c ****             *realDDR |= (1 << realPin);
1840:switcherator.c ****             // figure out direction
1841:switcherator.c ****             if (temp % 2 == 0) {
1842:switcherator.c ****                 // 0 = low is on  1 = high is on
1843:switcherator.c ****                 *realPort |= (1 << realPin);
1844:switcherator.c ****             } else {
1845:switcherator.c ****                 *realPort &= ~(1 << realPin);
1846:switcherator.c ****             }
1847:switcherator.c ****         }
1848:switcherator.c ****     } else {
1849:switcherator.c ****         for (x = 0; x < NUM_SWITCHES; x++)
1850:switcherator.c ****             switchStuff[x] = 255;
1851:switcherator.c ****     }
1852:switcherator.c **** 
1853:switcherator.c ****     int memoryMarker = 0;
1854:switcherator.c ****     int y = 0;
1855:switcherator.c ****     // get the programs
1856:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
1857:switcherator.c ****         memoryMarker = (WEEKLY_PROGRAM + (x * WEEKLY_PROGRAM_BYTES));
1858:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, WEEKLY_PROGRAM_BYTES) == 1) {
1859:switcherator.c ****             for (y = 0; y < 10; y++) {
1860:switcherator.c ****                 weeklyProgram[x][y] = tempStuff[y];
1861:switcherator.c ****             }
1862:switcherator.c ****         }
1863:switcherator.c ****     }
1864:switcherator.c ****     // get the inputs
1865:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
1866:switcherator.c ****         memoryMarker = (INPUT + (x * INPUT_BYTES));
1867:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, INPUT_BYTES) == 1) {
1868:switcherator.c ****             for (y = 0; y < 8; y++) {
1869:switcherator.c ****                 inputs[x][y] = tempStuff[y];
1870:switcherator.c ****             }
1871:switcherator.c ****         }
1872:switcherator.c ****     }
1873:switcherator.c ****     // get the time limits
1874:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++) {
1875:switcherator.c ****         memoryMarker = (LIMIT + (x * LIMIT_BYTES));
1876:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, LIMIT_BYTES) == 1) {
1877:switcherator.c ****             for (y = 0; y < 3; y++) {
1878:switcherator.c ****                 timeLimits[x][y] = tempStuff[y];
1879:switcherator.c ****             }
1880:switcherator.c ****         }
1881:switcherator.c ****     }
1882:switcherator.c **** 
1883:switcherator.c ****     if (readEEPROM(tempStuff, PWM_DIR, PWM_DIR_BYTES) == 1) {
1884:switcherator.c ****         DDRD |= (1 << PIND3) | (1 << PIND5) | (1 << PIND6);
1885:switcherator.c ****         // make sure initial values are 0
1886:switcherator.c ****         Red = 0;
1887:switcherator.c ****         Green = 0;
1888:switcherator.c ****         Blue = 0;
1889:switcherator.c ****         // Set output phase correct whatevers
1890:switcherator.c ****         // set it to inverted if the direction is 0
1891:switcherator.c ****         if (tempStuff[0] == 0) {
1892:switcherator.c ****             TCCR0A = (1 << COM0A0) | (1 << COM0A1) | (1 << COM0B0) | (1 << COM0B1) | (1 << WGM00);
1893:switcherator.c ****             TCCR2A = (1 << COM2B0) | (1 << COM2B1) | (1 << WGM20);
1894:switcherator.c ****             pwmdir = 0;
1895:switcherator.c ****         } else {
1896:switcherator.c ****             TCCR0A = (1 << COM0A1) | (1 << COM0B1) | (1 << WGM00);
1897:switcherator.c ****             TCCR2A = (1 << COM2B1) | (1 << WGM20);
1898:switcherator.c ****             pwmdir = 1;
1899:switcherator.c ****         }
1900:switcherator.c ****         // F_CPU/64 timers
1901:switcherator.c ****         TCCR0B = (1 << CS01) | (1 << CS00);
1902:switcherator.c **** 
1903:switcherator.c ****         TCCR2B = (1 << CS22); // F_CPU/64
1904:switcherator.c ****     }
1905:switcherator.c **** 
1906:switcherator.c ****     // get the pwm value bytes
1907:switcherator.c ****     memoryMarker = (PWM_VALUE);
1908:switcherator.c ****     if (readEEPROM(tempStuff, memoryMarker, PWM_VALUE_BYTES) == 1) {
1909:switcherator.c ****         pwmValues[0] = tempStuff[0];
1910:switcherator.c ****         pwmValues[1] = tempStuff[1];
1911:switcherator.c ****         pwmValues[2] = tempStuff[2];
1912:switcherator.c ****     }
1913:switcherator.c ****     // get the color change
1914:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
1915:switcherator.c ****         memoryMarker = (COLOR_CHANGE + (x * COLOR_CHANGE_BYTES));
1916:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, PWM_VALUE_BYTES) == 1) {
1917:switcherator.c ****             for (y = 0; y < 3; y++) {
1918:switcherator.c ****                 colorChanges[x][y] = tempStuff[y];
1919:switcherator.c ****             }
1920:switcherator.c ****         }
1921:switcherator.c ****     }
1922:switcherator.c **** }
1923:switcherator.c **** 
1924:switcherator.c **** int readEEPROM(char * data, int memLocation, int memBytes) {
 1150               		.loc 1 1924 0
 1151               	.LVL67:
 1152 064e EF92      		push r14
 1153               	.LCFI23:
 1154 0650 FF92      		push r15
 1155               	.LCFI24:
 1156 0652 0F93      		push r16
 1157               	.LCFI25:
 1158 0654 1F93      		push r17
 1159               	.LCFI26:
 1160 0656 CF93      		push r28
 1161               	.LCFI27:
 1162 0658 DF93      		push r29
 1163               	.LCFI28:
 1164               	/* prologue: function */
 1165               	/* frame size = 0 */
 1166               	/* stack size = 6 */
 1167               	.L__stack_usage = 6
 1168 065a 7C01      		movw r14,r24
 1169 065c EB01      		movw r28,r22
 1170 065e 8A01      		movw r16,r20
 1171               	.LVL68:
 1172 0660 FC01      		movw r30,r24
1925:switcherator.c ****     uint16_t checkProgram;
1926:switcherator.c ****     int x = 0;
1927:switcherator.c ****     for (x = 0; x < 14; x++) {
 1173               		.loc 1 1927 0
 1174 0662 20E0      		ldi r18,0
 1175 0664 30E0      		ldi r19,0
 1176               	.LVL69:
 1177               	.L79:
1928:switcherator.c ****         data[x] = 0;
 1178               		.loc 1 1928 0 discriminator 2
 1179 0666 1192      		st Z+,__zero_reg__
1927:switcherator.c ****     for (x = 0; x < 14; x++) {
 1180               		.loc 1 1927 0 discriminator 2
 1181 0668 2F5F      		subi r18,-1
 1182 066a 3F4F      		sbci r19,-1
 1183               	.LVL70:
 1184 066c 2E30      		cpi r18,14
 1185 066e 3105      		cpc r19,__zero_reg__
 1186 0670 01F4      		brne .L79
1929:switcherator.c ****     }
1930:switcherator.c ****     // see if it has been programmed
1931:switcherator.c ****     checkProgram = eeprom_read_word((uint16_t*) memLocation);
 1187               		.loc 1 1931 0
 1188 0672 CE01      		movw r24,r28
 1189 0674 0E94 0000 		call __eerd_word_m328
 1190               	.LVL71:
1932:switcherator.c ****     // "DW" = 68,87 = 0x4457
1933:switcherator.c ****     if (checkProgram == 0x4457) {
 1191               		.loc 1 1933 0
 1192 0678 8735      		cpi r24,87
 1193 067a 9444      		sbci r25,68
 1194 067c 01F4      		brne .L81
 1195               	.LVL72:
 1196               	.LBB20:
 1197               	.LBB21:
1934:switcherator.c ****         // we've written here before. now get the data (except marker)
1935:switcherator.c ****         eeprom_read_block((void*) data, (const void*) (memLocation + 2), (memBytes - 2));
 1198               		.loc 1 1935 0
 1199 067e A801      		movw r20,r16
 1200 0680 4250      		subi r20,2
 1201 0682 5109      		sbc r21,__zero_reg__
 1202 0684 BE01      		movw r22,r28
 1203 0686 6E5F      		subi r22,-2
 1204 0688 7F4F      		sbci r23,-1
 1205 068a C701      		movw r24,r14
 1206               	.LVL73:
 1207 068c 0E94 0000 		call __eerd_block_m328
 1208               	.LVL74:
 1209 0690 21E0      		ldi r18,lo8(1)
 1210 0692 30E0      		ldi r19,0
 1211 0694 00C0      		rjmp .L80
 1212               	.LVL75:
 1213               	.L81:
 1214               	.LBE21:
 1215               	.LBE20:
1936:switcherator.c ****         return 1;
1937:switcherator.c ****     } else {
1938:switcherator.c ****         return 0;
 1216               		.loc 1 1938 0
 1217 0696 20E0      		ldi r18,0
 1218 0698 30E0      		ldi r19,0
 1219               	.LVL76:
 1220               	.L80:
1939:switcherator.c ****     }
1940:switcherator.c **** }
 1221               		.loc 1 1940 0
 1222 069a C901      		movw r24,r18
 1223               	/* epilogue start */
 1224 069c DF91      		pop r29
 1225 069e CF91      		pop r28
 1226               	.LVL77:
 1227 06a0 1F91      		pop r17
 1228 06a2 0F91      		pop r16
 1229               	.LVL78:
 1230 06a4 FF90      		pop r15
 1231 06a6 EF90      		pop r14
 1232               	.LVL79:
 1233 06a8 0895      		ret
 1234               	.LFE42:
 1236               	.global	writeEEPROM
 1238               	writeEEPROM:
 1239               	.LFB43:
1941:switcherator.c **** 
1942:switcherator.c **** void writeEEPROM(char * data, int memLocation, int memBytes) {
 1240               		.loc 1 1942 0
 1241               	.LVL80:
 1242 06aa CF93      		push r28
 1243               	.LCFI29:
 1244 06ac DF93      		push r29
 1245               	.LCFI30:
 1246               	/* prologue: function */
 1247               	/* frame size = 0 */
 1248               	/* stack size = 2 */
 1249               	.L__stack_usage = 2
 1250 06ae EB01      		movw r28,r22
 1251               	.LVL81:
1943:switcherator.c ****     uint16_t marker = 0x4457; // "DW" in ascii
1944:switcherator.c ****     eeprom_update_block((const void*) data, (void*) (memLocation + 2), (memBytes - 2));
 1252               		.loc 1 1944 0
 1253 06b0 4250      		subi r20,2
 1254 06b2 5109      		sbc r21,__zero_reg__
 1255               	.LVL82:
 1256 06b4 6E5F      		subi r22,-2
 1257 06b6 7F4F      		sbci r23,-1
 1258               	.LVL83:
 1259 06b8 0E94 0000 		call __eeupd_block_m328
 1260               	.LVL84:
1945:switcherator.c ****     eeprom_update_word((uint16_t*) memLocation, marker);
 1261               		.loc 1 1945 0
 1262 06bc 67E5      		ldi r22,lo8(87)
 1263 06be 74E4      		ldi r23,lo8(68)
 1264 06c0 CE01      		movw r24,r28
 1265               	/* epilogue start */
1946:switcherator.c **** }
 1266               		.loc 1 1946 0
 1267 06c2 DF91      		pop r29
 1268 06c4 CF91      		pop r28
 1269               	.LVL85:
1945:switcherator.c ****     eeprom_update_word((uint16_t*) memLocation, marker);
 1270               		.loc 1 1945 0
 1271 06c6 0C94 0000 		jmp __eeupd_word_m328
 1272               	.LVL86:
 1273               	.LFE43:
 1275               	.global	clearEEPROM
 1277               	clearEEPROM:
 1278               	.LFB44:
1947:switcherator.c **** 
1948:switcherator.c **** void clearEEPROM(int memLocation) {
 1279               		.loc 1 1948 0
 1280               	.LVL87:
 1281               	/* prologue: function */
 1282               	/* frame size = 0 */
 1283               	/* stack size = 0 */
 1284               	.L__stack_usage = 0
1949:switcherator.c ****     uint16_t marker = 0x0000; // blank it out
1950:switcherator.c ****     eeprom_update_word((uint16_t*) memLocation, marker);
 1285               		.loc 1 1950 0
 1286 06ca 60E0      		ldi r22,0
 1287 06cc 70E0      		ldi r23,0
 1288 06ce 0C94 0000 		jmp __eeupd_word_m328
 1289               	.LVL88:
 1290               	.LFE44:
 1292               	.global	clockInit
 1294               	clockInit:
 1295               	.LFB47:
1951:switcherator.c **** }
1952:switcherator.c **** 
1953:switcherator.c **** void saveToEEPROM(void) {
1954:switcherator.c ****     char tempStuff[14];
1955:switcherator.c ****     int x = 0;
1956:switcherator.c ****     // Go through the addresses and assign them if set
1957:switcherator.c ****     if (tx_addr > 0) {
1958:switcherator.c ****         unformatAddress(tx_addr, tempStuff);
1959:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_TX, RADIO_ADDR_TX_BYTES);
1960:switcherator.c ****     }
1961:switcherator.c ****     if (rx_addr_p0 > 0) {
1962:switcherator.c ****         unformatAddress(rx_addr_p0, tempStuff);
1963:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R0, RADIO_ADDR_R0_BYTES);
1964:switcherator.c ****     }
1965:switcherator.c ****     if (rx_addr_p1 > 0) {
1966:switcherator.c ****         unformatAddress(rx_addr_p1, tempStuff);
1967:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R1, RADIO_ADDR_R1_BYTES);
1968:switcherator.c ****     }
1969:switcherator.c ****     if (rx_addr_p2 > 0) {
1970:switcherator.c ****         tempStuff[0] = rx_addr_p2;
1971:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R2, RADIO_ADDR_R2_BYTES);
1972:switcherator.c ****     }
1973:switcherator.c ****     if (rx_addr_p3 > 0) {
1974:switcherator.c ****         tempStuff[0] = rx_addr_p3;
1975:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R3, RADIO_ADDR_R3_BYTES);
1976:switcherator.c ****     }
1977:switcherator.c ****     if (rx_addr_p4 > 0) {
1978:switcherator.c ****         tempStuff[0] = rx_addr_p4;
1979:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R4, RADIO_ADDR_R4_BYTES);
1980:switcherator.c ****     }
1981:switcherator.c ****     if (rx_addr_p5 > 0) {
1982:switcherator.c ****         tempStuff[0] = rx_addr_p5;
1983:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R5, RADIO_ADDR_R5_BYTES);
1984:switcherator.c ****     }
1985:switcherator.c **** 
1986:switcherator.c ****     if (tweakTimer != 0) {
1987:switcherator.c ****         tempStuff[0] = tweakTimer >> 8;
1988:switcherator.c ****         tempStuff[1] = (tweakTimer & 0xff);
1989:switcherator.c ****         writeEEPROM(tempStuff, TWEAK_TIMER, TWEAK_TIMER_BYTES);
1990:switcherator.c ****     }
1991:switcherator.c **** 
1992:switcherator.c **** 
1993:switcherator.c **** 
1994:switcherator.c ****     if (daylightSavings[0][0] > 0) {
1995:switcherator.c ****         tempStuff[0] = (daylightSavings[0][0] >> 8);
1996:switcherator.c ****         tempStuff[1] = (daylightSavings[0][0] & 0xff);
1997:switcherator.c ****         tempStuff[2] = (daylightSavings[0][1] >> 8);
1998:switcherator.c ****         tempStuff[3] = (daylightSavings[0][1] & 0xff);
1999:switcherator.c ****         tempStuff[4] = (daylightSavings[1][0] >> 8);
2000:switcherator.c ****         tempStuff[5] = (daylightSavings[1][0] & 0xff);
2001:switcherator.c ****         tempStuff[6] = (daylightSavings[1][1] >> 8);
2002:switcherator.c ****         tempStuff[7] = (daylightSavings[1][1] & 0xff);
2003:switcherator.c ****         writeEEPROM(tempStuff, DAYLIGHT_SAVE, DAYLIGHT_SAVE_BYTES);
2004:switcherator.c ****     }
2005:switcherator.c ****     if (serial > 0) {
2006:switcherator.c ****         ltoa(serial, tempStuff, 10);
2007:switcherator.c ****         writeEEPROM(tempStuff, SERIAL_NUM, SERIAL_NUM_BYTES);
2008:switcherator.c ****     }
2009:switcherator.c ****     char setupaSwitch = 0;
2010:switcherator.c ****     char setupPWM = 0;
2011:switcherator.c **** 
2012:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
2013:switcherator.c ****         if (switchStuff[x] < 255)
2014:switcherator.c ****             setupaSwitch = 1;
2015:switcherator.c ****         if (switchStuff[x] >= 200 && switchStuff[x] <= 230)
2016:switcherator.c ****             setupPWM = 1;
2017:switcherator.c ****     }
2018:switcherator.c ****     if (setupaSwitch == 1) {
2019:switcherator.c ****         writeEEPROM(switchStuff, SWITCH_STUFF, SWITCH_STUFF_BYTES);
2020:switcherator.c ****         writeEEPROM(switchBright, BRIGHTNESS, BRIGHTNESS_BYTES);
2021:switcherator.c ****     }
2022:switcherator.c ****     tempStuff[0] = pwmdir;
2023:switcherator.c ****     if (setupPWM == 1)
2024:switcherator.c ****         writeEEPROM(tempStuff, PWM_DIR, PWM_DIR_BYTES);
2025:switcherator.c **** 
2026:switcherator.c ****     int memoryMarker;
2027:switcherator.c **** 
2028:switcherator.c **** 
2029:switcherator.c **** 
2030:switcherator.c **** 
2031:switcherator.c ****     // save the programs
2032:switcherator.c ****     int y = 0;
2033:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
2034:switcherator.c ****         memoryMarker = (WEEKLY_PROGRAM + (x * WEEKLY_PROGRAM_BYTES));
2035:switcherator.c ****         if (weeklyProgram[x][0] != 255 || weeklyProgram[x][1] != 255) {
2036:switcherator.c ****             for (y = 0; y < 10; y++)
2037:switcherator.c ****                 tempStuff[y] = weeklyProgram[x][y];
2038:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, WEEKLY_PROGRAM_BYTES);
2039:switcherator.c ****         }
2040:switcherator.c ****     }
2041:switcherator.c **** 
2042:switcherator.c ****     // save the inputs
2043:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
2044:switcherator.c ****         memoryMarker = (INPUT + (x * INPUT_BYTES));
2045:switcherator.c ****         if (inputs[x][0] != 255) {
2046:switcherator.c ****             for (y = 0; y < 8; y++) {
2047:switcherator.c ****                 tempStuff[y] = inputs[x][y];
2048:switcherator.c ****             }
2049:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, INPUT_BYTES);
2050:switcherator.c ****         }
2051:switcherator.c ****     }
2052:switcherator.c **** 
2053:switcherator.c ****     // save the time limits
2054:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++) {
2055:switcherator.c ****         memoryMarker = (LIMIT + (x * LIMIT_BYTES));
2056:switcherator.c ****         if (timeLimits[x][2] > 0) {
2057:switcherator.c ****             for (y = 0; y < 3; y++) {
2058:switcherator.c ****                 tempStuff[y] = timeLimits[x][y];
2059:switcherator.c ****             }
2060:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, INPUT_BYTES);
2061:switcherator.c ****         }
2062:switcherator.c ****     }
2063:switcherator.c **** 
2064:switcherator.c **** 
2065:switcherator.c ****     // save the pwm value bytes
2066:switcherator.c ****     memoryMarker = (PWM_VALUE);
2067:switcherator.c ****     if (pwmValues[0] != 0 || pwmValues[1] != 0 || pwmValues[2] != 0) {
2068:switcherator.c ****         for (y = 0; y < 3; y++) {
2069:switcherator.c ****             tempStuff[y] = pwmValues[y];
2070:switcherator.c ****         }
2071:switcherator.c ****         writeEEPROM(tempStuff, memoryMarker, PWM_VALUE_BYTES);
2072:switcherator.c ****     }
2073:switcherator.c **** 
2074:switcherator.c ****     // save the color change
2075:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
2076:switcherator.c ****         memoryMarker = (COLOR_CHANGE + (x * COLOR_CHANGE_BYTES));
2077:switcherator.c ****         if (colorChanges[0][0] != 0 || colorChanges[0][1] != 1 || colorChanges[0][2] != 0) {
2078:switcherator.c ****             for (y = 0; y < 3; y++) {
2079:switcherator.c ****                 tempStuff[y] = inputs[x][y];
2080:switcherator.c ****             }
2081:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, COLOR_CHANGE_BYTES);
2082:switcherator.c ****         }
2083:switcherator.c ****     }
2084:switcherator.c ****     ok();
2085:switcherator.c **** }
2086:switcherator.c **** 
2087:switcherator.c **** void clearToEEPROM(void) {
2088:switcherator.c ****     int x = 0;
2089:switcherator.c ****     clearEEPROM(SERIAL_NUM);
2090:switcherator.c ****     clearEEPROM(DAYLIGHT_SAVE);
2091:switcherator.c ****     clearEEPROM(RADIO_ADDR_TX);
2092:switcherator.c ****     clearEEPROM(RADIO_ADDR_R0);
2093:switcherator.c ****     clearEEPROM(RADIO_ADDR_R1);
2094:switcherator.c ****     clearEEPROM(RADIO_ADDR_R2);
2095:switcherator.c ****     clearEEPROM(RADIO_ADDR_R3);
2096:switcherator.c ****     clearEEPROM(RADIO_ADDR_R4);
2097:switcherator.c ****     clearEEPROM(RADIO_ADDR_R5);
2098:switcherator.c ****     clearEEPROM(SWITCH_STUFF);
2099:switcherator.c ****     clearEEPROM(PWM_DIR);
2100:switcherator.c ****     clearEEPROM(BRIGHTNESS);
2101:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++)
2102:switcherator.c ****         clearEEPROM((INPUT + (x * INPUT_BYTES)));
2103:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++)
2104:switcherator.c ****         clearEEPROM((LIMIT + (x * LIMIT_BYTES)));
2105:switcherator.c ****     clearEEPROM(PWM_VALUE);
2106:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++)
2107:switcherator.c ****         clearEEPROM((COLOR_CHANGE + (x * COLOR_CHANGE_BYTES)));
2108:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++)
2109:switcherator.c ****         clearEEPROM((WEEKLY_PROGRAM + (x * WEEKLY_PROGRAM_BYTES)));
2110:switcherator.c ****     clearEEPROM(TWEAK_TIMER);
2111:switcherator.c ****     ok();
2112:switcherator.c **** }
2113:switcherator.c **** 
2114:switcherator.c **** /****************************************************************
2115:switcherator.c ****  *
2116:switcherator.c ****  *              All Things Clock Related
2117:switcherator.c ****  *
2118:switcherator.c ****  ****************************************************************/
2119:switcherator.c **** 
2120:switcherator.c **** 
2121:switcherator.c **** // initialize the clock
2122:switcherator.c **** 
2123:switcherator.c **** void clockInit(void) {
 1296               		.loc 1 2123 0
 1297               	/* prologue: function */
 1298               	/* frame size = 0 */
 1299               	/* stack size = 0 */
 1300               	.L__stack_usage = 0
2124:switcherator.c ****     // Set CTC mode (clear timer on compare)
2125:switcherator.c ****     TCCR1A = 0;
 1301               		.loc 1 2125 0
 1302 06d2 1092 8000 		sts 128,__zero_reg__
2126:switcherator.c ****     TCCR1B = (1 << WGM12);
 1303               		.loc 1 2126 0
 1304 06d6 88E0      		ldi r24,lo8(8)
 1305 06d8 8093 8100 		sts 129,r24
2127:switcherator.c ****     OCR1A = TIMER_RESET;
 1306               		.loc 1 2127 0
 1307 06dc 1092 8900 		sts 136+1,__zero_reg__
 1308 06e0 1092 8800 		sts 136,__zero_reg__
2128:switcherator.c ****     TIMSK1 = (1 << OCIE1A); // set interrupt
 1309               		.loc 1 2128 0
 1310 06e4 82E0      		ldi r24,lo8(2)
 1311 06e6 8093 6F00 		sts 111,r24
 1312 06ea 0895      		ret
 1313               	.LFE47:
 1315               	.global	startClock
 1317               	startClock:
 1318               	.LFB50:
2129:switcherator.c **** }
2130:switcherator.c **** 
2131:switcherator.c **** // we received a time command.  set the clock
2132:switcherator.c **** // Must be this format:
2133:switcherator.c **** // TI:MMDDYYYYHHMMSS
2134:switcherator.c **** // 012345678901234567
2135:switcherator.c **** 
2136:switcherator.c **** void setClock(char * commandReceived) {
2137:switcherator.c ****     long tempInt;
2138:switcherator.c ****     // iterate through and get the times.
2139:switcherator.c ****     tempLongString[0] = '0';
2140:switcherator.c ****     tempLongString[1] = '0';
2141:switcherator.c ****     // Can't see a good loop so just get to it.
2142:switcherator.c ****     // Month
2143:switcherator.c ****     tempLongString[2] = commandReceived[3];
2144:switcherator.c ****     tempLongString[3] = commandReceived[4];
2145:switcherator.c ****     globalMonth = atoi(tempLongString);
2146:switcherator.c ****     // Day
2147:switcherator.c ****     tempLongString[2] = commandReceived[5];
2148:switcherator.c ****     tempLongString[3] = commandReceived[6];
2149:switcherator.c ****     globalDay = atoi(tempLongString);
2150:switcherator.c ****     // hour
2151:switcherator.c ****     tempLongString[2] = commandReceived[11];
2152:switcherator.c ****     tempLongString[3] = commandReceived[12];
2153:switcherator.c ****     globalHour = atoi(tempLongString);
2154:switcherator.c ****     // minute
2155:switcherator.c ****     tempLongString[2] = commandReceived[13];
2156:switcherator.c ****     tempLongString[3] = commandReceived[14];
2157:switcherator.c ****     globalMinute = atoi(tempLongString);
2158:switcherator.c ****     // second
2159:switcherator.c ****     tempLongString[2] = commandReceived[15];
2160:switcherator.c ****     tempLongString[3] = commandReceived[16];
2161:switcherator.c ****     globalSecond = atoi(tempLongString);
2162:switcherator.c ****     // year
2163:switcherator.c ****     tempLongString[0] = commandReceived[7];
2164:switcherator.c ****     tempLongString[1] = commandReceived[8];
2165:switcherator.c ****     tempLongString[2] = commandReceived[9];
2166:switcherator.c ****     tempLongString[3] = commandReceived[10];
2167:switcherator.c ****     globalYear = atoi(tempLongString);
2168:switcherator.c ****     dow = getWeekday(globalYear, globalMonth, globalDay); // get day of week
2169:switcherator.c ****     tempInt = dow;
2170:switcherator.c ****     tempInt = tempInt * 24 * 60 * 60;
2171:switcherator.c ****     weeklySeconds = tempInt;
2172:switcherator.c ****     tempInt = globalHour;
2173:switcherator.c ****     tempInt = tempInt * 60 * 60;
2174:switcherator.c ****     weeklySeconds += tempInt;
2175:switcherator.c ****     tempInt = globalMinute;
2176:switcherator.c ****     tempInt = tempInt * 60;
2177:switcherator.c ****     weeklySeconds += tempInt;
2178:switcherator.c ****     weeklySeconds += globalSecond;
2179:switcherator.c ****     clockString();
2180:switcherator.c ****     sendMessage(statusMsg);
2181:switcherator.c ****     stopClock();
2182:switcherator.c ****     startClock();
2183:switcherator.c ****     panicMyClockIsNotSet = 0;
2184:switcherator.c ****     if(failCondition == 3) {
2185:switcherator.c ****         clearFail();      
2186:switcherator.c ****     }
2187:switcherator.c **** }
2188:switcherator.c **** 
2189:switcherator.c **** 
2190:switcherator.c **** // Change the clock values to a string
2191:switcherator.c **** 
2192:switcherator.c **** void clockString(void) {
2193:switcherator.c ****     statusMsg[0] = 0;
2194:switcherator.c **** 
2195:switcherator.c ****     strcat(statusMsg, " ");
2196:switcherator.c ****     returnInt(globalMonth, tempIntString);
2197:switcherator.c ****     strcat(statusMsg, tempIntString);
2198:switcherator.c ****     strcat(statusMsg, "/");
2199:switcherator.c ****     returnInt(globalDay, tempIntString);
2200:switcherator.c ****     strcat(statusMsg, tempIntString);
2201:switcherator.c ****     strcat(statusMsg, "/");
2202:switcherator.c ****     itoa(globalYear, tempIntString, 10);
2203:switcherator.c ****     strcat(statusMsg, tempIntString);
2204:switcherator.c ****     strcat(statusMsg, " ");
2205:switcherator.c ****     returnInt(globalHour, tempIntString);
2206:switcherator.c ****     strcat(statusMsg, tempIntString);
2207:switcherator.c ****     strcat(statusMsg, ":");
2208:switcherator.c ****     returnInt(globalMinute, tempIntString);
2209:switcherator.c ****     strcat(statusMsg, tempIntString);
2210:switcherator.c ****     strcat(statusMsg, ":");
2211:switcherator.c ****     returnInt(globalSecond, tempIntString);
2212:switcherator.c ****     strcat(statusMsg, tempIntString);
2213:switcherator.c **** }
2214:switcherator.c **** 
2215:switcherator.c **** // start the clock
2216:switcherator.c **** 
2217:switcherator.c **** void startClock(void) {
 1319               		.loc 1 2217 0
 1320               	/* prologue: function */
 1321               	/* frame size = 0 */
 1322               	/* stack size = 0 */
 1323               	.L__stack_usage = 0
2218:switcherator.c ****     TCNT1 = 65535;
 1324               		.loc 1 2218 0
 1325 06ec 8FEF      		ldi r24,lo8(-1)
 1326 06ee 9FEF      		ldi r25,lo8(-1)
 1327 06f0 9093 8500 		sts 132+1,r25
 1328 06f4 8093 8400 		sts 132,r24
2219:switcherator.c ****     TCCR1B |= TIMER_CLOCK_SEL;
 1329               		.loc 1 2219 0
 1330 06f8 E1E8      		ldi r30,lo8(-127)
 1331 06fa F0E0      		ldi r31,0
 1332 06fc 8081      		ld r24,Z
 1333 06fe 8560      		ori r24,lo8(5)
 1334 0700 8083      		st Z,r24
 1335 0702 0895      		ret
 1336               	.LFE50:
 1338               	.global	stopClock
 1340               	stopClock:
 1341               	.LFB51:
2220:switcherator.c **** }
2221:switcherator.c **** 
2222:switcherator.c **** void stopClock(void) {
 1342               		.loc 1 2222 0
 1343               	/* prologue: function */
 1344               	/* frame size = 0 */
 1345               	/* stack size = 0 */
 1346               	.L__stack_usage = 0
2223:switcherator.c ****     TCCR1B &= ~(TIMER_CLOCK_SEL);
 1347               		.loc 1 2223 0
 1348 0704 E1E8      		ldi r30,lo8(-127)
 1349 0706 F0E0      		ldi r31,0
 1350 0708 8081      		ld r24,Z
 1351 070a 8A7F      		andi r24,lo8(-6)
 1352 070c 8083      		st Z,r24
 1353 070e 0895      		ret
 1354               	.LFE51:
 1356               	.global	getWeekday
 1358               	getWeekday:
 1359               	.LFB52:
2224:switcherator.c **** }
2225:switcherator.c **** 
2226:switcherator.c **** // returns the weekday - sunday = 0
2227:switcherator.c **** 
2228:switcherator.c **** int getWeekday(int year, int month, int day) {
 1360               		.loc 1 2228 0
 1361               	.LVL89:
 1362 0710 CF93      		push r28
 1363               	.LCFI31:
 1364 0712 DF93      		push r29
 1365               	.LCFI32:
 1366               	/* prologue: function */
 1367               	/* frame size = 0 */
 1368               	/* stack size = 2 */
 1369               	.L__stack_usage = 2
 1370 0714 FB01      		movw r30,r22
 1371 0716 EA01      		movw r28,r20
2229:switcherator.c ****     int adjustment, mm, yy;
2230:switcherator.c **** 
2231:switcherator.c ****     adjustment = (14 - month) / 12; // Jan is 13, feb is 14 in calculation
 1372               		.loc 1 2231 0
 1373 0718 8EE0      		ldi r24,lo8(14)
 1374 071a 90E0      		ldi r25,0
 1375               	.LVL90:
 1376 071c 861B      		sub r24,r22
 1377 071e 970B      		sbc r25,r23
 1378 0720 6CE0      		ldi r22,lo8(12)
 1379 0722 70E0      		ldi r23,0
 1380               	.LVL91:
 1381 0724 0E94 0000 		call __divmodhi4
 1382               	.LVL92:
2232:switcherator.c ****     mm = month + 12 * adjustment - 2;
2233:switcherator.c ****     yy = globalYear - adjustment;
 1383               		.loc 1 2233 0
 1384 0728 2091 0000 		lds r18,globalYear
 1385 072c 3091 0000 		lds r19,globalYear+1
 1386 0730 261B      		sub r18,r22
 1387 0732 370B      		sbc r19,r23
 1388               	.LVL93:
2232:switcherator.c ****     mm = month + 12 * adjustment - 2;
 1389               		.loc 1 2232 0
 1390 0734 8CE0      		ldi r24,lo8(12)
 1391 0736 869F      		mul r24,r22
 1392 0738 A001      		movw r20,r0
 1393 073a 879F      		mul r24,r23
 1394 073c 500D      		add r21,r0
 1395 073e 1124      		clr __zero_reg__
 1396               	.LVL94:
 1397 0740 4E0F      		add r20,r30
 1398 0742 5F1F      		adc r21,r31
 1399 0744 4250      		subi r20,2
 1400 0746 5109      		sbc r21,__zero_reg__
2234:switcherator.c ****     return ((day + (13 * mm - 1) / 5 + yy + yy / 4 - yy / 100 + yy / 400) % 7);
 1401               		.loc 1 2234 0
 1402 0748 6DE0      		ldi r22,lo8(13)
 1403               	.LVL95:
 1404 074a 649F      		mul r22,r20
 1405 074c C001      		movw r24,r0
 1406 074e 659F      		mul r22,r21
 1407 0750 900D      		add r25,r0
 1408 0752 1124      		clr __zero_reg__
 1409 0754 0197      		sbiw r24,1
 1410 0756 65E0      		ldi r22,lo8(5)
 1411 0758 70E0      		ldi r23,0
 1412 075a 0E94 0000 		call __divmodhi4
 1413 075e C60F      		add r28,r22
 1414 0760 D71F      		adc r29,r23
 1415               	.LVL96:
 1416 0762 C20F      		add r28,r18
 1417 0764 D31F      		adc r29,r19
 1418 0766 F901      		movw r30,r18
 1419               	.LVL97:
 1420 0768 37FD      		sbrc r19,7
 1421 076a 3396      		adiw r30,3
 1422               	.L89:
 1423 076c F595      		asr r31
 1424 076e E795      		ror r30
 1425 0770 F595      		asr r31
 1426 0772 E795      		ror r30
 1427 0774 EC0F      		add r30,r28
 1428 0776 FD1F      		adc r31,r29
 1429 0778 C901      		movw r24,r18
 1430 077a 6CE9      		ldi r22,lo8(-100)
 1431 077c 7FEF      		ldi r23,lo8(-1)
 1432 077e 0E94 0000 		call __divmodhi4
 1433 0782 E60F      		add r30,r22
 1434 0784 F71F      		adc r31,r23
 1435 0786 C901      		movw r24,r18
 1436 0788 60E9      		ldi r22,lo8(-112)
 1437 078a 71E0      		ldi r23,lo8(1)
 1438 078c 0E94 0000 		call __divmodhi4
 1439 0790 E60F      		add r30,r22
 1440 0792 F71F      		adc r31,r23
 1441 0794 CF01      		movw r24,r30
 1442 0796 67E0      		ldi r22,lo8(7)
 1443 0798 70E0      		ldi r23,0
 1444 079a 0E94 0000 		call __divmodhi4
 1445               	/* epilogue start */
2235:switcherator.c **** }
 1446               		.loc 1 2235 0
 1447 079e DF91      		pop r29
 1448 07a0 CF91      		pop r28
 1449 07a2 0895      		ret
 1450               	.LFE52:
 1452               		.section	.rodata
 1453               	.LC0:
 1454 0000 0000      		.word	0
 1455 0002 1F00      		.word	31
 1456 0004 1C00      		.word	28
 1457 0006 1F00      		.word	31
 1458 0008 1E00      		.word	30
 1459 000a 1F00      		.word	31
 1460 000c 1E00      		.word	30
 1461 000e 1F00      		.word	31
 1462 0010 1F00      		.word	31
 1463 0012 1E00      		.word	30
 1464 0014 1F00      		.word	31
 1465 0016 1E00      		.word	30
 1466               		.text
 1467               	.global	getDayofYear
 1469               	getDayofYear:
 1470               	.LFB53:
2236:switcherator.c **** 
2237:switcherator.c **** // returns the day of the year (1 - 365 or 366)
2238:switcherator.c **** 
2239:switcherator.c **** int getDayofYear(int year, int month, int day) {
 1471               		.loc 1 2239 0
 1472               	.LVL98:
 1473 07a4 CF93      		push r28
 1474               	.LCFI33:
 1475 07a6 DF93      		push r29
 1476               	.LCFI34:
 1477 07a8 CDB7      		in r28,__SP_L__
 1478 07aa DEB7      		in r29,__SP_H__
 1479               	.LCFI35:
 1480 07ac 6897      		sbiw r28,24
 1481               	.LCFI36:
 1482 07ae 0FB6      		in __tmp_reg__,__SREG__
 1483 07b0 F894      		cli
 1484 07b2 DEBF      		out __SP_H__,r29
 1485 07b4 0FBE      		out __SREG__,__tmp_reg__
 1486 07b6 CDBF      		out __SP_L__,r28
 1487               	/* prologue: function */
 1488               	/* frame size = 24 */
 1489               	/* stack size = 26 */
 1490               	.L__stack_usage = 26
2240:switcherator.c ****     int months[12] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30};
 1491               		.loc 1 2240 0
 1492 07b8 28E1      		ldi r18,lo8(24)
 1493 07ba E0E0      		ldi r30,lo8(.LC0)
 1494 07bc F0E0      		ldi r31,hi8(.LC0)
 1495 07be DE01      		movw r26,r28
 1496 07c0 1196      		adiw r26,1
 1497               		0:
 1498 07c2 0190      		ld r0,Z+
 1499 07c4 0D92      		st X+,r0
 1500 07c6 2A95      		dec r18
 1501 07c8 01F4      		brne 0b
 1502               	.LVL99:
2241:switcherator.c ****     int x = 0;
2242:switcherator.c ****     // adjust feb for leap year
2243:switcherator.c ****     if ((year % 4) == 0)
 1503               		.loc 1 2243 0
 1504 07ca 8370      		andi r24,3
 1505 07cc 9927      		clr r25
 1506               	.LVL100:
 1507 07ce 892B      		or r24,r25
 1508 07d0 01F4      		brne .L91
2244:switcherator.c ****         months[3] = 29;
 1509               		.loc 1 2244 0
 1510 07d2 8DE1      		ldi r24,lo8(29)
 1511 07d4 90E0      		ldi r25,0
 1512 07d6 9887      		std Y+8,r25
 1513 07d8 8F83      		std Y+7,r24
 1514               	.L91:
 1515               	.LVL101:
 1516 07da FE01      		movw r30,r28
 1517 07dc 3196      		adiw r30,1
2245:switcherator.c ****     // start with the day of the month, then add amounts for each month
2246:switcherator.c ****     int doy = day;
 1518               		.loc 1 2246 0
 1519 07de 9A01      		movw r18,r20
2247:switcherator.c ****     for (x = 0; x < month; x++) {
 1520               		.loc 1 2247 0
 1521 07e0 80E0      		ldi r24,0
 1522 07e2 90E0      		ldi r25,0
 1523 07e4 00C0      		rjmp .L92
 1524               	.LVL102:
 1525               	.L93:
2248:switcherator.c ****         doy += months[x];
 1526               		.loc 1 2248 0 discriminator 2
 1527 07e6 4191      		ld r20,Z+
 1528 07e8 5191      		ld r21,Z+
 1529 07ea 240F      		add r18,r20
 1530 07ec 351F      		adc r19,r21
 1531               	.LVL103:
2247:switcherator.c ****     for (x = 0; x < month; x++) {
 1532               		.loc 1 2247 0 discriminator 2
 1533 07ee 0196      		adiw r24,1
 1534               	.LVL104:
 1535               	.L92:
2247:switcherator.c ****     for (x = 0; x < month; x++) {
 1536               		.loc 1 2247 0 is_stmt 0 discriminator 1
 1537 07f0 8617      		cp r24,r22
 1538 07f2 9707      		cpc r25,r23
 1539 07f4 04F0      		brlt .L93
2249:switcherator.c ****     }
2250:switcherator.c ****     return doy;
2251:switcherator.c **** }
 1540               		.loc 1 2251 0 is_stmt 1
 1541 07f6 C901      		movw r24,r18
 1542               	.LVL105:
 1543               	/* epilogue start */
 1544 07f8 6896      		adiw r28,24
 1545 07fa 0FB6      		in __tmp_reg__,__SREG__
 1546 07fc F894      		cli
 1547 07fe DEBF      		out __SP_H__,r29
 1548 0800 0FBE      		out __SREG__,__tmp_reg__
 1549 0802 CDBF      		out __SP_L__,r28
 1550 0804 DF91      		pop r29
 1551 0806 CF91      		pop r28
 1552 0808 0895      		ret
 1553               	.LFE53:
 1555               	.global	checkDaylightSavings
 1557               	checkDaylightSavings:
 1558               	.LFB55:
2252:switcherator.c **** 
2253:switcherator.c **** // Sets up the days we do daylight savings
2254:switcherator.c **** // DS:MMDD MMDD
2255:switcherator.c **** // 012345678901
2256:switcherator.c **** 
2257:switcherator.c **** void setDaylightSavings(char * commandReceived) {
2258:switcherator.c ****     int dlInt;
2259:switcherator.c ****     tempIntString[0] = commandReceived[3];
2260:switcherator.c ****     tempIntString[1] = commandReceived[4];
2261:switcherator.c ****     dlInt = atoi(tempIntString);
2262:switcherator.c ****     daylightSavings[0][0] = dlInt;
2263:switcherator.c ****     tempIntString[0] = commandReceived[5];
2264:switcherator.c ****     tempIntString[1] = commandReceived[6];
2265:switcherator.c ****     dlInt = atoi(tempIntString);
2266:switcherator.c ****     daylightSavings[0][1] = dlInt;
2267:switcherator.c ****     tempIntString[0] = commandReceived[8];
2268:switcherator.c ****     tempIntString[1] = commandReceived[9];
2269:switcherator.c ****     dlInt = atoi(tempIntString);
2270:switcherator.c ****     daylightSavings[1][0] = dlInt;
2271:switcherator.c ****     tempIntString[0] = commandReceived[10];
2272:switcherator.c ****     tempIntString[1] = commandReceived[11];
2273:switcherator.c ****     dlInt = atoi(tempIntString);
2274:switcherator.c ****     daylightSavings[1][1] = dlInt;
2275:switcherator.c ****     ok();
2276:switcherator.c **** }
2277:switcherator.c **** 
2278:switcherator.c **** // Decide if this 3:00am is daylight savings and adjust accordingly
2279:switcherator.c **** 
2280:switcherator.c **** void checkDaylightSavings(void) {
 1559               		.loc 1 2280 0
 1560               	/* prologue: function */
 1561               	/* frame size = 0 */
 1562               	/* stack size = 0 */
 1563               	.L__stack_usage = 0
2281:switcherator.c ****     // have we adjusted for daylight savings?
2282:switcherator.c ****     if (wasDaylightSavings == 1)
 1564               		.loc 1 2282 0
 1565 080a 8091 0000 		lds r24,wasDaylightSavings
 1566 080e 8130      		cpi r24,lo8(1)
 1567 0810 01F0      		breq .L94
2283:switcherator.c ****         return;
2284:switcherator.c ****     if (globalMonth == daylightSavings[0][0] && globalDay == daylightSavings[0][1]) {
 1568               		.loc 1 2284 0
 1569 0812 8091 0000 		lds r24,globalMonth
 1570 0816 9091 0000 		lds r25,globalMonth+1
 1571 081a 2091 0000 		lds r18,daylightSavings
 1572 081e 3091 0000 		lds r19,daylightSavings+1
 1573 0822 8217      		cp r24,r18
 1574 0824 9307      		cpc r25,r19
 1575 0826 01F4      		brne .L96
 1576               		.loc 1 2284 0 is_stmt 0 discriminator 1
 1577 0828 4091 0000 		lds r20,globalDay
 1578 082c 5091 0000 		lds r21,globalDay+1
 1579 0830 2091 0000 		lds r18,daylightSavings+2
 1580 0834 3091 0000 		lds r19,daylightSavings+2+1
 1581 0838 4217      		cp r20,r18
 1582 083a 5307      		cpc r21,r19
 1583 083c 01F4      		brne .L96
2285:switcherator.c ****         wasDaylightSavings = 1;
 1584               		.loc 1 2285 0 is_stmt 1
 1585 083e 81E0      		ldi r24,lo8(1)
 1586 0840 8093 0000 		sts wasDaylightSavings,r24
2286:switcherator.c ****         globalHour++;
 1587               		.loc 1 2286 0
 1588 0844 8091 0000 		lds r24,globalHour
 1589 0848 9091 0000 		lds r25,globalHour+1
 1590 084c 0196      		adiw r24,1
 1591 084e 00C0      		rjmp .L100
 1592               	.L96:
2287:switcherator.c ****     } else if (globalMonth == daylightSavings[1][0] && globalDay == daylightSavings[1][1]) {
 1593               		.loc 1 2287 0
 1594 0850 2091 0000 		lds r18,daylightSavings+4
 1595 0854 3091 0000 		lds r19,daylightSavings+4+1
 1596 0858 8217      		cp r24,r18
 1597 085a 9307      		cpc r25,r19
 1598 085c 01F4      		brne .L94
 1599               		.loc 1 2287 0 is_stmt 0 discriminator 1
 1600 085e 2091 0000 		lds r18,globalDay
 1601 0862 3091 0000 		lds r19,globalDay+1
 1602 0866 8091 0000 		lds r24,daylightSavings+6
 1603 086a 9091 0000 		lds r25,daylightSavings+6+1
 1604 086e 2817      		cp r18,r24
 1605 0870 3907      		cpc r19,r25
 1606 0872 01F4      		brne .L94
2288:switcherator.c ****         wasDaylightSavings = 1;
 1607               		.loc 1 2288 0 is_stmt 1
 1608 0874 81E0      		ldi r24,lo8(1)
 1609 0876 8093 0000 		sts wasDaylightSavings,r24
2289:switcherator.c ****         globalHour--;
 1610               		.loc 1 2289 0
 1611 087a 8091 0000 		lds r24,globalHour
 1612 087e 9091 0000 		lds r25,globalHour+1
 1613 0882 0197      		sbiw r24,1
 1614               	.L100:
 1615 0884 9093 0000 		sts globalHour+1,r25
 1616 0888 8093 0000 		sts globalHour,r24
 1617               	.L94:
 1618 088c 0895      		ret
 1619               	.LFE55:
 1621               	.global	advanceDay
 1623               	advanceDay:
 1624               	.LFB56:
2290:switcherator.c ****     }
2291:switcherator.c **** }
2292:switcherator.c **** 
2293:switcherator.c **** // Advance a day in the calendar. 
2294:switcherator.c **** 
2295:switcherator.c **** void advanceDay(void) {
 1625               		.loc 1 2295 0
 1626               	/* prologue: function */
 1627               	/* frame size = 0 */
 1628               	/* stack size = 0 */
 1629               	.L__stack_usage = 0
 1630               	.LVL106:
2296:switcherator.c ****     int x = 0;
2297:switcherator.c ****     // Reset the daylight savings for next time
2298:switcherator.c ****     wasDaylightSavings = 0;
 1631               		.loc 1 2298 0
 1632 088e 1092 0000 		sts wasDaylightSavings,__zero_reg__
2299:switcherator.c ****     // start with dow
2300:switcherator.c ****     dow++;
 1633               		.loc 1 2300 0
 1634 0892 8091 0000 		lds r24,dow
 1635 0896 9091 0000 		lds r25,dow+1
 1636 089a 0196      		adiw r24,1
 1637 089c 9093 0000 		sts dow+1,r25
 1638 08a0 8093 0000 		sts dow,r24
2301:switcherator.c ****     if (dow == 7) {
 1639               		.loc 1 2301 0
 1640 08a4 0797      		sbiw r24,7
 1641 08a6 01F0      		breq .L102
 1642               	.LVL107:
 1643               	.L107:
2302:switcherator.c ****         // reset it to Sunday
2303:switcherator.c ****         dow = 0;
2304:switcherator.c ****         weeklySeconds = 0;
2305:switcherator.c ****         // switchStatus might be more than a week (604,800 seconds)
2306:switcherator.c ****         for (x = 0; x < NUM_SWITCHES; x++) {
2307:switcherator.c ****             if (switchStatus[x] >= 604800)
2308:switcherator.c ****                 switchStatus[x] -= 604800;
2309:switcherator.c ****         }
2310:switcherator.c ****     }
2311:switcherator.c ****     // then the day
2312:switcherator.c ****     globalDay++;
 1644               		.loc 1 2312 0
 1645 08a8 2091 0000 		lds r18,globalDay
 1646 08ac 3091 0000 		lds r19,globalDay+1
 1647 08b0 2F5F      		subi r18,-1
 1648 08b2 3F4F      		sbci r19,-1
 1649 08b4 3093 0000 		sts globalDay+1,r19
 1650 08b8 2093 0000 		sts globalDay,r18
2313:switcherator.c ****     // If we aren't advancing a month just move on
2314:switcherator.c ****     if (globalDay <= 28) {
 1651               		.loc 1 2314 0
 1652 08bc 2D31      		cpi r18,29
 1653 08be 3105      		cpc r19,__zero_reg__
 1654 08c0 00F4      		brsh .L140
 1655 08c2 0895      		ret
 1656               	.LVL108:
 1657               	.L102:
2303:switcherator.c ****         dow = 0;
 1658               		.loc 1 2303 0
 1659 08c4 1092 0000 		sts dow+1,__zero_reg__
 1660 08c8 1092 0000 		sts dow,__zero_reg__
2304:switcherator.c ****         weeklySeconds = 0;
 1661               		.loc 1 2304 0
 1662 08cc 1092 0000 		sts weeklySeconds,__zero_reg__
 1663 08d0 1092 0000 		sts weeklySeconds+1,__zero_reg__
 1664 08d4 1092 0000 		sts weeklySeconds+2,__zero_reg__
 1665 08d8 1092 0000 		sts weeklySeconds+3,__zero_reg__
 1666 08dc E0E0      		ldi r30,lo8(switchStatus)
 1667 08de F0E0      		ldi r31,hi8(switchStatus)
 1668               	.LVL109:
 1669               	.L106:
2307:switcherator.c ****             if (switchStatus[x] >= 604800)
 1670               		.loc 1 2307 0
 1671 08e0 8081      		ld r24,Z
 1672 08e2 9181      		ldd r25,Z+1
 1673 08e4 A281      		ldd r26,Z+2
 1674 08e6 B381      		ldd r27,Z+3
 1675 08e8 8038      		cpi r24,-128
 1676 08ea 2AE3      		ldi r18,58
 1677 08ec 9207      		cpc r25,r18
 1678 08ee 29E0      		ldi r18,9
 1679 08f0 A207      		cpc r26,r18
 1680 08f2 B105      		cpc r27,__zero_reg__
 1681 08f4 00F0      		brlo .L105
2308:switcherator.c ****                 switchStatus[x] -= 604800;
 1682               		.loc 1 2308 0
 1683 08f6 8058      		subi r24,-128
 1684 08f8 9A43      		sbci r25,58
 1685 08fa A940      		sbci r26,9
 1686 08fc B109      		sbc r27,__zero_reg__
 1687 08fe 8083      		st Z,r24
 1688 0900 9183      		std Z+1,r25
 1689 0902 A283      		std Z+2,r26
 1690 0904 B383      		std Z+3,r27
 1691               	.L105:
 1692 0906 3496      		adiw r30,4
2306:switcherator.c ****         for (x = 0; x < NUM_SWITCHES; x++) {
 1693               		.loc 1 2306 0
 1694 0908 80E0      		ldi r24,hi8(switchStatus+64)
 1695 090a E030      		cpi r30,lo8(switchStatus+64)
 1696 090c F807      		cpc r31,r24
 1697 090e 01F4      		brne .L106
 1698 0910 00C0      		rjmp .L107
 1699               	.L140:
2315:switcherator.c ****         return;
2316:switcherator.c ****     }
2317:switcherator.c ****     // possibly advancing a month
2318:switcherator.c ****     switch (globalMonth) {
 1700               		.loc 1 2318 0
 1701 0912 8091 0000 		lds r24,globalMonth
 1702 0916 9091 0000 		lds r25,globalMonth+1
 1703 091a 8630      		cpi r24,6
 1704 091c 9105      		cpc r25,__zero_reg__
 1705 091e 01F0      		breq .L110
 1706 0920 00F4      		brsh .L112
 1707 0922 8330      		cpi r24,3
 1708 0924 9105      		cpc r25,__zero_reg__
 1709 0926 01F0      		breq .L108
 1710 0928 00F4      		brsh .L113
 1711 092a 8130      		cpi r24,1
 1712 092c 9105      		cpc r25,__zero_reg__
 1713 092e 01F0      		breq .L108
 1714 0930 0297      		sbiw r24,2
 1715 0932 01F0      		breq .+2
 1716 0934 00C0      		rjmp .L101
 1717 0936 00C0      		rjmp .L109
 1718               	.L113:
 1719 0938 8430      		cpi r24,4
 1720 093a 9105      		cpc r25,__zero_reg__
 1721 093c 01F0      		breq .L110
 1722 093e 8530      		cpi r24,5
 1723 0940 9105      		cpc r25,__zero_reg__
 1724 0942 01F0      		breq .+2
 1725 0944 00C0      		rjmp .L101
 1726 0946 00C0      		rjmp .L108
 1727               	.L112:
 1728 0948 8930      		cpi r24,9
 1729 094a 9105      		cpc r25,__zero_reg__
 1730 094c 01F0      		breq .L110
 1731 094e 00F0      		brlo .L108
 1732 0950 8B30      		cpi r24,11
 1733 0952 9105      		cpc r25,__zero_reg__
 1734 0954 01F0      		breq .L110
 1735 0956 00F0      		brlo .L108
 1736 0958 0C97      		sbiw r24,12
 1737 095a 01F4      		brne .L101
 1738 095c 00C0      		rjmp .L111
 1739               	.L110:
2319:switcherator.c ****             // 30 days have september, april, june and november
2320:switcherator.c ****         case 4:
2321:switcherator.c ****         case 6:
2322:switcherator.c ****         case 9:
2323:switcherator.c ****         case 11:
2324:switcherator.c ****             if (globalDay > 30) {
 1740               		.loc 1 2324 0
 1741 095e 2F31      		cpi r18,31
 1742 0960 3105      		cpc r19,__zero_reg__
 1743 0962 00F0      		brlo .L101
 1744 0964 00C0      		rjmp .L142
 1745               	.L108:
2325:switcherator.c ****                 globalDay = 1;
2326:switcherator.c ****                 globalMonth++;
2327:switcherator.c ****             } else {
2328:switcherator.c ****                 return;
2329:switcherator.c ****             }
2330:switcherator.c ****             break;
2331:switcherator.c ****         case 1:
2332:switcherator.c ****         case 3:
2333:switcherator.c ****         case 5:
2334:switcherator.c ****         case 7:
2335:switcherator.c ****         case 8:
2336:switcherator.c ****         case 10:
2337:switcherator.c ****             if (globalDay > 31) {
 1746               		.loc 1 2337 0
 1747 0966 2032      		cpi r18,32
 1748 0968 3105      		cpc r19,__zero_reg__
 1749 096a 00F0      		brlo .L101
 1750               	.L142:
2338:switcherator.c ****                 globalDay = 1;
 1751               		.loc 1 2338 0
 1752 096c 21E0      		ldi r18,lo8(1)
 1753 096e 30E0      		ldi r19,0
 1754 0970 3093 0000 		sts globalDay+1,r19
 1755 0974 2093 0000 		sts globalDay,r18
2339:switcherator.c ****                 globalMonth++;
 1756               		.loc 1 2339 0
 1757 0978 0196      		adiw r24,1
 1758 097a 00C0      		rjmp .L141
 1759               	.L111:
2340:switcherator.c ****             } else {
2341:switcherator.c ****                 return;
2342:switcherator.c ****             }
2343:switcherator.c ****             break;
2344:switcherator.c ****         case 12:
2345:switcherator.c ****             if (globalDay > 31) {
 1760               		.loc 1 2345 0
 1761 097c 2032      		cpi r18,32
 1762 097e 3105      		cpc r19,__zero_reg__
 1763 0980 00F0      		brlo .L101
2346:switcherator.c ****                 // happy new year
2347:switcherator.c ****                 globalDay = 1;
 1764               		.loc 1 2347 0
 1765 0982 81E0      		ldi r24,lo8(1)
 1766 0984 90E0      		ldi r25,0
 1767 0986 9093 0000 		sts globalDay+1,r25
 1768 098a 8093 0000 		sts globalDay,r24
2348:switcherator.c ****                 globalMonth = 1;
 1769               		.loc 1 2348 0
 1770 098e 9093 0000 		sts globalMonth+1,r25
 1771 0992 8093 0000 		sts globalMonth,r24
2349:switcherator.c ****                 globalYear++;
 1772               		.loc 1 2349 0
 1773 0996 8091 0000 		lds r24,globalYear
 1774 099a 9091 0000 		lds r25,globalYear+1
 1775 099e 0196      		adiw r24,1
 1776 09a0 9093 0000 		sts globalYear+1,r25
 1777 09a4 8093 0000 		sts globalYear,r24
2350:switcherator.c ****             } else {
2351:switcherator.c ****                 return;
2352:switcherator.c ****             }
2353:switcherator.c ****             break;
 1778               		.loc 1 2353 0
 1779 09a8 0895      		ret
 1780               	.L109:
2354:switcherator.c ****         case 2:
2355:switcherator.c ****             // leap year?
2356:switcherator.c ****             if (globalYear % 4 == 0) {
 1781               		.loc 1 2356 0
 1782 09aa 8091 0000 		lds r24,globalYear
 1783 09ae 9091 0000 		lds r25,globalYear+1
 1784 09b2 8370      		andi r24,3
 1785 09b4 9927      		clr r25
 1786 09b6 892B      		or r24,r25
 1787 09b8 01F4      		brne .L114
2357:switcherator.c ****                 // yes
2358:switcherator.c ****                 if (globalDay > 29) {
 1788               		.loc 1 2358 0
 1789 09ba 2D31      		cpi r18,29
 1790 09bc 3105      		cpc r19,__zero_reg__
 1791 09be 01F0      		breq .L101
 1792               	.L114:
2359:switcherator.c ****                     globalDay = 1;
2360:switcherator.c ****                     globalMonth++;
2361:switcherator.c ****                 } else {
2362:switcherator.c ****                     return;
2363:switcherator.c ****                 }
2364:switcherator.c ****             } else {
2365:switcherator.c ****                 if (globalDay > 28) {
2366:switcherator.c ****                     globalDay = 1;
 1793               		.loc 1 2366 0
 1794 09c0 81E0      		ldi r24,lo8(1)
 1795 09c2 90E0      		ldi r25,0
 1796 09c4 9093 0000 		sts globalDay+1,r25
 1797 09c8 8093 0000 		sts globalDay,r24
2367:switcherator.c ****                     globalMonth++;
 1798               		.loc 1 2367 0
 1799 09cc 83E0      		ldi r24,lo8(3)
 1800 09ce 90E0      		ldi r25,0
 1801               	.L141:
 1802 09d0 9093 0000 		sts globalMonth+1,r25
 1803 09d4 8093 0000 		sts globalMonth,r24
 1804               	.L101:
 1805 09d8 0895      		ret
 1806               	.LFE56:
 1808               	.global	timerCheck
 1810               	timerCheck:
 1811               	.LFB57:
2368:switcherator.c ****                 } else {
2369:switcherator.c ****                     return;
2370:switcherator.c ****                 }
2371:switcherator.c ****             }
2372:switcherator.c ****             break;
2373:switcherator.c ****     }
2374:switcherator.c ****     return;
2375:switcherator.c **** }
2376:switcherator.c **** 
2377:switcherator.c **** // runs every second.  Checks to see if we need to turn something on or off
2378:switcherator.c **** 
2379:switcherator.c **** void timerCheck(void) {
 1812               		.loc 1 2379 0
 1813 09da 6F92      		push r6
 1814               	.LCFI37:
 1815 09dc 7F92      		push r7
 1816               	.LCFI38:
 1817 09de 8F92      		push r8
 1818               	.LCFI39:
 1819 09e0 9F92      		push r9
 1820               	.LCFI40:
 1821 09e2 AF92      		push r10
 1822               	.LCFI41:
 1823 09e4 BF92      		push r11
 1824               	.LCFI42:
 1825 09e6 CF92      		push r12
 1826               	.LCFI43:
 1827 09e8 DF92      		push r13
 1828               	.LCFI44:
 1829 09ea EF92      		push r14
 1830               	.LCFI45:
 1831 09ec FF92      		push r15
 1832               	.LCFI46:
 1833 09ee 0F93      		push r16
 1834               	.LCFI47:
 1835 09f0 1F93      		push r17
 1836               	.LCFI48:
 1837 09f2 CF93      		push r28
 1838               	.LCFI49:
 1839 09f4 DF93      		push r29
 1840               	.LCFI50:
 1841               	/* prologue: function */
 1842               	/* frame size = 0 */
 1843               	/* stack size = 14 */
 1844               	.L__stack_usage = 14
 1845               	.LVL110:
2380:switcherator.c ****     int x = 0;
2381:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
2382:switcherator.c ****         // see if something should turn off
2383:switcherator.c ****         if ((switchStatus[x] > 0) && (switchStatus[x] < weeklySeconds)) {
 1846               		.loc 1 2383 0
 1847 09f6 4091 0000 		lds r20,weeklySeconds
 1848 09fa 5091 0000 		lds r21,weeklySeconds+1
 1849 09fe 6091 0000 		lds r22,weeklySeconds+2
 1850 0a02 7091 0000 		lds r23,weeklySeconds+3
 1851 0a06 2091 0000 		lds r18,switchChanged
 1852 0a0a E0E0      		ldi r30,lo8(switchStatus)
 1853 0a0c F0E0      		ldi r31,hi8(switchStatus)
 1854               	.LVL111:
 1855               	.L145:
 1856 0a0e 8081      		ld r24,Z
 1857 0a10 9181      		ldd r25,Z+1
 1858 0a12 A281      		ldd r26,Z+2
 1859 0a14 B381      		ldd r27,Z+3
 1860 0a16 0097      		sbiw r24,0
 1861 0a18 A105      		cpc r26,__zero_reg__
 1862 0a1a B105      		cpc r27,__zero_reg__
 1863 0a1c 01F0      		breq .L144
 1864               		.loc 1 2383 0 is_stmt 0 discriminator 1
 1865 0a1e 8417      		cp r24,r20
 1866 0a20 9507      		cpc r25,r21
 1867 0a22 A607      		cpc r26,r22
 1868 0a24 B707      		cpc r27,r23
 1869 0a26 00F4      		brsh .L144
2384:switcherator.c ****             switchChanged = 1;
2385:switcherator.c ****             switchStatus[x] = 0;
 1870               		.loc 1 2385 0 is_stmt 1
 1871 0a28 1082      		st Z,__zero_reg__
 1872 0a2a 1182      		std Z+1,__zero_reg__
 1873 0a2c 1282      		std Z+2,__zero_reg__
 1874 0a2e 1382      		std Z+3,__zero_reg__
2384:switcherator.c ****             switchChanged = 1;
 1875               		.loc 1 2384 0
 1876 0a30 21E0      		ldi r18,lo8(1)
 1877               	.L144:
 1878 0a32 3496      		adiw r30,4
2381:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 1879               		.loc 1 2381 0
 1880 0a34 80E0      		ldi r24,hi8(switchStatus+64)
 1881 0a36 E030      		cpi r30,lo8(switchStatus+64)
 1882 0a38 F807      		cpc r31,r24
 1883 0a3a 01F4      		brne .L145
 1884 0a3c 2093 0000 		sts switchChanged,r18
 1885 0a40 C0E0      		ldi r28,lo8(weeklyProgram+4)
 1886 0a42 D0E0      		ldi r29,hi8(weeklyProgram+4)
 1887 0a44 00E0      		ldi r16,0
 1888 0a46 10E0      		ldi r17,0
2386:switcherator.c ****         }
2387:switcherator.c ****     }
2388:switcherator.c ****     // see if something should turn on
2389:switcherator.c ****     // weeklyProgram format
2390:switcherator.c ****     // DssddSSSSP
2391:switcherator.c ****     // 0123456789
2392:switcherator.c ****     long time;
2393:switcherator.c ****     int today = 0;
2394:switcherator.c ****     int duration = 0;
2395:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
2396:switcherator.c ****         // check if there is a valid program
2397:switcherator.c ****         if (weeklyProgram[x][0] != 255 && weeklyProgram[x][1] != 255) { // yes
2398:switcherator.c ****             // see if it goes today
2399:switcherator.c ****             // if dow = 0 (sunday) the program stores this as 0x40 then down from there
2400:switcherator.c ****             today = (0x40 >> dow);
 1889               		.loc 1 2400 0
 1890 0a48 30E4      		ldi r19,lo8(64)
 1891 0a4a C32E      		mov r12,r19
 1892 0a4c D12C      		mov r13,__zero_reg__
 1893               	.L147:
2379:switcherator.c **** void timerCheck(void) {
 1894               		.loc 1 2379 0
 1895 0a4e FE01      		movw r30,r28
 1896 0a50 3497      		sbiw r30,4
2397:switcherator.c ****         if (weeklyProgram[x][0] != 255 && weeklyProgram[x][1] != 255) { // yes
 1897               		.loc 1 2397 0
 1898 0a52 8081      		ld r24,Z
 1899 0a54 8F3F      		cpi r24,lo8(-1)
 1900 0a56 01F4      		brne .+2
 1901 0a58 00C0      		rjmp .L146
2379:switcherator.c **** void timerCheck(void) {
 1902               		.loc 1 2379 0 discriminator 1
 1903 0a5a FE01      		movw r30,r28
 1904 0a5c 3397      		sbiw r30,3
2397:switcherator.c ****         if (weeklyProgram[x][0] != 255 && weeklyProgram[x][1] != 255) { // yes
 1905               		.loc 1 2397 0 discriminator 1
 1906 0a5e 2081      		ld r18,Z
 1907 0a60 2F3F      		cpi r18,lo8(-1)
 1908 0a62 01F4      		brne .+2
 1909 0a64 00C0      		rjmp .L146
 1910               		.loc 1 2400 0
 1911 0a66 7090 0000 		lds r7,dow
 1912 0a6a 6090 0000 		lds r6,dow+1
 1913               	.LVL112:
2401:switcherator.c ****             // k is today the day?
2402:switcherator.c ****             if (weeklyProgram[x][0] & today) {
 1914               		.loc 1 2402 0
 1915 0a6e 90E0      		ldi r25,0
2400:switcherator.c ****             today = (0x40 >> dow);
 1916               		.loc 1 2400 0
 1917 0a70 A601      		movw r20,r12
 1918 0a72 072C      		mov r0,r7
 1919 0a74 00C0      		rjmp 2f
 1920               		1:
 1921 0a76 5595      		asr r21
 1922 0a78 4795      		ror r20
 1923               		2:
 1924 0a7a 0A94      		dec r0
 1925 0a7c 02F4      		brpl 1b
 1926               		.loc 1 2402 0
 1927 0a7e 8423      		and r24,r20
 1928 0a80 9523      		and r25,r21
 1929 0a82 892B      		or r24,r25
 1930 0a84 01F4      		brne .+2
 1931 0a86 00C0      		rjmp .L146
2403:switcherator.c **** 
2404:switcherator.c ****                 // yes we run today
2405:switcherator.c ****                 time = weeklyProgram[x][1];
 1932               		.loc 1 2405 0
 1933 0a88 822F      		mov r24,r18
 1934 0a8a 90E0      		ldi r25,0
 1935 0a8c A0E0      		ldi r26,0
 1936 0a8e B0E0      		ldi r27,0
 1937               	.LVL113:
2406:switcherator.c ****                 time <<= 8;
 1938               		.loc 1 2406 0
 1939 0a90 2227      		clr r18
 1940 0a92 382F      		mov r19,r24
 1941 0a94 492F      		mov r20,r25
 1942 0a96 5A2F      		mov r21,r26
 1943               	.LVL114:
2379:switcherator.c **** void timerCheck(void) {
 1944               		.loc 1 2379 0
 1945 0a98 FE01      		movw r30,r28
 1946 0a9a 3297      		sbiw r30,2
2407:switcherator.c ****                 time |= weeklyProgram[x][2];
 1947               		.loc 1 2407 0
 1948 0a9c 8081      		ld r24,Z
 1949 0a9e 282B      		or r18,r24
 1950               	.LVL115:
2408:switcherator.c ****                 // weeklyProgram is stored in minutes
2409:switcherator.c ****                 time *= 60;
 1951               		.loc 1 2409 0
 1952 0aa0 ACE3      		ldi r26,lo8(60)
 1953 0aa2 B0E0      		ldi r27,0
 1954 0aa4 0E94 0000 		call __muluhisi3
 1955 0aa8 4B01      		movw r8,r22
 1956 0aaa 5C01      		movw r10,r24
 1957               	.LVL116:
2379:switcherator.c **** void timerCheck(void) {
 1958               		.loc 1 2379 0
 1959 0aac FE01      		movw r30,r28
 1960 0aae 3197      		sbiw r30,1
2410:switcherator.c ****                 duration = weeklyProgram[x][3];
 1961               		.loc 1 2410 0
 1962 0ab0 F081      		ld r31,Z
 1963               	.LVL117:
2411:switcherator.c ****                 duration <<= 8;
2412:switcherator.c ****                 duration |= weeklyProgram[x][4];
 1964               		.loc 1 2412 0
 1965 0ab2 E881      		ld r30,Y
 1966               	.LVL118:
2413:switcherator.c ****                 time += (dow * 86400); //seconds in day
 1967               		.loc 1 2413 0
 1968 0ab4 A72D      		mov r26,r7
 1969 0ab6 B62D      		mov r27,r6
 1970 0ab8 20E8      		ldi r18,lo8(-128)
 1971 0aba 31E5      		ldi r19,lo8(81)
 1972 0abc 41E0      		ldi r20,lo8(1)
 1973 0abe 50E0      		ldi r21,0
 1974 0ac0 0E94 0000 		call __muluhisi3
 1975 0ac4 860E      		add r8,r22
 1976 0ac6 971E      		adc r9,r23
 1977 0ac8 A81E      		adc r10,r24
 1978 0aca B91E      		adc r11,r25
 1979               	.LVL119:
2414:switcherator.c ****                 // check if we are between start & stop time
2415:switcherator.c ****                 if ((weeklySeconds >= time) && (weeklySeconds < (time + duration))) {
 1980               		.loc 1 2415 0
 1981 0acc 4091 0000 		lds r20,weeklySeconds
 1982 0ad0 5091 0000 		lds r21,weeklySeconds+1
 1983 0ad4 6091 0000 		lds r22,weeklySeconds+2
 1984 0ad8 7091 0000 		lds r23,weeklySeconds+3
 1985 0adc 4815      		cp r20,r8
 1986 0ade 5905      		cpc r21,r9
 1987 0ae0 6A05      		cpc r22,r10
 1988 0ae2 7B05      		cpc r23,r11
 1989 0ae4 00F0      		brlo .L146
2411:switcherator.c ****                 duration <<= 8;
 1990               		.loc 1 2411 0 discriminator 1
 1991 0ae6 FF2E      		mov r15,r31
 1992 0ae8 E12C      		mov r14,__zero_reg__
2412:switcherator.c ****                 duration |= weeklyProgram[x][4];
 1993               		.loc 1 2412 0 discriminator 1
 1994 0aea C701      		movw r24,r14
 1995 0aec 8E2B      		or r24,r30
 1996               		.loc 1 2415 0 discriminator 1
 1997 0aee AA27      		clr r26
 1998 0af0 97FD      		sbrc r25,7
 1999 0af2 A095      		com r26
 2000 0af4 BA2F      		mov r27,r26
 2001 0af6 880D      		add r24,r8
 2002 0af8 991D      		adc r25,r9
 2003 0afa AA1D      		adc r26,r10
 2004 0afc BB1D      		adc r27,r11
 2005 0afe 4817      		cp r20,r24
 2006 0b00 5907      		cpc r21,r25
 2007 0b02 6A07      		cpc r22,r26
 2008 0b04 7B07      		cpc r23,r27
 2009 0b06 00F4      		brsh .L146
2416:switcherator.c ****                     // feed time to it so the end time won't change
2417:switcherator.c ****                     startTheProgram(x, 0, time);
 2010               		.loc 1 2417 0
 2011 0b08 A501      		movw r20,r10
 2012 0b0a 9401      		movw r18,r8
 2013 0b0c 60E0      		ldi r22,0
 2014 0b0e 70E0      		ldi r23,0
 2015 0b10 C801      		movw r24,r16
 2016 0b12 0E94 0000 		call startTheProgram
 2017               	.LVL120:
 2018               	.L146:
2395:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 2019               		.loc 1 2395 0
 2020 0b16 0F5F      		subi r16,-1
 2021 0b18 1F4F      		sbci r17,-1
 2022               	.LVL121:
 2023 0b1a 2A96      		adiw r28,10
 2024 0b1c 0A30      		cpi r16,10
 2025 0b1e 1105      		cpc r17,__zero_reg__
 2026 0b20 01F0      		breq .+2
 2027 0b22 00C0      		rjmp .L147
 2028               	/* epilogue start */
2418:switcherator.c ****                 }
2419:switcherator.c ****             }
2420:switcherator.c ****         }
2421:switcherator.c ****     }
2422:switcherator.c **** }
 2029               		.loc 1 2422 0
 2030 0b24 DF91      		pop r29
 2031 0b26 CF91      		pop r28
 2032 0b28 1F91      		pop r17
 2033 0b2a 0F91      		pop r16
 2034               	.LVL122:
 2035 0b2c FF90      		pop r15
 2036 0b2e EF90      		pop r14
 2037 0b30 DF90      		pop r13
 2038 0b32 CF90      		pop r12
 2039 0b34 BF90      		pop r11
 2040 0b36 AF90      		pop r10
 2041 0b38 9F90      		pop r9
 2042 0b3a 8F90      		pop r8
 2043 0b3c 7F90      		pop r7
 2044 0b3e 6F90      		pop r6
 2045 0b40 0895      		ret
 2046               	.LFE57:
 2048               	.global	switchOnOff
 2050               	switchOnOff:
 2051               	.LFB58:
2423:switcherator.c **** 
2424:switcherator.c **** // iterate through the switches and turn them on or off
2425:switcherator.c **** 
2426:switcherator.c **** void switchOnOff(void) {
 2052               		.loc 1 2426 0
 2053 0b42 7F92      		push r7
 2054               	.LCFI51:
 2055 0b44 8F92      		push r8
 2056               	.LCFI52:
 2057 0b46 9F92      		push r9
 2058               	.LCFI53:
 2059 0b48 AF92      		push r10
 2060               	.LCFI54:
 2061 0b4a BF92      		push r11
 2062               	.LCFI55:
 2063 0b4c CF92      		push r12
 2064               	.LCFI56:
 2065 0b4e DF92      		push r13
 2066               	.LCFI57:
 2067 0b50 EF92      		push r14
 2068               	.LCFI58:
 2069 0b52 FF92      		push r15
 2070               	.LCFI59:
 2071 0b54 0F93      		push r16
 2072               	.LCFI60:
 2073 0b56 1F93      		push r17
 2074               	.LCFI61:
 2075 0b58 CF93      		push r28
 2076               	.LCFI62:
 2077 0b5a DF93      		push r29
 2078               	.LCFI63:
 2079 0b5c 00D0      		rcall .
 2080 0b5e 1F92      		push __zero_reg__
 2081               	.LCFI64:
 2082 0b60 CDB7      		in r28,__SP_L__
 2083 0b62 DEB7      		in r29,__SP_H__
 2084               	.LCFI65:
 2085               	/* prologue: function */
 2086               	/* frame size = 3 */
 2087               	/* stack size = 16 */
 2088               	.L__stack_usage = 16
 2089               	.LVL123:
 2090 0b64 10E0      		ldi r17,lo8(switchStuff)
 2091 0b66 812E      		mov r8,r17
 2092 0b68 10E0      		ldi r17,hi8(switchStuff)
 2093 0b6a 912E      		mov r9,r17
 2094 0b6c 00E0      		ldi r16,lo8(switchStatus)
 2095 0b6e C02E      		mov r12,r16
 2096 0b70 00E0      		ldi r16,hi8(switchStatus)
 2097 0b72 D02E      		mov r13,r16
2427:switcherator.c ****     char port[1];
2428:switcherator.c ****     char pin[1];
2429:switcherator.c ****     int realPin = 0;
2430:switcherator.c ****     int x = 0;
2431:switcherator.c ****     char direction[1];
2432:switcherator.c ****     volatile unsigned char *thisPort = 0;
 2098               		.loc 1 2432 0
 2099 0b74 00E0      		ldi r16,0
 2100 0b76 10E0      		ldi r17,0
2433:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 2101               		.loc 1 2433 0
 2102 0b78 E12C      		mov r14,__zero_reg__
 2103 0b7a F12C      		mov r15,__zero_reg__
2434:switcherator.c ****         // see if a switch is set up
2435:switcherator.c ****         if (switchStuff[x] != 255) {
2436:switcherator.c ****             // find out if this is pwm
2437:switcherator.c ****             if (switchStuff[x] >= 200 && switchStuff[x] <= 220) {
2438:switcherator.c ****                 // are we turning it on or off
2439:switcherator.c ****                 if (switchStatus[x] == 0) {
2440:switcherator.c ****                     // turning it off
2441:switcherator.c ****                     if (switchStuff[x] == 200) {
2442:switcherator.c ****                         Red = 0;
2443:switcherator.c ****                         Green = 0;
2444:switcherator.c ****                         Blue = 0;
2445:switcherator.c ****                     } else if (switchStuff[x] == 201) {
2446:switcherator.c ****                         Red = 0;
2447:switcherator.c ****                         Green = 0;
2448:switcherator.c ****                         Blue = 0;
2449:switcherator.c ****                         runHue = 0;
2450:switcherator.c ****                     } else if (switchStuff[x] == 202) {
2451:switcherator.c ****                         Red = 0;
2452:switcherator.c ****                         Green = 0;
2453:switcherator.c ****                         Blue = 0;
2454:switcherator.c ****                         runColorChanges = 0;
2455:switcherator.c ****                     } else if (switchStuff[x] == 212) {
2456:switcherator.c ****                         bright = oldBright;
2457:switcherator.c ****                     }
2458:switcherator.c ****                 } else {
2459:switcherator.c ****                     // turn it on
2460:switcherator.c ****                     // decide if it is a changing hue or static values
2461:switcherator.c ****                     if (switchStuff[x] == 200) {
2462:switcherator.c ****                         // even numbers are static colors;
2463:switcherator.c ****                         red = pwmValues[0];
2464:switcherator.c ****                         green = pwmValues[1];
2465:switcherator.c ****                         blue = pwmValues[2];
2466:switcherator.c ****                         red = red * bright / 16;
2467:switcherator.c ****                         green = green * bright / 16;
2468:switcherator.c ****                         blue = blue * bright / 16;
2469:switcherator.c ****                         Red = red;
2470:switcherator.c ****                         Green = green;
2471:switcherator.c ****                         Blue = blue;
2472:switcherator.c ****                     } else if (switchStuff[x] == 202) {
2473:switcherator.c ****                         runColorChanges = 1;
2474:switcherator.c ****                     } else if (switchStuff[x] == 212) {
2475:switcherator.c ****                         // change the brightness
2476:switcherator.c ****                         bright = switchBright[x];
2477:switcherator.c ****                     } else {
2478:switcherator.c ****                         // get the hue cycle going
2479:switcherator.c ****                         runHue = 1;
2480:switcherator.c ****                     }
2481:switcherator.c ****                 }
2482:switcherator.c ****                 continue;
2483:switcherator.c ****             }
2484:switcherator.c ****             // switch is set up. Get details
2485:switcherator.c ****             getPort(x, port, pin, direction);
2486:switcherator.c ****             // yeah pointers and casts and whatevers. this fixes it
2487:switcherator.c ****             realPin = pin[0];
2488:switcherator.c ****             if (port[0] == 'B')
2489:switcherator.c ****                 thisPort = &PORTB;
2490:switcherator.c **** #ifdef PORTA
2491:switcherator.c ****             else if (port[0] == 'A')
2492:switcherator.c ****                 thisPort = &PORTA;
2493:switcherator.c **** #endif
2494:switcherator.c **** #ifdef PORTC
2495:switcherator.c ****             else if (port[0] == 'C')
2496:switcherator.c ****                 thisPort = &PORTC;
2497:switcherator.c **** #endif
2498:switcherator.c **** #ifdef PORTD
2499:switcherator.c ****             else if (port[0] == 'D')
2500:switcherator.c ****                 thisPort = &PORTD;
2501:switcherator.c **** #endif
2502:switcherator.c **** #ifdef PORTE
2503:switcherator.c ****             else if (port[0] == 'E')
2504:switcherator.c ****                 thisPort = &PORTE;
2505:switcherator.c **** #endif
2506:switcherator.c **** #ifdef PORTF
2507:switcherator.c ****             else if (port[0] == 'F')
2508:switcherator.c ****                 thisPort = &PORTF;
2509:switcherator.c **** #endif
2510:switcherator.c **** #ifdef PORTG
2511:switcherator.c ****             else if (port[0] == 'G')
2512:switcherator.c ****                 thisPort = &PORTG;
2513:switcherator.c **** #endif
2514:switcherator.c **** #ifdef PORTH
2515:switcherator.c ****             else if (port[0] == 'H')
2516:switcherator.c ****                 thisPort = &PORTH;
2517:switcherator.c **** #endif
2518:switcherator.c **** #ifdef PORTI
2519:switcherator.c ****             else if (port[0] == 'I')
2520:switcherator.c ****                 thisPort = &PORTI;
2521:switcherator.c **** #endif
2522:switcherator.c ****             // k we have the port - now decide if we are turning it on or off and turn it on/off
2523:switcherator.c ****             if (switchStatus[x] == 0) {
2524:switcherator.c ****                 // turning it off
2525:switcherator.c ****                 if (direction[0] == 0) {
2526:switcherator.c ****                     *thisPort |= (1 << realPin);
2527:switcherator.c ****                 } else {
2528:switcherator.c ****                     *thisPort &= ~(1 << realPin);
2529:switcherator.c ****                 }
2530:switcherator.c ****             } else {
2531:switcherator.c ****                 // turning it on
2532:switcherator.c ****                 if (direction[0] == 0) {
2533:switcherator.c ****                     *thisPort &= ~(1 << realPin);
2534:switcherator.c ****                 } else {
2535:switcherator.c ****                     *thisPort |= (1 << realPin);
 2104               		.loc 1 2535 0
 2105 0b7c AA24      		clr r10
 2106 0b7e A394      		inc r10
 2107 0b80 B12C      		mov r11,__zero_reg__
2479:switcherator.c ****                         runHue = 1;
 2108               		.loc 1 2479 0
 2109 0b82 7724      		clr r7
 2110 0b84 7394      		inc r7
 2111               	.LVL124:
 2112               	.L176:
2435:switcherator.c ****         if (switchStuff[x] != 255) {
 2113               		.loc 1 2435 0
 2114 0b86 F401      		movw r30,r8
 2115 0b88 2191      		ld r18,Z+
 2116 0b8a 4F01      		movw r8,r30
 2117 0b8c 2F3F      		cpi r18,lo8(-1)
 2118 0b8e 01F4      		brne .+2
 2119 0b90 00C0      		rjmp .L163
2437:switcherator.c ****             if (switchStuff[x] >= 200 && switchStuff[x] <= 220) {
 2120               		.loc 1 2437 0
 2121 0b92 822F      		mov r24,r18
 2122 0b94 885C      		subi r24,lo8(-(56))
 2123 0b96 8531      		cpi r24,lo8(21)
 2124 0b98 00F0      		brlo .+2
 2125 0b9a 00C0      		rjmp .L164
2439:switcherator.c ****                 if (switchStatus[x] == 0) {
 2126               		.loc 1 2439 0
 2127 0b9c F601      		movw r30,r12
 2128 0b9e 8081      		ld r24,Z
 2129 0ba0 9181      		ldd r25,Z+1
 2130 0ba2 A281      		ldd r26,Z+2
 2131 0ba4 B381      		ldd r27,Z+3
 2132 0ba6 892B      		or r24,r25
 2133 0ba8 8A2B      		or r24,r26
 2134 0baa 8B2B      		or r24,r27
 2135 0bac 01F4      		brne .L165
2441:switcherator.c ****                     if (switchStuff[x] == 200) {
 2136               		.loc 1 2441 0
 2137 0bae 283C      		cpi r18,lo8(-56)
 2138 0bb0 01F4      		brne .L166
2442:switcherator.c ****                         Red = 0;
 2139               		.loc 1 2442 0
 2140 0bb2 1092 B400 		sts 180,__zero_reg__
2443:switcherator.c ****                         Green = 0;
 2141               		.loc 1 2443 0
 2142 0bb6 18BC      		out 0x28,__zero_reg__
2444:switcherator.c ****                         Blue = 0;
 2143               		.loc 1 2444 0
 2144 0bb8 17BC      		out 0x27,__zero_reg__
 2145 0bba 00C0      		rjmp .L163
 2146               	.L166:
2445:switcherator.c ****                     } else if (switchStuff[x] == 201) {
 2147               		.loc 1 2445 0
 2148 0bbc 293C      		cpi r18,lo8(-55)
 2149 0bbe 01F4      		brne .L167
2446:switcherator.c ****                         Red = 0;
 2150               		.loc 1 2446 0
 2151 0bc0 1092 B400 		sts 180,__zero_reg__
2447:switcherator.c ****                         Green = 0;
 2152               		.loc 1 2447 0
 2153 0bc4 18BC      		out 0x28,__zero_reg__
2448:switcherator.c ****                         Blue = 0;
 2154               		.loc 1 2448 0
 2155 0bc6 17BC      		out 0x27,__zero_reg__
2449:switcherator.c ****                         runHue = 0;
 2156               		.loc 1 2449 0
 2157 0bc8 1092 0000 		sts runHue,__zero_reg__
 2158 0bcc 00C0      		rjmp .L163
 2159               	.L167:
2450:switcherator.c ****                     } else if (switchStuff[x] == 202) {
 2160               		.loc 1 2450 0
 2161 0bce 2A3C      		cpi r18,lo8(-54)
 2162 0bd0 01F4      		brne .L168
2451:switcherator.c ****                         Red = 0;
 2163               		.loc 1 2451 0
 2164 0bd2 1092 B400 		sts 180,__zero_reg__
2452:switcherator.c ****                         Green = 0;
 2165               		.loc 1 2452 0
 2166 0bd6 18BC      		out 0x28,__zero_reg__
2453:switcherator.c ****                         Blue = 0;
 2167               		.loc 1 2453 0
 2168 0bd8 17BC      		out 0x27,__zero_reg__
2454:switcherator.c ****                         runColorChanges = 0;
 2169               		.loc 1 2454 0
 2170 0bda 1092 0000 		sts runColorChanges,__zero_reg__
 2171 0bde 00C0      		rjmp .L163
 2172               	.L168:
2455:switcherator.c ****                     } else if (switchStuff[x] == 212) {
 2173               		.loc 1 2455 0
 2174 0be0 243D      		cpi r18,lo8(-44)
 2175 0be2 01F0      		breq .+2
 2176 0be4 00C0      		rjmp .L163
2456:switcherator.c ****                         bright = oldBright;
 2177               		.loc 1 2456 0
 2178 0be6 8091 0000 		lds r24,oldBright
 2179 0bea 00C0      		rjmp .L184
 2180               	.L165:
2461:switcherator.c ****                     if (switchStuff[x] == 200) {
 2181               		.loc 1 2461 0
 2182 0bec 283C      		cpi r18,lo8(-56)
 2183 0bee 01F4      		brne .L169
2464:switcherator.c ****                         green = pwmValues[1];
 2184               		.loc 1 2464 0
 2185 0bf0 8091 0000 		lds r24,pwmValues+1
2465:switcherator.c ****                         blue = pwmValues[2];
 2186               		.loc 1 2465 0
 2187 0bf4 E091 0000 		lds r30,pwmValues+2
2466:switcherator.c ****                         red = red * bright / 16;
 2188               		.loc 1 2466 0
 2189 0bf8 6091 0000 		lds r22,bright
 2190 0bfc 7091 0000 		lds r23,bright+1
2463:switcherator.c ****                         red = pwmValues[0];
 2191               		.loc 1 2463 0
 2192 0c00 9091 0000 		lds r25,pwmValues
2466:switcherator.c ****                         red = red * bright / 16;
 2193               		.loc 1 2466 0
 2194 0c04 969F      		mul r25,r22
 2195 0c06 A001      		movw r20,r0
 2196 0c08 979F      		mul r25,r23
 2197 0c0a 500D      		add r21,r0
 2198 0c0c 1124      		clr __zero_reg__
 2199 0c0e F4E0      		ldi r31,4
 2200               		1:
 2201 0c10 5695      		lsr r21
 2202 0c12 4795      		ror r20
 2203 0c14 FA95      		dec r31
 2204 0c16 01F4      		brne 1b
 2205 0c18 5093 0000 		sts red+1,r21
 2206 0c1c 4093 0000 		sts red,r20
2467:switcherator.c ****                         green = green * bright / 16;
 2207               		.loc 1 2467 0
 2208 0c20 869F      		mul r24,r22
 2209 0c22 9001      		movw r18,r0
 2210 0c24 879F      		mul r24,r23
 2211 0c26 300D      		add r19,r0
 2212 0c28 1124      		clr __zero_reg__
 2213 0c2a A4E0      		ldi r26,4
 2214               		1:
 2215 0c2c 3695      		lsr r19
 2216 0c2e 2795      		ror r18
 2217 0c30 AA95      		dec r26
 2218 0c32 01F4      		brne 1b
 2219 0c34 3093 0000 		sts green+1,r19
 2220 0c38 2093 0000 		sts green,r18
2468:switcherator.c ****                         blue = blue * bright / 16;
 2221               		.loc 1 2468 0
 2222 0c3c E69F      		mul r30,r22
 2223 0c3e C001      		movw r24,r0
 2224 0c40 E79F      		mul r30,r23
 2225 0c42 900D      		add r25,r0
 2226 0c44 1124      		clr __zero_reg__
 2227 0c46 B4E0      		ldi r27,4
 2228               		1:
 2229 0c48 9695      		lsr r25
 2230 0c4a 8795      		ror r24
 2231 0c4c BA95      		dec r27
 2232 0c4e 01F4      		brne 1b
 2233 0c50 9093 0000 		sts blue+1,r25
 2234 0c54 8093 0000 		sts blue,r24
2469:switcherator.c ****                         Red = red;
 2235               		.loc 1 2469 0
 2236 0c58 4093 B400 		sts 180,r20
2470:switcherator.c ****                         Green = green;
 2237               		.loc 1 2470 0
 2238 0c5c 28BD      		out 0x28,r18
2471:switcherator.c ****                         Blue = blue;
 2239               		.loc 1 2471 0
 2240 0c5e 87BD      		out 0x27,r24
 2241 0c60 00C0      		rjmp .L163
 2242               	.L169:
2472:switcherator.c ****                     } else if (switchStuff[x] == 202) {
 2243               		.loc 1 2472 0
 2244 0c62 2A3C      		cpi r18,lo8(-54)
 2245 0c64 01F4      		brne .L170
2473:switcherator.c ****                         runColorChanges = 1;
 2246               		.loc 1 2473 0
 2247 0c66 7092 0000 		sts runColorChanges,r7
 2248 0c6a 00C0      		rjmp .L163
 2249               	.L170:
2474:switcherator.c ****                     } else if (switchStuff[x] == 212) {
 2250               		.loc 1 2474 0
 2251 0c6c 243D      		cpi r18,lo8(-44)
 2252 0c6e 01F4      		brne .L171
2426:switcherator.c **** void switchOnOff(void) {
 2253               		.loc 1 2426 0
 2254 0c70 F701      		movw r30,r14
 2255 0c72 E050      		subi r30,lo8(-(switchBright))
 2256 0c74 F040      		sbci r31,hi8(-(switchBright))
2476:switcherator.c ****                         bright = switchBright[x];
 2257               		.loc 1 2476 0
 2258 0c76 8081      		ld r24,Z
 2259               	.L184:
 2260 0c78 8093 0000 		sts bright,r24
 2261 0c7c 1092 0000 		sts bright+1,__zero_reg__
 2262 0c80 00C0      		rjmp .L163
 2263               	.L171:
2479:switcherator.c ****                         runHue = 1;
 2264               		.loc 1 2479 0
 2265 0c82 7092 0000 		sts runHue,r7
 2266 0c86 00C0      		rjmp .L163
 2267               	.L164:
2485:switcherator.c ****             getPort(x, port, pin, direction);
 2268               		.loc 1 2485 0
 2269 0c88 9E01      		movw r18,r28
 2270 0c8a 2F5F      		subi r18,-1
 2271 0c8c 3F4F      		sbci r19,-1
 2272 0c8e AE01      		movw r20,r28
 2273 0c90 4E5F      		subi r20,-2
 2274 0c92 5F4F      		sbci r21,-1
 2275 0c94 BE01      		movw r22,r28
 2276 0c96 6D5F      		subi r22,-3
 2277 0c98 7F4F      		sbci r23,-1
 2278 0c9a C701      		movw r24,r14
 2279 0c9c 0E94 0000 		call getPort
 2280               	.LVL125:
2487:switcherator.c ****             realPin = pin[0];
 2281               		.loc 1 2487 0
 2282 0ca0 2A81      		ldd r18,Y+2
2488:switcherator.c ****             if (port[0] == 'B')
 2283               		.loc 1 2488 0
 2284 0ca2 8B81      		ldd r24,Y+3
 2285 0ca4 8234      		cpi r24,lo8(66)
 2286 0ca6 01F0      		breq .L177
2495:switcherator.c ****             else if (port[0] == 'C')
 2287               		.loc 1 2495 0
 2288 0ca8 8334      		cpi r24,lo8(67)
 2289 0caa 01F0      		breq .L178
2499:switcherator.c ****             else if (port[0] == 'D')
 2290               		.loc 1 2499 0
 2291 0cac 8434      		cpi r24,lo8(68)
 2292 0cae 01F4      		brne .L172
 2293 0cb0 00C0      		rjmp .L179
 2294               	.L177:
2489:switcherator.c ****                 thisPort = &PORTB;
 2295               		.loc 1 2489 0
 2296 0cb2 05E2      		ldi r16,lo8(37)
 2297 0cb4 10E0      		ldi r17,0
 2298 0cb6 00C0      		rjmp .L172
 2299               	.L178:
2496:switcherator.c ****                 thisPort = &PORTC;
 2300               		.loc 1 2496 0
 2301 0cb8 08E2      		ldi r16,lo8(40)
 2302 0cba 10E0      		ldi r17,0
 2303 0cbc 00C0      		rjmp .L172
 2304               	.L179:
2500:switcherator.c ****                 thisPort = &PORTD;
 2305               		.loc 1 2500 0
 2306 0cbe 0BE2      		ldi r16,lo8(43)
 2307 0cc0 10E0      		ldi r17,0
 2308               	.L172:
 2309               	.LVL126:
2523:switcherator.c ****             if (switchStatus[x] == 0) {
 2310               		.loc 1 2523 0
 2311 0cc2 F601      		movw r30,r12
 2312 0cc4 8081      		ld r24,Z
 2313 0cc6 9181      		ldd r25,Z+1
 2314 0cc8 A281      		ldd r26,Z+2
 2315 0cca B381      		ldd r27,Z+3
 2316 0ccc 3981      		ldd r19,Y+1
2526:switcherator.c ****                     *thisPort |= (1 << realPin);
 2317               		.loc 1 2526 0
 2318 0cce F801      		movw r30,r16
2523:switcherator.c ****             if (switchStatus[x] == 0) {
 2319               		.loc 1 2523 0
 2320 0cd0 892B      		or r24,r25
 2321 0cd2 8A2B      		or r24,r26
 2322 0cd4 8B2B      		or r24,r27
 2323 0cd6 01F4      		brne .L173
2525:switcherator.c ****                 if (direction[0] == 0) {
 2324               		.loc 1 2525 0
 2325 0cd8 3111      		cpse r19,__zero_reg__
 2326 0cda 00C0      		rjmp .L186
 2327 0cdc 00C0      		rjmp .L175
 2328               	.L173:
2532:switcherator.c ****                 if (direction[0] == 0) {
 2329               		.loc 1 2532 0
 2330 0cde 3111      		cpse r19,__zero_reg__
 2331 0ce0 00C0      		rjmp .L175
 2332               	.L186:
2533:switcherator.c ****                     *thisPort &= ~(1 << realPin);
 2333               		.loc 1 2533 0
 2334 0ce2 3081      		ld r19,Z
 2335 0ce4 C501      		movw r24,r10
 2336 0ce6 022E      		mov r0,r18
 2337 0ce8 00C0      		rjmp 2f
 2338               		1:
 2339 0cea 880F      		lsl r24
 2340               		2:
 2341 0cec 0A94      		dec r0
 2342 0cee 02F4      		brpl 1b
 2343 0cf0 8095      		com r24
 2344 0cf2 3823      		and r19,r24
 2345 0cf4 00C0      		rjmp .L185
 2346               	.L175:
 2347               		.loc 1 2535 0
 2348 0cf6 3081      		ld r19,Z
 2349 0cf8 C501      		movw r24,r10
 2350 0cfa 022E      		mov r0,r18
 2351 0cfc 00C0      		rjmp 2f
 2352               		1:
 2353 0cfe 880F      		lsl r24
 2354               		2:
 2355 0d00 0A94      		dec r0
 2356 0d02 02F4      		brpl 1b
 2357 0d04 382B      		or r19,r24
 2358               	.L185:
 2359 0d06 3083      		st Z,r19
 2360               	.LVL127:
 2361               	.L163:
2433:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 2362               		.loc 1 2433 0
 2363 0d08 FFEF      		ldi r31,-1
 2364 0d0a EF1A      		sub r14,r31
 2365 0d0c FF0A      		sbc r15,r31
 2366               	.LVL128:
 2367 0d0e 84E0      		ldi r24,4
 2368 0d10 C80E      		add r12,r24
 2369 0d12 D11C      		adc r13,__zero_reg__
 2370 0d14 E0E1      		ldi r30,16
 2371 0d16 EE16      		cp r14,r30
 2372 0d18 F104      		cpc r15,__zero_reg__
 2373 0d1a 01F0      		breq .+2
 2374 0d1c 00C0      		rjmp .L176
 2375               	/* epilogue start */
2536:switcherator.c ****                 }
2537:switcherator.c ****             }
2538:switcherator.c ****         }
2539:switcherator.c ****     }
2540:switcherator.c **** }
 2376               		.loc 1 2540 0
 2377 0d1e 0F90      		pop __tmp_reg__
 2378 0d20 0F90      		pop __tmp_reg__
 2379 0d22 0F90      		pop __tmp_reg__
 2380 0d24 DF91      		pop r29
 2381 0d26 CF91      		pop r28
 2382 0d28 1F91      		pop r17
 2383 0d2a 0F91      		pop r16
 2384               	.LVL129:
 2385 0d2c FF90      		pop r15
 2386 0d2e EF90      		pop r14
 2387               	.LVL130:
 2388 0d30 DF90      		pop r13
 2389 0d32 CF90      		pop r12
 2390 0d34 BF90      		pop r11
 2391 0d36 AF90      		pop r10
 2392 0d38 9F90      		pop r9
 2393 0d3a 8F90      		pop r8
 2394 0d3c 7F90      		pop r7
 2395 0d3e 0895      		ret
 2396               	.LFE58:
 2398               		.section	.rodata.str1.1,"aMS",@progbits,1
 2399               	.LC1:
 2400 0000 3000      		.string	"0"
 2401               		.text
 2402               	.global	returnInt
 2404               	returnInt:
 2405               	.LFB67:
2541:switcherator.c **** 
2542:switcherator.c **** // sets the time limits for switches to affect progams
2543:switcherator.c **** // TL:##HHMMHHMMddddddd
2544:switcherator.c **** // 01234567890123456789
2545:switcherator.c **** 
2546:switcherator.c **** void setTimeLimits(char * commandReceived) {
2547:switcherator.c ****     char tempReallyLongString[] = "0000000";
2548:switcherator.c ****     int programNumber = 0;
2549:switcherator.c ****     long weekLong = 0;
2550:switcherator.c ****     long startTime = 0;
2551:switcherator.c ****     long stopTime = 0;
2552:switcherator.c ****     int x = 0;
2553:switcherator.c ****     statusMsg[0] = 0;
2554:switcherator.c ****     unsigned int startHour, startMinute, stopHour, stopMinute;
2555:switcherator.c ****     tempIntString[0] = commandReceived[3];
2556:switcherator.c ****     tempIntString[1] = commandReceived[4];
2557:switcherator.c ****     programNumber = atoi(tempIntString);
2558:switcherator.c ****     if (programNumber > NUM_LIMITS) {
2559:switcherator.c ****         fail(0x10);
2560:switcherator.c ****         return;
2561:switcherator.c ****     }
2562:switcherator.c ****     if (commandReceived[5] == 'x' || commandReceived[5] == 'x') {
2563:switcherator.c ****         timeLimits[programNumber][2] = 0;
2564:switcherator.c ****         ok();
2565:switcherator.c ****         return;
2566:switcherator.c ****     }
2567:switcherator.c ****     if (commandReceived[5] == '?') {
2568:switcherator.c ****         // show the limit.
2569:switcherator.c ****         startTime = timeLimits[programNumber][0];
2570:switcherator.c ****         stopTime = timeLimits[programNumber][1];
2571:switcherator.c ****         strcat(statusMsg, "Start:");
2572:switcherator.c ****         startHour = (startTime / 60 / 60);
2573:switcherator.c ****         returnInt(startHour, tempLongString);
2574:switcherator.c ****         strcat(statusMsg, tempLongString);
2575:switcherator.c ****         startMinute = ((startTime - (startHour * 60 * 60)) / 60);
2576:switcherator.c ****         strcat(statusMsg, ":");
2577:switcherator.c ****         returnInt(startMinute, tempLongString);
2578:switcherator.c ****         strcat(statusMsg, tempLongString);
2579:switcherator.c ****         strcat(statusMsg, "Stop:");
2580:switcherator.c ****         stopHour = (startTime / 60 / 60);
2581:switcherator.c ****         returnInt(stopHour, tempLongString);
2582:switcherator.c ****         strcat(statusMsg, tempLongString);
2583:switcherator.c ****         stopMinute = ((startTime - (stopHour * 60 * 60)) / 60);
2584:switcherator.c ****         strcat(statusMsg, ":");
2585:switcherator.c ****         returnInt(stopMinute, tempLongString);
2586:switcherator.c ****         strcat(statusMsg, tempLongString);
2587:switcherator.c ****         sendMessage(statusMsg);
2588:switcherator.c ****         return;
2589:switcherator.c ****     }
2590:switcherator.c ****     for (x = 0; x < 7; x++) {
2591:switcherator.c ****         tempReallyLongString[x] = commandReceived[x + 13];
2592:switcherator.c ****     }
2593:switcherator.c ****     weekLong = strtol(tempReallyLongString, 0, 2);
2594:switcherator.c ****     tempIntString[0] = commandReceived[5];
2595:switcherator.c ****     tempIntString[1] = commandReceived[6];
2596:switcherator.c ****     startHour = atoi(tempIntString);
2597:switcherator.c ****     tempIntString[0] = commandReceived[7];
2598:switcherator.c ****     tempIntString[1] = commandReceived[8];
2599:switcherator.c ****     startMinute = atoi(tempIntString);
2600:switcherator.c ****     tempIntString[0] = commandReceived[9];
2601:switcherator.c ****     tempIntString[1] = commandReceived[10];
2602:switcherator.c ****     stopHour = atoi(tempIntString);
2603:switcherator.c ****     tempIntString[0] = commandReceived[11];
2604:switcherator.c ****     tempIntString[1] = commandReceived[12];
2605:switcherator.c ****     stopMinute = atoi(tempIntString);
2606:switcherator.c ****     if (startHour > 23 || stopHour > 23) {
2607:switcherator.c ****         fail(0x09);
2608:switcherator.c ****         return;
2609:switcherator.c ****     }
2610:switcherator.c ****     if (startMinute > 59 || stopMinute > 59) {
2611:switcherator.c ****         fail(0x0A);
2612:switcherator.c ****         return;
2613:switcherator.c ****     }
2614:switcherator.c ****     startTime = startHour;
2615:switcherator.c ****     startTime = startTime * 60 * 60;
2616:switcherator.c ****     startTime += (startMinute * 60);
2617:switcherator.c ****     stopTime = stopHour;
2618:switcherator.c ****     stopTime = stopTime * 60 * 60;
2619:switcherator.c ****     stopTime += (stopMinute * 60);
2620:switcherator.c ****     timeLimits[programNumber][0] = startTime;
2621:switcherator.c ****     timeLimits[programNumber][1] = stopTime;
2622:switcherator.c ****     timeLimits[programNumber][2] = weekLong;
2623:switcherator.c ****     ok();
2624:switcherator.c **** 
2625:switcherator.c **** }
2626:switcherator.c **** 
2627:switcherator.c **** // take in 3 digits to tweak the clock time
2628:switcherator.c **** // CT xxxx
2629:switcherator.c **** 
2630:switcherator.c **** void clockTweak(char * commandReceived) {
2631:switcherator.c ****     int x = 0;
2632:switcherator.c ****     for (x = 0; x < 4; x++) {
2633:switcherator.c ****         tempLongString[x] = commandReceived[(x + 3)];
2634:switcherator.c ****     }
2635:switcherator.c ****     int adjustment = atoi(tempLongString);
2636:switcherator.c ****     if (adjustment == 0) {
2637:switcherator.c ****         itoa(tweakTimer, tempLongString, 10);
2638:switcherator.c ****         statusMsg[0] = 0;
2639:switcherator.c ****         strcat(statusMsg, "Curr Tweak:");
2640:switcherator.c ****         strcat(statusMsg, tempLongString);
2641:switcherator.c ****         sendMessage(statusMsg);
2642:switcherator.c ****         return;
2643:switcherator.c ****     }
2644:switcherator.c ****     tweakTimer += adjustment;
2645:switcherator.c ****     ok();
2646:switcherator.c **** }
2647:switcherator.c **** 
2648:switcherator.c **** /****************************************************************
2649:switcherator.c ****  *
2650:switcherator.c ****  *              All Things debug and output Related
2651:switcherator.c ****  *
2652:switcherator.c ****  ****************************************************************/
2653:switcherator.c **** 
2654:switcherator.c **** 
2655:switcherator.c **** 
2656:switcherator.c **** 
2657:switcherator.c **** 
2658:switcherator.c **** 
2659:switcherator.c **** // sends a general status
2660:switcherator.c **** // basically an overview of the system
2661:switcherator.c **** 
2662:switcherator.c **** void generalStatus(char * commandReceived) {
2663:switcherator.c ****     statusMsg[0] = 0;
2664:switcherator.c ****     tempIntString[0] = commandReceived[2];
2665:switcherator.c ****     tempIntString[1] = commandReceived[3];
2666:switcherator.c **** 
2667:switcherator.c ****     strcat(statusMsg, "S#");
2668:switcherator.c ****     int serialLength = 0;
2669:switcherator.c ****     //since a 0 serial number is not valid that means to return the serial number
2670:switcherator.c ****     serialLength = strlen(stringSerial);
2671:switcherator.c ****     while (serialLength < 6) {
2672:switcherator.c ****         strcat(statusMsg, "0");
2673:switcherator.c ****         serialLength++;
2674:switcherator.c ****     }
2675:switcherator.c ****     strcat(statusMsg, stringSerial);
2676:switcherator.c **** 
2677:switcherator.c ****     if (panicMyClockIsNotSet == 1) {
2678:switcherator.c ****         strcat(statusMsg, " T:xx/xx/xxxx xx:xx:xx");
2679:switcherator.c ****     } else {
2680:switcherator.c ****         strcat(statusMsg, " T:");
2681:switcherator.c ****         returnInt(globalMonth, tempLongString);
2682:switcherator.c ****         strcat(statusMsg, tempLongString);
2683:switcherator.c ****         strcat(statusMsg, "/");
2684:switcherator.c ****         returnInt(globalDay, tempLongString);
2685:switcherator.c ****         strcat(statusMsg, tempLongString);
2686:switcherator.c ****         strcat(statusMsg, "/");
2687:switcherator.c ****         returnInt(globalYear, tempLongString);
2688:switcherator.c ****         strcat(statusMsg, tempLongString);
2689:switcherator.c ****         strcat(statusMsg, " ");
2690:switcherator.c ****         returnInt(globalHour, tempLongString);
2691:switcherator.c ****         strcat(statusMsg, tempLongString);
2692:switcherator.c ****         strcat(statusMsg, ":");
2693:switcherator.c ****         returnInt(globalMinute, tempLongString);
2694:switcherator.c ****         strcat(statusMsg, tempLongString);
2695:switcherator.c ****         strcat(statusMsg, ":");
2696:switcherator.c ****         returnInt(globalSecond, tempLongString);
2697:switcherator.c ****         strcat(statusMsg, tempLongString);
2698:switcherator.c ****     }
2699:switcherator.c ****     sendMessage(statusMsg);
2700:switcherator.c ****     statusMsg[0] = 0;
2701:switcherator.c ****     if (commandReceived[2] == 'q')
2702:switcherator.c ****         return;
2703:switcherator.c **** 
2704:switcherator.c ****     programsProgrammed();
2705:switcherator.c ****     switchesProgrammed();
2706:switcherator.c ****     inputsProgrammed();
2707:switcherator.c ****     switchesOn();
2708:switcherator.c **** }
2709:switcherator.c **** 
2710:switcherator.c **** // returns a basic view of the capabilities
2711:switcherator.c **** void generalInformation(void) {
2712:switcherator.c ****     statusMsg[0] = 0;
2713:switcherator.c ****     strcat(statusMsg,"Pr,");
2714:switcherator.c ****     int count = 0;
2715:switcherator.c ****     int x;
2716:switcherator.c ****     for(x=0;x<MAX_PROGRAM;x++) {
2717:switcherator.c ****         if(weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) 
2718:switcherator.c ****             count++;
2719:switcherator.c ****     }
2720:switcherator.c ****     returnInt(count,tempLongString);
2721:switcherator.c ****     strcat(statusMsg,tempLongString);
2722:switcherator.c ****     strcat(statusMsg,"/");
2723:switcherator.c ****     returnInt(MAX_PROGRAM,tempLongString);
2724:switcherator.c ****     strcat(statusMsg,tempLongString);
2725:switcherator.c ****     strcat(statusMsg,",Sw,");
2726:switcherator.c ****     count = 0;
2727:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
2728:switcherator.c ****         if (switchStuff[x] < 255)
2729:switcherator.c ****             count ++;
2730:switcherator.c ****     }
2731:switcherator.c ****     returnInt(count,tempLongString);
2732:switcherator.c ****     strcat(statusMsg,tempLongString);
2733:switcherator.c ****     strcat(statusMsg,"/");
2734:switcherator.c ****     returnInt(NUM_SWITCHES,tempLongString);
2735:switcherator.c ****     strcat(statusMsg,tempLongString);
2736:switcherator.c ****     strcat(statusMsg,",In,");
2737:switcherator.c ****     count = 0;
2738:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
2739:switcherator.c ****         if (inputs[x][0] < 255)
2740:switcherator.c ****             count ++;
2741:switcherator.c ****     }
2742:switcherator.c ****     returnInt(count,tempLongString);
2743:switcherator.c ****     strcat(statusMsg,tempLongString);
2744:switcherator.c ****     strcat(statusMsg,"/");
2745:switcherator.c ****     returnInt(NUM_INPUTS,tempLongString);
2746:switcherator.c ****     strcat(statusMsg,tempLongString);
2747:switcherator.c ****     strcat(statusMsg,",Li,");
2748:switcherator.c ****     count = 0;
2749:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++) {
2750:switcherator.c ****         if (inputs[x][2] > 0)
2751:switcherator.c ****             count ++;
2752:switcherator.c ****     }
2753:switcherator.c ****     returnInt(count,tempLongString);
2754:switcherator.c ****     strcat(statusMsg,tempLongString);
2755:switcherator.c ****     strcat(statusMsg,"/");
2756:switcherator.c ****     returnInt(NUM_LIMITS,tempLongString);
2757:switcherator.c ****     strcat(statusMsg,tempLongString);
2758:switcherator.c ****     strcat(statusMsg,",CC,");
2759:switcherator.c ****     count = 0;
2760:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
2761:switcherator.c ****         if (colorChanges[x][0] != 0 || colorChanges[x][1] != 1 || colorChanges[x][2] != 0)
2762:switcherator.c ****             count ++;
2763:switcherator.c ****     }
2764:switcherator.c ****     returnInt(count,tempLongString);
2765:switcherator.c ****     strcat(statusMsg,tempLongString);
2766:switcherator.c ****     strcat(statusMsg,"/");
2767:switcherator.c ****     returnInt(NUM_COLOR_CHANGES,tempLongString);
2768:switcherator.c ****     strcat(statusMsg,tempLongString);
2769:switcherator.c ****     sendMessage(statusMsg);
2770:switcherator.c **** }
2771:switcherator.c **** 
2772:switcherator.c **** // transmits Y or N for which programs have been programmed
2773:switcherator.c **** void programsProgrammed(void) {
2774:switcherator.c ****     strcat(statusMsg, "Progs");
2775:switcherator.c ****     int x;
2776:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
2777:switcherator.c ****         if (weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) {
2778:switcherator.c ****             strcat(statusMsg, "n");
2779:switcherator.c ****         } else {
2780:switcherator.c ****             strcat(statusMsg, "y");
2781:switcherator.c ****         }
2782:switcherator.c ****         // can only send 32 bytes at a time
2783:switcherator.c ****         if (strlen(statusMsg) > 30) {
2784:switcherator.c ****             sendMessage(statusMsg);
2785:switcherator.c ****             statusMsg[5] = 0;
2786:switcherator.c ****         }
2787:switcherator.c ****     }
2788:switcherator.c ****     sendMessage(statusMsg);    
2789:switcherator.c **** }
2790:switcherator.c **** // transmits Y or N for which switches have been programmed
2791:switcherator.c **** void switchesProgrammed(void) {
2792:switcherator.c ****     statusMsg[0] = 0;
2793:switcherator.c ****     strcat(statusMsg, "Swi");
2794:switcherator.c ****     int x;
2795:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
2796:switcherator.c **** 
2797:switcherator.c ****         if (switchStuff[x] == 255) {
2798:switcherator.c ****             strcat(statusMsg, "n");
2799:switcherator.c ****         } else {
2800:switcherator.c ****             strcat(statusMsg, "y");
2801:switcherator.c ****         }
2802:switcherator.c ****         // can only send 32 bytes at a time
2803:switcherator.c ****         if (strlen(statusMsg) > 30) {
2804:switcherator.c ****             sendMessage(statusMsg);
2805:switcherator.c ****             statusMsg[3] = 0;
2806:switcherator.c ****         }
2807:switcherator.c ****     }
2808:switcherator.c ****     sendMessage(statusMsg);
2809:switcherator.c **** }
2810:switcherator.c **** 
2811:switcherator.c **** // transmits Y or N for which inputs have been programmed
2812:switcherator.c **** void inputsProgrammed(void) {
2813:switcherator.c ****     statusMsg[0] = 0;
2814:switcherator.c ****     strcat(statusMsg, "In");
2815:switcherator.c ****     int x;
2816:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
2817:switcherator.c ****         if (inputs[x][0] == 255) {
2818:switcherator.c ****             strcat(statusMsg, "n");
2819:switcherator.c ****         } else {
2820:switcherator.c ****             strcat(statusMsg, "y");
2821:switcherator.c ****         }
2822:switcherator.c ****         // can only send 32 bytes at a time
2823:switcherator.c ****         if (strlen(statusMsg) > 30) {
2824:switcherator.c ****             sendMessage(statusMsg);
2825:switcherator.c ****             statusMsg[2] = 0;
2826:switcherator.c ****         }
2827:switcherator.c ****     }
2828:switcherator.c ****     sendMessage(statusMsg);
2829:switcherator.c **** }
2830:switcherator.c **** 
2831:switcherator.c **** // transmits Y or N for which switches are currently turned on
2832:switcherator.c **** void switchesOn(void) {
2833:switcherator.c ****     statusMsg[0] = 0;
2834:switcherator.c ****     strcat(statusMsg, "SwOn");
2835:switcherator.c ****     int x;
2836:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
2837:switcherator.c ****         if (switchStatus[x] > 0) {
2838:switcherator.c ****             strcat(statusMsg, "y");
2839:switcherator.c ****         } else {
2840:switcherator.c ****             strcat(statusMsg, "n");
2841:switcherator.c ****         }
2842:switcherator.c ****         if (strlen(statusMsg) > 30) {
2843:switcherator.c ****             sendMessage(statusMsg);
2844:switcherator.c ****             statusMsg[4] = 0;
2845:switcherator.c ****         }
2846:switcherator.c ****     }
2847:switcherator.c ****     sendMessage(statusMsg);
2848:switcherator.c **** }
2849:switcherator.c **** 
2850:switcherator.c **** void returnInt(int number, char * thisString) {
 2406               		.loc 1 2850 0
 2407               	.LVL131:
 2408 0d40 CF93      		push r28
 2409               	.LCFI66:
 2410 0d42 DF93      		push r29
 2411               	.LCFI67:
 2412               	/* prologue: function */
 2413               	/* frame size = 0 */
 2414               	/* stack size = 2 */
 2415               	.L__stack_usage = 2
 2416 0d44 EB01      		movw r28,r22
2851:switcherator.c ****     thisString[0] = 0;
 2417               		.loc 1 2851 0
 2418 0d46 1882      		st Y,__zero_reg__
2852:switcherator.c ****     itoa(number, tempHugeString, 10);
 2419               		.loc 1 2852 0
 2420 0d48 4AE0      		ldi r20,lo8(10)
 2421 0d4a 50E0      		ldi r21,0
 2422 0d4c 60E0      		ldi r22,lo8(tempHugeString)
 2423 0d4e 70E0      		ldi r23,hi8(tempHugeString)
 2424               	.LVL132:
 2425 0d50 0E94 0000 		call itoa
 2426               	.LVL133:
2853:switcherator.c ****     if (strlen(tempHugeString) == 1)
 2427               		.loc 1 2853 0
 2428 0d54 E0E0      		ldi r30,lo8(tempHugeString)
 2429 0d56 F0E0      		ldi r31,hi8(tempHugeString)
 2430               		0:
 2431 0d58 0190      		ld __tmp_reg__,Z+
 2432 0d5a 0020      		tst __tmp_reg__
 2433 0d5c 01F4      		brne 0b
 2434 0d5e E050      		subi r30,lo8(tempHugeString+2)
 2435 0d60 F040      		sbci r31,hi8(tempHugeString+2)
 2436 0d62 01F4      		brne .L188
2854:switcherator.c ****         strcat(thisString, "0");
 2437               		.loc 1 2854 0
 2438 0d64 60E0      		ldi r22,lo8(.LC1)
 2439 0d66 70E0      		ldi r23,hi8(.LC1)
 2440 0d68 CE01      		movw r24,r28
 2441 0d6a 0E94 0000 		call strcat
 2442               	.LVL134:
 2443               	.L188:
2855:switcherator.c ****     strcat(thisString, tempHugeString);
 2444               		.loc 1 2855 0
 2445 0d6e 60E0      		ldi r22,lo8(tempHugeString)
 2446 0d70 70E0      		ldi r23,hi8(tempHugeString)
 2447 0d72 CE01      		movw r24,r28
 2448               	/* epilogue start */
2856:switcherator.c **** }
 2449               		.loc 1 2856 0
 2450 0d74 DF91      		pop r29
 2451 0d76 CF91      		pop r28
 2452               	.LVL135:
2855:switcherator.c ****     strcat(thisString, tempHugeString);
 2453               		.loc 1 2855 0
 2454 0d78 0C94 0000 		jmp strcat
 2455               	.LVL136:
 2456               	.LFE67:
 2458               		.section	.rodata.str1.1
 2459               	.LC2:
 2460 0002 2000      		.string	" "
 2461               	.LC3:
 2462 0004 2F00      		.string	"/"
 2463               	.LC4:
 2464 0006 3A00      		.string	":"
 2465               		.text
 2466               	.global	clockString
 2468               	clockString:
 2469               	.LFB49:
2192:switcherator.c **** void clockString(void) {
 2470               		.loc 1 2192 0
 2471               	/* prologue: function */
 2472               	/* frame size = 0 */
 2473               	/* stack size = 0 */
 2474               	.L__stack_usage = 0
2193:switcherator.c ****     statusMsg[0] = 0;
 2475               		.loc 1 2193 0
 2476 0d7c 1092 0000 		sts statusMsg,__zero_reg__
2195:switcherator.c ****     strcat(statusMsg, " ");
 2477               		.loc 1 2195 0
 2478 0d80 60E0      		ldi r22,lo8(.LC2)
 2479 0d82 70E0      		ldi r23,hi8(.LC2)
 2480 0d84 80E0      		ldi r24,lo8(statusMsg)
 2481 0d86 90E0      		ldi r25,hi8(statusMsg)
 2482 0d88 0E94 0000 		call strcat
 2483               	.LVL137:
2196:switcherator.c ****     returnInt(globalMonth, tempIntString);
 2484               		.loc 1 2196 0
 2485 0d8c 60E0      		ldi r22,lo8(tempIntString)
 2486 0d8e 70E0      		ldi r23,hi8(tempIntString)
 2487 0d90 8091 0000 		lds r24,globalMonth
 2488 0d94 9091 0000 		lds r25,globalMonth+1
 2489 0d98 0E94 0000 		call returnInt
 2490               	.LVL138:
2197:switcherator.c ****     strcat(statusMsg, tempIntString);
 2491               		.loc 1 2197 0
 2492 0d9c 60E0      		ldi r22,lo8(tempIntString)
 2493 0d9e 70E0      		ldi r23,hi8(tempIntString)
 2494 0da0 80E0      		ldi r24,lo8(statusMsg)
 2495 0da2 90E0      		ldi r25,hi8(statusMsg)
 2496 0da4 0E94 0000 		call strcat
 2497               	.LVL139:
2198:switcherator.c ****     strcat(statusMsg, "/");
 2498               		.loc 1 2198 0
 2499 0da8 60E0      		ldi r22,lo8(.LC3)
 2500 0daa 70E0      		ldi r23,hi8(.LC3)
 2501 0dac 80E0      		ldi r24,lo8(statusMsg)
 2502 0dae 90E0      		ldi r25,hi8(statusMsg)
 2503 0db0 0E94 0000 		call strcat
 2504               	.LVL140:
2199:switcherator.c ****     returnInt(globalDay, tempIntString);
 2505               		.loc 1 2199 0
 2506 0db4 60E0      		ldi r22,lo8(tempIntString)
 2507 0db6 70E0      		ldi r23,hi8(tempIntString)
 2508 0db8 8091 0000 		lds r24,globalDay
 2509 0dbc 9091 0000 		lds r25,globalDay+1
 2510 0dc0 0E94 0000 		call returnInt
 2511               	.LVL141:
2200:switcherator.c ****     strcat(statusMsg, tempIntString);
 2512               		.loc 1 2200 0
 2513 0dc4 60E0      		ldi r22,lo8(tempIntString)
 2514 0dc6 70E0      		ldi r23,hi8(tempIntString)
 2515 0dc8 80E0      		ldi r24,lo8(statusMsg)
 2516 0dca 90E0      		ldi r25,hi8(statusMsg)
 2517 0dcc 0E94 0000 		call strcat
 2518               	.LVL142:
2201:switcherator.c ****     strcat(statusMsg, "/");
 2519               		.loc 1 2201 0
 2520 0dd0 60E0      		ldi r22,lo8(.LC3)
 2521 0dd2 70E0      		ldi r23,hi8(.LC3)
 2522 0dd4 80E0      		ldi r24,lo8(statusMsg)
 2523 0dd6 90E0      		ldi r25,hi8(statusMsg)
 2524 0dd8 0E94 0000 		call strcat
 2525               	.LVL143:
2202:switcherator.c ****     itoa(globalYear, tempIntString, 10);
 2526               		.loc 1 2202 0
 2527 0ddc 4AE0      		ldi r20,lo8(10)
 2528 0dde 50E0      		ldi r21,0
 2529 0de0 60E0      		ldi r22,lo8(tempIntString)
 2530 0de2 70E0      		ldi r23,hi8(tempIntString)
 2531 0de4 8091 0000 		lds r24,globalYear
 2532 0de8 9091 0000 		lds r25,globalYear+1
 2533 0dec 0E94 0000 		call itoa
 2534               	.LVL144:
2203:switcherator.c ****     strcat(statusMsg, tempIntString);
 2535               		.loc 1 2203 0
 2536 0df0 60E0      		ldi r22,lo8(tempIntString)
 2537 0df2 70E0      		ldi r23,hi8(tempIntString)
 2538 0df4 80E0      		ldi r24,lo8(statusMsg)
 2539 0df6 90E0      		ldi r25,hi8(statusMsg)
 2540 0df8 0E94 0000 		call strcat
 2541               	.LVL145:
2204:switcherator.c ****     strcat(statusMsg, " ");
 2542               		.loc 1 2204 0
 2543 0dfc 60E0      		ldi r22,lo8(.LC2)
 2544 0dfe 70E0      		ldi r23,hi8(.LC2)
 2545 0e00 80E0      		ldi r24,lo8(statusMsg)
 2546 0e02 90E0      		ldi r25,hi8(statusMsg)
 2547 0e04 0E94 0000 		call strcat
 2548               	.LVL146:
2205:switcherator.c ****     returnInt(globalHour, tempIntString);
 2549               		.loc 1 2205 0
 2550 0e08 60E0      		ldi r22,lo8(tempIntString)
 2551 0e0a 70E0      		ldi r23,hi8(tempIntString)
 2552 0e0c 8091 0000 		lds r24,globalHour
 2553 0e10 9091 0000 		lds r25,globalHour+1
 2554 0e14 0E94 0000 		call returnInt
 2555               	.LVL147:
2206:switcherator.c ****     strcat(statusMsg, tempIntString);
 2556               		.loc 1 2206 0
 2557 0e18 60E0      		ldi r22,lo8(tempIntString)
 2558 0e1a 70E0      		ldi r23,hi8(tempIntString)
 2559 0e1c 80E0      		ldi r24,lo8(statusMsg)
 2560 0e1e 90E0      		ldi r25,hi8(statusMsg)
 2561 0e20 0E94 0000 		call strcat
 2562               	.LVL148:
2207:switcherator.c ****     strcat(statusMsg, ":");
 2563               		.loc 1 2207 0
 2564 0e24 60E0      		ldi r22,lo8(.LC4)
 2565 0e26 70E0      		ldi r23,hi8(.LC4)
 2566 0e28 80E0      		ldi r24,lo8(statusMsg)
 2567 0e2a 90E0      		ldi r25,hi8(statusMsg)
 2568 0e2c 0E94 0000 		call strcat
 2569               	.LVL149:
2208:switcherator.c ****     returnInt(globalMinute, tempIntString);
 2570               		.loc 1 2208 0
 2571 0e30 60E0      		ldi r22,lo8(tempIntString)
 2572 0e32 70E0      		ldi r23,hi8(tempIntString)
 2573 0e34 8091 0000 		lds r24,globalMinute
 2574 0e38 9091 0000 		lds r25,globalMinute+1
 2575 0e3c 0E94 0000 		call returnInt
 2576               	.LVL150:
2209:switcherator.c ****     strcat(statusMsg, tempIntString);
 2577               		.loc 1 2209 0
 2578 0e40 60E0      		ldi r22,lo8(tempIntString)
 2579 0e42 70E0      		ldi r23,hi8(tempIntString)
 2580 0e44 80E0      		ldi r24,lo8(statusMsg)
 2581 0e46 90E0      		ldi r25,hi8(statusMsg)
 2582 0e48 0E94 0000 		call strcat
 2583               	.LVL151:
2210:switcherator.c ****     strcat(statusMsg, ":");
 2584               		.loc 1 2210 0
 2585 0e4c 60E0      		ldi r22,lo8(.LC4)
 2586 0e4e 70E0      		ldi r23,hi8(.LC4)
 2587 0e50 80E0      		ldi r24,lo8(statusMsg)
 2588 0e52 90E0      		ldi r25,hi8(statusMsg)
 2589 0e54 0E94 0000 		call strcat
 2590               	.LVL152:
2211:switcherator.c ****     returnInt(globalSecond, tempIntString);
 2591               		.loc 1 2211 0
 2592 0e58 60E0      		ldi r22,lo8(tempIntString)
 2593 0e5a 70E0      		ldi r23,hi8(tempIntString)
 2594 0e5c 8091 0000 		lds r24,globalSecond
 2595 0e60 9091 0000 		lds r25,globalSecond+1
 2596 0e64 0E94 0000 		call returnInt
 2597               	.LVL153:
2212:switcherator.c ****     strcat(statusMsg, tempIntString);
 2598               		.loc 1 2212 0
 2599 0e68 60E0      		ldi r22,lo8(tempIntString)
 2600 0e6a 70E0      		ldi r23,hi8(tempIntString)
 2601 0e6c 80E0      		ldi r24,lo8(statusMsg)
 2602 0e6e 90E0      		ldi r25,hi8(statusMsg)
 2603 0e70 0C94 0000 		jmp strcat
 2604               	.LVL154:
 2605               	.LFE49:
 2607               		.section	.rodata.str1.1
 2608               	.LC5:
 2609 0008 3078 00   		.string	"0x"
 2610               		.text
 2611               	.global	returnHex
 2613               	returnHex:
 2614               	.LFB68:
2857:switcherator.c **** 
2858:switcherator.c **** void returnHex(unsigned int number, char * thisString) {
 2615               		.loc 1 2858 0
 2616               	.LVL155:
 2617 0e74 0F93      		push r16
 2618               	.LCFI68:
 2619 0e76 1F93      		push r17
 2620               	.LCFI69:
 2621 0e78 CF93      		push r28
 2622               	.LCFI70:
 2623 0e7a DF93      		push r29
 2624               	.LCFI71:
 2625               	/* prologue: function */
 2626               	/* frame size = 0 */
 2627               	/* stack size = 4 */
 2628               	.L__stack_usage = 4
 2629 0e7c 8C01      		movw r16,r24
 2630 0e7e EB01      		movw r28,r22
2859:switcherator.c ****     thisString[0] = 0;
 2631               		.loc 1 2859 0
 2632 0e80 1882      		st Y,__zero_reg__
2860:switcherator.c ****     strcat(thisString, "0x");
 2633               		.loc 1 2860 0
 2634 0e82 60E0      		ldi r22,lo8(.LC5)
 2635 0e84 70E0      		ldi r23,hi8(.LC5)
 2636               	.LVL156:
 2637 0e86 CE01      		movw r24,r28
 2638               	.LVL157:
 2639 0e88 0E94 0000 		call strcat
 2640               	.LVL158:
2861:switcherator.c ****     itoa(number, tempHugeString, 16);
 2641               		.loc 1 2861 0
 2642 0e8c 40E1      		ldi r20,lo8(16)
 2643 0e8e 50E0      		ldi r21,0
 2644 0e90 60E0      		ldi r22,lo8(tempHugeString)
 2645 0e92 70E0      		ldi r23,hi8(tempHugeString)
 2646 0e94 C801      		movw r24,r16
 2647 0e96 0E94 0000 		call itoa
 2648               	.LVL159:
2862:switcherator.c ****     if (strlen(tempHugeString) == 1 || strlen(tempHugeString) == 3)
 2649               		.loc 1 2862 0
 2650 0e9a E0E0      		ldi r30,lo8(tempHugeString)
 2651 0e9c F0E0      		ldi r31,hi8(tempHugeString)
 2652               		0:
 2653 0e9e 0190      		ld __tmp_reg__,Z+
 2654 0ea0 0020      		tst __tmp_reg__
 2655 0ea2 01F4      		brne 0b
 2656 0ea4 3197      		sbiw r30,1
 2657 0ea6 E050      		subi r30,lo8(tempHugeString)
 2658 0ea8 F040      		sbci r31,hi8(tempHugeString)
 2659 0eaa E130      		cpi r30,1
 2660 0eac F105      		cpc r31,__zero_reg__
 2661 0eae 01F0      		breq .L191
 2662               		.loc 1 2862 0 is_stmt 0 discriminator 1
 2663 0eb0 3397      		sbiw r30,3
 2664 0eb2 01F4      		brne .L192
 2665               	.L191:
2863:switcherator.c ****         strcat(thisString, "0");
 2666               		.loc 1 2863 0 is_stmt 1
 2667 0eb4 60E0      		ldi r22,lo8(.LC1)
 2668 0eb6 70E0      		ldi r23,hi8(.LC1)
 2669 0eb8 CE01      		movw r24,r28
 2670 0eba 0E94 0000 		call strcat
 2671               	.LVL160:
 2672               	.L192:
2864:switcherator.c ****     strcat(thisString, tempHugeString);
 2673               		.loc 1 2864 0
 2674 0ebe 60E0      		ldi r22,lo8(tempHugeString)
 2675 0ec0 70E0      		ldi r23,hi8(tempHugeString)
 2676 0ec2 CE01      		movw r24,r28
 2677               	/* epilogue start */
2865:switcherator.c **** }
 2678               		.loc 1 2865 0
 2679 0ec4 DF91      		pop r29
 2680 0ec6 CF91      		pop r28
 2681               	.LVL161:
 2682 0ec8 1F91      		pop r17
 2683 0eca 0F91      		pop r16
 2684               	.LVL162:
2864:switcherator.c ****     strcat(thisString, tempHugeString);
 2685               		.loc 1 2864 0
 2686 0ecc 0C94 0000 		jmp strcat
 2687               	.LVL163:
 2688               	.LFE68:
 2690               	.global	returnHexWithout
 2692               	returnHexWithout:
 2693               	.LFB69:
2866:switcherator.c **** 
2867:switcherator.c **** 
2868:switcherator.c **** 
2869:switcherator.c **** // print hex without 0x
2870:switcherator.c **** 
2871:switcherator.c **** void returnHexWithout(unsigned int number, char * tempMe) {
 2694               		.loc 1 2871 0
 2695               	.LVL164:
 2696 0ed0 CF93      		push r28
 2697               	.LCFI72:
 2698 0ed2 DF93      		push r29
 2699               	.LCFI73:
 2700               	/* prologue: function */
 2701               	/* frame size = 0 */
 2702               	/* stack size = 2 */
 2703               	.L__stack_usage = 2
 2704 0ed4 EB01      		movw r28,r22
2872:switcherator.c ****     tempMe[0] = 0;
 2705               		.loc 1 2872 0
 2706 0ed6 1882      		st Y,__zero_reg__
2873:switcherator.c ****     itoa(number, tempHugeString, 16);
 2707               		.loc 1 2873 0
 2708 0ed8 40E1      		ldi r20,lo8(16)
 2709 0eda 50E0      		ldi r21,0
 2710 0edc 60E0      		ldi r22,lo8(tempHugeString)
 2711 0ede 70E0      		ldi r23,hi8(tempHugeString)
 2712               	.LVL165:
 2713 0ee0 0E94 0000 		call itoa
 2714               	.LVL166:
2874:switcherator.c ****     if (strlen(tempHugeString) == 1 || strlen(tempHugeString) == 3)
 2715               		.loc 1 2874 0
 2716 0ee4 E0E0      		ldi r30,lo8(tempHugeString)
 2717 0ee6 F0E0      		ldi r31,hi8(tempHugeString)
 2718               		0:
 2719 0ee8 0190      		ld __tmp_reg__,Z+
 2720 0eea 0020      		tst __tmp_reg__
 2721 0eec 01F4      		brne 0b
 2722 0eee 3197      		sbiw r30,1
 2723 0ef0 E050      		subi r30,lo8(tempHugeString)
 2724 0ef2 F040      		sbci r31,hi8(tempHugeString)
 2725 0ef4 E130      		cpi r30,1
 2726 0ef6 F105      		cpc r31,__zero_reg__
 2727 0ef8 01F0      		breq .L197
 2728               		.loc 1 2874 0 is_stmt 0 discriminator 1
 2729 0efa 3397      		sbiw r30,3
 2730 0efc 01F4      		brne .L198
 2731               	.L197:
2875:switcherator.c ****         strcat(tempMe, "0");
 2732               		.loc 1 2875 0 is_stmt 1
 2733 0efe 60E0      		ldi r22,lo8(.LC1)
 2734 0f00 70E0      		ldi r23,hi8(.LC1)
 2735 0f02 CE01      		movw r24,r28
 2736 0f04 0E94 0000 		call strcat
 2737               	.LVL167:
 2738               	.L198:
2876:switcherator.c ****     strcat(tempMe, tempHugeString);
 2739               		.loc 1 2876 0
 2740 0f08 60E0      		ldi r22,lo8(tempHugeString)
 2741 0f0a 70E0      		ldi r23,hi8(tempHugeString)
 2742 0f0c CE01      		movw r24,r28
 2743               	/* epilogue start */
2877:switcherator.c **** }
 2744               		.loc 1 2877 0
 2745 0f0e DF91      		pop r29
 2746 0f10 CF91      		pop r28
 2747               	.LVL168:
2876:switcherator.c ****     strcat(tempMe, tempHugeString);
 2748               		.loc 1 2876 0
 2749 0f12 0C94 0000 		jmp strcat
 2750               	.LVL169:
 2751               	.LFE69:
 2753               	.global	formatAddress
 2755               	formatAddress:
 2756               	.LFB72:
2878:switcherator.c **** 
2879:switcherator.c **** // Clock interrupt - fires when the compare is off
2880:switcherator.c **** 
2881:switcherator.c **** /****************************************************************
2882:switcherator.c ****  *
2883:switcherator.c ****  *              All Things Radio Related
2884:switcherator.c ****  *
2885:switcherator.c ****  ****************************************************************/
2886:switcherator.c **** 
2887:switcherator.c **** // initialize the radio
2888:switcherator.c **** 
2889:switcherator.c **** void radioInit(void) {
2890:switcherator.c ****     nrfInit();
2891:switcherator.c ****     rx_addr_p0 = SET_RX_ADDR_P0;
2892:switcherator.c ****     tx_addr = SET_TX_ADDR;
2893:switcherator.c ****     // use defaults the radio has
2894:switcherator.c ****     rx_addr_p1 = readAddr(RX_ADDR_P1);
2895:switcherator.c ****     rx_addr_p2 = readAddr(RX_ADDR_P2);
2896:switcherator.c ****     rx_addr_p3 = readAddr(RX_ADDR_P3);
2897:switcherator.c ****     rx_addr_p4 = readAddr(RX_ADDR_P4);
2898:switcherator.c ****     rx_addr_p5 = readAddr(RX_ADDR_P5);
2899:switcherator.c **** 
2900:switcherator.c ****     writeReg(RF_SETUP, SET_RF_SETUP);
2901:switcherator.c ****     writeAddr(RX_ADDR_P0, rx_addr_p0);
2902:switcherator.c ****     writeAddr(TX_ADDR, tx_addr);
2903:switcherator.c ****     writeReg(DYNPD, SET_DYNPD);
2904:switcherator.c ****     writeReg(FEATURE, SET_FEATURE);
2905:switcherator.c ****     writeReg(RF_CH, SET_RF_CH);
2906:switcherator.c ****     writeReg(CONFIG, SET_CONFIG);
2907:switcherator.c ****     writeReg(SETUP_RETR, SET_SETUP_RETR);
2908:switcherator.c **** 
2909:switcherator.c ****     // We've written the address - now see if we get the same result
2910:switcherator.c ****     radioTest();
2911:switcherator.c ****     
2912:switcherator.c ****     startRadio();
2913:switcherator.c **** 
2914:switcherator.c **** }
2915:switcherator.c **** 
2916:switcherator.c **** // radio test - just make sure it is still working
2917:switcherator.c **** int radioTest(void) {
2918:switcherator.c ****     uint64_t test_addr;
2919:switcherator.c ****     test_addr = readAddr(RX_ADDR_P0);    
2920:switcherator.c ****     if (test_addr != rx_addr_p0) {
2921:switcherator.c ****         // nope.  broken
2922:switcherator.c ****         failCondition = 1;
2923:switcherator.c ****         return -1;
2924:switcherator.c ****     }
2925:switcherator.c ****     if(failCondition == 1 || failCondition == 2)
2926:switcherator.c ****         clearFail();
2927:switcherator.c ****     return 1;
2928:switcherator.c **** }
2929:switcherator.c **** 
2930:switcherator.c **** // Take in an address and return a long long with the number
2931:switcherator.c **** 
2932:switcherator.c **** uint64_t formatAddress(char * address) {
 2757               		.loc 1 2932 0
 2758               	.LVL170:
 2759 0f16 0F93      		push r16
 2760               	.LCFI74:
 2761 0f18 CF93      		push r28
 2762               	.LCFI75:
 2763               	/* prologue: function */
 2764               	/* frame size = 0 */
 2765               	/* stack size = 2 */
 2766               	.L__stack_usage = 2
 2767               	.LVL171:
 2768 0f1a DC01      		movw r26,r24
2933:switcherator.c ****     int x = 0;
2934:switcherator.c ****     uint64_t newAddress = 0;
 2769               		.loc 1 2934 0
 2770 0f1c 20E0      		ldi r18,0
 2771 0f1e 30E0      		ldi r19,0
 2772 0f20 40E0      		ldi r20,0
 2773 0f22 50E0      		ldi r21,0
 2774 0f24 60E0      		ldi r22,0
 2775 0f26 70E0      		ldi r23,0
 2776 0f28 80E0      		ldi r24,0
 2777               	.LVL172:
 2778 0f2a 90E0      		ldi r25,0
2935:switcherator.c ****     int tempInt;
2936:switcherator.c ****     for (x = 0; x < 5; x++) {
 2779               		.loc 1 2936 0
 2780 0f2c E0E0      		ldi r30,0
 2781 0f2e F0E0      		ldi r31,0
 2782               	.LVL173:
 2783               	.L205:
2937:switcherator.c ****         tempInt = address[x];
 2784               		.loc 1 2937 0
 2785 0f30 CD91      		ld r28,X+
 2786               	.LVL174:
 2787 0f32 C22B      		or r28,r18
 2788               	.LVL175:
2938:switcherator.c ****         if (x < 4) {
2939:switcherator.c ****             newAddress |= (tempInt);
2940:switcherator.c ****             newAddress <<= 8;
 2789               		.loc 1 2940 0
 2790 0f34 2C2F      		mov r18,r28
2938:switcherator.c ****         if (x < 4) {
 2791               		.loc 1 2938 0
 2792 0f36 E430      		cpi r30,4
 2793 0f38 F105      		cpc r31,__zero_reg__
 2794 0f3a 01F0      		breq .L204
 2795               		.loc 1 2940 0
 2796 0f3c 08E0      		ldi r16,lo8(8)
 2797 0f3e 0E94 0000 		call __ashldi3
 2798               	.LVL176:
 2799               	.L204:
2936:switcherator.c ****     for (x = 0; x < 5; x++) {
 2800               		.loc 1 2936 0
 2801 0f42 3196      		adiw r30,1
 2802               	.LVL177:
 2803 0f44 E530      		cpi r30,5
 2804 0f46 F105      		cpc r31,__zero_reg__
 2805 0f48 01F4      		brne .L205
 2806               	/* epilogue start */
2941:switcherator.c ****         } else
2942:switcherator.c ****             newAddress |= tempInt;
2943:switcherator.c ****     }
2944:switcherator.c ****     return newAddress;
2945:switcherator.c **** }
 2807               		.loc 1 2945 0
 2808 0f4a CF91      		pop r28
 2809 0f4c 0F91      		pop r16
 2810 0f4e 0895      		ret
 2811               	.LFE72:
 2813               	.global	generalInit
 2815               	generalInit:
 2816               	.LFB41:
1711:switcherator.c **** void generalInit(void) {
 2817               		.loc 1 1711 0
 2818 0f50 EF92      		push r14
 2819               	.LCFI76:
 2820 0f52 FF92      		push r15
 2821               	.LCFI77:
 2822 0f54 0F93      		push r16
 2823               	.LCFI78:
 2824 0f56 1F93      		push r17
 2825               	.LCFI79:
 2826 0f58 CF93      		push r28
 2827               	.LCFI80:
 2828 0f5a DF93      		push r29
 2829               	.LCFI81:
 2830 0f5c CDB7      		in r28,__SP_L__
 2831 0f5e DEB7      		in r29,__SP_H__
 2832               	.LCFI82:
 2833 0f60 2E97      		sbiw r28,14
 2834               	.LCFI83:
 2835 0f62 0FB6      		in __tmp_reg__,__SREG__
 2836 0f64 F894      		cli
 2837 0f66 DEBF      		out __SP_H__,r29
 2838 0f68 0FBE      		out __SREG__,__tmp_reg__
 2839 0f6a CDBF      		out __SP_L__,r28
 2840               	/* prologue: function */
 2841               	/* frame size = 14 */
 2842               	/* stack size = 20 */
 2843               	.L__stack_usage = 20
 2844               	.LVL178:
1717:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_TX, RADIO_ADDR_TX_BYTES) == 1) {
 2845               		.loc 1 1717 0
 2846 0f6c 47E0      		ldi r20,lo8(7)
 2847 0f6e 50E0      		ldi r21,0
 2848 0f70 6EE0      		ldi r22,lo8(14)
 2849 0f72 70E0      		ldi r23,0
 2850 0f74 CE01      		movw r24,r28
 2851 0f76 0196      		adiw r24,1
 2852 0f78 0E94 0000 		call readEEPROM
 2853               	.LVL179:
 2854 0f7c 0197      		sbiw r24,1
 2855 0f7e 01F4      		brne .L208
1718:switcherator.c ****         tx_addr = formatAddress(tempStuff);
 2856               		.loc 1 1718 0
 2857 0f80 CE01      		movw r24,r28
 2858 0f82 0196      		adiw r24,1
 2859 0f84 0E94 0000 		call formatAddress
 2860               	.LVL180:
 2861 0f88 2093 0000 		sts tx_addr,r18
 2862 0f8c 3093 0000 		sts tx_addr+1,r19
 2863 0f90 4093 0000 		sts tx_addr+2,r20
 2864 0f94 5093 0000 		sts tx_addr+3,r21
 2865 0f98 6093 0000 		sts tx_addr+4,r22
 2866 0f9c 7093 0000 		sts tx_addr+5,r23
 2867 0fa0 8093 0000 		sts tx_addr+6,r24
 2868 0fa4 9093 0000 		sts tx_addr+7,r25
1719:switcherator.c ****         writeAddr(TX_ADDR, tx_addr);
 2869               		.loc 1 1719 0
 2870 0fa8 8901      		movw r16,r18
 2871 0faa 9A01      		movw r18,r20
 2872 0fac AB01      		movw r20,r22
 2873 0fae BC01      		movw r22,r24
 2874 0fb0 80E1      		ldi r24,lo8(16)
 2875 0fb2 0E94 0000 		call writeAddr
 2876               	.LVL181:
 2877               	.L208:
1721:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R0, RADIO_ADDR_R0_BYTES) == 1) {
 2878               		.loc 1 1721 0
 2879 0fb6 47E0      		ldi r20,lo8(7)
 2880 0fb8 50E0      		ldi r21,0
 2881 0fba 65E1      		ldi r22,lo8(21)
 2882 0fbc 70E0      		ldi r23,0
 2883 0fbe CE01      		movw r24,r28
 2884 0fc0 0196      		adiw r24,1
 2885 0fc2 0E94 0000 		call readEEPROM
 2886               	.LVL182:
 2887 0fc6 0197      		sbiw r24,1
 2888 0fc8 01F4      		brne .L209
1722:switcherator.c ****         rx_addr_p0 = formatAddress(tempStuff);
 2889               		.loc 1 1722 0
 2890 0fca CE01      		movw r24,r28
 2891 0fcc 0196      		adiw r24,1
 2892 0fce 0E94 0000 		call formatAddress
 2893               	.LVL183:
 2894 0fd2 2093 0000 		sts rx_addr_p0,r18
 2895 0fd6 3093 0000 		sts rx_addr_p0+1,r19
 2896 0fda 4093 0000 		sts rx_addr_p0+2,r20
 2897 0fde 5093 0000 		sts rx_addr_p0+3,r21
 2898 0fe2 6093 0000 		sts rx_addr_p0+4,r22
 2899 0fe6 7093 0000 		sts rx_addr_p0+5,r23
 2900 0fea 8093 0000 		sts rx_addr_p0+6,r24
 2901 0fee 9093 0000 		sts rx_addr_p0+7,r25
1723:switcherator.c ****         writeAddr(RX_ADDR_P0, rx_addr_p0);
 2902               		.loc 1 1723 0
 2903 0ff2 8901      		movw r16,r18
 2904 0ff4 9A01      		movw r18,r20
 2905 0ff6 AB01      		movw r20,r22
 2906 0ff8 BC01      		movw r22,r24
 2907 0ffa 8AE0      		ldi r24,lo8(10)
 2908 0ffc 0E94 0000 		call writeAddr
 2909               	.LVL184:
 2910               	.L209:
1726:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R1, RADIO_ADDR_R1_BYTES) == 1) {
 2911               		.loc 1 1726 0
 2912 1000 47E0      		ldi r20,lo8(7)
 2913 1002 50E0      		ldi r21,0
 2914 1004 6CE1      		ldi r22,lo8(28)
 2915 1006 70E0      		ldi r23,0
 2916 1008 CE01      		movw r24,r28
 2917 100a 0196      		adiw r24,1
 2918 100c 0E94 0000 		call readEEPROM
 2919               	.LVL185:
 2920 1010 0197      		sbiw r24,1
 2921 1012 01F4      		brne .L210
1727:switcherator.c ****         rx_addr_p1 = formatAddress(tempStuff);
 2922               		.loc 1 1727 0
 2923 1014 CE01      		movw r24,r28
 2924 1016 0196      		adiw r24,1
 2925 1018 0E94 0000 		call formatAddress
 2926               	.LVL186:
 2927 101c 2093 0000 		sts rx_addr_p1,r18
 2928 1020 3093 0000 		sts rx_addr_p1+1,r19
 2929 1024 4093 0000 		sts rx_addr_p1+2,r20
 2930 1028 5093 0000 		sts rx_addr_p1+3,r21
 2931 102c 6093 0000 		sts rx_addr_p1+4,r22
 2932 1030 7093 0000 		sts rx_addr_p1+5,r23
 2933 1034 8093 0000 		sts rx_addr_p1+6,r24
 2934 1038 9093 0000 		sts rx_addr_p1+7,r25
1728:switcherator.c ****         writeAddr(RX_ADDR_P1, rx_addr_p1);
 2935               		.loc 1 1728 0
 2936 103c 8901      		movw r16,r18
 2937 103e 9A01      		movw r18,r20
 2938 1040 AB01      		movw r20,r22
 2939 1042 BC01      		movw r22,r24
 2940 1044 8BE0      		ldi r24,lo8(11)
 2941 1046 0E94 0000 		call writeAddr
 2942               	.LVL187:
 2943               	.L210:
1730:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R2, RADIO_ADDR_R2_BYTES) == 1) {
 2944               		.loc 1 1730 0
 2945 104a 43E0      		ldi r20,lo8(3)
 2946 104c 50E0      		ldi r21,0
 2947 104e 63E2      		ldi r22,lo8(35)
 2948 1050 70E0      		ldi r23,0
 2949 1052 CE01      		movw r24,r28
 2950 1054 0196      		adiw r24,1
 2951 1056 0E94 0000 		call readEEPROM
 2952               	.LVL188:
 2953 105a 0197      		sbiw r24,1
 2954 105c 01F4      		brne .L211
1731:switcherator.c ****         rx_addr_p2 = tempStuff[0];
 2955               		.loc 1 1731 0
 2956 105e 0981      		ldd r16,Y+1
 2957 1060 0093 0000 		sts rx_addr_p2,r16
 2958 1064 1092 0000 		sts rx_addr_p2+1,__zero_reg__
 2959 1068 1092 0000 		sts rx_addr_p2+2,__zero_reg__
 2960 106c 1092 0000 		sts rx_addr_p2+3,__zero_reg__
 2961 1070 1092 0000 		sts rx_addr_p2+4,__zero_reg__
 2962 1074 1092 0000 		sts rx_addr_p2+5,__zero_reg__
 2963 1078 1092 0000 		sts rx_addr_p2+6,__zero_reg__
 2964 107c 1092 0000 		sts rx_addr_p2+7,__zero_reg__
1732:switcherator.c ****         writeAddr(RX_ADDR_P2, rx_addr_p2);
 2965               		.loc 1 1732 0
 2966 1080 10E0      		ldi r17,0
 2967 1082 20E0      		ldi r18,0
 2968 1084 30E0      		ldi r19,0
 2969 1086 40E0      		ldi r20,0
 2970 1088 50E0      		ldi r21,0
 2971 108a 60E0      		ldi r22,0
 2972 108c 70E0      		ldi r23,0
 2973 108e 8CE0      		ldi r24,lo8(12)
 2974 1090 0E94 0000 		call writeAddr
 2975               	.LVL189:
 2976               	.L211:
1734:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R3, RADIO_ADDR_R3_BYTES) == 1) {
 2977               		.loc 1 1734 0
 2978 1094 43E0      		ldi r20,lo8(3)
 2979 1096 50E0      		ldi r21,0
 2980 1098 66E2      		ldi r22,lo8(38)
 2981 109a 70E0      		ldi r23,0
 2982 109c CE01      		movw r24,r28
 2983 109e 0196      		adiw r24,1
 2984 10a0 0E94 0000 		call readEEPROM
 2985               	.LVL190:
 2986 10a4 0197      		sbiw r24,1
 2987 10a6 01F4      		brne .L212
1735:switcherator.c ****         rx_addr_p3 = tempStuff[0];
 2988               		.loc 1 1735 0
 2989 10a8 0981      		ldd r16,Y+1
 2990 10aa 0093 0000 		sts rx_addr_p3,r16
 2991 10ae 1092 0000 		sts rx_addr_p3+1,__zero_reg__
 2992 10b2 1092 0000 		sts rx_addr_p3+2,__zero_reg__
 2993 10b6 1092 0000 		sts rx_addr_p3+3,__zero_reg__
 2994 10ba 1092 0000 		sts rx_addr_p3+4,__zero_reg__
 2995 10be 1092 0000 		sts rx_addr_p3+5,__zero_reg__
 2996 10c2 1092 0000 		sts rx_addr_p3+6,__zero_reg__
 2997 10c6 1092 0000 		sts rx_addr_p3+7,__zero_reg__
1736:switcherator.c ****         writeAddr(RX_ADDR_P3, rx_addr_p3);
 2998               		.loc 1 1736 0
 2999 10ca 10E0      		ldi r17,0
 3000 10cc 20E0      		ldi r18,0
 3001 10ce 30E0      		ldi r19,0
 3002 10d0 40E0      		ldi r20,0
 3003 10d2 50E0      		ldi r21,0
 3004 10d4 60E0      		ldi r22,0
 3005 10d6 70E0      		ldi r23,0
 3006 10d8 8DE0      		ldi r24,lo8(13)
 3007 10da 0E94 0000 		call writeAddr
 3008               	.LVL191:
 3009               	.L212:
1738:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R4, RADIO_ADDR_R4_BYTES) == 1) {
 3010               		.loc 1 1738 0
 3011 10de 43E0      		ldi r20,lo8(3)
 3012 10e0 50E0      		ldi r21,0
 3013 10e2 69E2      		ldi r22,lo8(41)
 3014 10e4 70E0      		ldi r23,0
 3015 10e6 CE01      		movw r24,r28
 3016 10e8 0196      		adiw r24,1
 3017 10ea 0E94 0000 		call readEEPROM
 3018               	.LVL192:
 3019 10ee 0197      		sbiw r24,1
 3020 10f0 01F4      		brne .L213
1739:switcherator.c ****         rx_addr_p4 = tempStuff[0];
 3021               		.loc 1 1739 0
 3022 10f2 0981      		ldd r16,Y+1
 3023 10f4 0093 0000 		sts rx_addr_p4,r16
 3024 10f8 1092 0000 		sts rx_addr_p4+1,__zero_reg__
 3025 10fc 1092 0000 		sts rx_addr_p4+2,__zero_reg__
 3026 1100 1092 0000 		sts rx_addr_p4+3,__zero_reg__
 3027 1104 1092 0000 		sts rx_addr_p4+4,__zero_reg__
 3028 1108 1092 0000 		sts rx_addr_p4+5,__zero_reg__
 3029 110c 1092 0000 		sts rx_addr_p4+6,__zero_reg__
 3030 1110 1092 0000 		sts rx_addr_p4+7,__zero_reg__
1740:switcherator.c ****         writeAddr(RX_ADDR_P4, rx_addr_p4);
 3031               		.loc 1 1740 0
 3032 1114 10E0      		ldi r17,0
 3033 1116 20E0      		ldi r18,0
 3034 1118 30E0      		ldi r19,0
 3035 111a 40E0      		ldi r20,0
 3036 111c 50E0      		ldi r21,0
 3037 111e 60E0      		ldi r22,0
 3038 1120 70E0      		ldi r23,0
 3039 1122 8EE0      		ldi r24,lo8(14)
 3040 1124 0E94 0000 		call writeAddr
 3041               	.LVL193:
 3042               	.L213:
1742:switcherator.c ****     if (readEEPROM(tempStuff, RADIO_ADDR_R5, RADIO_ADDR_R5_BYTES) == 1) {
 3043               		.loc 1 1742 0
 3044 1128 43E0      		ldi r20,lo8(3)
 3045 112a 50E0      		ldi r21,0
 3046 112c 6CE2      		ldi r22,lo8(44)
 3047 112e 70E0      		ldi r23,0
 3048 1130 CE01      		movw r24,r28
 3049 1132 0196      		adiw r24,1
 3050 1134 0E94 0000 		call readEEPROM
 3051               	.LVL194:
 3052 1138 0197      		sbiw r24,1
 3053 113a 01F4      		brne .L214
1743:switcherator.c ****         rx_addr_p5 = tempStuff[0];
 3054               		.loc 1 1743 0
 3055 113c 0981      		ldd r16,Y+1
 3056 113e 0093 0000 		sts rx_addr_p5,r16
 3057 1142 1092 0000 		sts rx_addr_p5+1,__zero_reg__
 3058 1146 1092 0000 		sts rx_addr_p5+2,__zero_reg__
 3059 114a 1092 0000 		sts rx_addr_p5+3,__zero_reg__
 3060 114e 1092 0000 		sts rx_addr_p5+4,__zero_reg__
 3061 1152 1092 0000 		sts rx_addr_p5+5,__zero_reg__
 3062 1156 1092 0000 		sts rx_addr_p5+6,__zero_reg__
 3063 115a 1092 0000 		sts rx_addr_p5+7,__zero_reg__
1744:switcherator.c ****         writeAddr(RX_ADDR_P5, rx_addr_p5);
 3064               		.loc 1 1744 0
 3065 115e 10E0      		ldi r17,0
 3066 1160 20E0      		ldi r18,0
 3067 1162 30E0      		ldi r19,0
 3068 1164 40E0      		ldi r20,0
 3069 1166 50E0      		ldi r21,0
 3070 1168 60E0      		ldi r22,0
 3071 116a 70E0      		ldi r23,0
 3072 116c 8FE0      		ldi r24,lo8(15)
 3073 116e 0E94 0000 		call writeAddr
 3074               	.LVL195:
 3075               	.L214:
1746:switcherator.c ****     if (readEEPROM(tempStuff, TWEAK_TIMER, TWEAK_TIMER_BYTES) == 1) {
 3076               		.loc 1 1746 0
 3077 1172 44E0      		ldi r20,lo8(4)
 3078 1174 50E0      		ldi r21,0
 3079 1176 69E1      		ldi r22,lo8(25)
 3080 1178 71E0      		ldi r23,lo8(1)
 3081 117a CE01      		movw r24,r28
 3082 117c 0196      		adiw r24,1
 3083 117e 0E94 0000 		call readEEPROM
 3084               	.LVL196:
 3085 1182 0197      		sbiw r24,1
 3086 1184 01F4      		brne .L215
1747:switcherator.c ****         tweakTimer = tempStuff[0];
 3087               		.loc 1 1747 0
 3088 1186 8981      		ldd r24,Y+1
 3089 1188 90E0      		ldi r25,0
 3090 118a A0E0      		ldi r26,0
 3091 118c B0E0      		ldi r27,0
1748:switcherator.c ****         tweakTimer <<= 8;
 3092               		.loc 1 1748 0
 3093 118e BA2F      		mov r27,r26
 3094 1190 A92F      		mov r26,r25
 3095 1192 982F      		mov r25,r24
 3096 1194 8827      		clr r24
1749:switcherator.c ****         tweakTimer |= tempStuff[1];
 3097               		.loc 1 1749 0
 3098 1196 2A81      		ldd r18,Y+2
 3099 1198 822B      		or r24,r18
 3100 119a 8093 0000 		sts tweakTimer,r24
 3101 119e 9093 0000 		sts tweakTimer+1,r25
 3102 11a2 A093 0000 		sts tweakTimer+2,r26
 3103 11a6 B093 0000 		sts tweakTimer+3,r27
 3104               	.L215:
1754:switcherator.c ****     if (readEEPROM(tempStuff, DAYLIGHT_SAVE, DAYLIGHT_SAVE_BYTES) == 1) {
 3105               		.loc 1 1754 0
 3106 11aa 4AE0      		ldi r20,lo8(10)
 3107 11ac 50E0      		ldi r21,0
 3108 11ae 66E0      		ldi r22,lo8(6)
 3109 11b0 70E0      		ldi r23,0
 3110 11b2 CE01      		movw r24,r28
 3111 11b4 0196      		adiw r24,1
 3112 11b6 0E94 0000 		call readEEPROM
 3113               	.LVL197:
 3114 11ba 0197      		sbiw r24,1
 3115 11bc 01F4      		brne .L216
1756:switcherator.c ****         daylightSavings[0][0] = ((tempStuff[0] << 8) | (tempStuff[1]));
 3116               		.loc 1 1756 0
 3117 11be 9981      		ldd r25,Y+1
 3118 11c0 80E0      		ldi r24,0
 3119 11c2 2A81      		ldd r18,Y+2
 3120 11c4 822B      		or r24,r18
 3121 11c6 9093 0000 		sts daylightSavings+1,r25
 3122 11ca 8093 0000 		sts daylightSavings,r24
1758:switcherator.c ****         daylightSavings[0][1] = ((tempStuff[2] << 8) | (tempStuff[3]));
 3123               		.loc 1 1758 0
 3124 11ce 9B81      		ldd r25,Y+3
 3125 11d0 80E0      		ldi r24,0
 3126 11d2 2C81      		ldd r18,Y+4
 3127 11d4 822B      		or r24,r18
 3128 11d6 9093 0000 		sts daylightSavings+2+1,r25
 3129 11da 8093 0000 		sts daylightSavings+2,r24
1760:switcherator.c ****         daylightSavings[1][0] = ((tempStuff[4] << 8) | (tempStuff[5]));
 3130               		.loc 1 1760 0
 3131 11de 9D81      		ldd r25,Y+5
 3132 11e0 80E0      		ldi r24,0
 3133 11e2 2E81      		ldd r18,Y+6
 3134 11e4 822B      		or r24,r18
 3135 11e6 9093 0000 		sts daylightSavings+4+1,r25
 3136 11ea 8093 0000 		sts daylightSavings+4,r24
1762:switcherator.c ****         daylightSavings[1][1] = ((tempStuff[6] << 8) | (tempStuff[7]));
 3137               		.loc 1 1762 0
 3138 11ee 9F81      		ldd r25,Y+7
 3139 11f0 80E0      		ldi r24,0
 3140 11f2 2885      		ldd r18,Y+8
 3141 11f4 822B      		or r24,r18
 3142 11f6 9093 0000 		sts daylightSavings+6+1,r25
 3143 11fa 8093 0000 		sts daylightSavings+6,r24
 3144               	.L216:
1765:switcherator.c ****     if (readEEPROM(tempStuff, SERIAL_NUM, SERIAL_NUM_BYTES) == 1) {
 3145               		.loc 1 1765 0
 3146 11fe 48E0      		ldi r20,lo8(8)
 3147 1200 50E0      		ldi r21,0
 3148 1202 60E0      		ldi r22,0
 3149 1204 70E0      		ldi r23,0
 3150 1206 CE01      		movw r24,r28
 3151 1208 0196      		adiw r24,1
 3152 120a 0E94 0000 		call readEEPROM
 3153               	.LVL198:
 3154 120e 0197      		sbiw r24,1
 3155 1210 01F4      		brne .L217
1766:switcherator.c ****         serial = atol(tempStuff);
 3156               		.loc 1 1766 0
 3157 1212 CE01      		movw r24,r28
 3158 1214 0196      		adiw r24,1
 3159 1216 0E94 0000 		call atol
 3160               	.LVL199:
 3161 121a 6093 0000 		sts serial,r22
 3162 121e 7093 0000 		sts serial+1,r23
 3163 1222 8093 0000 		sts serial+2,r24
 3164 1226 9093 0000 		sts serial+3,r25
1767:switcherator.c ****         ltoa(serial, stringSerial, 10);
 3165               		.loc 1 1767 0
 3166 122a 2AE0      		ldi r18,lo8(10)
 3167 122c 30E0      		ldi r19,0
 3168 122e 40E0      		ldi r20,lo8(stringSerial)
 3169 1230 50E0      		ldi r21,hi8(stringSerial)
 3170 1232 0E94 0000 		call ltoa
 3171               	.LVL200:
 3172               	.L217:
1771:switcherator.c ****     if (readEEPROM(switchStuff, SWITCH_STUFF, SWITCH_STUFF_BYTES) == 1) {
 3173               		.loc 1 1771 0
 3174 1236 42E1      		ldi r20,lo8(18)
 3175 1238 50E0      		ldi r21,0
 3176 123a 60E3      		ldi r22,lo8(48)
 3177 123c 70E0      		ldi r23,0
 3178 123e 80E0      		ldi r24,lo8(switchStuff)
 3179 1240 90E0      		ldi r25,hi8(switchStuff)
 3180 1242 0E94 0000 		call readEEPROM
 3181               	.LVL201:
 3182 1246 0197      		sbiw r24,1
 3183 1248 01F0      		breq .+2
 3184 124a 00C0      		rjmp .L218
 3185               	.LBB22:
1772:switcherator.c ****         readEEPROM(switchBright, BRIGHTNESS, BRIGHTNESS_BYTES);
 3186               		.loc 1 1772 0
 3187 124c 42E1      		ldi r20,lo8(18)
 3188 124e 50E0      		ldi r21,0
 3189 1250 60E2      		ldi r22,lo8(32)
 3190 1252 71E0      		ldi r23,lo8(1)
 3191 1254 80E0      		ldi r24,lo8(switchBright)
 3192 1256 90E0      		ldi r25,hi8(switchBright)
 3193 1258 0E94 0000 		call readEEPROM
 3194               	.LVL202:
 3195 125c 80E0      		ldi r24,lo8(switchStuff)
 3196 125e 90E0      		ldi r25,hi8(switchStuff)
1839:switcherator.c ****             *realDDR |= (1 << realPin);
 3197               		.loc 1 1839 0
 3198 1260 41E0      		ldi r20,lo8(1)
 3199 1262 50E0      		ldi r21,0
 3200               	.LVL203:
 3201               	.L223:
1781:switcherator.c ****             temp = switchStuff[x];
 3202               		.loc 1 1781 0
 3203 1264 FC01      		movw r30,r24
 3204 1266 2191      		ld r18,Z+
 3205 1268 CF01      		movw r24,r30
 3206               	.LVL204:
1782:switcherator.c ****             if (temp > 15 && temp < 32) {
 3207               		.loc 1 1782 0
 3208 126a 622F      		mov r22,r18
 3209 126c 6051      		subi r22,lo8(-(-16))
 3210 126e 6031      		cpi r22,lo8(16)
 3211 1270 00F0      		brlo .L244
1793:switcherator.c ****             } else if (temp < 48) {
 3212               		.loc 1 1793 0
 3213 1272 2033      		cpi r18,lo8(48)
 3214 1274 00F4      		brsh .L220
 3215               	.LVL205:
1796:switcherator.c ****                 temp -= 32;
 3216               		.loc 1 1796 0
 3217 1276 6051      		subi r22,lo8(-(-16))
 3218               	.LVL206:
1795:switcherator.c ****                 realDDR = &DDRC;
 3219               		.loc 1 1795 0
 3220 1278 A7E2      		ldi r26,lo8(39)
 3221 127a B0E0      		ldi r27,0
1794:switcherator.c ****                 realPort = &PORTC;
 3222               		.loc 1 1794 0
 3223 127c E8E2      		ldi r30,lo8(40)
 3224 127e F0E0      		ldi r31,0
 3225 1280 00C0      		rjmp .L219
 3226               	.LVL207:
 3227               	.L220:
1799:switcherator.c ****             } else if (temp < 64) {
 3228               		.loc 1 1799 0
 3229 1282 2034      		cpi r18,lo8(64)
 3230 1284 00F4      		brsh .L221
 3231               	.LVL208:
1802:switcherator.c ****                 temp -= 48;
 3232               		.loc 1 1802 0
 3233 1286 622F      		mov r22,r18
 3234 1288 6053      		subi r22,lo8(-(-48))
 3235               	.LVL209:
1801:switcherator.c ****                 realDDR = &DDRD;
 3236               		.loc 1 1801 0
 3237 128a AAE2      		ldi r26,lo8(42)
 3238 128c B0E0      		ldi r27,0
1800:switcherator.c ****                 realPort = &PORTD;
 3239               		.loc 1 1800 0
 3240 128e EBE2      		ldi r30,lo8(43)
 3241 1290 F0E0      		ldi r31,0
 3242 1292 00C0      		rjmp .L219
 3243               	.LVL210:
 3244               	.L244:
1784:switcherator.c ****                 realDDR = &DDRB;
 3245               		.loc 1 1784 0
 3246 1294 A4E2      		ldi r26,lo8(36)
 3247 1296 B0E0      		ldi r27,0
1783:switcherator.c ****                 realPort = &PORTB;
 3248               		.loc 1 1783 0
 3249 1298 E5E2      		ldi r30,lo8(37)
 3250 129a F0E0      		ldi r31,0
 3251               	.LVL211:
 3252               	.L219:
1839:switcherator.c ****             *realDDR |= (1 << realPin);
 3253               		.loc 1 1839 0
 3254 129c 7C91      		ld r23,X
1838:switcherator.c ****             realPin = (temp / 2);
 3255               		.loc 1 1838 0
 3256 129e 262F      		mov r18,r22
 3257 12a0 2695      		lsr r18
 3258               	.LVL212:
1839:switcherator.c ****             *realDDR |= (1 << realPin);
 3259               		.loc 1 1839 0
 3260 12a2 8A01      		movw r16,r20
 3261 12a4 00C0      		rjmp 2f
 3262               		1:
 3263 12a6 000F      		lsl r16
 3264 12a8 111F      		rol r17
 3265               		2:
 3266 12aa 2A95      		dec r18
 3267 12ac 02F4      		brpl 1b
 3268 12ae 9801      		movw r18,r16
 3269               	.LVL213:
 3270 12b0 702B      		or r23,r16
 3271 12b2 7C93      		st X,r23
1841:switcherator.c ****             if (temp % 2 == 0) {
 3272               		.loc 1 1841 0
 3273 12b4 60FD      		sbrc r22,0
 3274 12b6 00C0      		rjmp .L222
1843:switcherator.c ****                 *realPort |= (1 << realPin);
 3275               		.loc 1 1843 0
 3276 12b8 2081      		ld r18,Z
 3277 12ba 202B      		or r18,r16
 3278 12bc 00C0      		rjmp .L255
 3279               	.L222:
1845:switcherator.c ****                 *realPort &= ~(1 << realPin);
 3280               		.loc 1 1845 0
 3281 12be 3081      		ld r19,Z
 3282 12c0 2095      		com r18
 3283 12c2 2323      		and r18,r19
 3284               	.L255:
 3285 12c4 2083      		st Z,r18
 3286               	.LVL214:
 3287               	.L221:
1780:switcherator.c ****         for (x = 0; x < NUM_SWITCHES; x++) {
 3288               		.loc 1 1780 0
 3289 12c6 10E0      		ldi r17,hi8(switchStuff+16)
 3290 12c8 8030      		cpi r24,lo8(switchStuff+16)
 3291 12ca 9107      		cpc r25,r17
 3292 12cc 01F4      		brne .L223
 3293               	.L226:
 3294               	.LVL215:
 3295 12ce 40E0      		ldi r20,lo8(weeklyProgram)
 3296 12d0 E42E      		mov r14,r20
 3297 12d2 40E0      		ldi r20,hi8(weeklyProgram)
 3298 12d4 F42E      		mov r15,r20
1800:switcherator.c ****                 realPort = &PORTD;
 3299               		.loc 1 1800 0
 3300 12d6 01EA      		ldi r16,lo8(-95)
 3301 12d8 10E0      		ldi r17,0
 3302 12da 00C0      		rjmp .L224
 3303               	.L218:
 3304 12dc E0E0      		ldi r30,lo8(switchStuff)
 3305 12de F0E0      		ldi r31,hi8(switchStuff)
 3306               	.LBE22:
1850:switcherator.c ****             switchStuff[x] = 255;
 3307               		.loc 1 1850 0
 3308 12e0 8FEF      		ldi r24,lo8(-1)
 3309               	.LVL216:
 3310               	.L225:
1850:switcherator.c ****             switchStuff[x] = 255;
 3311               		.loc 1 1850 0 is_stmt 0 discriminator 2
 3312 12e2 8193      		st Z+,r24
1849:switcherator.c ****         for (x = 0; x < NUM_SWITCHES; x++)
 3313               		.loc 1 1849 0 is_stmt 1 discriminator 2
 3314 12e4 20E0      		ldi r18,hi8(switchStuff+16)
 3315 12e6 E030      		cpi r30,lo8(switchStuff+16)
 3316 12e8 F207      		cpc r31,r18
 3317 12ea 01F4      		brne .L225
 3318 12ec 00C0      		rjmp .L226
 3319               	.L224:
 3320               	.LVL217:
1858:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, WEEKLY_PROGRAM_BYTES) == 1) {
 3321               		.loc 1 1858 0
 3322 12ee 4CE0      		ldi r20,lo8(12)
 3323 12f0 50E0      		ldi r21,0
 3324 12f2 B801      		movw r22,r16
 3325 12f4 CE01      		movw r24,r28
 3326 12f6 0196      		adiw r24,1
 3327 12f8 0E94 0000 		call readEEPROM
 3328               	.LVL218:
 3329 12fc 0197      		sbiw r24,1
 3330 12fe 01F0      		breq .L227
 3331               	.L230:
 3332 1300 045F      		subi r16,-12
 3333 1302 1F4F      		sbci r17,-1
 3334               	.LVL219:
 3335 1304 8AE0      		ldi r24,10
 3336 1306 E80E      		add r14,r24
 3337 1308 F11C      		adc r15,__zero_reg__
1856:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 3338               		.loc 1 1856 0
 3339 130a 0931      		cpi r16,25
 3340 130c 91E0      		ldi r25,1
 3341 130e 1907      		cpc r17,r25
 3342 1310 01F4      		brne .L224
 3343 1312 00C0      		rjmp .L253
 3344               	.LVL220:
 3345               	.L227:
 3346 1314 FE01      		movw r30,r28
 3347 1316 3196      		adiw r30,1
1858:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, WEEKLY_PROGRAM_BYTES) == 1) {
 3348               		.loc 1 1858 0
 3349 1318 80E0      		ldi r24,0
 3350 131a 90E0      		ldi r25,0
 3351               	.L229:
1860:switcherator.c ****                 weeklyProgram[x][y] = tempStuff[y];
 3352               		.loc 1 1860 0 discriminator 2
 3353 131c 2191      		ld r18,Z+
1711:switcherator.c **** void generalInit(void) {
 3354               		.loc 1 1711 0 discriminator 2
 3355 131e D701      		movw r26,r14
 3356 1320 A80F      		add r26,r24
 3357 1322 B91F      		adc r27,r25
1860:switcherator.c ****                 weeklyProgram[x][y] = tempStuff[y];
 3358               		.loc 1 1860 0 discriminator 2
 3359 1324 2C93      		st X,r18
1859:switcherator.c ****             for (y = 0; y < 10; y++) {
 3360               		.loc 1 1859 0 discriminator 2
 3361 1326 0196      		adiw r24,1
 3362               	.LVL221:
 3363 1328 8A30      		cpi r24,10
 3364 132a 9105      		cpc r25,__zero_reg__
 3365 132c 01F4      		brne .L229
 3366 132e 00C0      		rjmp .L230
 3367               	.LVL222:
 3368               	.L253:
 3369 1330 30E0      		ldi r19,lo8(inputs)
 3370 1332 E32E      		mov r14,r19
 3371 1334 30E0      		ldi r19,hi8(inputs)
 3372 1336 F32E      		mov r15,r19
1856:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 3373               		.loc 1 1856 0
 3374 1338 02E4      		ldi r16,lo8(66)
 3375 133a 10E0      		ldi r17,0
 3376               	.LVL223:
 3377               	.L232:
1867:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, INPUT_BYTES) == 1) {
 3378               		.loc 1 1867 0
 3379 133c 4AE0      		ldi r20,lo8(10)
 3380 133e 50E0      		ldi r21,0
 3381 1340 B801      		movw r22,r16
 3382 1342 CE01      		movw r24,r28
 3383 1344 0196      		adiw r24,1
 3384 1346 0E94 0000 		call readEEPROM
 3385               	.LVL224:
 3386 134a 0197      		sbiw r24,1
 3387 134c 01F0      		breq .L231
 3388               	.L235:
 3389 134e 065F      		subi r16,-10
 3390 1350 1F4F      		sbci r17,-1
 3391               	.LVL225:
 3392 1352 E8E0      		ldi r30,8
 3393 1354 EE0E      		add r14,r30
 3394 1356 F11C      		adc r15,__zero_reg__
1865:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 3395               		.loc 1 1865 0
 3396 1358 0A36      		cpi r16,106
 3397 135a 1105      		cpc r17,__zero_reg__
 3398 135c 01F4      		brne .L232
 3399 135e 00C0      		rjmp .L254
 3400               	.LVL226:
 3401               	.L231:
 3402 1360 FE01      		movw r30,r28
 3403 1362 3196      		adiw r30,1
1867:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, INPUT_BYTES) == 1) {
 3404               		.loc 1 1867 0
 3405 1364 80E0      		ldi r24,0
 3406 1366 90E0      		ldi r25,0
 3407               	.L234:
1869:switcherator.c ****                 inputs[x][y] = tempStuff[y];
 3408               		.loc 1 1869 0 discriminator 2
 3409 1368 2191      		ld r18,Z+
1711:switcherator.c **** void generalInit(void) {
 3410               		.loc 1 1711 0 discriminator 2
 3411 136a D701      		movw r26,r14
 3412 136c A80F      		add r26,r24
 3413 136e B91F      		adc r27,r25
1869:switcherator.c ****                 inputs[x][y] = tempStuff[y];
 3414               		.loc 1 1869 0 discriminator 2
 3415 1370 2C93      		st X,r18
1868:switcherator.c ****             for (y = 0; y < 8; y++) {
 3416               		.loc 1 1868 0 discriminator 2
 3417 1372 0196      		adiw r24,1
 3418               	.LVL227:
 3419 1374 8830      		cpi r24,8
 3420 1376 9105      		cpc r25,__zero_reg__
 3421 1378 01F4      		brne .L234
 3422 137a 00C0      		rjmp .L235
 3423               	.LVL228:
 3424               	.L254:
 3425 137c 00E0      		ldi r16,lo8(timeLimits)
 3426 137e 10E0      		ldi r17,hi8(timeLimits)
 3427               	.LVL229:
1865:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 3428               		.loc 1 1865 0
 3429 1380 2AE6      		ldi r18,lo8(106)
 3430 1382 E22E      		mov r14,r18
 3431 1384 F12C      		mov r15,__zero_reg__
 3432               	.L237:
 3433               	.LVL230:
1876:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, LIMIT_BYTES) == 1) {
 3434               		.loc 1 1876 0
 3435 1386 45E0      		ldi r20,lo8(5)
 3436 1388 50E0      		ldi r21,0
 3437 138a B701      		movw r22,r14
 3438 138c CE01      		movw r24,r28
 3439 138e 0196      		adiw r24,1
 3440 1390 0E94 0000 		call readEEPROM
 3441               	.LVL231:
 3442 1394 0197      		sbiw r24,1
 3443 1396 01F4      		brne .L236
 3444               	.LVL232:
1878:switcherator.c ****                 timeLimits[x][y] = tempStuff[y];
 3445               		.loc 1 1878 0 discriminator 1
 3446 1398 8981      		ldd r24,Y+1
 3447 139a 90E0      		ldi r25,0
 3448 139c A0E0      		ldi r26,0
 3449 139e B0E0      		ldi r27,0
 3450 13a0 F801      		movw r30,r16
 3451 13a2 8083      		st Z,r24
 3452 13a4 9183      		std Z+1,r25
 3453 13a6 A283      		std Z+2,r26
 3454 13a8 B383      		std Z+3,r27
 3455               	.LVL233:
 3456 13aa 8A81      		ldd r24,Y+2
 3457 13ac 90E0      		ldi r25,0
 3458 13ae A0E0      		ldi r26,0
 3459 13b0 B0E0      		ldi r27,0
 3460 13b2 8483      		std Z+4,r24
 3461 13b4 9583      		std Z+5,r25
 3462 13b6 A683      		std Z+6,r26
 3463 13b8 B783      		std Z+7,r27
 3464               	.LVL234:
 3465 13ba 8B81      		ldd r24,Y+3
 3466 13bc 90E0      		ldi r25,0
 3467 13be A0E0      		ldi r26,0
 3468 13c0 B0E0      		ldi r27,0
 3469 13c2 8087      		std Z+8,r24
 3470 13c4 9187      		std Z+9,r25
 3471 13c6 A287      		std Z+10,r26
 3472 13c8 B387      		std Z+11,r27
 3473               	.LVL235:
 3474               	.L236:
 3475 13ca F5E0      		ldi r31,5
 3476 13cc EF0E      		add r14,r31
 3477 13ce F11C      		adc r15,__zero_reg__
 3478               	.LVL236:
 3479 13d0 045F      		subi r16,-12
 3480 13d2 1F4F      		sbci r17,-1
1874:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++) {
 3481               		.loc 1 1874 0
 3482 13d4 2EE7      		ldi r18,126
 3483 13d6 E216      		cp r14,r18
 3484 13d8 F104      		cpc r15,__zero_reg__
 3485 13da 01F4      		brne .L237
1883:switcherator.c ****     if (readEEPROM(tempStuff, PWM_DIR, PWM_DIR_BYTES) == 1) {
 3486               		.loc 1 1883 0
 3487 13dc 43E0      		ldi r20,lo8(3)
 3488 13de 50E0      		ldi r21,0
 3489 13e0 6DE1      		ldi r22,lo8(29)
 3490 13e2 71E0      		ldi r23,lo8(1)
 3491 13e4 CE01      		movw r24,r28
 3492 13e6 0196      		adiw r24,1
 3493 13e8 0E94 0000 		call readEEPROM
 3494               	.LVL237:
 3495 13ec 0197      		sbiw r24,1
 3496 13ee 01F4      		brne .L238
1884:switcherator.c ****         DDRD |= (1 << PIND3) | (1 << PIND5) | (1 << PIND6);
 3497               		.loc 1 1884 0
 3498 13f0 8AB1      		in r24,0xa
 3499 13f2 8866      		ori r24,lo8(104)
 3500 13f4 8AB9      		out 0xa,r24
1886:switcherator.c ****         Red = 0;
 3501               		.loc 1 1886 0
 3502 13f6 1092 B400 		sts 180,__zero_reg__
1887:switcherator.c ****         Green = 0;
 3503               		.loc 1 1887 0
 3504 13fa 18BC      		out 0x28,__zero_reg__
1888:switcherator.c ****         Blue = 0;
 3505               		.loc 1 1888 0
 3506 13fc 17BC      		out 0x27,__zero_reg__
1891:switcherator.c ****         if (tempStuff[0] == 0) {
 3507               		.loc 1 1891 0
 3508 13fe 8981      		ldd r24,Y+1
 3509 1400 8111      		cpse r24,__zero_reg__
 3510 1402 00C0      		rjmp .L239
1892:switcherator.c ****             TCCR0A = (1 << COM0A0) | (1 << COM0A1) | (1 << COM0B0) | (1 << COM0B1) | (1 << WGM00);
 3511               		.loc 1 1892 0
 3512 1404 81EF      		ldi r24,lo8(-15)
 3513 1406 84BD      		out 0x24,r24
1893:switcherator.c ****             TCCR2A = (1 << COM2B0) | (1 << COM2B1) | (1 << WGM20);
 3514               		.loc 1 1893 0
 3515 1408 81E3      		ldi r24,lo8(49)
 3516 140a 8093 B000 		sts 176,r24
1894:switcherator.c ****             pwmdir = 0;
 3517               		.loc 1 1894 0
 3518 140e 1092 0000 		sts pwmdir,__zero_reg__
 3519 1412 00C0      		rjmp .L240
 3520               	.L239:
1896:switcherator.c ****             TCCR0A = (1 << COM0A1) | (1 << COM0B1) | (1 << WGM00);
 3521               		.loc 1 1896 0
 3522 1414 81EA      		ldi r24,lo8(-95)
 3523 1416 84BD      		out 0x24,r24
1897:switcherator.c ****             TCCR2A = (1 << COM2B1) | (1 << WGM20);
 3524               		.loc 1 1897 0
 3525 1418 81E2      		ldi r24,lo8(33)
 3526 141a 8093 B000 		sts 176,r24
1898:switcherator.c ****             pwmdir = 1;
 3527               		.loc 1 1898 0
 3528 141e 81E0      		ldi r24,lo8(1)
 3529 1420 8093 0000 		sts pwmdir,r24
 3530               	.L240:
1901:switcherator.c ****         TCCR0B = (1 << CS01) | (1 << CS00);
 3531               		.loc 1 1901 0
 3532 1424 83E0      		ldi r24,lo8(3)
 3533 1426 85BD      		out 0x25,r24
1903:switcherator.c ****         TCCR2B = (1 << CS22); // F_CPU/64
 3534               		.loc 1 1903 0
 3535 1428 84E0      		ldi r24,lo8(4)
 3536 142a 8093 B100 		sts 177,r24
 3537               	.L238:
 3538               	.LVL238:
1908:switcherator.c ****     if (readEEPROM(tempStuff, memoryMarker, PWM_VALUE_BYTES) == 1) {
 3539               		.loc 1 1908 0
 3540 142e 45E0      		ldi r20,lo8(5)
 3541 1430 50E0      		ldi r21,0
 3542 1432 6EE7      		ldi r22,lo8(126)
 3543 1434 70E0      		ldi r23,0
 3544 1436 CE01      		movw r24,r28
 3545 1438 0196      		adiw r24,1
 3546 143a 0E94 0000 		call readEEPROM
 3547               	.LVL239:
 3548 143e 0197      		sbiw r24,1
 3549 1440 01F4      		brne .L241
1909:switcherator.c ****         pwmValues[0] = tempStuff[0];
 3550               		.loc 1 1909 0
 3551 1442 8981      		ldd r24,Y+1
 3552 1444 8093 0000 		sts pwmValues,r24
1910:switcherator.c ****         pwmValues[1] = tempStuff[1];
 3553               		.loc 1 1910 0
 3554 1448 8A81      		ldd r24,Y+2
 3555 144a 8093 0000 		sts pwmValues+1,r24
1911:switcherator.c ****         pwmValues[2] = tempStuff[2];
 3556               		.loc 1 1911 0
 3557 144e 8B81      		ldd r24,Y+3
 3558 1450 8093 0000 		sts pwmValues+2,r24
 3559               	.L241:
 3560               	.LVL240:
 3561 1454 00E0      		ldi r16,lo8(colorChanges+2)
 3562 1456 10E0      		ldi r17,hi8(colorChanges+2)
1865:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 3563               		.loc 1 1865 0 discriminator 1
 3564 1458 93E8      		ldi r25,lo8(-125)
 3565 145a E92E      		mov r14,r25
 3566 145c F12C      		mov r15,__zero_reg__
 3567               	.LVL241:
 3568               	.L243:
1916:switcherator.c ****         if (readEEPROM(tempStuff, memoryMarker, PWM_VALUE_BYTES) == 1) {
 3569               		.loc 1 1916 0
 3570 145e 45E0      		ldi r20,lo8(5)
 3571 1460 50E0      		ldi r21,0
 3572 1462 B701      		movw r22,r14
 3573 1464 CE01      		movw r24,r28
 3574 1466 0196      		adiw r24,1
 3575 1468 0E94 0000 		call readEEPROM
 3576               	.LVL242:
 3577 146c 0197      		sbiw r24,1
 3578 146e 01F4      		brne .L242
 3579               	.LVL243:
1711:switcherator.c **** void generalInit(void) {
 3580               		.loc 1 1711 0 discriminator 1
 3581 1470 F801      		movw r30,r16
 3582 1472 3297      		sbiw r30,2
1918:switcherator.c ****                 colorChanges[x][y] = tempStuff[y];
 3583               		.loc 1 1918 0 discriminator 1
 3584 1474 8981      		ldd r24,Y+1
 3585 1476 8083      		st Z,r24
 3586               	.LVL244:
1711:switcherator.c **** void generalInit(void) {
 3587               		.loc 1 1711 0 discriminator 1
 3588 1478 F801      		movw r30,r16
 3589 147a 3197      		sbiw r30,1
1918:switcherator.c ****                 colorChanges[x][y] = tempStuff[y];
 3590               		.loc 1 1918 0 discriminator 1
 3591 147c 8A81      		ldd r24,Y+2
 3592 147e 8083      		st Z,r24
 3593               	.LVL245:
 3594 1480 8B81      		ldd r24,Y+3
 3595 1482 F801      		movw r30,r16
 3596 1484 8083      		st Z,r24
 3597               	.LVL246:
 3598               	.L242:
 3599 1486 F5E0      		ldi r31,5
 3600 1488 EF0E      		add r14,r31
 3601 148a F11C      		adc r15,__zero_reg__
 3602               	.LVL247:
 3603 148c 0D5F      		subi r16,-3
 3604 148e 1F4F      		sbci r17,-1
1914:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 3605               		.loc 1 1914 0
 3606 1490 21EA      		ldi r18,-95
 3607 1492 E216      		cp r14,r18
 3608 1494 F104      		cpc r15,__zero_reg__
 3609 1496 01F4      		brne .L243
 3610               	/* epilogue start */
1922:switcherator.c **** }
 3611               		.loc 1 1922 0
 3612 1498 2E96      		adiw r28,14
 3613 149a 0FB6      		in __tmp_reg__,__SREG__
 3614 149c F894      		cli
 3615 149e DEBF      		out __SP_H__,r29
 3616 14a0 0FBE      		out __SREG__,__tmp_reg__
 3617 14a2 CDBF      		out __SP_L__,r28
 3618 14a4 DF91      		pop r29
 3619 14a6 CF91      		pop r28
 3620 14a8 1F91      		pop r17
 3621 14aa 0F91      		pop r16
 3622 14ac FF90      		pop r15
 3623 14ae EF90      		pop r14
 3624               	.LVL248:
 3625 14b0 0895      		ret
 3626               	.LFE41:
 3628               	.global	unformatAddress
 3630               	unformatAddress:
 3631               	.LFB76:
2946:switcherator.c **** 
2947:switcherator.c **** // send receive addresses
2948:switcherator.c **** //static uint64_t rx_addr_p0, rx_addr_p1, rx_addr_p2, rx_addr_p3, rx_addr_p4, rx_addr_p5, tx_addr;
2949:switcherator.c **** 
2950:switcherator.c **** // display's a given address
2951:switcherator.c **** //RD:N RC:N 0xnnnnnnnnnn
2952:switcherator.c **** //0123
2953:switcherator.c **** 
2954:switcherator.c **** void radioDisplayAddress(char * commandReceived) {
2955:switcherator.c ****     int x = 0;
2956:switcherator.c ****     char tempRadioString[6];
2957:switcherator.c ****     statusMsg[0] = 0;
2958:switcherator.c ****     if(commandReceived[3] == '1') {
2959:switcherator.c ****             unformatAddress(rx_addr_p1, tempRadioString);
2960:switcherator.c ****             strcat(statusMsg, "r1-0x");
2961:switcherator.c ****     } else if(commandReceived[3] == '2') {
2962:switcherator.c ****             unformatAddress(rx_addr_p2, tempRadioString);
2963:switcherator.c ****             strcat(statusMsg, "r2-0x");
2964:switcherator.c ****     } else if(commandReceived[3] == '3') {
2965:switcherator.c ****             unformatAddress(rx_addr_p3, tempRadioString);
2966:switcherator.c ****             strcat(statusMsg, "r3-0x");
2967:switcherator.c ****     } else if(commandReceived[3] == '4') {
2968:switcherator.c ****             unformatAddress(rx_addr_p4, tempRadioString);
2969:switcherator.c ****             strcat(statusMsg, "r4-0x");
2970:switcherator.c ****     } else if (commandReceived[3] == '5') {
2971:switcherator.c ****             unformatAddress(rx_addr_p5, tempRadioString);
2972:switcherator.c ****             strcat(statusMsg, "r5-0x");
2973:switcherator.c ****     } else if (commandReceived[3] == 'T') {
2974:switcherator.c ****             unformatAddress(tx_addr, tempRadioString);
2975:switcherator.c ****             strcat(statusMsg, "t-0x");
2976:switcherator.c ****     } else {
2977:switcherator.c ****             unformatAddress(rx_addr_p0, tempRadioString);
2978:switcherator.c ****             strcat(statusMsg, "r0-0x");
2979:switcherator.c ****     }
2980:switcherator.c ****     for (x = 0; x < 5; x++) {
2981:switcherator.c ****         returnHexWithout(tempRadioString[x], tempLongString);
2982:switcherator.c ****         strcat(statusMsg, tempLongString);
2983:switcherator.c ****     }
2984:switcherator.c ****     sendMessage(statusMsg);
2985:switcherator.c **** }
2986:switcherator.c **** 
2987:switcherator.c **** // change the radio address
2988:switcherator.c **** // send receive addresses
2989:switcherator.c **** //static uint64_t rx_addr_p0, rx_addr_p1, rx_addr_p2, rx_addr_p3, rx_addr_p4, rx_addr_p5, tx_addr;
2990:switcherator.c **** 
2991:switcherator.c **** //RD:N RC:N 0xnnnnnnnnnn
2992:switcherator.c **** //     01234567890123456
2993:switcherator.c **** 
2994:switcherator.c **** void radioChangeAddress(char * commandReceived) {
2995:switcherator.c ****     int x = 0;
2996:switcherator.c ****     statusMsg[0] = 0;
2997:switcherator.c ****     int tempInt = 0;
2998:switcherator.c ****     uint64_t newAddress = 0;
2999:switcherator.c ****     char tempString[] = "0x00";
3000:switcherator.c ****     char tempRadioString[] = "00000";
3001:switcherator.c ****     for (x = 0; x < 5; x++) {
3002:switcherator.c ****         tempString[2] = commandReceived[((x * 2) + 7)];
3003:switcherator.c ****         tempString[3] = commandReceived[((x * 2) + 8)];
3004:switcherator.c ****         tempInt = strtol(tempString, 0, 0);
3005:switcherator.c ****         newAddress |= tempInt;
3006:switcherator.c ****         if (x < 4)
3007:switcherator.c ****             newAddress <<= 8;
3008:switcherator.c ****     }
3009:switcherator.c ****     switch (commandReceived[3]) {
3010:switcherator.c ****         case '0':
3011:switcherator.c ****             rx_addr_p0 = newAddress;
3012:switcherator.c ****             strcat(statusMsg, "r0 0x");
3013:switcherator.c ****             writeAddr(RX_ADDR_P0, newAddress);
3014:switcherator.c ****             break;
3015:switcherator.c ****         case '1':
3016:switcherator.c ****             rx_addr_p1 = newAddress;
3017:switcherator.c ****             strcat(statusMsg, "r1 0x");
3018:switcherator.c ****             writeAddr(RX_ADDR_P1, newAddress);
3019:switcherator.c ****             break;
3020:switcherator.c ****         case '2':
3021:switcherator.c ****             rx_addr_p2 = newAddress;
3022:switcherator.c ****             strcat(statusMsg, "r2 0x");
3023:switcherator.c ****             writeAddr(RX_ADDR_P2, newAddress);
3024:switcherator.c ****             break;
3025:switcherator.c ****         case '3':
3026:switcherator.c ****             rx_addr_p3 = newAddress;
3027:switcherator.c ****             strcat(statusMsg, "r3 0x");
3028:switcherator.c ****             writeAddr(RX_ADDR_P3, newAddress);
3029:switcherator.c ****             break;
3030:switcherator.c ****         case '4':
3031:switcherator.c ****             rx_addr_p4 = newAddress;
3032:switcherator.c ****             strcat(statusMsg, "r4 0x");
3033:switcherator.c ****             writeAddr(RX_ADDR_P4, newAddress);
3034:switcherator.c ****             break;
3035:switcherator.c ****         case '5':
3036:switcherator.c ****             rx_addr_p5 = newAddress;
3037:switcherator.c ****             strcat(statusMsg, "r5 0x");
3038:switcherator.c ****             writeAddr(RX_ADDR_P5, newAddress);
3039:switcherator.c ****             break;
3040:switcherator.c ****         case 'T':
3041:switcherator.c ****             tx_addr = newAddress;
3042:switcherator.c ****             strcat(statusMsg, "t 0x");
3043:switcherator.c ****             writeAddr(TX_ADDR, newAddress);
3044:switcherator.c ****             break;
3045:switcherator.c ****     }
3046:switcherator.c ****     unformatAddress(newAddress, tempRadioString);
3047:switcherator.c ****     for (x = 0; x < 5; x++) {
3048:switcherator.c ****         returnHexWithout(tempRadioString[x], tempLongString);
3049:switcherator.c ****         strcat(statusMsg, tempLongString);
3050:switcherator.c ****     }
3051:switcherator.c ****     sendMessage(statusMsg);
3052:switcherator.c **** }
3053:switcherator.c **** 
3054:switcherator.c **** // sets or views the serial number
3055:switcherator.c **** // SE nnnnnn
3056:switcherator.c **** // 012345678
3057:switcherator.c **** 
3058:switcherator.c **** void serialNumber(char * commandReceived) {
3059:switcherator.c ****     tempHugeString[0] = commandReceived[3];
3060:switcherator.c ****     tempHugeString[1] = commandReceived[4];
3061:switcherator.c ****     tempHugeString[2] = commandReceived[5];
3062:switcherator.c ****     tempHugeString[3] = commandReceived[6];
3063:switcherator.c ****     tempHugeString[4] = commandReceived[7];
3064:switcherator.c ****     tempHugeString[5] = commandReceived[8];
3065:switcherator.c ****     long temp = atol(tempHugeString);
3066:switcherator.c ****     int serialLength = 0;
3067:switcherator.c ****     statusMsg[0] = 0;
3068:switcherator.c ****     //since a 0 serial number is not valid that means to return the serial number
3069:switcherator.c ****     strcat(statusMsg, "Ser#");
3070:switcherator.c ****     if (temp > 0) {
3071:switcherator.c ****         // new serial number
3072:switcherator.c ****         serial = temp;
3073:switcherator.c ****         ltoa(serial, stringSerial, 10);
3074:switcherator.c **** 
3075:switcherator.c ****     }
3076:switcherator.c ****     serialLength = strlen(stringSerial);
3077:switcherator.c ****     while (serialLength < 6) {
3078:switcherator.c ****         strcat(statusMsg, "0");
3079:switcherator.c ****         serialLength++;
3080:switcherator.c ****     }
3081:switcherator.c ****     strcat(statusMsg, stringSerial);
3082:switcherator.c ****     sendMessage(statusMsg);
3083:switcherator.c **** }
3084:switcherator.c **** 
3085:switcherator.c **** // take the int and return the array
3086:switcherator.c **** 
3087:switcherator.c **** void unformatAddress(uint64_t oldAddress, char * formattedAddress) {
 3632               		.loc 1 3087 0
 3633               	.LVL249:
 3634 14b2 0F93      		push r16
 3635               	.LCFI84:
 3636 14b4 1F93      		push r17
 3637               	.LCFI85:
 3638               	/* prologue: function */
 3639               	/* frame size = 0 */
 3640               	/* stack size = 2 */
 3641               	.L__stack_usage = 2
 3642 14b6 F801      		movw r30,r16
 3643               	.LVL250:
3088:switcherator.c ****     uint64_t tempInt = oldAddress;
3089:switcherator.c ****     formattedAddress[4] = (tempInt & 0xff);
 3644               		.loc 1 3089 0
 3645 14b8 2483      		std Z+4,r18
3090:switcherator.c ****     tempInt >>= 8;
 3646               		.loc 1 3090 0
 3647 14ba 08E0      		ldi r16,lo8(8)
 3648               	.LVL251:
 3649 14bc 0E94 0000 		call __lshrdi3
 3650               	.LVL252:
3091:switcherator.c ****     formattedAddress[3] = (tempInt & 0xff);
 3651               		.loc 1 3091 0
 3652 14c0 2383      		std Z+3,r18
3092:switcherator.c ****     tempInt >>= 8;
 3653               		.loc 1 3092 0
 3654 14c2 0E94 0000 		call __lshrdi3
 3655               	.LVL253:
3093:switcherator.c ****     formattedAddress[2] = (tempInt & 0xff);
 3656               		.loc 1 3093 0
 3657 14c6 2283      		std Z+2,r18
3094:switcherator.c ****     tempInt >>= 8;
 3658               		.loc 1 3094 0
 3659 14c8 0E94 0000 		call __lshrdi3
 3660               	.LVL254:
3095:switcherator.c ****     formattedAddress[1] = (tempInt & 0xff);
 3661               		.loc 1 3095 0
 3662 14cc 2183      		std Z+1,r18
 3663               	.LVL255:
3096:switcherator.c ****     tempInt >>= 8;
 3664               		.loc 1 3096 0
 3665 14ce 0E94 0000 		call __lshrdi3
 3666               	.LVL256:
3097:switcherator.c ****     formattedAddress[0] = (tempInt & 0xff);
 3667               		.loc 1 3097 0
 3668 14d2 2083      		st Z,r18
 3669               	/* epilogue start */
3098:switcherator.c **** }
 3670               		.loc 1 3098 0
 3671 14d4 1F91      		pop r17
 3672 14d6 0F91      		pop r16
 3673 14d8 0895      		ret
 3674               	.LFE76:
 3676               	.global	getInput
 3678               	getInput:
 3679               	.LFB82:
3099:switcherator.c **** 
3100:switcherator.c **** void sendMessage(char * myResponse) {
3101:switcherator.c ****     stopRx();
3102:switcherator.c ****     _delay_us(100);
3103:switcherator.c ****     int transmitLength = strlen(myResponse);
3104:switcherator.c ****     if(!transmit(myResponse, transmitLength)) {
3105:switcherator.c ****         failCondition = 2;
3106:switcherator.c ****     } else {
3107:switcherator.c ****         failCondition = 0;
3108:switcherator.c ****         clearFail();
3109:switcherator.c ****     }
3110:switcherator.c ****     startRx();
3111:switcherator.c **** }
3112:switcherator.c **** 
3113:switcherator.c **** 
3114:switcherator.c **** /****************************************************************
3115:switcherator.c ****  *
3116:switcherator.c ****  *              All Things Input Related
3117:switcherator.c ****  *
3118:switcherator.c ****  ****************************************************************/
3119:switcherator.c **** 
3120:switcherator.c **** // sets up an input on one of the analog pins
3121:switcherator.c **** // DI:##Ppx?##DuraPO
3122:switcherator.c **** // AI:##PpLLLHHH?##DuraPOw
3123:switcherator.c **** // 0123456789012345678901234
3124:switcherator.c **** // int Port/pin like switches, low%,high%, switch/program, dur, poll time
3125:switcherator.c **** // inputs[NUM_INPUTS]
3126:switcherator.c **** 
3127:switcherator.c **** void setAnalogInput(char * commandReceived) {
3128:switcherator.c ****     int x = 0;
3129:switcherator.c ****     int inputNumber, lowPercent, highPercent, pollTime, outputNum, duration;
3130:switcherator.c ****     char pin = 0;
3131:switcherator.c ****     inputNumber = lowPercent = highPercent = pollTime = outputNum = duration = 0;
3132:switcherator.c ****     int switchNumber = 0;
3133:switcherator.c ****     long temp = 0;
3134:switcherator.c ****     char whichRGB = 0;
3135:switcherator.c ****     tempIntString[0] = commandReceived[3];
3136:switcherator.c ****     tempIntString[1] = commandReceived[4];
3137:switcherator.c ****     inputNumber = atoi(tempIntString);
3138:switcherator.c ****     if (inputNumber >= NUM_INPUTS) {
3139:switcherator.c ****         fail(0x11);
3140:switcherator.c ****         return;
3141:switcherator.c ****     }
3142:switcherator.c ****     tempIntString[0] = '0';
3143:switcherator.c ****     tempIntString[1] = commandReceived[6];
3144:switcherator.c ****     pin = atoi(tempIntString);
3145:switcherator.c ****     if (pin > 7) {
3146:switcherator.c ****         fail(0x04);
3147:switcherator.c ****         return;
3148:switcherator.c ****     }
3149:switcherator.c **** 
3150:switcherator.c ****     tempIntString[0] = commandReceived[14];
3151:switcherator.c ****     tempIntString[1] = commandReceived[15];
3152:switcherator.c ****     switchNumber = atoi(tempIntString);
3153:switcherator.c **** 
3154:switcherator.c ****     tempIntString[0] = commandReceived[20];
3155:switcherator.c ****     tempIntString[1] = commandReceived[21];
3156:switcherator.c ****     pollTime = atoi(tempIntString);
3157:switcherator.c **** 
3158:switcherator.c ****     tempIntString[0] = '0';
3159:switcherator.c ****     tempIntString[1] = commandReceived[22];
3160:switcherator.c ****     whichRGB = atoi(tempIntString);
3161:switcherator.c **** 
3162:switcherator.c ****     tempLongString[0] = '0';
3163:switcherator.c ****     tempLongString[1] = commandReceived[7];
3164:switcherator.c ****     tempLongString[2] = commandReceived[8];
3165:switcherator.c ****     tempLongString[3] = commandReceived[9];
3166:switcherator.c ****     lowPercent = atoi(tempLongString);
3167:switcherator.c ****     tempLongString[1] = commandReceived[10];
3168:switcherator.c ****     tempLongString[2] = commandReceived[11];
3169:switcherator.c ****     tempLongString[3] = commandReceived[12];
3170:switcherator.c ****     highPercent = atoi(tempLongString);
3171:switcherator.c **** 
3172:switcherator.c ****     tempLongString[0] = commandReceived[16];
3173:switcherator.c ****     tempLongString[1] = commandReceived[17];
3174:switcherator.c ****     tempLongString[2] = commandReceived[18];
3175:switcherator.c ****     tempLongString[3] = commandReceived[19];
3176:switcherator.c ****     duration = atoi(tempLongString);
3177:switcherator.c **** 
3178:switcherator.c ****     // pLHsDDP p int pin/port like sw, L%,H% (0,255 - digital), s - 0-127=switch, 128-255 = prog
3179:switcherator.c ****     // 0123456
3180:switcherator.c ****     // dur in seconds, poll time in secs or  0 for continuous. 
3181:switcherator.c ****     // #= analogIn num, p=pin, LLL=low%, HHH=High%,? = 'P'rog or 'S', ## = num
3182:switcherator.c ****     // Durat. = duration in seconds, POLL = poll time in seconds or 0 for 1/10
3183:switcherator.c ****     if (commandReceived[5] != 'C' && commandReceived[5] != 'c') {
3184:switcherator.c ****         fail(0x03);
3185:switcherator.c ****         return;
3186:switcherator.c ****     }
3187:switcherator.c ****     // Port / Pin
3188:switcherator.c ****     // value of 255 (default) means nothing programmed
3189:switcherator.c ****     // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
3190:switcherator.c ****     // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
3191:switcherator.c ****     // pin is abs(value/2)-the base - PINB3 = (22-16)/2  PINB3 (22-16)%2 = 0 - low (23-16)%2 = 1 - 
3192:switcherator.c ****     // port is C.  This is analog in so its not normal but need to set the DDR anyway
3193:switcherator.c ****     // get the pin
3194:switcherator.c ****     temp = pin * 2;
3195:switcherator.c ****     // add # for port C
3196:switcherator.c ****     temp += 32;
3197:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
3198:switcherator.c ****         if (switchStuff[x] == temp) {
3199:switcherator.c **** 
3200:switcherator.c ****             fail(0x12);
3201:switcherator.c ****             return;
3202:switcherator.c ****         }
3203:switcherator.c ****     }
3204:switcherator.c ****     inputs[inputNumber][0] = temp;
3205:switcherator.c ****     DDRC &= ~(1 << pin);
3206:switcherator.c ****     temp = lowPercent;
3207:switcherator.c ****     temp = temp * 255;
3208:switcherator.c ****     temp = temp / 100;
3209:switcherator.c ****     inputs[inputNumber][1] = temp;
3210:switcherator.c ****     temp = highPercent;
3211:switcherator.c ****     temp = temp * 255;
3212:switcherator.c ****     temp = temp / 100;
3213:switcherator.c ****     if (temp == 255) // if the top is 255 we need it to be 254 so its not digital
3214:switcherator.c ****         temp = 254;
3215:switcherator.c **** 
3216:switcherator.c ****     inputs[inputNumber][2] = temp;
3217:switcherator.c ****     // 128 switches and 128 programs possible
3218:switcherator.c ****     if (commandReceived[13] == 'P' || commandReceived[13] == 'p') {
3219:switcherator.c ****         switchNumber += 128;
3220:switcherator.c ****     }
3221:switcherator.c ****     inputs[inputNumber][3] = switchNumber;
3222:switcherator.c ****     temp = duration >> 8;
3223:switcherator.c ****     inputs[inputNumber][4] = temp;
3224:switcherator.c ****     temp = duration & 0xff;
3225:switcherator.c ****     inputs[inputNumber][5] = temp;
3226:switcherator.c **** 
3227:switcherator.c **** 
3228:switcherator.c ****     if (pollTime > 255)
3229:switcherator.c ****         pollTime = 255;
3230:switcherator.c ****     inputs[inputNumber][6] = pollTime;
3231:switcherator.c **** 
3232:switcherator.c ****     // if we are using a RGB switch then which ones do we activate (mask)
3233:switcherator.c ****     if (whichRGB > 7)
3234:switcherator.c ****         whichRGB = 7;
3235:switcherator.c ****     inputs[inputNumber][7] = whichRGB;
3236:switcherator.c **** 
3237:switcherator.c **** 
3238:switcherator.c ****     // set ADMUX when we do a conversion
3239:switcherator.c ****     // Set prescaler 1/32. why not... ;-)
3240:switcherator.c ****     ADCSRA |= (1 << ADPS2) || (1 << ADPS0);
3241:switcherator.c **** 
3242:switcherator.c **** 
3243:switcherator.c ****     ok();
3244:switcherator.c **** }
3245:switcherator.c **** 
3246:switcherator.c **** // set up an input on a regular pin
3247:switcherator.c **** // DI:##Ppx?##DuraPO
3248:switcherator.c **** // 012345678901234567890
3249:switcherator.c **** // #=digital in num, P=Port,p=pin, x=High or Low, ?='P'rog or 'S'witch,
3250:switcherator.c **** // ## = prog/switch num, Durat.=duration in seconds, POLL=poll time in sec or 0 for 1/10
3251:switcherator.c **** 
3252:switcherator.c **** void setDigitalInput(char * commandReceived) {
3253:switcherator.c ****     int x = 0;
3254:switcherator.c ****     int inputNumber, pollTime, outputNum, duration;
3255:switcherator.c ****     volatile unsigned char *realDDR = 0;
3256:switcherator.c ****     volatile unsigned char *realPort = 0;
3257:switcherator.c ****     char pin = 0;
3258:switcherator.c ****     inputNumber = pollTime = outputNum = duration = 0;
3259:switcherator.c ****     int switchNumber = 0;
3260:switcherator.c ****     int temp = 0;
3261:switcherator.c ****     tempIntString[0] = commandReceived[3];
3262:switcherator.c ****     tempIntString[1] = commandReceived[4];
3263:switcherator.c ****     inputNumber = atoi(tempIntString);
3264:switcherator.c ****     if (inputNumber >= NUM_INPUTS) {
3265:switcherator.c ****         fail(0x11);
3266:switcherator.c ****         return;
3267:switcherator.c ****     }
3268:switcherator.c ****     tempIntString[0] = '0';
3269:switcherator.c ****     tempIntString[1] = commandReceived[6];
3270:switcherator.c ****     pin = atoi(tempIntString);
3271:switcherator.c ****     if (pin > 7) {
3272:switcherator.c ****         fail(0x04);
3273:switcherator.c ****         return;
3274:switcherator.c ****     }
3275:switcherator.c **** 
3276:switcherator.c ****     tempIntString[0] = commandReceived[9];
3277:switcherator.c ****     tempIntString[1] = commandReceived[10];
3278:switcherator.c ****     switchNumber = atoi(tempIntString);
3279:switcherator.c **** 
3280:switcherator.c ****     tempIntString[0] = commandReceived[15];
3281:switcherator.c ****     tempIntString[1] = commandReceived[16];
3282:switcherator.c ****     pollTime = atoi(tempIntString);
3283:switcherator.c **** 
3284:switcherator.c ****     tempLongString[0] = commandReceived[11];
3285:switcherator.c ****     tempLongString[1] = commandReceived[12];
3286:switcherator.c ****     tempLongString[2] = commandReceived[13];
3287:switcherator.c ****     tempLongString[3] = commandReceived[14];
3288:switcherator.c ****     duration = atoi(tempLongString);
3289:switcherator.c ****     // if we are activating a program
3290:switcherator.c ****     if (commandReceived[8] == 'P' || commandReceived[8] == 'p') {
3291:switcherator.c ****         switchNumber += 128;
3292:switcherator.c ****     }
3293:switcherator.c ****     temp = pin * 2;
3294:switcherator.c ****     if (commandReceived[5] == 'B' || commandReceived[5] == 'b') {
3295:switcherator.c ****         realDDR = &DDRB;
3296:switcherator.c ****         realPort = &PORTB;
3297:switcherator.c ****         temp += 16;
3298:switcherator.c **** #ifdef PORTA
3299:switcherator.c ****     } else if (commandReceived[5] == 'A' || commandReceived[5] == 'a') {
3300:switcherator.c ****         realDDR = &DDRA;
3301:switcherator.c ****         realPort = &PORTA;
3302:switcherator.c ****         temp += 0;
3303:switcherator.c **** #endif        
3304:switcherator.c **** #ifdef PORTC
3305:switcherator.c ****     } else if (commandReceived[5] == 'C' || commandReceived[5] == 'c') {
3306:switcherator.c ****         realDDR = &DDRC;
3307:switcherator.c ****         realPort = &PORTC;
3308:switcherator.c ****         temp += 32;
3309:switcherator.c **** #endif        
3310:switcherator.c **** #ifdef PORTD
3311:switcherator.c ****     } else if (commandReceived[5] == 'D' || commandReceived[5] == 'd') {
3312:switcherator.c ****         realDDR = &DDRD;
3313:switcherator.c ****         realPort = &PORTD;
3314:switcherator.c ****         temp += 48;
3315:switcherator.c **** #endif        
3316:switcherator.c **** #ifdef PORTE
3317:switcherator.c ****     } else if (commandReceived[5] == 'E' || commandReceived[5] == 'e') {
3318:switcherator.c ****         realDDR = &DDRE;
3319:switcherator.c ****         realPort = &PORTE;
3320:switcherator.c ****         temp += 64;
3321:switcherator.c **** #endif        
3322:switcherator.c **** #ifdef PORTF
3323:switcherator.c ****     } else if (commandReceived[5] == 'F' || commandReceived[5] == 'f') {
3324:switcherator.c ****         realDDR = &DDRF;
3325:switcherator.c ****         realPort = &PORTF;
3326:switcherator.c ****         temp += 80;
3327:switcherator.c **** #endif        
3328:switcherator.c **** #ifdef PORTG
3329:switcherator.c ****     } else if (commandReceived[5] == 'G' || commandReceived[5] == 'g') {
3330:switcherator.c ****         realDDR = &DDRG;
3331:switcherator.c ****         realPort = &PORTG;
3332:switcherator.c ****         temp += 96;
3333:switcherator.c **** #endif        
3334:switcherator.c **** #ifdef PORTH
3335:switcherator.c ****     } else if (commandReceived[5] == 'H' || commandReceived[5] == 'h') {
3336:switcherator.c ****         realDDR = &DDRH;
3337:switcherator.c ****         realPort = &PORTH;
3338:switcherator.c ****         temp += 112;
3339:switcherator.c **** #endif        
3340:switcherator.c **** #ifdef PORTI
3341:switcherator.c ****     } else if (commandReceived[5] == 'I' || commandReceived[5] == 'i') {
3342:switcherator.c ****         realDDR = &DDRI;
3343:switcherator.c ****         realPort = &PORTI;
3344:switcherator.c ****         temp += 128;
3345:switcherator.c **** #endif        
3346:switcherator.c ****     }
3347:switcherator.c ****     // value of 255 (default) means nothing programmed
3348:switcherator.c ****     // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
3349:switcherator.c ****     // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
3350:switcherator.c ****     // pin is abs(value/2)-the base - PINB3 = (22-16)/2  PINB3 (22-16)%2 = 0 - low (23-16)%2 = 1 - 
3351:switcherator.c ****     // port is C.  This is analog in so its not normal but need to set the DDR anyway
3352:switcherator.c ****     // get the pin
3353:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
3354:switcherator.c ****         if (switchStuff[x] == temp || switchStuff[x] == (temp + 1)) {
3355:switcherator.c ****             fail(0x12);
3356:switcherator.c ****             return;
3357:switcherator.c ****         }
3358:switcherator.c ****     }
3359:switcherator.c **** 
3360:switcherator.c ****     inputs[inputNumber][0] = temp;
3361:switcherator.c **** 
3362:switcherator.c ****     if (commandReceived[7] == 'H' || commandReceived[7] == 'h' ||
3363:switcherator.c ****             commandReceived[7] == '1') {
3364:switcherator.c ****         inputs[inputNumber][1] = 0;
3365:switcherator.c ****         inputs[inputNumber][2] = 255;
3366:switcherator.c ****     } else {
3367:switcherator.c ****         inputs[inputNumber][1] = 255;
3368:switcherator.c ****         inputs[inputNumber][2] = 0;
3369:switcherator.c ****     }
3370:switcherator.c ****     inputs[inputNumber][3] = switchNumber;
3371:switcherator.c ****     temp = duration >> 8;
3372:switcherator.c ****     inputs[inputNumber][4] = temp;
3373:switcherator.c ****     temp = duration & 0xff;
3374:switcherator.c ****     inputs[inputNumber][5] = temp;
3375:switcherator.c **** 
3376:switcherator.c ****     if (pollTime > 255)
3377:switcherator.c ****         pollTime = 255;
3378:switcherator.c ****     inputs[inputNumber][6] = pollTime;
3379:switcherator.c **** 
3380:switcherator.c ****     *realDDR &= ~(1 << pin);
3381:switcherator.c ****     *realPort |= (1 << pin);
3382:switcherator.c **** 
3383:switcherator.c ****     ok();
3384:switcherator.c ****     // DI:##Ppx?##DuraPO
3385:switcherator.c ****     // 012345678901234567890
3386:switcherator.c **** }
3387:switcherator.c **** 
3388:switcherator.c **** // inputs[NUM_INPUTS] - is the following
3389:switcherator.c **** // pLHsDDP p int pin/port like sw, L%,H% (0,255 - digital), s - 0-127=switch, 128-255 = prog
3390:switcherator.c **** // 0123456
3391:switcherator.c **** // Port / Pin
3392:switcherator.c **** // value of 255 (default) means nothing programmed
3393:switcherator.c **** // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
3394:switcherator.c **** // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
3395:switcherator.c **** 
3396:switcherator.c **** // see if we check any inputs this second
3397:switcherator.c **** 
3398:switcherator.c **** void inputCheck(void) {
3399:switcherator.c ****     int x = 0;
3400:switcherator.c ****     int pollTime = 0;
3401:switcherator.c ****     // figure out if we care about our inputs
3402:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
3403:switcherator.c ****         // see if it is a valid input
3404:switcherator.c ****         if (inputs[x][0] == 255)
3405:switcherator.c ****             continue; // not valid. Skip
3406:switcherator.c ****         pollTime = inputs[x][6];
3407:switcherator.c ****         // see if it is one we check continuously or every second
3408:switcherator.c ****         if (pollTime == 0 || pollTime == 1) {
3409:switcherator.c ****             getInput(x);
3410:switcherator.c ****             // see if we it is the right second otherwise
3411:switcherator.c ****         } else if (weeklySeconds % pollTime == 0) {
3412:switcherator.c ****             getInput(x);
3413:switcherator.c ****         }
3414:switcherator.c ****     }
3415:switcherator.c **** }
3416:switcherator.c **** 
3417:switcherator.c **** // see if we check inputs continuously (every 10th)
3418:switcherator.c **** 
3419:switcherator.c **** void inputTenthCheck(void) {
3420:switcherator.c ****     int x = 0;
3421:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
3422:switcherator.c ****         // see if it is valid and marked continuously
3423:switcherator.c ****         if (inputs[x][0] != 255 && inputs[x][6] == 0)
3424:switcherator.c ****             getInput(x);
3425:switcherator.c ****     }
3426:switcherator.c **** }
3427:switcherator.c **** 
3428:switcherator.c **** // inputs[NUM_INPUTS] - is the following
3429:switcherator.c **** // pLHsDDPw p int pin/port like sw, L%,H% (0,255 - digital), s - 0-127=switch, 128-255 = prog
3430:switcherator.c **** // 01234567 - w= which analog out if needed
3431:switcherator.c **** // Port / Pin
3432:switcherator.c **** // value of 255 (default) means nothing programmed
3433:switcherator.c **** // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
3434:switcherator.c **** // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG
3435:switcherator.c **** 
3436:switcherator.c **** 
3437:switcherator.c **** // actually check the input and do something based on that
3438:switcherator.c **** 
3439:switcherator.c **** void getInput(int inputNumber) {
 3680               		.loc 1 3439 0
 3681               	.LVL257:
 3682 14da 2F92      		push r2
 3683               	.LCFI86:
 3684 14dc 3F92      		push r3
 3685               	.LCFI87:
 3686 14de 4F92      		push r4
 3687               	.LCFI88:
 3688 14e0 5F92      		push r5
 3689               	.LCFI89:
 3690 14e2 6F92      		push r6
 3691               	.LCFI90:
 3692 14e4 7F92      		push r7
 3693               	.LCFI91:
 3694 14e6 8F92      		push r8
 3695               	.LCFI92:
 3696 14e8 9F92      		push r9
 3697               	.LCFI93:
 3698 14ea AF92      		push r10
 3699               	.LCFI94:
 3700 14ec BF92      		push r11
 3701               	.LCFI95:
 3702 14ee CF92      		push r12
 3703               	.LCFI96:
 3704 14f0 DF92      		push r13
 3705               	.LCFI97:
 3706 14f2 EF92      		push r14
 3707               	.LCFI98:
 3708 14f4 FF92      		push r15
 3709               	.LCFI99:
 3710 14f6 0F93      		push r16
 3711               	.LCFI100:
 3712 14f8 1F93      		push r17
 3713               	.LCFI101:
 3714 14fa CF93      		push r28
 3715               	.LCFI102:
 3716 14fc DF93      		push r29
 3717               	.LCFI103:
 3718 14fe CDB7      		in r28,__SP_L__
 3719 1500 DEB7      		in r29,__SP_H__
 3720               	.LCFI104:
 3721 1502 2C97      		sbiw r28,12
 3722               	.LCFI105:
 3723 1504 0FB6      		in __tmp_reg__,__SREG__
 3724 1506 F894      		cli
 3725 1508 DEBF      		out __SP_H__,r29
 3726 150a 0FBE      		out __SREG__,__tmp_reg__
 3727 150c CDBF      		out __SP_L__,r28
 3728               	/* prologue: function */
 3729               	/* frame size = 12 */
 3730               	/* stack size = 30 */
 3731               	.L__stack_usage = 30
 3732 150e FC01      		movw r30,r24
 3733               	.LVL258:
3440:switcherator.c ****     int x = 0;
3441:switcherator.c ****     unsigned int outputNum, duration, low, high, switchNumber;
3442:switcherator.c ****     volatile unsigned char *thisPin = 0;
3443:switcherator.c ****     long temp = 0;
3444:switcherator.c ****     char test = 0;
3445:switcherator.c ****     char pwmValue = 0;
3446:switcherator.c ****     char whichRGB = 0;
3447:switcherator.c ****     // set up how many seconds are at the beginning of today
3448:switcherator.c ****     long daySeconds = (dow * 86400);
 3734               		.loc 1 3448 0
 3735 1510 2090 0000 		lds r2,dow
 3736 1514 3090 0000 		lds r3,dow+1
 3737 1518 2101      		movw r4,r2
 3738 151a 612C      		mov r6,__zero_reg__
 3739 151c 712C      		mov r7,__zero_reg__
 3740 151e A301      		movw r20,r6
 3741 1520 9201      		movw r18,r4
 3742 1522 60E8      		ldi r22,lo8(-128)
 3743 1524 71E5      		ldi r23,lo8(81)
 3744 1526 81E0      		ldi r24,lo8(1)
 3745 1528 90E0      		ldi r25,0
 3746 152a 0E94 0000 		call __mulsi3
 3747 152e 4B01      		movw r8,r22
 3748 1530 5C01      		movw r10,r24
 3749               	.LVL259:
3449:switcherator.c ****     long startTime, stopTime;
3450:switcherator.c ****     startTime = stopTime = 0;
3451:switcherator.c ****     outputNum = duration = low = high = switchNumber = 0;
3452:switcherator.c ****     outputNum = inputs[inputNumber][0];
 3750               		.loc 1 3452 0
 3751 1532 43E0      		ldi r20,3
 3752               		1:
 3753 1534 EE0F      		lsl r30
 3754 1536 FF1F      		rol r31
 3755 1538 4A95      		dec r20
 3756 153a 01F4      		brne 1b
 3757 153c E050      		subi r30,lo8(-(inputs))
 3758 153e F040      		sbci r31,hi8(-(inputs))
 3759 1540 6081      		ld r22,Z
 3760               	.LVL260:
3453:switcherator.c ****     low = inputs[inputNumber][1];
 3761               		.loc 1 3453 0
 3762 1542 C180      		ldd r12,Z+1
 3763 1544 EC2C      		mov r14,r12
 3764 1546 F12C      		mov r15,__zero_reg__
 3765               	.LVL261:
3454:switcherator.c ****     high = inputs[inputNumber][2];
 3766               		.loc 1 3454 0
 3767 1548 0281      		ldd r16,Z+2
 3768 154a 0983      		std Y+1,r16
 3769               	.LVL262:
3455:switcherator.c ****     switchNumber = inputs[inputNumber][3];
 3770               		.loc 1 3455 0
 3771 154c 0381      		ldd r16,Z+3
 3772               	.LVL263:
 3773 154e 10E0      		ldi r17,0
 3774               	.LVL264:
3456:switcherator.c ****     temp = inputs[inputNumber][4];
3457:switcherator.c ****     duration = (temp << 8);
 3775               		.loc 1 3457 0
 3776 1550 3481      		ldd r19,Z+4
 3777 1552 20E0      		ldi r18,0
3458:switcherator.c ****     temp = inputs[inputNumber][5];
3459:switcherator.c ****     duration |= temp;
 3778               		.loc 1 3459 0
 3779 1554 8581      		ldd r24,Z+5
 3780               	.LVL265:
 3781 1556 A901      		movw r20,r18
 3782 1558 482B      		or r20,r24
 3783 155a 5C87      		std Y+12,r21
 3784 155c 4B87      		std Y+11,r20
 3785               	.LVL266:
3460:switcherator.c ****     whichRGB = inputs[inputNumber][7];
 3786               		.loc 1 3460 0
 3787 155e D780      		ldd r13,Z+7
 3788               	.LVL267:
3461:switcherator.c ****     // if this is an analog input than both the low% or the high% will not be 255
3462:switcherator.c ****     if (low != 255 && high != 255) {
 3789               		.loc 1 3462 0
 3790 1560 5FEF      		ldi r21,-1
 3791 1562 E516      		cp r14,r21
 3792 1564 F104      		cpc r15,__zero_reg__
 3793 1566 01F4      		brne .+2
 3794 1568 00C0      		rjmp .L258
3454:switcherator.c ****     high = inputs[inputNumber][2];
 3795               		.loc 1 3454 0 discriminator 1
 3796 156a F981      		ldd r31,Y+1
 3797 156c EF2F      		mov r30,r31
 3798               	.LVL268:
 3799 156e F0E0      		ldi r31,0
 3800 1570 FA87      		std Y+10,r31
 3801 1572 E987      		std Y+9,r30
 3802               		.loc 1 3462 0 discriminator 1
 3803 1574 EF3F      		cpi r30,-1
 3804 1576 F105      		cpc r31,__zero_reg__
 3805 1578 01F4      		brne .+2
 3806 157a 00C0      		rjmp .L258
3452:switcherator.c ****     outputNum = inputs[inputNumber][0];
 3807               		.loc 1 3452 0
 3808 157c 70E0      		ldi r23,0
3463:switcherator.c ****         // this is an analog input
3464:switcherator.c ****         // currently only port C is supported for analog inputs
3465:switcherator.c ****         temp = outputNum - 32;
 3809               		.loc 1 3465 0
 3810 157e 6052      		subi r22,32
 3811 1580 7109      		sbc r23,__zero_reg__
 3812               	.LVL269:
 3813 1582 CB01      		movw r24,r22
 3814 1584 A0E0      		ldi r26,0
 3815 1586 B0E0      		ldi r27,0
 3816               	.LVL270:
3466:switcherator.c ****         temp = temp / 2;
 3817               		.loc 1 3466 0
 3818 1588 B595      		asr r27
 3819 158a A795      		ror r26
 3820 158c 9795      		ror r25
 3821 158e 8795      		ror r24
 3822               	.LVL271:
3467:switcherator.c ****         if (temp > 7) // if things got goofed up somehow 
 3823               		.loc 1 3467 0
 3824 1590 8830      		cpi r24,8
 3825 1592 9105      		cpc r25,__zero_reg__
 3826 1594 A105      		cpc r26,__zero_reg__
 3827 1596 B105      		cpc r27,__zero_reg__
 3828 1598 04F0      		brlt .+2
 3829 159a 00C0      		rjmp .L257
3468:switcherator.c ****             return;
3469:switcherator.c ****         ADMUX = temp; // which pin to check
 3830               		.loc 1 3469 0
 3831 159c 8093 7C00 		sts 124,r24
3470:switcherator.c ****         ADCSRA |= (1 << ADEN) | (1 << ADSC); // turn on ADC and start a conversion
 3832               		.loc 1 3470 0
 3833 15a0 8091 7A00 		lds r24,122
 3834               	.LVL272:
 3835 15a4 806C      		ori r24,lo8(-64)
 3836 15a6 8093 7A00 		sts 122,r24
 3837               	.L261:
3471:switcherator.c ****         loop_until_bit_is_set(ADCSRA, ADIF);
 3838               		.loc 1 3471 0 discriminator 1
 3839 15aa 8091 7A00 		lds r24,122
 3840 15ae 84FF      		sbrs r24,4
 3841 15b0 00C0      		rjmp .L261
3472:switcherator.c ****         temp = ADC;
 3842               		.loc 1 3472 0
 3843 15b2 2091 7800 		lds r18,120
 3844 15b6 3091 7900 		lds r19,120+1
 3845               	.LVL273:
3473:switcherator.c ****         temp = temp * 255;
 3846               		.loc 1 3473 0
 3847 15ba AFEF      		ldi r26,lo8(-1)
 3848 15bc B0E0      		ldi r27,0
 3849 15be 0E94 0000 		call __umulhisi3
 3850               	.LVL274:
3474:switcherator.c ****         temp = temp / 1024; // now its a number between 0 and 255;
 3851               		.loc 1 3474 0
 3852 15c2 2AE0      		ldi r18,10
 3853               		1:
 3854 15c4 9595      		asr r25
 3855 15c6 8795      		ror r24
 3856 15c8 7795      		ror r23
 3857 15ca 6795      		ror r22
 3858 15cc 2A95      		dec r18
 3859 15ce 01F4      		brne 1b
 3860               	.LVL275:
3475:switcherator.c ****         ADCSRA |= (1 << ADIF); // clear the ADC
 3861               		.loc 1 3475 0
 3862 15d0 2091 7A00 		lds r18,122
 3863 15d4 2061      		ori r18,lo8(16)
 3864 15d6 2093 7A00 		sts 122,r18
3476:switcherator.c ****         // see if we are turning on the switch
3477:switcherator.c ****         if (temp > low && temp < (high + 1)) {
 3865               		.loc 1 3477 0
 3866 15da 4C2C      		mov r4,r12
 3867 15dc 512C      		mov r5,__zero_reg__
 3868 15de 612C      		mov r6,__zero_reg__
 3869 15e0 712C      		mov r7,__zero_reg__
 3870 15e2 4616      		cp r4,r22
 3871 15e4 5706      		cpc r5,r23
 3872 15e6 6806      		cpc r6,r24
 3873 15e8 7906      		cpc r7,r25
 3874 15ea 04F0      		brlt .+2
 3875 15ec 00C0      		rjmp .L257
 3876               		.loc 1 3477 0 is_stmt 0 discriminator 1
 3877 15ee A985      		ldd r26,Y+9
 3878 15f0 BA85      		ldd r27,Y+10
 3879 15f2 1196      		adiw r26,1
 3880 15f4 9D01      		movw r18,r26
 3881 15f6 40E0      		ldi r20,0
 3882 15f8 50E0      		ldi r21,0
 3883               	.LVL276:
 3884 15fa 6217      		cp r22,r18
 3885 15fc 7307      		cpc r23,r19
 3886 15fe 8407      		cpc r24,r20
 3887 1600 9507      		cpc r25,r21
 3888 1602 04F0      		brlt .+2
 3889 1604 00C0      		rjmp .L257
3478:switcherator.c ****             // see if it is a PWM switch (not a program)
3479:switcherator.c ****             if (switchNumber < 128 && switchStuff[switchNumber] == 200) {
 3890               		.loc 1 3479 0 is_stmt 1
 3891 1606 0038      		cpi r16,-128
 3892 1608 1105      		cpc r17,__zero_reg__
 3893 160a 00F4      		brsh .L263
 3894               		.loc 1 3479 0 is_stmt 0 discriminator 1
 3895 160c F801      		movw r30,r16
 3896               	.LVL277:
 3897 160e E050      		subi r30,lo8(-(switchStuff))
 3898 1610 F040      		sbci r31,hi8(-(switchStuff))
 3899 1612 2081      		ld r18,Z
 3900 1614 283C      		cpi r18,lo8(-56)
 3901 1616 01F0      		breq .+2
 3902 1618 00C0      		rjmp .L294
3480:switcherator.c ****                 // this is a PWM so we're doing it based on the relative ADC value
3481:switcherator.c ****                 // see if we are using the whole range.
3482:switcherator.c ****                 if ((high - low) > 250) {
 3903               		.loc 1 3482 0 is_stmt 1
 3904 161a 4985      		ldd r20,Y+9
 3905 161c 5A85      		ldd r21,Y+10
 3906 161e 4E19      		sub r20,r14
 3907 1620 5F09      		sbc r21,r15
 3908 1622 4B3F      		cpi r20,-5
 3909 1624 5105      		cpc r21,__zero_reg__
 3910 1626 00F0      		brlo .+2
 3911 1628 00C0      		rjmp .L294
 3912               	.LVL278:
 3913               	.LBB23:
3483:switcherator.c ****                     pwmValue = temp;
3484:switcherator.c ****                 } else {
3485:switcherator.c ****                     // figure out what percentage between the values we are
3486:switcherator.c ****                     char range = high - low;
3487:switcherator.c ****                     temp = temp - low;
 3914               		.loc 1 3487 0
 3915 162a 9B01      		movw r18,r22
 3916 162c AC01      		movw r20,r24
 3917 162e 2419      		sub r18,r4
 3918 1630 3509      		sbc r19,r5
 3919 1632 4609      		sbc r20,r6
 3920 1634 5709      		sbc r21,r7
 3921               	.LVL279:
3488:switcherator.c ****                     temp = temp * 255;
 3922               		.loc 1 3488 0
 3923 1636 AFEF      		ldi r26,lo8(-1)
 3924 1638 B0E0      		ldi r27,0
 3925 163a 0E94 0000 		call __muluhisi3
 3926               	.LVL280:
3486:switcherator.c ****                     char range = high - low;
 3927               		.loc 1 3486 0
 3928 163e 2981      		ldd r18,Y+1
 3929 1640 2C19      		sub r18,r12
 3930               	.LVL281:
3489:switcherator.c ****                     temp = temp / range; // now we have a relative value between 0&255
 3931               		.loc 1 3489 0
 3932 1642 30E0      		ldi r19,0
 3933 1644 40E0      		ldi r20,0
 3934 1646 50E0      		ldi r21,0
 3935 1648 0E94 0000 		call __divmodsi4
 3936               	.LVL282:
3490:switcherator.c ****                     pwmValue = temp;
 3937               		.loc 1 3490 0
 3938 164c 822F      		mov r24,r18
 3939               	.LVL283:
3491:switcherator.c ****                     // see if we are changing RGB
3492:switcherator.c ****                     if (whichRGB & 4)
 3940               		.loc 1 3492 0
 3941 164e D2FC      		sbrc r13,2
3493:switcherator.c ****                         pwmValues[0] = pwmValue;
 3942               		.loc 1 3493 0
 3943 1650 2093 0000 		sts pwmValues,r18
 3944               	.L265:
3494:switcherator.c ****                     if (whichRGB & 2)
 3945               		.loc 1 3494 0
 3946 1654 D1FC      		sbrc r13,1
3495:switcherator.c ****                         pwmValues[1] = pwmValue;
 3947               		.loc 1 3495 0
 3948 1656 8093 0000 		sts pwmValues+1,r24
 3949               	.L266:
3496:switcherator.c ****                     if (whichRGB & 1)
 3950               		.loc 1 3496 0
 3951 165a D0FC      		sbrc r13,0
3497:switcherator.c ****                         pwmValues[2] = pwmValue;
 3952               		.loc 1 3497 0
 3953 165c 8093 0000 		sts pwmValues+2,r24
 3954               	.L267:
3498:switcherator.c ****                     if (whichRGB & 7) // if anything changed
 3955               		.loc 1 3498 0
 3956 1660 8D2D      		mov r24,r13
 3957 1662 8770      		andi r24,lo8(7)
 3958 1664 01F4      		brne .+2
 3959 1666 00C0      		rjmp .L294
3499:switcherator.c ****                         switchChanged = 1;
 3960               		.loc 1 3499 0
 3961 1668 81E0      		ldi r24,lo8(1)
 3962 166a 8093 0000 		sts switchChanged,r24
 3963 166e 00C0      		rjmp .L294
 3964               	.LVL284:
 3965               	.L263:
 3966 1670 E0E0      		ldi r30,lo8(timeLimits+8)
 3967 1672 F0E0      		ldi r31,hi8(timeLimits+8)
 3968               	.LVL285:
 3969               	.LBE23:
3439:switcherator.c **** void getInput(int inputNumber) {
 3970               		.loc 1 3439 0
 3971 1674 20E0      		ldi r18,0
 3972               	.LVL286:
 3973               	.L270:
3500:switcherator.c ****                 }
3501:switcherator.c ****             }
3502:switcherator.c ****             // k we set up PWM now make it so it switches on
3503:switcherator.c ****             if (switchNumber < 128) { // its a switch
3504:switcherator.c ****                 if (switchStatus[switchNumber] == 0) // the switch is off
3505:switcherator.c ****                     switchChanged = 1;
3506:switcherator.c ****                 if (switchStatus[switchNumber] < (weeklySeconds + duration))
3507:switcherator.c ****                     switchStatus[switchNumber] = (weeklySeconds + duration);
3508:switcherator.c ****             } else { // its a program;
3509:switcherator.c ****                 test = 0;
3510:switcherator.c ****                 // check and make sure we are within the time limits (eg dusk to dawn)
3511:switcherator.c ****                 // first if no time limits set up then ignore it
3512:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
3513:switcherator.c ****                     if (timeLimits[x][2] > 0)
 3974               		.loc 1 3513 0
 3975 1676 8081      		ld r24,Z
 3976 1678 9181      		ldd r25,Z+1
 3977 167a A281      		ldd r26,Z+2
 3978 167c B381      		ldd r27,Z+3
 3979 167e 892B      		or r24,r25
 3980 1680 8A2B      		or r24,r26
 3981 1682 8B2B      		or r24,r27
 3982 1684 01F0      		breq .L269
3514:switcherator.c ****                         test = 1;
 3983               		.loc 1 3514 0
 3984 1686 21E0      		ldi r18,lo8(1)
 3985               	.L269:
 3986               	.LVL287:
 3987 1688 3C96      		adiw r30,12
3512:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
 3988               		.loc 1 3512 0
 3989 168a 30E0      		ldi r19,hi8(timeLimits+56)
 3990 168c E030      		cpi r30,lo8(timeLimits+56)
 3991 168e F307      		cpc r31,r19
 3992 1690 01F4      		brne .L270
3515:switcherator.c ****                 }
3516:switcherator.c ****                 // no limits set up
3517:switcherator.c ****                 if (test == 0)
 3993               		.loc 1 3517 0
 3994 1692 2111      		cpse r18,__zero_reg__
 3995 1694 00C0      		rjmp .L271
3518:switcherator.c ****                     startTheProgram((switchNumber - 128), duration, 0);
 3996               		.loc 1 3518 0
 3997 1696 20E0      		ldi r18,0
 3998 1698 30E0      		ldi r19,0
 3999 169a A901      		movw r20,r18
 4000               	.LVL288:
 4001 169c 6B85      		ldd r22,Y+11
 4002 169e 7C85      		ldd r23,Y+12
 4003               	.LVL289:
 4004 16a0 C801      		movw r24,r16
 4005 16a2 8058      		subi r24,-128
 4006 16a4 9109      		sbc r25,__zero_reg__
 4007 16a6 0E94 0000 		call startTheProgram
 4008               	.LVL290:
 4009               	.L271:
 4010 16aa 80E0      		ldi r24,lo8(timeLimits)
 4011 16ac E82E      		mov r14,r24
 4012 16ae 80E0      		ldi r24,hi8(timeLimits)
 4013 16b0 F82E      		mov r15,r24
 4014               	.LVL291:
3519:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
3520:switcherator.c ****                     startTime = timeLimits[x][0];
3521:switcherator.c ****                     stopTime = timeLimits[x][1];
3522:switcherator.c ****                     // deal with nights that cross midnight
3523:switcherator.c ****                     if (stopTime < startTime) {
3524:switcherator.c ****                         temp = dow;
3525:switcherator.c ****                         // weekly seconds resets at the end of the week. so do lots of 9
3526:switcherator.c ****                         if (weeklySeconds <= (stopTime + daySeconds)) {
3527:switcherator.c ****                             // k this is dow + 1
3528:switcherator.c ****                             if (temp == 0)
3529:switcherator.c ****                                 temp = 6;
3530:switcherator.c ****                             else
3531:switcherator.c ****                                 temp--;
3532:switcherator.c ****                             if (timeLimits[x][2] & (1 << temp))
3533:switcherator.c ****                                 startTheProgram((switchNumber - 128), duration, 0);
3534:switcherator.c ****                         } else if (weeklySeconds >= (startTime + daySeconds)) {
3535:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
3536:switcherator.c ****                                 startTheProgram((switchNumber - 128), duration, 0);
3537:switcherator.c ****                         }
3538:switcherator.c ****                     } else {
3539:switcherator.c ****                         if (weeklySeconds >= (startTime + daySeconds) &&
3540:switcherator.c ****                                 weeklySeconds <= (stopTime + daySeconds)) {
3541:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
 4015               		.loc 1 3541 0 discriminator 1
 4016 16b2 CC24      		clr r12
 4017 16b4 C394      		inc r12
 4018 16b6 D12C      		mov r13,__zero_reg__
3542:switcherator.c ****                                 startTheProgram((switchNumber - 128), duration, 0);
 4019               		.loc 1 3542 0 discriminator 1
 4020 16b8 0058      		subi r16,-128
 4021 16ba 1109      		sbc r17,__zero_reg__
 4022               	.LVL292:
 4023               	.L276:
3520:switcherator.c ****                     startTime = timeLimits[x][0];
 4024               		.loc 1 3520 0
 4025 16bc D701      		movw r26,r14
 4026 16be 4D90      		ld r4,X+
 4027 16c0 5D90      		ld r5,X+
 4028 16c2 6D90      		ld r6,X+
 4029 16c4 7C90      		ld r7,X
 4030 16c6 1397      		sbiw r26,3
 4031               	.LVL293:
3521:switcherator.c ****                     stopTime = timeLimits[x][1];
 4032               		.loc 1 3521 0
 4033 16c8 1496      		adiw r26,4
 4034 16ca 4D91      		ld r20,X+
 4035 16cc 5D91      		ld r21,X+
 4036 16ce 6D91      		ld r22,X+
 4037 16d0 7C91      		ld r23,X
 4038 16d2 1797      		sbiw r26,4+3
 4039               	.LVL294:
 4040 16d4 8091 0000 		lds r24,weeklySeconds
 4041 16d8 9091 0000 		lds r25,weeklySeconds+1
 4042 16dc A091 0000 		lds r26,weeklySeconds+2
 4043 16e0 B091 0000 		lds r27,weeklySeconds+3
3523:switcherator.c ****                     if (stopTime < startTime) {
 4044               		.loc 1 3523 0
 4045 16e4 4415      		cp r20,r4
 4046 16e6 5505      		cpc r21,r5
 4047 16e8 6605      		cpc r22,r6
 4048 16ea 7705      		cpc r23,r7
 4049 16ec 04F0      		brlt .+2
 4050 16ee 00C0      		rjmp .L272
3524:switcherator.c ****                         temp = dow;
 4051               		.loc 1 3524 0
 4052 16f0 2091 0000 		lds r18,dow
 4053 16f4 3091 0000 		lds r19,dow+1
 4054               	.LVL295:
3526:switcherator.c ****                         if (weeklySeconds <= (stopTime + daySeconds)) {
 4055               		.loc 1 3526 0
 4056 16f8 480D      		add r20,r8
 4057 16fa 591D      		adc r21,r9
 4058 16fc 6A1D      		adc r22,r10
 4059 16fe 7B1D      		adc r23,r11
 4060               	.LVL296:
 4061 1700 4817      		cp r20,r24
 4062 1702 5907      		cpc r21,r25
 4063 1704 6A07      		cpc r22,r26
 4064 1706 7B07      		cpc r23,r27
 4065 1708 00F0      		brlo .L273
3524:switcherator.c ****                         temp = dow;
 4066               		.loc 1 3524 0
 4067 170a C901      		movw r24,r18
 4068 170c A0E0      		ldi r26,0
 4069 170e B0E0      		ldi r27,0
3528:switcherator.c ****                             if (temp == 0)
 4070               		.loc 1 3528 0
 4071 1710 0097      		sbiw r24,0
 4072 1712 A105      		cpc r26,__zero_reg__
 4073 1714 B105      		cpc r27,__zero_reg__
 4074 1716 01F0      		breq .L296
3531:switcherator.c ****                                 temp--;
 4075               		.loc 1 3531 0
 4076 1718 0197      		sbiw r24,1
 4077 171a A109      		sbc r26,__zero_reg__
 4078 171c B109      		sbc r27,__zero_reg__
 4079               	.LVL297:
 4080 171e 00C0      		rjmp .L274
 4081               	.LVL298:
 4082               	.L296:
3529:switcherator.c ****                                 temp = 6;
 4083               		.loc 1 3529 0
 4084 1720 86E0      		ldi r24,lo8(6)
 4085 1722 90E0      		ldi r25,0
 4086 1724 A0E0      		ldi r26,0
 4087 1726 B0E0      		ldi r27,0
 4088               	.LVL299:
 4089               	.L274:
3532:switcherator.c ****                             if (timeLimits[x][2] & (1 << temp))
 4090               		.loc 1 3532 0
 4091 1728 9601      		movw r18,r12
 4092 172a 00C0      		rjmp 2f
 4093               		1:
 4094 172c 220F      		lsl r18
 4095 172e 331F      		rol r19
 4096               		2:
 4097 1730 8A95      		dec r24
 4098 1732 02F4      		brpl 1b
 4099 1734 A901      		movw r20,r18
 4100 1736 6627      		clr r22
 4101 1738 57FD      		sbrc r21,7
 4102 173a 6095      		com r22
 4103 173c 762F      		mov r23,r22
 4104 173e F701      		movw r30,r14
 4105 1740 8085      		ldd r24,Z+8
 4106 1742 9185      		ldd r25,Z+9
 4107 1744 A285      		ldd r26,Z+10
 4108 1746 B385      		ldd r27,Z+11
 4109 1748 4823      		and r20,r24
 4110 174a 5923      		and r21,r25
 4111 174c 6A23      		and r22,r26
 4112 174e 7B23      		and r23,r27
 4113 1750 452B      		or r20,r21
 4114 1752 462B      		or r20,r22
 4115 1754 472B      		or r20,r23
 4116 1756 01F4      		brne .+2
 4117 1758 00C0      		rjmp .L275
 4118 175a 00C0      		rjmp .L348
 4119               	.LVL300:
 4120               	.L273:
3534:switcherator.c ****                         } else if (weeklySeconds >= (startTime + daySeconds)) {
 4121               		.loc 1 3534 0
 4122 175c 480C      		add r4,r8
 4123 175e 591C      		adc r5,r9
 4124 1760 6A1C      		adc r6,r10
 4125 1762 7B1C      		adc r7,r11
 4126               	.LVL301:
 4127 1764 8415      		cp r24,r4
 4128 1766 9505      		cpc r25,r5
 4129 1768 A605      		cpc r26,r6
 4130 176a B705      		cpc r27,r7
 4131 176c 00F0      		brlo .L275
3535:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
 4132               		.loc 1 3535 0
 4133 176e C601      		movw r24,r12
 4134 1770 00C0      		rjmp 2f
 4135               		1:
 4136 1772 880F      		lsl r24
 4137 1774 991F      		rol r25
 4138               		2:
 4139 1776 2A95      		dec r18
 4140 1778 02F4      		brpl 1b
 4141 177a 00C0      		rjmp .L352
 4142               	.LVL302:
 4143               	.L272:
3539:switcherator.c ****                         if (weeklySeconds >= (startTime + daySeconds) &&
 4144               		.loc 1 3539 0
 4145 177c 480C      		add r4,r8
 4146 177e 591C      		adc r5,r9
 4147 1780 6A1C      		adc r6,r10
 4148 1782 7B1C      		adc r7,r11
 4149               	.LVL303:
 4150 1784 8415      		cp r24,r4
 4151 1786 9505      		cpc r25,r5
 4152 1788 A605      		cpc r26,r6
 4153 178a B705      		cpc r27,r7
 4154 178c 00F0      		brlo .L275
3540:switcherator.c ****                                 weeklySeconds <= (stopTime + daySeconds)) {
 4155               		.loc 1 3540 0 discriminator 1
 4156 178e 480D      		add r20,r8
 4157 1790 591D      		adc r21,r9
 4158 1792 6A1D      		adc r22,r10
 4159 1794 7B1D      		adc r23,r11
 4160               	.LVL304:
3539:switcherator.c ****                         if (weeklySeconds >= (startTime + daySeconds) &&
 4161               		.loc 1 3539 0 discriminator 1
 4162 1796 4817      		cp r20,r24
 4163 1798 5907      		cpc r21,r25
 4164 179a 6A07      		cpc r22,r26
 4165 179c 7B07      		cpc r23,r27
 4166 179e 00F0      		brlo .L275
3541:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
 4167               		.loc 1 3541 0
 4168 17a0 C601      		movw r24,r12
 4169 17a2 0090 0000 		lds r0,dow
 4170 17a6 00C0      		rjmp 2f
 4171               		1:
 4172 17a8 880F      		lsl r24
 4173 17aa 991F      		rol r25
 4174               		2:
 4175 17ac 0A94      		dec r0
 4176 17ae 02F4      		brpl 1b
 4177               	.L352:
 4178 17b0 AA27      		clr r26
 4179 17b2 97FD      		sbrc r25,7
 4180 17b4 A095      		com r26
 4181 17b6 BA2F      		mov r27,r26
 4182 17b8 F701      		movw r30,r14
 4183 17ba 4085      		ldd r20,Z+8
 4184 17bc 5185      		ldd r21,Z+9
 4185 17be 6285      		ldd r22,Z+10
 4186 17c0 7385      		ldd r23,Z+11
 4187 17c2 8423      		and r24,r20
 4188 17c4 9523      		and r25,r21
 4189 17c6 A623      		and r26,r22
 4190 17c8 B723      		and r27,r23
 4191 17ca 892B      		or r24,r25
 4192 17cc 8A2B      		or r24,r26
 4193 17ce 8B2B      		or r24,r27
 4194 17d0 01F0      		breq .L275
 4195               	.L348:
 4196               		.loc 1 3542 0
 4197 17d2 20E0      		ldi r18,0
 4198 17d4 30E0      		ldi r19,0
 4199 17d6 A901      		movw r20,r18
 4200 17d8 6B85      		ldd r22,Y+11
 4201 17da 7C85      		ldd r23,Y+12
 4202 17dc C801      		movw r24,r16
 4203 17de 0E94 0000 		call startTheProgram
 4204               	.LVL305:
 4205               	.L275:
 4206 17e2 FCE0      		ldi r31,12
 4207 17e4 EF0E      		add r14,r31
 4208 17e6 F11C      		adc r15,__zero_reg__
3519:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
 4209               		.loc 1 3519 0
 4210 17e8 20E0      		ldi r18,lo8(timeLimits+48)
 4211 17ea E216      		cp r14,r18
 4212 17ec 20E0      		ldi r18,hi8(timeLimits+48)
 4213 17ee F206      		cpc r15,r18
 4214 17f0 01F0      		breq .+2
 4215 17f2 00C0      		rjmp .L276
 4216 17f4 00C0      		rjmp .L257
 4217               	.LVL306:
 4218               	.L258:
 4219               	.LBB24:
3543:switcherator.c ****                         }
3544:switcherator.c ****                     }
3545:switcherator.c ****                 } // end of the for
3546:switcherator.c ****             }
3547:switcherator.c ****         }
3548:switcherator.c **** 
3549:switcherator.c ****     } else {
3550:switcherator.c ****         // this is a digital input
3551:switcherator.c ****         // value of 255 (default) means nothing programmed
3552:switcherator.c ****         // value of 0-15 = PORTA, 16-31 = PORTB, 32-47 = PORTC, 
3553:switcherator.c ****         // 48-63 = PORTD, 64-79 = PORTE, 80-95 = PORTF, 96-112 = PORTG        
3554:switcherator.c ****         // figure out what we are dealing with and check it.
3555:switcherator.c ****         temp = outputNum;
 4220               		.loc 1 3555 0
 4221 17f6 862F      		mov r24,r22
 4222 17f8 90E0      		ldi r25,0
 4223 17fa A0E0      		ldi r26,0
 4224 17fc B0E0      		ldi r27,0
 4225               	.LVL307:
3556:switcherator.c ****         if (temp > 15 && temp < 32) {
 4226               		.loc 1 3556 0
 4227 17fe AC01      		movw r20,r24
 4228 1800 BD01      		movw r22,r26
 4229               	.LVL308:
 4230 1802 4051      		subi r20,16
 4231 1804 5109      		sbc r21,__zero_reg__
 4232 1806 6109      		sbc r22,__zero_reg__
 4233 1808 7109      		sbc r23,__zero_reg__
 4234 180a 4031      		cpi r20,16
 4235 180c 5105      		cpc r21,__zero_reg__
 4236 180e 6105      		cpc r22,__zero_reg__
 4237 1810 7105      		cpc r23,__zero_reg__
 4238 1812 00F4      		brsh .L277
 4239               	.LVL309:
3557:switcherator.c ****             thisPin = &PINB;
3558:switcherator.c ****             temp -= 16;
 4240               		.loc 1 3558 0
 4241 1814 CB01      		movw r24,r22
 4242 1816 BA01      		movw r22,r20
 4243               	.LVL310:
3557:switcherator.c ****             thisPin = &PINB;
 4244               		.loc 1 3557 0
 4245 1818 B3E2      		ldi r27,lo8(35)
 4246 181a CB2E      		mov r12,r27
 4247 181c D12C      		mov r13,__zero_reg__
 4248 181e 00C0      		rjmp .L278
 4249               	.LVL311:
 4250               	.L277:
3559:switcherator.c **** #ifdef PINA
3560:switcherator.c ****         } else if (temp < 16) {
3561:switcherator.c ****             thisPin = &PINA;
3562:switcherator.c ****             temp -= 0;
3563:switcherator.c **** #endif
3564:switcherator.c **** #ifdef PINC
3565:switcherator.c ****         } else if (temp < 48) {
 4251               		.loc 1 3565 0
 4252 1820 8033      		cpi r24,48
 4253 1822 9105      		cpc r25,__zero_reg__
 4254 1824 A105      		cpc r26,__zero_reg__
 4255 1826 B105      		cpc r27,__zero_reg__
 4256 1828 04F4      		brge .L279
 4257               	.LVL312:
3566:switcherator.c ****             thisPin = &PINC;
3567:switcherator.c ****             temp -= 32;
 4258               		.loc 1 3567 0
 4259 182a BC01      		movw r22,r24
 4260 182c CD01      		movw r24,r26
 4261               	.LVL313:
 4262 182e 6052      		subi r22,32
 4263 1830 7109      		sbc r23,__zero_reg__
 4264 1832 8109      		sbc r24,__zero_reg__
 4265 1834 9109      		sbc r25,__zero_reg__
 4266               	.LVL314:
3566:switcherator.c ****             thisPin = &PINC;
 4267               		.loc 1 3566 0
 4268 1836 A6E2      		ldi r26,lo8(38)
 4269 1838 CA2E      		mov r12,r26
 4270 183a D12C      		mov r13,__zero_reg__
 4271 183c 00C0      		rjmp .L278
 4272               	.LVL315:
 4273               	.L279:
3568:switcherator.c **** #endif
3569:switcherator.c **** #ifdef PIND
3570:switcherator.c ****         } else if (temp < 64) {
 4274               		.loc 1 3570 0
 4275 183e 8034      		cpi r24,64
 4276 1840 9105      		cpc r25,__zero_reg__
 4277 1842 A105      		cpc r26,__zero_reg__
 4278 1844 B105      		cpc r27,__zero_reg__
 4279 1846 04F0      		brlt .+2
 4280 1848 00C0      		rjmp .L257
 4281               	.LVL316:
3571:switcherator.c ****             thisPin = &PIND;
3572:switcherator.c ****             temp -= 48;
 4282               		.loc 1 3572 0
 4283 184a BC01      		movw r22,r24
 4284 184c CD01      		movw r24,r26
 4285               	.LVL317:
 4286 184e 6053      		subi r22,48
 4287 1850 7109      		sbc r23,__zero_reg__
 4288 1852 8109      		sbc r24,__zero_reg__
 4289 1854 9109      		sbc r25,__zero_reg__
 4290               	.LVL318:
3571:switcherator.c ****             thisPin = &PIND;
 4291               		.loc 1 3571 0
 4292 1856 F9E2      		ldi r31,lo8(41)
 4293 1858 CF2E      		mov r12,r31
 4294 185a D12C      		mov r13,__zero_reg__
 4295               	.LVL319:
 4296               	.L278:
3573:switcherator.c **** #endif
3574:switcherator.c **** #ifdef PINE
3575:switcherator.c ****         } else if (temp < 80) {
3576:switcherator.c ****             thisPin = &PINE;
3577:switcherator.c ****             temp -= 64;
3578:switcherator.c **** #endif
3579:switcherator.c **** #ifdef PINF
3580:switcherator.c ****         } else if (temp < 96) {
3581:switcherator.c ****             thisPin = &PINF;
3582:switcherator.c ****             temp -= 80;
3583:switcherator.c **** #endif
3584:switcherator.c **** #ifdef PING
3585:switcherator.c ****         } else if (temp < 112) {
3586:switcherator.c ****             thisPin = &PING;
3587:switcherator.c ****             temp -= 96;
3588:switcherator.c **** #endif
3589:switcherator.c **** #ifdef PINH
3590:switcherator.c ****         } else if (temp < 128) {
3591:switcherator.c ****             thisPin = &PINH;
3592:switcherator.c ****             temp -= 112;
3593:switcherator.c **** #endif
3594:switcherator.c **** #ifdef PINI
3595:switcherator.c ****         } else if (temp < 144) {
3596:switcherator.c ****             thisPin = &PINI;
3597:switcherator.c ****             temp -= 128;
3598:switcherator.c **** #endif
3599:switcherator.c ****         } else {
3600:switcherator.c ****             // something went wrong.  Who cares.
3601:switcherator.c ****             return;
3602:switcherator.c ****         }
3603:switcherator.c ****         // if we want the input to be high then low = 0.  If we want it to be 
3604:switcherator.c ****         // low to be on then low = 255;
3605:switcherator.c ****         temp = temp / 2;
 4297               		.loc 1 3605 0
 4298 185c 22E0      		ldi r18,lo8(2)
 4299 185e 30E0      		ldi r19,0
 4300 1860 40E0      		ldi r20,0
 4301 1862 50E0      		ldi r21,0
 4302 1864 0E94 0000 		call __divmodsi4
 4303               	.LVL320:
3606:switcherator.c ****         if (temp > 7) {
 4304               		.loc 1 3606 0
 4305 1868 2830      		cpi r18,8
 4306 186a 3105      		cpc r19,__zero_reg__
 4307 186c 4105      		cpc r20,__zero_reg__
 4308 186e 5105      		cpc r21,__zero_reg__
 4309 1870 04F0      		brlt .+2
 4310 1872 00C0      		rjmp .L257
3607:switcherator.c ****             return; // something wrong again
3608:switcherator.c ****         }
3609:switcherator.c ****         int pinsOn = *thisPin;
 4311               		.loc 1 3609 0
 4312 1874 D601      		movw r26,r12
 4313 1876 8C91      		ld r24,X
 4314               	.LVL321:
 4315 1878 90E0      		ldi r25,0
3610:switcherator.c ****         char yeaOurInputIsOn = 0;
3611:switcherator.c ****         if (pinsOn & (1 << temp)) {
 4316               		.loc 1 3611 0
 4317 187a 00C0      		rjmp 2f
 4318               		1:
 4319 187c 9595      		asr r25
 4320 187e 8795      		ror r24
 4321               		2:
 4322 1880 2A95      		dec r18
 4323 1882 02F4      		brpl 1b
 4324               	.LVL322:
 4325 1884 80FF      		sbrs r24,0
 4326 1886 00C0      		rjmp .L280
3612:switcherator.c ****             // pin is high
3613:switcherator.c ****             if (low == 0)
 4327               		.loc 1 3613 0
 4328 1888 EF28      		or r14,r15
 4329 188a 01F4      		brne .+2
 4330 188c 00C0      		rjmp .L281
 4331 188e 00C0      		rjmp .L257
 4332               	.L280:
3614:switcherator.c ****                 yeaOurInputIsOn = 1;
3615:switcherator.c ****         } else {
3616:switcherator.c ****             // pin is low
3617:switcherator.c ****             if (low == 255)
 4333               		.loc 1 3617 0
 4334 1890 BFEF      		ldi r27,-1
 4335 1892 EB16      		cp r14,r27
 4336 1894 F104      		cpc r15,__zero_reg__
 4337 1896 01F0      		breq .+2
 4338 1898 00C0      		rjmp .L257
 4339 189a 00C0      		rjmp .L281
 4340               	.LVL323:
 4341               	.L294:
3618:switcherator.c ****                 yeaOurInputIsOn = 1;
3619:switcherator.c ****         }
3620:switcherator.c ****         if (yeaOurInputIsOn == 1) {
3621:switcherator.c ****             if (switchNumber < 128) { // this is a switch
3622:switcherator.c ****                 if (switchStatus[switchNumber] == 0) // the switch is off
 4342               		.loc 1 3622 0
 4343 189c 000F      		lsl r16
 4344 189e 111F      		rol r17
 4345 18a0 000F      		lsl r16
 4346 18a2 111F      		rol r17
 4347               	.LVL324:
 4348 18a4 F801      		movw r30,r16
 4349 18a6 E050      		subi r30,lo8(-(switchStatus))
 4350 18a8 F040      		sbci r31,hi8(-(switchStatus))
 4351 18aa 4081      		ld r20,Z
 4352 18ac 5181      		ldd r21,Z+1
 4353 18ae 6281      		ldd r22,Z+2
 4354 18b0 7381      		ldd r23,Z+3
 4355 18b2 4115      		cp r20,__zero_reg__
 4356 18b4 5105      		cpc r21,__zero_reg__
 4357 18b6 6105      		cpc r22,__zero_reg__
 4358 18b8 7105      		cpc r23,__zero_reg__
 4359 18ba 01F4      		brne .L282
3623:switcherator.c ****                     switchChanged = 1;
 4360               		.loc 1 3623 0
 4361 18bc 81E0      		ldi r24,lo8(1)
 4362 18be 8093 0000 		sts switchChanged,r24
 4363               	.L282:
3624:switcherator.c ****                 if ((switchStatus[switchNumber]) < (weeklySeconds + duration))
 4364               		.loc 1 3624 0
 4365 18c2 8091 0000 		lds r24,weeklySeconds
 4366 18c6 9091 0000 		lds r25,weeklySeconds+1
 4367 18ca A091 0000 		lds r26,weeklySeconds+2
 4368 18ce B091 0000 		lds r27,weeklySeconds+3
 4369 18d2 EB85      		ldd r30,Y+11
 4370 18d4 FC85      		ldd r31,Y+12
 4371 18d6 8E0F      		add r24,r30
 4372 18d8 9F1F      		adc r25,r31
 4373 18da A11D      		adc r26,__zero_reg__
 4374 18dc B11D      		adc r27,__zero_reg__
 4375 18de 4817      		cp r20,r24
 4376 18e0 5907      		cpc r21,r25
 4377 18e2 6A07      		cpc r22,r26
 4378 18e4 7B07      		cpc r23,r27
 4379 18e6 00F0      		brlo .+2
 4380 18e8 00C0      		rjmp .L257
3625:switcherator.c ****                     switchStatus[switchNumber] = (weeklySeconds + duration);
 4381               		.loc 1 3625 0
 4382 18ea F801      		movw r30,r16
 4383 18ec E050      		subi r30,lo8(-(switchStatus))
 4384 18ee F040      		sbci r31,hi8(-(switchStatus))
 4385 18f0 8083      		st Z,r24
 4386 18f2 9183      		std Z+1,r25
 4387 18f4 A283      		std Z+2,r26
 4388 18f6 B383      		std Z+3,r27
 4389 18f8 00C0      		rjmp .L257
 4390               	.LVL325:
 4391               	.L284:
3626:switcherator.c ****             } else { // its a program;
3627:switcherator.c ****                 test = 0;
3628:switcherator.c ****                 // check and make sure we are within the time limits (eg dusk to dawn)
3629:switcherator.c ****                 // first if no time limits set up then ignore it
3630:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
3631:switcherator.c ****                     if (timeLimits[x][2] > 0)
 4392               		.loc 1 3631 0
 4393 18fa 8081      		ld r24,Z
 4394 18fc 9181      		ldd r25,Z+1
 4395 18fe A281      		ldd r26,Z+2
 4396 1900 B381      		ldd r27,Z+3
 4397 1902 892B      		or r24,r25
 4398 1904 8A2B      		or r24,r26
 4399 1906 8B2B      		or r24,r27
 4400 1908 01F0      		breq .L283
3632:switcherator.c ****                         test = 1;
 4401               		.loc 1 3632 0
 4402 190a 21E0      		ldi r18,lo8(1)
 4403               	.L283:
 4404               	.LVL326:
 4405 190c 3C96      		adiw r30,12
3630:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
 4406               		.loc 1 3630 0
 4407 190e 30E0      		ldi r19,hi8(timeLimits+56)
 4408 1910 E030      		cpi r30,lo8(timeLimits+56)
 4409 1912 F307      		cpc r31,r19
 4410 1914 01F4      		brne .L284
3633:switcherator.c ****                 }
3634:switcherator.c ****                 // no limits set up
3635:switcherator.c ****                 if (test == 0)
 4411               		.loc 1 3635 0
 4412 1916 2111      		cpse r18,__zero_reg__
 4413 1918 00C0      		rjmp .L285
3636:switcherator.c ****                     startTheProgram((switchNumber - 128), duration, 0);
 4414               		.loc 1 3636 0
 4415 191a 20E0      		ldi r18,0
 4416 191c 30E0      		ldi r19,0
 4417 191e A901      		movw r20,r18
 4418               	.LVL327:
 4419 1920 6B85      		ldd r22,Y+11
 4420 1922 7C85      		ldd r23,Y+12
 4421 1924 C801      		movw r24,r16
 4422 1926 8058      		subi r24,-128
 4423 1928 9109      		sbc r25,__zero_reg__
 4424 192a 0E94 0000 		call startTheProgram
 4425               	.LVL328:
 4426               	.L285:
3637:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
3638:switcherator.c ****                     startTime = timeLimits[x][0];
3639:switcherator.c ****                     stopTime = timeLimits[x][1];
3640:switcherator.c ****                     // deal with nights that cross midnight
3641:switcherator.c ****                     if (stopTime < startTime) {
3642:switcherator.c ****                         temp = dow;
3643:switcherator.c ****                         // weekly seconds resets at the end of the week. so do lots of 9
3644:switcherator.c ****                         if (weeklySeconds <= (stopTime + daySeconds)) {
3645:switcherator.c ****                             // k this is dow + 1
3646:switcherator.c ****                             if (temp == 0)
3647:switcherator.c ****                                 temp = 6;
3648:switcherator.c ****                             else
3649:switcherator.c ****                                 temp--;
 4427               		.loc 1 3649 0 discriminator 1
 4428 192e D301      		movw r26,r6
 4429 1930 C201      		movw r24,r4
 4430 1932 0197      		sbiw r24,1
 4431 1934 A109      		sbc r26,__zero_reg__
 4432 1936 B109      		sbc r27,__zero_reg__
3650:switcherator.c ****                             if (timeLimits[x][2] & (1 << temp))
 4433               		.loc 1 3650 0 discriminator 1
 4434 1938 4528      		or r4,r5
 4435 193a 4628      		or r4,r6
 4436 193c 4728      		or r4,r7
 4437 193e 01F4      		brne .L286
 4438 1940 76E0      		ldi r23,lo8(6)
 4439 1942 472E      		mov r4,r23
 4440 1944 512C      		mov r5,__zero_reg__
 4441 1946 612C      		mov r6,__zero_reg__
 4442 1948 712C      		mov r7,__zero_reg__
 4443 194a 00C0      		rjmp .L287
 4444               	.L286:
 4445 194c 2C01      		movw r4,r24
 4446 194e 3D01      		movw r6,r26
 4447               	.L287:
 4448 1950 81E0      		ldi r24,lo8(1)
 4449 1952 90E0      		ldi r25,0
 4450 1954 AC01      		movw r20,r24
 4451 1956 00C0      		rjmp 2f
 4452               		1:
 4453 1958 440F      		lsl r20
 4454 195a 551F      		rol r21
 4455               		2:
 4456 195c 4A94      		dec r4
 4457 195e 02F4      		brpl 1b
 4458 1960 9A01      		movw r18,r20
 4459 1962 4427      		clr r20
 4460 1964 37FD      		sbrc r19,7
 4461 1966 4095      		com r20
 4462 1968 542F      		mov r21,r20
 4463 196a 2983      		std Y+1,r18
 4464 196c 3A83      		std Y+2,r19
 4465 196e 4B83      		std Y+3,r20
 4466 1970 5C83      		std Y+4,r21
3651:switcherator.c ****                                 startTheProgram((switchNumber - 128), duration, 0);
3652:switcherator.c ****                         } else if (weeklySeconds >= (startTime + daySeconds)) {
3653:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
 4467               		.loc 1 3653 0 discriminator 1
 4468 1972 2C01      		movw r4,r24
 4469 1974 00C0      		rjmp 2f
 4470               		1:
 4471 1976 440C      		lsl r4
 4472 1978 551C      		rol r5
 4473               		2:
 4474 197a 2A94      		dec r2
 4475 197c 02F4      		brpl 1b
 4476 197e 6624      		clr r6
 4477 1980 57FC      		sbrc r5,7
 4478 1982 6094      		com r6
 4479 1984 762C      		mov r7,r6
 4480 1986 60E0      		ldi r22,lo8(timeLimits)
 4481 1988 E62E      		mov r14,r22
 4482 198a 60E0      		ldi r22,hi8(timeLimits)
 4483 198c F62E      		mov r15,r22
 4484               	.LVL329:
3654:switcherator.c ****                                 startTheProgram((switchNumber - 128), duration, 0);
3655:switcherator.c ****                         }
3656:switcherator.c ****                     } else {
3657:switcherator.c ****                         if (weeklySeconds >= (startTime + daySeconds) &&
3658:switcherator.c ****                                 weeklySeconds <= (stopTime + daySeconds)) {
3659:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
3660:switcherator.c ****                                 startTheProgram((switchNumber - 128), duration, 0);
 4485               		.loc 1 3660 0 discriminator 1
 4486 198e 6801      		movw r12,r16
 4487               	.LVL330:
 4488 1990 30E8      		ldi r19,-128
 4489 1992 C31A      		sub r12,r19
 4490 1994 D108      		sbc r13,__zero_reg__
 4491               	.LVL331:
 4492               	.L291:
3638:switcherator.c ****                     startTime = timeLimits[x][0];
 4493               		.loc 1 3638 0
 4494 1996 D701      		movw r26,r14
 4495 1998 8D91      		ld r24,X+
 4496 199a 9D91      		ld r25,X+
 4497 199c 0D90      		ld __tmp_reg__,X+
 4498 199e BC91      		ld r27,X
 4499 19a0 A02D      		mov r26,__tmp_reg__
 4500 19a2 8D83      		std Y+5,r24
 4501 19a4 9E83      		std Y+6,r25
 4502 19a6 AF83      		std Y+7,r26
 4503 19a8 B887      		std Y+8,r27
 4504               	.LVL332:
3639:switcherator.c ****                     stopTime = timeLimits[x][1];
 4505               		.loc 1 3639 0
 4506 19aa F701      		movw r30,r14
 4507 19ac 4481      		ldd r20,Z+4
 4508 19ae 5581      		ldd r21,Z+5
 4509 19b0 6681      		ldd r22,Z+6
 4510 19b2 7781      		ldd r23,Z+7
 4511               	.LVL333:
 4512 19b4 8091 0000 		lds r24,weeklySeconds
 4513 19b8 9091 0000 		lds r25,weeklySeconds+1
 4514 19bc A091 0000 		lds r26,weeklySeconds+2
 4515 19c0 B091 0000 		lds r27,weeklySeconds+3
 4516               	.LVL334:
3641:switcherator.c ****                     if (stopTime < startTime) {
 4517               		.loc 1 3641 0
 4518 19c4 0D81      		ldd r16,Y+5
 4519 19c6 1E81      		ldd r17,Y+6
 4520 19c8 2F81      		ldd r18,Y+7
 4521 19ca 3885      		ldd r19,Y+8
 4522 19cc 4017      		cp r20,r16
 4523 19ce 5107      		cpc r21,r17
 4524 19d0 6207      		cpc r22,r18
 4525 19d2 7307      		cpc r23,r19
 4526 19d4 04F4      		brge .L288
3644:switcherator.c ****                         if (weeklySeconds <= (stopTime + daySeconds)) {
 4527               		.loc 1 3644 0
 4528 19d6 480D      		add r20,r8
 4529 19d8 591D      		adc r21,r9
 4530 19da 6A1D      		adc r22,r10
 4531 19dc 7B1D      		adc r23,r11
 4532               	.LVL335:
 4533 19de 4817      		cp r20,r24
 4534 19e0 5907      		cpc r21,r25
 4535 19e2 6A07      		cpc r22,r26
 4536 19e4 7B07      		cpc r23,r27
 4537 19e6 00F0      		brlo .L289
3650:switcherator.c ****                             if (timeLimits[x][2] & (1 << temp))
 4538               		.loc 1 3650 0
 4539 19e8 8085      		ldd r24,Z+8
 4540 19ea 9185      		ldd r25,Z+9
 4541 19ec A285      		ldd r26,Z+10
 4542 19ee B385      		ldd r27,Z+11
 4543 19f0 2981      		ldd r18,Y+1
 4544 19f2 3A81      		ldd r19,Y+2
 4545 19f4 4B81      		ldd r20,Y+3
 4546 19f6 5C81      		ldd r21,Y+4
 4547 19f8 8223      		and r24,r18
 4548 19fa 9323      		and r25,r19
 4549 19fc A423      		and r26,r20
 4550 19fe B523      		and r27,r21
 4551 1a00 00C0      		rjmp .L355
 4552               	.L289:
3652:switcherator.c ****                         } else if (weeklySeconds >= (startTime + daySeconds)) {
 4553               		.loc 1 3652 0
 4554 1a02 4D81      		ldd r20,Y+5
 4555 1a04 5E81      		ldd r21,Y+6
 4556 1a06 6F81      		ldd r22,Y+7
 4557 1a08 7885      		ldd r23,Y+8
 4558 1a0a 480D      		add r20,r8
 4559 1a0c 591D      		adc r21,r9
 4560 1a0e 6A1D      		adc r22,r10
 4561 1a10 7B1D      		adc r23,r11
 4562 1a12 8417      		cp r24,r20
 4563 1a14 9507      		cpc r25,r21
 4564 1a16 A607      		cpc r26,r22
 4565 1a18 B707      		cpc r27,r23
 4566 1a1a 00F0      		brlo .L290
 4567 1a1c 00C0      		rjmp .L357
 4568               	.LVL336:
 4569               	.L288:
3657:switcherator.c ****                         if (weeklySeconds >= (startTime + daySeconds) &&
 4570               		.loc 1 3657 0
 4571 1a1e 0D81      		ldd r16,Y+5
 4572 1a20 1E81      		ldd r17,Y+6
 4573 1a22 2F81      		ldd r18,Y+7
 4574 1a24 3885      		ldd r19,Y+8
 4575 1a26 080D      		add r16,r8
 4576 1a28 191D      		adc r17,r9
 4577 1a2a 2A1D      		adc r18,r10
 4578 1a2c 3B1D      		adc r19,r11
 4579 1a2e 8017      		cp r24,r16
 4580 1a30 9107      		cpc r25,r17
 4581 1a32 A207      		cpc r26,r18
 4582 1a34 B307      		cpc r27,r19
 4583 1a36 00F0      		brlo .L290
3658:switcherator.c ****                                 weeklySeconds <= (stopTime + daySeconds)) {
 4584               		.loc 1 3658 0 discriminator 1
 4585 1a38 480D      		add r20,r8
 4586 1a3a 591D      		adc r21,r9
 4587 1a3c 6A1D      		adc r22,r10
 4588 1a3e 7B1D      		adc r23,r11
 4589               	.LVL337:
3657:switcherator.c ****                         if (weeklySeconds >= (startTime + daySeconds) &&
 4590               		.loc 1 3657 0 discriminator 1
 4591 1a40 4817      		cp r20,r24
 4592 1a42 5907      		cpc r21,r25
 4593 1a44 6A07      		cpc r22,r26
 4594 1a46 7B07      		cpc r23,r27
 4595 1a48 00F0      		brlo .L290
 4596               	.L357:
3659:switcherator.c ****                             if (timeLimits[x][2] & (1 << dow))
 4597               		.loc 1 3659 0
 4598 1a4a F701      		movw r30,r14
 4599 1a4c 8085      		ldd r24,Z+8
 4600 1a4e 9185      		ldd r25,Z+9
 4601 1a50 A285      		ldd r26,Z+10
 4602 1a52 B385      		ldd r27,Z+11
 4603 1a54 8421      		and r24,r4
 4604 1a56 9521      		and r25,r5
 4605 1a58 A621      		and r26,r6
 4606 1a5a B721      		and r27,r7
 4607               	.L355:
 4608 1a5c 892B      		or r24,r25
 4609 1a5e 8A2B      		or r24,r26
 4610 1a60 8B2B      		or r24,r27
 4611 1a62 01F0      		breq .L290
 4612               		.loc 1 3660 0
 4613 1a64 20E0      		ldi r18,0
 4614 1a66 30E0      		ldi r19,0
 4615 1a68 A901      		movw r20,r18
 4616 1a6a 6B85      		ldd r22,Y+11
 4617 1a6c 7C85      		ldd r23,Y+12
 4618 1a6e C601      		movw r24,r12
 4619 1a70 0E94 0000 		call startTheProgram
 4620               	.LVL338:
 4621               	.L290:
 4622 1a74 FCE0      		ldi r31,12
 4623 1a76 EF0E      		add r14,r31
 4624 1a78 F11C      		adc r15,__zero_reg__
3637:switcherator.c ****                 for (x = 0; x < NUM_LIMITS; x++) {
 4625               		.loc 1 3637 0
 4626 1a7a 00E0      		ldi r16,lo8(timeLimits+48)
 4627 1a7c E016      		cp r14,r16
 4628 1a7e 00E0      		ldi r16,hi8(timeLimits+48)
 4629 1a80 F006      		cpc r15,r16
 4630 1a82 01F0      		breq .+2
 4631 1a84 00C0      		rjmp .L291
 4632 1a86 00C0      		rjmp .L257
 4633               	.LVL339:
 4634               	.L281:
3621:switcherator.c ****             if (switchNumber < 128) { // this is a switch
 4635               		.loc 1 3621 0
 4636 1a88 0038      		cpi r16,-128
 4637 1a8a 1105      		cpc r17,__zero_reg__
 4638 1a8c 00F4      		brsh .+2
 4639 1a8e 00C0      		rjmp .L294
 4640 1a90 E0E0      		ldi r30,lo8(timeLimits+8)
 4641 1a92 F0E0      		ldi r31,hi8(timeLimits+8)
3439:switcherator.c **** void getInput(int inputNumber) {
 4642               		.loc 1 3439 0
 4643 1a94 20E0      		ldi r18,0
 4644               	.LVL340:
 4645 1a96 00C0      		rjmp .L284
 4646               	.LVL341:
 4647               	.L257:
 4648               	/* epilogue start */
 4649               	.LBE24:
3661:switcherator.c ****                         }
3662:switcherator.c ****                     }
3663:switcherator.c ****                 } // end of the for
3664:switcherator.c ****             }
3665:switcherator.c ****         }
3666:switcherator.c ****     }
3667:switcherator.c **** }
 4650               		.loc 1 3667 0
 4651 1a98 2C96      		adiw r28,12
 4652 1a9a 0FB6      		in __tmp_reg__,__SREG__
 4653 1a9c F894      		cli
 4654 1a9e DEBF      		out __SP_H__,r29
 4655 1aa0 0FBE      		out __SREG__,__tmp_reg__
 4656 1aa2 CDBF      		out __SP_L__,r28
 4657 1aa4 DF91      		pop r29
 4658 1aa6 CF91      		pop r28
 4659 1aa8 1F91      		pop r17
 4660 1aaa 0F91      		pop r16
 4661 1aac FF90      		pop r15
 4662 1aae EF90      		pop r14
 4663 1ab0 DF90      		pop r13
 4664               	.LVL342:
 4665 1ab2 CF90      		pop r12
 4666 1ab4 BF90      		pop r11
 4667 1ab6 AF90      		pop r10
 4668 1ab8 9F90      		pop r9
 4669 1aba 8F90      		pop r8
 4670               	.LVL343:
 4671 1abc 7F90      		pop r7
 4672 1abe 6F90      		pop r6
 4673 1ac0 5F90      		pop r5
 4674 1ac2 4F90      		pop r4
 4675 1ac4 3F90      		pop r3
 4676 1ac6 2F90      		pop r2
 4677 1ac8 0895      		ret
 4678               	.LFE82:
 4680               	.global	inputTenthCheck
 4682               	inputTenthCheck:
 4683               	.LFB81:
3419:switcherator.c **** void inputTenthCheck(void) {
 4684               		.loc 1 3419 0
 4685 1aca 0F93      		push r16
 4686               	.LCFI106:
 4687 1acc 1F93      		push r17
 4688               	.LCFI107:
 4689 1ace CF93      		push r28
 4690               	.LCFI108:
 4691 1ad0 DF93      		push r29
 4692               	.LCFI109:
 4693               	/* prologue: function */
 4694               	/* frame size = 0 */
 4695               	/* stack size = 4 */
 4696               	.L__stack_usage = 4
 4697               	.LVL344:
 4698 1ad2 00E0      		ldi r16,lo8(inputs+6)
 4699 1ad4 10E0      		ldi r17,hi8(inputs+6)
3421:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 4700               		.loc 1 3421 0
 4701 1ad6 C0E0      		ldi r28,0
 4702 1ad8 D0E0      		ldi r29,0
 4703               	.LVL345:
 4704               	.L361:
3419:switcherator.c **** void inputTenthCheck(void) {
 4705               		.loc 1 3419 0
 4706 1ada F801      		movw r30,r16
 4707 1adc 3697      		sbiw r30,6
3423:switcherator.c ****         if (inputs[x][0] != 255 && inputs[x][6] == 0)
 4708               		.loc 1 3423 0
 4709 1ade 8081      		ld r24,Z
 4710 1ae0 8F3F      		cpi r24,lo8(-1)
 4711 1ae2 01F0      		breq .L360
3423:switcherator.c ****         if (inputs[x][0] != 255 && inputs[x][6] == 0)
 4712               		.loc 1 3423 0 is_stmt 0 discriminator 1
 4713 1ae4 F801      		movw r30,r16
 4714 1ae6 8081      		ld r24,Z
 4715 1ae8 8111      		cpse r24,__zero_reg__
 4716 1aea 00C0      		rjmp .L360
3424:switcherator.c ****             getInput(x);
 4717               		.loc 1 3424 0 is_stmt 1
 4718 1aec CE01      		movw r24,r28
 4719 1aee 0E94 0000 		call getInput
 4720               	.LVL346:
 4721               	.L360:
3421:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 4722               		.loc 1 3421 0
 4723 1af2 2196      		adiw r28,1
 4724               	.LVL347:
 4725 1af4 085F      		subi r16,-8
 4726 1af6 1F4F      		sbci r17,-1
 4727 1af8 C430      		cpi r28,4
 4728 1afa D105      		cpc r29,__zero_reg__
 4729 1afc 01F4      		brne .L361
 4730               	/* epilogue start */
3426:switcherator.c **** }
 4731               		.loc 1 3426 0
 4732 1afe DF91      		pop r29
 4733 1b00 CF91      		pop r28
 4734               	.LVL348:
 4735 1b02 1F91      		pop r17
 4736 1b04 0F91      		pop r16
 4737 1b06 0895      		ret
 4738               	.LFE81:
 4740               	.global	inputCheck
 4742               	inputCheck:
 4743               	.LFB80:
3398:switcherator.c **** void inputCheck(void) {
 4744               		.loc 1 3398 0
 4745 1b08 0F93      		push r16
 4746               	.LCFI110:
 4747 1b0a 1F93      		push r17
 4748               	.LCFI111:
 4749 1b0c CF93      		push r28
 4750               	.LCFI112:
 4751 1b0e DF93      		push r29
 4752               	.LCFI113:
 4753               	/* prologue: function */
 4754               	/* frame size = 0 */
 4755               	/* stack size = 4 */
 4756               	.L__stack_usage = 4
 4757               	.LVL349:
 4758 1b10 00E0      		ldi r16,lo8(inputs+6)
 4759 1b12 10E0      		ldi r17,hi8(inputs+6)
3402:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 4760               		.loc 1 3402 0
 4761 1b14 C0E0      		ldi r28,0
 4762 1b16 D0E0      		ldi r29,0
 4763               	.LVL350:
 4764               	.L369:
3398:switcherator.c **** void inputCheck(void) {
 4765               		.loc 1 3398 0
 4766 1b18 F801      		movw r30,r16
 4767 1b1a 3697      		sbiw r30,6
3404:switcherator.c ****         if (inputs[x][0] == 255)
 4768               		.loc 1 3404 0
 4769 1b1c 8081      		ld r24,Z
 4770 1b1e 8F3F      		cpi r24,lo8(-1)
 4771 1b20 01F0      		breq .L367
3406:switcherator.c ****         pollTime = inputs[x][6];
 4772               		.loc 1 3406 0
 4773 1b22 F801      		movw r30,r16
 4774 1b24 2081      		ld r18,Z
 4775               	.LVL351:
3408:switcherator.c ****         if (pollTime == 0 || pollTime == 1) {
 4776               		.loc 1 3408 0
 4777 1b26 2230      		cpi r18,lo8(2)
 4778 1b28 00F4      		brsh .L368
 4779 1b2a 00C0      		rjmp .L374
 4780               	.L368:
3411:switcherator.c ****         } else if (weeklySeconds % pollTime == 0) {
 4781               		.loc 1 3411 0
 4782 1b2c 30E0      		ldi r19,0
 4783 1b2e 40E0      		ldi r20,0
 4784 1b30 50E0      		ldi r21,0
 4785 1b32 6091 0000 		lds r22,weeklySeconds
 4786 1b36 7091 0000 		lds r23,weeklySeconds+1
 4787 1b3a 8091 0000 		lds r24,weeklySeconds+2
 4788 1b3e 9091 0000 		lds r25,weeklySeconds+3
 4789 1b42 0E94 0000 		call __udivmodsi4
 4790               	.LVL352:
 4791 1b46 672B      		or r22,r23
 4792 1b48 682B      		or r22,r24
 4793 1b4a 692B      		or r22,r25
 4794 1b4c 01F4      		brne .L367
 4795               	.L374:
3412:switcherator.c ****             getInput(x);
 4796               		.loc 1 3412 0
 4797 1b4e CE01      		movw r24,r28
 4798 1b50 0E94 0000 		call getInput
 4799               	.LVL353:
 4800               	.L367:
3402:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 4801               		.loc 1 3402 0
 4802 1b54 2196      		adiw r28,1
 4803               	.LVL354:
 4804 1b56 085F      		subi r16,-8
 4805 1b58 1F4F      		sbci r17,-1
 4806 1b5a C430      		cpi r28,4
 4807 1b5c D105      		cpc r29,__zero_reg__
 4808 1b5e 01F4      		brne .L369
 4809               	/* epilogue start */
3415:switcherator.c **** }
 4810               		.loc 1 3415 0
 4811 1b60 DF91      		pop r29
 4812 1b62 CF91      		pop r28
 4813               	.LVL355:
 4814 1b64 1F91      		pop r17
 4815 1b66 0F91      		pop r16
 4816 1b68 0895      		ret
 4817               	.LFE80:
 4819               	.global	flashFail
 4821               	flashFail:
 4822               	.LFB84:
3668:switcherator.c **** 
3669:switcherator.c **** // clears an input
3670:switcherator.c **** // CI nn = input number
3671:switcherator.c **** 
3672:switcherator.c **** void clearInput(char * commandReceived) {
3673:switcherator.c ****     int inputNumber = 0;
3674:switcherator.c ****     volatile unsigned char *thisPort = 0;
3675:switcherator.c ****     tempIntString[0] = commandReceived[3];
3676:switcherator.c ****     tempIntString[1] = commandReceived[4];
3677:switcherator.c ****     inputNumber = atoi(tempIntString);
3678:switcherator.c ****     int temp = inputs[inputNumber][0];
3679:switcherator.c ****     if (temp > 15 && temp < 32) {
3680:switcherator.c ****         thisPort = &PINB;
3681:switcherator.c ****         temp -= 16;
3682:switcherator.c **** #ifdef PINA
3683:switcherator.c ****     } else if (temp < 16) {
3684:switcherator.c ****         thisPort = &PINA;
3685:switcherator.c ****         temp -= 0;
3686:switcherator.c **** #endif
3687:switcherator.c **** #ifdef PINC
3688:switcherator.c ****     } else if (temp < 48) {
3689:switcherator.c ****         thisPort = &PINC;
3690:switcherator.c ****         temp -= 32;
3691:switcherator.c **** #endif
3692:switcherator.c **** #ifdef PIND
3693:switcherator.c ****     } else if (temp < 64) {
3694:switcherator.c ****         thisPort = &PIND;
3695:switcherator.c ****         temp -= 48;
3696:switcherator.c **** #endif
3697:switcherator.c **** #ifdef PINE
3698:switcherator.c ****     } else if (temp < 80) {
3699:switcherator.c ****         thisPort = &PINE;
3700:switcherator.c ****         temp -= 64;
3701:switcherator.c **** #endif
3702:switcherator.c **** #ifdef PINF
3703:switcherator.c ****     } else if (temp < 96) {
3704:switcherator.c ****         thisPort = &PINF;
3705:switcherator.c ****         temp -= 80;
3706:switcherator.c **** #endif
3707:switcherator.c **** #ifdef PING
3708:switcherator.c ****     } else if (temp < 112) {
3709:switcherator.c ****         thisPort = &PING;
3710:switcherator.c ****         temp -= 96;
3711:switcherator.c **** #endif
3712:switcherator.c **** #ifdef PINH
3713:switcherator.c ****     } else if (temp < 128) {
3714:switcherator.c ****         thisPort = &PINH;
3715:switcherator.c ****         temp -= 112;
3716:switcherator.c **** #endif
3717:switcherator.c **** #ifdef PINI
3718:switcherator.c ****     } else if (temp < 144) {
3719:switcherator.c ****         thisPort = &PINI;
3720:switcherator.c ****         temp -= 128;
3721:switcherator.c **** #endif
3722:switcherator.c ****     } else {
3723:switcherator.c ****         ok();
3724:switcherator.c ****         return;
3725:switcherator.c ****     }
3726:switcherator.c ****     // zero out the port
3727:switcherator.c ****     *thisPort &= ~(1 << temp);
3728:switcherator.c ****     inputs[inputNumber][0] = 255;
3729:switcherator.c ****     ok();
3730:switcherator.c **** }
3731:switcherator.c **** 
3732:switcherator.c **** /****************************************************************
3733:switcherator.c ****  *
3734:switcherator.c ****  *              All Things Interrupt and on offish Related
3735:switcherator.c ****  *
3736:switcherator.c ****  ****************************************************************/
3737:switcherator.c **** 
3738:switcherator.c **** 
3739:switcherator.c **** // Flashes the indicator pin to determine problems
3740:switcherator.c **** 
3741:switcherator.c **** void flashFail(void) {
 4823               		.loc 1 3741 0
 4824               	/* prologue: function */
 4825               	/* frame size = 0 */
 4826               	/* stack size = 0 */
 4827               	.L__stack_usage = 0
3742:switcherator.c ****     failTimer++;
 4828               		.loc 1 3742 0
 4829 1b6a 8091 0000 		lds r24,failTimer
 4830 1b6e 8F5F      		subi r24,lo8(-(1))
 4831 1b70 8093 0000 		sts failTimer,r24
3743:switcherator.c ****     INDICATOR_DDR |= INDICATOR_PIN;
 4832               		.loc 1 3743 0
 4833 1b74 529A      		sbi 0xa,2
3744:switcherator.c ****     // different timings for different fails
3745:switcherator.c ****     if (failCondition == 1) {
 4834               		.loc 1 3745 0
 4835 1b76 9091 0000 		lds r25,failCondition
 4836 1b7a 9130      		cpi r25,lo8(1)
 4837 1b7c 01F4      		brne .L376
3746:switcherator.c ****         if (failTimer == 2) {
 4838               		.loc 1 3746 0
 4839 1b7e 8230      		cpi r24,lo8(2)
 4840 1b80 01F4      		brne .L377
 4841 1b82 00C0      		rjmp .L394
 4842               	.L377:
3747:switcherator.c ****             INDICATOR_PORT |= INDICATOR_PIN;
3748:switcherator.c ****         } else if (failTimer == 4) {
 4843               		.loc 1 3748 0
 4844 1b84 8430      		cpi r24,lo8(4)
 4845 1b86 01F4      		brne .L379
 4846 1b88 00C0      		rjmp .L392
 4847               	.L379:
3749:switcherator.c ****             INDICATOR_PORT &= ~(INDICATOR_PIN);
3750:switcherator.c ****         } else if (failTimer == 24)
 4848               		.loc 1 3750 0
 4849 1b8a 8831      		cpi r24,lo8(24)
 4850 1b8c 01F4      		brne .L375
 4851 1b8e 00C0      		rjmp .L393
 4852               	.L376:
3751:switcherator.c ****             failTimer = 0;
3752:switcherator.c ****     } else if (failCondition == 2) {
 4853               		.loc 1 3752 0
 4854 1b90 9230      		cpi r25,lo8(2)
 4855 1b92 01F4      		brne .L380
3753:switcherator.c ****         if (failTimer == 2) {
 4856               		.loc 1 3753 0
 4857 1b94 8230      		cpi r24,lo8(2)
 4858 1b96 01F4      		brne .L381
 4859 1b98 00C0      		rjmp .L394
 4860               	.L381:
3754:switcherator.c ****             INDICATOR_PORT |= INDICATOR_PIN;
3755:switcherator.c ****         } else if (failTimer == 4) {
 4861               		.loc 1 3755 0
 4862 1b9a 8430      		cpi r24,lo8(4)
 4863 1b9c 01F4      		brne .L382
 4864 1b9e 00C0      		rjmp .L392
 4865               	.L382:
3756:switcherator.c ****             INDICATOR_PORT &= ~(INDICATOR_PIN);
3757:switcherator.c ****         } else if (failTimer == 8) {
 4866               		.loc 1 3757 0
 4867 1ba0 8830      		cpi r24,lo8(8)
 4868 1ba2 01F4      		brne .L383
 4869 1ba4 00C0      		rjmp .L394
 4870               	.L383:
3758:switcherator.c ****             INDICATOR_PORT |= INDICATOR_PIN;
3759:switcherator.c ****         } else if (failTimer == 10) {
 4871               		.loc 1 3759 0
 4872 1ba6 8A30      		cpi r24,lo8(10)
 4873 1ba8 01F4      		brne .L384
 4874 1baa 00C0      		rjmp .L392
 4875               	.L384:
3760:switcherator.c ****             INDICATOR_PORT &= ~(INDICATOR_PIN);
3761:switcherator.c ****         } else if (failTimer == 30)
 4876               		.loc 1 3761 0
 4877 1bac 8E31      		cpi r24,lo8(30)
 4878 1bae 01F4      		brne .L375
 4879 1bb0 00C0      		rjmp .L393
 4880               	.L380:
3762:switcherator.c ****             failTimer = 0;
3763:switcherator.c ****     } else if (failCondition == 3) {
 4881               		.loc 1 3763 0
 4882 1bb2 9330      		cpi r25,lo8(3)
 4883 1bb4 01F4      		brne .L375
3764:switcherator.c ****         if (failTimer == 2) {
 4884               		.loc 1 3764 0
 4885 1bb6 8230      		cpi r24,lo8(2)
 4886 1bb8 01F4      		brne .L385
 4887 1bba 00C0      		rjmp .L394
 4888               	.L385:
3765:switcherator.c ****             INDICATOR_PORT |= INDICATOR_PIN;
3766:switcherator.c ****         } else if (failTimer == 4) {
 4889               		.loc 1 3766 0
 4890 1bbc 8430      		cpi r24,lo8(4)
 4891 1bbe 01F4      		brne .L386
 4892 1bc0 00C0      		rjmp .L392
 4893               	.L386:
3767:switcherator.c ****             INDICATOR_PORT &= ~(INDICATOR_PIN);
3768:switcherator.c ****         } else if (failTimer == 8) {
 4894               		.loc 1 3768 0
 4895 1bc2 8830      		cpi r24,lo8(8)
 4896 1bc4 01F4      		brne .L387
 4897 1bc6 00C0      		rjmp .L394
 4898               	.L387:
3769:switcherator.c ****             INDICATOR_PORT |= INDICATOR_PIN;
3770:switcherator.c ****         } else if (failTimer == 10) {
 4899               		.loc 1 3770 0
 4900 1bc8 8A30      		cpi r24,lo8(10)
 4901 1bca 01F4      		brne .L388
 4902 1bcc 00C0      		rjmp .L392
 4903               	.L388:
3771:switcherator.c ****             INDICATOR_PORT &= ~(INDICATOR_PIN);
3772:switcherator.c ****         } else if (failTimer == 14) {
 4904               		.loc 1 3772 0
 4905 1bce 8E30      		cpi r24,lo8(14)
 4906 1bd0 01F4      		brne .L389
 4907               	.L394:
3773:switcherator.c ****             INDICATOR_PORT |= INDICATOR_PIN;
 4908               		.loc 1 3773 0
 4909 1bd2 5A9A      		sbi 0xb,2
 4910 1bd4 0895      		ret
 4911               	.L389:
3774:switcherator.c ****         } else if (failTimer == 16) {
 4912               		.loc 1 3774 0
 4913 1bd6 8031      		cpi r24,lo8(16)
 4914 1bd8 01F4      		brne .L390
 4915               	.L392:
3775:switcherator.c ****             INDICATOR_PORT &= ~(INDICATOR_PIN);
 4916               		.loc 1 3775 0
 4917 1bda 5A98      		cbi 0xb,2
 4918 1bdc 0895      		ret
 4919               	.L390:
3776:switcherator.c ****         } else if (failTimer == 36)
 4920               		.loc 1 3776 0
 4921 1bde 8432      		cpi r24,lo8(36)
 4922 1be0 01F4      		brne .L375
 4923               	.L393:
3777:switcherator.c ****             failTimer = 0;
 4924               		.loc 1 3777 0
 4925 1be2 1092 0000 		sts failTimer,__zero_reg__
 4926               	.L375:
 4927 1be6 0895      		ret
 4928               	.LFE84:
 4930               	.global	clearFail
 4932               	clearFail:
 4933               	.LFB85:
3778:switcherator.c ****         }
3779:switcherator.c **** }
3780:switcherator.c **** 
3781:switcherator.c **** // turns off the indicator pin
3782:switcherator.c **** void clearFail(void) {
 4934               		.loc 1 3782 0
 4935               	/* prologue: function */
 4936               	/* frame size = 0 */
 4937               	/* stack size = 0 */
 4938               	.L__stack_usage = 0
3783:switcherator.c ****     failTimer = 0;
 4939               		.loc 1 3783 0
 4940 1be8 1092 0000 		sts failTimer,__zero_reg__
3784:switcherator.c ****     INDICATOR_PORT |= (INDICATOR_PIN);
 4941               		.loc 1 3784 0
 4942 1bec 5A9A      		sbi 0xb,2
3785:switcherator.c ****     INDICATOR_DDR |= (INDICATOR_PIN);
 4943               		.loc 1 3785 0
 4944 1bee 529A      		sbi 0xa,2
 4945 1bf0 0895      		ret
 4946               	.LFE85:
 4948               	.global	sendMessage
 4950               	sendMessage:
 4951               	.LFB77:
3100:switcherator.c **** void sendMessage(char * myResponse) {
 4952               		.loc 1 3100 0
 4953               	.LVL356:
 4954 1bf2 CF93      		push r28
 4955               	.LCFI114:
 4956 1bf4 DF93      		push r29
 4957               	.LCFI115:
 4958 1bf6 00D0      		rcall .
 4959               	.LCFI116:
 4960 1bf8 CDB7      		in r28,__SP_L__
 4961 1bfa DEB7      		in r29,__SP_H__
 4962               	.LCFI117:
 4963               	/* prologue: function */
 4964               	/* frame size = 2 */
 4965               	/* stack size = 4 */
 4966               	.L__stack_usage = 4
3101:switcherator.c ****     stopRx();
 4967               		.loc 1 3101 0
 4968 1bfc 8983      		std Y+1,r24
 4969 1bfe 9A83      		std Y+2,r25
 4970 1c00 0E94 0000 		call stopRx
 4971               	.LVL357:
 4972               	.LBB25:
 4973               	.LBB26:
 4974               		.file 2 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h"
   1:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
   6:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
   9:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  12:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  17:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  21:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  33:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  35:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  38:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  41:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  42:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  46:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /** \file */
  47:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \code
  49:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \endcode
  53:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  54:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     used.
  58:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  59:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  68:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  77:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  81:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** */
  82:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  83:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  87:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  88:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  93:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  94:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  97:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  98:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
 103:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 104:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /**
 105:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 107:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 109:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 112:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 114:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 120:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 125:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 129:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 132:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 140:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****  */
 141:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** void
 142:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** {
 144:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 153:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 156:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 159:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#else
 160:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#endif
 163:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 164:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 165:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 166:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #else
 167:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	{
 172:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		{
 176:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		}
 180:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		return;
 181:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	}
 182:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	else
 183:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
 186:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** }
 187:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 188:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /**
 189:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 191:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 193:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 196:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 198:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 202:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   
 207:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 211:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****  
 214:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 222:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****  */
 223:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** void
 224:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** {
 226:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 235:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 238:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 241:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#else
 242:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		//round up by default
 243:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#endif
 245:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 246:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 4975               		.loc 2 246 0
 4976 1c04 AFE8      		ldi r26,lo8(399)
 4977 1c06 B1E0      		ldi r27,hi8(399)
 4978 1c08 1197      		1: sbiw r26,1
 4979 1c0a 01F4      		brne 1b
 4980 1c0c 00C0      		rjmp .
 4981 1c0e 0000      		nop
 4982               	.LBE26:
 4983               	.LBE25:
3103:switcherator.c ****     int transmitLength = strlen(myResponse);
 4984               		.loc 1 3103 0
 4985 1c10 8981      		ldd r24,Y+1
 4986 1c12 E82F      		mov r30,r24
 4987 1c14 9A81      		ldd r25,Y+2
 4988 1c16 F92F      		mov r31,r25
 4989 1c18 DF01      		movw r26,r30
 4990               		0:
 4991 1c1a 0D90      		ld __tmp_reg__,X+
 4992 1c1c 0020      		tst __tmp_reg__
 4993 1c1e 01F4      		brne 0b
 4994 1c20 BD01      		movw r22,r26
 4995 1c22 6150      		subi r22,1
 4996 1c24 7109      		sbc r23,__zero_reg__
 4997 1c26 6E1B      		sub r22,r30
 4998 1c28 7F0B      		sbc r23,r31
3104:switcherator.c ****     if(!transmit(myResponse, transmitLength)) {
 4999               		.loc 1 3104 0
 5000 1c2a 0E94 0000 		call transmit
 5001               	.LVL358:
 5002 1c2e 8111      		cpse r24,__zero_reg__
 5003 1c30 00C0      		rjmp .L397
3105:switcherator.c ****         failCondition = 2;
 5004               		.loc 1 3105 0
 5005 1c32 82E0      		ldi r24,lo8(2)
 5006 1c34 8093 0000 		sts failCondition,r24
 5007 1c38 00C0      		rjmp .L398
 5008               	.L397:
3107:switcherator.c ****         failCondition = 0;
 5009               		.loc 1 3107 0
 5010 1c3a 1092 0000 		sts failCondition,__zero_reg__
3108:switcherator.c ****         clearFail();
 5011               		.loc 1 3108 0
 5012 1c3e 0E94 0000 		call clearFail
 5013               	.LVL359:
 5014               	.L398:
 5015               	/* epilogue start */
3111:switcherator.c **** }
 5016               		.loc 1 3111 0
 5017 1c42 0F90      		pop __tmp_reg__
 5018 1c44 0F90      		pop __tmp_reg__
 5019 1c46 DF91      		pop r29
 5020 1c48 CF91      		pop r28
3110:switcherator.c ****     startRx();
 5021               		.loc 1 3110 0
 5022 1c4a 0C94 0000 		jmp startRx
 5023               	.LVL360:
 5024               	.LFE77:
 5026               		.section	.rodata.str1.1
 5027               	.LC6:
 5028 000b 5365 7223 		.string	"Ser#"
 5028      00
 5029               		.text
 5030               	.global	serialNumber
 5032               	serialNumber:
 5033               	.LFB75:
3058:switcherator.c **** void serialNumber(char * commandReceived) {
 5034               		.loc 1 3058 0
 5035               	.LVL361:
 5036 1c4e CF92      		push r12
 5037               	.LCFI118:
 5038 1c50 DF92      		push r13
 5039               	.LCFI119:
 5040 1c52 EF92      		push r14
 5041               	.LCFI120:
 5042 1c54 FF92      		push r15
 5043               	.LCFI121:
 5044 1c56 CF93      		push r28
 5045               	.LCFI122:
 5046 1c58 DF93      		push r29
 5047               	.LCFI123:
 5048               	/* prologue: function */
 5049               	/* frame size = 0 */
 5050               	/* stack size = 6 */
 5051               	.L__stack_usage = 6
 5052 1c5a FC01      		movw r30,r24
3059:switcherator.c ****     tempHugeString[0] = commandReceived[3];
 5053               		.loc 1 3059 0
 5054 1c5c 8381      		ldd r24,Z+3
 5055               	.LVL362:
 5056 1c5e 8093 0000 		sts tempHugeString,r24
3060:switcherator.c ****     tempHugeString[1] = commandReceived[4];
 5057               		.loc 1 3060 0
 5058 1c62 8481      		ldd r24,Z+4
 5059 1c64 8093 0000 		sts tempHugeString+1,r24
3061:switcherator.c ****     tempHugeString[2] = commandReceived[5];
 5060               		.loc 1 3061 0
 5061 1c68 8581      		ldd r24,Z+5
 5062 1c6a 8093 0000 		sts tempHugeString+2,r24
3062:switcherator.c ****     tempHugeString[3] = commandReceived[6];
 5063               		.loc 1 3062 0
 5064 1c6e 8681      		ldd r24,Z+6
 5065 1c70 8093 0000 		sts tempHugeString+3,r24
3063:switcherator.c ****     tempHugeString[4] = commandReceived[7];
 5066               		.loc 1 3063 0
 5067 1c74 8781      		ldd r24,Z+7
 5068 1c76 8093 0000 		sts tempHugeString+4,r24
3064:switcherator.c ****     tempHugeString[5] = commandReceived[8];
 5069               		.loc 1 3064 0
 5070 1c7a 8085      		ldd r24,Z+8
 5071 1c7c 8093 0000 		sts tempHugeString+5,r24
3065:switcherator.c ****     long temp = atol(tempHugeString);
 5072               		.loc 1 3065 0
 5073 1c80 80E0      		ldi r24,lo8(tempHugeString)
 5074 1c82 90E0      		ldi r25,hi8(tempHugeString)
 5075 1c84 0E94 0000 		call atol
 5076               	.LVL363:
 5077 1c88 6B01      		movw r12,r22
 5078 1c8a 7C01      		movw r14,r24
 5079               	.LVL364:
3067:switcherator.c ****     statusMsg[0] = 0;
 5080               		.loc 1 3067 0
 5081 1c8c 1092 0000 		sts statusMsg,__zero_reg__
3069:switcherator.c ****     strcat(statusMsg, "Ser#");
 5082               		.loc 1 3069 0
 5083 1c90 60E0      		ldi r22,lo8(.LC6)
 5084 1c92 70E0      		ldi r23,hi8(.LC6)
 5085 1c94 80E0      		ldi r24,lo8(statusMsg)
 5086 1c96 90E0      		ldi r25,hi8(statusMsg)
 5087 1c98 0E94 0000 		call strcat
 5088               	.LVL365:
3070:switcherator.c ****     if (temp > 0) {
 5089               		.loc 1 3070 0
 5090 1c9c 1C14      		cp __zero_reg__,r12
 5091 1c9e 1D04      		cpc __zero_reg__,r13
 5092 1ca0 1E04      		cpc __zero_reg__,r14
 5093 1ca2 1F04      		cpc __zero_reg__,r15
 5094 1ca4 04F4      		brge .L400
3072:switcherator.c ****         serial = temp;
 5095               		.loc 1 3072 0
 5096 1ca6 C092 0000 		sts serial,r12
 5097 1caa D092 0000 		sts serial+1,r13
 5098 1cae E092 0000 		sts serial+2,r14
 5099 1cb2 F092 0000 		sts serial+3,r15
3073:switcherator.c ****         ltoa(serial, stringSerial, 10);
 5100               		.loc 1 3073 0
 5101 1cb6 2AE0      		ldi r18,lo8(10)
 5102 1cb8 30E0      		ldi r19,0
 5103 1cba 40E0      		ldi r20,lo8(stringSerial)
 5104 1cbc 50E0      		ldi r21,hi8(stringSerial)
 5105 1cbe C701      		movw r24,r14
 5106 1cc0 B601      		movw r22,r12
 5107 1cc2 0E94 0000 		call ltoa
 5108               	.LVL366:
 5109               	.L400:
3076:switcherator.c ****     serialLength = strlen(stringSerial);
 5110               		.loc 1 3076 0
 5111 1cc6 C0E0      		ldi r28,lo8(stringSerial)
 5112 1cc8 D0E0      		ldi r29,hi8(stringSerial)
 5113               		0:
 5114 1cca 0990      		ld __tmp_reg__,Y+
 5115 1ccc 0020      		tst __tmp_reg__
 5116 1cce 01F4      		brne 0b
 5117               	.LVL367:
 5118 1cd0 2197      		sbiw r28,1
 5119 1cd2 C050      		subi r28,lo8(stringSerial)
 5120 1cd4 D040      		sbci r29,hi8(stringSerial)
 5121               	.LVL368:
3077:switcherator.c ****     while (serialLength < 6) {
 5122               		.loc 1 3077 0
 5123 1cd6 00C0      		rjmp .L401
 5124               	.L402:
3078:switcherator.c ****         strcat(statusMsg, "0");
 5125               		.loc 1 3078 0
 5126 1cd8 60E0      		ldi r22,lo8(.LC1)
 5127 1cda 70E0      		ldi r23,hi8(.LC1)
 5128 1cdc 80E0      		ldi r24,lo8(statusMsg)
 5129 1cde 90E0      		ldi r25,hi8(statusMsg)
 5130 1ce0 0E94 0000 		call strcat
 5131               	.LVL369:
3079:switcherator.c ****         serialLength++;
 5132               		.loc 1 3079 0
 5133 1ce4 2196      		adiw r28,1
 5134               	.LVL370:
 5135               	.L401:
3077:switcherator.c ****     while (serialLength < 6) {
 5136               		.loc 1 3077 0 discriminator 1
 5137 1ce6 C630      		cpi r28,6
 5138 1ce8 D105      		cpc r29,__zero_reg__
 5139 1cea 04F0      		brlt .L402
3081:switcherator.c ****     strcat(statusMsg, stringSerial);
 5140               		.loc 1 3081 0
 5141 1cec 60E0      		ldi r22,lo8(stringSerial)
 5142 1cee 70E0      		ldi r23,hi8(stringSerial)
 5143 1cf0 80E0      		ldi r24,lo8(statusMsg)
 5144 1cf2 90E0      		ldi r25,hi8(statusMsg)
 5145 1cf4 0E94 0000 		call strcat
 5146               	.LVL371:
3082:switcherator.c ****     sendMessage(statusMsg);
 5147               		.loc 1 3082 0
 5148 1cf8 80E0      		ldi r24,lo8(statusMsg)
 5149 1cfa 90E0      		ldi r25,hi8(statusMsg)
 5150               	/* epilogue start */
3083:switcherator.c **** }
 5151               		.loc 1 3083 0
 5152 1cfc DF91      		pop r29
 5153 1cfe CF91      		pop r28
 5154               	.LVL372:
 5155 1d00 FF90      		pop r15
 5156 1d02 EF90      		pop r14
 5157 1d04 DF90      		pop r13
 5158 1d06 CF90      		pop r12
 5159               	.LVL373:
3082:switcherator.c ****     sendMessage(statusMsg);
 5160               		.loc 1 3082 0
 5161 1d08 0C94 0000 		jmp sendMessage
 5162               	.LVL374:
 5163               	.LFE75:
 5165               		.section	.rodata.str1.1
 5166               	.LC9:
 5167 0010 7230 2030 		.string	"r0 0x"
 5167      7800 
 5168               	.LC10:
 5169 0016 7231 2030 		.string	"r1 0x"
 5169      7800 
 5170               	.LC11:
 5171 001c 7232 2030 		.string	"r2 0x"
 5171      7800 
 5172               	.LC12:
 5173 0022 7233 2030 		.string	"r3 0x"
 5173      7800 
 5174               	.LC13:
 5175 0028 7234 2030 		.string	"r4 0x"
 5175      7800 
 5176               	.LC14:
 5177 002e 7235 2030 		.string	"r5 0x"
 5177      7800 
 5178               	.LC15:
 5179 0034 7420 3078 		.string	"t 0x"
 5179      00
 5180               	.LC7:
 5181 0039 3078 3030 		.string	"0x00"
 5181      00
 5182               	.LC8:
 5183 003e 3030 3030 		.string	"00000"
 5183      3000 
 5184               		.text
 5185               	.global	radioChangeAddress
 5187               	radioChangeAddress:
 5188               	.LFB74:
2994:switcherator.c **** void radioChangeAddress(char * commandReceived) {
 5189               		.loc 1 2994 0
 5190               	.LVL375:
 5191 1d0c 2F92      		push r2
 5192               	.LCFI124:
 5193 1d0e 3F92      		push r3
 5194               	.LCFI125:
 5195 1d10 4F92      		push r4
 5196               	.LCFI126:
 5197 1d12 5F92      		push r5
 5198               	.LCFI127:
 5199 1d14 6F92      		push r6
 5200               	.LCFI128:
 5201 1d16 7F92      		push r7
 5202               	.LCFI129:
 5203 1d18 8F92      		push r8
 5204               	.LCFI130:
 5205 1d1a 9F92      		push r9
 5206               	.LCFI131:
 5207 1d1c AF92      		push r10
 5208               	.LCFI132:
 5209 1d1e BF92      		push r11
 5210               	.LCFI133:
 5211 1d20 CF92      		push r12
 5212               	.LCFI134:
 5213 1d22 DF92      		push r13
 5214               	.LCFI135:
 5215 1d24 EF92      		push r14
 5216               	.LCFI136:
 5217 1d26 FF92      		push r15
 5218               	.LCFI137:
 5219 1d28 0F93      		push r16
 5220               	.LCFI138:
 5221 1d2a 1F93      		push r17
 5222               	.LCFI139:
 5223 1d2c CF93      		push r28
 5224               	.LCFI140:
 5225 1d2e DF93      		push r29
 5226               	.LCFI141:
 5227 1d30 CDB7      		in r28,__SP_L__
 5228 1d32 DEB7      		in r29,__SP_H__
 5229               	.LCFI142:
 5230 1d34 2B97      		sbiw r28,11
 5231               	.LCFI143:
 5232 1d36 0FB6      		in __tmp_reg__,__SREG__
 5233 1d38 F894      		cli
 5234 1d3a DEBF      		out __SP_H__,r29
 5235 1d3c 0FBE      		out __SREG__,__tmp_reg__
 5236 1d3e CDBF      		out __SP_L__,r28
 5237               	/* prologue: function */
 5238               	/* frame size = 11 */
 5239               	/* stack size = 29 */
 5240               	.L__stack_usage = 29
 5241 1d40 5C01      		movw r10,r24
 5242               	.LVL376:
2996:switcherator.c ****     statusMsg[0] = 0;
 5243               		.loc 1 2996 0
 5244 1d42 1092 0000 		sts statusMsg,__zero_reg__
 5245               	.LVL377:
2999:switcherator.c ****     char tempString[] = "0x00";
 5246               		.loc 1 2999 0
 5247 1d46 85E0      		ldi r24,lo8(5)
 5248               	.LVL378:
 5249 1d48 E0E0      		ldi r30,lo8(.LC7)
 5250 1d4a F0E0      		ldi r31,hi8(.LC7)
 5251 1d4c DE01      		movw r26,r28
 5252 1d4e 1796      		adiw r26,7
 5253               		0:
 5254 1d50 0190      		ld r0,Z+
 5255 1d52 0D92      		st X+,r0
 5256 1d54 8A95      		dec r24
 5257 1d56 01F4      		brne 0b
3000:switcherator.c ****     char tempRadioString[] = "00000";
 5258               		.loc 1 3000 0
 5259 1d58 86E0      		ldi r24,lo8(6)
 5260 1d5a E0E0      		ldi r30,lo8(.LC8)
 5261 1d5c F0E0      		ldi r31,hi8(.LC8)
 5262 1d5e DE01      		movw r26,r28
 5263 1d60 1196      		adiw r26,1
 5264               		0:
 5265 1d62 0190      		ld r0,Z+
 5266 1d64 0D92      		st X+,r0
 5267 1d66 8A95      		dec r24
 5268 1d68 01F4      		brne 0b
2994:switcherator.c **** void radioChangeAddress(char * commandReceived) {
 5269               		.loc 1 2994 0
 5270 1d6a 6501      		movw r12,r10
 5271 1d6c 88E0      		ldi r24,8
 5272 1d6e C80E      		add r12,r24
 5273 1d70 D11C      		adc r13,__zero_reg__
2998:switcherator.c ****     uint64_t newAddress = 0;
 5274               		.loc 1 2998 0
 5275 1d72 212C      		mov r2,__zero_reg__
 5276 1d74 312C      		mov r3,__zero_reg__
 5277 1d76 412C      		mov r4,__zero_reg__
 5278 1d78 512C      		mov r5,__zero_reg__
 5279 1d7a 612C      		mov r6,__zero_reg__
 5280 1d7c 712C      		mov r7,__zero_reg__
 5281 1d7e 812C      		mov r8,__zero_reg__
 5282 1d80 912C      		mov r9,__zero_reg__
3001:switcherator.c ****     for (x = 0; x < 5; x++) {
 5283               		.loc 1 3001 0
 5284 1d82 E12C      		mov r14,__zero_reg__
 5285 1d84 F12C      		mov r15,__zero_reg__
 5286               	.LVL379:
 5287               	.L405:
2994:switcherator.c **** void radioChangeAddress(char * commandReceived) {
 5288               		.loc 1 2994 0
 5289 1d86 F601      		movw r30,r12
 5290 1d88 3197      		sbiw r30,1
3002:switcherator.c ****         tempString[2] = commandReceived[((x * 2) + 7)];
 5291               		.loc 1 3002 0
 5292 1d8a 8081      		ld r24,Z
 5293 1d8c 8987      		std Y+9,r24
3003:switcherator.c ****         tempString[3] = commandReceived[((x * 2) + 8)];
 5294               		.loc 1 3003 0
 5295 1d8e F601      		movw r30,r12
 5296 1d90 8081      		ld r24,Z
 5297 1d92 8A87      		std Y+10,r24
3004:switcherator.c ****         tempInt = strtol(tempString, 0, 0);
 5298               		.loc 1 3004 0
 5299 1d94 40E0      		ldi r20,0
 5300 1d96 50E0      		ldi r21,0
 5301 1d98 60E0      		ldi r22,0
 5302 1d9a 70E0      		ldi r23,0
 5303 1d9c CE01      		movw r24,r28
 5304 1d9e 0796      		adiw r24,7
 5305 1da0 0E94 0000 		call strtol
 5306               	.LVL380:
3005:switcherator.c ****         newAddress |= tempInt;
 5307               		.loc 1 3005 0
 5308 1da4 872F      		mov r24,r23
 5309 1da6 880F      		lsl r24
 5310 1da8 880B      		sbc r24,r24
 5311 1daa 262A      		or r2,r22
 5312 1dac 372A      		or r3,r23
 5313 1dae 482A      		or r4,r24
 5314 1db0 582A      		or r5,r24
 5315 1db2 682A      		or r6,r24
 5316 1db4 782A      		or r7,r24
 5317 1db6 882A      		or r8,r24
 5318 1db8 982A      		or r9,r24
 5319               	.LVL381:
3006:switcherator.c ****         if (x < 4)
 5320               		.loc 1 3006 0
 5321 1dba F4E0      		ldi r31,4
 5322 1dbc EF16      		cp r14,r31
 5323 1dbe F104      		cpc r15,__zero_reg__
 5324 1dc0 01F0      		breq .L404
3007:switcherator.c ****             newAddress <<= 8;
 5325               		.loc 1 3007 0
 5326 1dc2 9101      		movw r18,r2
 5327 1dc4 A201      		movw r20,r4
 5328 1dc6 B301      		movw r22,r6
 5329 1dc8 C401      		movw r24,r8
 5330 1dca 08E0      		ldi r16,lo8(8)
 5331 1dcc 0E94 0000 		call __ashldi3
 5332 1dd0 1901      		movw r2,r18
 5333               	.LVL382:
 5334 1dd2 2A01      		movw r4,r20
 5335 1dd4 3B01      		movw r6,r22
 5336 1dd6 4C01      		movw r8,r24
 5337               	.LVL383:
 5338               	.L404:
3001:switcherator.c ****     for (x = 0; x < 5; x++) {
 5339               		.loc 1 3001 0
 5340 1dd8 8FEF      		ldi r24,-1
 5341 1dda E81A      		sub r14,r24
 5342 1ddc F80A      		sbc r15,r24
 5343               	.LVL384:
 5344 1dde E2E0      		ldi r30,2
 5345 1de0 CE0E      		add r12,r30
 5346 1de2 D11C      		adc r13,__zero_reg__
 5347 1de4 F5E0      		ldi r31,5
 5348 1de6 EF16      		cp r14,r31
 5349 1de8 F104      		cpc r15,__zero_reg__
 5350 1dea 01F4      		brne .L405
3009:switcherator.c ****     switch (commandReceived[3]) {
 5351               		.loc 1 3009 0
 5352 1dec F501      		movw r30,r10
 5353 1dee 8381      		ldd r24,Z+3
 5354 1df0 8333      		cpi r24,lo8(51)
 5355 1df2 01F4      		brne .+2
 5356 1df4 00C0      		rjmp .L410
 5357 1df6 00F4      		brsh .L414
 5358 1df8 8133      		cpi r24,lo8(49)
 5359 1dfa 01F0      		breq .L408
 5360 1dfc 00F0      		brlo .+2
 5361 1dfe 00C0      		rjmp .L409
 5362 1e00 8033      		cpi r24,lo8(48)
 5363 1e02 01F0      		breq .+2
 5364 1e04 00C0      		rjmp .L406
 5365 1e06 00C0      		rjmp .L407
 5366               	.L414:
 5367 1e08 8533      		cpi r24,lo8(53)
 5368 1e0a 01F4      		brne .+2
 5369 1e0c 00C0      		rjmp .L412
 5370 1e0e 00F4      		brsh .+2
 5371 1e10 00C0      		rjmp .L411
 5372 1e12 8435      		cpi r24,lo8(84)
 5373 1e14 01F0      		breq .+2
 5374 1e16 00C0      		rjmp .L406
 5375 1e18 00C0      		rjmp .L413
 5376               	.L407:
3011:switcherator.c ****             rx_addr_p0 = newAddress;
 5377               		.loc 1 3011 0
 5378 1e1a 2092 0000 		sts rx_addr_p0,r2
 5379 1e1e 3092 0000 		sts rx_addr_p0+1,r3
 5380 1e22 4092 0000 		sts rx_addr_p0+2,r4
 5381 1e26 5092 0000 		sts rx_addr_p0+3,r5
 5382 1e2a 6092 0000 		sts rx_addr_p0+4,r6
 5383 1e2e 7092 0000 		sts rx_addr_p0+5,r7
 5384 1e32 8092 0000 		sts rx_addr_p0+6,r8
 5385 1e36 9092 0000 		sts rx_addr_p0+7,r9
3012:switcherator.c ****             strcat(statusMsg, "r0 0x");
 5386               		.loc 1 3012 0
 5387 1e3a 60E0      		ldi r22,lo8(.LC9)
 5388 1e3c 70E0      		ldi r23,hi8(.LC9)
 5389 1e3e 80E0      		ldi r24,lo8(statusMsg)
 5390 1e40 90E0      		ldi r25,hi8(statusMsg)
 5391 1e42 0E94 0000 		call strcat
 5392               	.LVL385:
3013:switcherator.c ****             writeAddr(RX_ADDR_P0, newAddress);
 5393               		.loc 1 3013 0
 5394 1e46 8101      		movw r16,r2
 5395 1e48 9201      		movw r18,r4
 5396 1e4a A301      		movw r20,r6
 5397 1e4c B401      		movw r22,r8
 5398 1e4e 8AE0      		ldi r24,lo8(10)
 5399 1e50 00C0      		rjmp .L421
 5400               	.L408:
3016:switcherator.c ****             rx_addr_p1 = newAddress;
 5401               		.loc 1 3016 0
 5402 1e52 2092 0000 		sts rx_addr_p1,r2
 5403 1e56 3092 0000 		sts rx_addr_p1+1,r3
 5404 1e5a 4092 0000 		sts rx_addr_p1+2,r4
 5405 1e5e 5092 0000 		sts rx_addr_p1+3,r5
 5406 1e62 6092 0000 		sts rx_addr_p1+4,r6
 5407 1e66 7092 0000 		sts rx_addr_p1+5,r7
 5408 1e6a 8092 0000 		sts rx_addr_p1+6,r8
 5409 1e6e 9092 0000 		sts rx_addr_p1+7,r9
3017:switcherator.c ****             strcat(statusMsg, "r1 0x");
 5410               		.loc 1 3017 0
 5411 1e72 60E0      		ldi r22,lo8(.LC10)
 5412 1e74 70E0      		ldi r23,hi8(.LC10)
 5413 1e76 80E0      		ldi r24,lo8(statusMsg)
 5414 1e78 90E0      		ldi r25,hi8(statusMsg)
 5415 1e7a 0E94 0000 		call strcat
 5416               	.LVL386:
3018:switcherator.c ****             writeAddr(RX_ADDR_P1, newAddress);
 5417               		.loc 1 3018 0
 5418 1e7e 8101      		movw r16,r2
 5419 1e80 9201      		movw r18,r4
 5420 1e82 A301      		movw r20,r6
 5421 1e84 B401      		movw r22,r8
 5422 1e86 8BE0      		ldi r24,lo8(11)
 5423 1e88 00C0      		rjmp .L421
 5424               	.L409:
3021:switcherator.c ****             rx_addr_p2 = newAddress;
 5425               		.loc 1 3021 0
 5426 1e8a 2092 0000 		sts rx_addr_p2,r2
 5427 1e8e 3092 0000 		sts rx_addr_p2+1,r3
 5428 1e92 4092 0000 		sts rx_addr_p2+2,r4
 5429 1e96 5092 0000 		sts rx_addr_p2+3,r5
 5430 1e9a 6092 0000 		sts rx_addr_p2+4,r6
 5431 1e9e 7092 0000 		sts rx_addr_p2+5,r7
 5432 1ea2 8092 0000 		sts rx_addr_p2+6,r8
 5433 1ea6 9092 0000 		sts rx_addr_p2+7,r9
3022:switcherator.c ****             strcat(statusMsg, "r2 0x");
 5434               		.loc 1 3022 0
 5435 1eaa 60E0      		ldi r22,lo8(.LC11)
 5436 1eac 70E0      		ldi r23,hi8(.LC11)
 5437 1eae 80E0      		ldi r24,lo8(statusMsg)
 5438 1eb0 90E0      		ldi r25,hi8(statusMsg)
 5439 1eb2 0E94 0000 		call strcat
 5440               	.LVL387:
3023:switcherator.c ****             writeAddr(RX_ADDR_P2, newAddress);
 5441               		.loc 1 3023 0
 5442 1eb6 8101      		movw r16,r2
 5443 1eb8 9201      		movw r18,r4
 5444 1eba A301      		movw r20,r6
 5445 1ebc B401      		movw r22,r8
 5446 1ebe 8CE0      		ldi r24,lo8(12)
 5447 1ec0 00C0      		rjmp .L421
 5448               	.L410:
3026:switcherator.c ****             rx_addr_p3 = newAddress;
 5449               		.loc 1 3026 0
 5450 1ec2 2092 0000 		sts rx_addr_p3,r2
 5451 1ec6 3092 0000 		sts rx_addr_p3+1,r3
 5452 1eca 4092 0000 		sts rx_addr_p3+2,r4
 5453 1ece 5092 0000 		sts rx_addr_p3+3,r5
 5454 1ed2 6092 0000 		sts rx_addr_p3+4,r6
 5455 1ed6 7092 0000 		sts rx_addr_p3+5,r7
 5456 1eda 8092 0000 		sts rx_addr_p3+6,r8
 5457 1ede 9092 0000 		sts rx_addr_p3+7,r9
3027:switcherator.c ****             strcat(statusMsg, "r3 0x");
 5458               		.loc 1 3027 0
 5459 1ee2 60E0      		ldi r22,lo8(.LC12)
 5460 1ee4 70E0      		ldi r23,hi8(.LC12)
 5461 1ee6 80E0      		ldi r24,lo8(statusMsg)
 5462 1ee8 90E0      		ldi r25,hi8(statusMsg)
 5463 1eea 0E94 0000 		call strcat
 5464               	.LVL388:
3028:switcherator.c ****             writeAddr(RX_ADDR_P3, newAddress);
 5465               		.loc 1 3028 0
 5466 1eee 8101      		movw r16,r2
 5467 1ef0 9201      		movw r18,r4
 5468 1ef2 A301      		movw r20,r6
 5469 1ef4 B401      		movw r22,r8
 5470 1ef6 8DE0      		ldi r24,lo8(13)
 5471 1ef8 00C0      		rjmp .L421
 5472               	.L411:
3031:switcherator.c ****             rx_addr_p4 = newAddress;
 5473               		.loc 1 3031 0
 5474 1efa 2092 0000 		sts rx_addr_p4,r2
 5475 1efe 3092 0000 		sts rx_addr_p4+1,r3
 5476 1f02 4092 0000 		sts rx_addr_p4+2,r4
 5477 1f06 5092 0000 		sts rx_addr_p4+3,r5
 5478 1f0a 6092 0000 		sts rx_addr_p4+4,r6
 5479 1f0e 7092 0000 		sts rx_addr_p4+5,r7
 5480 1f12 8092 0000 		sts rx_addr_p4+6,r8
 5481 1f16 9092 0000 		sts rx_addr_p4+7,r9
3032:switcherator.c ****             strcat(statusMsg, "r4 0x");
 5482               		.loc 1 3032 0
 5483 1f1a 60E0      		ldi r22,lo8(.LC13)
 5484 1f1c 70E0      		ldi r23,hi8(.LC13)
 5485 1f1e 80E0      		ldi r24,lo8(statusMsg)
 5486 1f20 90E0      		ldi r25,hi8(statusMsg)
 5487 1f22 0E94 0000 		call strcat
 5488               	.LVL389:
3033:switcherator.c ****             writeAddr(RX_ADDR_P4, newAddress);
 5489               		.loc 1 3033 0
 5490 1f26 8101      		movw r16,r2
 5491 1f28 9201      		movw r18,r4
 5492 1f2a A301      		movw r20,r6
 5493 1f2c B401      		movw r22,r8
 5494 1f2e 8EE0      		ldi r24,lo8(14)
 5495 1f30 00C0      		rjmp .L421
 5496               	.L412:
3036:switcherator.c ****             rx_addr_p5 = newAddress;
 5497               		.loc 1 3036 0
 5498 1f32 2092 0000 		sts rx_addr_p5,r2
 5499 1f36 3092 0000 		sts rx_addr_p5+1,r3
 5500 1f3a 4092 0000 		sts rx_addr_p5+2,r4
 5501 1f3e 5092 0000 		sts rx_addr_p5+3,r5
 5502 1f42 6092 0000 		sts rx_addr_p5+4,r6
 5503 1f46 7092 0000 		sts rx_addr_p5+5,r7
 5504 1f4a 8092 0000 		sts rx_addr_p5+6,r8
 5505 1f4e 9092 0000 		sts rx_addr_p5+7,r9
3037:switcherator.c ****             strcat(statusMsg, "r5 0x");
 5506               		.loc 1 3037 0
 5507 1f52 60E0      		ldi r22,lo8(.LC14)
 5508 1f54 70E0      		ldi r23,hi8(.LC14)
 5509 1f56 80E0      		ldi r24,lo8(statusMsg)
 5510 1f58 90E0      		ldi r25,hi8(statusMsg)
 5511 1f5a 0E94 0000 		call strcat
 5512               	.LVL390:
3038:switcherator.c ****             writeAddr(RX_ADDR_P5, newAddress);
 5513               		.loc 1 3038 0
 5514 1f5e 8101      		movw r16,r2
 5515 1f60 9201      		movw r18,r4
 5516 1f62 A301      		movw r20,r6
 5517 1f64 B401      		movw r22,r8
 5518 1f66 8FE0      		ldi r24,lo8(15)
 5519 1f68 00C0      		rjmp .L421
 5520               	.L413:
3041:switcherator.c ****             tx_addr = newAddress;
 5521               		.loc 1 3041 0
 5522 1f6a 2092 0000 		sts tx_addr,r2
 5523 1f6e 3092 0000 		sts tx_addr+1,r3
 5524 1f72 4092 0000 		sts tx_addr+2,r4
 5525 1f76 5092 0000 		sts tx_addr+3,r5
 5526 1f7a 6092 0000 		sts tx_addr+4,r6
 5527 1f7e 7092 0000 		sts tx_addr+5,r7
 5528 1f82 8092 0000 		sts tx_addr+6,r8
 5529 1f86 9092 0000 		sts tx_addr+7,r9
3042:switcherator.c ****             strcat(statusMsg, "t 0x");
 5530               		.loc 1 3042 0
 5531 1f8a 60E0      		ldi r22,lo8(.LC15)
 5532 1f8c 70E0      		ldi r23,hi8(.LC15)
 5533 1f8e 80E0      		ldi r24,lo8(statusMsg)
 5534 1f90 90E0      		ldi r25,hi8(statusMsg)
 5535 1f92 0E94 0000 		call strcat
 5536               	.LVL391:
3043:switcherator.c ****             writeAddr(TX_ADDR, newAddress);
 5537               		.loc 1 3043 0
 5538 1f96 8101      		movw r16,r2
 5539 1f98 9201      		movw r18,r4
 5540 1f9a A301      		movw r20,r6
 5541 1f9c B401      		movw r22,r8
 5542 1f9e 80E1      		ldi r24,lo8(16)
 5543               	.L421:
 5544 1fa0 0E94 0000 		call writeAddr
 5545               	.LVL392:
 5546               	.L406:
3046:switcherator.c ****     unformatAddress(newAddress, tempRadioString);
 5547               		.loc 1 3046 0
 5548 1fa4 8E01      		movw r16,r28
 5549 1fa6 0F5F      		subi r16,-1
 5550 1fa8 1F4F      		sbci r17,-1
 5551 1faa 9101      		movw r18,r2
 5552 1fac A201      		movw r20,r4
 5553 1fae B301      		movw r22,r6
 5554 1fb0 C401      		movw r24,r8
 5555 1fb2 0E94 0000 		call unformatAddress
 5556               	.LVL393:
 5557 1fb6 7801      		movw r14,r16
2994:switcherator.c **** void radioChangeAddress(char * commandReceived) {
 5558               		.loc 1 2994 0
 5559 1fb8 6E01      		movw r12,r28
 5560 1fba F6E0      		ldi r31,6
 5561 1fbc CF0E      		add r12,r31
 5562 1fbe D11C      		adc r13,__zero_reg__
 5563               	.LVL394:
 5564               	.L415:
3048:switcherator.c ****         returnHexWithout(tempRadioString[x], tempLongString);
 5565               		.loc 1 3048 0 discriminator 2
 5566 1fc0 60E0      		ldi r22,lo8(tempLongString)
 5567 1fc2 70E0      		ldi r23,hi8(tempLongString)
 5568 1fc4 F701      		movw r30,r14
 5569 1fc6 8191      		ld r24,Z+
 5570 1fc8 7F01      		movw r14,r30
 5571 1fca 90E0      		ldi r25,0
 5572 1fcc 0E94 0000 		call returnHexWithout
 5573               	.LVL395:
3049:switcherator.c ****         strcat(statusMsg, tempLongString);
 5574               		.loc 1 3049 0 discriminator 2
 5575 1fd0 60E0      		ldi r22,lo8(tempLongString)
 5576 1fd2 70E0      		ldi r23,hi8(tempLongString)
 5577 1fd4 80E0      		ldi r24,lo8(statusMsg)
 5578 1fd6 90E0      		ldi r25,hi8(statusMsg)
 5579 1fd8 0E94 0000 		call strcat
 5580               	.LVL396:
3047:switcherator.c ****     for (x = 0; x < 5; x++) {
 5581               		.loc 1 3047 0 discriminator 2
 5582 1fdc EC14      		cp r14,r12
 5583 1fde FD04      		cpc r15,r13
 5584 1fe0 01F4      		brne .L415
3051:switcherator.c ****     sendMessage(statusMsg);
 5585               		.loc 1 3051 0
 5586 1fe2 80E0      		ldi r24,lo8(statusMsg)
 5587 1fe4 90E0      		ldi r25,hi8(statusMsg)
 5588 1fe6 0E94 0000 		call sendMessage
 5589               	.LVL397:
 5590               	/* epilogue start */
3052:switcherator.c **** }
 5591               		.loc 1 3052 0
 5592 1fea 2B96      		adiw r28,11
 5593 1fec 0FB6      		in __tmp_reg__,__SREG__
 5594 1fee F894      		cli
 5595 1ff0 DEBF      		out __SP_H__,r29
 5596 1ff2 0FBE      		out __SREG__,__tmp_reg__
 5597 1ff4 CDBF      		out __SP_L__,r28
 5598 1ff6 DF91      		pop r29
 5599 1ff8 CF91      		pop r28
 5600 1ffa 1F91      		pop r17
 5601 1ffc 0F91      		pop r16
 5602 1ffe FF90      		pop r15
 5603 2000 EF90      		pop r14
 5604 2002 DF90      		pop r13
 5605 2004 CF90      		pop r12
 5606 2006 BF90      		pop r11
 5607 2008 AF90      		pop r10
 5608               	.LVL398:
 5609 200a 9F90      		pop r9
 5610               	.LVL399:
 5611 200c 8F90      		pop r8
 5612 200e 7F90      		pop r7
 5613 2010 6F90      		pop r6
 5614 2012 5F90      		pop r5
 5615 2014 4F90      		pop r4
 5616 2016 3F90      		pop r3
 5617 2018 2F90      		pop r2
 5618 201a 0895      		ret
 5619               	.LFE74:
 5621               		.section	.rodata.str1.1
 5622               	.LC16:
 5623 0044 7231 2D30 		.string	"r1-0x"
 5623      7800 
 5624               	.LC17:
 5625 004a 7232 2D30 		.string	"r2-0x"
 5625      7800 
 5626               	.LC18:
 5627 0050 7233 2D30 		.string	"r3-0x"
 5627      7800 
 5628               	.LC19:
 5629 0056 7234 2D30 		.string	"r4-0x"
 5629      7800 
 5630               	.LC20:
 5631 005c 7235 2D30 		.string	"r5-0x"
 5631      7800 
 5632               	.LC21:
 5633 0062 742D 3078 		.string	"t-0x"
 5633      00
 5634               	.LC22:
 5635 0067 7230 2D30 		.string	"r0-0x"
 5635      7800 
 5636               		.text
 5637               	.global	radioDisplayAddress
 5639               	radioDisplayAddress:
 5640               	.LFB73:
2954:switcherator.c **** void radioDisplayAddress(char * commandReceived) {
 5641               		.loc 1 2954 0
 5642               	.LVL400:
 5643 201c EF92      		push r14
 5644               	.LCFI144:
 5645 201e FF92      		push r15
 5646               	.LCFI145:
 5647 2020 0F93      		push r16
 5648               	.LCFI146:
 5649 2022 1F93      		push r17
 5650               	.LCFI147:
 5651 2024 CF93      		push r28
 5652               	.LCFI148:
 5653 2026 DF93      		push r29
 5654               	.LCFI149:
 5655 2028 00D0      		rcall .
 5656 202a 00D0      		rcall .
 5657 202c 00D0      		rcall .
 5658               	.LCFI150:
 5659 202e CDB7      		in r28,__SP_L__
 5660 2030 DEB7      		in r29,__SP_H__
 5661               	.LCFI151:
 5662               	/* prologue: function */
 5663               	/* frame size = 6 */
 5664               	/* stack size = 12 */
 5665               	.L__stack_usage = 12
 5666               	.LVL401:
2957:switcherator.c ****     statusMsg[0] = 0;
 5667               		.loc 1 2957 0
 5668 2032 1092 0000 		sts statusMsg,__zero_reg__
2958:switcherator.c ****     if(commandReceived[3] == '1') {
 5669               		.loc 1 2958 0
 5670 2036 FC01      		movw r30,r24
 5671 2038 8381      		ldd r24,Z+3
 5672               	.LVL402:
 5673 203a 8133      		cpi r24,lo8(49)
 5674 203c 01F4      		brne .L423
2959:switcherator.c ****             unformatAddress(rx_addr_p1, tempRadioString);
 5675               		.loc 1 2959 0
 5676 203e 2091 0000 		lds r18,rx_addr_p1
 5677 2042 3091 0000 		lds r19,rx_addr_p1+1
 5678 2046 4091 0000 		lds r20,rx_addr_p1+2
 5679 204a 5091 0000 		lds r21,rx_addr_p1+3
 5680 204e 6091 0000 		lds r22,rx_addr_p1+4
 5681 2052 7091 0000 		lds r23,rx_addr_p1+5
 5682 2056 8E01      		movw r16,r28
 5683 2058 0F5F      		subi r16,-1
 5684 205a 1F4F      		sbci r17,-1
 5685 205c 8091 0000 		lds r24,rx_addr_p1+6
 5686 2060 9091 0000 		lds r25,rx_addr_p1+7
 5687 2064 0E94 0000 		call unformatAddress
 5688               	.LVL403:
2960:switcherator.c ****             strcat(statusMsg, "r1-0x");
 5689               		.loc 1 2960 0
 5690 2068 60E0      		ldi r22,lo8(.LC16)
 5691 206a 70E0      		ldi r23,hi8(.LC16)
 5692               	.L432:
 5693 206c 80E0      		ldi r24,lo8(statusMsg)
 5694 206e 90E0      		ldi r25,hi8(statusMsg)
 5695 2070 0E94 0000 		call strcat
 5696               	.LVL404:
 5697 2074 8E01      		movw r16,r28
 5698 2076 0F5F      		subi r16,-1
 5699 2078 1F4F      		sbci r17,-1
2954:switcherator.c **** void radioDisplayAddress(char * commandReceived) {
 5700               		.loc 1 2954 0
 5701 207a 7E01      		movw r14,r28
 5702 207c F6E0      		ldi r31,6
 5703 207e EF0E      		add r14,r31
 5704 2080 F11C      		adc r15,__zero_reg__
 5705 2082 00C0      		rjmp .L424
 5706               	.LVL405:
 5707               	.L423:
2961:switcherator.c ****     } else if(commandReceived[3] == '2') {
 5708               		.loc 1 2961 0
 5709 2084 8233      		cpi r24,lo8(50)
 5710 2086 01F4      		brne .L425
2962:switcherator.c ****             unformatAddress(rx_addr_p2, tempRadioString);
 5711               		.loc 1 2962 0
 5712 2088 2091 0000 		lds r18,rx_addr_p2
 5713 208c 3091 0000 		lds r19,rx_addr_p2+1
 5714 2090 4091 0000 		lds r20,rx_addr_p2+2
 5715 2094 5091 0000 		lds r21,rx_addr_p2+3
 5716 2098 6091 0000 		lds r22,rx_addr_p2+4
 5717 209c 7091 0000 		lds r23,rx_addr_p2+5
 5718 20a0 8E01      		movw r16,r28
 5719 20a2 0F5F      		subi r16,-1
 5720 20a4 1F4F      		sbci r17,-1
 5721 20a6 8091 0000 		lds r24,rx_addr_p2+6
 5722 20aa 9091 0000 		lds r25,rx_addr_p2+7
 5723 20ae 0E94 0000 		call unformatAddress
 5724               	.LVL406:
2963:switcherator.c ****             strcat(statusMsg, "r2-0x");
 5725               		.loc 1 2963 0
 5726 20b2 60E0      		ldi r22,lo8(.LC17)
 5727 20b4 70E0      		ldi r23,hi8(.LC17)
 5728 20b6 00C0      		rjmp .L432
 5729               	.LVL407:
 5730               	.L425:
2964:switcherator.c ****     } else if(commandReceived[3] == '3') {
 5731               		.loc 1 2964 0
 5732 20b8 8333      		cpi r24,lo8(51)
 5733 20ba 01F4      		brne .L427
2965:switcherator.c ****             unformatAddress(rx_addr_p3, tempRadioString);
 5734               		.loc 1 2965 0
 5735 20bc 2091 0000 		lds r18,rx_addr_p3
 5736 20c0 3091 0000 		lds r19,rx_addr_p3+1
 5737 20c4 4091 0000 		lds r20,rx_addr_p3+2
 5738 20c8 5091 0000 		lds r21,rx_addr_p3+3
 5739 20cc 6091 0000 		lds r22,rx_addr_p3+4
 5740 20d0 7091 0000 		lds r23,rx_addr_p3+5
 5741 20d4 8E01      		movw r16,r28
 5742 20d6 0F5F      		subi r16,-1
 5743 20d8 1F4F      		sbci r17,-1
 5744 20da 8091 0000 		lds r24,rx_addr_p3+6
 5745 20de 9091 0000 		lds r25,rx_addr_p3+7
 5746 20e2 0E94 0000 		call unformatAddress
 5747               	.LVL408:
2966:switcherator.c ****             strcat(statusMsg, "r3-0x");
 5748               		.loc 1 2966 0
 5749 20e6 60E0      		ldi r22,lo8(.LC18)
 5750 20e8 70E0      		ldi r23,hi8(.LC18)
 5751 20ea 00C0      		rjmp .L432
 5752               	.LVL409:
 5753               	.L427:
2967:switcherator.c ****     } else if(commandReceived[3] == '4') {
 5754               		.loc 1 2967 0
 5755 20ec 8433      		cpi r24,lo8(52)
 5756 20ee 01F4      		brne .L428
2968:switcherator.c ****             unformatAddress(rx_addr_p4, tempRadioString);
 5757               		.loc 1 2968 0
 5758 20f0 2091 0000 		lds r18,rx_addr_p4
 5759 20f4 3091 0000 		lds r19,rx_addr_p4+1
 5760 20f8 4091 0000 		lds r20,rx_addr_p4+2
 5761 20fc 5091 0000 		lds r21,rx_addr_p4+3
 5762 2100 6091 0000 		lds r22,rx_addr_p4+4
 5763 2104 7091 0000 		lds r23,rx_addr_p4+5
 5764 2108 8E01      		movw r16,r28
 5765 210a 0F5F      		subi r16,-1
 5766 210c 1F4F      		sbci r17,-1
 5767 210e 8091 0000 		lds r24,rx_addr_p4+6
 5768 2112 9091 0000 		lds r25,rx_addr_p4+7
 5769 2116 0E94 0000 		call unformatAddress
 5770               	.LVL410:
2969:switcherator.c ****             strcat(statusMsg, "r4-0x");
 5771               		.loc 1 2969 0
 5772 211a 60E0      		ldi r22,lo8(.LC19)
 5773 211c 70E0      		ldi r23,hi8(.LC19)
 5774 211e 00C0      		rjmp .L432
 5775               	.LVL411:
 5776               	.L428:
2970:switcherator.c ****     } else if (commandReceived[3] == '5') {
 5777               		.loc 1 2970 0
 5778 2120 8533      		cpi r24,lo8(53)
 5779 2122 01F4      		brne .L429
2971:switcherator.c ****             unformatAddress(rx_addr_p5, tempRadioString);
 5780               		.loc 1 2971 0
 5781 2124 2091 0000 		lds r18,rx_addr_p5
 5782 2128 3091 0000 		lds r19,rx_addr_p5+1
 5783 212c 4091 0000 		lds r20,rx_addr_p5+2
 5784 2130 5091 0000 		lds r21,rx_addr_p5+3
 5785 2134 6091 0000 		lds r22,rx_addr_p5+4
 5786 2138 7091 0000 		lds r23,rx_addr_p5+5
 5787 213c 8E01      		movw r16,r28
 5788 213e 0F5F      		subi r16,-1
 5789 2140 1F4F      		sbci r17,-1
 5790 2142 8091 0000 		lds r24,rx_addr_p5+6
 5791 2146 9091 0000 		lds r25,rx_addr_p5+7
 5792 214a 0E94 0000 		call unformatAddress
 5793               	.LVL412:
2972:switcherator.c ****             strcat(statusMsg, "r5-0x");
 5794               		.loc 1 2972 0
 5795 214e 60E0      		ldi r22,lo8(.LC20)
 5796 2150 70E0      		ldi r23,hi8(.LC20)
 5797 2152 00C0      		rjmp .L432
 5798               	.LVL413:
 5799               	.L429:
2973:switcherator.c ****     } else if (commandReceived[3] == 'T') {
 5800               		.loc 1 2973 0
 5801 2154 8435      		cpi r24,lo8(84)
 5802 2156 01F4      		brne .L430
2974:switcherator.c ****             unformatAddress(tx_addr, tempRadioString);
 5803               		.loc 1 2974 0
 5804 2158 2091 0000 		lds r18,tx_addr
 5805 215c 3091 0000 		lds r19,tx_addr+1
 5806 2160 4091 0000 		lds r20,tx_addr+2
 5807 2164 5091 0000 		lds r21,tx_addr+3
 5808 2168 6091 0000 		lds r22,tx_addr+4
 5809 216c 7091 0000 		lds r23,tx_addr+5
 5810 2170 8E01      		movw r16,r28
 5811 2172 0F5F      		subi r16,-1
 5812 2174 1F4F      		sbci r17,-1
 5813 2176 8091 0000 		lds r24,tx_addr+6
 5814 217a 9091 0000 		lds r25,tx_addr+7
 5815 217e 0E94 0000 		call unformatAddress
 5816               	.LVL414:
2975:switcherator.c ****             strcat(statusMsg, "t-0x");
 5817               		.loc 1 2975 0
 5818 2182 60E0      		ldi r22,lo8(.LC21)
 5819 2184 70E0      		ldi r23,hi8(.LC21)
 5820 2186 00C0      		rjmp .L432
 5821               	.LVL415:
 5822               	.L430:
2977:switcherator.c ****             unformatAddress(rx_addr_p0, tempRadioString);
 5823               		.loc 1 2977 0
 5824 2188 2091 0000 		lds r18,rx_addr_p0
 5825 218c 3091 0000 		lds r19,rx_addr_p0+1
 5826 2190 4091 0000 		lds r20,rx_addr_p0+2
 5827 2194 5091 0000 		lds r21,rx_addr_p0+3
 5828 2198 6091 0000 		lds r22,rx_addr_p0+4
 5829 219c 7091 0000 		lds r23,rx_addr_p0+5
 5830 21a0 8E01      		movw r16,r28
 5831 21a2 0F5F      		subi r16,-1
 5832 21a4 1F4F      		sbci r17,-1
 5833 21a6 8091 0000 		lds r24,rx_addr_p0+6
 5834 21aa 9091 0000 		lds r25,rx_addr_p0+7
 5835 21ae 0E94 0000 		call unformatAddress
 5836               	.LVL416:
2978:switcherator.c ****             strcat(statusMsg, "r0-0x");
 5837               		.loc 1 2978 0
 5838 21b2 60E0      		ldi r22,lo8(.LC22)
 5839 21b4 70E0      		ldi r23,hi8(.LC22)
 5840 21b6 00C0      		rjmp .L432
 5841               	.LVL417:
 5842               	.L424:
2981:switcherator.c ****         returnHexWithout(tempRadioString[x], tempLongString);
 5843               		.loc 1 2981 0 discriminator 2
 5844 21b8 60E0      		ldi r22,lo8(tempLongString)
 5845 21ba 70E0      		ldi r23,hi8(tempLongString)
 5846 21bc F801      		movw r30,r16
 5847 21be 8191      		ld r24,Z+
 5848 21c0 8F01      		movw r16,r30
 5849 21c2 90E0      		ldi r25,0
 5850 21c4 0E94 0000 		call returnHexWithout
 5851               	.LVL418:
2982:switcherator.c ****         strcat(statusMsg, tempLongString);
 5852               		.loc 1 2982 0 discriminator 2
 5853 21c8 60E0      		ldi r22,lo8(tempLongString)
 5854 21ca 70E0      		ldi r23,hi8(tempLongString)
 5855 21cc 80E0      		ldi r24,lo8(statusMsg)
 5856 21ce 90E0      		ldi r25,hi8(statusMsg)
 5857 21d0 0E94 0000 		call strcat
 5858               	.LVL419:
2980:switcherator.c ****     for (x = 0; x < 5; x++) {
 5859               		.loc 1 2980 0 discriminator 2
 5860 21d4 0E15      		cp r16,r14
 5861 21d6 1F05      		cpc r17,r15
 5862 21d8 01F4      		brne .L424
2984:switcherator.c ****     sendMessage(statusMsg);
 5863               		.loc 1 2984 0
 5864 21da 80E0      		ldi r24,lo8(statusMsg)
 5865 21dc 90E0      		ldi r25,hi8(statusMsg)
 5866 21de 0E94 0000 		call sendMessage
 5867               	.LVL420:
 5868               	/* epilogue start */
2985:switcherator.c **** }
 5869               		.loc 1 2985 0
 5870 21e2 2696      		adiw r28,6
 5871 21e4 0FB6      		in __tmp_reg__,__SREG__
 5872 21e6 F894      		cli
 5873 21e8 DEBF      		out __SP_H__,r29
 5874 21ea 0FBE      		out __SREG__,__tmp_reg__
 5875 21ec CDBF      		out __SP_L__,r28
 5876 21ee DF91      		pop r29
 5877 21f0 CF91      		pop r28
 5878 21f2 1F91      		pop r17
 5879 21f4 0F91      		pop r16
 5880 21f6 FF90      		pop r15
 5881 21f8 EF90      		pop r14
 5882 21fa 0895      		ret
 5883               	.LFE73:
 5885               		.section	.rodata.str1.1
 5886               	.LC23:
 5887 006d 5377 4F6E 		.string	"SwOn"
 5887      00
 5888               	.LC24:
 5889 0072 7900      		.string	"y"
 5890               	.LC25:
 5891 0074 6E00      		.string	"n"
 5892               		.text
 5893               	.global	switchesOn
 5895               	switchesOn:
 5896               	.LFB66:
2832:switcherator.c **** void switchesOn(void) {
 5897               		.loc 1 2832 0
 5898 21fc CF93      		push r28
 5899               	.LCFI152:
 5900 21fe DF93      		push r29
 5901               	.LCFI153:
 5902               	/* prologue: function */
 5903               	/* frame size = 0 */
 5904               	/* stack size = 2 */
 5905               	.L__stack_usage = 2
2833:switcherator.c ****     statusMsg[0] = 0;
 5906               		.loc 1 2833 0
 5907 2200 1092 0000 		sts statusMsg,__zero_reg__
2834:switcherator.c ****     strcat(statusMsg, "SwOn");
 5908               		.loc 1 2834 0
 5909 2204 60E0      		ldi r22,lo8(.LC23)
 5910 2206 70E0      		ldi r23,hi8(.LC23)
 5911 2208 80E0      		ldi r24,lo8(statusMsg)
 5912 220a 90E0      		ldi r25,hi8(statusMsg)
 5913 220c 0E94 0000 		call strcat
 5914               	.LVL421:
 5915 2210 C0E0      		ldi r28,lo8(switchStatus)
 5916 2212 D0E0      		ldi r29,hi8(switchStatus)
 5917               	.LVL422:
 5918               	.L437:
2837:switcherator.c ****         if (switchStatus[x] > 0) {
 5919               		.loc 1 2837 0
 5920 2214 8991      		ld r24,Y+
 5921 2216 9991      		ld r25,Y+
 5922 2218 A991      		ld r26,Y+
 5923 221a B991      		ld r27,Y+
 5924 221c 892B      		or r24,r25
 5925 221e 8A2B      		or r24,r26
 5926 2220 8B2B      		or r24,r27
 5927 2222 01F0      		breq .L434
2838:switcherator.c ****             strcat(statusMsg, "y");
 5928               		.loc 1 2838 0
 5929 2224 60E0      		ldi r22,lo8(.LC24)
 5930 2226 70E0      		ldi r23,hi8(.LC24)
 5931 2228 00C0      		rjmp .L439
 5932               	.L434:
2840:switcherator.c ****             strcat(statusMsg, "n");
 5933               		.loc 1 2840 0
 5934 222a 60E0      		ldi r22,lo8(.LC25)
 5935 222c 70E0      		ldi r23,hi8(.LC25)
 5936               	.L439:
 5937 222e 80E0      		ldi r24,lo8(statusMsg)
 5938 2230 90E0      		ldi r25,hi8(statusMsg)
 5939 2232 0E94 0000 		call strcat
 5940               	.LVL423:
2842:switcherator.c ****         if (strlen(statusMsg) > 30) {
 5941               		.loc 1 2842 0
 5942 2236 E0E0      		ldi r30,lo8(statusMsg)
 5943 2238 F0E0      		ldi r31,hi8(statusMsg)
 5944               		0:
 5945 223a 0190      		ld __tmp_reg__,Z+
 5946 223c 0020      		tst __tmp_reg__
 5947 223e 01F4      		brne 0b
 5948 2240 3197      		sbiw r30,1
 5949 2242 E050      		subi r30,lo8(statusMsg)
 5950 2244 F040      		sbci r31,hi8(statusMsg)
 5951 2246 7F97      		sbiw r30,31
 5952 2248 00F0      		brlo .L436
2843:switcherator.c ****             sendMessage(statusMsg);
 5953               		.loc 1 2843 0
 5954 224a 80E0      		ldi r24,lo8(statusMsg)
 5955 224c 90E0      		ldi r25,hi8(statusMsg)
 5956 224e 0E94 0000 		call sendMessage
 5957               	.LVL424:
2844:switcherator.c ****             statusMsg[4] = 0;
 5958               		.loc 1 2844 0
 5959 2252 1092 0000 		sts statusMsg+4,__zero_reg__
 5960               	.L436:
2836:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 5961               		.loc 1 2836 0
 5962 2256 80E0      		ldi r24,hi8(switchStatus+64)
 5963 2258 C030      		cpi r28,lo8(switchStatus+64)
 5964 225a D807      		cpc r29,r24
 5965 225c 01F4      		brne .L437
2847:switcherator.c ****     sendMessage(statusMsg);
 5966               		.loc 1 2847 0
 5967 225e 80E0      		ldi r24,lo8(statusMsg)
 5968 2260 90E0      		ldi r25,hi8(statusMsg)
 5969               	/* epilogue start */
2848:switcherator.c **** }
 5970               		.loc 1 2848 0
 5971 2262 DF91      		pop r29
 5972 2264 CF91      		pop r28
2847:switcherator.c ****     sendMessage(statusMsg);
 5973               		.loc 1 2847 0
 5974 2266 0C94 0000 		jmp sendMessage
 5975               	.LVL425:
 5976               	.LFE66:
 5978               		.section	.rodata.str1.1
 5979               	.LC26:
 5980 0076 496E 00   		.string	"In"
 5981               		.text
 5982               	.global	inputsProgrammed
 5984               	inputsProgrammed:
 5985               	.LFB65:
2812:switcherator.c **** void inputsProgrammed(void) {
 5986               		.loc 1 2812 0
 5987 226a CF93      		push r28
 5988               	.LCFI154:
 5989 226c DF93      		push r29
 5990               	.LCFI155:
 5991               	/* prologue: function */
 5992               	/* frame size = 0 */
 5993               	/* stack size = 2 */
 5994               	.L__stack_usage = 2
2813:switcherator.c ****     statusMsg[0] = 0;
 5995               		.loc 1 2813 0
 5996 226e 1092 0000 		sts statusMsg,__zero_reg__
2814:switcherator.c ****     strcat(statusMsg, "In");
 5997               		.loc 1 2814 0
 5998 2272 60E0      		ldi r22,lo8(.LC26)
 5999 2274 70E0      		ldi r23,hi8(.LC26)
 6000 2276 80E0      		ldi r24,lo8(statusMsg)
 6001 2278 90E0      		ldi r25,hi8(statusMsg)
 6002 227a 0E94 0000 		call strcat
 6003               	.LVL426:
 6004 227e C0E0      		ldi r28,lo8(inputs)
 6005 2280 D0E0      		ldi r29,hi8(inputs)
 6006               	.LVL427:
 6007               	.L444:
2817:switcherator.c ****         if (inputs[x][0] == 255) {
 6008               		.loc 1 2817 0
 6009 2282 8881      		ld r24,Y
 6010 2284 8F3F      		cpi r24,lo8(-1)
 6011 2286 01F4      		brne .L441
2818:switcherator.c ****             strcat(statusMsg, "n");
 6012               		.loc 1 2818 0
 6013 2288 60E0      		ldi r22,lo8(.LC25)
 6014 228a 70E0      		ldi r23,hi8(.LC25)
 6015 228c 00C0      		rjmp .L446
 6016               	.L441:
2820:switcherator.c ****             strcat(statusMsg, "y");
 6017               		.loc 1 2820 0
 6018 228e 60E0      		ldi r22,lo8(.LC24)
 6019 2290 70E0      		ldi r23,hi8(.LC24)
 6020               	.L446:
 6021 2292 80E0      		ldi r24,lo8(statusMsg)
 6022 2294 90E0      		ldi r25,hi8(statusMsg)
 6023 2296 0E94 0000 		call strcat
 6024               	.LVL428:
2823:switcherator.c ****         if (strlen(statusMsg) > 30) {
 6025               		.loc 1 2823 0
 6026 229a E0E0      		ldi r30,lo8(statusMsg)
 6027 229c F0E0      		ldi r31,hi8(statusMsg)
 6028               		0:
 6029 229e 0190      		ld __tmp_reg__,Z+
 6030 22a0 0020      		tst __tmp_reg__
 6031 22a2 01F4      		brne 0b
 6032 22a4 3197      		sbiw r30,1
 6033 22a6 E050      		subi r30,lo8(statusMsg)
 6034 22a8 F040      		sbci r31,hi8(statusMsg)
 6035 22aa 7F97      		sbiw r30,31
 6036 22ac 00F0      		brlo .L443
2824:switcherator.c ****             sendMessage(statusMsg);
 6037               		.loc 1 2824 0
 6038 22ae 80E0      		ldi r24,lo8(statusMsg)
 6039 22b0 90E0      		ldi r25,hi8(statusMsg)
 6040 22b2 0E94 0000 		call sendMessage
 6041               	.LVL429:
2825:switcherator.c ****             statusMsg[2] = 0;
 6042               		.loc 1 2825 0
 6043 22b6 1092 0000 		sts statusMsg+2,__zero_reg__
 6044               	.L443:
 6045 22ba 2896      		adiw r28,8
2816:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 6046               		.loc 1 2816 0
 6047 22bc 80E0      		ldi r24,hi8(inputs+32)
 6048 22be C030      		cpi r28,lo8(inputs+32)
 6049 22c0 D807      		cpc r29,r24
 6050 22c2 01F4      		brne .L444
2828:switcherator.c ****     sendMessage(statusMsg);
 6051               		.loc 1 2828 0
 6052 22c4 80E0      		ldi r24,lo8(statusMsg)
 6053 22c6 90E0      		ldi r25,hi8(statusMsg)
 6054               	/* epilogue start */
2829:switcherator.c **** }
 6055               		.loc 1 2829 0
 6056 22c8 DF91      		pop r29
 6057 22ca CF91      		pop r28
2828:switcherator.c ****     sendMessage(statusMsg);
 6058               		.loc 1 2828 0
 6059 22cc 0C94 0000 		jmp sendMessage
 6060               	.LVL430:
 6061               	.LFE65:
 6063               		.section	.rodata.str1.1
 6064               	.LC27:
 6065 0079 5377 6900 		.string	"Swi"
 6066               		.text
 6067               	.global	switchesProgrammed
 6069               	switchesProgrammed:
 6070               	.LFB64:
2791:switcherator.c **** void switchesProgrammed(void) {
 6071               		.loc 1 2791 0
 6072 22d0 CF93      		push r28
 6073               	.LCFI156:
 6074 22d2 DF93      		push r29
 6075               	.LCFI157:
 6076               	/* prologue: function */
 6077               	/* frame size = 0 */
 6078               	/* stack size = 2 */
 6079               	.L__stack_usage = 2
2792:switcherator.c ****     statusMsg[0] = 0;
 6080               		.loc 1 2792 0
 6081 22d4 1092 0000 		sts statusMsg,__zero_reg__
2793:switcherator.c ****     strcat(statusMsg, "Swi");
 6082               		.loc 1 2793 0
 6083 22d8 60E0      		ldi r22,lo8(.LC27)
 6084 22da 70E0      		ldi r23,hi8(.LC27)
 6085 22dc 80E0      		ldi r24,lo8(statusMsg)
 6086 22de 90E0      		ldi r25,hi8(statusMsg)
 6087 22e0 0E94 0000 		call strcat
 6088               	.LVL431:
 6089 22e4 C0E0      		ldi r28,lo8(switchStuff)
 6090 22e6 D0E0      		ldi r29,hi8(switchStuff)
 6091               	.LVL432:
 6092               	.L451:
2797:switcherator.c ****         if (switchStuff[x] == 255) {
 6093               		.loc 1 2797 0
 6094 22e8 8991      		ld r24,Y+
 6095 22ea 8F3F      		cpi r24,lo8(-1)
 6096 22ec 01F4      		brne .L448
2798:switcherator.c ****             strcat(statusMsg, "n");
 6097               		.loc 1 2798 0
 6098 22ee 60E0      		ldi r22,lo8(.LC25)
 6099 22f0 70E0      		ldi r23,hi8(.LC25)
 6100 22f2 00C0      		rjmp .L453
 6101               	.L448:
2800:switcherator.c ****             strcat(statusMsg, "y");
 6102               		.loc 1 2800 0
 6103 22f4 60E0      		ldi r22,lo8(.LC24)
 6104 22f6 70E0      		ldi r23,hi8(.LC24)
 6105               	.L453:
 6106 22f8 80E0      		ldi r24,lo8(statusMsg)
 6107 22fa 90E0      		ldi r25,hi8(statusMsg)
 6108 22fc 0E94 0000 		call strcat
 6109               	.LVL433:
2803:switcherator.c ****         if (strlen(statusMsg) > 30) {
 6110               		.loc 1 2803 0
 6111 2300 E0E0      		ldi r30,lo8(statusMsg)
 6112 2302 F0E0      		ldi r31,hi8(statusMsg)
 6113               		0:
 6114 2304 0190      		ld __tmp_reg__,Z+
 6115 2306 0020      		tst __tmp_reg__
 6116 2308 01F4      		brne 0b
 6117 230a 3197      		sbiw r30,1
 6118 230c E050      		subi r30,lo8(statusMsg)
 6119 230e F040      		sbci r31,hi8(statusMsg)
 6120 2310 7F97      		sbiw r30,31
 6121 2312 00F0      		brlo .L450
2804:switcherator.c ****             sendMessage(statusMsg);
 6122               		.loc 1 2804 0
 6123 2314 80E0      		ldi r24,lo8(statusMsg)
 6124 2316 90E0      		ldi r25,hi8(statusMsg)
 6125 2318 0E94 0000 		call sendMessage
 6126               	.LVL434:
2805:switcherator.c ****             statusMsg[3] = 0;
 6127               		.loc 1 2805 0
 6128 231c 1092 0000 		sts statusMsg+3,__zero_reg__
 6129               	.L450:
2795:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 6130               		.loc 1 2795 0
 6131 2320 80E0      		ldi r24,hi8(switchStuff+16)
 6132 2322 C030      		cpi r28,lo8(switchStuff+16)
 6133 2324 D807      		cpc r29,r24
 6134 2326 01F4      		brne .L451
2808:switcherator.c ****     sendMessage(statusMsg);
 6135               		.loc 1 2808 0
 6136 2328 80E0      		ldi r24,lo8(statusMsg)
 6137 232a 90E0      		ldi r25,hi8(statusMsg)
 6138               	/* epilogue start */
2809:switcherator.c **** }
 6139               		.loc 1 2809 0
 6140 232c DF91      		pop r29
 6141 232e CF91      		pop r28
2808:switcherator.c ****     sendMessage(statusMsg);
 6142               		.loc 1 2808 0
 6143 2330 0C94 0000 		jmp sendMessage
 6144               	.LVL435:
 6145               	.LFE64:
 6147               		.section	.rodata.str1.1
 6148               	.LC28:
 6149 007d 5072 6F67 		.string	"Progs"
 6149      7300 
 6150               		.text
 6151               	.global	programsProgrammed
 6153               	programsProgrammed:
 6154               	.LFB63:
2773:switcherator.c **** void programsProgrammed(void) {
 6155               		.loc 1 2773 0
 6156 2334 CF93      		push r28
 6157               	.LCFI158:
 6158 2336 DF93      		push r29
 6159               	.LCFI159:
 6160               	/* prologue: function */
 6161               	/* frame size = 0 */
 6162               	/* stack size = 2 */
 6163               	.L__stack_usage = 2
2774:switcherator.c ****     strcat(statusMsg, "Progs");
 6164               		.loc 1 2774 0
 6165 2338 60E0      		ldi r22,lo8(.LC28)
 6166 233a 70E0      		ldi r23,hi8(.LC28)
 6167 233c 80E0      		ldi r24,lo8(statusMsg)
 6168 233e 90E0      		ldi r25,hi8(statusMsg)
 6169 2340 0E94 0000 		call strcat
 6170               	.LVL436:
 6171 2344 C0E0      		ldi r28,lo8(weeklyProgram+1)
 6172 2346 D0E0      		ldi r29,hi8(weeklyProgram+1)
 6173               	.LVL437:
 6174               	.L458:
2773:switcherator.c **** void programsProgrammed(void) {
 6175               		.loc 1 2773 0
 6176 2348 FE01      		movw r30,r28
 6177 234a 3197      		sbiw r30,1
2777:switcherator.c ****         if (weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) {
 6178               		.loc 1 2777 0
 6179 234c 8081      		ld r24,Z
 6180 234e 8F3F      		cpi r24,lo8(-1)
 6181 2350 01F4      		brne .L455
2777:switcherator.c ****         if (weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) {
 6182               		.loc 1 2777 0 is_stmt 0 discriminator 1
 6183 2352 8881      		ld r24,Y
 6184 2354 8F3F      		cpi r24,lo8(-1)
 6185 2356 01F4      		brne .L455
2778:switcherator.c ****             strcat(statusMsg, "n");
 6186               		.loc 1 2778 0 is_stmt 1
 6187 2358 60E0      		ldi r22,lo8(.LC25)
 6188 235a 70E0      		ldi r23,hi8(.LC25)
 6189 235c 00C0      		rjmp .L460
 6190               	.L455:
2780:switcherator.c ****             strcat(statusMsg, "y");
 6191               		.loc 1 2780 0
 6192 235e 60E0      		ldi r22,lo8(.LC24)
 6193 2360 70E0      		ldi r23,hi8(.LC24)
 6194               	.L460:
 6195 2362 80E0      		ldi r24,lo8(statusMsg)
 6196 2364 90E0      		ldi r25,hi8(statusMsg)
 6197 2366 0E94 0000 		call strcat
 6198               	.LVL438:
2783:switcherator.c ****         if (strlen(statusMsg) > 30) {
 6199               		.loc 1 2783 0
 6200 236a E0E0      		ldi r30,lo8(statusMsg)
 6201 236c F0E0      		ldi r31,hi8(statusMsg)
 6202               		0:
 6203 236e 0190      		ld __tmp_reg__,Z+
 6204 2370 0020      		tst __tmp_reg__
 6205 2372 01F4      		brne 0b
 6206 2374 3197      		sbiw r30,1
 6207 2376 E050      		subi r30,lo8(statusMsg)
 6208 2378 F040      		sbci r31,hi8(statusMsg)
 6209 237a 7F97      		sbiw r30,31
 6210 237c 00F0      		brlo .L457
2784:switcherator.c ****             sendMessage(statusMsg);
 6211               		.loc 1 2784 0
 6212 237e 80E0      		ldi r24,lo8(statusMsg)
 6213 2380 90E0      		ldi r25,hi8(statusMsg)
 6214 2382 0E94 0000 		call sendMessage
 6215               	.LVL439:
2785:switcherator.c ****             statusMsg[5] = 0;
 6216               		.loc 1 2785 0
 6217 2386 1092 0000 		sts statusMsg+5,__zero_reg__
 6218               	.L457:
 6219 238a 2A96      		adiw r28,10
2776:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 6220               		.loc 1 2776 0
 6221 238c 80E0      		ldi r24,hi8(weeklyProgram+101)
 6222 238e C030      		cpi r28,lo8(weeklyProgram+101)
 6223 2390 D807      		cpc r29,r24
 6224 2392 01F4      		brne .L458
2788:switcherator.c ****     sendMessage(statusMsg);    
 6225               		.loc 1 2788 0
 6226 2394 80E0      		ldi r24,lo8(statusMsg)
 6227 2396 90E0      		ldi r25,hi8(statusMsg)
 6228               	/* epilogue start */
2789:switcherator.c **** }
 6229               		.loc 1 2789 0
 6230 2398 DF91      		pop r29
 6231 239a CF91      		pop r28
2788:switcherator.c ****     sendMessage(statusMsg);    
 6232               		.loc 1 2788 0
 6233 239c 0C94 0000 		jmp sendMessage
 6234               	.LVL440:
 6235               	.LFE63:
 6237               		.section	.rodata.str1.1
 6238               	.LC29:
 6239 0083 5072 2C00 		.string	"Pr,"
 6240               	.LC30:
 6241 0087 2C53 772C 		.string	",Sw,"
 6241      00
 6242               	.LC31:
 6243 008c 2C49 6E2C 		.string	",In,"
 6243      00
 6244               	.LC32:
 6245 0091 2C4C 692C 		.string	",Li,"
 6245      00
 6246               	.LC33:
 6247 0096 2C43 432C 		.string	",CC,"
 6247      00
 6248               		.text
 6249               	.global	generalInformation
 6251               	generalInformation:
 6252               	.LFB62:
2711:switcherator.c **** void generalInformation(void) {
 6253               		.loc 1 2711 0
 6254               	/* prologue: function */
 6255               	/* frame size = 0 */
 6256               	/* stack size = 0 */
 6257               	.L__stack_usage = 0
2712:switcherator.c ****     statusMsg[0] = 0;
 6258               		.loc 1 2712 0
 6259 23a0 1092 0000 		sts statusMsg,__zero_reg__
2713:switcherator.c ****     strcat(statusMsg,"Pr,");
 6260               		.loc 1 2713 0
 6261 23a4 60E0      		ldi r22,lo8(.LC29)
 6262 23a6 70E0      		ldi r23,hi8(.LC29)
 6263 23a8 80E0      		ldi r24,lo8(statusMsg)
 6264 23aa 90E0      		ldi r25,hi8(statusMsg)
 6265 23ac 0E94 0000 		call strcat
 6266               	.LVL441:
 6267 23b0 E0E0      		ldi r30,lo8(weeklyProgram+1)
 6268 23b2 F0E0      		ldi r31,hi8(weeklyProgram+1)
2714:switcherator.c ****     int count = 0;
 6269               		.loc 1 2714 0
 6270 23b4 80E0      		ldi r24,0
 6271 23b6 90E0      		ldi r25,0
 6272               	.LVL442:
 6273               	.L463:
2711:switcherator.c **** void generalInformation(void) {
 6274               		.loc 1 2711 0
 6275 23b8 DF01      		movw r26,r30
 6276 23ba 1197      		sbiw r26,1
2717:switcherator.c ****         if(weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) 
 6277               		.loc 1 2717 0
 6278 23bc 2C91      		ld r18,X
 6279 23be 2F3F      		cpi r18,lo8(-1)
 6280 23c0 01F4      		brne .L462
2717:switcherator.c ****         if(weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) 
 6281               		.loc 1 2717 0 is_stmt 0 discriminator 1
 6282 23c2 2081      		ld r18,Z
 6283 23c4 2F3F      		cpi r18,lo8(-1)
 6284 23c6 01F4      		brne .L462
2718:switcherator.c ****             count++;
 6285               		.loc 1 2718 0 is_stmt 1
 6286 23c8 0196      		adiw r24,1
 6287               	.LVL443:
 6288               	.L462:
 6289 23ca 3A96      		adiw r30,10
2716:switcherator.c ****     for(x=0;x<MAX_PROGRAM;x++) {
 6290               		.loc 1 2716 0
 6291 23cc 20E0      		ldi r18,hi8(weeklyProgram+101)
 6292 23ce E030      		cpi r30,lo8(weeklyProgram+101)
 6293 23d0 F207      		cpc r31,r18
 6294 23d2 01F4      		brne .L463
2720:switcherator.c ****     returnInt(count,tempLongString);
 6295               		.loc 1 2720 0
 6296 23d4 60E0      		ldi r22,lo8(tempLongString)
 6297 23d6 70E0      		ldi r23,hi8(tempLongString)
 6298 23d8 0E94 0000 		call returnInt
 6299               	.LVL444:
2721:switcherator.c ****     strcat(statusMsg,tempLongString);
 6300               		.loc 1 2721 0
 6301 23dc 60E0      		ldi r22,lo8(tempLongString)
 6302 23de 70E0      		ldi r23,hi8(tempLongString)
 6303 23e0 80E0      		ldi r24,lo8(statusMsg)
 6304 23e2 90E0      		ldi r25,hi8(statusMsg)
 6305 23e4 0E94 0000 		call strcat
 6306               	.LVL445:
2722:switcherator.c ****     strcat(statusMsg,"/");
 6307               		.loc 1 2722 0
 6308 23e8 60E0      		ldi r22,lo8(.LC3)
 6309 23ea 70E0      		ldi r23,hi8(.LC3)
 6310 23ec 80E0      		ldi r24,lo8(statusMsg)
 6311 23ee 90E0      		ldi r25,hi8(statusMsg)
 6312 23f0 0E94 0000 		call strcat
 6313               	.LVL446:
2723:switcherator.c ****     returnInt(MAX_PROGRAM,tempLongString);
 6314               		.loc 1 2723 0
 6315 23f4 60E0      		ldi r22,lo8(tempLongString)
 6316 23f6 70E0      		ldi r23,hi8(tempLongString)
 6317 23f8 8AE0      		ldi r24,lo8(10)
 6318 23fa 90E0      		ldi r25,0
 6319 23fc 0E94 0000 		call returnInt
 6320               	.LVL447:
2724:switcherator.c ****     strcat(statusMsg,tempLongString);
 6321               		.loc 1 2724 0
 6322 2400 60E0      		ldi r22,lo8(tempLongString)
 6323 2402 70E0      		ldi r23,hi8(tempLongString)
 6324 2404 80E0      		ldi r24,lo8(statusMsg)
 6325 2406 90E0      		ldi r25,hi8(statusMsg)
 6326 2408 0E94 0000 		call strcat
 6327               	.LVL448:
2725:switcherator.c ****     strcat(statusMsg,",Sw,");
 6328               		.loc 1 2725 0
 6329 240c 60E0      		ldi r22,lo8(.LC30)
 6330 240e 70E0      		ldi r23,hi8(.LC30)
 6331 2410 80E0      		ldi r24,lo8(statusMsg)
 6332 2412 90E0      		ldi r25,hi8(statusMsg)
 6333 2414 0E94 0000 		call strcat
 6334               	.LVL449:
 6335 2418 E0E0      		ldi r30,lo8(switchStuff)
 6336 241a F0E0      		ldi r31,hi8(switchStuff)
2726:switcherator.c ****     count = 0;
 6337               		.loc 1 2726 0
 6338 241c 80E0      		ldi r24,0
 6339 241e 90E0      		ldi r25,0
 6340               	.LVL450:
 6341               	.L465:
2728:switcherator.c ****         if (switchStuff[x] < 255)
 6342               		.loc 1 2728 0
 6343 2420 2191      		ld r18,Z+
 6344 2422 2F3F      		cpi r18,lo8(-1)
 6345 2424 01F0      		breq .L464
2729:switcherator.c ****             count ++;
 6346               		.loc 1 2729 0
 6347 2426 0196      		adiw r24,1
 6348               	.LVL451:
 6349               	.L464:
2727:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 6350               		.loc 1 2727 0
 6351 2428 20E0      		ldi r18,hi8(switchStuff+16)
 6352 242a E030      		cpi r30,lo8(switchStuff+16)
 6353 242c F207      		cpc r31,r18
 6354 242e 01F4      		brne .L465
2731:switcherator.c ****     returnInt(count,tempLongString);
 6355               		.loc 1 2731 0
 6356 2430 60E0      		ldi r22,lo8(tempLongString)
 6357 2432 70E0      		ldi r23,hi8(tempLongString)
 6358 2434 0E94 0000 		call returnInt
 6359               	.LVL452:
2732:switcherator.c ****     strcat(statusMsg,tempLongString);
 6360               		.loc 1 2732 0
 6361 2438 60E0      		ldi r22,lo8(tempLongString)
 6362 243a 70E0      		ldi r23,hi8(tempLongString)
 6363 243c 80E0      		ldi r24,lo8(statusMsg)
 6364 243e 90E0      		ldi r25,hi8(statusMsg)
 6365 2440 0E94 0000 		call strcat
 6366               	.LVL453:
2733:switcherator.c ****     strcat(statusMsg,"/");
 6367               		.loc 1 2733 0
 6368 2444 60E0      		ldi r22,lo8(.LC3)
 6369 2446 70E0      		ldi r23,hi8(.LC3)
 6370 2448 80E0      		ldi r24,lo8(statusMsg)
 6371 244a 90E0      		ldi r25,hi8(statusMsg)
 6372 244c 0E94 0000 		call strcat
 6373               	.LVL454:
2734:switcherator.c ****     returnInt(NUM_SWITCHES,tempLongString);
 6374               		.loc 1 2734 0
 6375 2450 60E0      		ldi r22,lo8(tempLongString)
 6376 2452 70E0      		ldi r23,hi8(tempLongString)
 6377 2454 80E1      		ldi r24,lo8(16)
 6378 2456 90E0      		ldi r25,0
 6379 2458 0E94 0000 		call returnInt
 6380               	.LVL455:
2735:switcherator.c ****     strcat(statusMsg,tempLongString);
 6381               		.loc 1 2735 0
 6382 245c 60E0      		ldi r22,lo8(tempLongString)
 6383 245e 70E0      		ldi r23,hi8(tempLongString)
 6384 2460 80E0      		ldi r24,lo8(statusMsg)
 6385 2462 90E0      		ldi r25,hi8(statusMsg)
 6386 2464 0E94 0000 		call strcat
 6387               	.LVL456:
2736:switcherator.c ****     strcat(statusMsg,",In,");
 6388               		.loc 1 2736 0
 6389 2468 60E0      		ldi r22,lo8(.LC31)
 6390 246a 70E0      		ldi r23,hi8(.LC31)
 6391 246c 80E0      		ldi r24,lo8(statusMsg)
 6392 246e 90E0      		ldi r25,hi8(statusMsg)
 6393 2470 0E94 0000 		call strcat
 6394               	.LVL457:
 6395 2474 E0E0      		ldi r30,lo8(inputs)
 6396 2476 F0E0      		ldi r31,hi8(inputs)
2737:switcherator.c ****     count = 0;
 6397               		.loc 1 2737 0
 6398 2478 80E0      		ldi r24,0
 6399 247a 90E0      		ldi r25,0
 6400               	.LVL458:
 6401               	.L467:
2739:switcherator.c ****         if (inputs[x][0] < 255)
 6402               		.loc 1 2739 0
 6403 247c 2081      		ld r18,Z
 6404 247e 2F3F      		cpi r18,lo8(-1)
 6405 2480 01F0      		breq .L466
2740:switcherator.c ****             count ++;
 6406               		.loc 1 2740 0
 6407 2482 0196      		adiw r24,1
 6408               	.LVL459:
 6409               	.L466:
 6410 2484 3896      		adiw r30,8
2738:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 6411               		.loc 1 2738 0
 6412 2486 20E0      		ldi r18,hi8(inputs+32)
 6413 2488 E030      		cpi r30,lo8(inputs+32)
 6414 248a F207      		cpc r31,r18
 6415 248c 01F4      		brne .L467
2742:switcherator.c ****     returnInt(count,tempLongString);
 6416               		.loc 1 2742 0
 6417 248e 60E0      		ldi r22,lo8(tempLongString)
 6418 2490 70E0      		ldi r23,hi8(tempLongString)
 6419 2492 0E94 0000 		call returnInt
 6420               	.LVL460:
2743:switcherator.c ****     strcat(statusMsg,tempLongString);
 6421               		.loc 1 2743 0
 6422 2496 60E0      		ldi r22,lo8(tempLongString)
 6423 2498 70E0      		ldi r23,hi8(tempLongString)
 6424 249a 80E0      		ldi r24,lo8(statusMsg)
 6425 249c 90E0      		ldi r25,hi8(statusMsg)
 6426 249e 0E94 0000 		call strcat
 6427               	.LVL461:
2744:switcherator.c ****     strcat(statusMsg,"/");
 6428               		.loc 1 2744 0
 6429 24a2 60E0      		ldi r22,lo8(.LC3)
 6430 24a4 70E0      		ldi r23,hi8(.LC3)
 6431 24a6 80E0      		ldi r24,lo8(statusMsg)
 6432 24a8 90E0      		ldi r25,hi8(statusMsg)
 6433 24aa 0E94 0000 		call strcat
 6434               	.LVL462:
2745:switcherator.c ****     returnInt(NUM_INPUTS,tempLongString);
 6435               		.loc 1 2745 0
 6436 24ae 60E0      		ldi r22,lo8(tempLongString)
 6437 24b0 70E0      		ldi r23,hi8(tempLongString)
 6438 24b2 84E0      		ldi r24,lo8(4)
 6439 24b4 90E0      		ldi r25,0
 6440 24b6 0E94 0000 		call returnInt
 6441               	.LVL463:
2746:switcherator.c ****     strcat(statusMsg,tempLongString);
 6442               		.loc 1 2746 0
 6443 24ba 60E0      		ldi r22,lo8(tempLongString)
 6444 24bc 70E0      		ldi r23,hi8(tempLongString)
 6445 24be 80E0      		ldi r24,lo8(statusMsg)
 6446 24c0 90E0      		ldi r25,hi8(statusMsg)
 6447 24c2 0E94 0000 		call strcat
 6448               	.LVL464:
2747:switcherator.c ****     strcat(statusMsg,",Li,");
 6449               		.loc 1 2747 0
 6450 24c6 60E0      		ldi r22,lo8(.LC32)
 6451 24c8 70E0      		ldi r23,hi8(.LC32)
 6452 24ca 80E0      		ldi r24,lo8(statusMsg)
 6453 24cc 90E0      		ldi r25,hi8(statusMsg)
 6454 24ce 0E94 0000 		call strcat
 6455               	.LVL465:
 6456 24d2 E0E0      		ldi r30,lo8(inputs+2)
 6457 24d4 F0E0      		ldi r31,hi8(inputs+2)
2748:switcherator.c ****     count = 0;
 6458               		.loc 1 2748 0
 6459 24d6 80E0      		ldi r24,0
 6460 24d8 90E0      		ldi r25,0
 6461               	.LVL466:
 6462               	.L469:
2750:switcherator.c ****         if (inputs[x][2] > 0)
 6463               		.loc 1 2750 0
 6464 24da 2081      		ld r18,Z
 6465 24dc 2111      		cpse r18,__zero_reg__
2751:switcherator.c ****             count ++;
 6466               		.loc 1 2751 0
 6467 24de 0196      		adiw r24,1
 6468               	.LVL467:
 6469               	.L468:
 6470 24e0 3896      		adiw r30,8
2749:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++) {
 6471               		.loc 1 2749 0
 6472 24e2 20E0      		ldi r18,hi8(inputs+34)
 6473 24e4 E030      		cpi r30,lo8(inputs+34)
 6474 24e6 F207      		cpc r31,r18
 6475 24e8 01F4      		brne .L469
2753:switcherator.c ****     returnInt(count,tempLongString);
 6476               		.loc 1 2753 0
 6477 24ea 60E0      		ldi r22,lo8(tempLongString)
 6478 24ec 70E0      		ldi r23,hi8(tempLongString)
 6479 24ee 0E94 0000 		call returnInt
 6480               	.LVL468:
2754:switcherator.c ****     strcat(statusMsg,tempLongString);
 6481               		.loc 1 2754 0
 6482 24f2 60E0      		ldi r22,lo8(tempLongString)
 6483 24f4 70E0      		ldi r23,hi8(tempLongString)
 6484 24f6 80E0      		ldi r24,lo8(statusMsg)
 6485 24f8 90E0      		ldi r25,hi8(statusMsg)
 6486 24fa 0E94 0000 		call strcat
 6487               	.LVL469:
2755:switcherator.c ****     strcat(statusMsg,"/");
 6488               		.loc 1 2755 0
 6489 24fe 60E0      		ldi r22,lo8(.LC3)
 6490 2500 70E0      		ldi r23,hi8(.LC3)
 6491 2502 80E0      		ldi r24,lo8(statusMsg)
 6492 2504 90E0      		ldi r25,hi8(statusMsg)
 6493 2506 0E94 0000 		call strcat
 6494               	.LVL470:
2756:switcherator.c ****     returnInt(NUM_LIMITS,tempLongString);
 6495               		.loc 1 2756 0
 6496 250a 60E0      		ldi r22,lo8(tempLongString)
 6497 250c 70E0      		ldi r23,hi8(tempLongString)
 6498 250e 84E0      		ldi r24,lo8(4)
 6499 2510 90E0      		ldi r25,0
 6500 2512 0E94 0000 		call returnInt
 6501               	.LVL471:
2757:switcherator.c ****     strcat(statusMsg,tempLongString);
 6502               		.loc 1 2757 0
 6503 2516 60E0      		ldi r22,lo8(tempLongString)
 6504 2518 70E0      		ldi r23,hi8(tempLongString)
 6505 251a 80E0      		ldi r24,lo8(statusMsg)
 6506 251c 90E0      		ldi r25,hi8(statusMsg)
 6507 251e 0E94 0000 		call strcat
 6508               	.LVL472:
2758:switcherator.c ****     strcat(statusMsg,",CC,");
 6509               		.loc 1 2758 0
 6510 2522 60E0      		ldi r22,lo8(.LC33)
 6511 2524 70E0      		ldi r23,hi8(.LC33)
 6512 2526 80E0      		ldi r24,lo8(statusMsg)
 6513 2528 90E0      		ldi r25,hi8(statusMsg)
 6514 252a 0E94 0000 		call strcat
 6515               	.LVL473:
 6516 252e E0E0      		ldi r30,lo8(colorChanges+2)
 6517 2530 F0E0      		ldi r31,hi8(colorChanges+2)
2759:switcherator.c ****     count = 0;
 6518               		.loc 1 2759 0
 6519 2532 80E0      		ldi r24,0
 6520 2534 90E0      		ldi r25,0
 6521               	.LVL474:
 6522               	.L472:
2711:switcherator.c **** void generalInformation(void) {
 6523               		.loc 1 2711 0
 6524 2536 DF01      		movw r26,r30
 6525 2538 1297      		sbiw r26,2
2761:switcherator.c ****         if (colorChanges[x][0] != 0 || colorChanges[x][1] != 1 || colorChanges[x][2] != 0)
 6526               		.loc 1 2761 0
 6527 253a 2C91      		ld r18,X
 6528 253c 2111      		cpse r18,__zero_reg__
 6529 253e 00C0      		rjmp .L470
2711:switcherator.c **** void generalInformation(void) {
 6530               		.loc 1 2711 0 discriminator 1
 6531 2540 DF01      		movw r26,r30
 6532 2542 1197      		sbiw r26,1
2761:switcherator.c ****         if (colorChanges[x][0] != 0 || colorChanges[x][1] != 1 || colorChanges[x][2] != 0)
 6533               		.loc 1 2761 0 discriminator 1
 6534 2544 2C91      		ld r18,X
 6535 2546 2130      		cpi r18,lo8(1)
 6536 2548 01F4      		brne .L470
 6537 254a 2081      		ld r18,Z
 6538 254c 2111      		cpse r18,__zero_reg__
 6539               	.L470:
2762:switcherator.c ****             count ++;
 6540               		.loc 1 2762 0
 6541 254e 0196      		adiw r24,1
 6542               	.LVL475:
 6543               	.L471:
 6544 2550 3396      		adiw r30,3
2760:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 6545               		.loc 1 2760 0
 6546 2552 20E0      		ldi r18,hi8(colorChanges+20)
 6547 2554 E030      		cpi r30,lo8(colorChanges+20)
 6548 2556 F207      		cpc r31,r18
 6549 2558 01F4      		brne .L472
2764:switcherator.c ****     returnInt(count,tempLongString);
 6550               		.loc 1 2764 0
 6551 255a 60E0      		ldi r22,lo8(tempLongString)
 6552 255c 70E0      		ldi r23,hi8(tempLongString)
 6553 255e 0E94 0000 		call returnInt
 6554               	.LVL476:
2765:switcherator.c ****     strcat(statusMsg,tempLongString);
 6555               		.loc 1 2765 0
 6556 2562 60E0      		ldi r22,lo8(tempLongString)
 6557 2564 70E0      		ldi r23,hi8(tempLongString)
 6558 2566 80E0      		ldi r24,lo8(statusMsg)
 6559 2568 90E0      		ldi r25,hi8(statusMsg)
 6560 256a 0E94 0000 		call strcat
 6561               	.LVL477:
2766:switcherator.c ****     strcat(statusMsg,"/");
 6562               		.loc 1 2766 0
 6563 256e 60E0      		ldi r22,lo8(.LC3)
 6564 2570 70E0      		ldi r23,hi8(.LC3)
 6565 2572 80E0      		ldi r24,lo8(statusMsg)
 6566 2574 90E0      		ldi r25,hi8(statusMsg)
 6567 2576 0E94 0000 		call strcat
 6568               	.LVL478:
2767:switcherator.c ****     returnInt(NUM_COLOR_CHANGES,tempLongString);
 6569               		.loc 1 2767 0
 6570 257a 60E0      		ldi r22,lo8(tempLongString)
 6571 257c 70E0      		ldi r23,hi8(tempLongString)
 6572 257e 86E0      		ldi r24,lo8(6)
 6573 2580 90E0      		ldi r25,0
 6574 2582 0E94 0000 		call returnInt
 6575               	.LVL479:
2768:switcherator.c ****     strcat(statusMsg,tempLongString);
 6576               		.loc 1 2768 0
 6577 2586 60E0      		ldi r22,lo8(tempLongString)
 6578 2588 70E0      		ldi r23,hi8(tempLongString)
 6579 258a 80E0      		ldi r24,lo8(statusMsg)
 6580 258c 90E0      		ldi r25,hi8(statusMsg)
 6581 258e 0E94 0000 		call strcat
 6582               	.LVL480:
2769:switcherator.c ****     sendMessage(statusMsg);
 6583               		.loc 1 2769 0
 6584 2592 80E0      		ldi r24,lo8(statusMsg)
 6585 2594 90E0      		ldi r25,hi8(statusMsg)
 6586 2596 0C94 0000 		jmp sendMessage
 6587               	.LVL481:
 6588               	.LFE62:
 6590               		.section	.rodata.str1.1
 6591               	.LC34:
 6592 009b 5323 00   		.string	"S#"
 6593               	.LC35:
 6594 009e 2054 3A78 		.string	" T:xx/xx/xxxx xx:xx:xx"
 6594      782F 7878 
 6594      2F78 7878 
 6594      7820 7878 
 6594      3A78 783A 
 6595               	.LC36:
 6596 00b5 2054 3A00 		.string	" T:"
 6597               		.text
 6598               	.global	generalStatus
 6600               	generalStatus:
 6601               	.LFB61:
2662:switcherator.c **** void generalStatus(char * commandReceived) {
 6602               		.loc 1 2662 0
 6603               	.LVL482:
 6604 259a 0F93      		push r16
 6605               	.LCFI160:
 6606 259c 1F93      		push r17
 6607               	.LCFI161:
 6608 259e CF93      		push r28
 6609               	.LCFI162:
 6610 25a0 DF93      		push r29
 6611               	.LCFI163:
 6612               	/* prologue: function */
 6613               	/* frame size = 0 */
 6614               	/* stack size = 4 */
 6615               	.L__stack_usage = 4
 6616 25a2 8C01      		movw r16,r24
2663:switcherator.c ****     statusMsg[0] = 0;
 6617               		.loc 1 2663 0
 6618 25a4 1092 0000 		sts statusMsg,__zero_reg__
2664:switcherator.c ****     tempIntString[0] = commandReceived[2];
 6619               		.loc 1 2664 0
 6620 25a8 FC01      		movw r30,r24
 6621 25aa 8281      		ldd r24,Z+2
 6622               	.LVL483:
 6623 25ac 8093 0000 		sts tempIntString,r24
2665:switcherator.c ****     tempIntString[1] = commandReceived[3];
 6624               		.loc 1 2665 0
 6625 25b0 8381      		ldd r24,Z+3
 6626 25b2 8093 0000 		sts tempIntString+1,r24
2667:switcherator.c ****     strcat(statusMsg, "S#");
 6627               		.loc 1 2667 0
 6628 25b6 60E0      		ldi r22,lo8(.LC34)
 6629 25b8 70E0      		ldi r23,hi8(.LC34)
 6630 25ba 80E0      		ldi r24,lo8(statusMsg)
 6631 25bc 90E0      		ldi r25,hi8(statusMsg)
 6632 25be 0E94 0000 		call strcat
 6633               	.LVL484:
2670:switcherator.c ****     serialLength = strlen(stringSerial);
 6634               		.loc 1 2670 0
 6635 25c2 C0E0      		ldi r28,lo8(stringSerial)
 6636 25c4 D0E0      		ldi r29,hi8(stringSerial)
 6637               		0:
 6638 25c6 0990      		ld __tmp_reg__,Y+
 6639 25c8 0020      		tst __tmp_reg__
 6640 25ca 01F4      		brne 0b
 6641               	.LVL485:
 6642 25cc 2197      		sbiw r28,1
 6643 25ce C050      		subi r28,lo8(stringSerial)
 6644 25d0 D040      		sbci r29,hi8(stringSerial)
 6645               	.LVL486:
2671:switcherator.c ****     while (serialLength < 6) {
 6646               		.loc 1 2671 0
 6647 25d2 00C0      		rjmp .L491
 6648               	.L492:
2672:switcherator.c ****         strcat(statusMsg, "0");
 6649               		.loc 1 2672 0
 6650 25d4 60E0      		ldi r22,lo8(.LC1)
 6651 25d6 70E0      		ldi r23,hi8(.LC1)
 6652 25d8 80E0      		ldi r24,lo8(statusMsg)
 6653 25da 90E0      		ldi r25,hi8(statusMsg)
 6654 25dc 0E94 0000 		call strcat
 6655               	.LVL487:
2673:switcherator.c ****         serialLength++;
 6656               		.loc 1 2673 0
 6657 25e0 2196      		adiw r28,1
 6658               	.LVL488:
 6659               	.L491:
2671:switcherator.c ****     while (serialLength < 6) {
 6660               		.loc 1 2671 0 discriminator 1
 6661 25e2 C630      		cpi r28,6
 6662 25e4 D105      		cpc r29,__zero_reg__
 6663 25e6 04F0      		brlt .L492
2675:switcherator.c ****     strcat(statusMsg, stringSerial);
 6664               		.loc 1 2675 0
 6665 25e8 60E0      		ldi r22,lo8(stringSerial)
 6666 25ea 70E0      		ldi r23,hi8(stringSerial)
 6667 25ec 80E0      		ldi r24,lo8(statusMsg)
 6668 25ee 90E0      		ldi r25,hi8(statusMsg)
 6669 25f0 0E94 0000 		call strcat
 6670               	.LVL489:
2677:switcherator.c ****     if (panicMyClockIsNotSet == 1) {
 6671               		.loc 1 2677 0
 6672 25f4 8091 0000 		lds r24,panicMyClockIsNotSet
 6673 25f8 8130      		cpi r24,lo8(1)
 6674 25fa 01F4      		brne .L493
2678:switcherator.c ****         strcat(statusMsg, " T:xx/xx/xxxx xx:xx:xx");
 6675               		.loc 1 2678 0
 6676 25fc 60E0      		ldi r22,lo8(.LC35)
 6677 25fe 70E0      		ldi r23,hi8(.LC35)
 6678 2600 00C0      		rjmp .L496
 6679               	.L493:
2680:switcherator.c ****         strcat(statusMsg, " T:");
 6680               		.loc 1 2680 0
 6681 2602 60E0      		ldi r22,lo8(.LC36)
 6682 2604 70E0      		ldi r23,hi8(.LC36)
 6683 2606 80E0      		ldi r24,lo8(statusMsg)
 6684 2608 90E0      		ldi r25,hi8(statusMsg)
 6685 260a 0E94 0000 		call strcat
 6686               	.LVL490:
2681:switcherator.c ****         returnInt(globalMonth, tempLongString);
 6687               		.loc 1 2681 0
 6688 260e 60E0      		ldi r22,lo8(tempLongString)
 6689 2610 70E0      		ldi r23,hi8(tempLongString)
 6690 2612 8091 0000 		lds r24,globalMonth
 6691 2616 9091 0000 		lds r25,globalMonth+1
 6692 261a 0E94 0000 		call returnInt
 6693               	.LVL491:
2682:switcherator.c ****         strcat(statusMsg, tempLongString);
 6694               		.loc 1 2682 0
 6695 261e 60E0      		ldi r22,lo8(tempLongString)
 6696 2620 70E0      		ldi r23,hi8(tempLongString)
 6697 2622 80E0      		ldi r24,lo8(statusMsg)
 6698 2624 90E0      		ldi r25,hi8(statusMsg)
 6699 2626 0E94 0000 		call strcat
 6700               	.LVL492:
2683:switcherator.c ****         strcat(statusMsg, "/");
 6701               		.loc 1 2683 0
 6702 262a 60E0      		ldi r22,lo8(.LC3)
 6703 262c 70E0      		ldi r23,hi8(.LC3)
 6704 262e 80E0      		ldi r24,lo8(statusMsg)
 6705 2630 90E0      		ldi r25,hi8(statusMsg)
 6706 2632 0E94 0000 		call strcat
 6707               	.LVL493:
2684:switcherator.c ****         returnInt(globalDay, tempLongString);
 6708               		.loc 1 2684 0
 6709 2636 60E0      		ldi r22,lo8(tempLongString)
 6710 2638 70E0      		ldi r23,hi8(tempLongString)
 6711 263a 8091 0000 		lds r24,globalDay
 6712 263e 9091 0000 		lds r25,globalDay+1
 6713 2642 0E94 0000 		call returnInt
 6714               	.LVL494:
2685:switcherator.c ****         strcat(statusMsg, tempLongString);
 6715               		.loc 1 2685 0
 6716 2646 60E0      		ldi r22,lo8(tempLongString)
 6717 2648 70E0      		ldi r23,hi8(tempLongString)
 6718 264a 80E0      		ldi r24,lo8(statusMsg)
 6719 264c 90E0      		ldi r25,hi8(statusMsg)
 6720 264e 0E94 0000 		call strcat
 6721               	.LVL495:
2686:switcherator.c ****         strcat(statusMsg, "/");
 6722               		.loc 1 2686 0
 6723 2652 60E0      		ldi r22,lo8(.LC3)
 6724 2654 70E0      		ldi r23,hi8(.LC3)
 6725 2656 80E0      		ldi r24,lo8(statusMsg)
 6726 2658 90E0      		ldi r25,hi8(statusMsg)
 6727 265a 0E94 0000 		call strcat
 6728               	.LVL496:
2687:switcherator.c ****         returnInt(globalYear, tempLongString);
 6729               		.loc 1 2687 0
 6730 265e 60E0      		ldi r22,lo8(tempLongString)
 6731 2660 70E0      		ldi r23,hi8(tempLongString)
 6732 2662 8091 0000 		lds r24,globalYear
 6733 2666 9091 0000 		lds r25,globalYear+1
 6734 266a 0E94 0000 		call returnInt
 6735               	.LVL497:
2688:switcherator.c ****         strcat(statusMsg, tempLongString);
 6736               		.loc 1 2688 0
 6737 266e 60E0      		ldi r22,lo8(tempLongString)
 6738 2670 70E0      		ldi r23,hi8(tempLongString)
 6739 2672 80E0      		ldi r24,lo8(statusMsg)
 6740 2674 90E0      		ldi r25,hi8(statusMsg)
 6741 2676 0E94 0000 		call strcat
 6742               	.LVL498:
2689:switcherator.c ****         strcat(statusMsg, " ");
 6743               		.loc 1 2689 0
 6744 267a 60E0      		ldi r22,lo8(.LC2)
 6745 267c 70E0      		ldi r23,hi8(.LC2)
 6746 267e 80E0      		ldi r24,lo8(statusMsg)
 6747 2680 90E0      		ldi r25,hi8(statusMsg)
 6748 2682 0E94 0000 		call strcat
 6749               	.LVL499:
2690:switcherator.c ****         returnInt(globalHour, tempLongString);
 6750               		.loc 1 2690 0
 6751 2686 60E0      		ldi r22,lo8(tempLongString)
 6752 2688 70E0      		ldi r23,hi8(tempLongString)
 6753 268a 8091 0000 		lds r24,globalHour
 6754 268e 9091 0000 		lds r25,globalHour+1
 6755 2692 0E94 0000 		call returnInt
 6756               	.LVL500:
2691:switcherator.c ****         strcat(statusMsg, tempLongString);
 6757               		.loc 1 2691 0
 6758 2696 60E0      		ldi r22,lo8(tempLongString)
 6759 2698 70E0      		ldi r23,hi8(tempLongString)
 6760 269a 80E0      		ldi r24,lo8(statusMsg)
 6761 269c 90E0      		ldi r25,hi8(statusMsg)
 6762 269e 0E94 0000 		call strcat
 6763               	.LVL501:
2692:switcherator.c ****         strcat(statusMsg, ":");
 6764               		.loc 1 2692 0
 6765 26a2 60E0      		ldi r22,lo8(.LC4)
 6766 26a4 70E0      		ldi r23,hi8(.LC4)
 6767 26a6 80E0      		ldi r24,lo8(statusMsg)
 6768 26a8 90E0      		ldi r25,hi8(statusMsg)
 6769 26aa 0E94 0000 		call strcat
 6770               	.LVL502:
2693:switcherator.c ****         returnInt(globalMinute, tempLongString);
 6771               		.loc 1 2693 0
 6772 26ae 60E0      		ldi r22,lo8(tempLongString)
 6773 26b0 70E0      		ldi r23,hi8(tempLongString)
 6774 26b2 8091 0000 		lds r24,globalMinute
 6775 26b6 9091 0000 		lds r25,globalMinute+1
 6776 26ba 0E94 0000 		call returnInt
 6777               	.LVL503:
2694:switcherator.c ****         strcat(statusMsg, tempLongString);
 6778               		.loc 1 2694 0
 6779 26be 60E0      		ldi r22,lo8(tempLongString)
 6780 26c0 70E0      		ldi r23,hi8(tempLongString)
 6781 26c2 80E0      		ldi r24,lo8(statusMsg)
 6782 26c4 90E0      		ldi r25,hi8(statusMsg)
 6783 26c6 0E94 0000 		call strcat
 6784               	.LVL504:
2695:switcherator.c ****         strcat(statusMsg, ":");
 6785               		.loc 1 2695 0
 6786 26ca 60E0      		ldi r22,lo8(.LC4)
 6787 26cc 70E0      		ldi r23,hi8(.LC4)
 6788 26ce 80E0      		ldi r24,lo8(statusMsg)
 6789 26d0 90E0      		ldi r25,hi8(statusMsg)
 6790 26d2 0E94 0000 		call strcat
 6791               	.LVL505:
2696:switcherator.c ****         returnInt(globalSecond, tempLongString);
 6792               		.loc 1 2696 0
 6793 26d6 60E0      		ldi r22,lo8(tempLongString)
 6794 26d8 70E0      		ldi r23,hi8(tempLongString)
 6795 26da 8091 0000 		lds r24,globalSecond
 6796 26de 9091 0000 		lds r25,globalSecond+1
 6797 26e2 0E94 0000 		call returnInt
 6798               	.LVL506:
2697:switcherator.c ****         strcat(statusMsg, tempLongString);
 6799               		.loc 1 2697 0
 6800 26e6 60E0      		ldi r22,lo8(tempLongString)
 6801 26e8 70E0      		ldi r23,hi8(tempLongString)
 6802               	.L496:
 6803 26ea 80E0      		ldi r24,lo8(statusMsg)
 6804 26ec 90E0      		ldi r25,hi8(statusMsg)
 6805 26ee 0E94 0000 		call strcat
 6806               	.LVL507:
2699:switcherator.c ****     sendMessage(statusMsg);
 6807               		.loc 1 2699 0
 6808 26f2 80E0      		ldi r24,lo8(statusMsg)
 6809 26f4 90E0      		ldi r25,hi8(statusMsg)
 6810 26f6 0E94 0000 		call sendMessage
 6811               	.LVL508:
2700:switcherator.c ****     statusMsg[0] = 0;
 6812               		.loc 1 2700 0
 6813 26fa 1092 0000 		sts statusMsg,__zero_reg__
2701:switcherator.c ****     if (commandReceived[2] == 'q')
 6814               		.loc 1 2701 0
 6815 26fe F801      		movw r30,r16
 6816 2700 8281      		ldd r24,Z+2
 6817 2702 8137      		cpi r24,lo8(113)
 6818 2704 01F0      		breq .L490
2704:switcherator.c ****     programsProgrammed();
 6819               		.loc 1 2704 0
 6820 2706 0E94 0000 		call programsProgrammed
 6821               	.LVL509:
2705:switcherator.c ****     switchesProgrammed();
 6822               		.loc 1 2705 0
 6823 270a 0E94 0000 		call switchesProgrammed
 6824               	.LVL510:
2706:switcherator.c ****     inputsProgrammed();
 6825               		.loc 1 2706 0
 6826 270e 0E94 0000 		call inputsProgrammed
 6827               	.LVL511:
 6828               	/* epilogue start */
2708:switcherator.c **** }
 6829               		.loc 1 2708 0
 6830 2712 DF91      		pop r29
 6831 2714 CF91      		pop r28
 6832               	.LVL512:
 6833 2716 1F91      		pop r17
 6834 2718 0F91      		pop r16
 6835               	.LVL513:
2707:switcherator.c ****     switchesOn();
 6836               		.loc 1 2707 0
 6837 271a 0C94 0000 		jmp switchesOn
 6838               	.LVL514:
 6839               	.L490:
 6840               	/* epilogue start */
2708:switcherator.c **** }
 6841               		.loc 1 2708 0
 6842 271e DF91      		pop r29
 6843 2720 CF91      		pop r28
 6844               	.LVL515:
 6845 2722 1F91      		pop r17
 6846 2724 0F91      		pop r16
 6847               	.LVL516:
 6848 2726 0895      		ret
 6849               	.LFE61:
 6851               		.section	.rodata.str1.1
 6852               	.LC37:
 6853 00b9 5023 00   		.string	"P#"
 6854               	.LC38:
 6855 00bc 626C 616E 		.string	"blank."
 6855      6B2E 00
 6856               	.LC39:
 6857 00c3 5072 6F67 		.string	"Prog#"
 6857      2300 
 6858               	.LC40:
 6859 00c9 533A 2D00 		.string	"S:-"
 6860               	.LC41:
 6861 00cd 5300      		.string	"S"
 6862               	.LC42:
 6863 00cf 543A 00   		.string	"T:"
 6864               	.LC43:
 6865 00d2 2044 7572 		.string	" Dur:"
 6865      3A00 
 6866               	.LC44:
 6867 00d8 4461 7973 		.string	"Days:"
 6867      3A00 
 6868               	.LC45:
 6869 00de 2D2D 2D2D 		.string	"-------"
 6869      2D2D 2D00 
 6870               	.LC46:
 6871 00e6 2D00      		.string	"-"
 6872               	.LC47:
 6873 00e8 4D00      		.string	"M"
 6874               	.LC48:
 6875 00ea 5400      		.string	"T"
 6876               	.LC49:
 6877 00ec 5700      		.string	"W"
 6878               	.LC50:
 6879 00ee 4600      		.string	"F"
 6880               		.text
 6881               	.global	programDisplay
 6883               	programDisplay:
 6884               	.LFB37:
1516:switcherator.c **** void programDisplay(char * commandReceived) {
 6885               		.loc 1 1516 0
 6886               	.LVL517:
 6887 2728 AF92      		push r10
 6888               	.LCFI164:
 6889 272a BF92      		push r11
 6890               	.LCFI165:
 6891 272c CF92      		push r12
 6892               	.LCFI166:
 6893 272e DF92      		push r13
 6894               	.LCFI167:
 6895 2730 EF92      		push r14
 6896               	.LCFI168:
 6897 2732 FF92      		push r15
 6898               	.LCFI169:
 6899 2734 0F93      		push r16
 6900               	.LCFI170:
 6901 2736 1F93      		push r17
 6902               	.LCFI171:
 6903 2738 CF93      		push r28
 6904               	.LCFI172:
 6905 273a DF93      		push r29
 6906               	.LCFI173:
 6907 273c CDB7      		in r28,__SP_L__
 6908 273e DEB7      		in r29,__SP_H__
 6909               	.LCFI174:
 6910 2740 6097      		sbiw r28,16
 6911               	.LCFI175:
 6912 2742 0FB6      		in __tmp_reg__,__SREG__
 6913 2744 F894      		cli
 6914 2746 DEBF      		out __SP_H__,r29
 6915 2748 0FBE      		out __SREG__,__tmp_reg__
 6916 274a CDBF      		out __SP_L__,r28
 6917               	/* prologue: function */
 6918               	/* frame size = 16 */
 6919               	/* stack size = 26 */
 6920               	.L__stack_usage = 26
 6921               	.LVL518:
1519:switcherator.c ****     tempIntString[0] = commandReceived[3];
 6922               		.loc 1 1519 0
 6923 274c FC01      		movw r30,r24
 6924 274e 2381      		ldd r18,Z+3
 6925 2750 2093 0000 		sts tempIntString,r18
1520:switcherator.c ****     tempIntString[1] = commandReceived[4];
 6926               		.loc 1 1520 0
 6927 2754 8481      		ldd r24,Z+4
 6928               	.LVL519:
 6929 2756 8093 0000 		sts tempIntString+1,r24
1521:switcherator.c ****     programNumber = atoi(tempIntString);
 6930               		.loc 1 1521 0
 6931 275a 80E0      		ldi r24,lo8(tempIntString)
 6932 275c 90E0      		ldi r25,hi8(tempIntString)
 6933 275e 0E94 0000 		call atoi
 6934               	.LVL520:
 6935 2762 8C01      		movw r16,r24
 6936               	.LVL521:
1522:switcherator.c ****     statusMsg[0] = 0;
 6937               		.loc 1 1522 0
 6938 2764 1092 0000 		sts statusMsg,__zero_reg__
1523:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 6939               		.loc 1 1523 0
 6940 2768 8AE0      		ldi r24,lo8(10)
 6941 276a 809F      		mul r24,r16
 6942 276c F001      		movw r30,r0
 6943 276e 819F      		mul r24,r17
 6944 2770 F00D      		add r31,r0
 6945 2772 1124      		clr __zero_reg__
 6946 2774 E050      		subi r30,lo8(-(weeklyProgram))
 6947 2776 F040      		sbci r31,hi8(-(weeklyProgram))
 6948 2778 8081      		ld r24,Z
 6949 277a 8F3F      		cpi r24,lo8(-1)
 6950 277c 01F4      		brne .L498
1523:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 6951               		.loc 1 1523 0 is_stmt 0 discriminator 1
 6952 277e 8181      		ldd r24,Z+1
 6953 2780 8F3F      		cpi r24,lo8(-1)
 6954 2782 01F4      		brne .L498
1524:switcherator.c ****         strcat(statusMsg, "P#");
 6955               		.loc 1 1524 0 is_stmt 1
 6956 2784 60E0      		ldi r22,lo8(.LC37)
 6957 2786 70E0      		ldi r23,hi8(.LC37)
 6958 2788 80E0      		ldi r24,lo8(statusMsg)
 6959 278a 90E0      		ldi r25,hi8(statusMsg)
 6960 278c 0E94 0000 		call strcat
 6961               	.LVL522:
1525:switcherator.c ****         returnInt(programNumber, tempIntString);
 6962               		.loc 1 1525 0
 6963 2790 60E0      		ldi r22,lo8(tempIntString)
 6964 2792 70E0      		ldi r23,hi8(tempIntString)
 6965 2794 C801      		movw r24,r16
 6966 2796 0E94 0000 		call returnInt
 6967               	.LVL523:
1526:switcherator.c ****         strcat(statusMsg, tempIntString);
 6968               		.loc 1 1526 0
 6969 279a 60E0      		ldi r22,lo8(tempIntString)
 6970 279c 70E0      		ldi r23,hi8(tempIntString)
 6971 279e 80E0      		ldi r24,lo8(statusMsg)
 6972 27a0 90E0      		ldi r25,hi8(statusMsg)
 6973 27a2 0E94 0000 		call strcat
 6974               	.LVL524:
1527:switcherator.c ****         strcat(statusMsg, "blank.");
 6975               		.loc 1 1527 0
 6976 27a6 60E0      		ldi r22,lo8(.LC38)
 6977 27a8 70E0      		ldi r23,hi8(.LC38)
 6978 27aa 00C0      		rjmp .L526
 6979               	.L498:
1532:switcherator.c ****     switches[0] = 0;
 6980               		.loc 1 1532 0
 6981 27ac 1982      		std Y+1,__zero_reg__
 6982               	.LVL525:
1534:switcherator.c ****     switchCount = programGetSwitches(programNumber, switches);
 6983               		.loc 1 1534 0
 6984 27ae BE01      		movw r22,r28
 6985 27b0 6F5F      		subi r22,-1
 6986 27b2 7F4F      		sbci r23,-1
 6987 27b4 C801      		movw r24,r16
 6988 27b6 0E94 0000 		call programGetSwitches
 6989               	.LVL526:
 6990 27ba 6C01      		movw r12,r24
 6991               	.LVL527:
1535:switcherator.c ****     statusMsg[0] = 0;
 6992               		.loc 1 1535 0
 6993 27bc 1092 0000 		sts statusMsg,__zero_reg__
1536:switcherator.c ****     strcat(statusMsg, "Prog#");
 6994               		.loc 1 1536 0
 6995 27c0 60E0      		ldi r22,lo8(.LC39)
 6996 27c2 70E0      		ldi r23,hi8(.LC39)
 6997 27c4 80E0      		ldi r24,lo8(statusMsg)
 6998 27c6 90E0      		ldi r25,hi8(statusMsg)
 6999 27c8 0E94 0000 		call strcat
 7000               	.LVL528:
1537:switcherator.c ****     itoa(programNumber, tempIntString, 10);
 7001               		.loc 1 1537 0
 7002 27cc 4AE0      		ldi r20,lo8(10)
 7003 27ce 50E0      		ldi r21,0
 7004 27d0 60E0      		ldi r22,lo8(tempIntString)
 7005 27d2 70E0      		ldi r23,hi8(tempIntString)
 7006 27d4 C801      		movw r24,r16
 7007 27d6 0E94 0000 		call itoa
 7008               	.LVL529:
1538:switcherator.c ****     strcat(statusMsg, tempIntString);
 7009               		.loc 1 1538 0
 7010 27da 60E0      		ldi r22,lo8(tempIntString)
 7011 27dc 70E0      		ldi r23,hi8(tempIntString)
 7012 27de 80E0      		ldi r24,lo8(statusMsg)
 7013 27e0 90E0      		ldi r25,hi8(statusMsg)
 7014 27e2 0E94 0000 		call strcat
 7015               	.LVL530:
1539:switcherator.c ****     if (switchCount == 0) {
 7016               		.loc 1 1539 0
 7017 27e6 C114      		cp r12,__zero_reg__
 7018 27e8 D104      		cpc r13,__zero_reg__
 7019 27ea 01F4      		brne .L500
1540:switcherator.c ****         strcat(switches, "S:-");
 7020               		.loc 1 1540 0
 7021 27ec 60E0      		ldi r22,lo8(.LC40)
 7022 27ee 70E0      		ldi r23,hi8(.LC40)
 7023 27f0 CE01      		movw r24,r28
 7024 27f2 0196      		adiw r24,1
 7025 27f4 0E94 0000 		call strcat
 7026               	.LVL531:
 7027 27f8 00C0      		rjmp .L501
 7028               	.L500:
 7029               	.LVL532:
 7030               	.LBB27:
1543:switcherator.c ****         strcat(statusMsg, "S");
 7031               		.loc 1 1543 0
 7032 27fa 60E0      		ldi r22,lo8(.LC41)
 7033 27fc 70E0      		ldi r23,hi8(.LC41)
 7034 27fe 80E0      		ldi r24,lo8(statusMsg)
 7035 2800 90E0      		ldi r25,hi8(statusMsg)
 7036 2802 0E94 0000 		call strcat
 7037               	.LVL533:
 7038 2806 EE24      		clr r14
 7039 2808 E394      		inc r14
 7040 280a F12C      		mov r15,__zero_reg__
 7041 280c EC0E      		add r14,r28
 7042 280e FD1E      		adc r15,r29
1516:switcherator.c **** void programDisplay(char * commandReceived) {
 7043               		.loc 1 1516 0
 7044 2810 5701      		movw r10,r14
1544:switcherator.c ****         for (x = 0; x < switchCount; x++) {
 7045               		.loc 1 1544 0
 7046 2812 00C0      		rjmp .L502
 7047               	.LVL534:
 7048               	.L503:
1545:switcherator.c ****             strcat(statusMsg, ":");
 7049               		.loc 1 1545 0 discriminator 2
 7050 2814 60E0      		ldi r22,lo8(.LC4)
 7051 2816 70E0      		ldi r23,hi8(.LC4)
 7052 2818 80E0      		ldi r24,lo8(statusMsg)
 7053 281a 90E0      		ldi r25,hi8(statusMsg)
 7054 281c 0E94 0000 		call strcat
 7055               	.LVL535:
1547:switcherator.c ****             itoa(temp, tempIntString, 10);
 7056               		.loc 1 1547 0 discriminator 2
 7057 2820 4AE0      		ldi r20,lo8(10)
 7058 2822 50E0      		ldi r21,0
 7059 2824 60E0      		ldi r22,lo8(tempIntString)
 7060 2826 70E0      		ldi r23,hi8(tempIntString)
 7061 2828 F701      		movw r30,r14
 7062 282a 8191      		ld r24,Z+
 7063 282c 7F01      		movw r14,r30
 7064               	.LVL536:
 7065 282e 90E0      		ldi r25,0
 7066 2830 0E94 0000 		call itoa
 7067               	.LVL537:
1548:switcherator.c ****             strcat(statusMsg, tempIntString);
 7068               		.loc 1 1548 0 discriminator 2
 7069 2834 60E0      		ldi r22,lo8(tempIntString)
 7070 2836 70E0      		ldi r23,hi8(tempIntString)
 7071 2838 80E0      		ldi r24,lo8(statusMsg)
 7072 283a 90E0      		ldi r25,hi8(statusMsg)
 7073 283c 0E94 0000 		call strcat
 7074               	.LVL538:
 7075               	.L502:
1516:switcherator.c **** void programDisplay(char * commandReceived) {
 7076               		.loc 1 1516 0 discriminator 1
 7077 2840 C701      		movw r24,r14
 7078 2842 8A19      		sub r24,r10
 7079 2844 9B09      		sbc r25,r11
1544:switcherator.c ****         for (x = 0; x < switchCount; x++) {
 7080               		.loc 1 1544 0 discriminator 1
 7081 2846 8C15      		cp r24,r12
 7082 2848 9D05      		cpc r25,r13
 7083 284a 04F0      		brlt .L503
 7084               	.L501:
 7085               	.LBE27:
1551:switcherator.c ****     sendMessage(statusMsg);
 7086               		.loc 1 1551 0
 7087 284c 80E0      		ldi r24,lo8(statusMsg)
 7088 284e 90E0      		ldi r25,hi8(statusMsg)
 7089 2850 0E94 0000 		call sendMessage
 7090               	.LVL539:
1552:switcherator.c ****     statusMsg[0] = 0;
 7091               		.loc 1 1552 0
 7092 2854 1092 0000 		sts statusMsg,__zero_reg__
 7093               	.LVL540:
1554:switcherator.c ****     time = weeklyProgram[programNumber][1];
 7094               		.loc 1 1554 0
 7095 2858 8AE0      		ldi r24,lo8(10)
 7096 285a 809F      		mul r24,r16
 7097 285c F001      		movw r30,r0
 7098 285e 819F      		mul r24,r17
 7099 2860 F00D      		add r31,r0
 7100 2862 1124      		clr __zero_reg__
 7101 2864 E050      		subi r30,lo8(-(weeklyProgram))
 7102 2866 F040      		sbci r31,hi8(-(weeklyProgram))
 7103               	.LVL541:
1555:switcherator.c ****     time <<= 8;
 7104               		.loc 1 1555 0
 7105 2868 9181      		ldd r25,Z+1
 7106 286a 80E0      		ldi r24,0
 7107               	.LVL542:
1556:switcherator.c ****     time |= weeklyProgram[programNumber][2];
 7108               		.loc 1 1556 0
 7109 286c 2281      		ldd r18,Z+2
 7110 286e AC01      		movw r20,r24
 7111 2870 422B      		or r20,r18
 7112 2872 9A01      		movw r18,r20
 7113               	.LVL543:
1557:switcherator.c ****     unsigned int hours = (time / 60);
 7114               		.loc 1 1557 0
 7115 2874 5CE3      		ldi r21,lo8(60)
 7116 2876 E52E      		mov r14,r21
 7117 2878 F12C      		mov r15,__zero_reg__
 7118 287a C901      		movw r24,r18
 7119 287c B701      		movw r22,r14
 7120 287e 0E94 0000 		call __udivmodhi4
 7121 2882 8B01      		movw r16,r22
 7122               	.LVL544:
1558:switcherator.c ****     unsigned int minutes = (time - (hours * 60));
 7123               		.loc 1 1558 0
 7124 2884 4CE3      		ldi r20,lo8(60)
 7125 2886 469F      		mul r20,r22
 7126 2888 C001      		movw r24,r0
 7127 288a 479F      		mul r20,r23
 7128 288c 900D      		add r25,r0
 7129 288e 1124      		clr __zero_reg__
 7130 2890 6901      		movw r12,r18
 7131               	.LVL545:
 7132 2892 C81A      		sub r12,r24
 7133 2894 D90A      		sbc r13,r25
 7134               	.LVL546:
1560:switcherator.c ****     time <<= 8;
 7135               		.loc 1 1560 0
 7136 2896 3381      		ldd r19,Z+3
 7137 2898 20E0      		ldi r18,0
1561:switcherator.c ****     time |= weeklyProgram[programNumber][4];
 7138               		.loc 1 1561 0
 7139 289a 8481      		ldd r24,Z+4
 7140 289c A901      		movw r20,r18
 7141 289e 482B      		or r20,r24
 7142 28a0 CA01      		movw r24,r20
1562:switcherator.c ****     int duration = (time / 60);
 7143               		.loc 1 1562 0
 7144 28a2 B701      		movw r22,r14
 7145 28a4 0E94 0000 		call __udivmodhi4
 7146 28a8 B62E      		mov r11,r22
 7147 28aa E72E      		mov r14,r23
 7148               	.LVL547:
1564:switcherator.c ****     weekdays = weeklyProgram[programNumber][0];
 7149               		.loc 1 1564 0
 7150 28ac F080      		ld r15,Z
 7151               	.LVL548:
1565:switcherator.c ****     strcat(statusMsg, "T:");
 7152               		.loc 1 1565 0
 7153 28ae 60E0      		ldi r22,lo8(.LC42)
 7154 28b0 70E0      		ldi r23,hi8(.LC42)
 7155 28b2 80E0      		ldi r24,lo8(statusMsg)
 7156 28b4 90E0      		ldi r25,hi8(statusMsg)
 7157 28b6 0E94 0000 		call strcat
 7158               	.LVL549:
1566:switcherator.c ****     itoa(hours, tempIntString, 10);
 7159               		.loc 1 1566 0
 7160 28ba 4AE0      		ldi r20,lo8(10)
 7161 28bc 50E0      		ldi r21,0
 7162 28be 60E0      		ldi r22,lo8(tempIntString)
 7163 28c0 70E0      		ldi r23,hi8(tempIntString)
 7164 28c2 C801      		movw r24,r16
 7165 28c4 0E94 0000 		call itoa
 7166               	.LVL550:
1567:switcherator.c ****     strcat(statusMsg, tempIntString);
 7167               		.loc 1 1567 0
 7168 28c8 60E0      		ldi r22,lo8(tempIntString)
 7169 28ca 70E0      		ldi r23,hi8(tempIntString)
 7170 28cc 80E0      		ldi r24,lo8(statusMsg)
 7171 28ce 90E0      		ldi r25,hi8(statusMsg)
 7172 28d0 0E94 0000 		call strcat
 7173               	.LVL551:
1568:switcherator.c ****     strcat(statusMsg, ":");
 7174               		.loc 1 1568 0
 7175 28d4 60E0      		ldi r22,lo8(.LC4)
 7176 28d6 70E0      		ldi r23,hi8(.LC4)
 7177 28d8 80E0      		ldi r24,lo8(statusMsg)
 7178 28da 90E0      		ldi r25,hi8(statusMsg)
 7179 28dc 0E94 0000 		call strcat
 7180               	.LVL552:
1569:switcherator.c ****     itoa(minutes, tempIntString, 10);
 7181               		.loc 1 1569 0
 7182 28e0 4AE0      		ldi r20,lo8(10)
 7183 28e2 50E0      		ldi r21,0
 7184 28e4 60E0      		ldi r22,lo8(tempIntString)
 7185 28e6 70E0      		ldi r23,hi8(tempIntString)
 7186 28e8 C601      		movw r24,r12
 7187 28ea 0E94 0000 		call itoa
 7188               	.LVL553:
1570:switcherator.c ****     strcat(statusMsg, tempIntString);
 7189               		.loc 1 1570 0
 7190 28ee 60E0      		ldi r22,lo8(tempIntString)
 7191 28f0 70E0      		ldi r23,hi8(tempIntString)
 7192 28f2 80E0      		ldi r24,lo8(statusMsg)
 7193 28f4 90E0      		ldi r25,hi8(statusMsg)
 7194 28f6 0E94 0000 		call strcat
 7195               	.LVL554:
1571:switcherator.c ****     strcat(statusMsg, " Dur:");
 7196               		.loc 1 1571 0
 7197 28fa 60E0      		ldi r22,lo8(.LC43)
 7198 28fc 70E0      		ldi r23,hi8(.LC43)
 7199 28fe 80E0      		ldi r24,lo8(statusMsg)
 7200 2900 90E0      		ldi r25,hi8(statusMsg)
 7201 2902 0E94 0000 		call strcat
 7202               	.LVL555:
1572:switcherator.c ****     itoa(duration, tempLongString, 10);
 7203               		.loc 1 1572 0
 7204 2906 4AE0      		ldi r20,lo8(10)
 7205 2908 50E0      		ldi r21,0
 7206 290a 60E0      		ldi r22,lo8(tempLongString)
 7207 290c 70E0      		ldi r23,hi8(tempLongString)
 7208 290e 8B2D      		mov r24,r11
 7209 2910 9E2D      		mov r25,r14
 7210 2912 0E94 0000 		call itoa
 7211               	.LVL556:
1573:switcherator.c ****     strcat(statusMsg, tempLongString);
 7212               		.loc 1 1573 0
 7213 2916 60E0      		ldi r22,lo8(tempLongString)
 7214 2918 70E0      		ldi r23,hi8(tempLongString)
 7215 291a 80E0      		ldi r24,lo8(statusMsg)
 7216 291c 90E0      		ldi r25,hi8(statusMsg)
 7217 291e 0E94 0000 		call strcat
 7218               	.LVL557:
1574:switcherator.c ****     strcat(statusMsg, "Days:");
 7219               		.loc 1 1574 0
 7220 2922 60E0      		ldi r22,lo8(.LC44)
 7221 2924 70E0      		ldi r23,hi8(.LC44)
 7222 2926 80E0      		ldi r24,lo8(statusMsg)
 7223 2928 90E0      		ldi r25,hi8(statusMsg)
 7224 292a 0E94 0000 		call strcat
 7225               	.LVL558:
1575:switcherator.c ****     if (weekdays == 255) {
 7226               		.loc 1 1575 0
 7227 292e 5FEF      		ldi r21,lo8(-1)
 7228 2930 F512      		cpse r15,r21
 7229 2932 00C0      		rjmp .L504
1576:switcherator.c ****         strcat(statusMsg, "-------");
 7230               		.loc 1 1576 0
 7231 2934 60E0      		ldi r22,lo8(.LC45)
 7232 2936 70E0      		ldi r23,hi8(.LC45)
 7233 2938 00C0      		rjmp .L526
 7234               	.L504:
1580:switcherator.c ****     if (weekdays & 0x40) {
 7235               		.loc 1 1580 0
 7236 293a F6FE      		sbrs r15,6
 7237 293c 00C0      		rjmp .L505
1581:switcherator.c ****         strcat(statusMsg, "S");
 7238               		.loc 1 1581 0
 7239 293e 60E0      		ldi r22,lo8(.LC41)
 7240 2940 70E0      		ldi r23,hi8(.LC41)
 7241 2942 00C0      		rjmp .L520
 7242               	.L505:
1583:switcherator.c ****         strcat(statusMsg, "-");
 7243               		.loc 1 1583 0
 7244 2944 60E0      		ldi r22,lo8(.LC46)
 7245 2946 70E0      		ldi r23,hi8(.LC46)
 7246               	.L520:
 7247 2948 80E0      		ldi r24,lo8(statusMsg)
 7248 294a 90E0      		ldi r25,hi8(statusMsg)
 7249 294c 0E94 0000 		call strcat
 7250               	.LVL559:
1585:switcherator.c ****     if (weekdays & 0x20) {
 7251               		.loc 1 1585 0
 7252 2950 F5FE      		sbrs r15,5
 7253 2952 00C0      		rjmp .L507
1586:switcherator.c ****         strcat(statusMsg, "M");
 7254               		.loc 1 1586 0
 7255 2954 60E0      		ldi r22,lo8(.LC47)
 7256 2956 70E0      		ldi r23,hi8(.LC47)
 7257 2958 00C0      		rjmp .L521
 7258               	.L507:
1588:switcherator.c ****         strcat(statusMsg, "-");
 7259               		.loc 1 1588 0
 7260 295a 60E0      		ldi r22,lo8(.LC46)
 7261 295c 70E0      		ldi r23,hi8(.LC46)
 7262               	.L521:
 7263 295e 80E0      		ldi r24,lo8(statusMsg)
 7264 2960 90E0      		ldi r25,hi8(statusMsg)
 7265 2962 0E94 0000 		call strcat
 7266               	.LVL560:
1590:switcherator.c ****     if (weekdays & 0x10) {
 7267               		.loc 1 1590 0
 7268 2966 F4FE      		sbrs r15,4
 7269 2968 00C0      		rjmp .L509
1591:switcherator.c ****         strcat(statusMsg, "T");
 7270               		.loc 1 1591 0
 7271 296a 60E0      		ldi r22,lo8(.LC48)
 7272 296c 70E0      		ldi r23,hi8(.LC48)
 7273 296e 00C0      		rjmp .L522
 7274               	.L509:
1593:switcherator.c ****         strcat(statusMsg, "-");
 7275               		.loc 1 1593 0
 7276 2970 60E0      		ldi r22,lo8(.LC46)
 7277 2972 70E0      		ldi r23,hi8(.LC46)
 7278               	.L522:
 7279 2974 80E0      		ldi r24,lo8(statusMsg)
 7280 2976 90E0      		ldi r25,hi8(statusMsg)
 7281 2978 0E94 0000 		call strcat
 7282               	.LVL561:
1595:switcherator.c ****     if (weekdays & 0x08) {
 7283               		.loc 1 1595 0
 7284 297c F3FE      		sbrs r15,3
 7285 297e 00C0      		rjmp .L511
1596:switcherator.c ****         strcat(statusMsg, "W");
 7286               		.loc 1 1596 0
 7287 2980 60E0      		ldi r22,lo8(.LC49)
 7288 2982 70E0      		ldi r23,hi8(.LC49)
 7289 2984 00C0      		rjmp .L523
 7290               	.L511:
1598:switcherator.c ****         strcat(statusMsg, "-");
 7291               		.loc 1 1598 0
 7292 2986 60E0      		ldi r22,lo8(.LC46)
 7293 2988 70E0      		ldi r23,hi8(.LC46)
 7294               	.L523:
 7295 298a 80E0      		ldi r24,lo8(statusMsg)
 7296 298c 90E0      		ldi r25,hi8(statusMsg)
 7297 298e 0E94 0000 		call strcat
 7298               	.LVL562:
1600:switcherator.c ****     if (weekdays & 0x04) {
 7299               		.loc 1 1600 0
 7300 2992 F2FE      		sbrs r15,2
 7301 2994 00C0      		rjmp .L513
1601:switcherator.c ****         strcat(statusMsg, "T");
 7302               		.loc 1 1601 0
 7303 2996 60E0      		ldi r22,lo8(.LC48)
 7304 2998 70E0      		ldi r23,hi8(.LC48)
 7305 299a 00C0      		rjmp .L524
 7306               	.L513:
1603:switcherator.c ****         strcat(statusMsg, "-");
 7307               		.loc 1 1603 0
 7308 299c 60E0      		ldi r22,lo8(.LC46)
 7309 299e 70E0      		ldi r23,hi8(.LC46)
 7310               	.L524:
 7311 29a0 80E0      		ldi r24,lo8(statusMsg)
 7312 29a2 90E0      		ldi r25,hi8(statusMsg)
 7313 29a4 0E94 0000 		call strcat
 7314               	.LVL563:
1605:switcherator.c ****     if (weekdays & 0x02) {
 7315               		.loc 1 1605 0
 7316 29a8 F1FE      		sbrs r15,1
 7317 29aa 00C0      		rjmp .L515
1606:switcherator.c ****         strcat(statusMsg, "F");
 7318               		.loc 1 1606 0
 7319 29ac 60E0      		ldi r22,lo8(.LC50)
 7320 29ae 70E0      		ldi r23,hi8(.LC50)
 7321 29b0 00C0      		rjmp .L525
 7322               	.L515:
1608:switcherator.c ****         strcat(statusMsg, "-");
 7323               		.loc 1 1608 0
 7324 29b2 60E0      		ldi r22,lo8(.LC46)
 7325 29b4 70E0      		ldi r23,hi8(.LC46)
 7326               	.L525:
 7327 29b6 80E0      		ldi r24,lo8(statusMsg)
 7328 29b8 90E0      		ldi r25,hi8(statusMsg)
 7329 29ba 0E94 0000 		call strcat
 7330               	.LVL564:
1610:switcherator.c ****     if (weekdays & 0x01) {
 7331               		.loc 1 1610 0
 7332 29be F0FE      		sbrs r15,0
 7333 29c0 00C0      		rjmp .L517
1611:switcherator.c ****         strcat(statusMsg, "S");
 7334               		.loc 1 1611 0
 7335 29c2 60E0      		ldi r22,lo8(.LC41)
 7336 29c4 70E0      		ldi r23,hi8(.LC41)
 7337 29c6 00C0      		rjmp .L526
 7338               	.L517:
1613:switcherator.c ****         strcat(statusMsg, "-");
 7339               		.loc 1 1613 0
 7340 29c8 60E0      		ldi r22,lo8(.LC46)
 7341 29ca 70E0      		ldi r23,hi8(.LC46)
 7342               	.LVL565:
 7343               	.L526:
 7344 29cc 80E0      		ldi r24,lo8(statusMsg)
 7345 29ce 90E0      		ldi r25,hi8(statusMsg)
 7346 29d0 0E94 0000 		call strcat
 7347               	.LVL566:
1616:switcherator.c ****     sendMessage(statusMsg);
 7348               		.loc 1 1616 0
 7349 29d4 80E0      		ldi r24,lo8(statusMsg)
 7350 29d6 90E0      		ldi r25,hi8(statusMsg)
 7351 29d8 0E94 0000 		call sendMessage
 7352               	.LVL567:
 7353               	/* epilogue start */
1617:switcherator.c **** }
 7354               		.loc 1 1617 0
 7355 29dc 6096      		adiw r28,16
 7356 29de 0FB6      		in __tmp_reg__,__SREG__
 7357 29e0 F894      		cli
 7358 29e2 DEBF      		out __SP_H__,r29
 7359 29e4 0FBE      		out __SREG__,__tmp_reg__
 7360 29e6 CDBF      		out __SP_L__,r28
 7361 29e8 DF91      		pop r29
 7362 29ea CF91      		pop r28
 7363 29ec 1F91      		pop r17
 7364 29ee 0F91      		pop r16
 7365 29f0 FF90      		pop r15
 7366 29f2 EF90      		pop r14
 7367 29f4 DF90      		pop r13
 7368 29f6 CF90      		pop r12
 7369 29f8 BF90      		pop r11
 7370 29fa AF90      		pop r10
 7371 29fc 0895      		ret
 7372               	.LFE37:
 7374               		.section	.rodata.str1.1
 7375               	.LC51:
 7376 00f0 5661 6C20 		.string	"Val 0x"
 7376      3078 00
 7377               	.LC52:
 7378 00f7 2C00      		.string	","
 7379               	.LC53:
 7380 00f9 2064 6972 		.string	" dir "
 7380      2000 
 7381               	.LC54:
 7382 00ff 436F 6C20 		.string	"Col Ch"
 7382      4368 00
 7383               	.LC55:
 7384 0106 5057 4D20 		.string	"PWM "
 7384      00
 7385               	.LC56:
 7386 010b 7374 6174 		.string	"static"
 7386      6963 00
 7387               	.LC57:
 7388 0112 436F 6C43 		.string	"ColCh"
 7388      6800 
 7389               	.LC58:
 7390 0118 6875 6500 		.string	"hue"
 7391               	.LC59:
 7392 011c 6F6E 2073 		.string	"on sw# "
 7392      7723 2000 
 7393               		.text
 7394               	.global	pwmSummary
 7396               	pwmSummary:
 7397               	.LFB26:
1013:switcherator.c **** void pwmSummary(void) {
 7398               		.loc 1 1013 0
 7399 29fe CF92      		push r12
 7400               	.LCFI176:
 7401 2a00 DF92      		push r13
 7402               	.LCFI177:
 7403 2a02 EF92      		push r14
 7404               	.LCFI178:
 7405 2a04 FF92      		push r15
 7406               	.LCFI179:
 7407 2a06 0F93      		push r16
 7408               	.LCFI180:
 7409 2a08 1F93      		push r17
 7410               	.LCFI181:
 7411 2a0a CF93      		push r28
 7412               	.LCFI182:
 7413 2a0c DF93      		push r29
 7414               	.LCFI183:
 7415 2a0e 1F92      		push __zero_reg__
 7416               	.LCFI184:
 7417 2a10 CDB7      		in r28,__SP_L__
 7418 2a12 DEB7      		in r29,__SP_H__
 7419               	.LCFI185:
 7420               	/* prologue: function */
 7421               	/* frame size = 1 */
 7422               	/* stack size = 9 */
 7423               	.L__stack_usage = 9
1014:switcherator.c ****     statusMsg[0] = 0;
 7424               		.loc 1 1014 0
 7425 2a14 1092 0000 		sts statusMsg,__zero_reg__
1015:switcherator.c ****     strcat(statusMsg, "Val 0x");
 7426               		.loc 1 1015 0
 7427 2a18 60E0      		ldi r22,lo8(.LC51)
 7428 2a1a 70E0      		ldi r23,hi8(.LC51)
 7429 2a1c 80E0      		ldi r24,lo8(statusMsg)
 7430 2a1e 90E0      		ldi r25,hi8(statusMsg)
 7431 2a20 0E94 0000 		call strcat
 7432               	.LVL568:
 7433 2a24 00E0      		ldi r16,lo8(pwmValues)
 7434 2a26 10E0      		ldi r17,hi8(pwmValues)
1017:switcherator.c ****     for (x = 0; x < 3; x++) {
 7435               		.loc 1 1017 0
 7436 2a28 E12C      		mov r14,__zero_reg__
 7437 2a2a F12C      		mov r15,__zero_reg__
 7438 2a2c 00C0      		rjmp .L528
 7439               	.LVL569:
 7440               	.L529:
1019:switcherator.c ****             strcat(statusMsg, ",");
 7441               		.loc 1 1019 0
 7442 2a2e 60E0      		ldi r22,lo8(.LC52)
 7443 2a30 70E0      		ldi r23,hi8(.LC52)
 7444 2a32 80E0      		ldi r24,lo8(statusMsg)
 7445 2a34 90E0      		ldi r25,hi8(statusMsg)
 7446 2a36 0E94 0000 		call strcat
 7447               	.LVL570:
 7448               	.L528:
1020:switcherator.c ****         returnHexWithout(pwmValues[x], tempLongString);
 7449               		.loc 1 1020 0
 7450 2a3a 60E0      		ldi r22,lo8(tempLongString)
 7451 2a3c 70E0      		ldi r23,hi8(tempLongString)
 7452 2a3e F801      		movw r30,r16
 7453 2a40 8191      		ld r24,Z+
 7454 2a42 8F01      		movw r16,r30
 7455 2a44 90E0      		ldi r25,0
 7456 2a46 0E94 0000 		call returnHexWithout
 7457               	.LVL571:
1021:switcherator.c ****         strcat(statusMsg, tempLongString);
 7458               		.loc 1 1021 0
 7459 2a4a 60E0      		ldi r22,lo8(tempLongString)
 7460 2a4c 70E0      		ldi r23,hi8(tempLongString)
 7461 2a4e 80E0      		ldi r24,lo8(statusMsg)
 7462 2a50 90E0      		ldi r25,hi8(statusMsg)
 7463 2a52 0E94 0000 		call strcat
 7464               	.LVL572:
1017:switcherator.c ****     for (x = 0; x < 3; x++) {
 7465               		.loc 1 1017 0
 7466 2a56 FFEF      		ldi r31,-1
 7467 2a58 EF1A      		sub r14,r31
 7468 2a5a FF0A      		sbc r15,r31
 7469               	.LVL573:
 7470 2a5c 83E0      		ldi r24,3
 7471 2a5e E816      		cp r14,r24
 7472 2a60 F104      		cpc r15,__zero_reg__
 7473 2a62 01F4      		brne .L529
1023:switcherator.c ****     strcat(statusMsg, " dir ");
 7474               		.loc 1 1023 0
 7475 2a64 60E0      		ldi r22,lo8(.LC53)
 7476 2a66 70E0      		ldi r23,hi8(.LC53)
 7477 2a68 80E0      		ldi r24,lo8(statusMsg)
 7478 2a6a 90E0      		ldi r25,hi8(statusMsg)
 7479 2a6c 0E94 0000 		call strcat
 7480               	.LVL574:
1024:switcherator.c ****     returnInt(pwmdir, tempLongString);
 7481               		.loc 1 1024 0
 7482 2a70 60E0      		ldi r22,lo8(tempLongString)
 7483 2a72 70E0      		ldi r23,hi8(tempLongString)
 7484 2a74 8091 0000 		lds r24,pwmdir
 7485 2a78 90E0      		ldi r25,0
 7486 2a7a 0E94 0000 		call returnInt
 7487               	.LVL575:
1025:switcherator.c ****     strcat(statusMsg, tempLongString);
 7488               		.loc 1 1025 0
 7489 2a7e 60E0      		ldi r22,lo8(tempLongString)
 7490 2a80 70E0      		ldi r23,hi8(tempLongString)
 7491 2a82 80E0      		ldi r24,lo8(statusMsg)
 7492 2a84 90E0      		ldi r25,hi8(statusMsg)
 7493 2a86 0E94 0000 		call strcat
 7494               	.LVL576:
1026:switcherator.c ****     sendMessage(statusMsg);
 7495               		.loc 1 1026 0
 7496 2a8a 80E0      		ldi r24,lo8(statusMsg)
 7497 2a8c 90E0      		ldi r25,hi8(statusMsg)
 7498 2a8e 0E94 0000 		call sendMessage
 7499               	.LVL577:
1027:switcherator.c ****     statusMsg[0] = 0;
 7500               		.loc 1 1027 0
 7501 2a92 1092 0000 		sts statusMsg,__zero_reg__
1028:switcherator.c ****     strcat(statusMsg, "Col Ch");
 7502               		.loc 1 1028 0
 7503 2a96 60E0      		ldi r22,lo8(.LC54)
 7504 2a98 70E0      		ldi r23,hi8(.LC54)
 7505 2a9a 80E0      		ldi r24,lo8(statusMsg)
 7506 2a9c 90E0      		ldi r25,hi8(statusMsg)
 7507 2a9e 0E94 0000 		call strcat
 7508               	.LVL578:
 7509 2aa2 70E0      		ldi r23,lo8(colorChanges)
 7510 2aa4 E72E      		mov r14,r23
 7511 2aa6 70E0      		ldi r23,hi8(colorChanges)
 7512 2aa8 F72E      		mov r15,r23
1030:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 7513               		.loc 1 1030 0
 7514 2aaa C12C      		mov r12,__zero_reg__
 7515 2aac D12C      		mov r13,__zero_reg__
 7516 2aae 00C0      		rjmp .L530
 7517               	.LVL579:
 7518               	.L533:
1032:switcherator.c ****             strcat(statusMsg, ",");
 7519               		.loc 1 1032 0
 7520 2ab0 60E0      		ldi r22,lo8(.LC52)
 7521 2ab2 70E0      		ldi r23,hi8(.LC52)
 7522 2ab4 80E0      		ldi r24,lo8(statusMsg)
 7523 2ab6 90E0      		ldi r25,hi8(statusMsg)
 7524 2ab8 0E94 0000 		call strcat
 7525               	.LVL580:
 7526 2abc E3E0      		ldi r30,3
 7527 2abe EE0E      		add r14,r30
 7528 2ac0 F11C      		adc r15,__zero_reg__
 7529               	.LVL581:
 7530               	.L530:
1033:switcherator.c ****         strcat(statusMsg, "0x");
 7531               		.loc 1 1033 0
 7532 2ac2 60E0      		ldi r22,lo8(.LC5)
 7533 2ac4 70E0      		ldi r23,hi8(.LC5)
 7534 2ac6 80E0      		ldi r24,lo8(statusMsg)
 7535 2ac8 90E0      		ldi r25,hi8(statusMsg)
 7536 2aca 0E94 0000 		call strcat
 7537               	.LVL582:
1034:switcherator.c ****         for (y = 0; y < 3; y++) {
 7538               		.loc 1 1034 0
 7539 2ace 00E0      		ldi r16,0
 7540 2ad0 10E0      		ldi r17,0
 7541               	.LVL583:
 7542               	.L531:
1013:switcherator.c **** void pwmSummary(void) {
 7543               		.loc 1 1013 0 discriminator 2
 7544 2ad2 F701      		movw r30,r14
 7545 2ad4 E00F      		add r30,r16
 7546 2ad6 F11F      		adc r31,r17
1035:switcherator.c ****             returnHexWithout(colorChanges[x][y], tempLongString);
 7547               		.loc 1 1035 0 discriminator 2
 7548 2ad8 60E0      		ldi r22,lo8(tempLongString)
 7549 2ada 70E0      		ldi r23,hi8(tempLongString)
 7550 2adc 8081      		ld r24,Z
 7551 2ade 90E0      		ldi r25,0
 7552 2ae0 0E94 0000 		call returnHexWithout
 7553               	.LVL584:
1036:switcherator.c ****             strcat(statusMsg, tempLongString);
 7554               		.loc 1 1036 0 discriminator 2
 7555 2ae4 60E0      		ldi r22,lo8(tempLongString)
 7556 2ae6 70E0      		ldi r23,hi8(tempLongString)
 7557 2ae8 80E0      		ldi r24,lo8(statusMsg)
 7558 2aea 90E0      		ldi r25,hi8(statusMsg)
 7559 2aec 0E94 0000 		call strcat
 7560               	.LVL585:
1034:switcherator.c ****         for (y = 0; y < 3; y++) {
 7561               		.loc 1 1034 0 discriminator 2
 7562 2af0 0F5F      		subi r16,-1
 7563 2af2 1F4F      		sbci r17,-1
 7564               	.LVL586:
 7565 2af4 0330      		cpi r16,3
 7566 2af6 1105      		cpc r17,__zero_reg__
 7567 2af8 01F4      		brne .L531
1038:switcherator.c ****         if (strlen(statusMsg) > 25 && (x + 1) < NUM_COLOR_CHANGES) {
 7568               		.loc 1 1038 0
 7569 2afa E0E0      		ldi r30,lo8(statusMsg)
 7570 2afc F0E0      		ldi r31,hi8(statusMsg)
 7571               		0:
 7572 2afe 0190      		ld __tmp_reg__,Z+
 7573 2b00 0020      		tst __tmp_reg__
 7574 2b02 01F4      		brne 0b
 7575 2b04 3197      		sbiw r30,1
 7576 2b06 E050      		subi r30,lo8(statusMsg)
 7577 2b08 F040      		sbci r31,hi8(statusMsg)
 7578 2b0a 7A97      		sbiw r30,26
 7579 2b0c 00F0      		brlo .L532
1038:switcherator.c ****         if (strlen(statusMsg) > 25 && (x + 1) < NUM_COLOR_CHANGES) {
 7580               		.loc 1 1038 0 is_stmt 0 discriminator 1
 7581 2b0e F5E0      		ldi r31,5
 7582 2b10 CF16      		cp r12,r31
 7583 2b12 D104      		cpc r13,__zero_reg__
 7584 2b14 01F0      		breq .L532
1039:switcherator.c ****             sendMessage(statusMsg);
 7585               		.loc 1 1039 0 is_stmt 1
 7586 2b16 80E0      		ldi r24,lo8(statusMsg)
 7587 2b18 90E0      		ldi r25,hi8(statusMsg)
 7588 2b1a 0E94 0000 		call sendMessage
 7589               	.LVL587:
1040:switcherator.c ****             statusMsg[6] = 0;
 7590               		.loc 1 1040 0
 7591 2b1e 1092 0000 		sts statusMsg+6,__zero_reg__
 7592               	.L532:
1030:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 7593               		.loc 1 1030 0
 7594 2b22 8FEF      		ldi r24,-1
 7595 2b24 C81A      		sub r12,r24
 7596 2b26 D80A      		sbc r13,r24
 7597               	.LVL588:
 7598 2b28 E6E0      		ldi r30,6
 7599 2b2a CE16      		cp r12,r30
 7600 2b2c D104      		cpc r13,__zero_reg__
 7601 2b2e 01F0      		breq .+2
 7602 2b30 00C0      		rjmp .L533
1043:switcherator.c ****     sendMessage(statusMsg);
 7603               		.loc 1 1043 0
 7604 2b32 80E0      		ldi r24,lo8(statusMsg)
 7605 2b34 90E0      		ldi r25,hi8(statusMsg)
 7606 2b36 0E94 0000 		call sendMessage
 7607               	.LVL589:
1044:switcherator.c ****     statusMsg[0] = 0;
 7608               		.loc 1 1044 0
 7609 2b3a 1092 0000 		sts statusMsg,__zero_reg__
 7610               	.LVL590:
 7611 2b3e 00E0      		ldi r16,lo8(switchStuff)
 7612 2b40 10E0      		ldi r17,hi8(switchStuff)
 7613               	.LVL591:
1045:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 7614               		.loc 1 1045 0
 7615 2b42 E12C      		mov r14,__zero_reg__
 7616 2b44 F12C      		mov r15,__zero_reg__
 7617               	.LVL592:
 7618               	.L538:
1046:switcherator.c ****         if ((switchStuff[x] >= 200) && (switchStuff[x] <= 220)) {
 7619               		.loc 1 1046 0
 7620 2b46 F801      		movw r30,r16
 7621 2b48 2191      		ld r18,Z+
 7622 2b4a 8F01      		movw r16,r30
 7623 2b4c 822F      		mov r24,r18
 7624 2b4e 885C      		subi r24,lo8(-(56))
 7625 2b50 8531      		cpi r24,lo8(21)
 7626 2b52 00F4      		brsh .L534
1047:switcherator.c ****             strcat(statusMsg, "PWM ");
 7627               		.loc 1 1047 0
 7628 2b54 60E0      		ldi r22,lo8(.LC55)
 7629 2b56 70E0      		ldi r23,hi8(.LC55)
 7630 2b58 80E0      		ldi r24,lo8(statusMsg)
 7631 2b5a 90E0      		ldi r25,hi8(statusMsg)
 7632 2b5c 2983      		std Y+1,r18
 7633 2b5e 0E94 0000 		call strcat
 7634               	.LVL593:
1048:switcherator.c ****             if (switchStuff[x] == 200) {
 7635               		.loc 1 1048 0
 7636 2b62 2981      		ldd r18,Y+1
 7637 2b64 283C      		cpi r18,lo8(-56)
 7638 2b66 01F4      		brne .L535
1049:switcherator.c ****                 strcat(statusMsg, "static");
 7639               		.loc 1 1049 0
 7640 2b68 60E0      		ldi r22,lo8(.LC56)
 7641 2b6a 70E0      		ldi r23,hi8(.LC56)
 7642 2b6c 00C0      		rjmp .L544
 7643               	.L535:
1050:switcherator.c ****             } else if (switchStuff[x] == 202) {
 7644               		.loc 1 1050 0
 7645 2b6e 2A3C      		cpi r18,lo8(-54)
 7646 2b70 01F4      		brne .L537
1051:switcherator.c ****                 strcat(statusMsg, "ColCh");
 7647               		.loc 1 1051 0
 7648 2b72 60E0      		ldi r22,lo8(.LC57)
 7649 2b74 70E0      		ldi r23,hi8(.LC57)
 7650 2b76 00C0      		rjmp .L544
 7651               	.L537:
1053:switcherator.c ****                 strcat(statusMsg, "hue");
 7652               		.loc 1 1053 0
 7653 2b78 60E0      		ldi r22,lo8(.LC58)
 7654 2b7a 70E0      		ldi r23,hi8(.LC58)
 7655               	.L544:
 7656 2b7c 80E0      		ldi r24,lo8(statusMsg)
 7657 2b7e 90E0      		ldi r25,hi8(statusMsg)
 7658 2b80 0E94 0000 		call strcat
 7659               	.LVL594:
1055:switcherator.c ****             strcat(statusMsg, "on sw# ");
 7660               		.loc 1 1055 0
 7661 2b84 60E0      		ldi r22,lo8(.LC59)
 7662 2b86 70E0      		ldi r23,hi8(.LC59)
 7663 2b88 80E0      		ldi r24,lo8(statusMsg)
 7664 2b8a 90E0      		ldi r25,hi8(statusMsg)
 7665 2b8c 0E94 0000 		call strcat
 7666               	.LVL595:
1056:switcherator.c ****             returnInt(x, tempLongString);
 7667               		.loc 1 1056 0
 7668 2b90 60E0      		ldi r22,lo8(tempLongString)
 7669 2b92 70E0      		ldi r23,hi8(tempLongString)
 7670 2b94 C701      		movw r24,r14
 7671 2b96 0E94 0000 		call returnInt
 7672               	.LVL596:
1057:switcherator.c ****             strcat(statusMsg, tempLongString);
 7673               		.loc 1 1057 0
 7674 2b9a 60E0      		ldi r22,lo8(tempLongString)
 7675 2b9c 70E0      		ldi r23,hi8(tempLongString)
 7676 2b9e 80E0      		ldi r24,lo8(statusMsg)
 7677 2ba0 90E0      		ldi r25,hi8(statusMsg)
 7678 2ba2 0E94 0000 		call strcat
 7679               	.LVL597:
1058:switcherator.c ****             sendMessage(statusMsg);
 7680               		.loc 1 1058 0
 7681 2ba6 80E0      		ldi r24,lo8(statusMsg)
 7682 2ba8 90E0      		ldi r25,hi8(statusMsg)
 7683 2baa 0E94 0000 		call sendMessage
 7684               	.LVL598:
1059:switcherator.c ****             statusMsg[0] = 0;
 7685               		.loc 1 1059 0
 7686 2bae 1092 0000 		sts statusMsg,__zero_reg__
 7687               	.L534:
1045:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 7688               		.loc 1 1045 0
 7689 2bb2 FFEF      		ldi r31,-1
 7690 2bb4 EF1A      		sub r14,r31
 7691 2bb6 FF0A      		sbc r15,r31
 7692               	.LVL599:
 7693 2bb8 80E1      		ldi r24,16
 7694 2bba E816      		cp r14,r24
 7695 2bbc F104      		cpc r15,__zero_reg__
 7696 2bbe 01F4      		brne .L538
 7697               	/* epilogue start */
1062:switcherator.c **** }
 7698               		.loc 1 1062 0
 7699 2bc0 0F90      		pop __tmp_reg__
 7700 2bc2 DF91      		pop r29
 7701 2bc4 CF91      		pop r28
 7702 2bc6 1F91      		pop r17
 7703 2bc8 0F91      		pop r16
 7704 2bca FF90      		pop r15
 7705 2bcc EF90      		pop r14
 7706               	.LVL600:
 7707 2bce DF90      		pop r13
 7708 2bd0 CF90      		pop r12
 7709 2bd2 0895      		ret
 7710               	.LFE26:
 7712               		.section	.rodata.str1.1
 7713               	.LC60:
 7714 0124 436F 4300 		.string	"CoC"
 7715               	.LC61:
 7716 0128 4272 7400 		.string	"Brt"
 7717               	.LC62:
 7718 012c 4669 7800 		.string	"Fix"
 7719               	.LC63:
 7720 0130 4875 6500 		.string	"Hue"
 7721               	.LC64:
 7722 0134 4C00      		.string	"L"
 7723               	.LC65:
 7724 0136 4800      		.string	"H"
 7725               		.text
 7726               	.global	switchDisplay
 7728               	switchDisplay:
 7729               	.LFB16:
 636:switcherator.c **** void switchDisplay(char * commandReceived) {
 7730               		.loc 1 636 0
 7731               	.LVL601:
 7732 2bd4 CF93      		push r28
 7733               	.LCFI186:
 7734 2bd6 DF93      		push r29
 7735               	.LCFI187:
 7736 2bd8 CDB7      		in r28,__SP_L__
 7737 2bda DEB7      		in r29,__SP_H__
 7738               	.LCFI188:
 7739 2bdc A397      		sbiw r28,35
 7740               	.LCFI189:
 7741 2bde 0FB6      		in __tmp_reg__,__SREG__
 7742 2be0 F894      		cli
 7743 2be2 DEBF      		out __SP_H__,r29
 7744 2be4 0FBE      		out __SREG__,__tmp_reg__
 7745 2be6 CDBF      		out __SP_L__,r28
 7746               	/* prologue: function */
 7747               	/* frame size = 35 */
 7748               	/* stack size = 37 */
 7749               	.L__stack_usage = 37
 637:switcherator.c ****     char port[] = {0};
 7750               		.loc 1 637 0
 7751 2be8 1BA2      		std Y+35,__zero_reg__
 638:switcherator.c ****     char pin[] = {0};
 7752               		.loc 1 638 0
 7753 2bea 1AA2      		std Y+34,__zero_reg__
 639:switcherator.c ****     char direction[] = {0};
 7754               		.loc 1 639 0
 7755 2bec 19A2      		std Y+33,__zero_reg__
 7756               	.LVL602:
 643:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 7757               		.loc 1 643 0
 7758 2bee 0E94 0000 		call getSwitchNumber
 7759               	.LVL603:
 644:switcherator.c ****     statusMsg[0] = 0;
 7760               		.loc 1 644 0
 7761 2bf2 1982      		std Y+1,__zero_reg__
 646:switcherator.c ****     if (switchStuff[switchNumber] >= 200 && switchStuff[switchNumber] <= 220) {
 7762               		.loc 1 646 0
 7763 2bf4 FC01      		movw r30,r24
 7764 2bf6 E050      		subi r30,lo8(-(switchStuff))
 7765 2bf8 F040      		sbci r31,hi8(-(switchStuff))
 7766 2bfa 2081      		ld r18,Z
 7767 2bfc 322F      		mov r19,r18
 7768 2bfe 385C      		subi r19,lo8(-(56))
 7769 2c00 3531      		cpi r19,lo8(21)
 7770 2c02 00F4      		brsh .L546
 648:switcherator.c ****         if (switchStuff[switchNumber] % 2 == 0) {
 7771               		.loc 1 648 0
 7772 2c04 20FD      		sbrc r18,0
 7773 2c06 00C0      		rjmp .L547
 649:switcherator.c ****             if (switchStuff[switchNumber] == 202) {
 7774               		.loc 1 649 0
 7775 2c08 2A3C      		cpi r18,lo8(-54)
 7776 2c0a 01F4      		brne .L548
 650:switcherator.c ****                 strcat(statusMsg, "CoC");
 7777               		.loc 1 650 0
 7778 2c0c 60E0      		ldi r22,lo8(.LC60)
 7779 2c0e 70E0      		ldi r23,hi8(.LC60)
 7780 2c10 00C0      		rjmp .L552
 7781               	.L548:
 651:switcherator.c ****             } else if (switchStuff[switchNumber] == 212) {
 7782               		.loc 1 651 0
 7783 2c12 243D      		cpi r18,lo8(-44)
 7784 2c14 01F4      		brne .L550
 652:switcherator.c ****                 strcat(statusMsg, "Brt");
 7785               		.loc 1 652 0
 7786 2c16 60E0      		ldi r22,lo8(.LC61)
 7787 2c18 70E0      		ldi r23,hi8(.LC61)
 7788 2c1a 00C0      		rjmp .L552
 7789               	.L550:
 654:switcherator.c ****                 strcat(statusMsg, "Fix");
 7790               		.loc 1 654 0
 7791 2c1c 60E0      		ldi r22,lo8(.LC62)
 7792 2c1e 70E0      		ldi r23,hi8(.LC62)
 7793 2c20 00C0      		rjmp .L552
 7794               	.L547:
 657:switcherator.c ****             strcat(statusMsg, "Hue");
 7795               		.loc 1 657 0
 7796 2c22 60E0      		ldi r22,lo8(.LC63)
 7797 2c24 70E0      		ldi r23,hi8(.LC63)
 7798 2c26 00C0      		rjmp .L552
 7799               	.L546:
 660:switcherator.c ****         getPort(switchNumber, port, pin, direction);
 7800               		.loc 1 660 0
 7801 2c28 9E01      		movw r18,r28
 7802 2c2a 2F5D      		subi r18,-33
 7803 2c2c 3F4F      		sbci r19,-1
 7804 2c2e AE01      		movw r20,r28
 7805 2c30 4E5D      		subi r20,-34
 7806 2c32 5F4F      		sbci r21,-1
 7807 2c34 BE01      		movw r22,r28
 7808 2c36 6D5D      		subi r22,-35
 7809 2c38 7F4F      		sbci r23,-1
 7810 2c3a 0E94 0000 		call getPort
 7811               	.LVL604:
 661:switcherator.c ****         tempIntString[0] = port[0];
 7812               		.loc 1 661 0
 7813 2c3e 8BA1      		ldd r24,Y+35
 7814 2c40 8093 0000 		sts tempIntString,r24
 662:switcherator.c ****         tempIntString[1] = 0;
 7815               		.loc 1 662 0
 7816 2c44 1092 0000 		sts tempIntString+1,__zero_reg__
 663:switcherator.c ****         strcat(statusMsg, tempIntString);
 7817               		.loc 1 663 0
 7818 2c48 60E0      		ldi r22,lo8(tempIntString)
 7819 2c4a 70E0      		ldi r23,hi8(tempIntString)
 7820 2c4c CE01      		movw r24,r28
 7821 2c4e 0196      		adiw r24,1
 7822 2c50 0E94 0000 		call strcat
 7823               	.LVL605:
 665:switcherator.c ****         itoa(realPin, tempIntString, 10);
 7824               		.loc 1 665 0
 7825 2c54 4AE0      		ldi r20,lo8(10)
 7826 2c56 50E0      		ldi r21,0
 7827 2c58 60E0      		ldi r22,lo8(tempIntString)
 7828 2c5a 70E0      		ldi r23,hi8(tempIntString)
 7829 2c5c 8AA1      		ldd r24,Y+34
 7830 2c5e 90E0      		ldi r25,0
 7831 2c60 0E94 0000 		call itoa
 7832               	.LVL606:
 666:switcherator.c ****         strcat(statusMsg, tempIntString);
 7833               		.loc 1 666 0
 7834 2c64 60E0      		ldi r22,lo8(tempIntString)
 7835 2c66 70E0      		ldi r23,hi8(tempIntString)
 7836 2c68 CE01      		movw r24,r28
 7837 2c6a 0196      		adiw r24,1
 7838 2c6c 0E94 0000 		call strcat
 7839               	.LVL607:
 667:switcherator.c ****         if (direction[0] == 0) {
 7840               		.loc 1 667 0
 7841 2c70 89A1      		ldd r24,Y+33
 7842 2c72 8111      		cpse r24,__zero_reg__
 7843 2c74 00C0      		rjmp .L551
 668:switcherator.c ****             strcat(statusMsg, "L");
 7844               		.loc 1 668 0
 7845 2c76 60E0      		ldi r22,lo8(.LC64)
 7846 2c78 70E0      		ldi r23,hi8(.LC64)
 7847 2c7a 00C0      		rjmp .L552
 7848               	.L551:
 670:switcherator.c ****             strcat(statusMsg, "H");
 7849               		.loc 1 670 0
 7850 2c7c 60E0      		ldi r22,lo8(.LC65)
 7851 2c7e 70E0      		ldi r23,hi8(.LC65)
 7852               	.L552:
 7853 2c80 CE01      		movw r24,r28
 7854 2c82 0196      		adiw r24,1
 7855 2c84 0E94 0000 		call strcat
 7856               	.LVL608:
 673:switcherator.c ****     sendMessage(statusMsg);
 7857               		.loc 1 673 0
 7858 2c88 CE01      		movw r24,r28
 7859 2c8a 0196      		adiw r24,1
 7860 2c8c 0E94 0000 		call sendMessage
 7861               	.LVL609:
 7862               	/* epilogue start */
 675:switcherator.c **** }
 7863               		.loc 1 675 0
 7864 2c90 A396      		adiw r28,35
 7865 2c92 0FB6      		in __tmp_reg__,__SREG__
 7866 2c94 F894      		cli
 7867 2c96 DEBF      		out __SP_H__,r29
 7868 2c98 0FBE      		out __SREG__,__tmp_reg__
 7869 2c9a CDBF      		out __SP_L__,r28
 7870 2c9c DF91      		pop r29
 7871 2c9e CF91      		pop r28
 7872 2ca0 0895      		ret
 7873               	.LFE16:
 7875               		.section	.rodata.str1.1
 7876               	.LC66:
 7877 0138 6F6B 00   		.string	"ok"
 7878               		.text
 7879               	.global	ok
 7881               	ok:
 7882               	.LFB11:
 425:switcherator.c **** void ok(void) {
 7883               		.loc 1 425 0
 7884               	/* prologue: function */
 7885               	/* frame size = 0 */
 7886               	/* stack size = 0 */
 7887               	.L__stack_usage = 0
 426:switcherator.c ****     sendMessage("ok");
 7888               		.loc 1 426 0
 7889 2ca2 80E0      		ldi r24,lo8(.LC66)
 7890 2ca4 90E0      		ldi r25,hi8(.LC66)
 7891 2ca6 0C94 0000 		jmp sendMessage
 7892               	.LVL610:
 7893               	.LFE11:
 7895               	.global	clearInput
 7897               	clearInput:
 7898               	.LFB83:
3672:switcherator.c **** void clearInput(char * commandReceived) {
 7899               		.loc 1 3672 0
 7900               	.LVL611:
 7901               	/* prologue: function */
 7902               	/* frame size = 0 */
 7903               	/* stack size = 0 */
 7904               	.L__stack_usage = 0
3675:switcherator.c ****     tempIntString[0] = commandReceived[3];
 7905               		.loc 1 3675 0
 7906 2caa FC01      		movw r30,r24
 7907 2cac 2381      		ldd r18,Z+3
 7908 2cae 2093 0000 		sts tempIntString,r18
3676:switcherator.c ****     tempIntString[1] = commandReceived[4];
 7909               		.loc 1 3676 0
 7910 2cb2 8481      		ldd r24,Z+4
 7911               	.LVL612:
 7912 2cb4 8093 0000 		sts tempIntString+1,r24
3677:switcherator.c ****     inputNumber = atoi(tempIntString);
 7913               		.loc 1 3677 0
 7914 2cb8 80E0      		ldi r24,lo8(tempIntString)
 7915 2cba 90E0      		ldi r25,hi8(tempIntString)
 7916 2cbc 0E94 0000 		call atoi
 7917               	.LVL613:
3678:switcherator.c ****     int temp = inputs[inputNumber][0];
 7918               		.loc 1 3678 0
 7919 2cc0 E3E0      		ldi r30,3
 7920               		1:
 7921 2cc2 880F      		lsl r24
 7922 2cc4 991F      		rol r25
 7923 2cc6 EA95      		dec r30
 7924 2cc8 01F4      		brne 1b
 7925               	.LVL614:
 7926 2cca FC01      		movw r30,r24
 7927 2ccc E050      		subi r30,lo8(-(inputs))
 7928 2cce F040      		sbci r31,hi8(-(inputs))
 7929 2cd0 2081      		ld r18,Z
 7930 2cd2 30E0      		ldi r19,0
 7931               	.LVL615:
3679:switcherator.c ****     if (temp > 15 && temp < 32) {
 7932               		.loc 1 3679 0
 7933 2cd4 A901      		movw r20,r18
 7934 2cd6 4051      		subi r20,16
 7935 2cd8 5109      		sbc r21,__zero_reg__
 7936 2cda 4031      		cpi r20,16
 7937 2cdc 5105      		cpc r21,__zero_reg__
 7938 2cde 00F4      		brsh .L555
 7939               	.LVL616:
3681:switcherator.c ****         temp -= 16;
 7940               		.loc 1 3681 0
 7941 2ce0 9A01      		movw r18,r20
 7942               	.LVL617:
3680:switcherator.c ****         thisPort = &PINB;
 7943               		.loc 1 3680 0
 7944 2ce2 E3E2      		ldi r30,lo8(35)
 7945 2ce4 F0E0      		ldi r31,0
 7946 2ce6 00C0      		rjmp .L556
 7947               	.LVL618:
 7948               	.L555:
3688:switcherator.c ****     } else if (temp < 48) {
 7949               		.loc 1 3688 0
 7950 2ce8 2033      		cpi r18,48
 7951 2cea 3105      		cpc r19,__zero_reg__
 7952 2cec 04F4      		brge .L557
 7953               	.LVL619:
3690:switcherator.c ****         temp -= 32;
 7954               		.loc 1 3690 0
 7955 2cee 2052      		subi r18,32
 7956 2cf0 3109      		sbc r19,__zero_reg__
 7957               	.LVL620:
3689:switcherator.c ****         thisPort = &PINC;
 7958               		.loc 1 3689 0
 7959 2cf2 E6E2      		ldi r30,lo8(38)
 7960 2cf4 F0E0      		ldi r31,0
 7961 2cf6 00C0      		rjmp .L556
 7962               	.LVL621:
 7963               	.L557:
3693:switcherator.c ****     } else if (temp < 64) {
 7964               		.loc 1 3693 0
 7965 2cf8 2034      		cpi r18,64
 7966 2cfa 3105      		cpc r19,__zero_reg__
 7967 2cfc 04F4      		brge .L559
 7968               	.LVL622:
3695:switcherator.c ****         temp -= 48;
 7969               		.loc 1 3695 0
 7970 2cfe 2053      		subi r18,48
 7971 2d00 3109      		sbc r19,__zero_reg__
 7972               	.LVL623:
3694:switcherator.c ****         thisPort = &PIND;
 7973               		.loc 1 3694 0
 7974 2d02 E9E2      		ldi r30,lo8(41)
 7975 2d04 F0E0      		ldi r31,0
 7976               	.LVL624:
 7977               	.L556:
3727:switcherator.c ****     *thisPort &= ~(1 << temp);
 7978               		.loc 1 3727 0
 7979 2d06 3081      		ld r19,Z
 7980 2d08 41E0      		ldi r20,lo8(1)
 7981 2d0a 50E0      		ldi r21,0
 7982 2d0c 00C0      		rjmp 2f
 7983               		1:
 7984 2d0e 440F      		lsl r20
 7985               		2:
 7986 2d10 2A95      		dec r18
 7987 2d12 02F4      		brpl 1b
 7988 2d14 4095      		com r20
 7989 2d16 4323      		and r20,r19
 7990 2d18 4083      		st Z,r20
3728:switcherator.c ****     inputs[inputNumber][0] = 255;
 7991               		.loc 1 3728 0
 7992 2d1a FC01      		movw r30,r24
 7993               	.LVL625:
 7994 2d1c E050      		subi r30,lo8(-(inputs))
 7995 2d1e F040      		sbci r31,hi8(-(inputs))
 7996 2d20 2FEF      		ldi r18,lo8(-1)
 7997 2d22 2083      		st Z,r18
 7998               	.L559:
3729:switcherator.c ****     ok();
 7999               		.loc 1 3729 0
 8000 2d24 0C94 0000 		jmp ok
 8001               	.LVL626:
 8002               	.LFE83:
 8004               	.global	setDaylightSavings
 8006               	setDaylightSavings:
 8007               	.LFB54:
2257:switcherator.c **** void setDaylightSavings(char * commandReceived) {
 8008               		.loc 1 2257 0
 8009               	.LVL627:
 8010 2d28 EF92      		push r14
 8011               	.LCFI190:
 8012 2d2a FF92      		push r15
 8013               	.LCFI191:
 8014 2d2c 0F93      		push r16
 8015               	.LCFI192:
 8016 2d2e 1F93      		push r17
 8017               	.LCFI193:
 8018 2d30 CF93      		push r28
 8019               	.LCFI194:
 8020 2d32 DF93      		push r29
 8021               	.LCFI195:
 8022               	/* prologue: function */
 8023               	/* frame size = 0 */
 8024               	/* stack size = 6 */
 8025               	.L__stack_usage = 6
 8026 2d34 EC01      		movw r28,r24
2259:switcherator.c ****     tempIntString[0] = commandReceived[3];
 8027               		.loc 1 2259 0
 8028 2d36 F0E0      		ldi r31,lo8(tempIntString)
 8029 2d38 EF2E      		mov r14,r31
 8030 2d3a F0E0      		ldi r31,hi8(tempIntString)
 8031 2d3c FF2E      		mov r15,r31
 8032 2d3e 8B81      		ldd r24,Y+3
 8033               	.LVL628:
 8034 2d40 F701      		movw r30,r14
 8035 2d42 8083      		st Z,r24
2260:switcherator.c ****     tempIntString[1] = commandReceived[4];
 8036               		.loc 1 2260 0
 8037 2d44 00E0      		ldi r16,lo8(tempIntString+1)
 8038 2d46 10E0      		ldi r17,hi8(tempIntString+1)
 8039 2d48 8C81      		ldd r24,Y+4
 8040 2d4a F801      		movw r30,r16
 8041 2d4c 8083      		st Z,r24
2261:switcherator.c ****     dlInt = atoi(tempIntString);
 8042               		.loc 1 2261 0
 8043 2d4e C701      		movw r24,r14
 8044 2d50 0E94 0000 		call atoi
 8045               	.LVL629:
2262:switcherator.c ****     daylightSavings[0][0] = dlInt;
 8046               		.loc 1 2262 0
 8047 2d54 9093 0000 		sts daylightSavings+1,r25
 8048 2d58 8093 0000 		sts daylightSavings,r24
2263:switcherator.c ****     tempIntString[0] = commandReceived[5];
 8049               		.loc 1 2263 0
 8050 2d5c 8D81      		ldd r24,Y+5
 8051               	.LVL630:
 8052 2d5e F701      		movw r30,r14
 8053 2d60 8083      		st Z,r24
2264:switcherator.c ****     tempIntString[1] = commandReceived[6];
 8054               		.loc 1 2264 0
 8055 2d62 8E81      		ldd r24,Y+6
 8056 2d64 F801      		movw r30,r16
 8057 2d66 8083      		st Z,r24
2265:switcherator.c ****     dlInt = atoi(tempIntString);
 8058               		.loc 1 2265 0
 8059 2d68 C701      		movw r24,r14
 8060 2d6a 0E94 0000 		call atoi
 8061               	.LVL631:
2266:switcherator.c ****     daylightSavings[0][1] = dlInt;
 8062               		.loc 1 2266 0
 8063 2d6e 9093 0000 		sts daylightSavings+2+1,r25
 8064 2d72 8093 0000 		sts daylightSavings+2,r24
2267:switcherator.c ****     tempIntString[0] = commandReceived[8];
 8065               		.loc 1 2267 0
 8066 2d76 8885      		ldd r24,Y+8
 8067               	.LVL632:
 8068 2d78 F701      		movw r30,r14
 8069 2d7a 8083      		st Z,r24
2268:switcherator.c ****     tempIntString[1] = commandReceived[9];
 8070               		.loc 1 2268 0
 8071 2d7c 8985      		ldd r24,Y+9
 8072 2d7e F801      		movw r30,r16
 8073 2d80 8083      		st Z,r24
2269:switcherator.c ****     dlInt = atoi(tempIntString);
 8074               		.loc 1 2269 0
 8075 2d82 C701      		movw r24,r14
 8076 2d84 0E94 0000 		call atoi
 8077               	.LVL633:
2270:switcherator.c ****     daylightSavings[1][0] = dlInt;
 8078               		.loc 1 2270 0
 8079 2d88 9093 0000 		sts daylightSavings+4+1,r25
 8080 2d8c 8093 0000 		sts daylightSavings+4,r24
2271:switcherator.c ****     tempIntString[0] = commandReceived[10];
 8081               		.loc 1 2271 0
 8082 2d90 8A85      		ldd r24,Y+10
 8083               	.LVL634:
 8084 2d92 F701      		movw r30,r14
 8085 2d94 8083      		st Z,r24
2272:switcherator.c ****     tempIntString[1] = commandReceived[11];
 8086               		.loc 1 2272 0
 8087 2d96 8B85      		ldd r24,Y+11
 8088 2d98 F801      		movw r30,r16
 8089 2d9a 8083      		st Z,r24
2273:switcherator.c ****     dlInt = atoi(tempIntString);
 8090               		.loc 1 2273 0
 8091 2d9c C701      		movw r24,r14
 8092 2d9e 0E94 0000 		call atoi
 8093               	.LVL635:
2274:switcherator.c ****     daylightSavings[1][1] = dlInt;
 8094               		.loc 1 2274 0
 8095 2da2 9093 0000 		sts daylightSavings+6+1,r25
 8096 2da6 8093 0000 		sts daylightSavings+6,r24
 8097               	/* epilogue start */
2276:switcherator.c **** }
 8098               		.loc 1 2276 0
 8099 2daa DF91      		pop r29
 8100 2dac CF91      		pop r28
 8101               	.LVL636:
 8102 2dae 1F91      		pop r17
 8103 2db0 0F91      		pop r16
 8104 2db2 FF90      		pop r15
 8105 2db4 EF90      		pop r14
2275:switcherator.c ****     ok();
 8106               		.loc 1 2275 0
 8107 2db6 0C94 0000 		jmp ok
 8108               	.LVL637:
 8109               	.LFE54:
 8111               	.global	clearToEEPROM
 8113               	clearToEEPROM:
 8114               	.LFB46:
2087:switcherator.c **** void clearToEEPROM(void) {
 8115               		.loc 1 2087 0
 8116 2dba CF93      		push r28
 8117               	.LCFI196:
 8118 2dbc DF93      		push r29
 8119               	.LCFI197:
 8120               	/* prologue: function */
 8121               	/* frame size = 0 */
 8122               	/* stack size = 2 */
 8123               	.L__stack_usage = 2
 8124               	.LVL638:
2089:switcherator.c ****     clearEEPROM(SERIAL_NUM);
 8125               		.loc 1 2089 0
 8126 2dbe 80E0      		ldi r24,0
 8127 2dc0 90E0      		ldi r25,0
 8128 2dc2 0E94 0000 		call clearEEPROM
 8129               	.LVL639:
2090:switcherator.c ****     clearEEPROM(DAYLIGHT_SAVE);
 8130               		.loc 1 2090 0
 8131 2dc6 86E0      		ldi r24,lo8(6)
 8132 2dc8 90E0      		ldi r25,0
 8133 2dca 0E94 0000 		call clearEEPROM
 8134               	.LVL640:
2091:switcherator.c ****     clearEEPROM(RADIO_ADDR_TX);
 8135               		.loc 1 2091 0
 8136 2dce 8EE0      		ldi r24,lo8(14)
 8137 2dd0 90E0      		ldi r25,0
 8138 2dd2 0E94 0000 		call clearEEPROM
 8139               	.LVL641:
2092:switcherator.c ****     clearEEPROM(RADIO_ADDR_R0);
 8140               		.loc 1 2092 0
 8141 2dd6 85E1      		ldi r24,lo8(21)
 8142 2dd8 90E0      		ldi r25,0
 8143 2dda 0E94 0000 		call clearEEPROM
 8144               	.LVL642:
2093:switcherator.c ****     clearEEPROM(RADIO_ADDR_R1);
 8145               		.loc 1 2093 0
 8146 2dde 8CE1      		ldi r24,lo8(28)
 8147 2de0 90E0      		ldi r25,0
 8148 2de2 0E94 0000 		call clearEEPROM
 8149               	.LVL643:
2094:switcherator.c ****     clearEEPROM(RADIO_ADDR_R2);
 8150               		.loc 1 2094 0
 8151 2de6 83E2      		ldi r24,lo8(35)
 8152 2de8 90E0      		ldi r25,0
 8153 2dea 0E94 0000 		call clearEEPROM
 8154               	.LVL644:
2095:switcherator.c ****     clearEEPROM(RADIO_ADDR_R3);
 8155               		.loc 1 2095 0
 8156 2dee 86E2      		ldi r24,lo8(38)
 8157 2df0 90E0      		ldi r25,0
 8158 2df2 0E94 0000 		call clearEEPROM
 8159               	.LVL645:
2096:switcherator.c ****     clearEEPROM(RADIO_ADDR_R4);
 8160               		.loc 1 2096 0
 8161 2df6 89E2      		ldi r24,lo8(41)
 8162 2df8 90E0      		ldi r25,0
 8163 2dfa 0E94 0000 		call clearEEPROM
 8164               	.LVL646:
2097:switcherator.c ****     clearEEPROM(RADIO_ADDR_R5);
 8165               		.loc 1 2097 0
 8166 2dfe 8CE2      		ldi r24,lo8(44)
 8167 2e00 90E0      		ldi r25,0
 8168 2e02 0E94 0000 		call clearEEPROM
 8169               	.LVL647:
2098:switcherator.c ****     clearEEPROM(SWITCH_STUFF);
 8170               		.loc 1 2098 0
 8171 2e06 80E3      		ldi r24,lo8(48)
 8172 2e08 90E0      		ldi r25,0
 8173 2e0a 0E94 0000 		call clearEEPROM
 8174               	.LVL648:
2099:switcherator.c ****     clearEEPROM(PWM_DIR);
 8175               		.loc 1 2099 0
 8176 2e0e 8DE1      		ldi r24,lo8(29)
 8177 2e10 91E0      		ldi r25,lo8(1)
 8178 2e12 0E94 0000 		call clearEEPROM
 8179               	.LVL649:
2100:switcherator.c ****     clearEEPROM(BRIGHTNESS);
 8180               		.loc 1 2100 0
 8181 2e16 80E2      		ldi r24,lo8(32)
 8182 2e18 91E0      		ldi r25,lo8(1)
 8183 2e1a 0E94 0000 		call clearEEPROM
 8184               	.LVL650:
2102:switcherator.c ****         clearEEPROM((INPUT + (x * INPUT_BYTES)));
 8185               		.loc 1 2102 0
 8186 2e1e 82E4      		ldi r24,lo8(66)
 8187 2e20 90E0      		ldi r25,0
 8188 2e22 0E94 0000 		call clearEEPROM
 8189               	.LVL651:
 8190 2e26 8CE4      		ldi r24,lo8(76)
 8191 2e28 90E0      		ldi r25,0
 8192 2e2a 0E94 0000 		call clearEEPROM
 8193               	.LVL652:
 8194 2e2e 86E5      		ldi r24,lo8(86)
 8195 2e30 90E0      		ldi r25,0
 8196 2e32 0E94 0000 		call clearEEPROM
 8197               	.LVL653:
 8198 2e36 80E6      		ldi r24,lo8(96)
 8199 2e38 90E0      		ldi r25,0
 8200 2e3a 0E94 0000 		call clearEEPROM
 8201               	.LVL654:
2104:switcherator.c ****         clearEEPROM((LIMIT + (x * LIMIT_BYTES)));
 8202               		.loc 1 2104 0
 8203 2e3e 8AE6      		ldi r24,lo8(106)
 8204 2e40 90E0      		ldi r25,0
 8205 2e42 0E94 0000 		call clearEEPROM
 8206               	.LVL655:
 8207 2e46 8FE6      		ldi r24,lo8(111)
 8208 2e48 90E0      		ldi r25,0
 8209 2e4a 0E94 0000 		call clearEEPROM
 8210               	.LVL656:
 8211 2e4e 84E7      		ldi r24,lo8(116)
 8212 2e50 90E0      		ldi r25,0
 8213 2e52 0E94 0000 		call clearEEPROM
 8214               	.LVL657:
 8215 2e56 89E7      		ldi r24,lo8(121)
 8216 2e58 90E0      		ldi r25,0
 8217 2e5a 0E94 0000 		call clearEEPROM
 8218               	.LVL658:
2105:switcherator.c ****     clearEEPROM(PWM_VALUE);
 8219               		.loc 1 2105 0
 8220 2e5e 8EE7      		ldi r24,lo8(126)
 8221 2e60 90E0      		ldi r25,0
 8222 2e62 0E94 0000 		call clearEEPROM
 8223               	.LVL659:
2107:switcherator.c ****         clearEEPROM((COLOR_CHANGE + (x * COLOR_CHANGE_BYTES)));
 8224               		.loc 1 2107 0
 8225 2e66 83E8      		ldi r24,lo8(-125)
 8226 2e68 90E0      		ldi r25,0
 8227 2e6a 0E94 0000 		call clearEEPROM
 8228               	.LVL660:
 8229 2e6e 88E8      		ldi r24,lo8(-120)
 8230 2e70 90E0      		ldi r25,0
 8231 2e72 0E94 0000 		call clearEEPROM
 8232               	.LVL661:
 8233 2e76 8DE8      		ldi r24,lo8(-115)
 8234 2e78 90E0      		ldi r25,0
 8235 2e7a 0E94 0000 		call clearEEPROM
 8236               	.LVL662:
 8237 2e7e 82E9      		ldi r24,lo8(-110)
 8238 2e80 90E0      		ldi r25,0
 8239 2e82 0E94 0000 		call clearEEPROM
 8240               	.LVL663:
 8241 2e86 87E9      		ldi r24,lo8(-105)
 8242 2e88 90E0      		ldi r25,0
 8243 2e8a 0E94 0000 		call clearEEPROM
 8244               	.LVL664:
 8245 2e8e 8CE9      		ldi r24,lo8(-100)
 8246 2e90 90E0      		ldi r25,0
 8247 2e92 0E94 0000 		call clearEEPROM
 8248               	.LVL665:
 8249 2e96 C1EA      		ldi r28,lo8(-95)
 8250 2e98 D0E0      		ldi r29,0
 8251               	.LVL666:
 8252               	.L562:
2109:switcherator.c ****         clearEEPROM((WEEKLY_PROGRAM + (x * WEEKLY_PROGRAM_BYTES)));
 8253               		.loc 1 2109 0 discriminator 2
 8254 2e9a CE01      		movw r24,r28
 8255 2e9c 0E94 0000 		call clearEEPROM
 8256               	.LVL667:
 8257 2ea0 2C96      		adiw r28,12
2108:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++)
 8258               		.loc 1 2108 0 discriminator 2
 8259 2ea2 C931      		cpi r28,25
 8260 2ea4 81E0      		ldi r24,1
 8261 2ea6 D807      		cpc r29,r24
 8262 2ea8 01F4      		brne .L562
2110:switcherator.c ****     clearEEPROM(TWEAK_TIMER);
 8263               		.loc 1 2110 0
 8264 2eaa 89E1      		ldi r24,lo8(25)
 8265 2eac 91E0      		ldi r25,lo8(1)
 8266 2eae 0E94 0000 		call clearEEPROM
 8267               	.LVL668:
 8268               	/* epilogue start */
2112:switcherator.c **** }
 8269               		.loc 1 2112 0
 8270 2eb2 DF91      		pop r29
 8271 2eb4 CF91      		pop r28
2111:switcherator.c ****     ok();
 8272               		.loc 1 2111 0
 8273 2eb6 0C94 0000 		jmp ok
 8274               	.LVL669:
 8275               	.LFE46:
 8277               	.global	saveToEEPROM
 8279               	saveToEEPROM:
 8280               	.LFB45:
1953:switcherator.c **** void saveToEEPROM(void) {
 8281               		.loc 1 1953 0
 8282 2eba BF92      		push r11
 8283               	.LCFI198:
 8284 2ebc CF92      		push r12
 8285               	.LCFI199:
 8286 2ebe DF92      		push r13
 8287               	.LCFI200:
 8288 2ec0 EF92      		push r14
 8289               	.LCFI201:
 8290 2ec2 FF92      		push r15
 8291               	.LCFI202:
 8292 2ec4 0F93      		push r16
 8293               	.LCFI203:
 8294 2ec6 1F93      		push r17
 8295               	.LCFI204:
 8296 2ec8 CF93      		push r28
 8297               	.LCFI205:
 8298 2eca DF93      		push r29
 8299               	.LCFI206:
 8300 2ecc CDB7      		in r28,__SP_L__
 8301 2ece DEB7      		in r29,__SP_H__
 8302               	.LCFI207:
 8303 2ed0 2E97      		sbiw r28,14
 8304               	.LCFI208:
 8305 2ed2 0FB6      		in __tmp_reg__,__SREG__
 8306 2ed4 F894      		cli
 8307 2ed6 DEBF      		out __SP_H__,r29
 8308 2ed8 0FBE      		out __SREG__,__tmp_reg__
 8309 2eda CDBF      		out __SP_L__,r28
 8310               	/* prologue: function */
 8311               	/* frame size = 14 */
 8312               	/* stack size = 23 */
 8313               	.L__stack_usage = 23
 8314               	.LVL670:
1957:switcherator.c ****     if (tx_addr > 0) {
 8315               		.loc 1 1957 0
 8316 2edc B090 0000 		lds r11,tx_addr
 8317 2ee0 C090 0000 		lds r12,tx_addr+1
 8318 2ee4 D090 0000 		lds r13,tx_addr+2
 8319 2ee8 E090 0000 		lds r14,tx_addr+3
 8320 2eec F090 0000 		lds r15,tx_addr+4
 8321 2ef0 B091 0000 		lds r27,tx_addr+5
 8322 2ef4 F091 0000 		lds r31,tx_addr+6
 8323 2ef8 E091 0000 		lds r30,tx_addr+7
 8324 2efc 2B2D      		mov r18,r11
 8325 2efe 3C2D      		mov r19,r12
 8326 2f00 4D2D      		mov r20,r13
 8327 2f02 5E2D      		mov r21,r14
 8328 2f04 6F2D      		mov r22,r15
 8329 2f06 7B2F      		mov r23,r27
 8330 2f08 8F2F      		mov r24,r31
 8331 2f0a 9E2F      		mov r25,r30
 8332 2f0c A0E0      		ldi r26,0
 8333 2f0e 0E94 0000 		call __cmpdi2_s8
 8334 2f12 01F0      		breq .L565
1958:switcherator.c ****         unformatAddress(tx_addr, tempStuff);
 8335               		.loc 1 1958 0
 8336 2f14 8E01      		movw r16,r28
 8337 2f16 0F5F      		subi r16,-1
 8338 2f18 1F4F      		sbci r17,-1
 8339 2f1a 0E94 0000 		call unformatAddress
 8340               	.LVL671:
1959:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_TX, RADIO_ADDR_TX_BYTES);
 8341               		.loc 1 1959 0
 8342 2f1e 47E0      		ldi r20,lo8(7)
 8343 2f20 50E0      		ldi r21,0
 8344 2f22 6EE0      		ldi r22,lo8(14)
 8345 2f24 70E0      		ldi r23,0
 8346 2f26 C801      		movw r24,r16
 8347 2f28 0E94 0000 		call writeEEPROM
 8348               	.LVL672:
 8349               	.L565:
1961:switcherator.c ****     if (rx_addr_p0 > 0) {
 8350               		.loc 1 1961 0
 8351 2f2c B090 0000 		lds r11,rx_addr_p0
 8352 2f30 C090 0000 		lds r12,rx_addr_p0+1
 8353 2f34 D090 0000 		lds r13,rx_addr_p0+2
 8354 2f38 E090 0000 		lds r14,rx_addr_p0+3
 8355 2f3c F090 0000 		lds r15,rx_addr_p0+4
 8356 2f40 B091 0000 		lds r27,rx_addr_p0+5
 8357 2f44 F091 0000 		lds r31,rx_addr_p0+6
 8358 2f48 E091 0000 		lds r30,rx_addr_p0+7
 8359 2f4c 2B2D      		mov r18,r11
 8360 2f4e 3C2D      		mov r19,r12
 8361 2f50 4D2D      		mov r20,r13
 8362 2f52 5E2D      		mov r21,r14
 8363 2f54 6F2D      		mov r22,r15
 8364 2f56 7B2F      		mov r23,r27
 8365 2f58 8F2F      		mov r24,r31
 8366 2f5a 9E2F      		mov r25,r30
 8367 2f5c A0E0      		ldi r26,0
 8368 2f5e 0E94 0000 		call __cmpdi2_s8
 8369 2f62 01F0      		breq .L566
1962:switcherator.c ****         unformatAddress(rx_addr_p0, tempStuff);
 8370               		.loc 1 1962 0
 8371 2f64 8E01      		movw r16,r28
 8372 2f66 0F5F      		subi r16,-1
 8373 2f68 1F4F      		sbci r17,-1
 8374 2f6a 0E94 0000 		call unformatAddress
 8375               	.LVL673:
1963:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R0, RADIO_ADDR_R0_BYTES);
 8376               		.loc 1 1963 0
 8377 2f6e 47E0      		ldi r20,lo8(7)
 8378 2f70 50E0      		ldi r21,0
 8379 2f72 65E1      		ldi r22,lo8(21)
 8380 2f74 70E0      		ldi r23,0
 8381 2f76 C801      		movw r24,r16
 8382 2f78 0E94 0000 		call writeEEPROM
 8383               	.LVL674:
 8384               	.L566:
1965:switcherator.c ****     if (rx_addr_p1 > 0) {
 8385               		.loc 1 1965 0
 8386 2f7c B090 0000 		lds r11,rx_addr_p1
 8387 2f80 C090 0000 		lds r12,rx_addr_p1+1
 8388 2f84 D090 0000 		lds r13,rx_addr_p1+2
 8389 2f88 E090 0000 		lds r14,rx_addr_p1+3
 8390 2f8c F090 0000 		lds r15,rx_addr_p1+4
 8391 2f90 B091 0000 		lds r27,rx_addr_p1+5
 8392 2f94 F091 0000 		lds r31,rx_addr_p1+6
 8393 2f98 E091 0000 		lds r30,rx_addr_p1+7
 8394 2f9c 2B2D      		mov r18,r11
 8395 2f9e 3C2D      		mov r19,r12
 8396 2fa0 4D2D      		mov r20,r13
 8397 2fa2 5E2D      		mov r21,r14
 8398 2fa4 6F2D      		mov r22,r15
 8399 2fa6 7B2F      		mov r23,r27
 8400 2fa8 8F2F      		mov r24,r31
 8401 2faa 9E2F      		mov r25,r30
 8402 2fac A0E0      		ldi r26,0
 8403 2fae 0E94 0000 		call __cmpdi2_s8
 8404 2fb2 01F0      		breq .L567
1966:switcherator.c ****         unformatAddress(rx_addr_p1, tempStuff);
 8405               		.loc 1 1966 0
 8406 2fb4 8E01      		movw r16,r28
 8407 2fb6 0F5F      		subi r16,-1
 8408 2fb8 1F4F      		sbci r17,-1
 8409 2fba 0E94 0000 		call unformatAddress
 8410               	.LVL675:
1967:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R1, RADIO_ADDR_R1_BYTES);
 8411               		.loc 1 1967 0
 8412 2fbe 47E0      		ldi r20,lo8(7)
 8413 2fc0 50E0      		ldi r21,0
 8414 2fc2 6CE1      		ldi r22,lo8(28)
 8415 2fc4 70E0      		ldi r23,0
 8416 2fc6 C801      		movw r24,r16
 8417 2fc8 0E94 0000 		call writeEEPROM
 8418               	.LVL676:
 8419               	.L567:
1969:switcherator.c ****     if (rx_addr_p2 > 0) {
 8420               		.loc 1 1969 0
 8421 2fcc E091 0000 		lds r30,rx_addr_p2
 8422 2fd0 3091 0000 		lds r19,rx_addr_p2+1
 8423 2fd4 4091 0000 		lds r20,rx_addr_p2+2
 8424 2fd8 5091 0000 		lds r21,rx_addr_p2+3
 8425 2fdc 6091 0000 		lds r22,rx_addr_p2+4
 8426 2fe0 7091 0000 		lds r23,rx_addr_p2+5
 8427 2fe4 2E2F      		mov r18,r30
 8428 2fe6 8091 0000 		lds r24,rx_addr_p2+6
 8429 2fea 9091 0000 		lds r25,rx_addr_p2+7
 8430 2fee A0E0      		ldi r26,0
 8431 2ff0 0E94 0000 		call __cmpdi2_s8
 8432 2ff4 01F0      		breq .L568
1970:switcherator.c ****         tempStuff[0] = rx_addr_p2;
 8433               		.loc 1 1970 0
 8434 2ff6 E983      		std Y+1,r30
1971:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R2, RADIO_ADDR_R2_BYTES);
 8435               		.loc 1 1971 0
 8436 2ff8 43E0      		ldi r20,lo8(3)
 8437 2ffa 50E0      		ldi r21,0
 8438 2ffc 63E2      		ldi r22,lo8(35)
 8439 2ffe 70E0      		ldi r23,0
 8440 3000 CE01      		movw r24,r28
 8441 3002 0196      		adiw r24,1
 8442 3004 0E94 0000 		call writeEEPROM
 8443               	.LVL677:
 8444               	.L568:
1973:switcherator.c ****     if (rx_addr_p3 > 0) {
 8445               		.loc 1 1973 0
 8446 3008 E091 0000 		lds r30,rx_addr_p3
 8447 300c 3091 0000 		lds r19,rx_addr_p3+1
 8448 3010 4091 0000 		lds r20,rx_addr_p3+2
 8449 3014 5091 0000 		lds r21,rx_addr_p3+3
 8450 3018 6091 0000 		lds r22,rx_addr_p3+4
 8451 301c 7091 0000 		lds r23,rx_addr_p3+5
 8452 3020 2E2F      		mov r18,r30
 8453 3022 8091 0000 		lds r24,rx_addr_p3+6
 8454 3026 9091 0000 		lds r25,rx_addr_p3+7
 8455 302a A0E0      		ldi r26,0
 8456 302c 0E94 0000 		call __cmpdi2_s8
 8457 3030 01F0      		breq .L569
1974:switcherator.c ****         tempStuff[0] = rx_addr_p3;
 8458               		.loc 1 1974 0
 8459 3032 E983      		std Y+1,r30
1975:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R3, RADIO_ADDR_R3_BYTES);
 8460               		.loc 1 1975 0
 8461 3034 43E0      		ldi r20,lo8(3)
 8462 3036 50E0      		ldi r21,0
 8463 3038 66E2      		ldi r22,lo8(38)
 8464 303a 70E0      		ldi r23,0
 8465 303c CE01      		movw r24,r28
 8466 303e 0196      		adiw r24,1
 8467 3040 0E94 0000 		call writeEEPROM
 8468               	.LVL678:
 8469               	.L569:
1977:switcherator.c ****     if (rx_addr_p4 > 0) {
 8470               		.loc 1 1977 0
 8471 3044 E091 0000 		lds r30,rx_addr_p4
 8472 3048 3091 0000 		lds r19,rx_addr_p4+1
 8473 304c 4091 0000 		lds r20,rx_addr_p4+2
 8474 3050 5091 0000 		lds r21,rx_addr_p4+3
 8475 3054 6091 0000 		lds r22,rx_addr_p4+4
 8476 3058 7091 0000 		lds r23,rx_addr_p4+5
 8477 305c 2E2F      		mov r18,r30
 8478 305e 8091 0000 		lds r24,rx_addr_p4+6
 8479 3062 9091 0000 		lds r25,rx_addr_p4+7
 8480 3066 A0E0      		ldi r26,0
 8481 3068 0E94 0000 		call __cmpdi2_s8
 8482 306c 01F0      		breq .L570
1978:switcherator.c ****         tempStuff[0] = rx_addr_p4;
 8483               		.loc 1 1978 0
 8484 306e E983      		std Y+1,r30
1979:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R4, RADIO_ADDR_R4_BYTES);
 8485               		.loc 1 1979 0
 8486 3070 43E0      		ldi r20,lo8(3)
 8487 3072 50E0      		ldi r21,0
 8488 3074 69E2      		ldi r22,lo8(41)
 8489 3076 70E0      		ldi r23,0
 8490 3078 CE01      		movw r24,r28
 8491 307a 0196      		adiw r24,1
 8492 307c 0E94 0000 		call writeEEPROM
 8493               	.LVL679:
 8494               	.L570:
1981:switcherator.c ****     if (rx_addr_p5 > 0) {
 8495               		.loc 1 1981 0
 8496 3080 E091 0000 		lds r30,rx_addr_p5
 8497 3084 3091 0000 		lds r19,rx_addr_p5+1
 8498 3088 4091 0000 		lds r20,rx_addr_p5+2
 8499 308c 5091 0000 		lds r21,rx_addr_p5+3
 8500 3090 6091 0000 		lds r22,rx_addr_p5+4
 8501 3094 7091 0000 		lds r23,rx_addr_p5+5
 8502 3098 2E2F      		mov r18,r30
 8503 309a 8091 0000 		lds r24,rx_addr_p5+6
 8504 309e 9091 0000 		lds r25,rx_addr_p5+7
 8505 30a2 A0E0      		ldi r26,0
 8506 30a4 0E94 0000 		call __cmpdi2_s8
 8507 30a8 01F0      		breq .L571
1982:switcherator.c ****         tempStuff[0] = rx_addr_p5;
 8508               		.loc 1 1982 0
 8509 30aa E983      		std Y+1,r30
1983:switcherator.c ****         writeEEPROM(tempStuff, RADIO_ADDR_R5, RADIO_ADDR_R5_BYTES);
 8510               		.loc 1 1983 0
 8511 30ac 43E0      		ldi r20,lo8(3)
 8512 30ae 50E0      		ldi r21,0
 8513 30b0 6CE2      		ldi r22,lo8(44)
 8514 30b2 70E0      		ldi r23,0
 8515 30b4 CE01      		movw r24,r28
 8516 30b6 0196      		adiw r24,1
 8517 30b8 0E94 0000 		call writeEEPROM
 8518               	.LVL680:
 8519               	.L571:
1986:switcherator.c ****     if (tweakTimer != 0) {
 8520               		.loc 1 1986 0
 8521 30bc 8091 0000 		lds r24,tweakTimer
 8522 30c0 9091 0000 		lds r25,tweakTimer+1
 8523 30c4 A091 0000 		lds r26,tweakTimer+2
 8524 30c8 B091 0000 		lds r27,tweakTimer+3
 8525 30cc 0097      		sbiw r24,0
 8526 30ce A105      		cpc r26,__zero_reg__
 8527 30d0 B105      		cpc r27,__zero_reg__
 8528 30d2 01F0      		breq .L572
1987:switcherator.c ****         tempStuff[0] = tweakTimer >> 8;
 8529               		.loc 1 1987 0
 8530 30d4 9983      		std Y+1,r25
1988:switcherator.c ****         tempStuff[1] = (tweakTimer & 0xff);
 8531               		.loc 1 1988 0
 8532 30d6 8A83      		std Y+2,r24
1989:switcherator.c ****         writeEEPROM(tempStuff, TWEAK_TIMER, TWEAK_TIMER_BYTES);
 8533               		.loc 1 1989 0
 8534 30d8 44E0      		ldi r20,lo8(4)
 8535 30da 50E0      		ldi r21,0
 8536 30dc 69E1      		ldi r22,lo8(25)
 8537 30de 71E0      		ldi r23,lo8(1)
 8538 30e0 CE01      		movw r24,r28
 8539 30e2 0196      		adiw r24,1
 8540 30e4 0E94 0000 		call writeEEPROM
 8541               	.LVL681:
 8542               	.L572:
1994:switcherator.c ****     if (daylightSavings[0][0] > 0) {
 8543               		.loc 1 1994 0
 8544 30e8 8091 0000 		lds r24,daylightSavings
 8545 30ec 9091 0000 		lds r25,daylightSavings+1
 8546 30f0 0097      		sbiw r24,0
 8547 30f2 01F0      		breq .L573
1995:switcherator.c ****         tempStuff[0] = (daylightSavings[0][0] >> 8);
 8548               		.loc 1 1995 0
 8549 30f4 9983      		std Y+1,r25
1996:switcherator.c ****         tempStuff[1] = (daylightSavings[0][0] & 0xff);
 8550               		.loc 1 1996 0
 8551 30f6 8A83      		std Y+2,r24
1997:switcherator.c ****         tempStuff[2] = (daylightSavings[0][1] >> 8);
 8552               		.loc 1 1997 0
 8553 30f8 8091 0000 		lds r24,daylightSavings+2
 8554 30fc 9091 0000 		lds r25,daylightSavings+3
 8555 3100 9B83      		std Y+3,r25
1998:switcherator.c ****         tempStuff[3] = (daylightSavings[0][1] & 0xff);
 8556               		.loc 1 1998 0
 8557 3102 8C83      		std Y+4,r24
1999:switcherator.c ****         tempStuff[4] = (daylightSavings[1][0] >> 8);
 8558               		.loc 1 1999 0
 8559 3104 8091 0000 		lds r24,daylightSavings+4
 8560 3108 9091 0000 		lds r25,daylightSavings+5
 8561 310c 9D83      		std Y+5,r25
2000:switcherator.c ****         tempStuff[5] = (daylightSavings[1][0] & 0xff);
 8562               		.loc 1 2000 0
 8563 310e 8E83      		std Y+6,r24
2001:switcherator.c ****         tempStuff[6] = (daylightSavings[1][1] >> 8);
 8564               		.loc 1 2001 0
 8565 3110 8091 0000 		lds r24,daylightSavings+6
 8566 3114 9091 0000 		lds r25,daylightSavings+7
 8567 3118 9F83      		std Y+7,r25
2002:switcherator.c ****         tempStuff[7] = (daylightSavings[1][1] & 0xff);
 8568               		.loc 1 2002 0
 8569 311a 8887      		std Y+8,r24
2003:switcherator.c ****         writeEEPROM(tempStuff, DAYLIGHT_SAVE, DAYLIGHT_SAVE_BYTES);
 8570               		.loc 1 2003 0
 8571 311c 4AE0      		ldi r20,lo8(10)
 8572 311e 50E0      		ldi r21,0
 8573 3120 66E0      		ldi r22,lo8(6)
 8574 3122 70E0      		ldi r23,0
 8575 3124 CE01      		movw r24,r28
 8576 3126 0196      		adiw r24,1
 8577 3128 0E94 0000 		call writeEEPROM
 8578               	.LVL682:
 8579               	.L573:
2005:switcherator.c ****     if (serial > 0) {
 8580               		.loc 1 2005 0
 8581 312c 6091 0000 		lds r22,serial
 8582 3130 7091 0000 		lds r23,serial+1
 8583 3134 8091 0000 		lds r24,serial+2
 8584 3138 9091 0000 		lds r25,serial+3
 8585 313c 1616      		cp __zero_reg__,r22
 8586 313e 1706      		cpc __zero_reg__,r23
 8587 3140 1806      		cpc __zero_reg__,r24
 8588 3142 1906      		cpc __zero_reg__,r25
 8589 3144 04F4      		brge .L574
2006:switcherator.c ****         ltoa(serial, tempStuff, 10);
 8590               		.loc 1 2006 0
 8591 3146 2AE0      		ldi r18,lo8(10)
 8592 3148 30E0      		ldi r19,0
 8593 314a AE01      		movw r20,r28
 8594 314c 4F5F      		subi r20,-1
 8595 314e 5F4F      		sbci r21,-1
 8596 3150 0E94 0000 		call ltoa
 8597               	.LVL683:
2007:switcherator.c ****         writeEEPROM(tempStuff, SERIAL_NUM, SERIAL_NUM_BYTES);
 8598               		.loc 1 2007 0
 8599 3154 48E0      		ldi r20,lo8(8)
 8600 3156 50E0      		ldi r21,0
 8601 3158 60E0      		ldi r22,0
 8602 315a 70E0      		ldi r23,0
 8603 315c CE01      		movw r24,r28
 8604 315e 0196      		adiw r24,1
 8605 3160 0E94 0000 		call writeEEPROM
 8606               	.LVL684:
 8607               	.L574:
 8608 3164 E0E0      		ldi r30,lo8(switchStuff)
 8609 3166 F0E0      		ldi r31,hi8(switchStuff)
2010:switcherator.c ****     char setupPWM = 0;
 8610               		.loc 1 2010 0
 8611 3168 10E0      		ldi r17,0
2009:switcherator.c ****     char setupaSwitch = 0;
 8612               		.loc 1 2009 0
 8613 316a 80E0      		ldi r24,0
 8614               	.LVL685:
 8615               	.L577:
2013:switcherator.c ****         if (switchStuff[x] < 255)
 8616               		.loc 1 2013 0
 8617 316c 9191      		ld r25,Z+
 8618 316e 9F3F      		cpi r25,lo8(-1)
 8619 3170 01F0      		breq .L575
2014:switcherator.c ****             setupaSwitch = 1;
 8620               		.loc 1 2014 0
 8621 3172 81E0      		ldi r24,lo8(1)
 8622               	.L575:
 8623               	.LVL686:
2015:switcherator.c ****         if (switchStuff[x] >= 200 && switchStuff[x] <= 230)
 8624               		.loc 1 2015 0
 8625 3174 985C      		subi r25,lo8(-(56))
 8626 3176 9F31      		cpi r25,lo8(31)
 8627 3178 00F4      		brsh .L576
2016:switcherator.c ****             setupPWM = 1;
 8628               		.loc 1 2016 0
 8629 317a 11E0      		ldi r17,lo8(1)
 8630               	.L576:
 8631               	.LVL687:
2012:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 8632               		.loc 1 2012 0
 8633 317c 90E0      		ldi r25,hi8(switchStuff+16)
 8634 317e E030      		cpi r30,lo8(switchStuff+16)
 8635 3180 F907      		cpc r31,r25
 8636 3182 01F4      		brne .L577
2018:switcherator.c ****     if (setupaSwitch == 1) {
 8637               		.loc 1 2018 0
 8638 3184 8130      		cpi r24,lo8(1)
 8639 3186 01F4      		brne .L578
2019:switcherator.c ****         writeEEPROM(switchStuff, SWITCH_STUFF, SWITCH_STUFF_BYTES);
 8640               		.loc 1 2019 0
 8641 3188 42E1      		ldi r20,lo8(18)
 8642 318a 50E0      		ldi r21,0
 8643 318c 60E3      		ldi r22,lo8(48)
 8644 318e 70E0      		ldi r23,0
 8645 3190 80E0      		ldi r24,lo8(switchStuff)
 8646 3192 90E0      		ldi r25,hi8(switchStuff)
 8647               	.LVL688:
 8648 3194 0E94 0000 		call writeEEPROM
 8649               	.LVL689:
2020:switcherator.c ****         writeEEPROM(switchBright, BRIGHTNESS, BRIGHTNESS_BYTES);
 8650               		.loc 1 2020 0
 8651 3198 42E1      		ldi r20,lo8(18)
 8652 319a 50E0      		ldi r21,0
 8653 319c 60E2      		ldi r22,lo8(32)
 8654 319e 71E0      		ldi r23,lo8(1)
 8655 31a0 80E0      		ldi r24,lo8(switchBright)
 8656 31a2 90E0      		ldi r25,hi8(switchBright)
 8657 31a4 0E94 0000 		call writeEEPROM
 8658               	.LVL690:
 8659               	.L578:
2022:switcherator.c ****     tempStuff[0] = pwmdir;
 8660               		.loc 1 2022 0
 8661 31a8 8091 0000 		lds r24,pwmdir
 8662 31ac 8983      		std Y+1,r24
2023:switcherator.c ****     if (setupPWM == 1)
 8663               		.loc 1 2023 0
 8664 31ae 1130      		cpi r17,lo8(1)
 8665 31b0 01F4      		brne .L579
2024:switcherator.c ****         writeEEPROM(tempStuff, PWM_DIR, PWM_DIR_BYTES);
 8666               		.loc 1 2024 0
 8667 31b2 43E0      		ldi r20,lo8(3)
 8668 31b4 50E0      		ldi r21,0
 8669 31b6 6DE1      		ldi r22,lo8(29)
 8670 31b8 71E0      		ldi r23,lo8(1)
 8671 31ba CE01      		movw r24,r28
 8672 31bc 0196      		adiw r24,1
 8673 31be 0E94 0000 		call writeEEPROM
 8674               	.LVL691:
 8675               	.L579:
 8676 31c2 00E0      		ldi r16,lo8(weeklyProgram)
 8677 31c4 E02E      		mov r14,r16
 8678 31c6 00E0      		ldi r16,hi8(weeklyProgram)
 8679 31c8 F02E      		mov r15,r16
 8680 31ca 80E0      		ldi r24,lo8(weeklyProgram+1)
 8681 31cc C82E      		mov r12,r24
 8682 31ce 80E0      		ldi r24,hi8(weeklyProgram+1)
 8683 31d0 D82E      		mov r13,r24
2016:switcherator.c ****             setupPWM = 1;
 8684               		.loc 1 2016 0 discriminator 1
 8685 31d2 01EA      		ldi r16,lo8(-95)
 8686 31d4 10E0      		ldi r17,0
 8687               	.LVL692:
 8688               	.L583:
2034:switcherator.c ****         memoryMarker = (WEEKLY_PROGRAM + (x * WEEKLY_PROGRAM_BYTES));
 8689               		.loc 1 2034 0
 8690 31d6 B801      		movw r22,r16
 8691               	.LVL693:
2035:switcherator.c ****         if (weeklyProgram[x][0] != 255 || weeklyProgram[x][1] != 255) {
 8692               		.loc 1 2035 0
 8693 31d8 F701      		movw r30,r14
 8694 31da 8081      		ld r24,Z
 8695 31dc 8F3F      		cpi r24,lo8(-1)
 8696 31de 01F4      		brne .L580
2035:switcherator.c ****         if (weeklyProgram[x][0] != 255 || weeklyProgram[x][1] != 255) {
 8697               		.loc 1 2035 0 is_stmt 0 discriminator 1
 8698 31e0 F601      		movw r30,r12
 8699 31e2 8081      		ld r24,Z
 8700 31e4 8F3F      		cpi r24,lo8(-1)
 8701 31e6 01F0      		breq .L581
 8702               	.L580:
 8703 31e8 FE01      		movw r30,r28
 8704 31ea 3196      		adiw r30,1
2016:switcherator.c ****             setupPWM = 1;
 8705               		.loc 1 2016 0 is_stmt 1 discriminator 2
 8706 31ec 80E0      		ldi r24,0
 8707 31ee 90E0      		ldi r25,0
 8708               	.L582:
1953:switcherator.c **** void saveToEEPROM(void) {
 8709               		.loc 1 1953 0 discriminator 2
 8710 31f0 D701      		movw r26,r14
 8711 31f2 A80F      		add r26,r24
 8712 31f4 B91F      		adc r27,r25
2037:switcherator.c ****                 tempStuff[y] = weeklyProgram[x][y];
 8713               		.loc 1 2037 0 discriminator 2
 8714 31f6 2C91      		ld r18,X
 8715 31f8 2193      		st Z+,r18
2036:switcherator.c ****             for (y = 0; y < 10; y++)
 8716               		.loc 1 2036 0 discriminator 2
 8717 31fa 0196      		adiw r24,1
 8718               	.LVL694:
 8719 31fc 8A30      		cpi r24,10
 8720 31fe 9105      		cpc r25,__zero_reg__
 8721 3200 01F4      		brne .L582
2038:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, WEEKLY_PROGRAM_BYTES);
 8722               		.loc 1 2038 0
 8723 3202 4CE0      		ldi r20,lo8(12)
 8724 3204 50E0      		ldi r21,0
 8725 3206 CE01      		movw r24,r28
 8726               	.LVL695:
 8727 3208 0196      		adiw r24,1
 8728 320a 0E94 0000 		call writeEEPROM
 8729               	.LVL696:
 8730               	.L581:
 8731 320e FAE0      		ldi r31,10
 8732 3210 EF0E      		add r14,r31
 8733 3212 F11C      		adc r15,__zero_reg__
 8734 3214 8AE0      		ldi r24,10
 8735 3216 C80E      		add r12,r24
 8736 3218 D11C      		adc r13,__zero_reg__
 8737 321a 045F      		subi r16,-12
 8738 321c 1F4F      		sbci r17,-1
2033:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 8739               		.loc 1 2033 0
 8740 321e 0931      		cpi r16,25
 8741 3220 91E0      		ldi r25,1
 8742 3222 1907      		cpc r17,r25
 8743 3224 01F4      		brne .L583
 8744 3226 10E0      		ldi r17,lo8(inputs)
 8745 3228 E12E      		mov r14,r17
 8746 322a 10E0      		ldi r17,hi8(inputs)
 8747 322c F12E      		mov r15,r17
 8748               	.LVL697:
 8749 322e 02E4      		ldi r16,lo8(66)
 8750 3230 10E0      		ldi r17,0
 8751               	.L586:
2045:switcherator.c ****         if (inputs[x][0] != 255) {
 8752               		.loc 1 2045 0
 8753 3232 F701      		movw r30,r14
 8754 3234 8081      		ld r24,Z
 8755 3236 8F3F      		cpi r24,lo8(-1)
 8756 3238 01F0      		breq .L584
 8757 323a FE01      		movw r30,r28
 8758 323c 3196      		adiw r30,1
 8759 323e 80E0      		ldi r24,0
 8760 3240 90E0      		ldi r25,0
 8761               	.L585:
1953:switcherator.c **** void saveToEEPROM(void) {
 8762               		.loc 1 1953 0 discriminator 2
 8763 3242 D701      		movw r26,r14
 8764 3244 A80F      		add r26,r24
 8765 3246 B91F      		adc r27,r25
2047:switcherator.c ****                 tempStuff[y] = inputs[x][y];
 8766               		.loc 1 2047 0 discriminator 2
 8767 3248 2C91      		ld r18,X
 8768 324a 2193      		st Z+,r18
2046:switcherator.c ****             for (y = 0; y < 8; y++) {
 8769               		.loc 1 2046 0 discriminator 2
 8770 324c 0196      		adiw r24,1
 8771               	.LVL698:
 8772 324e 8830      		cpi r24,8
 8773 3250 9105      		cpc r25,__zero_reg__
 8774 3252 01F4      		brne .L585
2049:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, INPUT_BYTES);
 8775               		.loc 1 2049 0
 8776 3254 4AE0      		ldi r20,lo8(10)
 8777 3256 50E0      		ldi r21,0
 8778 3258 B801      		movw r22,r16
 8779 325a CE01      		movw r24,r28
 8780               	.LVL699:
 8781 325c 0196      		adiw r24,1
 8782 325e 0E94 0000 		call writeEEPROM
 8783               	.LVL700:
 8784               	.L584:
 8785 3262 F8E0      		ldi r31,8
 8786 3264 EF0E      		add r14,r31
 8787 3266 F11C      		adc r15,__zero_reg__
 8788 3268 065F      		subi r16,-10
 8789 326a 1F4F      		sbci r17,-1
2043:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 8790               		.loc 1 2043 0
 8791 326c 0A36      		cpi r16,106
 8792 326e 1105      		cpc r17,__zero_reg__
 8793 3270 01F4      		brne .L586
 8794 3272 00E0      		ldi r16,lo8(timeLimits)
 8795 3274 10E0      		ldi r17,hi8(timeLimits)
 8796 3276 BAE6      		ldi r27,lo8(106)
 8797 3278 EB2E      		mov r14,r27
 8798 327a F12C      		mov r15,__zero_reg__
 8799               	.L588:
2056:switcherator.c ****         if (timeLimits[x][2] > 0) {
 8800               		.loc 1 2056 0
 8801 327c F801      		movw r30,r16
 8802 327e 8085      		ldd r24,Z+8
 8803 3280 9185      		ldd r25,Z+9
 8804 3282 A285      		ldd r26,Z+10
 8805 3284 B385      		ldd r27,Z+11
 8806 3286 0097      		sbiw r24,0
 8807 3288 A105      		cpc r26,__zero_reg__
 8808 328a B105      		cpc r27,__zero_reg__
 8809 328c 01F0      		breq .L587
 8810               	.LVL701:
2058:switcherator.c ****                 tempStuff[y] = timeLimits[x][y];
 8811               		.loc 1 2058 0 discriminator 1
 8812 328e 2081      		ld r18,Z
 8813 3290 2983      		std Y+1,r18
 8814               	.LVL702:
 8815 3292 2481      		ldd r18,Z+4
 8816 3294 2A83      		std Y+2,r18
 8817               	.LVL703:
 8818 3296 8B83      		std Y+3,r24
 8819               	.LVL704:
2060:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, INPUT_BYTES);
 8820               		.loc 1 2060 0 discriminator 1
 8821 3298 4AE0      		ldi r20,lo8(10)
 8822 329a 50E0      		ldi r21,0
 8823 329c B701      		movw r22,r14
 8824 329e CE01      		movw r24,r28
 8825 32a0 0196      		adiw r24,1
 8826 32a2 0E94 0000 		call writeEEPROM
 8827               	.LVL705:
 8828               	.L587:
 8829 32a6 045F      		subi r16,-12
 8830 32a8 1F4F      		sbci r17,-1
 8831 32aa F5E0      		ldi r31,5
 8832 32ac EF0E      		add r14,r31
 8833 32ae F11C      		adc r15,__zero_reg__
2054:switcherator.c ****     for (x = 0; x < NUM_LIMITS; x++) {
 8834               		.loc 1 2054 0
 8835 32b0 8EE7      		ldi r24,126
 8836 32b2 E816      		cp r14,r24
 8837 32b4 F104      		cpc r15,__zero_reg__
 8838 32b6 01F4      		brne .L588
 8839               	.LVL706:
2067:switcherator.c ****     if (pwmValues[0] != 0 || pwmValues[1] != 0 || pwmValues[2] != 0) {
 8840               		.loc 1 2067 0
 8841 32b8 8091 0000 		lds r24,pwmValues
 8842 32bc 8111      		cpse r24,__zero_reg__
 8843 32be 00C0      		rjmp .L589
2067:switcherator.c ****     if (pwmValues[0] != 0 || pwmValues[1] != 0 || pwmValues[2] != 0) {
 8844               		.loc 1 2067 0 is_stmt 0 discriminator 1
 8845 32c0 9091 0000 		lds r25,pwmValues+1
 8846 32c4 9923      		tst r25
 8847 32c6 01F0      		breq .L590
 8848               	.L589:
 8849               	.LVL707:
2069:switcherator.c ****             tempStuff[y] = pwmValues[y];
 8850               		.loc 1 2069 0 is_stmt 1 discriminator 1
 8851 32c8 8983      		std Y+1,r24
 8852               	.LVL708:
 8853 32ca 8091 0000 		lds r24,pwmValues+1
 8854 32ce 8A83      		std Y+2,r24
 8855               	.LVL709:
 8856 32d0 8091 0000 		lds r24,pwmValues+2
 8857 32d4 8B83      		std Y+3,r24
 8858               	.LVL710:
2071:switcherator.c ****         writeEEPROM(tempStuff, memoryMarker, PWM_VALUE_BYTES);
 8859               		.loc 1 2071 0 discriminator 1
 8860 32d6 45E0      		ldi r20,lo8(5)
 8861 32d8 50E0      		ldi r21,0
 8862 32da 6EE7      		ldi r22,lo8(126)
 8863 32dc 70E0      		ldi r23,0
 8864 32de CE01      		movw r24,r28
 8865 32e0 0196      		adiw r24,1
 8866 32e2 0E94 0000 		call writeEEPROM
 8867               	.LVL711:
 8868               	.L592:
 8869 32e6 A0E0      		ldi r26,lo8(inputs+2)
 8870 32e8 EA2E      		mov r14,r26
 8871 32ea A0E0      		ldi r26,hi8(inputs+2)
 8872 32ec FA2E      		mov r15,r26
2043:switcherator.c ****     for (x = 0; x < NUM_INPUTS; x++) {
 8873               		.loc 1 2043 0 discriminator 1
 8874 32ee 03E8      		ldi r16,lo8(-125)
 8875 32f0 10E0      		ldi r17,0
 8876 32f2 00C0      		rjmp .L591
 8877               	.LVL712:
 8878               	.L590:
2067:switcherator.c ****     if (pwmValues[0] != 0 || pwmValues[1] != 0 || pwmValues[2] != 0) {
 8879               		.loc 1 2067 0 discriminator 1
 8880 32f4 9091 0000 		lds r25,pwmValues+2
 8881 32f8 9111      		cpse r25,__zero_reg__
 8882 32fa 00C0      		rjmp .L589
 8883 32fc 00C0      		rjmp .L592
 8884               	.LVL713:
 8885               	.L591:
2076:switcherator.c ****         memoryMarker = (COLOR_CHANGE + (x * COLOR_CHANGE_BYTES));
 8886               		.loc 1 2076 0
 8887 32fe B801      		movw r22,r16
 8888               	.LVL714:
2077:switcherator.c ****         if (colorChanges[0][0] != 0 || colorChanges[0][1] != 1 || colorChanges[0][2] != 0) {
 8889               		.loc 1 2077 0
 8890 3300 8091 0000 		lds r24,colorChanges
 8891 3304 8111      		cpse r24,__zero_reg__
 8892 3306 00C0      		rjmp .L593
2077:switcherator.c ****         if (colorChanges[0][0] != 0 || colorChanges[0][1] != 1 || colorChanges[0][2] != 0) {
 8893               		.loc 1 2077 0 is_stmt 0 discriminator 1
 8894 3308 8091 0000 		lds r24,colorChanges+1
 8895 330c 8130      		cpi r24,lo8(1)
 8896 330e 01F0      		breq .L594
 8897               	.L593:
 8898               	.LVL715:
1953:switcherator.c **** void saveToEEPROM(void) {
 8899               		.loc 1 1953 0 is_stmt 1 discriminator 1
 8900 3310 F701      		movw r30,r14
 8901 3312 3297      		sbiw r30,2
2079:switcherator.c ****                 tempStuff[y] = inputs[x][y];
 8902               		.loc 1 2079 0 discriminator 1
 8903 3314 8081      		ld r24,Z
 8904 3316 8983      		std Y+1,r24
 8905               	.LVL716:
1953:switcherator.c **** void saveToEEPROM(void) {
 8906               		.loc 1 1953 0 discriminator 1
 8907 3318 F701      		movw r30,r14
 8908 331a 3197      		sbiw r30,1
2079:switcherator.c ****                 tempStuff[y] = inputs[x][y];
 8909               		.loc 1 2079 0 discriminator 1
 8910 331c 8081      		ld r24,Z
 8911 331e 8A83      		std Y+2,r24
 8912               	.LVL717:
 8913 3320 F701      		movw r30,r14
 8914 3322 8081      		ld r24,Z
 8915 3324 8B83      		std Y+3,r24
 8916               	.LVL718:
2081:switcherator.c ****             writeEEPROM(tempStuff, memoryMarker, COLOR_CHANGE_BYTES);
 8917               		.loc 1 2081 0 discriminator 1
 8918 3326 45E0      		ldi r20,lo8(5)
 8919 3328 50E0      		ldi r21,0
 8920 332a CE01      		movw r24,r28
 8921 332c 0196      		adiw r24,1
 8922 332e 0E94 0000 		call writeEEPROM
 8923               	.LVL719:
 8924 3332 00C0      		rjmp .L595
 8925               	.LVL720:
 8926               	.L594:
2077:switcherator.c ****         if (colorChanges[0][0] != 0 || colorChanges[0][1] != 1 || colorChanges[0][2] != 0) {
 8927               		.loc 1 2077 0 discriminator 1
 8928 3334 8091 0000 		lds r24,colorChanges+2
 8929 3338 8111      		cpse r24,__zero_reg__
 8930 333a 00C0      		rjmp .L593
 8931               	.LVL721:
 8932               	.L595:
 8933 333c F8E0      		ldi r31,8
 8934 333e EF0E      		add r14,r31
 8935 3340 F11C      		adc r15,__zero_reg__
 8936 3342 0B5F      		subi r16,-5
 8937 3344 1F4F      		sbci r17,-1
2075:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 8938               		.loc 1 2075 0
 8939 3346 013A      		cpi r16,-95
 8940 3348 1105      		cpc r17,__zero_reg__
 8941 334a 01F4      		brne .L591
2084:switcherator.c ****     ok();
 8942               		.loc 1 2084 0
 8943 334c 0E94 0000 		call ok
 8944               	.LVL722:
 8945               	/* epilogue start */
2085:switcherator.c **** }
 8946               		.loc 1 2085 0
 8947 3350 2E96      		adiw r28,14
 8948 3352 0FB6      		in __tmp_reg__,__SREG__
 8949 3354 F894      		cli
 8950 3356 DEBF      		out __SP_H__,r29
 8951 3358 0FBE      		out __SREG__,__tmp_reg__
 8952 335a CDBF      		out __SP_L__,r28
 8953 335c DF91      		pop r29
 8954 335e CF91      		pop r28
 8955 3360 1F91      		pop r17
 8956 3362 0F91      		pop r16
 8957 3364 FF90      		pop r15
 8958 3366 EF90      		pop r14
 8959 3368 DF90      		pop r13
 8960 336a CF90      		pop r12
 8961 336c BF90      		pop r11
 8962 336e 0895      		ret
 8963               	.LFE45:
 8965               	.global	pwmValueSet
 8967               	pwmValueSet:
 8968               	.LFB24:
 967:switcherator.c **** void pwmValueSet(char * commandReceived) {
 8969               		.loc 1 967 0
 8970               	.LVL723:
 8971 3370 CF92      		push r12
 8972               	.LCFI209:
 8973 3372 DF92      		push r13
 8974               	.LCFI210:
 8975 3374 EF92      		push r14
 8976               	.LCFI211:
 8977 3376 FF92      		push r15
 8978               	.LCFI212:
 8979 3378 0F93      		push r16
 8980               	.LCFI213:
 8981 337a 1F93      		push r17
 8982               	.LCFI214:
 8983 337c CF93      		push r28
 8984               	.LCFI215:
 8985 337e DF93      		push r29
 8986               	.LCFI216:
 8987               	/* prologue: function */
 8988               	/* frame size = 0 */
 8989               	/* stack size = 8 */
 8990               	.L__stack_usage = 8
 8991 3380 EC01      		movw r28,r24
 968:switcherator.c ****     tempLongString[3] = 0;
 8992               		.loc 1 968 0
 8993 3382 1092 0000 		sts tempLongString+3,__zero_reg__
 969:switcherator.c ****     tempLongString[0] = commandReceived[6];
 8994               		.loc 1 969 0
 8995 3386 90E0      		ldi r25,lo8(tempLongString)
 8996 3388 C92E      		mov r12,r25
 8997 338a 90E0      		ldi r25,hi8(tempLongString)
 8998 338c D92E      		mov r13,r25
 8999 338e 8E81      		ldd r24,Y+6
 9000               	.LVL724:
 9001 3390 F601      		movw r30,r12
 9002 3392 8083      		st Z,r24
 970:switcherator.c ****     tempLongString[1] = commandReceived[7];
 9003               		.loc 1 970 0
 9004 3394 20E0      		ldi r18,lo8(tempLongString+1)
 9005 3396 E22E      		mov r14,r18
 9006 3398 20E0      		ldi r18,hi8(tempLongString+1)
 9007 339a F22E      		mov r15,r18
 9008 339c 8F81      		ldd r24,Y+7
 9009 339e F701      		movw r30,r14
 9010 33a0 8083      		st Z,r24
 971:switcherator.c ****     tempLongString[2] = commandReceived[8];
 9011               		.loc 1 971 0
 9012 33a2 00E0      		ldi r16,lo8(tempLongString+2)
 9013 33a4 10E0      		ldi r17,hi8(tempLongString+2)
 9014 33a6 8885      		ldd r24,Y+8
 9015 33a8 F801      		movw r30,r16
 9016 33aa 8083      		st Z,r24
 972:switcherator.c ****     pwmValues[0] = atoi(tempLongString);
 9017               		.loc 1 972 0
 9018 33ac C601      		movw r24,r12
 9019 33ae 0E94 0000 		call atoi
 9020               	.LVL725:
 9021 33b2 8093 0000 		sts pwmValues,r24
 973:switcherator.c ****     tempLongString[0] = commandReceived[10];
 9022               		.loc 1 973 0
 9023 33b6 8A85      		ldd r24,Y+10
 9024 33b8 F601      		movw r30,r12
 9025 33ba 8083      		st Z,r24
 974:switcherator.c ****     tempLongString[1] = commandReceived[11];
 9026               		.loc 1 974 0
 9027 33bc 8B85      		ldd r24,Y+11
 9028 33be F701      		movw r30,r14
 9029 33c0 8083      		st Z,r24
 975:switcherator.c ****     tempLongString[2] = commandReceived[12];
 9030               		.loc 1 975 0
 9031 33c2 8C85      		ldd r24,Y+12
 9032 33c4 F801      		movw r30,r16
 9033 33c6 8083      		st Z,r24
 976:switcherator.c ****     pwmValues[1] = atoi(tempLongString);
 9034               		.loc 1 976 0
 9035 33c8 C601      		movw r24,r12
 9036 33ca 0E94 0000 		call atoi
 9037               	.LVL726:
 9038 33ce 8093 0000 		sts pwmValues+1,r24
 977:switcherator.c ****     tempLongString[0] = commandReceived[14];
 9039               		.loc 1 977 0
 9040 33d2 8E85      		ldd r24,Y+14
 9041 33d4 F601      		movw r30,r12
 9042 33d6 8083      		st Z,r24
 978:switcherator.c ****     tempLongString[1] = commandReceived[15];
 9043               		.loc 1 978 0
 9044 33d8 8F85      		ldd r24,Y+15
 9045 33da F701      		movw r30,r14
 9046 33dc 8083      		st Z,r24
 979:switcherator.c ****     tempLongString[2] = commandReceived[16];
 9047               		.loc 1 979 0
 9048 33de 8889      		ldd r24,Y+16
 9049 33e0 F801      		movw r30,r16
 9050 33e2 8083      		st Z,r24
 980:switcherator.c ****     pwmValues[2] = atoi(tempLongString);
 9051               		.loc 1 980 0
 9052 33e4 C601      		movw r24,r12
 9053 33e6 0E94 0000 		call atoi
 9054               	.LVL727:
 9055 33ea 8093 0000 		sts pwmValues+2,r24
 981:switcherator.c ****     statusMsg[0] = 0;
 9056               		.loc 1 981 0
 9057 33ee 1092 0000 		sts statusMsg,__zero_reg__
 9058               	/* epilogue start */
 983:switcherator.c **** }
 9059               		.loc 1 983 0
 9060 33f2 DF91      		pop r29
 9061 33f4 CF91      		pop r28
 9062               	.LVL728:
 9063 33f6 1F91      		pop r17
 9064 33f8 0F91      		pop r16
 9065 33fa FF90      		pop r15
 9066 33fc EF90      		pop r14
 9067 33fe DF90      		pop r13
 9068 3400 CF90      		pop r12
 982:switcherator.c ****     ok();
 9069               		.loc 1 982 0
 9070 3402 0C94 0000 		jmp ok
 9071               	.LVL729:
 9072               	.LFE24:
 9074               	.global	setHueSpeed
 9076               	setHueSpeed:
 9077               	.LFB23:
 952:switcherator.c **** void setHueSpeed(char * commandReceived) {
 9078               		.loc 1 952 0
 9079               	.LVL730:
 9080               	/* prologue: function */
 9081               	/* frame size = 0 */
 9082               	/* stack size = 0 */
 9083               	.L__stack_usage = 0
 953:switcherator.c ****     tempIntString[0] = commandReceived[3];
 9084               		.loc 1 953 0
 9085 3406 FC01      		movw r30,r24
 9086 3408 2381      		ldd r18,Z+3
 9087 340a 2093 0000 		sts tempIntString,r18
 954:switcherator.c ****     tempIntString[1] = commandReceived[4];
 9088               		.loc 1 954 0
 9089 340e 8481      		ldd r24,Z+4
 9090               	.LVL731:
 9091 3410 8093 0000 		sts tempIntString+1,r24
 9092               	.LVL732:
 956:switcherator.c ****     programNumber = atoi(tempIntString);
 9093               		.loc 1 956 0
 9094 3414 80E0      		ldi r24,lo8(tempIntString)
 9095 3416 90E0      		ldi r25,hi8(tempIntString)
 9096 3418 0E94 0000 		call atoi
 9097               	.LVL733:
 957:switcherator.c ****     if (programNumber > 0)
 9098               		.loc 1 957 0
 9099 341c 1816      		cp __zero_reg__,r24
 9100 341e 1906      		cpc __zero_reg__,r25
 9101 3420 04F4      		brge .L622
 958:switcherator.c ****         hueSpeed = programNumber;
 9102               		.loc 1 958 0
 9103 3422 9093 0000 		sts hueSpeed+1,r25
 9104 3426 8093 0000 		sts hueSpeed,r24
 9105               	.L622:
 959:switcherator.c ****     ok();
 9106               		.loc 1 959 0
 9107 342a 0C94 0000 		jmp ok
 9108               	.LVL734:
 9109               	.LFE23:
 9111               	.global	cycleHue
 9113               	cycleHue:
 9114               	.LFB22:
 936:switcherator.c **** void cycleHue(char * commandReceived) {
 9115               		.loc 1 936 0
 9116               	.LVL735:
 9117               	/* prologue: function */
 9118               	/* frame size = 0 */
 9119               	/* stack size = 0 */
 9120               	.L__stack_usage = 0
 9121 342e FC01      		movw r30,r24
 938:switcherator.c ****     tempLongString[0] = commandReceived[5];
 9122               		.loc 1 938 0
 9123 3430 8581      		ldd r24,Z+5
 9124               	.LVL736:
 9125 3432 8093 0000 		sts tempLongString,r24
 939:switcherator.c ****     tempLongString[1] = commandReceived[6];
 9126               		.loc 1 939 0
 9127 3436 8681      		ldd r24,Z+6
 9128 3438 8093 0000 		sts tempLongString+1,r24
 940:switcherator.c ****     tempLongString[2] = commandReceived[7];
 9129               		.loc 1 940 0
 9130 343c 8781      		ldd r24,Z+7
 9131 343e 8093 0000 		sts tempLongString+2,r24
 941:switcherator.c ****     tempLongString[3] = commandReceived[8];
 9132               		.loc 1 941 0
 9133 3442 8085      		ldd r24,Z+8
 9134 3444 8093 0000 		sts tempLongString+3,r24
 9135               	.LVL737:
 943:switcherator.c ****     programNumber = atoi(tempLongString);
 9136               		.loc 1 943 0
 9137 3448 80E0      		ldi r24,lo8(tempLongString)
 9138 344a 90E0      		ldi r25,hi8(tempLongString)
 9139 344c 0E94 0000 		call atoi
 9140               	.LVL738:
 944:switcherator.c ****     if (programNumber > 0)
 9141               		.loc 1 944 0
 9142 3450 1816      		cp __zero_reg__,r24
 9143 3452 1906      		cpc __zero_reg__,r25
 9144 3454 04F4      		brge .L624
 945:switcherator.c ****         colorChangeSpeed = programNumber;
 9145               		.loc 1 945 0
 9146 3456 9093 0000 		sts colorChangeSpeed+1,r25
 9147 345a 8093 0000 		sts colorChangeSpeed,r24
 9148               	.L624:
 946:switcherator.c ****     ok();
 9149               		.loc 1 946 0
 9150 345e 0C94 0000 		jmp ok
 9151               	.LVL739:
 9152               	.LFE22:
 9154               	.global	switchClear
 9156               	switchClear:
 9157               	.LFB14:
 559:switcherator.c **** void switchClear(char * commandReceived) {
 9158               		.loc 1 559 0
 9159               	.LVL740:
 9160               	/* prologue: function */
 9161               	/* frame size = 0 */
 9162               	/* stack size = 0 */
 9163               	.L__stack_usage = 0
 562:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 9164               		.loc 1 562 0
 9165 3462 0E94 0000 		call getSwitchNumber
 9166               	.LVL741:
 563:switcherator.c ****     clearTheSwitch(switchNumber);
 9167               		.loc 1 563 0
 9168 3466 0E94 0000 		call clearTheSwitch
 9169               	.LVL742:
 564:switcherator.c ****     ok();
 9170               		.loc 1 564 0
 9171 346a 0C94 0000 		jmp ok
 9172               	.LVL743:
 9173               	.LFE14:
 9175               		.section	.rodata.str1.1
 9176               	.LC67:
 9177 013b 4375 7272 		.string	"Curr Tweak:"
 9177      2054 7765 
 9177      616B 3A00 
 9178               		.text
 9179               	.global	clockTweak
 9181               	clockTweak:
 9182               	.LFB60:
2630:switcherator.c **** void clockTweak(char * commandReceived) {
 9183               		.loc 1 2630 0
 9184               	.LVL744:
 9185               	/* prologue: function */
 9186               	/* frame size = 0 */
 9187               	/* stack size = 0 */
 9188               	.L__stack_usage = 0
 9189 346e FC01      		movw r30,r24
 9190               	.LVL745:
2633:switcherator.c ****         tempLongString[x] = commandReceived[(x + 3)];
 9191               		.loc 1 2633 0
 9192 3470 8381      		ldd r24,Z+3
 9193               	.LVL746:
 9194 3472 8093 0000 		sts tempLongString,r24
 9195               	.LVL747:
 9196 3476 8481      		ldd r24,Z+4
 9197 3478 8093 0000 		sts tempLongString+1,r24
 9198               	.LVL748:
 9199 347c 8581      		ldd r24,Z+5
 9200 347e 8093 0000 		sts tempLongString+2,r24
 9201               	.LVL749:
 9202 3482 8681      		ldd r24,Z+6
 9203 3484 8093 0000 		sts tempLongString+3,r24
 9204               	.LVL750:
2635:switcherator.c ****     int adjustment = atoi(tempLongString);
 9205               		.loc 1 2635 0
 9206 3488 80E0      		ldi r24,lo8(tempLongString)
 9207 348a 90E0      		ldi r25,hi8(tempLongString)
 9208 348c 0E94 0000 		call atoi
 9209               	.LVL751:
2636:switcherator.c ****     if (adjustment == 0) {
 9210               		.loc 1 2636 0
 9211 3490 0097      		sbiw r24,0
 9212 3492 01F4      		brne .L627
2637:switcherator.c ****         itoa(tweakTimer, tempLongString, 10);
 9213               		.loc 1 2637 0
 9214 3494 4AE0      		ldi r20,lo8(10)
 9215 3496 50E0      		ldi r21,0
 9216 3498 60E0      		ldi r22,lo8(tempLongString)
 9217 349a 70E0      		ldi r23,hi8(tempLongString)
 9218 349c 8091 0000 		lds r24,tweakTimer
 9219 34a0 9091 0000 		lds r25,tweakTimer+1
 9220               	.LVL752:
 9221 34a4 0E94 0000 		call itoa
 9222               	.LVL753:
2638:switcherator.c ****         statusMsg[0] = 0;
 9223               		.loc 1 2638 0
 9224 34a8 1092 0000 		sts statusMsg,__zero_reg__
2639:switcherator.c ****         strcat(statusMsg, "Curr Tweak:");
 9225               		.loc 1 2639 0
 9226 34ac 60E0      		ldi r22,lo8(.LC67)
 9227 34ae 70E0      		ldi r23,hi8(.LC67)
 9228 34b0 80E0      		ldi r24,lo8(statusMsg)
 9229 34b2 90E0      		ldi r25,hi8(statusMsg)
 9230 34b4 0E94 0000 		call strcat
 9231               	.LVL754:
2640:switcherator.c ****         strcat(statusMsg, tempLongString);
 9232               		.loc 1 2640 0
 9233 34b8 60E0      		ldi r22,lo8(tempLongString)
 9234 34ba 70E0      		ldi r23,hi8(tempLongString)
 9235 34bc 80E0      		ldi r24,lo8(statusMsg)
 9236 34be 90E0      		ldi r25,hi8(statusMsg)
 9237 34c0 0E94 0000 		call strcat
 9238               	.LVL755:
2641:switcherator.c ****         sendMessage(statusMsg);
 9239               		.loc 1 2641 0
 9240 34c4 80E0      		ldi r24,lo8(statusMsg)
 9241 34c6 90E0      		ldi r25,hi8(statusMsg)
 9242 34c8 0C94 0000 		jmp sendMessage
 9243               	.LVL756:
 9244               	.L627:
2644:switcherator.c ****     tweakTimer += adjustment;
 9245               		.loc 1 2644 0
 9246 34cc AA27      		clr r26
 9247 34ce 97FD      		sbrc r25,7
 9248 34d0 A095      		com r26
 9249 34d2 BA2F      		mov r27,r26
 9250 34d4 4091 0000 		lds r20,tweakTimer
 9251 34d8 5091 0000 		lds r21,tweakTimer+1
 9252 34dc 6091 0000 		lds r22,tweakTimer+2
 9253 34e0 7091 0000 		lds r23,tweakTimer+3
 9254 34e4 480F      		add r20,r24
 9255 34e6 591F      		adc r21,r25
 9256 34e8 6A1F      		adc r22,r26
 9257 34ea 7B1F      		adc r23,r27
 9258 34ec 4093 0000 		sts tweakTimer,r20
 9259 34f0 5093 0000 		sts tweakTimer+1,r21
 9260 34f4 6093 0000 		sts tweakTimer+2,r22
 9261 34f8 7093 0000 		sts tweakTimer+3,r23
2645:switcherator.c ****     ok();
 9262               		.loc 1 2645 0
 9263 34fc 0C94 0000 		jmp ok
 9264               	.LVL757:
 9265               	.LFE60:
 9267               		.section	.rodata.str1.1
 9268               	.LC68:
 9269 0147 5365 7420 		.string	"Set @"
 9269      4000 
 9270               	.LC69:
 9271 014d 4240 00   		.string	"B@"
 9272               		.text
 9273               	.global	brightnessSet
 9275               	brightnessSet:
 9276               	.LFB29:
1165:switcherator.c **** void brightnessSet(char * commandReceived) {
 9277               		.loc 1 1165 0
 9278               	.LVL758:
 9279               	/* prologue: function */
 9280               	/* frame size = 0 */
 9281               	/* stack size = 0 */
 9282               	.L__stack_usage = 0
1166:switcherator.c ****     int brightValue = getSwitchNumber(commandReceived);
 9283               		.loc 1 1166 0
 9284 3500 0E94 0000 		call getSwitchNumber
 9285               	.LVL759:
 9286 3504 9C01      		movw r18,r24
 9287               	.LVL760:
 9288 3506 8091 0000 		lds r24,oldBright
1167:switcherator.c ****     if (brightValue == 0) {
 9289               		.loc 1 1167 0
 9290 350a 2115      		cp r18,__zero_reg__
 9291 350c 3105      		cpc r19,__zero_reg__
 9292 350e 01F4      		brne .L629
1169:switcherator.c ****         itoa(oldBright, tempIntString, 10);
 9293               		.loc 1 1169 0
 9294 3510 4AE0      		ldi r20,lo8(10)
 9295 3512 50E0      		ldi r21,0
 9296 3514 60E0      		ldi r22,lo8(tempIntString)
 9297 3516 70E0      		ldi r23,hi8(tempIntString)
 9298 3518 90E0      		ldi r25,0
 9299 351a 0E94 0000 		call itoa
 9300               	.LVL761:
1170:switcherator.c ****         statusMsg[0] = 0;
 9301               		.loc 1 1170 0
 9302 351e 1092 0000 		sts statusMsg,__zero_reg__
1171:switcherator.c ****         strcat(statusMsg, "Set @");
 9303               		.loc 1 1171 0
 9304 3522 60E0      		ldi r22,lo8(.LC68)
 9305 3524 70E0      		ldi r23,hi8(.LC68)
 9306 3526 80E0      		ldi r24,lo8(statusMsg)
 9307 3528 90E0      		ldi r25,hi8(statusMsg)
 9308 352a 0E94 0000 		call strcat
 9309               	.LVL762:
1172:switcherator.c ****         strcat(statusMsg, tempIntString);
 9310               		.loc 1 1172 0
 9311 352e 60E0      		ldi r22,lo8(tempIntString)
 9312 3530 70E0      		ldi r23,hi8(tempIntString)
 9313 3532 80E0      		ldi r24,lo8(statusMsg)
 9314 3534 90E0      		ldi r25,hi8(statusMsg)
 9315 3536 0E94 0000 		call strcat
 9316               	.LVL763:
1173:switcherator.c ****         strcat(statusMsg, "B@");
 9317               		.loc 1 1173 0
 9318 353a 60E0      		ldi r22,lo8(.LC69)
 9319 353c 70E0      		ldi r23,hi8(.LC69)
 9320 353e 80E0      		ldi r24,lo8(statusMsg)
 9321 3540 90E0      		ldi r25,hi8(statusMsg)
 9322 3542 0E94 0000 		call strcat
 9323               	.LVL764:
1174:switcherator.c ****         itoa(bright, tempIntString, 10);
 9324               		.loc 1 1174 0
 9325 3546 4AE0      		ldi r20,lo8(10)
 9326 3548 50E0      		ldi r21,0
 9327 354a 60E0      		ldi r22,lo8(tempIntString)
 9328 354c 70E0      		ldi r23,hi8(tempIntString)
 9329 354e 8091 0000 		lds r24,bright
 9330 3552 9091 0000 		lds r25,bright+1
 9331 3556 0E94 0000 		call itoa
 9332               	.LVL765:
1175:switcherator.c ****         strcat(statusMsg, tempIntString);
 9333               		.loc 1 1175 0
 9334 355a 60E0      		ldi r22,lo8(tempIntString)
 9335 355c 70E0      		ldi r23,hi8(tempIntString)
 9336 355e 80E0      		ldi r24,lo8(statusMsg)
 9337 3560 90E0      		ldi r25,hi8(statusMsg)
 9338 3562 0E94 0000 		call strcat
 9339               	.LVL766:
1176:switcherator.c ****         sendMessage(statusMsg);
 9340               		.loc 1 1176 0
 9341 3566 80E0      		ldi r24,lo8(statusMsg)
 9342 3568 90E0      		ldi r25,hi8(statusMsg)
 9343 356a 0C94 0000 		jmp sendMessage
 9344               	.LVL767:
 9345               	.L629:
 9346 356e 2131      		cpi r18,17
 9347 3570 3105      		cpc r19,__zero_reg__
 9348 3572 04F0      		brlt .L630
 9349 3574 20E1      		ldi r18,lo8(16)
 9350 3576 30E0      		ldi r19,0
 9351               	.LVL768:
 9352               	.L630:
1180:switcherator.c ****         if (oldBright == bright) {
 9353               		.loc 1 1180 0
 9354 3578 90E0      		ldi r25,0
 9355 357a 4091 0000 		lds r20,bright
 9356 357e 5091 0000 		lds r21,bright+1
 9357 3582 8417      		cp r24,r20
 9358 3584 9507      		cpc r25,r21
 9359 3586 01F4      		brne .L631
1182:switcherator.c ****             bright = brightValue;
 9360               		.loc 1 1182 0
 9361 3588 3093 0000 		sts bright+1,r19
 9362 358c 2093 0000 		sts bright,r18
 9363               	.L631:
1184:switcherator.c ****         oldBright = brightValue;
 9364               		.loc 1 1184 0
 9365 3590 2093 0000 		sts oldBright,r18
1185:switcherator.c ****         switchChanged = 1;
 9366               		.loc 1 1185 0
 9367 3594 81E0      		ldi r24,lo8(1)
 9368 3596 8093 0000 		sts switchChanged,r24
1186:switcherator.c ****         ok();
 9369               		.loc 1 1186 0
 9370 359a 0C94 0000 		jmp ok
 9371               	.LVL769:
 9372               	.LFE29:
 9374               		.section	.rodata.str1.1
 9375               	.LC70:
 9376 0150 6661 696C 		.string	"fail 0x"
 9376      2030 7800 
 9377               		.text
 9378               	.global	fail
 9380               	fail:
 9381               	.LFB10:
 417:switcherator.c **** void fail(int failCode) {
 9382               		.loc 1 417 0
 9383               	.LVL770:
 9384 359e CF93      		push r28
 9385               	.LCFI217:
 9386 35a0 DF93      		push r29
 9387               	.LCFI218:
 9388               	/* prologue: function */
 9389               	/* frame size = 0 */
 9390               	/* stack size = 2 */
 9391               	.L__stack_usage = 2
 9392 35a2 EC01      		movw r28,r24
 418:switcherator.c ****     statusMsg[0] = 0;
 9393               		.loc 1 418 0
 9394 35a4 1092 0000 		sts statusMsg,__zero_reg__
 419:switcherator.c ****     strcat(statusMsg, "fail 0x");
 9395               		.loc 1 419 0
 9396 35a8 60E0      		ldi r22,lo8(.LC70)
 9397 35aa 70E0      		ldi r23,hi8(.LC70)
 9398 35ac 80E0      		ldi r24,lo8(statusMsg)
 9399 35ae 90E0      		ldi r25,hi8(statusMsg)
 9400               	.LVL771:
 9401 35b0 0E94 0000 		call strcat
 9402               	.LVL772:
 420:switcherator.c ****     returnHex(failCode, tempIntString);
 9403               		.loc 1 420 0
 9404 35b4 60E0      		ldi r22,lo8(tempIntString)
 9405 35b6 70E0      		ldi r23,hi8(tempIntString)
 9406 35b8 CE01      		movw r24,r28
 9407 35ba 0E94 0000 		call returnHex
 9408               	.LVL773:
 421:switcherator.c ****     strcat(statusMsg, tempIntString);
 9409               		.loc 1 421 0
 9410 35be 60E0      		ldi r22,lo8(tempIntString)
 9411 35c0 70E0      		ldi r23,hi8(tempIntString)
 9412 35c2 80E0      		ldi r24,lo8(statusMsg)
 9413 35c4 90E0      		ldi r25,hi8(statusMsg)
 9414 35c6 0E94 0000 		call strcat
 9415               	.LVL774:
 422:switcherator.c ****     sendMessage(statusMsg);
 9416               		.loc 1 422 0
 9417 35ca 80E0      		ldi r24,lo8(statusMsg)
 9418 35cc 90E0      		ldi r25,hi8(statusMsg)
 9419               	/* epilogue start */
 423:switcherator.c **** }
 9420               		.loc 1 423 0
 9421 35ce DF91      		pop r29
 9422 35d0 CF91      		pop r28
 9423               	.LVL775:
 422:switcherator.c ****     sendMessage(statusMsg);
 9424               		.loc 1 422 0
 9425 35d2 0C94 0000 		jmp sendMessage
 9426               	.LVL776:
 9427               	.LFE10:
 9429               	.global	setDigitalInput
 9431               	setDigitalInput:
 9432               	.LFB79:
3252:switcherator.c **** void setDigitalInput(char * commandReceived) {
 9433               		.loc 1 3252 0
 9434               	.LVL777:
 9435 35d6 5F92      		push r5
 9436               	.LCFI219:
 9437 35d8 6F92      		push r6
 9438               	.LCFI220:
 9439 35da 7F92      		push r7
 9440               	.LCFI221:
 9441 35dc 8F92      		push r8
 9442               	.LCFI222:
 9443 35de 9F92      		push r9
 9444               	.LCFI223:
 9445 35e0 AF92      		push r10
 9446               	.LCFI224:
 9447 35e2 BF92      		push r11
 9448               	.LCFI225:
 9449 35e4 CF92      		push r12
 9450               	.LCFI226:
 9451 35e6 DF92      		push r13
 9452               	.LCFI227:
 9453 35e8 EF92      		push r14
 9454               	.LCFI228:
 9455 35ea FF92      		push r15
 9456               	.LCFI229:
 9457 35ec 0F93      		push r16
 9458               	.LCFI230:
 9459 35ee 1F93      		push r17
 9460               	.LCFI231:
 9461 35f0 CF93      		push r28
 9462               	.LCFI232:
 9463 35f2 DF93      		push r29
 9464               	.LCFI233:
 9465               	/* prologue: function */
 9466               	/* frame size = 0 */
 9467               	/* stack size = 15 */
 9468               	.L__stack_usage = 15
 9469 35f4 EC01      		movw r28,r24
 9470               	.LVL778:
3261:switcherator.c ****     tempIntString[0] = commandReceived[3];
 9471               		.loc 1 3261 0
 9472 35f6 8B81      		ldd r24,Y+3
 9473               	.LVL779:
 9474 35f8 8093 0000 		sts tempIntString,r24
3262:switcherator.c ****     tempIntString[1] = commandReceived[4];
 9475               		.loc 1 3262 0
 9476 35fc 8C81      		ldd r24,Y+4
 9477 35fe 8093 0000 		sts tempIntString+1,r24
3263:switcherator.c ****     inputNumber = atoi(tempIntString);
 9478               		.loc 1 3263 0
 9479 3602 80E0      		ldi r24,lo8(tempIntString)
 9480 3604 90E0      		ldi r25,hi8(tempIntString)
 9481 3606 0E94 0000 		call atoi
 9482               	.LVL780:
 9483 360a 7C01      		movw r14,r24
 9484               	.LVL781:
3264:switcherator.c ****     if (inputNumber >= NUM_INPUTS) {
 9485               		.loc 1 3264 0
 9486 360c 84E0      		ldi r24,4
 9487 360e E816      		cp r14,r24
 9488 3610 F104      		cpc r15,__zero_reg__
 9489 3612 04F0      		brlt .L634
3265:switcherator.c ****         fail(0x11);
 9490               		.loc 1 3265 0
 9491 3614 81E1      		ldi r24,lo8(17)
 9492 3616 90E0      		ldi r25,0
 9493 3618 00C0      		rjmp .L671
 9494               	.L634:
3268:switcherator.c ****     tempIntString[0] = '0';
 9495               		.loc 1 3268 0
 9496 361a 80E3      		ldi r24,lo8(48)
 9497 361c 8093 0000 		sts tempIntString,r24
3269:switcherator.c ****     tempIntString[1] = commandReceived[6];
 9498               		.loc 1 3269 0
 9499 3620 8E81      		ldd r24,Y+6
 9500 3622 8093 0000 		sts tempIntString+1,r24
3270:switcherator.c ****     pin = atoi(tempIntString);
 9501               		.loc 1 3270 0
 9502 3626 80E0      		ldi r24,lo8(tempIntString)
 9503 3628 90E0      		ldi r25,hi8(tempIntString)
 9504 362a 0E94 0000 		call atoi
 9505               	.LVL782:
 9506 362e 6C01      		movw r12,r24
 9507               	.LVL783:
3271:switcherator.c ****     if (pin > 7) {
 9508               		.loc 1 3271 0
 9509 3630 E7E0      		ldi r30,lo8(7)
 9510 3632 E817      		cp r30,r24
 9511 3634 00F4      		brsh .L635
3272:switcherator.c ****         fail(0x04);
 9512               		.loc 1 3272 0
 9513 3636 84E0      		ldi r24,lo8(4)
 9514 3638 90E0      		ldi r25,0
 9515               	.LVL784:
 9516               	.L671:
 9517               	/* epilogue start */
3386:switcherator.c **** }
 9518               		.loc 1 3386 0
 9519 363a DF91      		pop r29
 9520 363c CF91      		pop r28
 9521               	.LVL785:
 9522 363e 1F91      		pop r17
 9523 3640 0F91      		pop r16
 9524 3642 FF90      		pop r15
 9525 3644 EF90      		pop r14
 9526               	.LVL786:
 9527 3646 DF90      		pop r13
 9528 3648 CF90      		pop r12
 9529 364a BF90      		pop r11
 9530 364c AF90      		pop r10
 9531 364e 9F90      		pop r9
 9532 3650 8F90      		pop r8
 9533 3652 7F90      		pop r7
 9534 3654 6F90      		pop r6
 9535 3656 5F90      		pop r5
3272:switcherator.c ****         fail(0x04);
 9536               		.loc 1 3272 0
 9537 3658 0C94 0000 		jmp fail
 9538               	.LVL787:
 9539               	.L635:
3276:switcherator.c ****     tempIntString[0] = commandReceived[9];
 9540               		.loc 1 3276 0
 9541 365c 8985      		ldd r24,Y+9
 9542 365e 8093 0000 		sts tempIntString,r24
3277:switcherator.c ****     tempIntString[1] = commandReceived[10];
 9543               		.loc 1 3277 0
 9544 3662 8A85      		ldd r24,Y+10
 9545 3664 8093 0000 		sts tempIntString+1,r24
3278:switcherator.c ****     switchNumber = atoi(tempIntString);
 9546               		.loc 1 3278 0
 9547 3668 80E0      		ldi r24,lo8(tempIntString)
 9548 366a 90E0      		ldi r25,hi8(tempIntString)
 9549 366c 0E94 0000 		call atoi
 9550               	.LVL788:
 9551 3670 8C01      		movw r16,r24
 9552               	.LVL789:
3280:switcherator.c ****     tempIntString[0] = commandReceived[15];
 9553               		.loc 1 3280 0
 9554 3672 8F85      		ldd r24,Y+15
 9555 3674 8093 0000 		sts tempIntString,r24
3281:switcherator.c ****     tempIntString[1] = commandReceived[16];
 9556               		.loc 1 3281 0
 9557 3678 8889      		ldd r24,Y+16
 9558 367a 8093 0000 		sts tempIntString+1,r24
3282:switcherator.c ****     pollTime = atoi(tempIntString);
 9559               		.loc 1 3282 0
 9560 367e 80E0      		ldi r24,lo8(tempIntString)
 9561 3680 90E0      		ldi r25,hi8(tempIntString)
 9562 3682 0E94 0000 		call atoi
 9563               	.LVL790:
 9564 3686 4C01      		movw r8,r24
 9565               	.LVL791:
3284:switcherator.c ****     tempLongString[0] = commandReceived[11];
 9566               		.loc 1 3284 0
 9567 3688 8B85      		ldd r24,Y+11
 9568 368a 8093 0000 		sts tempLongString,r24
3285:switcherator.c ****     tempLongString[1] = commandReceived[12];
 9569               		.loc 1 3285 0
 9570 368e 8C85      		ldd r24,Y+12
 9571 3690 8093 0000 		sts tempLongString+1,r24
3286:switcherator.c ****     tempLongString[2] = commandReceived[13];
 9572               		.loc 1 3286 0
 9573 3694 8D85      		ldd r24,Y+13
 9574 3696 8093 0000 		sts tempLongString+2,r24
3287:switcherator.c ****     tempLongString[3] = commandReceived[14];
 9575               		.loc 1 3287 0
 9576 369a 8E85      		ldd r24,Y+14
 9577 369c 8093 0000 		sts tempLongString+3,r24
3288:switcherator.c ****     duration = atoi(tempLongString);
 9578               		.loc 1 3288 0
 9579 36a0 80E0      		ldi r24,lo8(tempLongString)
 9580 36a2 90E0      		ldi r25,hi8(tempLongString)
 9581 36a4 0E94 0000 		call atoi
 9582               	.LVL792:
 9583 36a8 582E      		mov r5,r24
 9584               	.LVL793:
3290:switcherator.c ****     if (commandReceived[8] == 'P' || commandReceived[8] == 'p') {
 9585               		.loc 1 3290 0
 9586 36aa 2885      		ldd r18,Y+8
 9587 36ac 2035      		cpi r18,lo8(80)
 9588 36ae 01F0      		breq .L636
3290:switcherator.c ****     if (commandReceived[8] == 'P' || commandReceived[8] == 'p') {
 9589               		.loc 1 3290 0 is_stmt 0 discriminator 1
 9590 36b0 2037      		cpi r18,lo8(112)
 9591 36b2 01F4      		brne .L637
 9592               	.L636:
3291:switcherator.c ****         switchNumber += 128;
 9593               		.loc 1 3291 0 is_stmt 1
 9594 36b4 0058      		subi r16,-128
 9595 36b6 1F4F      		sbci r17,-1
 9596               	.LVL794:
 9597               	.L637:
3293:switcherator.c ****     temp = pin * 2;
 9598               		.loc 1 3293 0
 9599 36b8 B601      		movw r22,r12
 9600 36ba 7727      		clr r23
 9601 36bc 9B01      		movw r18,r22
 9602 36be 220F      		lsl r18
 9603 36c0 331F      		rol r19
 9604               	.LVL795:
3294:switcherator.c ****     if (commandReceived[5] == 'B' || commandReceived[5] == 'b') {
 9605               		.loc 1 3294 0
 9606 36c2 4D81      		ldd r20,Y+5
 9607 36c4 4234      		cpi r20,lo8(66)
 9608 36c6 01F0      		breq .L638
3294:switcherator.c ****     if (commandReceived[5] == 'B' || commandReceived[5] == 'b') {
 9609               		.loc 1 3294 0 is_stmt 0 discriminator 1
 9610 36c8 4236      		cpi r20,lo8(98)
 9611 36ca 01F4      		brne .L639
 9612               	.L638:
 9613               	.LVL796:
3297:switcherator.c ****         temp += 16;
 9614               		.loc 1 3297 0 is_stmt 1
 9615 36cc 205F      		subi r18,-16
 9616 36ce 3F4F      		sbci r19,-1
 9617               	.LVL797:
3296:switcherator.c ****         realPort = &PORTB;
 9618               		.loc 1 3296 0
 9619 36d0 A5E2      		ldi r26,lo8(37)
 9620 36d2 6A2E      		mov r6,r26
 9621 36d4 712C      		mov r7,__zero_reg__
3295:switcherator.c ****         realDDR = &DDRB;
 9622               		.loc 1 3295 0
 9623 36d6 A4E2      		ldi r26,lo8(36)
 9624 36d8 B0E0      		ldi r27,0
3297:switcherator.c ****         temp += 16;
 9625               		.loc 1 3297 0
 9626 36da 00C0      		rjmp .L640
 9627               	.LVL798:
 9628               	.L639:
3305:switcherator.c ****     } else if (commandReceived[5] == 'C' || commandReceived[5] == 'c') {
 9629               		.loc 1 3305 0
 9630 36dc 4334      		cpi r20,lo8(67)
 9631 36de 01F0      		breq .L641
3305:switcherator.c ****     } else if (commandReceived[5] == 'C' || commandReceived[5] == 'c') {
 9632               		.loc 1 3305 0 is_stmt 0 discriminator 1
 9633 36e0 4336      		cpi r20,lo8(99)
 9634 36e2 01F4      		brne .L642
 9635               	.L641:
 9636               	.LVL799:
3308:switcherator.c ****         temp += 32;
 9637               		.loc 1 3308 0 is_stmt 1
 9638 36e4 205E      		subi r18,-32
 9639 36e6 3F4F      		sbci r19,-1
 9640               	.LVL800:
3307:switcherator.c ****         realPort = &PORTC;
 9641               		.loc 1 3307 0
 9642 36e8 F8E2      		ldi r31,lo8(40)
 9643 36ea 6F2E      		mov r6,r31
 9644 36ec 712C      		mov r7,__zero_reg__
3306:switcherator.c ****         realDDR = &DDRC;
 9645               		.loc 1 3306 0
 9646 36ee A7E2      		ldi r26,lo8(39)
 9647 36f0 B0E0      		ldi r27,0
3308:switcherator.c ****         temp += 32;
 9648               		.loc 1 3308 0
 9649 36f2 00C0      		rjmp .L640
 9650               	.LVL801:
 9651               	.L642:
3311:switcherator.c ****     } else if (commandReceived[5] == 'D' || commandReceived[5] == 'd') {
 9652               		.loc 1 3311 0
 9653 36f4 4434      		cpi r20,lo8(68)
 9654 36f6 01F0      		breq .L643
3311:switcherator.c ****     } else if (commandReceived[5] == 'D' || commandReceived[5] == 'd') {
 9655               		.loc 1 3311 0 is_stmt 0 discriminator 1
 9656 36f8 4436      		cpi r20,lo8(100)
 9657 36fa 01F4      		brne .L651
 9658               	.L643:
 9659               	.LVL802:
3314:switcherator.c ****         temp += 48;
 9660               		.loc 1 3314 0 is_stmt 1
 9661 36fc 205D      		subi r18,-48
 9662 36fe 3F4F      		sbci r19,-1
 9663               	.LVL803:
3313:switcherator.c ****         realPort = &PORTD;
 9664               		.loc 1 3313 0
 9665 3700 EBE2      		ldi r30,lo8(43)
 9666 3702 6E2E      		mov r6,r30
 9667 3704 712C      		mov r7,__zero_reg__
3312:switcherator.c ****         realDDR = &DDRD;
 9668               		.loc 1 3312 0
 9669 3706 AAE2      		ldi r26,lo8(42)
 9670 3708 B0E0      		ldi r27,0
 9671 370a 00C0      		rjmp .L640
 9672               	.LVL804:
 9673               	.L651:
3256:switcherator.c ****     volatile unsigned char *realPort = 0;
 9674               		.loc 1 3256 0
 9675 370c 612C      		mov r6,__zero_reg__
 9676 370e 712C      		mov r7,__zero_reg__
3255:switcherator.c ****     volatile unsigned char *realDDR = 0;
 9677               		.loc 1 3255 0
 9678 3710 A0E0      		ldi r26,0
 9679 3712 B0E0      		ldi r27,0
 9680               	.LVL805:
 9681               	.L640:
 9682 3714 40E0      		ldi r20,lo8(switchStuff)
 9683 3716 50E0      		ldi r21,hi8(switchStuff)
3354:switcherator.c ****         if (switchStuff[x] == temp || switchStuff[x] == (temp + 1)) {
 9684               		.loc 1 3354 0
 9685 3718 5901      		movw r10,r18
 9686 371a FFEF      		ldi r31,-1
 9687 371c AF1A      		sub r10,r31
 9688 371e BF0A      		sbc r11,r31
 9689               	.LVL806:
 9690               	.L646:
 9691 3720 FA01      		movw r30,r20
 9692 3722 C190      		ld r12,Z+
 9693 3724 AF01      		movw r20,r30
 9694 3726 D12C      		mov r13,__zero_reg__
 9695 3728 C216      		cp r12,r18
 9696 372a D306      		cpc r13,r19
 9697 372c 01F0      		breq .L644
3354:switcherator.c ****         if (switchStuff[x] == temp || switchStuff[x] == (temp + 1)) {
 9698               		.loc 1 3354 0 is_stmt 0 discriminator 1
 9699 372e CA14      		cp r12,r10
 9700 3730 DB04      		cpc r13,r11
 9701 3732 01F4      		brne .L645
 9702               	.L644:
3355:switcherator.c ****             fail(0x12);
 9703               		.loc 1 3355 0 is_stmt 1
 9704 3734 82E1      		ldi r24,lo8(18)
 9705 3736 90E0      		ldi r25,0
 9706 3738 00C0      		rjmp .L671
 9707               	.L645:
3353:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 9708               		.loc 1 3353 0
 9709 373a F0E0      		ldi r31,hi8(switchStuff+16)
 9710 373c 4030      		cpi r20,lo8(switchStuff+16)
 9711 373e 5F07      		cpc r21,r31
 9712 3740 01F4      		brne .L646
3360:switcherator.c ****     inputs[inputNumber][0] = temp;
 9713               		.loc 1 3360 0
 9714 3742 A701      		movw r20,r14
 9715 3744 33E0      		ldi r19,3
 9716               		1:
 9717 3746 440F      		lsl r20
 9718 3748 551F      		rol r21
 9719 374a 3A95      		dec r19
 9720 374c 01F4      		brne 1b
 9721 374e 70E0      		ldi r23,lo8(inputs)
 9722 3750 E72E      		mov r14,r23
 9723 3752 70E0      		ldi r23,hi8(inputs)
 9724 3754 F72E      		mov r15,r23
 9725               	.LVL807:
 9726 3756 E40E      		add r14,r20
 9727 3758 F51E      		adc r15,r21
 9728 375a F701      		movw r30,r14
 9729 375c 2083      		st Z,r18
3362:switcherator.c ****     if (commandReceived[7] == 'H' || commandReceived[7] == 'h' ||
 9730               		.loc 1 3362 0
 9731 375e 2F81      		ldd r18,Y+7
 9732               	.LVL808:
 9733 3760 2834      		cpi r18,lo8(72)
 9734 3762 01F0      		breq .L647
3362:switcherator.c ****     if (commandReceived[7] == 'H' || commandReceived[7] == 'h' ||
 9735               		.loc 1 3362 0 is_stmt 0 discriminator 1
 9736 3764 2836      		cpi r18,lo8(104)
 9737 3766 01F0      		breq .L647
 9738 3768 2133      		cpi r18,lo8(49)
 9739 376a 01F4      		brne .L648
 9740               	.L647:
3364:switcherator.c ****         inputs[inputNumber][1] = 0;
 9741               		.loc 1 3364 0 is_stmt 1
 9742 376c EA01      		movw r28,r20
 9743               	.LVL809:
 9744 376e C050      		subi r28,lo8(-(inputs))
 9745 3770 D040      		sbci r29,hi8(-(inputs))
 9746 3772 1982      		std Y+1,__zero_reg__
3365:switcherator.c ****         inputs[inputNumber][2] = 255;
 9747               		.loc 1 3365 0
 9748 3774 2FEF      		ldi r18,lo8(-1)
 9749 3776 2A83      		std Y+2,r18
 9750 3778 00C0      		rjmp .L649
 9751               	.LVL810:
 9752               	.L648:
3367:switcherator.c ****         inputs[inputNumber][1] = 255;
 9753               		.loc 1 3367 0
 9754 377a 2FEF      		ldi r18,lo8(-1)
 9755 377c F701      		movw r30,r14
 9756 377e 2183      		std Z+1,r18
3368:switcherator.c ****         inputs[inputNumber][2] = 0;
 9757               		.loc 1 3368 0
 9758 3780 1282      		std Z+2,__zero_reg__
 9759               	.LVL811:
 9760               	.L649:
3370:switcherator.c ****     inputs[inputNumber][3] = switchNumber;
 9761               		.loc 1 3370 0
 9762 3782 EA01      		movw r28,r20
 9763 3784 C050      		subi r28,lo8(-(inputs))
 9764 3786 D040      		sbci r29,hi8(-(inputs))
 9765 3788 0B83      		std Y+3,r16
 9766               	.LVL812:
3372:switcherator.c ****     inputs[inputNumber][4] = temp;
 9767               		.loc 1 3372 0
 9768 378a 9C83      		std Y+4,r25
 9769               	.LVL813:
3374:switcherator.c ****     inputs[inputNumber][5] = temp;
 9770               		.loc 1 3374 0
 9771 378c 5D82      		std Y+5,r5
 9772               	.LVL814:
3378:switcherator.c ****     inputs[inputNumber][6] = pollTime;
 9773               		.loc 1 3378 0
 9774 378e 9401      		movw r18,r8
 9775 3790 2F3F      		cpi r18,-1
 9776 3792 3105      		cpc r19,__zero_reg__
 9777 3794 01F0      		breq .L650
 9778 3796 04F0      		brlt .L650
 9779 3798 2FEF      		ldi r18,lo8(-1)
 9780 379a 30E0      		ldi r19,0
 9781               	.L650:
 9782 379c 2E83      		std Y+6,r18
3380:switcherator.c ****     *realDDR &= ~(1 << pin);
 9783               		.loc 1 3380 0
 9784 379e 8C91      		ld r24,X
 9785 37a0 21E0      		ldi r18,lo8(1)
 9786 37a2 30E0      		ldi r19,0
 9787 37a4 00C0      		rjmp 2f
 9788               		1:
 9789 37a6 220F      		lsl r18
 9790               		2:
 9791 37a8 6A95      		dec r22
 9792 37aa 02F4      		brpl 1b
 9793 37ac 922F      		mov r25,r18
 9794               	.LVL815:
 9795 37ae 9095      		com r25
 9796 37b0 8923      		and r24,r25
 9797 37b2 8C93      		st X,r24
3381:switcherator.c ****     *realPort |= (1 << pin);
 9798               		.loc 1 3381 0
 9799 37b4 F301      		movw r30,r6
 9800 37b6 8081      		ld r24,Z
 9801 37b8 822B      		or r24,r18
 9802 37ba 8083      		st Z,r24
 9803               	/* epilogue start */
3386:switcherator.c **** }
 9804               		.loc 1 3386 0
 9805 37bc DF91      		pop r29
 9806 37be CF91      		pop r28
 9807               	.LVL816:
 9808 37c0 1F91      		pop r17
 9809 37c2 0F91      		pop r16
 9810 37c4 FF90      		pop r15
 9811 37c6 EF90      		pop r14
 9812 37c8 DF90      		pop r13
 9813 37ca CF90      		pop r12
 9814 37cc BF90      		pop r11
 9815 37ce AF90      		pop r10
 9816 37d0 9F90      		pop r9
 9817               	.LVL817:
 9818 37d2 8F90      		pop r8
 9819 37d4 7F90      		pop r7
 9820 37d6 6F90      		pop r6
 9821               	.LVL818:
 9822 37d8 5F90      		pop r5
 9823               	.LVL819:
3383:switcherator.c ****     ok();
 9824               		.loc 1 3383 0
 9825 37da 0C94 0000 		jmp ok
 9826               	.LVL820:
 9827               	.LFE79:
 9829               	.global	setAnalogInput
 9831               	setAnalogInput:
 9832               	.LFB78:
3127:switcherator.c **** void setAnalogInput(char * commandReceived) {
 9833               		.loc 1 3127 0
 9834               	.LVL821:
 9835 37de 2F92      		push r2
 9836               	.LCFI234:
 9837 37e0 3F92      		push r3
 9838               	.LCFI235:
 9839 37e2 4F92      		push r4
 9840               	.LCFI236:
 9841 37e4 5F92      		push r5
 9842               	.LCFI237:
 9843 37e6 6F92      		push r6
 9844               	.LCFI238:
 9845 37e8 7F92      		push r7
 9846               	.LCFI239:
 9847 37ea 8F92      		push r8
 9848               	.LCFI240:
 9849 37ec 9F92      		push r9
 9850               	.LCFI241:
 9851 37ee AF92      		push r10
 9852               	.LCFI242:
 9853 37f0 BF92      		push r11
 9854               	.LCFI243:
 9855 37f2 CF92      		push r12
 9856               	.LCFI244:
 9857 37f4 DF92      		push r13
 9858               	.LCFI245:
 9859 37f6 EF92      		push r14
 9860               	.LCFI246:
 9861 37f8 FF92      		push r15
 9862               	.LCFI247:
 9863 37fa 0F93      		push r16
 9864               	.LCFI248:
 9865 37fc 1F93      		push r17
 9866               	.LCFI249:
 9867 37fe CF93      		push r28
 9868               	.LCFI250:
 9869 3800 DF93      		push r29
 9870               	.LCFI251:
 9871 3802 00D0      		rcall .
 9872 3804 1F92      		push __zero_reg__
 9873               	.LCFI252:
 9874 3806 CDB7      		in r28,__SP_L__
 9875 3808 DEB7      		in r29,__SP_H__
 9876               	.LCFI253:
 9877               	/* prologue: function */
 9878               	/* frame size = 3 */
 9879               	/* stack size = 21 */
 9880               	.L__stack_usage = 21
 9881 380a 9B83      		std Y+3,r25
 9882 380c 8A83      		std Y+2,r24
 9883               	.LVL822:
3135:switcherator.c ****     tempIntString[0] = commandReceived[3];
 9884               		.loc 1 3135 0
 9885 380e DC01      		movw r26,r24
 9886 3810 1396      		adiw r26,3
 9887 3812 8C91      		ld r24,X
 9888 3814 1397      		sbiw r26,3
 9889               	.LVL823:
 9890 3816 8093 0000 		sts tempIntString,r24
3136:switcherator.c ****     tempIntString[1] = commandReceived[4];
 9891               		.loc 1 3136 0
 9892 381a 1496      		adiw r26,4
 9893 381c 8C91      		ld r24,X
 9894 381e 8093 0000 		sts tempIntString+1,r24
3137:switcherator.c ****     inputNumber = atoi(tempIntString);
 9895               		.loc 1 3137 0
 9896 3822 80E0      		ldi r24,lo8(tempIntString)
 9897 3824 90E0      		ldi r25,hi8(tempIntString)
 9898 3826 0E94 0000 		call atoi
 9899               	.LVL824:
 9900 382a 8C01      		movw r16,r24
 9901               	.LVL825:
3138:switcherator.c ****     if (inputNumber >= NUM_INPUTS) {
 9902               		.loc 1 3138 0
 9903 382c 8430      		cpi r24,4
 9904 382e 9105      		cpc r25,__zero_reg__
 9905 3830 04F0      		brlt .L673
3139:switcherator.c ****         fail(0x11);
 9906               		.loc 1 3139 0
 9907 3832 81E1      		ldi r24,lo8(17)
 9908 3834 90E0      		ldi r25,0
 9909 3836 00C0      		rjmp .L694
 9910               	.L673:
3142:switcherator.c ****     tempIntString[0] = '0';
 9911               		.loc 1 3142 0
 9912 3838 50E3      		ldi r21,lo8(48)
 9913 383a B52E      		mov r11,r21
 9914 383c B092 0000 		sts tempIntString,r11
3143:switcherator.c ****     tempIntString[1] = commandReceived[6];
 9915               		.loc 1 3143 0
 9916 3840 EA81      		ldd r30,Y+2
 9917 3842 FB81      		ldd r31,Y+3
 9918 3844 8681      		ldd r24,Z+6
 9919 3846 8093 0000 		sts tempIntString+1,r24
3144:switcherator.c ****     pin = atoi(tempIntString);
 9920               		.loc 1 3144 0
 9921 384a 80E0      		ldi r24,lo8(tempIntString)
 9922 384c 90E0      		ldi r25,hi8(tempIntString)
 9923 384e 0E94 0000 		call atoi
 9924               	.LVL826:
 9925 3852 6C01      		movw r12,r24
 9926               	.LVL827:
3145:switcherator.c ****     if (pin > 7) {
 9927               		.loc 1 3145 0
 9928 3854 F7E0      		ldi r31,lo8(7)
 9929 3856 F817      		cp r31,r24
 9930 3858 00F4      		brsh .L674
3146:switcherator.c ****         fail(0x04);
 9931               		.loc 1 3146 0
 9932 385a 84E0      		ldi r24,lo8(4)
 9933 385c 90E0      		ldi r25,0
 9934               	.LVL828:
 9935               	.L694:
 9936               	/* epilogue start */
3244:switcherator.c **** }
 9937               		.loc 1 3244 0
 9938 385e 0F90      		pop __tmp_reg__
 9939 3860 0F90      		pop __tmp_reg__
 9940 3862 0F90      		pop __tmp_reg__
 9941 3864 DF91      		pop r29
 9942 3866 CF91      		pop r28
 9943 3868 1F91      		pop r17
 9944 386a 0F91      		pop r16
 9945               	.LVL829:
 9946 386c FF90      		pop r15
 9947 386e EF90      		pop r14
 9948 3870 DF90      		pop r13
 9949 3872 CF90      		pop r12
 9950 3874 BF90      		pop r11
 9951 3876 AF90      		pop r10
 9952 3878 9F90      		pop r9
 9953 387a 8F90      		pop r8
 9954 387c 7F90      		pop r7
 9955 387e 6F90      		pop r6
 9956 3880 5F90      		pop r5
 9957 3882 4F90      		pop r4
 9958 3884 3F90      		pop r3
 9959 3886 2F90      		pop r2
3146:switcherator.c ****         fail(0x04);
 9960               		.loc 1 3146 0
 9961 3888 0C94 0000 		jmp fail
 9962               	.LVL830:
 9963               	.L674:
3150:switcherator.c ****     tempIntString[0] = commandReceived[14];
 9964               		.loc 1 3150 0
 9965 388c AA81      		ldd r26,Y+2
 9966 388e BB81      		ldd r27,Y+3
 9967 3890 1E96      		adiw r26,14
 9968 3892 8C91      		ld r24,X
 9969 3894 1E97      		sbiw r26,14
 9970 3896 8093 0000 		sts tempIntString,r24
3151:switcherator.c ****     tempIntString[1] = commandReceived[15];
 9971               		.loc 1 3151 0
 9972 389a 1F96      		adiw r26,15
 9973 389c 8C91      		ld r24,X
 9974 389e 8093 0000 		sts tempIntString+1,r24
3152:switcherator.c ****     switchNumber = atoi(tempIntString);
 9975               		.loc 1 3152 0
 9976 38a2 80E0      		ldi r24,lo8(tempIntString)
 9977 38a4 90E0      		ldi r25,hi8(tempIntString)
 9978 38a6 0E94 0000 		call atoi
 9979               	.LVL831:
 9980 38aa 7C01      		movw r14,r24
 9981               	.LVL832:
3154:switcherator.c ****     tempIntString[0] = commandReceived[20];
 9982               		.loc 1 3154 0
 9983 38ac EA81      		ldd r30,Y+2
 9984 38ae FB81      		ldd r31,Y+3
 9985 38b0 8489      		ldd r24,Z+20
 9986 38b2 8093 0000 		sts tempIntString,r24
3155:switcherator.c ****     tempIntString[1] = commandReceived[21];
 9987               		.loc 1 3155 0
 9988 38b6 8589      		ldd r24,Z+21
 9989 38b8 8093 0000 		sts tempIntString+1,r24
3156:switcherator.c ****     pollTime = atoi(tempIntString);
 9990               		.loc 1 3156 0
 9991 38bc 80E0      		ldi r24,lo8(tempIntString)
 9992 38be 90E0      		ldi r25,hi8(tempIntString)
 9993 38c0 0E94 0000 		call atoi
 9994               	.LVL833:
 9995 38c4 782E      		mov r7,r24
 9996 38c6 892E      		mov r8,r25
 9997               	.LVL834:
3158:switcherator.c ****     tempIntString[0] = '0';
 9998               		.loc 1 3158 0
 9999 38c8 B092 0000 		sts tempIntString,r11
3159:switcherator.c ****     tempIntString[1] = commandReceived[22];
 10000               		.loc 1 3159 0
 10001 38cc AA81      		ldd r26,Y+2
 10002 38ce BB81      		ldd r27,Y+3
 10003 38d0 5696      		adiw r26,22
 10004 38d2 8C91      		ld r24,X
 10005 38d4 8093 0000 		sts tempIntString+1,r24
3160:switcherator.c ****     whichRGB = atoi(tempIntString);
 10006               		.loc 1 3160 0
 10007 38d8 80E0      		ldi r24,lo8(tempIntString)
 10008 38da 90E0      		ldi r25,hi8(tempIntString)
 10009 38dc 0E94 0000 		call atoi
 10010               	.LVL835:
 10011 38e0 982E      		mov r9,r24
 10012               	.LVL836:
3162:switcherator.c ****     tempLongString[0] = '0';
 10013               		.loc 1 3162 0
 10014 38e2 B092 0000 		sts tempLongString,r11
3163:switcherator.c ****     tempLongString[1] = commandReceived[7];
 10015               		.loc 1 3163 0
 10016 38e6 EA81      		ldd r30,Y+2
 10017 38e8 FB81      		ldd r31,Y+3
 10018 38ea 8781      		ldd r24,Z+7
 10019 38ec 8093 0000 		sts tempLongString+1,r24
3164:switcherator.c ****     tempLongString[2] = commandReceived[8];
 10020               		.loc 1 3164 0
 10021 38f0 8085      		ldd r24,Z+8
 10022 38f2 8093 0000 		sts tempLongString+2,r24
3165:switcherator.c ****     tempLongString[3] = commandReceived[9];
 10023               		.loc 1 3165 0
 10024 38f6 8185      		ldd r24,Z+9
 10025 38f8 8093 0000 		sts tempLongString+3,r24
3166:switcherator.c ****     lowPercent = atoi(tempLongString);
 10026               		.loc 1 3166 0
 10027 38fc 80E0      		ldi r24,lo8(tempLongString)
 10028 38fe 90E0      		ldi r25,hi8(tempLongString)
 10029 3900 0E94 0000 		call atoi
 10030               	.LVL837:
 10031 3904 5C01      		movw r10,r24
 10032               	.LVL838:
3167:switcherator.c ****     tempLongString[1] = commandReceived[10];
 10033               		.loc 1 3167 0
 10034 3906 AA81      		ldd r26,Y+2
 10035 3908 BB81      		ldd r27,Y+3
 10036 390a 1A96      		adiw r26,10
 10037 390c 8C91      		ld r24,X
 10038 390e 1A97      		sbiw r26,10
 10039 3910 8093 0000 		sts tempLongString+1,r24
3168:switcherator.c ****     tempLongString[2] = commandReceived[11];
 10040               		.loc 1 3168 0
 10041 3914 1B96      		adiw r26,11
 10042 3916 8C91      		ld r24,X
 10043 3918 1B97      		sbiw r26,11
 10044 391a 8093 0000 		sts tempLongString+2,r24
3169:switcherator.c ****     tempLongString[3] = commandReceived[12];
 10045               		.loc 1 3169 0
 10046 391e 1C96      		adiw r26,12
 10047 3920 8C91      		ld r24,X
 10048 3922 8093 0000 		sts tempLongString+3,r24
3170:switcherator.c ****     highPercent = atoi(tempLongString);
 10049               		.loc 1 3170 0
 10050 3926 80E0      		ldi r24,lo8(tempLongString)
 10051 3928 90E0      		ldi r25,hi8(tempLongString)
 10052 392a 0E94 0000 		call atoi
 10053               	.LVL839:
 10054 392e 2C01      		movw r4,r24
 10055               	.LVL840:
3172:switcherator.c ****     tempLongString[0] = commandReceived[16];
 10056               		.loc 1 3172 0
 10057 3930 EA81      		ldd r30,Y+2
 10058 3932 FB81      		ldd r31,Y+3
 10059 3934 8089      		ldd r24,Z+16
 10060 3936 8093 0000 		sts tempLongString,r24
3173:switcherator.c ****     tempLongString[1] = commandReceived[17];
 10061               		.loc 1 3173 0
 10062 393a 8189      		ldd r24,Z+17
 10063 393c 8093 0000 		sts tempLongString+1,r24
3174:switcherator.c ****     tempLongString[2] = commandReceived[18];
 10064               		.loc 1 3174 0
 10065 3940 8289      		ldd r24,Z+18
 10066 3942 8093 0000 		sts tempLongString+2,r24
3175:switcherator.c ****     tempLongString[3] = commandReceived[19];
 10067               		.loc 1 3175 0
 10068 3946 8389      		ldd r24,Z+19
 10069 3948 8093 0000 		sts tempLongString+3,r24
3176:switcherator.c ****     duration = atoi(tempLongString);
 10070               		.loc 1 3176 0
 10071 394c 80E0      		ldi r24,lo8(tempLongString)
 10072 394e 90E0      		ldi r25,hi8(tempLongString)
 10073 3950 0E94 0000 		call atoi
 10074               	.LVL841:
 10075 3954 682E      		mov r6,r24
 10076 3956 9983      		std Y+1,r25
 10077               	.LVL842:
3183:switcherator.c ****     if (commandReceived[5] != 'C' && commandReceived[5] != 'c') {
 10078               		.loc 1 3183 0
 10079 3958 AA81      		ldd r26,Y+2
 10080 395a BB81      		ldd r27,Y+3
 10081 395c 1596      		adiw r26,5
 10082 395e 8C91      		ld r24,X
 10083 3960 8334      		cpi r24,lo8(67)
 10084 3962 01F0      		breq .L675
3183:switcherator.c ****     if (commandReceived[5] != 'C' && commandReceived[5] != 'c') {
 10085               		.loc 1 3183 0 is_stmt 0 discriminator 1
 10086 3964 8336      		cpi r24,lo8(99)
 10087 3966 01F0      		breq .L675
3184:switcherator.c ****         fail(0x03);
 10088               		.loc 1 3184 0 is_stmt 1
 10089 3968 83E0      		ldi r24,lo8(3)
 10090 396a 90E0      		ldi r25,0
 10091 396c 00C0      		rjmp .L694
 10092               	.L675:
3194:switcherator.c ****     temp = pin * 2;
 10093               		.loc 1 3194 0
 10094 396e DD24      		clr r13
 10095               	.LVL843:
 10096 3970 C601      		movw r24,r12
 10097 3972 880F      		lsl r24
 10098 3974 991F      		rol r25
 10099 3976 AA27      		clr r26
 10100 3978 97FD      		sbrc r25,7
 10101 397a A095      		com r26
 10102 397c BA2F      		mov r27,r26
 10103               	.LVL844:
3196:switcherator.c ****     temp += 32;
 10104               		.loc 1 3196 0
 10105 397e 8096      		adiw r24,32
 10106 3980 A11D      		adc r26,__zero_reg__
 10107 3982 B11D      		adc r27,__zero_reg__
 10108               	.LVL845:
 10109 3984 E0E0      		ldi r30,lo8(switchStuff)
 10110 3986 F0E0      		ldi r31,hi8(switchStuff)
 10111               	.LVL846:
 10112               	.L677:
3198:switcherator.c ****         if (switchStuff[x] == temp) {
 10113               		.loc 1 3198 0
 10114 3988 4191      		ld r20,Z+
 10115 398a 50E0      		ldi r21,0
 10116 398c 60E0      		ldi r22,0
 10117 398e 70E0      		ldi r23,0
 10118 3990 4817      		cp r20,r24
 10119 3992 5907      		cpc r21,r25
 10120 3994 6A07      		cpc r22,r26
 10121 3996 7B07      		cpc r23,r27
 10122 3998 01F4      		brne .L676
3200:switcherator.c ****             fail(0x12);
 10123               		.loc 1 3200 0
 10124 399a 82E1      		ldi r24,lo8(18)
 10125 399c 90E0      		ldi r25,0
 10126               	.LVL847:
 10127 399e 00C0      		rjmp .L694
 10128               	.LVL848:
 10129               	.L676:
3197:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 10130               		.loc 1 3197 0
 10131 39a0 20E0      		ldi r18,hi8(switchStuff+16)
 10132 39a2 E030      		cpi r30,lo8(switchStuff+16)
 10133 39a4 F207      		cpc r31,r18
 10134 39a6 01F4      		brne .L677
3204:switcherator.c ****     inputs[inputNumber][0] = temp;
 10135               		.loc 1 3204 0
 10136 39a8 93E0      		ldi r25,3
 10137               		1:
 10138 39aa 000F      		lsl r16
 10139 39ac 111F      		rol r17
 10140 39ae 9A95      		dec r25
 10141 39b0 01F4      		brne 1b
 10142               	.LVL849:
 10143 39b2 20E0      		ldi r18,lo8(inputs)
 10144 39b4 222E      		mov r2,r18
 10145 39b6 20E0      		ldi r18,hi8(inputs)
 10146 39b8 322E      		mov r3,r18
 10147 39ba 200E      		add r2,r16
 10148 39bc 311E      		adc r3,r17
 10149 39be F101      		movw r30,r2
 10150 39c0 8083      		st Z,r24
3205:switcherator.c ****     DDRC &= ~(1 << pin);
 10151               		.loc 1 3205 0
 10152 39c2 27B1      		in r18,0x7
 10153 39c4 81E0      		ldi r24,lo8(1)
 10154 39c6 90E0      		ldi r25,0
 10155               	.LVL850:
 10156 39c8 00C0      		rjmp 2f
 10157               		1:
 10158 39ca 880F      		lsl r24
 10159               		2:
 10160 39cc CA94      		dec r12
 10161 39ce 02F4      		brpl 1b
 10162 39d0 8095      		com r24
 10163 39d2 8223      		and r24,r18
 10164 39d4 87B9      		out 0x7,r24
 10165               	.LVL851:
3207:switcherator.c ****     temp = temp * 255;
 10166               		.loc 1 3207 0
 10167 39d6 2FEF      		ldi r18,lo8(-1)
 10168 39d8 30E0      		ldi r19,0
 10169 39da D501      		movw r26,r10
 10170 39dc 0E94 0000 		call __usmulhisi3
 10171               	.LVL852:
3208:switcherator.c ****     temp = temp / 100;
 10172               		.loc 1 3208 0
 10173 39e0 34E6      		ldi r19,lo8(100)
 10174 39e2 A32E      		mov r10,r19
 10175 39e4 B12C      		mov r11,__zero_reg__
 10176 39e6 C12C      		mov r12,__zero_reg__
 10177 39e8 D12C      		mov r13,__zero_reg__
 10178               	.LVL853:
 10179 39ea A601      		movw r20,r12
 10180 39ec 9501      		movw r18,r10
 10181 39ee 0E94 0000 		call __divmodsi4
 10182               	.LVL854:
3209:switcherator.c ****     inputs[inputNumber][1] = temp;
 10183               		.loc 1 3209 0
 10184 39f2 D101      		movw r26,r2
 10185 39f4 1196      		adiw r26,1
 10186 39f6 2C93      		st X,r18
 10187               	.LVL855:
3211:switcherator.c ****     temp = temp * 255;
 10188               		.loc 1 3211 0
 10189 39f8 2FEF      		ldi r18,lo8(-1)
 10190 39fa 30E0      		ldi r19,0
 10191 39fc D201      		movw r26,r4
 10192 39fe 0E94 0000 		call __usmulhisi3
 10193               	.LVL856:
3212:switcherator.c ****     temp = temp / 100;
 10194               		.loc 1 3212 0
 10195 3a02 A601      		movw r20,r12
 10196 3a04 9501      		movw r18,r10
 10197 3a06 0E94 0000 		call __divmodsi4
 10198               	.LVL857:
3213:switcherator.c ****     if (temp == 255) // if the top is 255 we need it to be 254 so its not digital
 10199               		.loc 1 3213 0
 10200 3a0a 2F3F      		cpi r18,-1
 10201 3a0c 3105      		cpc r19,__zero_reg__
 10202 3a0e 4105      		cpc r20,__zero_reg__
 10203 3a10 5105      		cpc r21,__zero_reg__
 10204 3a12 01F4      		brne .L678
3214:switcherator.c ****         temp = 254;
 10205               		.loc 1 3214 0
 10206 3a14 2EEF      		ldi r18,lo8(-2)
 10207 3a16 30E0      		ldi r19,0
 10208 3a18 40E0      		ldi r20,0
 10209 3a1a 50E0      		ldi r21,0
 10210               	.LVL858:
 10211               	.L678:
3216:switcherator.c ****     inputs[inputNumber][2] = temp;
 10212               		.loc 1 3216 0
 10213 3a1c F801      		movw r30,r16
 10214 3a1e E050      		subi r30,lo8(-(inputs))
 10215 3a20 F040      		sbci r31,hi8(-(inputs))
 10216 3a22 2283      		std Z+2,r18
3218:switcherator.c ****     if (commandReceived[13] == 'P' || commandReceived[13] == 'p') {
 10217               		.loc 1 3218 0
 10218 3a24 EA81      		ldd r30,Y+2
 10219 3a26 FB81      		ldd r31,Y+3
 10220 3a28 8585      		ldd r24,Z+13
 10221 3a2a 8035      		cpi r24,lo8(80)
 10222 3a2c 01F0      		breq .L679
3218:switcherator.c ****     if (commandReceived[13] == 'P' || commandReceived[13] == 'p') {
 10223               		.loc 1 3218 0 is_stmt 0 discriminator 1
 10224 3a2e 8037      		cpi r24,lo8(112)
 10225 3a30 01F4      		brne .L680
 10226               	.L679:
3219:switcherator.c ****         switchNumber += 128;
 10227               		.loc 1 3219 0 is_stmt 1
 10228 3a32 F0E8      		ldi r31,-128
 10229 3a34 EF0E      		add r14,r31
 10230 3a36 F11C      		adc r15,__zero_reg__
 10231               	.LVL859:
 10232               	.L680:
3221:switcherator.c ****     inputs[inputNumber][3] = switchNumber;
 10233               		.loc 1 3221 0
 10234 3a38 F801      		movw r30,r16
 10235 3a3a E050      		subi r30,lo8(-(inputs))
 10236 3a3c F040      		sbci r31,hi8(-(inputs))
 10237 3a3e E382      		std Z+3,r14
 10238               	.LVL860:
3223:switcherator.c ****     inputs[inputNumber][4] = temp;
 10239               		.loc 1 3223 0
 10240 3a40 2981      		ldd r18,Y+1
 10241 3a42 2483      		std Z+4,r18
 10242               	.LVL861:
3225:switcherator.c ****     inputs[inputNumber][5] = temp;
 10243               		.loc 1 3225 0
 10244 3a44 6582      		std Z+5,r6
 10245               	.LVL862:
3230:switcherator.c ****     inputs[inputNumber][6] = pollTime;
 10246               		.loc 1 3230 0
 10247 3a46 872D      		mov r24,r7
 10248 3a48 982D      		mov r25,r8
 10249 3a4a 8F3F      		cpi r24,-1
 10250 3a4c 9105      		cpc r25,__zero_reg__
 10251 3a4e 01F0      		breq .L681
 10252 3a50 04F0      		brlt .L681
 10253 3a52 8FEF      		ldi r24,lo8(-1)
 10254 3a54 90E0      		ldi r25,0
 10255               	.L681:
 10256 3a56 8683      		std Z+6,r24
 10257               	.LVL863:
3235:switcherator.c ****     inputs[inputNumber][7] = whichRGB;
 10258               		.loc 1 3235 0
 10259 3a58 F801      		movw r30,r16
 10260 3a5a E050      		subi r30,lo8(-(inputs))
 10261 3a5c F040      		sbci r31,hi8(-(inputs))
 10262 3a5e 892D      		mov r24,r9
 10263 3a60 8830      		cpi r24,lo8(8)
 10264 3a62 00F0      		brlo .L682
 10265 3a64 87E0      		ldi r24,lo8(7)
 10266               	.L682:
 10267 3a66 8783      		std Z+7,r24
3240:switcherator.c ****     ADCSRA |= (1 << ADPS2) || (1 << ADPS0);
 10268               		.loc 1 3240 0
 10269 3a68 8091 7A00 		lds r24,122
 10270 3a6c 8160      		ori r24,lo8(1)
 10271 3a6e 8093 7A00 		sts 122,r24
 10272               	/* epilogue start */
3244:switcherator.c **** }
 10273               		.loc 1 3244 0
 10274 3a72 0F90      		pop __tmp_reg__
 10275 3a74 0F90      		pop __tmp_reg__
 10276 3a76 0F90      		pop __tmp_reg__
 10277 3a78 DF91      		pop r29
 10278 3a7a CF91      		pop r28
 10279 3a7c 1F91      		pop r17
 10280 3a7e 0F91      		pop r16
 10281 3a80 FF90      		pop r15
 10282 3a82 EF90      		pop r14
 10283 3a84 DF90      		pop r13
 10284 3a86 CF90      		pop r12
 10285 3a88 BF90      		pop r11
 10286 3a8a AF90      		pop r10
 10287 3a8c 9F90      		pop r9
 10288               	.LVL864:
 10289 3a8e 8F90      		pop r8
 10290               	.LVL865:
 10291 3a90 7F90      		pop r7
 10292               	.LVL866:
 10293 3a92 6F90      		pop r6
 10294               	.LVL867:
 10295 3a94 5F90      		pop r5
 10296 3a96 4F90      		pop r4
 10297               	.LVL868:
 10298 3a98 3F90      		pop r3
 10299 3a9a 2F90      		pop r2
3243:switcherator.c ****     ok();
 10300               		.loc 1 3243 0
 10301 3a9c 0C94 0000 		jmp ok
 10302               	.LVL869:
 10303               	.LFE78:
 10305               	.global	startProgram
 10307               	startProgram:
 10308               	.LFB39:
1652:switcherator.c **** void startProgram(char * commandReceived) {
 10309               		.loc 1 1652 0
 10310               	.LVL870:
 10311 3aa0 0F93      		push r16
 10312               	.LCFI254:
 10313 3aa2 1F93      		push r17
 10314               	.LCFI255:
 10315 3aa4 CF93      		push r28
 10316               	.LCFI256:
 10317 3aa6 DF93      		push r29
 10318               	.LCFI257:
 10319               	/* prologue: function */
 10320               	/* frame size = 0 */
 10321               	/* stack size = 4 */
 10322               	.L__stack_usage = 4
 10323 3aa8 EC01      		movw r28,r24
 10324               	.LVL871:
1656:switcherator.c ****     tempIntString[0] = commandReceived[3];
 10325               		.loc 1 1656 0
 10326 3aaa 8B81      		ldd r24,Y+3
 10327               	.LVL872:
 10328 3aac 8093 0000 		sts tempIntString,r24
1657:switcherator.c ****     tempIntString[1] = commandReceived[4];
 10329               		.loc 1 1657 0
 10330 3ab0 8C81      		ldd r24,Y+4
 10331 3ab2 8093 0000 		sts tempIntString+1,r24
1658:switcherator.c ****     programNumber = atoi(tempIntString);
 10332               		.loc 1 1658 0
 10333 3ab6 80E0      		ldi r24,lo8(tempIntString)
 10334 3ab8 90E0      		ldi r25,hi8(tempIntString)
 10335 3aba 0E94 0000 		call atoi
 10336               	.LVL873:
 10337 3abe 8C01      		movw r16,r24
 10338               	.LVL874:
1659:switcherator.c ****     if (programNumber >= MAX_PROGRAM) {
 10339               		.loc 1 1659 0
 10340 3ac0 8A30      		cpi r24,10
 10341 3ac2 9105      		cpc r25,__zero_reg__
 10342 3ac4 04F0      		brlt .L696
1660:switcherator.c ****         fail(2);
 10343               		.loc 1 1660 0
 10344 3ac6 82E0      		ldi r24,lo8(2)
 10345 3ac8 90E0      		ldi r25,0
 10346               	/* epilogue start */
1673:switcherator.c **** }
 10347               		.loc 1 1673 0
 10348 3aca DF91      		pop r29
 10349 3acc CF91      		pop r28
 10350               	.LVL875:
 10351 3ace 1F91      		pop r17
 10352 3ad0 0F91      		pop r16
 10353               	.LVL876:
1660:switcherator.c ****         fail(2);
 10354               		.loc 1 1660 0
 10355 3ad2 0C94 0000 		jmp fail
 10356               	.LVL877:
 10357               	.L696:
1664:switcherator.c ****     tempHugeString[0] = commandReceived[5];
 10358               		.loc 1 1664 0
 10359 3ad6 8D81      		ldd r24,Y+5
 10360 3ad8 8093 0000 		sts tempHugeString,r24
1665:switcherator.c ****     tempHugeString[1] = commandReceived[6];
 10361               		.loc 1 1665 0
 10362 3adc 8E81      		ldd r24,Y+6
 10363 3ade 8093 0000 		sts tempHugeString+1,r24
1666:switcherator.c ****     tempHugeString[2] = commandReceived[7];
 10364               		.loc 1 1666 0
 10365 3ae2 8F81      		ldd r24,Y+7
 10366 3ae4 8093 0000 		sts tempHugeString+2,r24
1667:switcherator.c ****     tempHugeString[3] = commandReceived[8];
 10367               		.loc 1 1667 0
 10368 3ae8 8885      		ldd r24,Y+8
 10369 3aea 8093 0000 		sts tempHugeString+3,r24
1668:switcherator.c ****     tempHugeString[4] = commandReceived[9];
 10370               		.loc 1 1668 0
 10371 3aee 8985      		ldd r24,Y+9
 10372 3af0 8093 0000 		sts tempHugeString+4,r24
1669:switcherator.c ****     tempHugeString[5] = commandReceived[10];
 10373               		.loc 1 1669 0
 10374 3af4 8A85      		ldd r24,Y+10
 10375 3af6 8093 0000 		sts tempHugeString+5,r24
1670:switcherator.c ****     duration = atol(tempHugeString);
 10376               		.loc 1 1670 0
 10377 3afa 80E0      		ldi r24,lo8(tempHugeString)
 10378 3afc 90E0      		ldi r25,hi8(tempHugeString)
 10379 3afe 0E94 0000 		call atol
 10380               	.LVL878:
1671:switcherator.c ****     startTheProgram(programNumber, duration, 0);
 10381               		.loc 1 1671 0
 10382 3b02 20E0      		ldi r18,0
 10383 3b04 30E0      		ldi r19,0
 10384 3b06 A901      		movw r20,r18
 10385 3b08 C801      		movw r24,r16
 10386 3b0a 0E94 0000 		call startTheProgram
 10387               	.LVL879:
 10388               	/* epilogue start */
1673:switcherator.c **** }
 10389               		.loc 1 1673 0
 10390 3b0e DF91      		pop r29
 10391 3b10 CF91      		pop r28
 10392               	.LVL880:
 10393 3b12 1F91      		pop r17
 10394 3b14 0F91      		pop r16
 10395               	.LVL881:
1672:switcherator.c ****     ok();
 10396               		.loc 1 1672 0
 10397 3b16 0C94 0000 		jmp ok
 10398               	.LVL882:
 10399               	.LFE39:
 10401               	.global	programSetTime
 10403               	programSetTime:
 10404               	.LFB36:
1457:switcherator.c **** void programSetTime(char * commandReceived) {
 10405               		.loc 1 1457 0
 10406               	.LVL883:
 10407 3b1a AF92      		push r10
 10408               	.LCFI258:
 10409 3b1c BF92      		push r11
 10410               	.LCFI259:
 10411 3b1e CF92      		push r12
 10412               	.LCFI260:
 10413 3b20 DF92      		push r13
 10414               	.LCFI261:
 10415 3b22 EF92      		push r14
 10416               	.LCFI262:
 10417 3b24 FF92      		push r15
 10418               	.LCFI263:
 10419 3b26 0F93      		push r16
 10420               	.LCFI264:
 10421 3b28 1F93      		push r17
 10422               	.LCFI265:
 10423 3b2a CF93      		push r28
 10424               	.LCFI266:
 10425 3b2c DF93      		push r29
 10426               	.LCFI267:
 10427               	/* prologue: function */
 10428               	/* frame size = 0 */
 10429               	/* stack size = 10 */
 10430               	.L__stack_usage = 10
 10431 3b2e EC01      		movw r28,r24
 10432               	.LVL884:
1463:switcherator.c ****     tempIntString[0] = commandReceived[3];
 10433               		.loc 1 1463 0
 10434 3b30 8B81      		ldd r24,Y+3
 10435               	.LVL885:
 10436 3b32 8093 0000 		sts tempIntString,r24
1464:switcherator.c ****     tempIntString[1] = commandReceived[4];
 10437               		.loc 1 1464 0
 10438 3b36 FC80      		ldd r15,Y+4
 10439 3b38 F092 0000 		sts tempIntString+1,r15
1465:switcherator.c ****     programNumber = atoi(tempIntString);
 10440               		.loc 1 1465 0
 10441 3b3c 80E0      		ldi r24,lo8(tempIntString)
 10442 3b3e 90E0      		ldi r25,hi8(tempIntString)
 10443 3b40 0E94 0000 		call atoi
 10444               	.LVL886:
 10445 3b44 8C01      		movw r16,r24
 10446               	.LVL887:
1466:switcherator.c ****     if (programNumber >= MAX_PROGRAM || (programNumber == 0 && commandReceived[4] != '0')) {
 10447               		.loc 1 1466 0
 10448 3b46 8A30      		cpi r24,10
 10449 3b48 9105      		cpc r25,__zero_reg__
 10450 3b4a 04F4      		brge .L698
1466:switcherator.c ****     if (programNumber >= MAX_PROGRAM || (programNumber == 0 && commandReceived[4] != '0')) {
 10451               		.loc 1 1466 0 is_stmt 0 discriminator 1
 10452 3b4c 0097      		sbiw r24,0
 10453 3b4e 01F4      		brne .L699
 10454 3b50 20E3      		ldi r18,lo8(48)
 10455 3b52 F216      		cp r15,r18
 10456 3b54 01F0      		breq .L699
 10457               	.L698:
1467:switcherator.c ****         fail(2);
 10458               		.loc 1 1467 0 is_stmt 1
 10459 3b56 82E0      		ldi r24,lo8(2)
 10460 3b58 90E0      		ldi r25,0
 10461 3b5a 00C0      		rjmp .L715
 10462               	.L699:
1474:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 10463               		.loc 1 1474 0
 10464 3b5c 8AE0      		ldi r24,lo8(10)
 10465 3b5e 809F      		mul r24,r16
 10466 3b60 F001      		movw r30,r0
 10467 3b62 819F      		mul r24,r17
 10468 3b64 F00D      		add r31,r0
 10469 3b66 1124      		clr __zero_reg__
 10470 3b68 E050      		subi r30,lo8(-(weeklyProgram))
 10471 3b6a F040      		sbci r31,hi8(-(weeklyProgram))
 10472 3b6c 8081      		ld r24,Z
 10473 3b6e 8F3F      		cpi r24,lo8(-1)
 10474 3b70 01F4      		brne .L700
1474:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 10475               		.loc 1 1474 0 is_stmt 0 discriminator 1
 10476 3b72 8181      		ldd r24,Z+1
 10477 3b74 8F3F      		cpi r24,lo8(-1)
 10478 3b76 01F4      		brne .L700
1475:switcherator.c ****         fail(0x0d);
 10479               		.loc 1 1475 0 is_stmt 1
 10480 3b78 8DE0      		ldi r24,lo8(13)
 10481 3b7a 90E0      		ldi r25,0
 10482               	.LVL888:
 10483               	.L715:
 10484               	/* epilogue start */
1514:switcherator.c **** }
 10485               		.loc 1 1514 0
 10486 3b7c DF91      		pop r29
 10487 3b7e CF91      		pop r28
 10488               	.LVL889:
 10489 3b80 1F91      		pop r17
 10490 3b82 0F91      		pop r16
 10491               	.LVL890:
 10492 3b84 FF90      		pop r15
 10493 3b86 EF90      		pop r14
 10494 3b88 DF90      		pop r13
 10495 3b8a CF90      		pop r12
 10496 3b8c BF90      		pop r11
 10497 3b8e AF90      		pop r10
1475:switcherator.c ****         fail(0x0d);
 10498               		.loc 1 1475 0
 10499 3b90 0C94 0000 		jmp fail
 10500               	.LVL891:
 10501               	.L700:
1478:switcherator.c ****     tempIntString[0] = commandReceived[5];
 10502               		.loc 1 1478 0
 10503 3b94 8D81      		ldd r24,Y+5
 10504 3b96 8093 0000 		sts tempIntString,r24
1479:switcherator.c ****     tempIntString[1] = commandReceived[6];
 10505               		.loc 1 1479 0
 10506 3b9a AE80      		ldd r10,Y+6
 10507 3b9c A092 0000 		sts tempIntString+1,r10
1480:switcherator.c ****     hours = atoi(tempIntString);
 10508               		.loc 1 1480 0
 10509 3ba0 80E0      		ldi r24,lo8(tempIntString)
 10510 3ba2 90E0      		ldi r25,hi8(tempIntString)
 10511 3ba4 0E94 0000 		call atoi
 10512               	.LVL892:
 10513 3ba8 6C01      		movw r12,r24
 10514               	.LVL893:
1481:switcherator.c ****     tempIntString[0] = commandReceived[7];
 10515               		.loc 1 1481 0
 10516 3baa 8F81      		ldd r24,Y+7
 10517 3bac 8093 0000 		sts tempIntString,r24
1482:switcherator.c ****     tempIntString[1] = commandReceived[8];
 10518               		.loc 1 1482 0
 10519 3bb0 B884      		ldd r11,Y+8
 10520 3bb2 B092 0000 		sts tempIntString+1,r11
1483:switcherator.c ****     minutes = atoi(tempIntString);
 10521               		.loc 1 1483 0
 10522 3bb6 80E0      		ldi r24,lo8(tempIntString)
 10523 3bb8 90E0      		ldi r25,hi8(tempIntString)
 10524 3bba 0E94 0000 		call atoi
 10525               	.LVL894:
 10526 3bbe 7C01      		movw r14,r24
 10527               	.LVL895:
1484:switcherator.c ****     tempLongString[0] = commandReceived[9];
 10528               		.loc 1 1484 0
 10529 3bc0 8985      		ldd r24,Y+9
 10530 3bc2 8093 0000 		sts tempLongString,r24
1485:switcherator.c ****     tempLongString[1] = commandReceived[10];
 10531               		.loc 1 1485 0
 10532 3bc6 8A85      		ldd r24,Y+10
 10533 3bc8 8093 0000 		sts tempLongString+1,r24
1486:switcherator.c ****     tempLongString[2] = commandReceived[11];
 10534               		.loc 1 1486 0
 10535 3bcc 8B85      		ldd r24,Y+11
 10536 3bce 8093 0000 		sts tempLongString+2,r24
1487:switcherator.c ****     tempLongString[3] = commandReceived[12];
 10537               		.loc 1 1487 0
 10538 3bd2 8C85      		ldd r24,Y+12
 10539 3bd4 8093 0000 		sts tempLongString+3,r24
1488:switcherator.c ****     duration = atoi(tempLongString);
 10540               		.loc 1 1488 0
 10541 3bd8 80E0      		ldi r24,lo8(tempLongString)
 10542 3bda 90E0      		ldi r25,hi8(tempLongString)
 10543 3bdc 0E94 0000 		call atoi
 10544               	.LVL896:
1489:switcherator.c ****     if (hours >= 24 || (hours == 0 && commandReceived[6] != '0')) {
 10545               		.loc 1 1489 0
 10546 3be0 28E1      		ldi r18,24
 10547 3be2 C216      		cp r12,r18
 10548 3be4 D104      		cpc r13,__zero_reg__
 10549 3be6 04F4      		brge .L701
1489:switcherator.c ****     if (hours >= 24 || (hours == 0 && commandReceived[6] != '0')) {
 10550               		.loc 1 1489 0 is_stmt 0 discriminator 1
 10551 3be8 C114      		cp r12,__zero_reg__
 10552 3bea D104      		cpc r13,__zero_reg__
 10553 3bec 01F4      		brne .L702
 10554 3bee 20E3      		ldi r18,lo8(48)
 10555 3bf0 A216      		cp r10,r18
 10556 3bf2 01F0      		breq .L702
 10557               	.L701:
1490:switcherator.c ****         fail(9);
 10558               		.loc 1 1490 0 is_stmt 1
 10559 3bf4 89E0      		ldi r24,lo8(9)
 10560 3bf6 90E0      		ldi r25,0
 10561               	.LVL897:
 10562 3bf8 00C0      		rjmp .L715
 10563               	.LVL898:
 10564               	.L702:
1493:switcherator.c ****     if (minutes >= 60 || (minutes == 0 && commandReceived[8] != '0')) {
 10565               		.loc 1 1493 0
 10566 3bfa 2CE3      		ldi r18,60
 10567 3bfc E216      		cp r14,r18
 10568 3bfe F104      		cpc r15,__zero_reg__
 10569 3c00 04F4      		brge .L703
1493:switcherator.c ****     if (minutes >= 60 || (minutes == 0 && commandReceived[8] != '0')) {
 10570               		.loc 1 1493 0 is_stmt 0 discriminator 1
 10571 3c02 E114      		cp r14,__zero_reg__
 10572 3c04 F104      		cpc r15,__zero_reg__
 10573 3c06 01F4      		brne .L704
 10574 3c08 20E3      		ldi r18,lo8(48)
 10575 3c0a B216      		cp r11,r18
 10576 3c0c 01F0      		breq .L704
 10577               	.L703:
1494:switcherator.c ****         fail(0x0a);
 10578               		.loc 1 1494 0 is_stmt 1
 10579 3c0e 8AE0      		ldi r24,lo8(10)
 10580 3c10 90E0      		ldi r25,0
 10581               	.LVL899:
 10582 3c12 00C0      		rjmp .L715
 10583               	.LVL900:
 10584               	.L704:
1497:switcherator.c ****     if (duration == 0) {
 10585               		.loc 1 1497 0
 10586 3c14 0097      		sbiw r24,0
 10587 3c16 01F4      		brne .L705
1498:switcherator.c ****         fail(0x0b);
 10588               		.loc 1 1498 0
 10589 3c18 8BE0      		ldi r24,lo8(11)
 10590 3c1a 90E0      		ldi r25,0
 10591               	.LVL901:
 10592 3c1c 00C0      		rjmp .L715
 10593               	.LVL902:
 10594               	.L705:
1501:switcherator.c ****     duration *= 60; // convert to seconds
 10595               		.loc 1 1501 0
 10596 3c1e 6CE3      		ldi r22,lo8(60)
 10597 3c20 689F      		mul r22,r24
 10598 3c22 A001      		movw r20,r0
 10599 3c24 699F      		mul r22,r25
 10600 3c26 500D      		add r21,r0
 10601 3c28 1124      		clr __zero_reg__
 10602               	.LVL903:
1502:switcherator.c ****     startTime = (hours * 60);
 10603               		.loc 1 1502 0
 10604 3c2a 6C9D      		mul r22,r12
 10605 3c2c 9001      		movw r18,r0
 10606 3c2e 6D9D      		mul r22,r13
 10607 3c30 300D      		add r19,r0
 10608 3c32 1124      		clr __zero_reg__
 10609               	.LVL904:
1503:switcherator.c ****     startTime += minutes; // stored in minutes
 10610               		.loc 1 1503 0
 10611 3c34 2E0D      		add r18,r14
 10612 3c36 3F1D      		adc r19,r15
 10613               	.LVL905:
1506:switcherator.c ****     weeklyProgram[programNumber][1] = temp;
 10614               		.loc 1 1506 0
 10615 3c38 8AE0      		ldi r24,lo8(10)
 10616 3c3a 809F      		mul r24,r16
 10617 3c3c F001      		movw r30,r0
 10618 3c3e 819F      		mul r24,r17
 10619 3c40 F00D      		add r31,r0
 10620 3c42 1124      		clr __zero_reg__
 10621 3c44 E050      		subi r30,lo8(-(weeklyProgram))
 10622 3c46 F040      		sbci r31,hi8(-(weeklyProgram))
 10623 3c48 3183      		std Z+1,r19
 10624               	.LVL906:
1508:switcherator.c ****     weeklyProgram[programNumber][2] = temp;
 10625               		.loc 1 1508 0
 10626 3c4a 2283      		std Z+2,r18
 10627               	.LVL907:
1510:switcherator.c ****     weeklyProgram[programNumber][3] = temp;
 10628               		.loc 1 1510 0
 10629 3c4c 5383      		std Z+3,r21
 10630               	.LVL908:
1511:switcherator.c ****     temp = (duration & 0xff);
 10631               		.loc 1 1511 0
 10632 3c4e 5527      		clr r21
 10633               	.LVL909:
1512:switcherator.c ****     weeklyProgram[programNumber][4] = temp;
 10634               		.loc 1 1512 0
 10635 3c50 4483      		std Z+4,r20
 10636               	/* epilogue start */
1514:switcherator.c **** }
 10637               		.loc 1 1514 0
 10638 3c52 DF91      		pop r29
 10639 3c54 CF91      		pop r28
 10640               	.LVL910:
 10641 3c56 1F91      		pop r17
 10642 3c58 0F91      		pop r16
 10643               	.LVL911:
 10644 3c5a FF90      		pop r15
 10645 3c5c EF90      		pop r14
 10646               	.LVL912:
 10647 3c5e DF90      		pop r13
 10648 3c60 CF90      		pop r12
 10649               	.LVL913:
 10650 3c62 BF90      		pop r11
 10651 3c64 AF90      		pop r10
1513:switcherator.c ****     ok();
 10652               		.loc 1 1513 0
 10653 3c66 0C94 0000 		jmp ok
 10654               	.LVL914:
 10655               	.LFE36:
 10657               		.section	.rodata.str1.1
 10658               	.LC71:
 10659 0158 3030 3030 		.string	"0000000"
 10659      3030 3000 
 10660               		.text
 10661               	.global	programSetDays
 10663               	programSetDays:
 10664               	.LFB35:
1416:switcherator.c **** void programSetDays(char * commandReceived) {
 10665               		.loc 1 1416 0
 10666               	.LVL915:
 10667 3c6a EF92      		push r14
 10668               	.LCFI268:
 10669 3c6c FF92      		push r15
 10670               	.LCFI269:
 10671 3c6e 0F93      		push r16
 10672               	.LCFI270:
 10673 3c70 1F93      		push r17
 10674               	.LCFI271:
 10675 3c72 CF93      		push r28
 10676               	.LCFI272:
 10677 3c74 DF93      		push r29
 10678               	.LCFI273:
 10679 3c76 CDB7      		in r28,__SP_L__
 10680 3c78 DEB7      		in r29,__SP_H__
 10681               	.LCFI274:
 10682 3c7a 2897      		sbiw r28,8
 10683               	.LCFI275:
 10684 3c7c 0FB6      		in __tmp_reg__,__SREG__
 10685 3c7e F894      		cli
 10686 3c80 DEBF      		out __SP_H__,r29
 10687 3c82 0FBE      		out __SREG__,__tmp_reg__
 10688 3c84 CDBF      		out __SP_L__,r28
 10689               	/* prologue: function */
 10690               	/* frame size = 8 */
 10691               	/* stack size = 14 */
 10692               	.L__stack_usage = 14
 10693 3c86 7C01      		movw r14,r24
1417:switcherator.c ****     char tempReallyLongString[] = "0000000";
 10694               		.loc 1 1417 0
 10695 3c88 88E0      		ldi r24,lo8(8)
 10696               	.LVL916:
 10697 3c8a E0E0      		ldi r30,lo8(.LC71)
 10698 3c8c F0E0      		ldi r31,hi8(.LC71)
 10699 3c8e DE01      		movw r26,r28
 10700 3c90 1196      		adiw r26,1
 10701               		0:
 10702 3c92 0190      		ld r0,Z+
 10703 3c94 0D92      		st X+,r0
 10704 3c96 8A95      		dec r24
 10705 3c98 01F4      		brne 0b
 10706               	.LVL917:
1420:switcherator.c ****     tempIntString[0] = commandReceived[3];
 10707               		.loc 1 1420 0
 10708 3c9a F701      		movw r30,r14
 10709 3c9c 8381      		ldd r24,Z+3
 10710 3c9e 8093 0000 		sts tempIntString,r24
1421:switcherator.c ****     tempIntString[1] = commandReceived[4];
 10711               		.loc 1 1421 0
 10712 3ca2 8481      		ldd r24,Z+4
 10713 3ca4 8093 0000 		sts tempIntString+1,r24
1422:switcherator.c ****     programNumber = atoi(tempIntString);
 10714               		.loc 1 1422 0
 10715 3ca8 80E0      		ldi r24,lo8(tempIntString)
 10716 3caa 90E0      		ldi r25,hi8(tempIntString)
 10717 3cac 0E94 0000 		call atoi
 10718               	.LVL918:
 10719 3cb0 8C01      		movw r16,r24
 10720               	.LVL919:
1423:switcherator.c ****     tempReallyLongString[0] = commandReceived[5];
 10721               		.loc 1 1423 0
 10722 3cb2 F701      		movw r30,r14
 10723 3cb4 8581      		ldd r24,Z+5
 10724 3cb6 8983      		std Y+1,r24
1424:switcherator.c ****     tempReallyLongString[1] = commandReceived[6];
 10725               		.loc 1 1424 0
 10726 3cb8 8681      		ldd r24,Z+6
 10727 3cba 8A83      		std Y+2,r24
1425:switcherator.c ****     tempReallyLongString[2] = commandReceived[7];
 10728               		.loc 1 1425 0
 10729 3cbc 8781      		ldd r24,Z+7
 10730 3cbe 8B83      		std Y+3,r24
1426:switcherator.c ****     tempReallyLongString[3] = commandReceived[8];
 10731               		.loc 1 1426 0
 10732 3cc0 8085      		ldd r24,Z+8
 10733 3cc2 8C83      		std Y+4,r24
1427:switcherator.c ****     tempReallyLongString[4] = commandReceived[9];
 10734               		.loc 1 1427 0
 10735 3cc4 8185      		ldd r24,Z+9
 10736 3cc6 8D83      		std Y+5,r24
1428:switcherator.c ****     tempReallyLongString[5] = commandReceived[10];
 10737               		.loc 1 1428 0
 10738 3cc8 8285      		ldd r24,Z+10
 10739 3cca 8E83      		std Y+6,r24
1429:switcherator.c ****     tempReallyLongString[6] = commandReceived[11];
 10740               		.loc 1 1429 0
 10741 3ccc 8385      		ldd r24,Z+11
 10742 3cce 8F83      		std Y+7,r24
1430:switcherator.c ****     weekLong = strtol(tempReallyLongString, 0, 2);
 10743               		.loc 1 1430 0
 10744 3cd0 42E0      		ldi r20,lo8(2)
 10745 3cd2 50E0      		ldi r21,0
 10746 3cd4 60E0      		ldi r22,0
 10747 3cd6 70E0      		ldi r23,0
 10748 3cd8 CE01      		movw r24,r28
 10749 3cda 0196      		adiw r24,1
 10750 3cdc 0E94 0000 		call strtol
 10751               	.LVL920:
1431:switcherator.c ****     if ((programNumber >= MAX_PROGRAM) || (programNumber == 0 && commandReceived[4] != '0')) {
 10752               		.loc 1 1431 0
 10753 3ce0 0A30      		cpi r16,10
 10754 3ce2 1105      		cpc r17,__zero_reg__
 10755 3ce4 04F4      		brge .L717
1431:switcherator.c ****     if ((programNumber >= MAX_PROGRAM) || (programNumber == 0 && commandReceived[4] != '0')) {
 10756               		.loc 1 1431 0 is_stmt 0 discriminator 1
 10757 3ce6 0115      		cp r16,__zero_reg__
 10758 3ce8 1105      		cpc r17,__zero_reg__
 10759 3cea 01F4      		brne .L718
 10760 3cec F701      		movw r30,r14
 10761 3cee 2481      		ldd r18,Z+4
 10762 3cf0 2033      		cpi r18,lo8(48)
 10763 3cf2 01F0      		breq .L718
 10764               	.L717:
1432:switcherator.c ****         fail(2);
 10765               		.loc 1 1432 0 is_stmt 1
 10766 3cf4 82E0      		ldi r24,lo8(2)
 10767 3cf6 90E0      		ldi r25,0
 10768 3cf8 00C0      		rjmp .L726
 10769               	.L718:
1439:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 10770               		.loc 1 1439 0
 10771 3cfa 2AE0      		ldi r18,lo8(10)
 10772 3cfc 209F      		mul r18,r16
 10773 3cfe F001      		movw r30,r0
 10774 3d00 219F      		mul r18,r17
 10775 3d02 F00D      		add r31,r0
 10776 3d04 1124      		clr __zero_reg__
 10777 3d06 E050      		subi r30,lo8(-(weeklyProgram))
 10778 3d08 F040      		sbci r31,hi8(-(weeklyProgram))
 10779 3d0a 2081      		ld r18,Z
 10780 3d0c 2F3F      		cpi r18,lo8(-1)
 10781 3d0e 01F4      		brne .L720
1439:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 10782               		.loc 1 1439 0 is_stmt 0 discriminator 1
 10783 3d10 2181      		ldd r18,Z+1
 10784 3d12 2F3F      		cpi r18,lo8(-1)
 10785 3d14 01F4      		brne .L720
1440:switcherator.c ****         fail(0x0d);
 10786               		.loc 1 1440 0 is_stmt 1
 10787 3d16 8DE0      		ldi r24,lo8(13)
 10788 3d18 90E0      		ldi r25,0
 10789 3d1a 00C0      		rjmp .L726
 10790               	.L720:
1443:switcherator.c ****     if ((weekLong & 0x7f) == 0) {
 10791               		.loc 1 1443 0
 10792 3d1c AB01      		movw r20,r22
 10793 3d1e BC01      		movw r22,r24
 10794 3d20 4F77      		andi r20,127
 10795 3d22 5527      		clr r21
 10796 3d24 6627      		clr r22
 10797 3d26 7727      		clr r23
 10798 3d28 4115      		cp r20,__zero_reg__
 10799 3d2a 5105      		cpc r21,__zero_reg__
 10800 3d2c 6105      		cpc r22,__zero_reg__
 10801 3d2e 7105      		cpc r23,__zero_reg__
 10802 3d30 01F4      		brne .L721
1444:switcherator.c ****         fail(0x0f);
 10803               		.loc 1 1444 0
 10804 3d32 8FE0      		ldi r24,lo8(15)
 10805 3d34 90E0      		ldi r25,0
 10806               	.L726:
 10807 3d36 0E94 0000 		call fail
 10808               	.LVL921:
 10809 3d3a 00C0      		rjmp .L716
 10810               	.LVL922:
 10811               	.L721:
1448:switcherator.c ****     weeklyProgram[programNumber][0] = weekdays;
 10812               		.loc 1 1448 0
 10813 3d3c 8AE0      		ldi r24,lo8(10)
 10814 3d3e 809F      		mul r24,r16
 10815 3d40 F001      		movw r30,r0
 10816 3d42 819F      		mul r24,r17
 10817 3d44 F00D      		add r31,r0
 10818 3d46 1124      		clr __zero_reg__
 10819 3d48 E050      		subi r30,lo8(-(weeklyProgram))
 10820 3d4a F040      		sbci r31,hi8(-(weeklyProgram))
1447:switcherator.c ****     char weekdays = (weekLong & 0x7f);
 10821               		.loc 1 1447 0
 10822 3d4c 4083      		st Z,r20
1449:switcherator.c ****     ok();
 10823               		.loc 1 1449 0
 10824 3d4e 0E94 0000 		call ok
 10825               	.LVL923:
 10826               	.L716:
 10827               	/* epilogue start */
1450:switcherator.c **** }
 10828               		.loc 1 1450 0
 10829 3d52 2896      		adiw r28,8
 10830 3d54 0FB6      		in __tmp_reg__,__SREG__
 10831 3d56 F894      		cli
 10832 3d58 DEBF      		out __SP_H__,r29
 10833 3d5a 0FBE      		out __SREG__,__tmp_reg__
 10834 3d5c CDBF      		out __SP_L__,r28
 10835 3d5e DF91      		pop r29
 10836 3d60 CF91      		pop r28
 10837 3d62 1F91      		pop r17
 10838 3d64 0F91      		pop r16
 10839               	.LVL924:
 10840 3d66 FF90      		pop r15
 10841 3d68 EF90      		pop r14
 10842               	.LVL925:
 10843 3d6a 0895      		ret
 10844               	.LFE35:
 10846               	.global	programAddSwitch
 10848               	programAddSwitch:
 10849               	.LFB33:
1311:switcherator.c **** void programAddSwitch(char * commandReceived) {
 10850               		.loc 1 1311 0
 10851               	.LVL926:
 10852 3d6c CF92      		push r12
 10853               	.LCFI276:
 10854 3d6e DF92      		push r13
 10855               	.LCFI277:
 10856 3d70 EF92      		push r14
 10857               	.LCFI278:
 10858 3d72 FF92      		push r15
 10859               	.LCFI279:
 10860 3d74 0F93      		push r16
 10861               	.LCFI280:
 10862 3d76 1F93      		push r17
 10863               	.LCFI281:
 10864 3d78 CF93      		push r28
 10865               	.LCFI282:
 10866 3d7a DF93      		push r29
 10867               	.LCFI283:
 10868 3d7c CDB7      		in r28,__SP_L__
 10869 3d7e DEB7      		in r29,__SP_H__
 10870               	.LCFI284:
 10871 3d80 6097      		sbiw r28,16
 10872               	.LCFI285:
 10873 3d82 0FB6      		in __tmp_reg__,__SREG__
 10874 3d84 F894      		cli
 10875 3d86 DEBF      		out __SP_H__,r29
 10876 3d88 0FBE      		out __SREG__,__tmp_reg__
 10877 3d8a CDBF      		out __SP_L__,r28
 10878               	/* prologue: function */
 10879               	/* frame size = 16 */
 10880               	/* stack size = 24 */
 10881               	.L__stack_usage = 24
 10882 3d8c 7C01      		movw r14,r24
 10883               	.LVL927:
1314:switcherator.c ****     tempIntString[0] = commandReceived[3];
 10884               		.loc 1 1314 0
 10885 3d8e FC01      		movw r30,r24
 10886 3d90 8381      		ldd r24,Z+3
 10887               	.LVL928:
 10888 3d92 8093 0000 		sts tempIntString,r24
1315:switcherator.c ****     tempIntString[1] = commandReceived[4];
 10889               		.loc 1 1315 0
 10890 3d96 8481      		ldd r24,Z+4
 10891 3d98 8093 0000 		sts tempIntString+1,r24
1316:switcherator.c ****     programNumber = atoi(tempIntString);
 10892               		.loc 1 1316 0
 10893 3d9c 80E0      		ldi r24,lo8(tempIntString)
 10894 3d9e 90E0      		ldi r25,hi8(tempIntString)
 10895 3da0 0E94 0000 		call atoi
 10896               	.LVL929:
 10897 3da4 8C01      		movw r16,r24
 10898               	.LVL930:
1317:switcherator.c ****     tempIntString[0] = commandReceived[5];
 10899               		.loc 1 1317 0
 10900 3da6 F701      		movw r30,r14
 10901 3da8 8581      		ldd r24,Z+5
 10902 3daa 8093 0000 		sts tempIntString,r24
1318:switcherator.c ****     tempIntString[1] = commandReceived[6];
 10903               		.loc 1 1318 0
 10904 3dae 8681      		ldd r24,Z+6
 10905 3db0 8093 0000 		sts tempIntString+1,r24
1319:switcherator.c ****     switchNumber = atoi(tempIntString);
 10906               		.loc 1 1319 0
 10907 3db4 80E0      		ldi r24,lo8(tempIntString)
 10908 3db6 90E0      		ldi r25,hi8(tempIntString)
 10909 3db8 0E94 0000 		call atoi
 10910               	.LVL931:
 10911 3dbc 6C01      		movw r12,r24
 10912               	.LVL932:
1321:switcherator.c ****     switches[0] = 0;
 10913               		.loc 1 1321 0
 10914 3dbe 1982      		std Y+1,__zero_reg__
1322:switcherator.c ****     int switchCount = programGetSwitches(programNumber, switches);
 10915               		.loc 1 1322 0
 10916 3dc0 BE01      		movw r22,r28
 10917 3dc2 6F5F      		subi r22,-1
 10918 3dc4 7F4F      		sbci r23,-1
 10919 3dc6 C801      		movw r24,r16
 10920 3dc8 0E94 0000 		call programGetSwitches
 10921               	.LVL933:
 10922 3dcc FE01      		movw r30,r28
 10923 3dce 3196      		adiw r30,1
1311:switcherator.c **** void programAddSwitch(char * commandReceived) {
 10924               		.loc 1 1311 0
 10925 3dd0 AF01      		movw r20,r30
1325:switcherator.c ****     for (x = 0; x < switchCount; x++) {
 10926               		.loc 1 1325 0
 10927 3dd2 00C0      		rjmp .L728
 10928               	.LVL934:
 10929               	.L730:
1326:switcherator.c ****         if (switches[x] == switchNumber) {
 10930               		.loc 1 1326 0
 10931 3dd4 2191      		ld r18,Z+
 10932 3dd6 30E0      		ldi r19,0
 10933 3dd8 2C15      		cp r18,r12
 10934 3dda 3D05      		cpc r19,r13
 10935 3ddc 01F4      		brne .L728
1327:switcherator.c ****             fail(0x0c);
 10936               		.loc 1 1327 0
 10937 3dde 8CE0      		ldi r24,lo8(12)
 10938 3de0 90E0      		ldi r25,0
 10939               	.LVL935:
 10940 3de2 00C0      		rjmp .L754
 10941               	.LVL936:
 10942               	.L728:
1311:switcherator.c **** void programAddSwitch(char * commandReceived) {
 10943               		.loc 1 1311 0 discriminator 1
 10944 3de4 9F01      		movw r18,r30
 10945 3de6 241B      		sub r18,r20
 10946 3de8 350B      		sbc r19,r21
1325:switcherator.c ****     for (x = 0; x < switchCount; x++) {
 10947               		.loc 1 1325 0 discriminator 1
 10948 3dea 2817      		cp r18,r24
 10949 3dec 3907      		cpc r19,r25
 10950 3dee 04F0      		brlt .L730
1333:switcherator.c ****     if ((programNumber >= MAX_PROGRAM) || (programNumber == 0 && commandReceived[4] != '0')) {
 10951               		.loc 1 1333 0
 10952 3df0 0A30      		cpi r16,10
 10953 3df2 1105      		cpc r17,__zero_reg__
 10954 3df4 04F4      		brge .L731
1333:switcherator.c ****     if ((programNumber >= MAX_PROGRAM) || (programNumber == 0 && commandReceived[4] != '0')) {
 10955               		.loc 1 1333 0 is_stmt 0 discriminator 1
 10956 3df6 0115      		cp r16,__zero_reg__
 10957 3df8 1105      		cpc r17,__zero_reg__
 10958 3dfa 01F4      		brne .L732
 10959 3dfc F701      		movw r30,r14
 10960 3dfe 8481      		ldd r24,Z+4
 10961               	.LVL937:
 10962 3e00 8033      		cpi r24,lo8(48)
 10963 3e02 01F0      		breq .L732
 10964               	.L731:
1334:switcherator.c ****         fail(2);
 10965               		.loc 1 1334 0 is_stmt 1
 10966 3e04 82E0      		ldi r24,lo8(2)
 10967 3e06 90E0      		ldi r25,0
 10968 3e08 00C0      		rjmp .L754
 10969               	.L732:
1337:switcherator.c ****     if ((switchNumber >= NUM_SWITCHES) || (switchNumber == 0 && commandReceived[6] != '0')) {
 10970               		.loc 1 1337 0
 10971 3e0a F0E1      		ldi r31,16
 10972 3e0c CF16      		cp r12,r31
 10973 3e0e D104      		cpc r13,__zero_reg__
 10974 3e10 04F4      		brge .L733
1337:switcherator.c ****     if ((switchNumber >= NUM_SWITCHES) || (switchNumber == 0 && commandReceived[6] != '0')) {
 10975               		.loc 1 1337 0 is_stmt 0 discriminator 1
 10976 3e12 C114      		cp r12,__zero_reg__
 10977 3e14 D104      		cpc r13,__zero_reg__
 10978 3e16 01F4      		brne .L734
 10979 3e18 F701      		movw r30,r14
 10980 3e1a 8681      		ldd r24,Z+6
 10981 3e1c 8033      		cpi r24,lo8(48)
 10982 3e1e 01F0      		breq .L734
 10983               	.L733:
1338:switcherator.c ****         fail(1);
 10984               		.loc 1 1338 0 is_stmt 1
 10985 3e20 81E0      		ldi r24,lo8(1)
 10986 3e22 90E0      		ldi r25,0
 10987 3e24 00C0      		rjmp .L754
 10988               	.L734:
1345:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 10989               		.loc 1 1345 0
 10990 3e26 8AE0      		ldi r24,lo8(10)
 10991 3e28 809F      		mul r24,r16
 10992 3e2a F001      		movw r30,r0
 10993 3e2c 819F      		mul r24,r17
 10994 3e2e F00D      		add r31,r0
 10995 3e30 1124      		clr __zero_reg__
 10996 3e32 E050      		subi r30,lo8(-(weeklyProgram))
 10997 3e34 F040      		sbci r31,hi8(-(weeklyProgram))
 10998 3e36 8081      		ld r24,Z
 10999 3e38 8F3F      		cpi r24,lo8(-1)
 11000 3e3a 01F4      		brne .L735
1345:switcherator.c ****     if (weeklyProgram[programNumber][0] == 255 && weeklyProgram[programNumber][1] == 255) {
 11001               		.loc 1 1345 0 is_stmt 0 discriminator 1
 11002 3e3c 8181      		ldd r24,Z+1
 11003 3e3e 8F3F      		cpi r24,lo8(-1)
 11004 3e40 01F4      		brne .L735
1346:switcherator.c ****         fail(0x0d);
 11005               		.loc 1 1346 0 is_stmt 1
 11006 3e42 8DE0      		ldi r24,lo8(13)
 11007 3e44 90E0      		ldi r25,0
 11008 3e46 00C0      		rjmp .L754
 11009               	.L735:
 11010               	.LVL938:
1353:switcherator.c ****     itoa(programNumber, tempIntString, 10);
 11011               		.loc 1 1353 0
 11012 3e48 4AE0      		ldi r20,lo8(10)
 11013 3e4a 50E0      		ldi r21,0
 11014 3e4c 60E0      		ldi r22,lo8(tempIntString)
 11015 3e4e 70E0      		ldi r23,hi8(tempIntString)
 11016 3e50 C801      		movw r24,r16
 11017 3e52 0E94 0000 		call itoa
 11018               	.LVL939:
1355:switcherator.c ****     blankSwitch = findOpenSwitch(programNumber);
 11019               		.loc 1 1355 0
 11020 3e56 C801      		movw r24,r16
 11021 3e58 0E94 0000 		call findOpenSwitch
 11022               	.LVL940:
1357:switcherator.c ****         if (blankSwitch == 0) {
 11023               		.loc 1 1357 0
 11024 3e5c 0097      		sbiw r24,0
 11025 3e5e 01F4      		brne .L736
1360:switcherator.c ****             overflowProgram = weeklyProgram[programNumber][9];
 11026               		.loc 1 1360 0
 11027 3e60 4AE0      		ldi r20,lo8(10)
 11028               	.LVL941:
 11029               	.L753:
 11030 3e62 409F      		mul r20,r16
 11031 3e64 F001      		movw r30,r0
 11032 3e66 419F      		mul r20,r17
 11033 3e68 F00D      		add r31,r0
 11034 3e6a 1124      		clr __zero_reg__
 11035 3e6c E050      		subi r30,lo8(-(weeklyProgram))
 11036 3e6e F040      		sbci r31,hi8(-(weeklyProgram))
 11037 3e70 8185      		ldd r24,Z+9
 11038 3e72 90E0      		ldi r25,0
 11039               	.LVL942:
1361:switcherator.c ****             if (overflowProgram == 255) {
 11040               		.loc 1 1361 0
 11041 3e74 8F3F      		cpi r24,-1
 11042 3e76 9105      		cpc r25,__zero_reg__
 11043 3e78 01F4      		brne .L743
 11044 3e7a 2FEF      		ldi r18,lo8(-1)
 11045 3e7c 30E0      		ldi r19,0
 11046 3e7e 89E0      		ldi r24,lo8(9)
 11047 3e80 90E0      		ldi r25,0
 11048               	.LVL943:
 11049               	.L739:
 11050               	.LBB28:
1368:switcherator.c ****                     if (weeklyProgram[x][0] == 255 && weeklyProgram[x][5] == 255) {
 11051               		.loc 1 1368 0
 11052 3e82 489F      		mul r20,r24
 11053 3e84 F001      		movw r30,r0
 11054 3e86 499F      		mul r20,r25
 11055 3e88 F00D      		add r31,r0
 11056 3e8a 1124      		clr __zero_reg__
 11057 3e8c E050      		subi r30,lo8(-(weeklyProgram))
 11058 3e8e F040      		sbci r31,hi8(-(weeklyProgram))
 11059 3e90 5081      		ld r21,Z
 11060 3e92 5F3F      		cpi r21,lo8(-1)
 11061 3e94 01F4      		brne .L738
1368:switcherator.c ****                     if (weeklyProgram[x][0] == 255 && weeklyProgram[x][5] == 255) {
 11062               		.loc 1 1368 0 is_stmt 0 discriminator 1
 11063 3e96 5581      		ldd r21,Z+5
 11064 3e98 5F3F      		cpi r21,lo8(-1)
 11065 3e9a 01F4      		brne .L738
1368:switcherator.c ****                     if (weeklyProgram[x][0] == 255 && weeklyProgram[x][5] == 255) {
 11066               		.loc 1 1368 0
 11067 3e9c 9C01      		movw r18,r24
1372:switcherator.c ****                         x = 0;
 11068               		.loc 1 1372 0 is_stmt 1
 11069 3e9e 80E0      		ldi r24,0
 11070 3ea0 90E0      		ldi r25,0
 11071               	.L738:
 11072               	.LVL944:
1366:switcherator.c ****                 for (x = (MAX_PROGRAM - 1); x > 0; x--) {
 11073               		.loc 1 1366 0
 11074 3ea2 0197      		sbiw r24,1
 11075               	.LVL945:
 11076 3ea4 1816      		cp __zero_reg__,r24
 11077 3ea6 1906      		cpc __zero_reg__,r25
 11078 3ea8 04F0      		brlt .L739
1375:switcherator.c ****                 if (possibleBlank == 255) {
 11079               		.loc 1 1375 0
 11080 3eaa 2F3F      		cpi r18,-1
 11081 3eac 3105      		cpc r19,__zero_reg__
 11082 3eae 01F4      		brne .L740
1377:switcherator.c ****                     fail(0x0e);
 11083               		.loc 1 1377 0
 11084 3eb0 8EE0      		ldi r24,lo8(14)
 11085 3eb2 90E0      		ldi r25,0
 11086               	.LVL946:
 11087               	.L754:
 11088 3eb4 0E94 0000 		call fail
 11089               	.LVL947:
 11090 3eb8 00C0      		rjmp .L727
 11091               	.LVL948:
 11092               	.L740:
1381:switcherator.c ****                 weeklyProgram[programNumber][9] = possibleBlank;
 11093               		.loc 1 1381 0
 11094 3eba 409F      		mul r20,r16
 11095 3ebc F001      		movw r30,r0
 11096 3ebe 419F      		mul r20,r17
 11097 3ec0 F00D      		add r31,r0
 11098 3ec2 1124      		clr __zero_reg__
 11099 3ec4 E050      		subi r30,lo8(-(weeklyProgram))
 11100 3ec6 F040      		sbci r31,hi8(-(weeklyProgram))
 11101 3ec8 2187      		std Z+9,r18
 11102               	.LVL949:
 11103 3eca 8901      		movw r16,r18
 11104 3ecc 00C0      		rjmp .L753
 11105               	.LVL950:
 11106               	.L743:
 11107               	.LBE28:
1361:switcherator.c ****             if (overflowProgram == 255) {
 11108               		.loc 1 1361 0
 11109 3ece 8C01      		movw r16,r24
 11110               	.LVL951:
 11111 3ed0 00C0      		rjmp .L753
 11112               	.LVL952:
 11113               	.L736:
1393:switcherator.c ****     weeklyProgram[programNumber][blankSwitch] = switchNumber;
 11114               		.loc 1 1393 0 discriminator 1
 11115 3ed2 2AE0      		ldi r18,lo8(10)
 11116 3ed4 209F      		mul r18,r16
 11117 3ed6 F001      		movw r30,r0
 11118 3ed8 219F      		mul r18,r17
 11119 3eda F00D      		add r31,r0
 11120 3edc 1124      		clr __zero_reg__
 11121 3ede E80F      		add r30,r24
 11122 3ee0 F91F      		adc r31,r25
 11123 3ee2 E050      		subi r30,lo8(-(weeklyProgram))
 11124 3ee4 F040      		sbci r31,hi8(-(weeklyProgram))
 11125 3ee6 C082      		st Z,r12
1394:switcherator.c ****     ok();
 11126               		.loc 1 1394 0 discriminator 1
 11127 3ee8 0E94 0000 		call ok
 11128               	.LVL953:
 11129               	.L727:
 11130               	/* epilogue start */
1395:switcherator.c **** }
 11131               		.loc 1 1395 0
 11132 3eec 6096      		adiw r28,16
 11133 3eee 0FB6      		in __tmp_reg__,__SREG__
 11134 3ef0 F894      		cli
 11135 3ef2 DEBF      		out __SP_H__,r29
 11136 3ef4 0FBE      		out __SREG__,__tmp_reg__
 11137 3ef6 CDBF      		out __SP_L__,r28
 11138 3ef8 DF91      		pop r29
 11139 3efa CF91      		pop r28
 11140 3efc 1F91      		pop r17
 11141 3efe 0F91      		pop r16
 11142               	.LVL954:
 11143 3f00 FF90      		pop r15
 11144 3f02 EF90      		pop r14
 11145               	.LVL955:
 11146 3f04 DF90      		pop r13
 11147 3f06 CF90      		pop r12
 11148               	.LVL956:
 11149 3f08 0895      		ret
 11150               	.LFE33:
 11152               	.global	clearProgram
 11154               	clearProgram:
 11155               	.LFB31:
1281:switcherator.c **** void clearProgram(char * commandReceived) {
 11156               		.loc 1 1281 0
 11157               	.LVL957:
 11158 3f0a 0F93      		push r16
 11159               	.LCFI286:
 11160 3f0c 1F93      		push r17
 11161               	.LCFI287:
 11162 3f0e CF93      		push r28
 11163               	.LCFI288:
 11164 3f10 DF93      		push r29
 11165               	.LCFI289:
 11166               	/* prologue: function */
 11167               	/* frame size = 0 */
 11168               	/* stack size = 4 */
 11169               	.L__stack_usage = 4
 11170 3f12 8C01      		movw r16,r24
1282:switcherator.c ****     int programNumber = getSwitchNumber(commandReceived);
 11171               		.loc 1 1282 0
 11172 3f14 0E94 0000 		call getSwitchNumber
 11173               	.LVL958:
 11174 3f18 EC01      		movw r28,r24
 11175               	.LVL959:
1283:switcherator.c ****     if (programNumber >= MAX_PROGRAM || (programNumber == 0 && commandReceived[4] != '0')) {
 11176               		.loc 1 1283 0
 11177 3f1a 8A30      		cpi r24,10
 11178 3f1c 9105      		cpc r25,__zero_reg__
 11179 3f1e 04F4      		brge .L756
1283:switcherator.c ****     if (programNumber >= MAX_PROGRAM || (programNumber == 0 && commandReceived[4] != '0')) {
 11180               		.loc 1 1283 0 is_stmt 0 discriminator 1
 11181 3f20 0097      		sbiw r24,0
 11182 3f22 01F4      		brne .L757
 11183 3f24 F801      		movw r30,r16
 11184 3f26 8481      		ldd r24,Z+4
 11185               	.LVL960:
 11186 3f28 8033      		cpi r24,lo8(48)
 11187 3f2a 01F0      		breq .L757
 11188               	.L756:
1284:switcherator.c ****         fail(2);
 11189               		.loc 1 1284 0 is_stmt 1
 11190 3f2c 82E0      		ldi r24,lo8(2)
 11191 3f2e 90E0      		ldi r25,0
 11192               	/* epilogue start */
1290:switcherator.c **** }
 11193               		.loc 1 1290 0
 11194 3f30 DF91      		pop r29
 11195 3f32 CF91      		pop r28
 11196               	.LVL961:
 11197 3f34 1F91      		pop r17
 11198 3f36 0F91      		pop r16
 11199               	.LVL962:
1284:switcherator.c ****         fail(2);
 11200               		.loc 1 1284 0
 11201 3f38 0C94 0000 		jmp fail
 11202               	.LVL963:
 11203               	.L757:
1286:switcherator.c ****         itoa(programNumber, tempIntString, 10);
 11204               		.loc 1 1286 0
 11205 3f3c 4AE0      		ldi r20,lo8(10)
 11206 3f3e 50E0      		ldi r21,0
 11207 3f40 60E0      		ldi r22,lo8(tempIntString)
 11208 3f42 70E0      		ldi r23,hi8(tempIntString)
 11209 3f44 CE01      		movw r24,r28
 11210 3f46 0E94 0000 		call itoa
 11211               	.LVL964:
1287:switcherator.c ****         ok();
 11212               		.loc 1 1287 0
 11213 3f4a 0E94 0000 		call ok
 11214               	.LVL965:
1288:switcherator.c ****         clearTheProgram(programNumber);
 11215               		.loc 1 1288 0
 11216 3f4e CE01      		movw r24,r28
 11217               	/* epilogue start */
1290:switcherator.c **** }
 11218               		.loc 1 1290 0
 11219 3f50 DF91      		pop r29
 11220 3f52 CF91      		pop r28
 11221               	.LVL966:
 11222 3f54 1F91      		pop r17
 11223 3f56 0F91      		pop r16
 11224               	.LVL967:
1288:switcherator.c ****         clearTheProgram(programNumber);
 11225               		.loc 1 1288 0
 11226 3f58 0C94 0000 		jmp clearTheProgram
 11227               	.LVL968:
 11228               	.LFE31:
 11230               	.global	colorChangeSet
 11232               	colorChangeSet:
 11233               	.LFB25:
 989:switcherator.c **** void colorChangeSet(char * commandReceived) {
 11234               		.loc 1 989 0
 11235               	.LVL969:
 11236 3f5c EF92      		push r14
 11237               	.LCFI290:
 11238 3f5e FF92      		push r15
 11239               	.LCFI291:
 11240 3f60 0F93      		push r16
 11241               	.LCFI292:
 11242 3f62 1F93      		push r17
 11243               	.LCFI293:
 11244 3f64 CF93      		push r28
 11245               	.LCFI294:
 11246 3f66 DF93      		push r29
 11247               	.LCFI295:
 11248               	/* prologue: function */
 11249               	/* frame size = 0 */
 11250               	/* stack size = 6 */
 11251               	.L__stack_usage = 6
 11252 3f68 EC01      		movw r28,r24
 990:switcherator.c ****     int programNumber = getSwitchNumber(commandReceived);
 11253               		.loc 1 990 0
 11254 3f6a 0E94 0000 		call getSwitchNumber
 11255               	.LVL970:
 11256 3f6e 7C01      		movw r14,r24
 11257               	.LVL971:
 991:switcherator.c ****     if (programNumber >= NUM_COLOR_CHANGES) {
 11258               		.loc 1 991 0
 11259 3f70 86E0      		ldi r24,6
 11260 3f72 E816      		cp r14,r24
 11261 3f74 F104      		cpc r15,__zero_reg__
 11262 3f76 04F0      		brlt .L762
 992:switcherator.c ****         fail(7);
 11263               		.loc 1 992 0
 11264 3f78 87E0      		ldi r24,lo8(7)
 11265 3f7a 90E0      		ldi r25,0
 11266               	/* epilogue start */
1009:switcherator.c **** }
 11267               		.loc 1 1009 0
 11268 3f7c DF91      		pop r29
 11269 3f7e CF91      		pop r28
 11270               	.LVL972:
 11271 3f80 1F91      		pop r17
 11272 3f82 0F91      		pop r16
 11273 3f84 FF90      		pop r15
 11274 3f86 EF90      		pop r14
 11275               	.LVL973:
 992:switcherator.c ****         fail(7);
 11276               		.loc 1 992 0
 11277 3f88 0C94 0000 		jmp fail
 11278               	.LVL974:
 11279               	.L762:
 995:switcherator.c ****     tempLongString[3] = 0;
 11280               		.loc 1 995 0
 11281 3f8c 1092 0000 		sts tempLongString+3,__zero_reg__
 996:switcherator.c ****     tempLongString[0] = commandReceived[6];
 11282               		.loc 1 996 0
 11283 3f90 8E81      		ldd r24,Y+6
 11284 3f92 8093 0000 		sts tempLongString,r24
 997:switcherator.c ****     tempLongString[1] = commandReceived[7];
 11285               		.loc 1 997 0
 11286 3f96 8F81      		ldd r24,Y+7
 11287 3f98 8093 0000 		sts tempLongString+1,r24
 998:switcherator.c ****     tempLongString[2] = commandReceived[8];
 11288               		.loc 1 998 0
 11289 3f9c 8885      		ldd r24,Y+8
 11290 3f9e 8093 0000 		sts tempLongString+2,r24
 999:switcherator.c ****     colorChanges[programNumber][0] = atoi(tempLongString);
 11291               		.loc 1 999 0
 11292 3fa2 80E0      		ldi r24,lo8(tempLongString)
 11293 3fa4 90E0      		ldi r25,hi8(tempLongString)
 11294 3fa6 0E94 0000 		call atoi
 11295               	.LVL975:
 11296 3faa 8701      		movw r16,r14
 11297 3fac 000F      		lsl r16
 11298 3fae 111F      		rol r17
 11299 3fb0 0E0D      		add r16,r14
 11300 3fb2 1F1D      		adc r17,r15
 11301 3fb4 0050      		subi r16,lo8(-(colorChanges))
 11302 3fb6 1040      		sbci r17,hi8(-(colorChanges))
 11303 3fb8 F801      		movw r30,r16
 11304 3fba 8083      		st Z,r24
1000:switcherator.c ****     tempLongString[0] = commandReceived[10];
 11305               		.loc 1 1000 0
 11306 3fbc 8A85      		ldd r24,Y+10
 11307 3fbe 8093 0000 		sts tempLongString,r24
1001:switcherator.c ****     tempLongString[1] = commandReceived[11];
 11308               		.loc 1 1001 0
 11309 3fc2 8B85      		ldd r24,Y+11
 11310 3fc4 8093 0000 		sts tempLongString+1,r24
1002:switcherator.c ****     tempLongString[2] = commandReceived[12];
 11311               		.loc 1 1002 0
 11312 3fc8 8C85      		ldd r24,Y+12
 11313 3fca 8093 0000 		sts tempLongString+2,r24
1003:switcherator.c ****     colorChanges[programNumber][1] = atoi(tempLongString);
 11314               		.loc 1 1003 0
 11315 3fce 80E0      		ldi r24,lo8(tempLongString)
 11316 3fd0 90E0      		ldi r25,hi8(tempLongString)
 11317 3fd2 0E94 0000 		call atoi
 11318               	.LVL976:
 11319 3fd6 F801      		movw r30,r16
 11320 3fd8 8183      		std Z+1,r24
1004:switcherator.c ****     tempLongString[0] = commandReceived[14];
 11321               		.loc 1 1004 0
 11322 3fda 8E85      		ldd r24,Y+14
 11323 3fdc 8093 0000 		sts tempLongString,r24
1005:switcherator.c ****     tempLongString[1] = commandReceived[15];
 11324               		.loc 1 1005 0
 11325 3fe0 8F85      		ldd r24,Y+15
 11326 3fe2 8093 0000 		sts tempLongString+1,r24
1006:switcherator.c ****     tempLongString[2] = commandReceived[16];
 11327               		.loc 1 1006 0
 11328 3fe6 8889      		ldd r24,Y+16
 11329 3fe8 8093 0000 		sts tempLongString+2,r24
1007:switcherator.c ****     colorChanges[programNumber][2] = atoi(tempLongString);
 11330               		.loc 1 1007 0
 11331 3fec 80E0      		ldi r24,lo8(tempLongString)
 11332 3fee 90E0      		ldi r25,hi8(tempLongString)
 11333 3ff0 0E94 0000 		call atoi
 11334               	.LVL977:
 11335 3ff4 F801      		movw r30,r16
 11336 3ff6 8283      		std Z+2,r24
 11337               	/* epilogue start */
1009:switcherator.c **** }
 11338               		.loc 1 1009 0
 11339 3ff8 DF91      		pop r29
 11340 3ffa CF91      		pop r28
 11341               	.LVL978:
 11342 3ffc 1F91      		pop r17
 11343 3ffe 0F91      		pop r16
 11344 4000 FF90      		pop r15
 11345 4002 EF90      		pop r14
 11346               	.LVL979:
1008:switcherator.c ****     ok();
 11347               		.loc 1 1008 0
 11348 4004 0C94 0000 		jmp ok
 11349               	.LVL980:
 11350               	.LFE25:
 11352               	.global	pwmSetup
 11354               	pwmSetup:
 11355               	.LFB20:
 866:switcherator.c **** void pwmSetup(char * commandReceived) {
 11356               		.loc 1 866 0
 11357               	.LVL981:
 11358 4008 0F93      		push r16
 11359               	.LCFI296:
 11360 400a 1F93      		push r17
 11361               	.LCFI297:
 11362 400c CF93      		push r28
 11363               	.LCFI298:
 11364 400e DF93      		push r29
 11365               	.LCFI299:
 11366               	/* prologue: function */
 11367               	/* frame size = 0 */
 11368               	/* stack size = 4 */
 11369               	.L__stack_usage = 4
 11370 4010 EC01      		movw r28,r24
 11371               	.LVL982:
 11372 4012 E0E0      		ldi r30,lo8(switchStuff)
 11373 4014 F0E0      		ldi r31,hi8(switchStuff)
 11374               	.LVL983:
 11375               	.L766:
 869:switcherator.c ****         if (switchStuff[x] == 70 || switchStuff[x] == 71 || switchStuff[x] == 74 ||
 11376               		.loc 1 869 0
 11377 4016 8191      		ld r24,Z+
 11378 4018 982F      		mov r25,r24
 11379 401a 9654      		subi r25,lo8(-(-70))
 11380 401c 9230      		cpi r25,lo8(2)
 11381 401e 00F0      		brlo .L764
 869:switcherator.c ****         if (switchStuff[x] == 70 || switchStuff[x] == 71 || switchStuff[x] == 74 ||
 11382               		.loc 1 869 0 is_stmt 0 discriminator 1
 11383 4020 8A34      		cpi r24,lo8(74)
 11384 4022 01F0      		breq .L764
 11385 4024 8B34      		cpi r24,lo8(75)
 11386 4026 01F0      		breq .L764
 870:switcherator.c ****                 switchStuff[x] == 75 || switchStuff[x] == 76 || switchStuff[x] == 77) {
 11387               		.loc 1 870 0 is_stmt 1
 11388 4028 8C34      		cpi r24,lo8(76)
 11389 402a 01F0      		breq .L764
 870:switcherator.c ****                 switchStuff[x] == 75 || switchStuff[x] == 76 || switchStuff[x] == 77) {
 11390               		.loc 1 870 0 is_stmt 0 discriminator 1
 11391 402c 8D34      		cpi r24,lo8(77)
 11392 402e 01F4      		brne .L765
 11393               	.L764:
 871:switcherator.c ****             fail(6);
 11394               		.loc 1 871 0 is_stmt 1
 11395 4030 86E0      		ldi r24,lo8(6)
 11396 4032 90E0      		ldi r25,0
 11397               	/* epilogue start */
 911:switcherator.c **** }
 11398               		.loc 1 911 0
 11399 4034 DF91      		pop r29
 11400 4036 CF91      		pop r28
 11401               	.LVL984:
 11402 4038 1F91      		pop r17
 11403 403a 0F91      		pop r16
 871:switcherator.c ****             fail(6);
 11404               		.loc 1 871 0
 11405 403c 0C94 0000 		jmp fail
 11406               	.LVL985:
 11407               	.L765:
 868:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 11408               		.loc 1 868 0
 11409 4040 80E0      		ldi r24,hi8(switchStuff+16)
 11410 4042 E030      		cpi r30,lo8(switchStuff+16)
 11411 4044 F807      		cpc r31,r24
 11412 4046 01F4      		brne .L766
 11413               	.LVL986:
 877:switcherator.c ****     tempIntString[0] = commandReceived[5];
 11414               		.loc 1 877 0
 11415 4048 8D81      		ldd r24,Y+5
 11416 404a 8093 0000 		sts tempIntString,r24
 878:switcherator.c ****     tempIntString[1] = commandReceived[6];
 11417               		.loc 1 878 0
 11418 404e 8E81      		ldd r24,Y+6
 11419 4050 8093 0000 		sts tempIntString+1,r24
 879:switcherator.c ****     switchNumber = atoi(tempIntString);
 11420               		.loc 1 879 0
 11421 4054 80E0      		ldi r24,lo8(tempIntString)
 11422 4056 90E0      		ldi r25,hi8(tempIntString)
 11423 4058 0E94 0000 		call atoi
 11424               	.LVL987:
 11425 405c 8C01      		movw r16,r24
 11426               	.LVL988:
 880:switcherator.c ****     clearTheSwitch(switchNumber);
 11427               		.loc 1 880 0
 11428 405e 0E94 0000 		call clearTheSwitch
 11429               	.LVL989:
 882:switcherator.c ****     if (commandReceived[8] == 'H' || commandReceived[8] == 'h' || commandReceived[8] == '1') {
 11430               		.loc 1 882 0
 11431 4062 8885      		ldd r24,Y+8
 11432 4064 8834      		cpi r24,lo8(72)
 11433 4066 01F0      		breq .L767
 882:switcherator.c ****     if (commandReceived[8] == 'H' || commandReceived[8] == 'h' || commandReceived[8] == '1') {
 11434               		.loc 1 882 0 is_stmt 0 discriminator 1
 11435 4068 8836      		cpi r24,lo8(104)
 11436 406a 01F0      		breq .L767
 11437 406c 8133      		cpi r24,lo8(49)
 11438 406e 01F4      		brne .L768
 11439               	.L767:
 883:switcherator.c ****         switchStuff[switchNumber] = 201;
 11440               		.loc 1 883 0 is_stmt 1
 11441 4070 F801      		movw r30,r16
 11442 4072 E050      		subi r30,lo8(-(switchStuff))
 11443 4074 F040      		sbci r31,hi8(-(switchStuff))
 11444 4076 89EC      		ldi r24,lo8(-55)
 11445 4078 00C0      		rjmp .L793
 11446               	.L768:
 11447 407a F801      		movw r30,r16
 11448 407c E050      		subi r30,lo8(-(switchStuff))
 11449 407e F040      		sbci r31,hi8(-(switchStuff))
 884:switcherator.c ****     } else if (commandReceived[8] == 'C' || commandReceived[8] == 'c') {
 11450               		.loc 1 884 0
 11451 4080 8334      		cpi r24,lo8(67)
 11452 4082 01F0      		breq .L770
 884:switcherator.c ****     } else if (commandReceived[8] == 'C' || commandReceived[8] == 'c') {
 11453               		.loc 1 884 0 is_stmt 0 discriminator 1
 11454 4084 8336      		cpi r24,lo8(99)
 11455 4086 01F4      		brne .L771
 11456               	.L770:
 885:switcherator.c ****         switchStuff[switchNumber] = 202;
 11457               		.loc 1 885 0 is_stmt 1
 11458 4088 8AEC      		ldi r24,lo8(-54)
 11459 408a 00C0      		rjmp .L793
 11460               	.L771:
 887:switcherator.c ****         switchStuff[switchNumber] = 200;
 11461               		.loc 1 887 0
 11462 408c 88EC      		ldi r24,lo8(-56)
 11463               	.L793:
 11464 408e 8083      		st Z,r24
 889:switcherator.c ****     DDRD |= (1 << PIND3) | (1 << PIND5) | (1 << PIND6);
 11465               		.loc 1 889 0
 11466 4090 8AB1      		in r24,0xa
 11467 4092 8866      		ori r24,lo8(104)
 11468 4094 8AB9      		out 0xa,r24
 891:switcherator.c ****     Red = 0;
 11469               		.loc 1 891 0
 11470 4096 1092 B400 		sts 180,__zero_reg__
 892:switcherator.c ****     Green = 0;
 11471               		.loc 1 892 0
 11472 409a 18BC      		out 0x28,__zero_reg__
 893:switcherator.c ****     Blue = 0;
 11473               		.loc 1 893 0
 11474 409c 17BC      		out 0x27,__zero_reg__
 896:switcherator.c ****     if (commandReceived[7] == '0') {
 11475               		.loc 1 896 0
 11476 409e 8F81      		ldd r24,Y+7
 11477 40a0 8033      		cpi r24,lo8(48)
 11478 40a2 01F4      		brne .L772
 897:switcherator.c ****         pwmdir = 0;
 11479               		.loc 1 897 0
 11480 40a4 1092 0000 		sts pwmdir,__zero_reg__
 898:switcherator.c ****         TCCR0A = (1 << COM0A0) | (1 << COM0A1) | (1 << COM0B0) | (1 << COM0B1) | (1 << WGM00);
 11481               		.loc 1 898 0
 11482 40a8 81EF      		ldi r24,lo8(-15)
 11483 40aa 84BD      		out 0x24,r24
 899:switcherator.c ****         TCCR2A = (1 << COM2B0) | (1 << COM2B1) | (1 << WGM20);
 11484               		.loc 1 899 0
 11485 40ac 81E3      		ldi r24,lo8(49)
 11486 40ae 00C0      		rjmp .L794
 11487               	.L772:
 901:switcherator.c ****         pwmdir = 1;
 11488               		.loc 1 901 0
 11489 40b0 81E0      		ldi r24,lo8(1)
 11490 40b2 8093 0000 		sts pwmdir,r24
 902:switcherator.c ****         TCCR0A = (1 << COM0A1) | (1 << COM0B1) | (1 << WGM00);
 11491               		.loc 1 902 0
 11492 40b6 81EA      		ldi r24,lo8(-95)
 11493 40b8 84BD      		out 0x24,r24
 903:switcherator.c ****         TCCR2A = (1 << COM2B1) | (1 << WGM20);
 11494               		.loc 1 903 0
 11495 40ba 81E2      		ldi r24,lo8(33)
 11496               	.L794:
 11497 40bc 8093 B000 		sts 176,r24
 906:switcherator.c ****     TCCR0B = (1 << CS01) | (1 << CS00);
 11498               		.loc 1 906 0
 11499 40c0 83E0      		ldi r24,lo8(3)
 11500 40c2 85BD      		out 0x25,r24
 908:switcherator.c ****     TCCR2B = (1 << CS22); // F_CPU/64
 11501               		.loc 1 908 0
 11502 40c4 84E0      		ldi r24,lo8(4)
 11503 40c6 8093 B100 		sts 177,r24
 11504               	/* epilogue start */
 911:switcherator.c **** }
 11505               		.loc 1 911 0
 11506 40ca DF91      		pop r29
 11507 40cc CF91      		pop r28
 11508               	.LVL990:
 11509 40ce 1F91      		pop r17
 11510 40d0 0F91      		pop r16
 11511               	.LVL991:
 910:switcherator.c ****     ok();
 11512               		.loc 1 910 0
 11513 40d2 0C94 0000 		jmp ok
 11514               	.LVL992:
 11515               	.LFE20:
 11517               	.global	startSwitch
 11519               	startSwitch:
 11520               	.LFB17:
 681:switcherator.c **** void startSwitch(char * commandReceived) {
 11521               		.loc 1 681 0
 11522               	.LVL993:
 11523 40d6 EF92      		push r14
 11524               	.LCFI300:
 11525 40d8 FF92      		push r15
 11526               	.LCFI301:
 11527 40da 0F93      		push r16
 11528               	.LCFI302:
 11529 40dc 1F93      		push r17
 11530               	.LCFI303:
 11531 40de CF93      		push r28
 11532               	.LCFI304:
 11533 40e0 DF93      		push r29
 11534               	.LCFI305:
 11535 40e2 00D0      		rcall .
 11536 40e4 00D0      		rcall .
 11537               	.LCFI306:
 11538 40e6 CDB7      		in r28,__SP_L__
 11539 40e8 DEB7      		in r29,__SP_H__
 11540               	.LCFI307:
 11541               	/* prologue: function */
 11542               	/* frame size = 4 */
 11543               	/* stack size = 10 */
 11544               	.L__stack_usage = 10
 11545 40ea 7C01      		movw r14,r24
 11546               	.LVL994:
 685:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 11547               		.loc 1 685 0
 11548 40ec 0E94 0000 		call getSwitchNumber
 11549               	.LVL995:
 11550 40f0 8C01      		movw r16,r24
 11551               	.LVL996:
 686:switcherator.c ****     if ((switchNumber >= NUM_SWITCHES) || (switchStuff[switchNumber] == 255)) {
 11552               		.loc 1 686 0
 11553 40f2 8031      		cpi r24,16
 11554 40f4 9105      		cpc r25,__zero_reg__
 11555 40f6 04F4      		brge .L796
 686:switcherator.c ****     if ((switchNumber >= NUM_SWITCHES) || (switchStuff[switchNumber] == 255)) {
 11556               		.loc 1 686 0 is_stmt 0 discriminator 1
 11557 40f8 FC01      		movw r30,r24
 11558 40fa E050      		subi r30,lo8(-(switchStuff))
 11559 40fc F040      		sbci r31,hi8(-(switchStuff))
 11560 40fe 2081      		ld r18,Z
 11561 4100 2F3F      		cpi r18,lo8(-1)
 11562 4102 01F4      		brne .L797
 11563               	.L796:
 687:switcherator.c ****         fail(1);
 11564               		.loc 1 687 0 is_stmt 1
 11565 4104 81E0      		ldi r24,lo8(1)
 11566 4106 90E0      		ldi r25,0
 11567 4108 00C0      		rjmp .L813
 11568               	.L797:
 691:switcherator.c ****     tempHugeString[0] = commandReceived[5];
 11569               		.loc 1 691 0
 11570 410a F701      		movw r30,r14
 11571 410c 8581      		ldd r24,Z+5
 11572 410e 8093 0000 		sts tempHugeString,r24
 692:switcherator.c ****     tempHugeString[1] = commandReceived[6];
 11573               		.loc 1 692 0
 11574 4112 8681      		ldd r24,Z+6
 11575 4114 8093 0000 		sts tempHugeString+1,r24
 693:switcherator.c ****     tempHugeString[2] = commandReceived[7];
 11576               		.loc 1 693 0
 11577 4118 8781      		ldd r24,Z+7
 11578 411a 8093 0000 		sts tempHugeString+2,r24
 694:switcherator.c ****     tempHugeString[3] = commandReceived[8];
 11579               		.loc 1 694 0
 11580 411e 8085      		ldd r24,Z+8
 11581 4120 8093 0000 		sts tempHugeString+3,r24
 695:switcherator.c ****     tempHugeString[4] = commandReceived[9];
 11582               		.loc 1 695 0
 11583 4124 8185      		ldd r24,Z+9
 11584 4126 8093 0000 		sts tempHugeString+4,r24
 696:switcherator.c ****     tempHugeString[5] = commandReceived[10];
 11585               		.loc 1 696 0
 11586 412a 8285      		ldd r24,Z+10
 11587 412c 8093 0000 		sts tempHugeString+5,r24
 697:switcherator.c ****     duration = atol(tempHugeString);
 11588               		.loc 1 697 0
 11589 4130 80E0      		ldi r24,lo8(tempHugeString)
 11590 4132 90E0      		ldi r25,hi8(tempHugeString)
 11591 4134 2C83      		std Y+4,r18
 11592 4136 0E94 0000 		call atol
 11593               	.LVL997:
 11594 413a 462F      		mov r20,r22
 11595 413c 572F      		mov r21,r23
 11596 413e BC01      		movw r22,r24
 11597               	.LVL998:
 698:switcherator.c ****     if (duration == 0) {
 11598               		.loc 1 698 0
 11599 4140 2C81      		ldd r18,Y+4
 11600 4142 4115      		cp r20,__zero_reg__
 11601 4144 5105      		cpc r21,__zero_reg__
 11602 4146 6105      		cpc r22,__zero_reg__
 11603 4148 7105      		cpc r23,__zero_reg__
 11604 414a 01F4      		brne .L799
 699:switcherator.c ****         fail(5);
 11605               		.loc 1 699 0
 11606 414c 85E0      		ldi r24,lo8(5)
 11607 414e 90E0      		ldi r25,0
 11608               	.LVL999:
 11609               	.L813:
 11610 4150 0E94 0000 		call fail
 11611               	.LVL1000:
 700:switcherator.c ****         return;
 11612               		.loc 1 700 0
 11613 4154 00C0      		rjmp .L795
 11614               	.LVL1001:
 11615               	.L799:
 703:switcherator.c ****     if ((weeklySeconds + duration) > switchStatus[switchNumber])
 11616               		.loc 1 703 0
 11617 4156 8091 0000 		lds r24,weeklySeconds
 11618 415a 9091 0000 		lds r25,weeklySeconds+1
 11619 415e A091 0000 		lds r26,weeklySeconds+2
 11620 4162 B091 0000 		lds r27,weeklySeconds+3
 11621 4166 840F      		add r24,r20
 11622 4168 951F      		adc r25,r21
 11623 416a A61F      		adc r26,r22
 11624 416c B71F      		adc r27,r23
 11625 416e F801      		movw r30,r16
 11626 4170 EE0F      		lsl r30
 11627 4172 FF1F      		rol r31
 11628 4174 EE0F      		lsl r30
 11629 4176 FF1F      		rol r31
 11630 4178 E050      		subi r30,lo8(-(switchStatus))
 11631 417a F040      		sbci r31,hi8(-(switchStatus))
 11632 417c 4081      		ld r20,Z
 11633 417e 5181      		ldd r21,Z+1
 11634 4180 6281      		ldd r22,Z+2
 11635 4182 7381      		ldd r23,Z+3
 11636               	.LVL1002:
 11637 4184 4817      		cp r20,r24
 11638 4186 5907      		cpc r21,r25
 11639 4188 6A07      		cpc r22,r26
 11640 418a 7B07      		cpc r23,r27
 11641 418c 00F4      		brsh .L800
 704:switcherator.c ****         switchStatus[switchNumber] = (weeklySeconds + duration);
 11642               		.loc 1 704 0
 11643 418e 8083      		st Z,r24
 11644 4190 9183      		std Z+1,r25
 11645 4192 A283      		std Z+2,r26
 11646 4194 B383      		std Z+3,r27
 11647               	.L800:
 707:switcherator.c ****     if (switchStuff[switchNumber] >= 200 && switchStuff[switchNumber] <= 220) {
 11648               		.loc 1 707 0
 11649 4196 822F      		mov r24,r18
 11650 4198 885C      		subi r24,lo8(-(56))
 11651 419a 8531      		cpi r24,lo8(21)
 11652 419c 00F0      		brlo .+2
 11653 419e 00C0      		rjmp .L801
 709:switcherator.c ****         if (switchStuff[switchNumber] == 200) {
 11654               		.loc 1 709 0
 11655 41a0 283C      		cpi r18,lo8(-56)
 11656 41a2 01F4      		brne .L802
 712:switcherator.c ****             green = pwmValues[1];
 11657               		.loc 1 712 0
 11658 41a4 8091 0000 		lds r24,pwmValues+1
 713:switcherator.c ****             blue = pwmValues[2];
 11659               		.loc 1 713 0
 11660 41a8 E091 0000 		lds r30,pwmValues+2
 714:switcherator.c ****             red = red * bright / 16;
 11661               		.loc 1 714 0
 11662 41ac 6091 0000 		lds r22,bright
 11663 41b0 7091 0000 		lds r23,bright+1
 711:switcherator.c ****             red = pwmValues[0];
 11664               		.loc 1 711 0
 11665 41b4 9091 0000 		lds r25,pwmValues
 714:switcherator.c ****             red = red * bright / 16;
 11666               		.loc 1 714 0
 11667 41b8 969F      		mul r25,r22
 11668 41ba A001      		movw r20,r0
 11669 41bc 979F      		mul r25,r23
 11670 41be 500D      		add r21,r0
 11671 41c0 1124      		clr __zero_reg__
 11672 41c2 F4E0      		ldi r31,4
 11673               		1:
 11674 41c4 5695      		lsr r21
 11675 41c6 4795      		ror r20
 11676 41c8 FA95      		dec r31
 11677 41ca 01F4      		brne 1b
 11678 41cc 5093 0000 		sts red+1,r21
 11679 41d0 4093 0000 		sts red,r20
 715:switcherator.c ****             green = green * bright / 16;
 11680               		.loc 1 715 0
 11681 41d4 869F      		mul r24,r22
 11682 41d6 9001      		movw r18,r0
 11683 41d8 879F      		mul r24,r23
 11684 41da 300D      		add r19,r0
 11685 41dc 1124      		clr __zero_reg__
 11686 41de A4E0      		ldi r26,4
 11687               		1:
 11688 41e0 3695      		lsr r19
 11689 41e2 2795      		ror r18
 11690 41e4 AA95      		dec r26
 11691 41e6 01F4      		brne 1b
 11692 41e8 3093 0000 		sts green+1,r19
 11693 41ec 2093 0000 		sts green,r18
 716:switcherator.c ****             blue = blue * bright / 16;
 11694               		.loc 1 716 0
 11695 41f0 E69F      		mul r30,r22
 11696 41f2 C001      		movw r24,r0
 11697 41f4 E79F      		mul r30,r23
 11698 41f6 900D      		add r25,r0
 11699 41f8 1124      		clr __zero_reg__
 11700 41fa B4E0      		ldi r27,4
 11701               		1:
 11702 41fc 9695      		lsr r25
 11703 41fe 8795      		ror r24
 11704 4200 BA95      		dec r27
 11705 4202 01F4      		brne 1b
 11706 4204 9093 0000 		sts blue+1,r25
 11707 4208 8093 0000 		sts blue,r24
 717:switcherator.c ****             Red = red;
 11708               		.loc 1 717 0
 11709 420c 4093 B400 		sts 180,r20
 718:switcherator.c ****             Green = green;
 11710               		.loc 1 718 0
 11711 4210 28BD      		out 0x28,r18
 719:switcherator.c ****             Blue = blue;
 11712               		.loc 1 719 0
 11713 4212 87BD      		out 0x27,r24
 11714 4214 00C0      		rjmp .L803
 11715               	.L802:
 720:switcherator.c ****         } else if (switchStuff[switchNumber] == 202) {
 11716               		.loc 1 720 0
 11717 4216 2A3C      		cpi r18,lo8(-54)
 11718 4218 01F4      		brne .L804
 721:switcherator.c ****             runColorChanges = 1;
 11719               		.loc 1 721 0
 11720 421a 81E0      		ldi r24,lo8(1)
 11721 421c 8093 0000 		sts runColorChanges,r24
 11722 4220 00C0      		rjmp .L803
 11723               	.L804:
 722:switcherator.c ****         } else if (switchStuff[switchNumber] == 212) {
 11724               		.loc 1 722 0
 11725 4222 243D      		cpi r18,lo8(-44)
 11726 4224 01F4      		brne .L805
 723:switcherator.c ****             bright = switchBright[switchNumber];
 11727               		.loc 1 723 0
 11728 4226 F801      		movw r30,r16
 11729 4228 E050      		subi r30,lo8(-(switchBright))
 11730 422a F040      		sbci r31,hi8(-(switchBright))
 11731 422c 8081      		ld r24,Z
 11732 422e 8093 0000 		sts bright,r24
 11733 4232 1092 0000 		sts bright+1,__zero_reg__
 11734 4236 00C0      		rjmp .L803
 11735               	.L805:
 725:switcherator.c ****             runHue = 1;
 11736               		.loc 1 725 0
 11737 4238 81E0      		ldi r24,lo8(1)
 11738 423a 8093 0000 		sts runHue,r24
 11739 423e 00C0      		rjmp .L803
 11740               	.L801:
 11741               	.LVL1003:
 11742               	.LBB29:
 736:switcherator.c ****         getPort(switchNumber, port, pin, direction);
 11743               		.loc 1 736 0
 11744 4240 9E01      		movw r18,r28
 11745 4242 2F5F      		subi r18,-1
 11746 4244 3F4F      		sbci r19,-1
 11747 4246 AE01      		movw r20,r28
 11748 4248 4E5F      		subi r20,-2
 11749 424a 5F4F      		sbci r21,-1
 11750 424c BE01      		movw r22,r28
 11751 424e 6D5F      		subi r22,-3
 11752 4250 7F4F      		sbci r23,-1
 11753 4252 C801      		movw r24,r16
 11754 4254 0E94 0000 		call getPort
 11755               	.LVL1004:
 738:switcherator.c ****         realPin = pin[0];
 11756               		.loc 1 738 0
 11757 4258 3A81      		ldd r19,Y+2
 11758               	.LVL1005:
 739:switcherator.c ****         if (port[0] == 'B')
 11759               		.loc 1 739 0
 11760 425a 8B81      		ldd r24,Y+3
 11761 425c 8234      		cpi r24,lo8(66)
 11762 425e 01F0      		breq .L809
 746:switcherator.c ****         else if (port[0] == 'C')
 11763               		.loc 1 746 0
 11764 4260 8334      		cpi r24,lo8(67)
 11765 4262 01F0      		breq .L810
 750:switcherator.c ****         else if (port[0] == 'D')
 11766               		.loc 1 750 0
 11767 4264 8434      		cpi r24,lo8(68)
 11768 4266 01F0      		breq .L811
 735:switcherator.c ****         volatile unsigned char *thisPort = 0;
 11769               		.loc 1 735 0
 11770 4268 E0E0      		ldi r30,0
 11771 426a F0E0      		ldi r31,0
 11772 426c 00C0      		rjmp .L806
 11773               	.L809:
 740:switcherator.c ****             thisPort = &PORTB;
 11774               		.loc 1 740 0
 11775 426e E5E2      		ldi r30,lo8(37)
 11776 4270 F0E0      		ldi r31,0
 11777 4272 00C0      		rjmp .L806
 11778               	.L810:
 747:switcherator.c ****             thisPort = &PORTC;
 11779               		.loc 1 747 0
 11780 4274 E8E2      		ldi r30,lo8(40)
 11781 4276 F0E0      		ldi r31,0
 11782 4278 00C0      		rjmp .L806
 11783               	.L811:
 751:switcherator.c ****             thisPort = &PORTD;
 11784               		.loc 1 751 0
 11785 427a EBE2      		ldi r30,lo8(43)
 11786 427c F0E0      		ldi r31,0
 11787               	.L806:
 11788               	.LVL1006:
 775:switcherator.c ****         if (direction[0] == 0) {
 11789               		.loc 1 775 0
 11790 427e 8981      		ldd r24,Y+1
 776:switcherator.c ****             *thisPort &= ~(1 << realPin);
 11791               		.loc 1 776 0
 11792 4280 2081      		ld r18,Z
 775:switcherator.c ****         if (direction[0] == 0) {
 11793               		.loc 1 775 0
 11794 4282 8111      		cpse r24,__zero_reg__
 11795 4284 00C0      		rjmp .L807
 776:switcherator.c ****             *thisPort &= ~(1 << realPin);
 11796               		.loc 1 776 0
 11797 4286 81E0      		ldi r24,lo8(1)
 11798 4288 90E0      		ldi r25,0
 11799 428a 032E      		mov r0,r19
 11800 428c 00C0      		rjmp 2f
 11801               		1:
 11802 428e 880F      		lsl r24
 11803               		2:
 11804 4290 0A94      		dec r0
 11805 4292 02F4      		brpl 1b
 11806 4294 8095      		com r24
 11807 4296 2823      		and r18,r24
 11808 4298 00C0      		rjmp .L812
 11809               	.L807:
 778:switcherator.c ****             *thisPort |= (1 << realPin);
 11810               		.loc 1 778 0
 11811 429a 81E0      		ldi r24,lo8(1)
 11812 429c 90E0      		ldi r25,0
 11813 429e 00C0      		rjmp 2f
 11814               		1:
 11815 42a0 880F      		lsl r24
 11816               		2:
 11817 42a2 3A95      		dec r19
 11818 42a4 02F4      		brpl 1b
 11819 42a6 282B      		or r18,r24
 11820               	.L812:
 11821 42a8 2083      		st Z,r18
 11822               	.LVL1007:
 11823               	.L803:
 11824               	.LBE29:
 781:switcherator.c ****     ok();
 11825               		.loc 1 781 0
 11826 42aa 0E94 0000 		call ok
 11827               	.LVL1008:
 11828               	.L795:
 11829               	/* epilogue start */
 782:switcherator.c **** }
 11830               		.loc 1 782 0
 11831 42ae 0F90      		pop __tmp_reg__
 11832 42b0 0F90      		pop __tmp_reg__
 11833 42b2 0F90      		pop __tmp_reg__
 11834 42b4 0F90      		pop __tmp_reg__
 11835 42b6 DF91      		pop r29
 11836 42b8 CF91      		pop r28
 11837 42ba 1F91      		pop r17
 11838 42bc 0F91      		pop r16
 11839               	.LVL1009:
 11840 42be FF90      		pop r15
 11841 42c0 EF90      		pop r14
 11842               	.LVL1010:
 11843 42c2 0895      		ret
 11844               	.LFE17:
 11846               	.global	setNewSwitch
 11848               	setNewSwitch:
 11849               	.LFB13:
 451:switcherator.c **** void setNewSwitch(char * commandReceived) {
 11850               		.loc 1 451 0
 11851               	.LVL1011:
 11852 42c4 AF92      		push r10
 11853               	.LCFI308:
 11854 42c6 BF92      		push r11
 11855               	.LCFI309:
 11856 42c8 CF92      		push r12
 11857               	.LCFI310:
 11858 42ca DF92      		push r13
 11859               	.LCFI311:
 11860 42cc EF92      		push r14
 11861               	.LCFI312:
 11862 42ce FF92      		push r15
 11863               	.LCFI313:
 11864 42d0 0F93      		push r16
 11865               	.LCFI314:
 11866 42d2 1F93      		push r17
 11867               	.LCFI315:
 11868 42d4 CF93      		push r28
 11869               	.LCFI316:
 11870 42d6 DF93      		push r29
 11871               	.LCFI317:
 11872 42d8 1F92      		push __zero_reg__
 11873               	.LCFI318:
 11874 42da CDB7      		in r28,__SP_L__
 11875 42dc DEB7      		in r29,__SP_H__
 11876               	.LCFI319:
 11877               	/* prologue: function */
 11878               	/* frame size = 1 */
 11879               	/* stack size = 11 */
 11880               	.L__stack_usage = 11
 11881 42de 6C01      		movw r12,r24
 11882               	.LVL1012:
 461:switcherator.c ****     tempIntString[0] = '0';
 11883               		.loc 1 461 0
 11884 42e0 80E3      		ldi r24,lo8(48)
 11885               	.LVL1013:
 11886 42e2 8093 0000 		sts tempIntString,r24
 462:switcherator.c ****     tempIntString[1] = commandReceived[6];
 11887               		.loc 1 462 0
 11888 42e6 D601      		movw r26,r12
 11889 42e8 1696      		adiw r26,6
 11890 42ea 8C91      		ld r24,X
 11891 42ec 8093 0000 		sts tempIntString+1,r24
 463:switcherator.c ****     pin = atoi(tempIntString);
 11892               		.loc 1 463 0
 11893 42f0 80E0      		ldi r24,lo8(tempIntString)
 11894 42f2 90E0      		ldi r25,hi8(tempIntString)
 11895 42f4 0E94 0000 		call atoi
 11896               	.LVL1014:
 11897 42f8 F82E      		mov r15,r24
 11898               	.LVL1015:
 465:switcherator.c ****     tempIntString[1] = commandReceived[7];
 11899               		.loc 1 465 0
 11900 42fa F601      		movw r30,r12
 11901 42fc 8781      		ldd r24,Z+7
 11902 42fe 8093 0000 		sts tempIntString+1,r24
 466:switcherator.c ****     direction = atoi(tempIntString);
 11903               		.loc 1 466 0
 11904 4302 80E0      		ldi r24,lo8(tempIntString)
 11905 4304 90E0      		ldi r25,hi8(tempIntString)
 11906 4306 0E94 0000 		call atoi
 11907               	.LVL1016:
 11908 430a E82E      		mov r14,r24
 11909               	.LVL1017:
 467:switcherator.c ****     port = commandReceived[5];
 11910               		.loc 1 467 0
 11911 430c D601      		movw r26,r12
 11912 430e 1596      		adiw r26,5
 11913 4310 2C91      		ld r18,X
 11914               	.LVL1018:
 468:switcherator.c ****     switchNumber = getSwitchNumber(commandReceived);
 11915               		.loc 1 468 0
 11916 4312 C601      		movw r24,r12
 11917 4314 2983      		std Y+1,r18
 11918 4316 0E94 0000 		call getSwitchNumber
 11919               	.LVL1019:
 11920 431a 8C01      		movw r16,r24
 11921               	.LVL1020:
 470:switcherator.c ****     clearTheSwitch(switchNumber);
 11922               		.loc 1 470 0
 11923 431c 0E94 0000 		call clearTheSwitch
 11924               	.LVL1021:
 472:switcherator.c ****     if (port == 'B' || port == 'b') {
 11925               		.loc 1 472 0
 11926 4320 2981      		ldd r18,Y+1
 11927 4322 2234      		cpi r18,lo8(66)
 11928 4324 01F4      		brne .+2
 11929 4326 00C0      		rjmp .L825
 472:switcherator.c ****     if (port == 'B' || port == 'b') {
 11930               		.loc 1 472 0 is_stmt 0 discriminator 1
 11931 4328 2236      		cpi r18,lo8(98)
 11932 432a 01F4      		brne .+2
 11933 432c 00C0      		rjmp .L825
 483:switcherator.c ****     } else if (port == 'C' || port == 'c') {
 11934               		.loc 1 483 0 is_stmt 1
 11935 432e 2334      		cpi r18,lo8(67)
 11936 4330 01F4      		brne .+2
 11937 4332 00C0      		rjmp .L827
 483:switcherator.c ****     } else if (port == 'C' || port == 'c') {
 11938               		.loc 1 483 0 is_stmt 0 discriminator 1
 11939 4334 2336      		cpi r18,lo8(99)
 11940 4336 01F4      		brne .+2
 11941 4338 00C0      		rjmp .L827
 489:switcherator.c ****     } else if (port == 'D' || port == 'd') {
 11942               		.loc 1 489 0 is_stmt 1
 11943 433a 2434      		cpi r18,lo8(68)
 11944 433c 01F4      		brne .+2
 11945 433e 00C0      		rjmp .L829
 489:switcherator.c ****     } else if (port == 'D' || port == 'd') {
 11946               		.loc 1 489 0 is_stmt 0 discriminator 1
 11947 4340 2436      		cpi r18,lo8(100)
 11948 4342 01F0      		breq .+2
 11949 4344 00C0      		rjmp .L839
 11950 4346 00C0      		rjmp .L829
 11951               	.LVL1022:
 11952               	.L840:
 530:switcherator.c ****     } else if ((switchNumber >= NUM_SWITCHES) ||
 11953               		.loc 1 530 0 is_stmt 1 discriminator 1
 11954 4348 0115      		cp r16,__zero_reg__
 11955 434a 1105      		cpc r17,__zero_reg__
 11956 434c 01F4      		brne .L817
 531:switcherator.c ****             ((switchNumber == 0) && (commandReceived[3] != '0') && (commandReceived[4] != 0))) {
 11957               		.loc 1 531 0
 11958 434e D601      		movw r26,r12
 11959 4350 1396      		adiw r26,3
 11960 4352 8C91      		ld r24,X
 11961 4354 1397      		sbiw r26,3
 11962 4356 8033      		cpi r24,lo8(48)
 11963 4358 01F0      		breq .L817
 531:switcherator.c ****             ((switchNumber == 0) && (commandReceived[3] != '0') && (commandReceived[4] != 0))) {
 11964               		.loc 1 531 0 is_stmt 0 discriminator 1
 11965 435a 1496      		adiw r26,4
 11966 435c 8C91      		ld r24,X
 11967 435e 8823      		tst r24
 11968 4360 01F0      		breq .L817
 11969               	.L822:
 532:switcherator.c ****         fail(1);
 11970               		.loc 1 532 0 is_stmt 1
 11971 4362 81E0      		ldi r24,lo8(1)
 11972 4364 90E0      		ldi r25,0
 11973 4366 00C0      		rjmp .L841
 11974               	.L817:
 463:switcherator.c ****     pin = atoi(tempIntString);
 11975               		.loc 1 463 0
 11976 4368 4F2D      		mov r20,r15
 533:switcherator.c ****     } else if ((pin > 7) || ((pin == 0) && (commandReceived[6] != '0'))) {
 11977               		.loc 1 533 0
 11978 436a 4830      		cpi r20,lo8(8)
 11979 436c 00F4      		brsh .L818
 533:switcherator.c ****     } else if ((pin > 7) || ((pin == 0) && (commandReceived[6] != '0'))) {
 11980               		.loc 1 533 0 is_stmt 0 discriminator 1
 11981 436e F110      		cpse r15,__zero_reg__
 11982 4370 00C0      		rjmp .L819
 11983 4372 D601      		movw r26,r12
 11984 4374 1696      		adiw r26,6
 11985 4376 8C91      		ld r24,X
 11986 4378 8033      		cpi r24,lo8(48)
 11987 437a 01F0      		breq .L819
 11988               	.L818:
 534:switcherator.c ****         fail(4);
 11989               		.loc 1 534 0 is_stmt 1
 11990 437c 84E0      		ldi r24,lo8(4)
 11991 437e 90E0      		ldi r25,0
 11992 4380 00C0      		rjmp .L841
 11993               	.L819:
 537:switcherator.c ****         *realDDR |= (1 << originalPin);
 11994               		.loc 1 537 0
 11995 4382 D501      		movw r26,r10
 11996 4384 5C91      		ld r21,X
 11997 4386 21E0      		ldi r18,lo8(1)
 11998 4388 30E0      		ldi r19,0
 11999 438a 0F2C      		mov r0,r15
 12000 438c 00C0      		rjmp 2f
 12001               		1:
 12002 438e 220F      		lsl r18
 12003               		2:
 12004 4390 0A94      		dec r0
 12005 4392 02F4      		brpl 1b
 12006 4394 522B      		or r21,r18
 12007 4396 5C93      		st X,r21
 539:switcherator.c ****         pinMultiplied = pin * 2;
 12008               		.loc 1 539 0
 12009 4398 440F      		lsl r20
 12010               	.LVL1023:
 542:switcherator.c ****         switchStuff[switchNumber] = pin;
 12011               		.loc 1 542 0
 12012 439a D801      		movw r26,r16
 12013 439c A050      		subi r26,lo8(-(switchStuff))
 12014 439e B040      		sbci r27,hi8(-(switchStuff))
 541:switcherator.c ****         pin = pinMultiplied + pinSubtractee;
 12015               		.loc 1 541 0
 12016 43a0 490F      		add r20,r25
 12017               	.LVL1024:
 542:switcherator.c ****         switchStuff[switchNumber] = pin;
 12018               		.loc 1 542 0
 12019 43a2 4C93      		st X,r20
 546:switcherator.c ****             *realPort |= (1 << originalPin);
 12020               		.loc 1 546 0
 12021 43a4 8081      		ld r24,Z
 544:switcherator.c ****         if (direction == 0) {
 12022               		.loc 1 544 0
 12023 43a6 E110      		cpse r14,__zero_reg__
 12024 43a8 00C0      		rjmp .L820
 546:switcherator.c ****             *realPort |= (1 << originalPin);
 12025               		.loc 1 546 0
 12026 43aa 822B      		or r24,r18
 12027 43ac 8083      		st Z,r24
 12028 43ae 00C0      		rjmp .L821
 12029               	.L820:
 548:switcherator.c ****             *realPort &= ~(1 << originalPin);
 12030               		.loc 1 548 0
 12031 43b0 2095      		com r18
 12032 43b2 8223      		and r24,r18
 12033 43b4 8083      		st Z,r24
 549:switcherator.c ****             switchStuff[switchNumber]++;
 12034               		.loc 1 549 0
 12035 43b6 8C91      		ld r24,X
 12036 43b8 8F5F      		subi r24,lo8(-(1))
 12037 43ba 8C93      		st X,r24
 12038               	.L821:
 12039               	/* epilogue start */
 553:switcherator.c **** }
 12040               		.loc 1 553 0
 12041 43bc 0F90      		pop __tmp_reg__
 12042 43be DF91      		pop r29
 12043 43c0 CF91      		pop r28
 12044 43c2 1F91      		pop r17
 12045 43c4 0F91      		pop r16
 12046               	.LVL1025:
 12047 43c6 FF90      		pop r15
 12048               	.LVL1026:
 12049 43c8 EF90      		pop r14
 12050               	.LVL1027:
 12051 43ca DF90      		pop r13
 12052 43cc CF90      		pop r12
 12053               	.LVL1028:
 12054 43ce BF90      		pop r11
 12055 43d0 AF90      		pop r10
 12056               	.LVL1029:
 551:switcherator.c ****         ok();
 12057               		.loc 1 551 0
 12058 43d2 0C94 0000 		jmp ok
 12059               	.LVL1030:
 12060               	.L839:
 529:switcherator.c ****         fail(2);
 12061               		.loc 1 529 0
 12062 43d6 82E0      		ldi r24,lo8(2)
 12063 43d8 90E0      		ldi r25,0
 12064               	.LVL1031:
 12065               	.L841:
 12066               	/* epilogue start */
 553:switcherator.c **** }
 12067               		.loc 1 553 0
 12068 43da 0F90      		pop __tmp_reg__
 12069 43dc DF91      		pop r29
 12070 43de CF91      		pop r28
 12071 43e0 1F91      		pop r17
 12072 43e2 0F91      		pop r16
 12073               	.LVL1032:
 12074 43e4 FF90      		pop r15
 12075               	.LVL1033:
 12076 43e6 EF90      		pop r14
 12077               	.LVL1034:
 12078 43e8 DF90      		pop r13
 12079 43ea CF90      		pop r12
 12080               	.LVL1035:
 12081 43ec BF90      		pop r11
 12082 43ee AF90      		pop r10
 529:switcherator.c ****         fail(2);
 12083               		.loc 1 529 0
 12084 43f0 0C94 0000 		jmp fail
 12085               	.LVL1036:
 12086               	.L825:
 474:switcherator.c ****         realDDR = &DDRB;
 12087               		.loc 1 474 0
 12088 43f4 64E2      		ldi r22,lo8(36)
 12089 43f6 A62E      		mov r10,r22
 12090 43f8 B12C      		mov r11,__zero_reg__
 473:switcherator.c ****         realPort = &PORTB;
 12091               		.loc 1 473 0
 12092 43fa E5E2      		ldi r30,lo8(37)
 12093 43fc F0E0      		ldi r31,0
 475:switcherator.c ****         pinSubtractee = 16;
 12094               		.loc 1 475 0
 12095 43fe 90E1      		ldi r25,lo8(16)
 12096 4400 00C0      		rjmp .L815
 12097               	.L827:
 485:switcherator.c ****         realDDR = &DDRC;
 12098               		.loc 1 485 0
 12099 4402 57E2      		ldi r21,lo8(39)
 12100 4404 A52E      		mov r10,r21
 12101 4406 B12C      		mov r11,__zero_reg__
 484:switcherator.c ****         realPort = &PORTC;
 12102               		.loc 1 484 0
 12103 4408 E8E2      		ldi r30,lo8(40)
 12104 440a F0E0      		ldi r31,0
 486:switcherator.c ****         pinSubtractee = 32;
 12105               		.loc 1 486 0
 12106 440c 90E2      		ldi r25,lo8(32)
 12107 440e 00C0      		rjmp .L815
 12108               	.L829:
 491:switcherator.c ****         realDDR = &DDRD;
 12109               		.loc 1 491 0
 12110 4410 4AE2      		ldi r20,lo8(42)
 12111 4412 A42E      		mov r10,r20
 12112 4414 B12C      		mov r11,__zero_reg__
 490:switcherator.c ****         realPort = &PORTD;
 12113               		.loc 1 490 0
 12114 4416 EBE2      		ldi r30,lo8(43)
 12115 4418 F0E0      		ldi r31,0
 492:switcherator.c ****         pinSubtractee = 48;
 12116               		.loc 1 492 0
 12117 441a 90E3      		ldi r25,lo8(48)
 12118               	.L815:
 12119               	.LVL1037:
 530:switcherator.c ****     } else if ((switchNumber >= NUM_SWITCHES) ||
 12120               		.loc 1 530 0
 12121 441c 0031      		cpi r16,16
 12122 441e 1105      		cpc r17,__zero_reg__
 12123 4420 04F4      		brge .+2
 12124 4422 00C0      		rjmp .L840
 12125 4424 00C0      		rjmp .L822
 12126               	.LFE13:
 12128               		.section	.rodata.str1.1
 12129               	.LC72:
 12130 0160 5374 6172 		.string	"Start:"
 12130      743A 00
 12131               	.LC73:
 12132 0167 5374 6F70 		.string	"Stop:"
 12132      3A00 
 12133               		.text
 12134               	.global	setTimeLimits
 12136               	setTimeLimits:
 12137               	.LFB59:
2546:switcherator.c **** void setTimeLimits(char * commandReceived) {
 12138               		.loc 1 2546 0
 12139               	.LVL1038:
 12140 4426 2F92      		push r2
 12141               	.LCFI320:
 12142 4428 3F92      		push r3
 12143               	.LCFI321:
 12144 442a 4F92      		push r4
 12145               	.LCFI322:
 12146 442c 5F92      		push r5
 12147               	.LCFI323:
 12148 442e 6F92      		push r6
 12149               	.LCFI324:
 12150 4430 7F92      		push r7
 12151               	.LCFI325:
 12152 4432 8F92      		push r8
 12153               	.LCFI326:
 12154 4434 9F92      		push r9
 12155               	.LCFI327:
 12156 4436 AF92      		push r10
 12157               	.LCFI328:
 12158 4438 BF92      		push r11
 12159               	.LCFI329:
 12160 443a CF92      		push r12
 12161               	.LCFI330:
 12162 443c DF92      		push r13
 12163               	.LCFI331:
 12164 443e EF92      		push r14
 12165               	.LCFI332:
 12166 4440 FF92      		push r15
 12167               	.LCFI333:
 12168 4442 0F93      		push r16
 12169               	.LCFI334:
 12170 4444 1F93      		push r17
 12171               	.LCFI335:
 12172 4446 CF93      		push r28
 12173               	.LCFI336:
 12174 4448 DF93      		push r29
 12175               	.LCFI337:
 12176 444a CDB7      		in r28,__SP_L__
 12177 444c DEB7      		in r29,__SP_H__
 12178               	.LCFI338:
 12179 444e 2C97      		sbiw r28,12
 12180               	.LCFI339:
 12181 4450 0FB6      		in __tmp_reg__,__SREG__
 12182 4452 F894      		cli
 12183 4454 DEBF      		out __SP_H__,r29
 12184 4456 0FBE      		out __SREG__,__tmp_reg__
 12185 4458 CDBF      		out __SP_L__,r28
 12186               	/* prologue: function */
 12187               	/* frame size = 12 */
 12188               	/* stack size = 30 */
 12189               	.L__stack_usage = 30
 12190 445a 6C01      		movw r12,r24
2547:switcherator.c ****     char tempReallyLongString[] = "0000000";
 12191               		.loc 1 2547 0
 12192 445c 88E0      		ldi r24,lo8(8)
 12193               	.LVL1039:
 12194 445e E0E0      		ldi r30,lo8(.LC71)
 12195 4460 F0E0      		ldi r31,hi8(.LC71)
 12196 4462 DE01      		movw r26,r28
 12197 4464 1196      		adiw r26,1
 12198               		0:
 12199 4466 0190      		ld r0,Z+
 12200 4468 0D92      		st X+,r0
 12201 446a 8A95      		dec r24
 12202 446c 01F4      		brne 0b
 12203               	.LVL1040:
2553:switcherator.c ****     statusMsg[0] = 0;
 12204               		.loc 1 2553 0
 12205 446e 1092 0000 		sts statusMsg,__zero_reg__
2555:switcherator.c ****     tempIntString[0] = commandReceived[3];
 12206               		.loc 1 2555 0
 12207 4472 F601      		movw r30,r12
 12208 4474 8381      		ldd r24,Z+3
 12209 4476 8093 0000 		sts tempIntString,r24
2556:switcherator.c ****     tempIntString[1] = commandReceived[4];
 12210               		.loc 1 2556 0
 12211 447a 8481      		ldd r24,Z+4
 12212 447c 8093 0000 		sts tempIntString+1,r24
2557:switcherator.c ****     programNumber = atoi(tempIntString);
 12213               		.loc 1 2557 0
 12214 4480 80E0      		ldi r24,lo8(tempIntString)
 12215 4482 90E0      		ldi r25,hi8(tempIntString)
 12216 4484 0E94 0000 		call atoi
 12217               	.LVL1041:
 12218 4488 8C01      		movw r16,r24
 12219               	.LVL1042:
2558:switcherator.c ****     if (programNumber > NUM_LIMITS) {
 12220               		.loc 1 2558 0
 12221 448a 8530      		cpi r24,5
 12222 448c 9105      		cpc r25,__zero_reg__
 12223 448e 04F0      		brlt .L843
2559:switcherator.c ****         fail(0x10);
 12224               		.loc 1 2559 0
 12225 4490 80E1      		ldi r24,lo8(16)
 12226 4492 90E0      		ldi r25,0
 12227 4494 00C0      		rjmp .L854
 12228               	.L843:
2562:switcherator.c ****     if (commandReceived[5] == 'x' || commandReceived[5] == 'x') {
 12229               		.loc 1 2562 0
 12230 4496 F601      		movw r30,r12
 12231 4498 8581      		ldd r24,Z+5
 12232 449a 8837      		cpi r24,lo8(120)
 12233 449c 01F4      		brne .L845
2563:switcherator.c ****         timeLimits[programNumber][2] = 0;
 12234               		.loc 1 2563 0
 12235 449e 8CE0      		ldi r24,lo8(12)
 12236 44a0 809F      		mul r24,r16
 12237 44a2 F001      		movw r30,r0
 12238 44a4 819F      		mul r24,r17
 12239 44a6 F00D      		add r31,r0
 12240 44a8 1124      		clr __zero_reg__
 12241 44aa E050      		subi r30,lo8(-(timeLimits))
 12242 44ac F040      		sbci r31,hi8(-(timeLimits))
 12243 44ae 1086      		std Z+8,__zero_reg__
 12244 44b0 1186      		std Z+9,__zero_reg__
 12245 44b2 1286      		std Z+10,__zero_reg__
 12246 44b4 1386      		std Z+11,__zero_reg__
 12247 44b6 00C0      		rjmp .L855
 12248               	.L845:
2567:switcherator.c ****     if (commandReceived[5] == '?') {
 12249               		.loc 1 2567 0
 12250 44b8 8F33      		cpi r24,lo8(63)
 12251 44ba 01F0      		breq .+2
 12252 44bc 00C0      		rjmp .L846
2569:switcherator.c ****         startTime = timeLimits[programNumber][0];
 12253               		.loc 1 2569 0
 12254 44be 8CE0      		ldi r24,lo8(12)
 12255 44c0 809F      		mul r24,r16
 12256 44c2 F001      		movw r30,r0
 12257 44c4 819F      		mul r24,r17
 12258 44c6 F00D      		add r31,r0
 12259 44c8 1124      		clr __zero_reg__
 12260 44ca E050      		subi r30,lo8(-(timeLimits))
 12261 44cc F040      		sbci r31,hi8(-(timeLimits))
 12262 44ce 8080      		ld r8,Z
 12263 44d0 9180      		ldd r9,Z+1
 12264 44d2 A280      		ldd r10,Z+2
 12265 44d4 B380      		ldd r11,Z+3
 12266               	.LVL1043:
2571:switcherator.c ****         strcat(statusMsg, "Start:");
 12267               		.loc 1 2571 0
 12268 44d6 60E0      		ldi r22,lo8(.LC72)
 12269 44d8 70E0      		ldi r23,hi8(.LC72)
 12270 44da 80E0      		ldi r24,lo8(statusMsg)
 12271 44dc 90E0      		ldi r25,hi8(statusMsg)
 12272 44de 0E94 0000 		call strcat
 12273               	.LVL1044:
2572:switcherator.c ****         startHour = (startTime / 60 / 60);
 12274               		.loc 1 2572 0
 12275 44e2 C501      		movw r24,r10
 12276 44e4 B401      		movw r22,r8
 12277 44e6 20E1      		ldi r18,lo8(16)
 12278 44e8 3EE0      		ldi r19,lo8(14)
 12279 44ea 40E0      		ldi r20,0
 12280 44ec 50E0      		ldi r21,0
 12281 44ee 0E94 0000 		call __divmodsi4
 12282 44f2 6901      		movw r12,r18
 12283 44f4 7A01      		movw r14,r20
 12284               	.LVL1045:
2573:switcherator.c ****         returnInt(startHour, tempLongString);
 12285               		.loc 1 2573 0
 12286 44f6 60E0      		ldi r22,lo8(tempLongString)
 12287 44f8 70E0      		ldi r23,hi8(tempLongString)
 12288 44fa C901      		movw r24,r18
 12289 44fc 0E94 0000 		call returnInt
 12290               	.LVL1046:
2574:switcherator.c ****         strcat(statusMsg, tempLongString);
 12291               		.loc 1 2574 0
 12292 4500 60E0      		ldi r22,lo8(tempLongString)
 12293 4502 70E0      		ldi r23,hi8(tempLongString)
 12294 4504 80E0      		ldi r24,lo8(statusMsg)
 12295 4506 90E0      		ldi r25,hi8(statusMsg)
 12296 4508 0E94 0000 		call strcat
 12297               	.LVL1047:
2576:switcherator.c ****         strcat(statusMsg, ":");
 12298               		.loc 1 2576 0
 12299 450c 60E0      		ldi r22,lo8(.LC4)
 12300 450e 70E0      		ldi r23,hi8(.LC4)
 12301 4510 80E0      		ldi r24,lo8(statusMsg)
 12302 4512 90E0      		ldi r25,hi8(statusMsg)
 12303 4514 0E94 0000 		call strcat
 12304               	.LVL1048:
2575:switcherator.c ****         startMinute = ((startTime - (startHour * 60 * 60)) / 60);
 12305               		.loc 1 2575 0
 12306 4518 20E1      		ldi r18,lo8(16)
 12307 451a 3EE0      		ldi r19,lo8(14)
 12308 451c C29E      		mul r12,r18
 12309 451e C001      		movw r24,r0
 12310 4520 C39E      		mul r12,r19
 12311 4522 900D      		add r25,r0
 12312 4524 D29E      		mul r13,r18
 12313 4526 900D      		add r25,r0
 12314 4528 1124      		clr r1
 12315 452a A501      		movw r20,r10
 12316 452c 9401      		movw r18,r8
 12317 452e 281B      		sub r18,r24
 12318 4530 390B      		sbc r19,r25
 12319 4532 4109      		sbc r20,__zero_reg__
 12320 4534 5109      		sbc r21,__zero_reg__
 12321 4536 CA01      		movw r24,r20
 12322 4538 B901      		movw r22,r18
 12323 453a 2CE3      		ldi r18,lo8(60)
 12324 453c 30E0      		ldi r19,0
 12325 453e 40E0      		ldi r20,0
 12326 4540 50E0      		ldi r21,0
 12327 4542 0E94 0000 		call __divmodsi4
2577:switcherator.c ****         returnInt(startMinute, tempLongString);
 12328               		.loc 1 2577 0
 12329 4546 60E0      		ldi r22,lo8(tempLongString)
 12330 4548 70E0      		ldi r23,hi8(tempLongString)
 12331 454a C901      		movw r24,r18
 12332 454c 2987      		std Y+9,r18
 12333 454e 3A87      		std Y+10,r19
 12334 4550 4B87      		std Y+11,r20
 12335 4552 5C87      		std Y+12,r21
 12336 4554 0E94 0000 		call returnInt
 12337               	.LVL1049:
2578:switcherator.c ****         strcat(statusMsg, tempLongString);
 12338               		.loc 1 2578 0
 12339 4558 60E0      		ldi r22,lo8(tempLongString)
 12340 455a 70E0      		ldi r23,hi8(tempLongString)
 12341 455c 80E0      		ldi r24,lo8(statusMsg)
 12342 455e 90E0      		ldi r25,hi8(statusMsg)
 12343 4560 0E94 0000 		call strcat
 12344               	.LVL1050:
2579:switcherator.c ****         strcat(statusMsg, "Stop:");
 12345               		.loc 1 2579 0
 12346 4564 60E0      		ldi r22,lo8(.LC73)
 12347 4566 70E0      		ldi r23,hi8(.LC73)
 12348 4568 80E0      		ldi r24,lo8(statusMsg)
 12349 456a 90E0      		ldi r25,hi8(statusMsg)
 12350 456c 0E94 0000 		call strcat
 12351               	.LVL1051:
2581:switcherator.c ****         returnInt(stopHour, tempLongString);
 12352               		.loc 1 2581 0
 12353 4570 60E0      		ldi r22,lo8(tempLongString)
 12354 4572 70E0      		ldi r23,hi8(tempLongString)
 12355 4574 C601      		movw r24,r12
 12356 4576 0E94 0000 		call returnInt
 12357               	.LVL1052:
2582:switcherator.c ****         strcat(statusMsg, tempLongString);
 12358               		.loc 1 2582 0
 12359 457a 60E0      		ldi r22,lo8(tempLongString)
 12360 457c 70E0      		ldi r23,hi8(tempLongString)
 12361 457e 80E0      		ldi r24,lo8(statusMsg)
 12362 4580 90E0      		ldi r25,hi8(statusMsg)
 12363 4582 0E94 0000 		call strcat
 12364               	.LVL1053:
2584:switcherator.c ****         strcat(statusMsg, ":");
 12365               		.loc 1 2584 0
 12366 4586 60E0      		ldi r22,lo8(.LC4)
 12367 4588 70E0      		ldi r23,hi8(.LC4)
 12368 458a 80E0      		ldi r24,lo8(statusMsg)
 12369 458c 90E0      		ldi r25,hi8(statusMsg)
 12370 458e 0E94 0000 		call strcat
 12371               	.LVL1054:
2585:switcherator.c ****         returnInt(stopMinute, tempLongString);
 12372               		.loc 1 2585 0
 12373 4592 60E0      		ldi r22,lo8(tempLongString)
 12374 4594 70E0      		ldi r23,hi8(tempLongString)
 12375 4596 2985      		ldd r18,Y+9
 12376 4598 3A85      		ldd r19,Y+10
 12377 459a C901      		movw r24,r18
 12378 459c 0E94 0000 		call returnInt
 12379               	.LVL1055:
2586:switcherator.c ****         strcat(statusMsg, tempLongString);
 12380               		.loc 1 2586 0
 12381 45a0 60E0      		ldi r22,lo8(tempLongString)
 12382 45a2 70E0      		ldi r23,hi8(tempLongString)
 12383 45a4 80E0      		ldi r24,lo8(statusMsg)
 12384 45a6 90E0      		ldi r25,hi8(statusMsg)
 12385 45a8 0E94 0000 		call strcat
 12386               	.LVL1056:
2587:switcherator.c ****         sendMessage(statusMsg);
 12387               		.loc 1 2587 0
 12388 45ac 80E0      		ldi r24,lo8(statusMsg)
 12389 45ae 90E0      		ldi r25,hi8(statusMsg)
 12390 45b0 0E94 0000 		call sendMessage
 12391               	.LVL1057:
 12392 45b4 00C0      		rjmp .L842
 12393               	.LVL1058:
 12394               	.L846:
2546:switcherator.c **** void setTimeLimits(char * commandReceived) {
 12395               		.loc 1 2546 0
 12396 45b6 D601      		movw r26,r12
 12397 45b8 1D96      		adiw r26,13
 12398 45ba FE01      		movw r30,r28
 12399 45bc 3196      		adiw r30,1
 12400 45be CE01      		movw r24,r28
 12401 45c0 0896      		adiw r24,8
 12402               	.LVL1059:
 12403               	.L847:
2591:switcherator.c ****         tempReallyLongString[x] = commandReceived[x + 13];
 12404               		.loc 1 2591 0 discriminator 2
 12405 45c2 2D91      		ld r18,X+
 12406 45c4 2193      		st Z+,r18
2590:switcherator.c ****     for (x = 0; x < 7; x++) {
 12407               		.loc 1 2590 0 discriminator 2
 12408 45c6 E817      		cp r30,r24
 12409 45c8 F907      		cpc r31,r25
 12410 45ca 01F4      		brne .L847
2593:switcherator.c ****     weekLong = strtol(tempReallyLongString, 0, 2);
 12411               		.loc 1 2593 0
 12412 45cc 42E0      		ldi r20,lo8(2)
 12413 45ce 50E0      		ldi r21,0
 12414 45d0 60E0      		ldi r22,0
 12415 45d2 70E0      		ldi r23,0
 12416 45d4 CE01      		movw r24,r28
 12417 45d6 0196      		adiw r24,1
 12418 45d8 0E94 0000 		call strtol
 12419               	.LVL1060:
 12420 45dc 2B01      		movw r4,r22
 12421 45de 3C01      		movw r6,r24
 12422               	.LVL1061:
2594:switcherator.c ****     tempIntString[0] = commandReceived[5];
 12423               		.loc 1 2594 0
 12424 45e0 F601      		movw r30,r12
 12425 45e2 8581      		ldd r24,Z+5
 12426 45e4 8093 0000 		sts tempIntString,r24
2595:switcherator.c ****     tempIntString[1] = commandReceived[6];
 12427               		.loc 1 2595 0
 12428 45e8 8681      		ldd r24,Z+6
 12429 45ea 8093 0000 		sts tempIntString+1,r24
2596:switcherator.c ****     startHour = atoi(tempIntString);
 12430               		.loc 1 2596 0
 12431 45ee 80E0      		ldi r24,lo8(tempIntString)
 12432 45f0 90E0      		ldi r25,hi8(tempIntString)
 12433 45f2 0E94 0000 		call atoi
 12434               	.LVL1062:
 12435 45f6 7C01      		movw r14,r24
 12436               	.LVL1063:
2597:switcherator.c ****     tempIntString[0] = commandReceived[7];
 12437               		.loc 1 2597 0
 12438 45f8 F601      		movw r30,r12
 12439 45fa 8781      		ldd r24,Z+7
 12440 45fc 8093 0000 		sts tempIntString,r24
2598:switcherator.c ****     tempIntString[1] = commandReceived[8];
 12441               		.loc 1 2598 0
 12442 4600 8085      		ldd r24,Z+8
 12443 4602 8093 0000 		sts tempIntString+1,r24
2599:switcherator.c ****     startMinute = atoi(tempIntString);
 12444               		.loc 1 2599 0
 12445 4606 80E0      		ldi r24,lo8(tempIntString)
 12446 4608 90E0      		ldi r25,hi8(tempIntString)
 12447 460a 0E94 0000 		call atoi
 12448               	.LVL1064:
 12449 460e 4C01      		movw r8,r24
 12450               	.LVL1065:
2600:switcherator.c ****     tempIntString[0] = commandReceived[9];
 12451               		.loc 1 2600 0
 12452 4610 F601      		movw r30,r12
 12453 4612 8185      		ldd r24,Z+9
 12454 4614 8093 0000 		sts tempIntString,r24
2601:switcherator.c ****     tempIntString[1] = commandReceived[10];
 12455               		.loc 1 2601 0
 12456 4618 8285      		ldd r24,Z+10
 12457 461a 8093 0000 		sts tempIntString+1,r24
2602:switcherator.c ****     stopHour = atoi(tempIntString);
 12458               		.loc 1 2602 0
 12459 461e 80E0      		ldi r24,lo8(tempIntString)
 12460 4620 90E0      		ldi r25,hi8(tempIntString)
 12461 4622 0E94 0000 		call atoi
 12462               	.LVL1066:
 12463 4626 1C01      		movw r2,r24
 12464               	.LVL1067:
2603:switcherator.c ****     tempIntString[0] = commandReceived[11];
 12465               		.loc 1 2603 0
 12466 4628 F601      		movw r30,r12
 12467 462a 8385      		ldd r24,Z+11
 12468 462c 8093 0000 		sts tempIntString,r24
2604:switcherator.c ****     tempIntString[1] = commandReceived[12];
 12469               		.loc 1 2604 0
 12470 4630 8485      		ldd r24,Z+12
 12471 4632 8093 0000 		sts tempIntString+1,r24
2605:switcherator.c ****     stopMinute = atoi(tempIntString);
 12472               		.loc 1 2605 0
 12473 4636 80E0      		ldi r24,lo8(tempIntString)
 12474 4638 90E0      		ldi r25,hi8(tempIntString)
 12475 463a 0E94 0000 		call atoi
 12476               	.LVL1068:
2606:switcherator.c ****     if (startHour > 23 || stopHour > 23) {
 12477               		.loc 1 2606 0
 12478 463e F8E1      		ldi r31,24
 12479 4640 EF16      		cp r14,r31
 12480 4642 F104      		cpc r15,__zero_reg__
 12481 4644 00F4      		brsh .L848
2606:switcherator.c ****     if (startHour > 23 || stopHour > 23) {
 12482               		.loc 1 2606 0 is_stmt 0 discriminator 1
 12483 4646 28E1      		ldi r18,24
 12484 4648 2216      		cp r2,r18
 12485 464a 3104      		cpc r3,__zero_reg__
 12486 464c 00F0      		brlo .L849
 12487               	.L848:
2607:switcherator.c ****         fail(0x09);
 12488               		.loc 1 2607 0 is_stmt 1
 12489 464e 89E0      		ldi r24,lo8(9)
 12490 4650 90E0      		ldi r25,0
 12491               	.LVL1069:
 12492 4652 00C0      		rjmp .L854
 12493               	.LVL1070:
 12494               	.L849:
2599:switcherator.c ****     startMinute = atoi(tempIntString);
 12495               		.loc 1 2599 0
 12496 4654 F401      		movw r30,r8
2610:switcherator.c ****     if (startMinute > 59 || stopMinute > 59) {
 12497               		.loc 1 2610 0
 12498 4656 EC33      		cpi r30,60
 12499 4658 F105      		cpc r31,__zero_reg__
 12500 465a 00F4      		brsh .L850
2605:switcherator.c ****     stopMinute = atoi(tempIntString);
 12501               		.loc 1 2605 0 discriminator 1
 12502 465c AC01      		movw r20,r24
2610:switcherator.c ****     if (startMinute > 59 || stopMinute > 59) {
 12503               		.loc 1 2610 0 discriminator 1
 12504 465e 8C33      		cpi r24,60
 12505 4660 9105      		cpc r25,__zero_reg__
 12506 4662 00F0      		brlo .L851
 12507               	.L850:
2611:switcherator.c ****         fail(0x0A);
 12508               		.loc 1 2611 0
 12509 4664 8AE0      		ldi r24,lo8(10)
 12510 4666 90E0      		ldi r25,0
 12511               	.LVL1071:
 12512               	.L854:
 12513 4668 0E94 0000 		call fail
 12514               	.LVL1072:
 12515 466c 00C0      		rjmp .L842
 12516               	.LVL1073:
 12517               	.L851:
2615:switcherator.c ****     startTime = startTime * 60 * 60;
 12518               		.loc 1 2615 0
 12519 466e 9701      		movw r18,r14
 12520 4670 A0E1      		ldi r26,lo8(16)
 12521 4672 BEE0      		ldi r27,lo8(14)
 12522 4674 0E94 0000 		call __umulhisi3
 12523 4678 6B01      		movw r12,r22
 12524 467a 7C01      		movw r14,r24
 12525               	.LVL1074:
2618:switcherator.c ****     stopTime = stopTime * 60 * 60;
 12526               		.loc 1 2618 0
 12527 467c 9101      		movw r18,r2
 12528 467e 0E94 0000 		call __umulhisi3
 12529               	.LVL1075:
2620:switcherator.c ****     timeLimits[programNumber][0] = startTime;
 12530               		.loc 1 2620 0
 12531 4682 2CE0      		ldi r18,lo8(12)
 12532 4684 209F      		mul r18,r16
 12533 4686 D001      		movw r26,r0
 12534 4688 219F      		mul r18,r17
 12535 468a B00D      		add r27,r0
 12536 468c 1124      		clr __zero_reg__
 12537 468e A050      		subi r26,lo8(-(timeLimits))
 12538 4690 B040      		sbci r27,hi8(-(timeLimits))
2616:switcherator.c ****     startTime += (startMinute * 60);
 12539               		.loc 1 2616 0
 12540 4692 2CE3      		ldi r18,lo8(60)
 12541 4694 289D      		mul r18,r8
 12542 4696 8001      		movw r16,r0
 12543 4698 299D      		mul r18,r9
 12544 469a 100D      		add r17,r0
 12545 469c 1124      		clr __zero_reg__
 12546               	.LVL1076:
 12547 469e C00E      		add r12,r16
 12548 46a0 D11E      		adc r13,r17
 12549 46a2 E11C      		adc r14,__zero_reg__
 12550 46a4 F11C      		adc r15,__zero_reg__
 12551               	.LVL1077:
2620:switcherator.c ****     timeLimits[programNumber][0] = startTime;
 12552               		.loc 1 2620 0
 12553 46a6 CD92      		st X+,r12
 12554 46a8 DD92      		st X+,r13
 12555 46aa ED92      		st X+,r14
 12556 46ac FC92      		st X,r15
 12557 46ae 1397      		sbiw r26,3
2619:switcherator.c ****     stopTime += (stopMinute * 60);
 12558               		.loc 1 2619 0
 12559 46b0 249F      		mul r18,r20
 12560 46b2 F001      		movw r30,r0
 12561 46b4 259F      		mul r18,r21
 12562 46b6 F00D      		add r31,r0
 12563 46b8 1124      		clr __zero_reg__
 12564 46ba 6E0F      		add r22,r30
 12565 46bc 7F1F      		adc r23,r31
 12566 46be 811D      		adc r24,__zero_reg__
 12567 46c0 911D      		adc r25,__zero_reg__
 12568               	.LVL1078:
2621:switcherator.c ****     timeLimits[programNumber][1] = stopTime;
 12569               		.loc 1 2621 0
 12570 46c2 1496      		adiw r26,4
 12571 46c4 6D93      		st X+,r22
 12572 46c6 7D93      		st X+,r23
 12573 46c8 8D93      		st X+,r24
 12574 46ca 9C93      		st X,r25
 12575 46cc 1797      		sbiw r26,4+3
2622:switcherator.c ****     timeLimits[programNumber][2] = weekLong;
 12576               		.loc 1 2622 0
 12577 46ce 1896      		adiw r26,8
 12578 46d0 4D92      		st X+,r4
 12579 46d2 5D92      		st X+,r5
 12580 46d4 6D92      		st X+,r6
 12581 46d6 7C92      		st X,r7
 12582 46d8 1B97      		sbiw r26,8+3
 12583               	.LVL1079:
 12584               	.L855:
2623:switcherator.c ****     ok();
 12585               		.loc 1 2623 0
 12586 46da 0E94 0000 		call ok
 12587               	.LVL1080:
 12588               	.L842:
 12589               	/* epilogue start */
2625:switcherator.c **** }
 12590               		.loc 1 2625 0
 12591 46de 2C96      		adiw r28,12
 12592 46e0 0FB6      		in __tmp_reg__,__SREG__
 12593 46e2 F894      		cli
 12594 46e4 DEBF      		out __SP_H__,r29
 12595 46e6 0FBE      		out __SREG__,__tmp_reg__
 12596 46e8 CDBF      		out __SP_L__,r28
 12597 46ea DF91      		pop r29
 12598 46ec CF91      		pop r28
 12599 46ee 1F91      		pop r17
 12600 46f0 0F91      		pop r16
 12601 46f2 FF90      		pop r15
 12602 46f4 EF90      		pop r14
 12603 46f6 DF90      		pop r13
 12604 46f8 CF90      		pop r12
 12605 46fa BF90      		pop r11
 12606 46fc AF90      		pop r10
 12607 46fe 9F90      		pop r9
 12608 4700 8F90      		pop r8
 12609 4702 7F90      		pop r7
 12610 4704 6F90      		pop r6
 12611 4706 5F90      		pop r5
 12612 4708 4F90      		pop r4
 12613 470a 3F90      		pop r3
 12614 470c 2F90      		pop r2
 12615 470e 0895      		ret
 12616               	.LFE59:
 12618               		.section	.rodata.str1.1
 12619               	.LC74:
 12620 016d 4E65 7720 		.string	"New prog#"
 12620      7072 6F67 
 12620      2300 
 12621               		.text
 12622               	.global	newProgram
 12624               	newProgram:
 12625               	.LFB30:
1212:switcherator.c **** void newProgram(char * commandReceived) {
 12626               		.loc 1 1212 0
 12627               	.LVL1081:
 12628 4710 AF92      		push r10
 12629               	.LCFI340:
 12630 4712 BF92      		push r11
 12631               	.LCFI341:
 12632 4714 CF92      		push r12
 12633               	.LCFI342:
 12634 4716 DF92      		push r13
 12635               	.LCFI343:
 12636 4718 EF92      		push r14
 12637               	.LCFI344:
 12638 471a FF92      		push r15
 12639               	.LCFI345:
 12640 471c 0F93      		push r16
 12641               	.LCFI346:
 12642 471e 1F93      		push r17
 12643               	.LCFI347:
 12644 4720 CF93      		push r28
 12645               	.LCFI348:
 12646 4722 DF93      		push r29
 12647               	.LCFI349:
 12648               	/* prologue: function */
 12649               	/* frame size = 0 */
 12650               	/* stack size = 10 */
 12651               	.L__stack_usage = 10
 12652 4724 EC01      		movw r28,r24
 12653               	.LVL1082:
 12654 4726 E0E0      		ldi r30,lo8(weeklyProgram+1)
 12655 4728 F0E0      		ldi r31,hi8(weeklyProgram+1)
1220:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 12656               		.loc 1 1220 0
 12657 472a 00E0      		ldi r16,0
 12658 472c 10E0      		ldi r17,0
 12659               	.LVL1083:
 12660               	.L859:
1212:switcherator.c **** void newProgram(char * commandReceived) {
 12661               		.loc 1 1212 0
 12662 472e DF01      		movw r26,r30
 12663 4730 1197      		sbiw r26,1
1222:switcherator.c ****         if (weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) {
 12664               		.loc 1 1222 0
 12665 4732 8C91      		ld r24,X
 12666 4734 8F3F      		cpi r24,lo8(-1)
 12667 4736 01F4      		brne .L857
1222:switcherator.c ****         if (weeklyProgram[x][0] == 255 && weeklyProgram[x][1] == 255) {
 12668               		.loc 1 1222 0 is_stmt 0 discriminator 1
 12669 4738 8081      		ld r24,Z
 12670 473a 8F3F      		cpi r24,lo8(-1)
 12671 473c 01F4      		brne .+2
 12672 473e 00C0      		rjmp .L858
 12673               	.L857:
1220:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 12674               		.loc 1 1220 0 is_stmt 1
 12675 4740 0F5F      		subi r16,-1
 12676 4742 1F4F      		sbci r17,-1
 12677               	.LVL1084:
 12678 4744 3A96      		adiw r30,10
 12679 4746 0A30      		cpi r16,10
 12680 4748 1105      		cpc r17,__zero_reg__
 12681 474a 01F4      		brne .L859
 12682 474c 00C0      		rjmp .L874
 12683               	.LVL1085:
 12684               	.L875:
1245:switcherator.c ****     if (hours >= 24 || (hours == 0 && commandReceived[4] != '0')) {
 12685               		.loc 1 1245 0 discriminator 1
 12686 474e E114      		cp r14,__zero_reg__
 12687 4750 F104      		cpc r15,__zero_reg__
 12688 4752 01F4      		brne .L861
 12689 4754 20E3      		ldi r18,lo8(48)
 12690 4756 A216      		cp r10,r18
 12691 4758 01F0      		breq .L861
 12692               	.L865:
1246:switcherator.c ****         fail(9);
 12693               		.loc 1 1246 0
 12694 475a 89E0      		ldi r24,lo8(9)
 12695 475c 90E0      		ldi r25,0
 12696               	.LVL1086:
 12697 475e 00C0      		rjmp .L876
 12698               	.LVL1087:
 12699               	.L861:
1249:switcherator.c ****     if (minutes >= 60 || (minutes == 0 && commandReceived[6] != '0')) {
 12700               		.loc 1 1249 0
 12701 4760 2CE3      		ldi r18,60
 12702 4762 C216      		cp r12,r18
 12703 4764 D104      		cpc r13,__zero_reg__
 12704 4766 04F4      		brge .L862
1249:switcherator.c ****     if (minutes >= 60 || (minutes == 0 && commandReceived[6] != '0')) {
 12705               		.loc 1 1249 0 is_stmt 0 discriminator 1
 12706 4768 C114      		cp r12,__zero_reg__
 12707 476a D104      		cpc r13,__zero_reg__
 12708 476c 01F4      		brne .L863
 12709 476e 20E3      		ldi r18,lo8(48)
 12710 4770 B216      		cp r11,r18
 12711 4772 01F0      		breq .L863
 12712               	.L862:
1250:switcherator.c ****         fail(0x0a);
 12713               		.loc 1 1250 0 is_stmt 1
 12714 4774 8AE0      		ldi r24,lo8(10)
 12715 4776 90E0      		ldi r25,0
 12716               	.LVL1088:
 12717 4778 00C0      		rjmp .L876
 12718               	.LVL1089:
 12719               	.L863:
1253:switcherator.c ****     if (duration == 0) {
 12720               		.loc 1 1253 0
 12721 477a 0097      		sbiw r24,0
 12722 477c 01F4      		brne .L864
1254:switcherator.c ****         fail(0x0b);
 12723               		.loc 1 1254 0
 12724 477e 8BE0      		ldi r24,lo8(11)
 12725 4780 90E0      		ldi r25,0
 12726               	.LVL1090:
 12727 4782 00C0      		rjmp .L876
 12728               	.LVL1091:
 12729               	.L864:
1257:switcherator.c ****     duration *= 60; // convert to seconds
 12730               		.loc 1 1257 0
 12731 4784 6CE3      		ldi r22,lo8(60)
 12732 4786 689F      		mul r22,r24
 12733 4788 A001      		movw r20,r0
 12734 478a 699F      		mul r22,r25
 12735 478c 500D      		add r21,r0
 12736 478e 1124      		clr __zero_reg__
 12737               	.LVL1092:
1258:switcherator.c ****     startTime = (hours * 60);
 12738               		.loc 1 1258 0
 12739 4790 6E9D      		mul r22,r14
 12740 4792 9001      		movw r18,r0
 12741 4794 6F9D      		mul r22,r15
 12742 4796 300D      		add r19,r0
 12743 4798 1124      		clr __zero_reg__
 12744               	.LVL1093:
1259:switcherator.c ****     startTime += minutes; // stored in minutes
 12745               		.loc 1 1259 0
 12746 479a 2C0D      		add r18,r12
 12747 479c 3D1D      		adc r19,r13
 12748               	.LVL1094:
1262:switcherator.c ****     weeklyProgram[programNumber][1] = temp;
 12749               		.loc 1 1262 0
 12750 479e 8AE0      		ldi r24,lo8(10)
 12751 47a0 809F      		mul r24,r16
 12752 47a2 F001      		movw r30,r0
 12753 47a4 819F      		mul r24,r17
 12754 47a6 F00D      		add r31,r0
 12755 47a8 1124      		clr __zero_reg__
 12756 47aa E050      		subi r30,lo8(-(weeklyProgram))
 12757 47ac F040      		sbci r31,hi8(-(weeklyProgram))
 12758 47ae 3183      		std Z+1,r19
 12759               	.LVL1095:
1264:switcherator.c ****     weeklyProgram[programNumber][2] = temp;
 12760               		.loc 1 1264 0
 12761 47b0 2283      		std Z+2,r18
 12762               	.LVL1096:
1266:switcherator.c ****     weeklyProgram[programNumber][3] = temp;
 12763               		.loc 1 1266 0
 12764 47b2 5383      		std Z+3,r21
 12765               	.LVL1097:
1267:switcherator.c ****     temp = (duration & 0xff);
 12766               		.loc 1 1267 0
 12767 47b4 5527      		clr r21
 12768               	.LVL1098:
1268:switcherator.c ****     weeklyProgram[programNumber][4] = temp;
 12769               		.loc 1 1268 0
 12770 47b6 4483      		std Z+4,r20
1269:switcherator.c ****     statusMsg[0] = 0;
 12771               		.loc 1 1269 0
 12772 47b8 1092 0000 		sts statusMsg,__zero_reg__
1270:switcherator.c ****     strcat(statusMsg, "New prog#");
 12773               		.loc 1 1270 0
 12774 47bc 60E0      		ldi r22,lo8(.LC74)
 12775 47be 70E0      		ldi r23,hi8(.LC74)
 12776 47c0 80E0      		ldi r24,lo8(statusMsg)
 12777 47c2 90E0      		ldi r25,hi8(statusMsg)
 12778 47c4 0E94 0000 		call strcat
 12779               	.LVL1099:
1271:switcherator.c ****     returnInt(programNumber, tempIntString);
 12780               		.loc 1 1271 0
 12781 47c8 60E0      		ldi r22,lo8(tempIntString)
 12782 47ca 70E0      		ldi r23,hi8(tempIntString)
 12783 47cc C801      		movw r24,r16
 12784 47ce 0E94 0000 		call returnInt
 12785               	.LVL1100:
1272:switcherator.c ****     strcat(statusMsg, tempIntString);
 12786               		.loc 1 1272 0
 12787 47d2 60E0      		ldi r22,lo8(tempIntString)
 12788 47d4 70E0      		ldi r23,hi8(tempIntString)
 12789 47d6 80E0      		ldi r24,lo8(statusMsg)
 12790 47d8 90E0      		ldi r25,hi8(statusMsg)
 12791 47da 0E94 0000 		call strcat
 12792               	.LVL1101:
1273:switcherator.c ****     sendMessage(statusMsg);
 12793               		.loc 1 1273 0
 12794 47de 80E0      		ldi r24,lo8(statusMsg)
 12795 47e0 90E0      		ldi r25,hi8(statusMsg)
 12796               	/* epilogue start */
1274:switcherator.c **** }
 12797               		.loc 1 1274 0
 12798 47e2 DF91      		pop r29
 12799 47e4 CF91      		pop r28
 12800               	.LVL1102:
 12801 47e6 1F91      		pop r17
 12802 47e8 0F91      		pop r16
 12803               	.LVL1103:
 12804 47ea FF90      		pop r15
 12805 47ec EF90      		pop r14
 12806               	.LVL1104:
 12807 47ee DF90      		pop r13
 12808 47f0 CF90      		pop r12
 12809               	.LVL1105:
 12810 47f2 BF90      		pop r11
 12811 47f4 AF90      		pop r10
1273:switcherator.c ****     sendMessage(statusMsg);
 12812               		.loc 1 1273 0
 12813 47f6 0C94 0000 		jmp sendMessage
 12814               	.LVL1106:
 12815               	.L874:
1230:switcherator.c ****         fail(8);
 12816               		.loc 1 1230 0
 12817 47fa 88E0      		ldi r24,lo8(8)
 12818 47fc 90E0      		ldi r25,0
 12819               	.LVL1107:
 12820               	.L876:
 12821               	/* epilogue start */
1274:switcherator.c **** }
 12822               		.loc 1 1274 0
 12823 47fe DF91      		pop r29
 12824 4800 CF91      		pop r28
 12825               	.LVL1108:
 12826 4802 1F91      		pop r17
 12827 4804 0F91      		pop r16
 12828 4806 FF90      		pop r15
 12829 4808 EF90      		pop r14
 12830 480a DF90      		pop r13
 12831 480c CF90      		pop r12
 12832 480e BF90      		pop r11
 12833 4810 AF90      		pop r10
1230:switcherator.c ****         fail(8);
 12834               		.loc 1 1230 0
 12835 4812 0C94 0000 		jmp fail
 12836               	.LVL1109:
 12837               	.L858:
1233:switcherator.c ****     clearTheProgram(programNumber);
 12838               		.loc 1 1233 0
 12839 4816 C801      		movw r24,r16
 12840 4818 0E94 0000 		call clearTheProgram
 12841               	.LVL1110:
1234:switcherator.c ****     tempIntString[0] = commandReceived[3];
 12842               		.loc 1 1234 0
 12843 481c 8B81      		ldd r24,Y+3
 12844 481e 8093 0000 		sts tempIntString,r24
1235:switcherator.c ****     tempIntString[1] = commandReceived[4];
 12845               		.loc 1 1235 0
 12846 4822 AC80      		ldd r10,Y+4
 12847 4824 A092 0000 		sts tempIntString+1,r10
1236:switcherator.c ****     hours = atoi(tempIntString);
 12848               		.loc 1 1236 0
 12849 4828 80E0      		ldi r24,lo8(tempIntString)
 12850 482a 90E0      		ldi r25,hi8(tempIntString)
 12851 482c 0E94 0000 		call atoi
 12852               	.LVL1111:
 12853 4830 7C01      		movw r14,r24
 12854               	.LVL1112:
1237:switcherator.c ****     tempIntString[0] = commandReceived[5];
 12855               		.loc 1 1237 0
 12856 4832 8D81      		ldd r24,Y+5
 12857 4834 8093 0000 		sts tempIntString,r24
1238:switcherator.c ****     tempIntString[1] = commandReceived[6];
 12858               		.loc 1 1238 0
 12859 4838 BE80      		ldd r11,Y+6
 12860 483a B092 0000 		sts tempIntString+1,r11
1239:switcherator.c ****     minutes = atoi(tempIntString);
 12861               		.loc 1 1239 0
 12862 483e 80E0      		ldi r24,lo8(tempIntString)
 12863 4840 90E0      		ldi r25,hi8(tempIntString)
 12864 4842 0E94 0000 		call atoi
 12865               	.LVL1113:
 12866 4846 6C01      		movw r12,r24
 12867               	.LVL1114:
1240:switcherator.c ****     tempLongString[0] = commandReceived[7];
 12868               		.loc 1 1240 0
 12869 4848 8F81      		ldd r24,Y+7
 12870 484a 8093 0000 		sts tempLongString,r24
1241:switcherator.c ****     tempLongString[1] = commandReceived[8];
 12871               		.loc 1 1241 0
 12872 484e 8885      		ldd r24,Y+8
 12873 4850 8093 0000 		sts tempLongString+1,r24
1242:switcherator.c ****     tempLongString[2] = commandReceived[9];
 12874               		.loc 1 1242 0
 12875 4854 8985      		ldd r24,Y+9
 12876 4856 8093 0000 		sts tempLongString+2,r24
1243:switcherator.c ****     tempLongString[3] = commandReceived[10];
 12877               		.loc 1 1243 0
 12878 485a 8A85      		ldd r24,Y+10
 12879 485c 8093 0000 		sts tempLongString+3,r24
1244:switcherator.c ****     duration = atoi(tempLongString);
 12880               		.loc 1 1244 0
 12881 4860 80E0      		ldi r24,lo8(tempLongString)
 12882 4862 90E0      		ldi r25,hi8(tempLongString)
 12883 4864 0E94 0000 		call atoi
 12884               	.LVL1115:
1245:switcherator.c ****     if (hours >= 24 || (hours == 0 && commandReceived[4] != '0')) {
 12885               		.loc 1 1245 0
 12886 4868 28E1      		ldi r18,24
 12887 486a E216      		cp r14,r18
 12888 486c F104      		cpc r15,__zero_reg__
 12889 486e 04F4      		brge .+2
 12890 4870 00C0      		rjmp .L875
 12891 4872 00C0      		rjmp .L865
 12892               	.LFE30:
 12894               	.global	switchBrightness
 12896               	switchBrightness:
 12897               	.LFB19:
 827:switcherator.c **** void switchBrightness(char * commandReceived) {
 12898               		.loc 1 827 0
 12899               	.LVL1116:
 12900 4874 FF92      		push r15
 12901               	.LCFI350:
 12902 4876 0F93      		push r16
 12903               	.LCFI351:
 12904 4878 1F93      		push r17
 12905               	.LCFI352:
 12906 487a CF93      		push r28
 12907               	.LCFI353:
 12908 487c DF93      		push r29
 12909               	.LCFI354:
 12910               	/* prologue: function */
 12911               	/* frame size = 0 */
 12912               	/* stack size = 5 */
 12913               	.L__stack_usage = 5
 12914 487e 8C01      		movw r16,r24
 828:switcherator.c ****     int switchNumber = getSwitchNumber(commandReceived);
 12915               		.loc 1 828 0
 12916 4880 0E94 0000 		call getSwitchNumber
 12917               	.LVL1117:
 12918 4884 EC01      		movw r28,r24
 12919               	.LVL1118:
 830:switcherator.c ****     if (switchNumber >= NUM_SWITCHES) {
 12920               		.loc 1 830 0
 12921 4886 8031      		cpi r24,16
 12922 4888 9105      		cpc r25,__zero_reg__
 12923 488a 04F0      		brlt .L878
 831:switcherator.c ****         fail(1);
 12924               		.loc 1 831 0
 12925 488c 81E0      		ldi r24,lo8(1)
 12926 488e 90E0      		ldi r25,0
 12927               	.LVL1119:
 12928               	/* epilogue start */
 853:switcherator.c **** }
 12929               		.loc 1 853 0
 12930 4890 DF91      		pop r29
 12931 4892 CF91      		pop r28
 12932               	.LVL1120:
 12933 4894 1F91      		pop r17
 12934 4896 0F91      		pop r16
 12935               	.LVL1121:
 12936 4898 FF90      		pop r15
 831:switcherator.c ****         fail(1);
 12937               		.loc 1 831 0
 12938 489a 0C94 0000 		jmp fail
 12939               	.LVL1122:
 12940               	.L878:
 834:switcherator.c ****     tempIntString[0] = commandReceived[5];
 12941               		.loc 1 834 0
 12942 489e F801      		movw r30,r16
 12943 48a0 8581      		ldd r24,Z+5
 12944               	.LVL1123:
 12945 48a2 8093 0000 		sts tempIntString,r24
 835:switcherator.c ****     tempIntString[1] = commandReceived[6];
 12946               		.loc 1 835 0
 12947 48a6 8681      		ldd r24,Z+6
 12948 48a8 8093 0000 		sts tempIntString+1,r24
 836:switcherator.c ****     char brightValue = atoi(tempIntString);
 12949               		.loc 1 836 0
 12950 48ac 80E0      		ldi r24,lo8(tempIntString)
 12951 48ae 90E0      		ldi r25,hi8(tempIntString)
 12952 48b0 0E94 0000 		call atoi
 12953               	.LVL1124:
 12954 48b4 F82E      		mov r15,r24
 12955               	.LVL1125:
 12956 48b6 8E01      		movw r16,r28
 12957               	.LVL1126:
 12958 48b8 0050      		subi r16,lo8(-(switchBright))
 12959 48ba 1040      		sbci r17,hi8(-(switchBright))
 837:switcherator.c ****     if (brightValue == 0) {
 12960               		.loc 1 837 0
 12961 48bc 8111      		cpse r24,__zero_reg__
 12962 48be 00C0      		rjmp .L879
 12963               	.LVL1127:
 839:switcherator.c ****         itoa(tempBright, tempIntString, 10);
 12964               		.loc 1 839 0
 12965 48c0 4AE0      		ldi r20,lo8(10)
 12966 48c2 50E0      		ldi r21,0
 12967 48c4 60E0      		ldi r22,lo8(tempIntString)
 12968 48c6 70E0      		ldi r23,hi8(tempIntString)
 12969 48c8 F801      		movw r30,r16
 12970 48ca 8081      		ld r24,Z
 12971 48cc 90E0      		ldi r25,0
 12972 48ce 0E94 0000 		call itoa
 12973               	.LVL1128:
 840:switcherator.c ****         statusMsg[0] = 0;
 12974               		.loc 1 840 0
 12975 48d2 1092 0000 		sts statusMsg,__zero_reg__
 841:switcherator.c ****         strcat(statusMsg, "Set @");
 12976               		.loc 1 841 0
 12977 48d6 60E0      		ldi r22,lo8(.LC68)
 12978 48d8 70E0      		ldi r23,hi8(.LC68)
 12979 48da 80E0      		ldi r24,lo8(statusMsg)
 12980 48dc 90E0      		ldi r25,hi8(statusMsg)
 12981 48de 0E94 0000 		call strcat
 12982               	.LVL1129:
 842:switcherator.c ****         strcat(statusMsg, tempIntString);
 12983               		.loc 1 842 0
 12984 48e2 60E0      		ldi r22,lo8(tempIntString)
 12985 48e4 70E0      		ldi r23,hi8(tempIntString)
 12986 48e6 80E0      		ldi r24,lo8(statusMsg)
 12987 48e8 90E0      		ldi r25,hi8(statusMsg)
 12988 48ea 0E94 0000 		call strcat
 12989               	.LVL1130:
 843:switcherator.c ****         sendMessage(statusMsg);
 12990               		.loc 1 843 0
 12991 48ee 80E0      		ldi r24,lo8(statusMsg)
 12992 48f0 90E0      		ldi r25,hi8(statusMsg)
 12993               	/* epilogue start */
 853:switcherator.c **** }
 12994               		.loc 1 853 0
 12995 48f2 DF91      		pop r29
 12996 48f4 CF91      		pop r28
 12997               	.LVL1131:
 12998 48f6 1F91      		pop r17
 12999 48f8 0F91      		pop r16
 13000               	.LVL1132:
 13001 48fa FF90      		pop r15
 13002               	.LVL1133:
 843:switcherator.c ****         sendMessage(statusMsg);
 13003               		.loc 1 843 0
 13004 48fc 0C94 0000 		jmp sendMessage
 13005               	.LVL1134:
 13006               	.L879:
 847:switcherator.c ****         clearTheSwitch(switchNumber);
 13007               		.loc 1 847 0
 13008 4900 CE01      		movw r24,r28
 13009 4902 0E94 0000 		call clearTheSwitch
 13010               	.LVL1135:
 849:switcherator.c ****         switchStuff[switchNumber] = 212;
 13011               		.loc 1 849 0
 13012 4906 C050      		subi r28,lo8(-(switchStuff))
 13013 4908 D040      		sbci r29,hi8(-(switchStuff))
 13014               	.LVL1136:
 13015 490a 84ED      		ldi r24,lo8(-44)
 13016 490c 8883      		st Y,r24
 850:switcherator.c ****         switchBright[switchNumber] = brightValue;
 13017               		.loc 1 850 0
 13018 490e 8F2D      		mov r24,r15
 13019 4910 8131      		cpi r24,lo8(17)
 13020 4912 00F0      		brlo .L880
 13021 4914 80E1      		ldi r24,lo8(16)
 13022               	.L880:
 13023 4916 F801      		movw r30,r16
 13024 4918 8083      		st Z,r24
 13025               	/* epilogue start */
 853:switcherator.c **** }
 13026               		.loc 1 853 0
 13027 491a DF91      		pop r29
 13028 491c CF91      		pop r28
 13029 491e 1F91      		pop r17
 13030 4920 0F91      		pop r16
 13031               	.LVL1137:
 13032 4922 FF90      		pop r15
 13033               	.LVL1138:
 851:switcherator.c ****         ok();
 13034               		.loc 1 851 0
 13035 4924 0C94 0000 		jmp ok
 13036               	.LVL1139:
 13037               	.LFE19:
 13039               	.global	radioTest
 13041               	radioTest:
 13042               	.LFB71:
2917:switcherator.c **** int radioTest(void) {
 13043               		.loc 1 2917 0
 13044 4928 AF92      		push r10
 13045               	.LCFI355:
 13046 492a BF92      		push r11
 13047               	.LCFI356:
 13048 492c CF92      		push r12
 13049               	.LCFI357:
 13050 492e DF92      		push r13
 13051               	.LCFI358:
 13052 4930 EF92      		push r14
 13053               	.LCFI359:
 13054 4932 FF92      		push r15
 13055               	.LCFI360:
 13056 4934 0F93      		push r16
 13057               	.LCFI361:
 13058 4936 1F93      		push r17
 13059               	.LCFI362:
 13060               	/* prologue: function */
 13061               	/* frame size = 0 */
 13062               	/* stack size = 8 */
 13063               	.L__stack_usage = 8
2919:switcherator.c ****     test_addr = readAddr(RX_ADDR_P0);    
 13064               		.loc 1 2919 0
 13065 4938 8AE0      		ldi r24,lo8(10)
 13066 493a 0E94 0000 		call readAddr
 13067               	.LVL1140:
2920:switcherator.c ****     if (test_addr != rx_addr_p0) {
 13068               		.loc 1 2920 0
 13069 493e A090 0000 		lds r10,rx_addr_p0
 13070 4942 B090 0000 		lds r11,rx_addr_p0+1
 13071 4946 C090 0000 		lds r12,rx_addr_p0+2
 13072 494a D090 0000 		lds r13,rx_addr_p0+3
 13073 494e E090 0000 		lds r14,rx_addr_p0+4
 13074 4952 F090 0000 		lds r15,rx_addr_p0+5
 13075 4956 0091 0000 		lds r16,rx_addr_p0+6
 13076 495a 1091 0000 		lds r17,rx_addr_p0+7
 13077 495e 0E94 0000 		call __cmpdi2
 13078 4962 01F0      		breq .L882
2922:switcherator.c ****         failCondition = 1;
 13079               		.loc 1 2922 0
 13080 4964 81E0      		ldi r24,lo8(1)
 13081               	.LVL1141:
 13082 4966 8093 0000 		sts failCondition,r24
2923:switcherator.c ****         return -1;
 13083               		.loc 1 2923 0
 13084 496a 2FEF      		ldi r18,lo8(-1)
 13085 496c 3FEF      		ldi r19,lo8(-1)
 13086 496e 00C0      		rjmp .L883
 13087               	.LVL1142:
 13088               	.L882:
2925:switcherator.c ****     if(failCondition == 1 || failCondition == 2)
 13089               		.loc 1 2925 0
 13090 4970 8091 0000 		lds r24,failCondition
 13091               	.LVL1143:
 13092 4974 8150      		subi r24,lo8(-(-1))
 13093 4976 8230      		cpi r24,lo8(2)
 13094 4978 00F4      		brsh .L884
2926:switcherator.c ****         clearFail();
 13095               		.loc 1 2926 0
 13096 497a 0E94 0000 		call clearFail
 13097               	.LVL1144:
 13098               	.L884:
2927:switcherator.c ****     return 1;
 13099               		.loc 1 2927 0
 13100 497e 21E0      		ldi r18,lo8(1)
 13101 4980 30E0      		ldi r19,0
 13102               	.L883:
2928:switcherator.c **** }
 13103               		.loc 1 2928 0
 13104 4982 C901      		movw r24,r18
 13105               	/* epilogue start */
 13106 4984 1F91      		pop r17
 13107 4986 0F91      		pop r16
 13108 4988 FF90      		pop r15
 13109 498a EF90      		pop r14
 13110 498c DF90      		pop r13
 13111 498e CF90      		pop r12
 13112 4990 BF90      		pop r11
 13113 4992 AF90      		pop r10
 13114 4994 0895      		ret
 13115               	.LFE71:
 13117               	.global	radioInit
 13119               	radioInit:
 13120               	.LFB70:
2889:switcherator.c **** void radioInit(void) {
 13121               		.loc 1 2889 0
 13122 4996 0F93      		push r16
 13123               	.LCFI363:
 13124 4998 1F93      		push r17
 13125               	.LCFI364:
 13126               	/* prologue: function */
 13127               	/* frame size = 0 */
 13128               	/* stack size = 2 */
 13129               	.L__stack_usage = 2
2890:switcherator.c ****     nrfInit();
 13130               		.loc 1 2890 0
 13131 499a 0E94 0000 		call nrfInit
 13132               	.LVL1145:
2891:switcherator.c ****     rx_addr_p0 = SET_RX_ADDR_P0;
 13133               		.loc 1 2891 0
 13134 499e 92E0      		ldi r25,lo8(2)
 13135 49a0 9093 0000 		sts rx_addr_p0,r25
 13136 49a4 80EF      		ldi r24,lo8(-16)
 13137 49a6 8093 0000 		sts rx_addr_p0+1,r24
 13138 49aa 8093 0000 		sts rx_addr_p0+2,r24
 13139 49ae 8093 0000 		sts rx_addr_p0+3,r24
 13140 49b2 8093 0000 		sts rx_addr_p0+4,r24
 13141 49b6 1092 0000 		sts rx_addr_p0+5,__zero_reg__
 13142 49ba 1092 0000 		sts rx_addr_p0+6,__zero_reg__
 13143 49be 1092 0000 		sts rx_addr_p0+7,__zero_reg__
2892:switcherator.c ****     tx_addr = SET_TX_ADDR;
 13144               		.loc 1 2892 0
 13145 49c2 9093 0000 		sts tx_addr,r25
 13146 49c6 8093 0000 		sts tx_addr+1,r24
 13147 49ca 8093 0000 		sts tx_addr+2,r24
 13148 49ce 8093 0000 		sts tx_addr+3,r24
 13149 49d2 8093 0000 		sts tx_addr+4,r24
 13150 49d6 1092 0000 		sts tx_addr+5,__zero_reg__
 13151 49da 1092 0000 		sts tx_addr+6,__zero_reg__
 13152 49de 1092 0000 		sts tx_addr+7,__zero_reg__
2894:switcherator.c ****     rx_addr_p1 = readAddr(RX_ADDR_P1);
 13153               		.loc 1 2894 0
 13154 49e2 8BE0      		ldi r24,lo8(11)
 13155 49e4 0E94 0000 		call readAddr
 13156               	.LVL1146:
 13157 49e8 2093 0000 		sts rx_addr_p1,r18
 13158 49ec 3093 0000 		sts rx_addr_p1+1,r19
 13159 49f0 4093 0000 		sts rx_addr_p1+2,r20
 13160 49f4 5093 0000 		sts rx_addr_p1+3,r21
 13161 49f8 6093 0000 		sts rx_addr_p1+4,r22
 13162 49fc 7093 0000 		sts rx_addr_p1+5,r23
 13163 4a00 8093 0000 		sts rx_addr_p1+6,r24
 13164 4a04 9093 0000 		sts rx_addr_p1+7,r25
2895:switcherator.c ****     rx_addr_p2 = readAddr(RX_ADDR_P2);
 13165               		.loc 1 2895 0
 13166 4a08 8CE0      		ldi r24,lo8(12)
 13167 4a0a 0E94 0000 		call readAddr
 13168               	.LVL1147:
 13169 4a0e 2093 0000 		sts rx_addr_p2,r18
 13170 4a12 3093 0000 		sts rx_addr_p2+1,r19
 13171 4a16 4093 0000 		sts rx_addr_p2+2,r20
 13172 4a1a 5093 0000 		sts rx_addr_p2+3,r21
 13173 4a1e 6093 0000 		sts rx_addr_p2+4,r22
 13174 4a22 7093 0000 		sts rx_addr_p2+5,r23
 13175 4a26 8093 0000 		sts rx_addr_p2+6,r24
 13176 4a2a 9093 0000 		sts rx_addr_p2+7,r25
2896:switcherator.c ****     rx_addr_p3 = readAddr(RX_ADDR_P3);
 13177               		.loc 1 2896 0
 13178 4a2e 8DE0      		ldi r24,lo8(13)
 13179 4a30 0E94 0000 		call readAddr
 13180               	.LVL1148:
 13181 4a34 2093 0000 		sts rx_addr_p3,r18
 13182 4a38 3093 0000 		sts rx_addr_p3+1,r19
 13183 4a3c 4093 0000 		sts rx_addr_p3+2,r20
 13184 4a40 5093 0000 		sts rx_addr_p3+3,r21
 13185 4a44 6093 0000 		sts rx_addr_p3+4,r22
 13186 4a48 7093 0000 		sts rx_addr_p3+5,r23
 13187 4a4c 8093 0000 		sts rx_addr_p3+6,r24
 13188 4a50 9093 0000 		sts rx_addr_p3+7,r25
2897:switcherator.c ****     rx_addr_p4 = readAddr(RX_ADDR_P4);
 13189               		.loc 1 2897 0
 13190 4a54 8EE0      		ldi r24,lo8(14)
 13191 4a56 0E94 0000 		call readAddr
 13192               	.LVL1149:
 13193 4a5a 2093 0000 		sts rx_addr_p4,r18
 13194 4a5e 3093 0000 		sts rx_addr_p4+1,r19
 13195 4a62 4093 0000 		sts rx_addr_p4+2,r20
 13196 4a66 5093 0000 		sts rx_addr_p4+3,r21
 13197 4a6a 6093 0000 		sts rx_addr_p4+4,r22
 13198 4a6e 7093 0000 		sts rx_addr_p4+5,r23
 13199 4a72 8093 0000 		sts rx_addr_p4+6,r24
 13200 4a76 9093 0000 		sts rx_addr_p4+7,r25
2898:switcherator.c ****     rx_addr_p5 = readAddr(RX_ADDR_P5);
 13201               		.loc 1 2898 0
 13202 4a7a 8FE0      		ldi r24,lo8(15)
 13203 4a7c 0E94 0000 		call readAddr
 13204               	.LVL1150:
 13205 4a80 2093 0000 		sts rx_addr_p5,r18
 13206 4a84 3093 0000 		sts rx_addr_p5+1,r19
 13207 4a88 4093 0000 		sts rx_addr_p5+2,r20
 13208 4a8c 5093 0000 		sts rx_addr_p5+3,r21
 13209 4a90 6093 0000 		sts rx_addr_p5+4,r22
 13210 4a94 7093 0000 		sts rx_addr_p5+5,r23
 13211 4a98 8093 0000 		sts rx_addr_p5+6,r24
 13212 4a9c 9093 0000 		sts rx_addr_p5+7,r25
2900:switcherator.c ****     writeReg(RF_SETUP, SET_RF_SETUP);
 13213               		.loc 1 2900 0
 13214 4aa0 66E0      		ldi r22,lo8(6)
 13215 4aa2 86E0      		ldi r24,lo8(6)
 13216 4aa4 0E94 0000 		call writeReg
 13217               	.LVL1151:
2901:switcherator.c ****     writeAddr(RX_ADDR_P0, rx_addr_p0);
 13218               		.loc 1 2901 0
 13219 4aa8 0091 0000 		lds r16,rx_addr_p0
 13220 4aac 1091 0000 		lds r17,rx_addr_p0+1
 13221 4ab0 2091 0000 		lds r18,rx_addr_p0+2
 13222 4ab4 3091 0000 		lds r19,rx_addr_p0+3
 13223 4ab8 4091 0000 		lds r20,rx_addr_p0+4
 13224 4abc 5091 0000 		lds r21,rx_addr_p0+5
 13225 4ac0 6091 0000 		lds r22,rx_addr_p0+6
 13226 4ac4 7091 0000 		lds r23,rx_addr_p0+7
 13227 4ac8 8AE0      		ldi r24,lo8(10)
 13228 4aca 0E94 0000 		call writeAddr
 13229               	.LVL1152:
2902:switcherator.c ****     writeAddr(TX_ADDR, tx_addr);
 13230               		.loc 1 2902 0
 13231 4ace 0091 0000 		lds r16,tx_addr
 13232 4ad2 1091 0000 		lds r17,tx_addr+1
 13233 4ad6 2091 0000 		lds r18,tx_addr+2
 13234 4ada 3091 0000 		lds r19,tx_addr+3
 13235 4ade 4091 0000 		lds r20,tx_addr+4
 13236 4ae2 5091 0000 		lds r21,tx_addr+5
 13237 4ae6 6091 0000 		lds r22,tx_addr+6
 13238 4aea 7091 0000 		lds r23,tx_addr+7
 13239 4aee 80E1      		ldi r24,lo8(16)
 13240 4af0 0E94 0000 		call writeAddr
 13241               	.LVL1153:
2903:switcherator.c ****     writeReg(DYNPD, SET_DYNPD);
 13242               		.loc 1 2903 0
 13243 4af4 6FE3      		ldi r22,lo8(63)
 13244 4af6 8CE1      		ldi r24,lo8(28)
 13245 4af8 0E94 0000 		call writeReg
 13246               	.LVL1154:
2904:switcherator.c ****     writeReg(FEATURE, SET_FEATURE);
 13247               		.loc 1 2904 0
 13248 4afc 64E0      		ldi r22,lo8(4)
 13249 4afe 8DE1      		ldi r24,lo8(29)
 13250 4b00 0E94 0000 		call writeReg
 13251               	.LVL1155:
2905:switcherator.c ****     writeReg(RF_CH, SET_RF_CH);
 13252               		.loc 1 2905 0
 13253 4b04 6AE2      		ldi r22,lo8(42)
 13254 4b06 85E0      		ldi r24,lo8(5)
 13255 4b08 0E94 0000 		call writeReg
 13256               	.LVL1156:
2906:switcherator.c ****     writeReg(CONFIG, SET_CONFIG);
 13257               		.loc 1 2906 0
 13258 4b0c 68E0      		ldi r22,lo8(8)
 13259 4b0e 80E0      		ldi r24,0
 13260 4b10 0E94 0000 		call writeReg
 13261               	.LVL1157:
2907:switcherator.c ****     writeReg(SETUP_RETR, SET_SETUP_RETR);
 13262               		.loc 1 2907 0
 13263 4b14 6FE0      		ldi r22,lo8(15)
 13264 4b16 84E0      		ldi r24,lo8(4)
 13265 4b18 0E94 0000 		call writeReg
 13266               	.LVL1158:
2910:switcherator.c ****     radioTest();
 13267               		.loc 1 2910 0
 13268 4b1c 0E94 0000 		call radioTest
 13269               	.LVL1159:
 13270               	/* epilogue start */
2914:switcherator.c **** }
 13271               		.loc 1 2914 0
 13272 4b20 1F91      		pop r17
 13273 4b22 0F91      		pop r16
2912:switcherator.c ****     startRadio();
 13274               		.loc 1 2912 0
 13275 4b24 0C94 0000 		jmp startRadio
 13276               	.LVL1160:
 13277               	.LFE70:
 13279               	.global	setClock
 13281               	setClock:
 13282               	.LFB48:
2136:switcherator.c **** void setClock(char * commandReceived) {
 13283               		.loc 1 2136 0
 13284               	.LVL1161:
 13285 4b28 6F92      		push r6
 13286               	.LCFI365:
 13287 4b2a 7F92      		push r7
 13288               	.LCFI366:
 13289 4b2c 8F92      		push r8
 13290               	.LCFI367:
 13291 4b2e 9F92      		push r9
 13292               	.LCFI368:
 13293 4b30 AF92      		push r10
 13294               	.LCFI369:
 13295 4b32 BF92      		push r11
 13296               	.LCFI370:
 13297 4b34 CF92      		push r12
 13298               	.LCFI371:
 13299 4b36 DF92      		push r13
 13300               	.LCFI372:
 13301 4b38 EF92      		push r14
 13302               	.LCFI373:
 13303 4b3a FF92      		push r15
 13304               	.LCFI374:
 13305 4b3c 0F93      		push r16
 13306               	.LCFI375:
 13307 4b3e 1F93      		push r17
 13308               	.LCFI376:
 13309 4b40 CF93      		push r28
 13310               	.LCFI377:
 13311 4b42 DF93      		push r29
 13312               	.LCFI378:
 13313               	/* prologue: function */
 13314               	/* frame size = 0 */
 13315               	/* stack size = 14 */
 13316               	.L__stack_usage = 14
 13317 4b44 EC01      		movw r28,r24
2139:switcherator.c ****     tempLongString[0] = '0';
 13318               		.loc 1 2139 0
 13319 4b46 80E3      		ldi r24,lo8(48)
 13320               	.LVL1162:
 13321 4b48 8093 0000 		sts tempLongString,r24
2140:switcherator.c ****     tempLongString[1] = '0';
 13322               		.loc 1 2140 0
 13323 4b4c 8093 0000 		sts tempLongString+1,r24
2143:switcherator.c ****     tempLongString[2] = commandReceived[3];
 13324               		.loc 1 2143 0
 13325 4b50 8B81      		ldd r24,Y+3
 13326 4b52 8093 0000 		sts tempLongString+2,r24
2144:switcherator.c ****     tempLongString[3] = commandReceived[4];
 13327               		.loc 1 2144 0
 13328 4b56 8C81      		ldd r24,Y+4
 13329 4b58 8093 0000 		sts tempLongString+3,r24
2145:switcherator.c ****     globalMonth = atoi(tempLongString);
 13330               		.loc 1 2145 0
 13331 4b5c 80E0      		ldi r24,lo8(tempLongString)
 13332 4b5e 90E0      		ldi r25,hi8(tempLongString)
 13333 4b60 0E94 0000 		call atoi
 13334               	.LVL1163:
 13335 4b64 6C01      		movw r12,r24
 13336 4b66 9093 0000 		sts globalMonth+1,r25
 13337 4b6a 8093 0000 		sts globalMonth,r24
2147:switcherator.c ****     tempLongString[2] = commandReceived[5];
 13338               		.loc 1 2147 0
 13339 4b6e 8D81      		ldd r24,Y+5
 13340 4b70 8093 0000 		sts tempLongString+2,r24
2148:switcherator.c ****     tempLongString[3] = commandReceived[6];
 13341               		.loc 1 2148 0
 13342 4b74 8E81      		ldd r24,Y+6
 13343 4b76 8093 0000 		sts tempLongString+3,r24
2149:switcherator.c ****     globalDay = atoi(tempLongString);
 13344               		.loc 1 2149 0
 13345 4b7a 80E0      		ldi r24,lo8(tempLongString)
 13346 4b7c 90E0      		ldi r25,hi8(tempLongString)
 13347 4b7e 0E94 0000 		call atoi
 13348               	.LVL1164:
 13349 4b82 8C01      		movw r16,r24
 13350 4b84 9093 0000 		sts globalDay+1,r25
 13351 4b88 8093 0000 		sts globalDay,r24
2151:switcherator.c ****     tempLongString[2] = commandReceived[11];
 13352               		.loc 1 2151 0
 13353 4b8c 8B85      		ldd r24,Y+11
 13354 4b8e 8093 0000 		sts tempLongString+2,r24
2152:switcherator.c ****     tempLongString[3] = commandReceived[12];
 13355               		.loc 1 2152 0
 13356 4b92 8C85      		ldd r24,Y+12
 13357 4b94 8093 0000 		sts tempLongString+3,r24
2153:switcherator.c ****     globalHour = atoi(tempLongString);
 13358               		.loc 1 2153 0
 13359 4b98 80E0      		ldi r24,lo8(tempLongString)
 13360 4b9a 90E0      		ldi r25,hi8(tempLongString)
 13361 4b9c 0E94 0000 		call atoi
 13362               	.LVL1165:
 13363 4ba0 4C01      		movw r8,r24
 13364 4ba2 8093 0000 		sts globalHour,r24
 13365 4ba6 9092 0000 		sts globalHour+1,r9
2155:switcherator.c ****     tempLongString[2] = commandReceived[13];
 13366               		.loc 1 2155 0
 13367 4baa 8D85      		ldd r24,Y+13
 13368 4bac 8093 0000 		sts tempLongString+2,r24
2156:switcherator.c ****     tempLongString[3] = commandReceived[14];
 13369               		.loc 1 2156 0
 13370 4bb0 8E85      		ldd r24,Y+14
 13371 4bb2 8093 0000 		sts tempLongString+3,r24
2157:switcherator.c ****     globalMinute = atoi(tempLongString);
 13372               		.loc 1 2157 0
 13373 4bb6 80E0      		ldi r24,lo8(tempLongString)
 13374 4bb8 90E0      		ldi r25,hi8(tempLongString)
 13375 4bba 0E94 0000 		call atoi
 13376               	.LVL1166:
 13377 4bbe 5C01      		movw r10,r24
 13378 4bc0 8093 0000 		sts globalMinute,r24
 13379 4bc4 B092 0000 		sts globalMinute+1,r11
2159:switcherator.c ****     tempLongString[2] = commandReceived[15];
 13380               		.loc 1 2159 0
 13381 4bc8 8F85      		ldd r24,Y+15
 13382 4bca 8093 0000 		sts tempLongString+2,r24
2160:switcherator.c ****     tempLongString[3] = commandReceived[16];
 13383               		.loc 1 2160 0
 13384 4bce 8889      		ldd r24,Y+16
 13385 4bd0 8093 0000 		sts tempLongString+3,r24
2161:switcherator.c ****     globalSecond = atoi(tempLongString);
 13386               		.loc 1 2161 0
 13387 4bd4 80E0      		ldi r24,lo8(tempLongString)
 13388 4bd6 90E0      		ldi r25,hi8(tempLongString)
 13389 4bd8 0E94 0000 		call atoi
 13390               	.LVL1167:
 13391 4bdc 3C01      		movw r6,r24
 13392 4bde 9093 0000 		sts globalSecond+1,r25
 13393 4be2 8093 0000 		sts globalSecond,r24
2163:switcherator.c ****     tempLongString[0] = commandReceived[7];
 13394               		.loc 1 2163 0
 13395 4be6 8F81      		ldd r24,Y+7
 13396 4be8 8093 0000 		sts tempLongString,r24
2164:switcherator.c ****     tempLongString[1] = commandReceived[8];
 13397               		.loc 1 2164 0
 13398 4bec 8885      		ldd r24,Y+8
 13399 4bee 8093 0000 		sts tempLongString+1,r24
2165:switcherator.c ****     tempLongString[2] = commandReceived[9];
 13400               		.loc 1 2165 0
 13401 4bf2 8985      		ldd r24,Y+9
 13402 4bf4 8093 0000 		sts tempLongString+2,r24
2166:switcherator.c ****     tempLongString[3] = commandReceived[10];
 13403               		.loc 1 2166 0
 13404 4bf8 8A85      		ldd r24,Y+10
 13405 4bfa 8093 0000 		sts tempLongString+3,r24
2167:switcherator.c ****     globalYear = atoi(tempLongString);
 13406               		.loc 1 2167 0
 13407 4bfe 80E0      		ldi r24,lo8(tempLongString)
 13408 4c00 90E0      		ldi r25,hi8(tempLongString)
 13409 4c02 0E94 0000 		call atoi
 13410               	.LVL1168:
 13411 4c06 9093 0000 		sts globalYear+1,r25
 13412 4c0a 8093 0000 		sts globalYear,r24
2168:switcherator.c ****     dow = getWeekday(globalYear, globalMonth, globalDay); // get day of week
 13413               		.loc 1 2168 0
 13414 4c0e A801      		movw r20,r16
 13415 4c10 B601      		movw r22,r12
 13416 4c12 0E94 0000 		call getWeekday
 13417               	.LVL1169:
 13418 4c16 DC01      		movw r26,r24
 13419 4c18 8093 0000 		sts dow,r24
 13420 4c1c B093 0000 		sts dow+1,r27
 13421               	.LVL1170:
2170:switcherator.c ****     tempInt = tempInt * 24 * 60 * 60;
 13422               		.loc 1 2170 0
 13423 4c20 20E8      		ldi r18,lo8(-128)
 13424 4c22 31E5      		ldi r19,lo8(81)
 13425 4c24 41E0      		ldi r20,lo8(1)
 13426 4c26 50E0      		ldi r21,0
 13427 4c28 0E94 0000 		call __muluhisi3
 13428 4c2c 6B01      		movw r12,r22
 13429 4c2e 7C01      		movw r14,r24
2173:switcherator.c ****     tempInt = tempInt * 60 * 60;
 13430               		.loc 1 2173 0
 13431 4c30 9401      		movw r18,r8
 13432 4c32 A0E1      		ldi r26,lo8(16)
 13433 4c34 BEE0      		ldi r27,lo8(14)
 13434 4c36 0E94 0000 		call __umulhisi3
2174:switcherator.c ****     weeklySeconds += tempInt;
 13435               		.loc 1 2174 0
 13436 4c3a C60E      		add r12,r22
 13437 4c3c D71E      		adc r13,r23
 13438 4c3e E81E      		adc r14,r24
 13439 4c40 F91E      		adc r15,r25
2177:switcherator.c ****     weeklySeconds += tempInt;
 13440               		.loc 1 2177 0
 13441 4c42 C60C      		add r12,r6
 13442 4c44 D71C      		adc r13,r7
 13443 4c46 E11C      		adc r14,__zero_reg__
 13444 4c48 F11C      		adc r15,__zero_reg__
2176:switcherator.c ****     tempInt = tempInt * 60;
 13445               		.loc 1 2176 0
 13446 4c4a 9501      		movw r18,r10
 13447 4c4c ACE3      		ldi r26,lo8(60)
 13448 4c4e B0E0      		ldi r27,0
 13449 4c50 0E94 0000 		call __umulhisi3
2178:switcherator.c ****     weeklySeconds += globalSecond;
 13450               		.loc 1 2178 0
 13451 4c54 C60E      		add r12,r22
 13452 4c56 D71E      		adc r13,r23
 13453 4c58 E81E      		adc r14,r24
 13454 4c5a F91E      		adc r15,r25
 13455 4c5c C092 0000 		sts weeklySeconds,r12
 13456 4c60 D092 0000 		sts weeklySeconds+1,r13
 13457 4c64 E092 0000 		sts weeklySeconds+2,r14
 13458 4c68 F092 0000 		sts weeklySeconds+3,r15
2179:switcherator.c ****     clockString();
 13459               		.loc 1 2179 0
 13460 4c6c 0E94 0000 		call clockString
 13461               	.LVL1171:
2180:switcherator.c ****     sendMessage(statusMsg);
 13462               		.loc 1 2180 0
 13463 4c70 80E0      		ldi r24,lo8(statusMsg)
 13464 4c72 90E0      		ldi r25,hi8(statusMsg)
 13465 4c74 0E94 0000 		call sendMessage
 13466               	.LVL1172:
2181:switcherator.c ****     stopClock();
 13467               		.loc 1 2181 0
 13468 4c78 0E94 0000 		call stopClock
 13469               	.LVL1173:
2182:switcherator.c ****     startClock();
 13470               		.loc 1 2182 0
 13471 4c7c 0E94 0000 		call startClock
 13472               	.LVL1174:
2183:switcherator.c ****     panicMyClockIsNotSet = 0;
 13473               		.loc 1 2183 0
 13474 4c80 1092 0000 		sts panicMyClockIsNotSet,__zero_reg__
2184:switcherator.c ****     if(failCondition == 3) {
 13475               		.loc 1 2184 0
 13476 4c84 8091 0000 		lds r24,failCondition
 13477 4c88 8330      		cpi r24,lo8(3)
 13478 4c8a 01F4      		brne .L886
 13479               	/* epilogue start */
2187:switcherator.c **** }
 13480               		.loc 1 2187 0
 13481 4c8c DF91      		pop r29
 13482 4c8e CF91      		pop r28
 13483               	.LVL1175:
 13484 4c90 1F91      		pop r17
 13485 4c92 0F91      		pop r16
 13486 4c94 FF90      		pop r15
 13487 4c96 EF90      		pop r14
 13488 4c98 DF90      		pop r13
 13489 4c9a CF90      		pop r12
 13490 4c9c BF90      		pop r11
 13491               	.LVL1176:
 13492 4c9e AF90      		pop r10
 13493 4ca0 9F90      		pop r9
 13494 4ca2 8F90      		pop r8
 13495 4ca4 7F90      		pop r7
 13496 4ca6 6F90      		pop r6
2185:switcherator.c ****         clearFail();      
 13497               		.loc 1 2185 0
 13498 4ca8 0C94 0000 		jmp clearFail
 13499               	.LVL1177:
 13500               	.L886:
 13501               	/* epilogue start */
2187:switcherator.c **** }
 13502               		.loc 1 2187 0
 13503 4cac DF91      		pop r29
 13504 4cae CF91      		pop r28
 13505               	.LVL1178:
 13506 4cb0 1F91      		pop r17
 13507 4cb2 0F91      		pop r16
 13508 4cb4 FF90      		pop r15
 13509 4cb6 EF90      		pop r14
 13510 4cb8 DF90      		pop r13
 13511 4cba CF90      		pop r12
 13512 4cbc BF90      		pop r11
 13513               	.LVL1179:
 13514 4cbe AF90      		pop r10
 13515 4cc0 9F90      		pop r9
 13516 4cc2 8F90      		pop r8
 13517 4cc4 7F90      		pop r7
 13518 4cc6 6F90      		pop r6
 13519 4cc8 0895      		ret
 13520               	.LFE48:
 13522               	.global	checkCommand
 13524               	checkCommand:
 13525               	.LFB8:
 265:switcherator.c **** void checkCommand(char * commandReceived) {
 13526               		.loc 1 265 0
 13527               	.LVL1180:
 13528               	/* prologue: function */
 13529               	/* frame size = 0 */
 13530               	/* stack size = 0 */
 13531               	.L__stack_usage = 0
 266:switcherator.c ****     if (commandReceived[0] > 0x60)
 13532               		.loc 1 266 0
 13533 4cca FC01      		movw r30,r24
 13534 4ccc 2081      		ld r18,Z
 13535 4cce 2136      		cpi r18,lo8(97)
 13536 4cd0 00F0      		brlo .L889
 267:switcherator.c ****         commandReceived[0] -= 0x20;
 13537               		.loc 1 267 0
 13538 4cd2 2052      		subi r18,lo8(-(-32))
 13539 4cd4 2083      		st Z,r18
 13540               	.L889:
 268:switcherator.c ****     if (commandReceived[1] > 0x60)
 13541               		.loc 1 268 0
 13542 4cd6 FC01      		movw r30,r24
 13543 4cd8 2181      		ldd r18,Z+1
 13544 4cda 2136      		cpi r18,lo8(97)
 13545 4cdc 00F0      		brlo .L890
 269:switcherator.c ****         commandReceived[1] -= 0x20;
 13546               		.loc 1 269 0
 13547 4cde 2052      		subi r18,lo8(-(-32))
 13548 4ce0 2183      		std Z+1,r18
 13549               	.L890:
 271:switcherator.c ****     switchme <<= 8;
 13550               		.loc 1 271 0
 13551 4ce2 FC01      		movw r30,r24
 13552 4ce4 3081      		ld r19,Z
 13553 4ce6 20E0      		ldi r18,0
 13554               	.LVL1181:
 272:switcherator.c ****     switchme |= commandReceived[1];
 13555               		.loc 1 272 0
 13556 4ce8 4181      		ldd r20,Z+1
 13557 4cea 242B      		or r18,r20
 13558               	.LVL1182:
 273:switcherator.c ****     switch (switchme) {
 13559               		.loc 1 273 0
 13560 4cec 2934      		cpi r18,73
 13561 4cee F0E5      		ldi r31,80
 13562 4cf0 3F07      		cpc r19,r31
 13563 4cf2 01F4      		brne .+2
 13564 4cf4 00C0      		rjmp .L910
 13565 4cf6 04F0      		brlt .+2
 13566 4cf8 00C0      		rjmp .L929
 13567 4cfa 2934      		cpi r18,73
 13568 4cfc E4E4      		ldi r30,68
 13569 4cfe 3E07      		cpc r19,r30
 13570 4d00 01F4      		brne .+2
 13571 4d02 00C0      		rjmp .L900
 13572 4d04 04F4      		brge .L930
 13573 4d06 2834      		cpi r18,72
 13574 4d08 43E4      		ldi r20,67
 13575 4d0a 3407      		cpc r19,r20
 13576 4d0c 01F4      		brne .+2
 13577 4d0e 00C0      		rjmp .L895
 13578 4d10 04F4      		brge .L931
 13579 4d12 2335      		cpi r18,83
 13580 4d14 F2E4      		ldi r31,66
 13581 4d16 3F07      		cpc r19,r31
 13582 4d18 01F4      		brne .+2
 13583 4d1a 00C0      		rjmp .L893
 13584 4d1c 2334      		cpi r18,67
 13585 4d1e 43E4      		ldi r20,67
 13586 4d20 3407      		cpc r19,r20
 13587 4d22 01F4      		brne .+2
 13588 4d24 00C0      		rjmp .L894
 13589 4d26 2934      		cpi r18,73
 13590 4d28 3144      		sbci r19,65
 13591 4d2a 01F0      		breq .+2
 13592 4d2c 00C0      		rjmp .L888
 13593 4d2e 00C0      		rjmp .L892
 13594               	.L931:
 13595 4d30 2C34      		cpi r18,76
 13596 4d32 F3E4      		ldi r31,67
 13597 4d34 3F07      		cpc r19,r31
 13598 4d36 01F4      		brne .+2
 13599 4d38 00C0      		rjmp .L897
 13600 4d3a 04F4      		brge .L932
 13601 4d3c 2934      		cpi r18,73
 13602 4d3e 3344      		sbci r19,67
 13603 4d40 01F0      		breq .+2
 13604 4d42 00C0      		rjmp .L888
 13605 4d44 00C0      		rjmp .L896
 13606               	.L932:
 13607 4d46 2035      		cpi r18,80
 13608 4d48 F3E4      		ldi r31,67
 13609 4d4a 3F07      		cpc r19,r31
 13610 4d4c 01F4      		brne .+2
 13611 4d4e 00C0      		rjmp .L898
 13612 4d50 2435      		cpi r18,84
 13613 4d52 3344      		sbci r19,67
 13614 4d54 01F0      		breq .+2
 13615 4d56 00C0      		rjmp .L888
 13616 4d58 00C0      		rjmp .L899
 13617               	.L930:
 13618 4d5a 2035      		cpi r18,80
 13619 4d5c E9E4      		ldi r30,73
 13620 4d5e 3E07      		cpc r19,r30
 13621 4d60 01F4      		brne .+2
 13622 4d62 00C0      		rjmp .L905
 13623 4d64 04F4      		brge .L933
 13624 4d66 2934      		cpi r18,73
 13625 4d68 47E4      		ldi r20,71
 13626 4d6a 3407      		cpc r19,r20
 13627 4d6c 01F4      		brne .+2
 13628 4d6e 00C0      		rjmp .L902
 13629 4d70 04F4      		brge .L934
 13630 4d72 2335      		cpi r18,83
 13631 4d74 3444      		sbci r19,68
 13632 4d76 01F0      		breq .+2
 13633 4d78 00C0      		rjmp .L888
 13634 4d7a 00C0      		rjmp .L901
 13635               	.L934:
 13636 4d7c 2335      		cpi r18,83
 13637 4d7e 47E4      		ldi r20,71
 13638 4d80 3407      		cpc r19,r20
 13639 4d82 01F4      		brne .+2
 13640 4d84 00C0      		rjmp .L903
 13641 4d86 2436      		cpi r18,100
 13642 4d88 3844      		sbci r19,72
 13643 4d8a 01F0      		breq .+2
 13644 4d8c 00C0      		rjmp .L888
 13645 4d8e 00C0      		rjmp .L904
 13646               	.L933:
 13647 4d90 2335      		cpi r18,83
 13648 4d92 FEE4      		ldi r31,78
 13649 4d94 3F07      		cpc r19,r31
 13650 4d96 01F4      		brne .+2
 13651 4d98 00C0      		rjmp .L907
 13652 4d9a 04F4      		brge .L935
 13653 4d9c 2035      		cpi r18,80
 13654 4d9e 3E44      		sbci r19,78
 13655 4da0 01F0      		breq .+2
 13656 4da2 00C0      		rjmp .L888
 13657 4da4 00C0      		rjmp .L906
 13658               	.L935:
 13659 4da6 2134      		cpi r18,65
 13660 4da8 F0E5      		ldi r31,80
 13661 4daa 3F07      		cpc r19,r31
 13662 4dac 01F4      		brne .+2
 13663 4dae 00C0      		rjmp .L908
 13664 4db0 2434      		cpi r18,68
 13665 4db2 3045      		sbci r19,80
 13666 4db4 01F0      		breq .+2
 13667 4db6 00C0      		rjmp .L888
 13668 4db8 00C0      		rjmp .L909
 13669               	.L929:
 13670 4dba 2234      		cpi r18,66
 13671 4dbc E3E5      		ldi r30,83
 13672 4dbe 3E07      		cpc r19,r30
 13673 4dc0 01F4      		brne .+2
 13674 4dc2 00C0      		rjmp .L919
 13675 4dc4 04F4      		brge .L936
 13676 4dc6 2635      		cpi r18,86
 13677 4dc8 40E5      		ldi r20,80
 13678 4dca 3407      		cpc r19,r20
 13679 4dcc 01F4      		brne .+2
 13680 4dce 00C0      		rjmp .L914
 13681 4dd0 04F4      		brge .L937
 13682 4dd2 2335      		cpi r18,83
 13683 4dd4 F0E5      		ldi r31,80
 13684 4dd6 3F07      		cpc r19,r31
 13685 4dd8 01F4      		brne .+2
 13686 4dda 00C0      		rjmp .L912
 13687 4ddc 2435      		cpi r18,84
 13688 4dde 40E5      		ldi r20,80
 13689 4de0 3407      		cpc r19,r20
 13690 4de2 01F4      		brne .+2
 13691 4de4 00C0      		rjmp .L913
 13692 4de6 2035      		cpi r18,80
 13693 4de8 3045      		sbci r19,80
 13694               	.LVL1183:
 13695 4dea 01F0      		breq .+2
 13696 4dec 00C0      		rjmp .L888
 13697 4dee 00C0      		rjmp .L911
 13698               	.LVL1184:
 13699               	.L937:
 13700 4df0 2334      		cpi r18,67
 13701 4df2 E2E5      		ldi r30,82
 13702 4df4 3E07      		cpc r19,r30
 13703 4df6 01F4      		brne .+2
 13704 4df8 00C0      		rjmp .L916
 13705 4dfa 04F4      		brge .L938
 13706 4dfc 2735      		cpi r18,87
 13707 4dfe 3045      		sbci r19,80
 13708 4e00 01F0      		breq .+2
 13709 4e02 00C0      		rjmp .L888
 13710 4e04 00C0      		rjmp .L915
 13711               	.L938:
 13712 4e06 2434      		cpi r18,68
 13713 4e08 E2E5      		ldi r30,82
 13714 4e0a 3E07      		cpc r19,r30
 13715 4e0c 01F4      		brne .+2
 13716 4e0e 00C0      		rjmp .L917
 13717 4e10 2134      		cpi r18,65
 13718 4e12 3345      		sbci r19,83
 13719 4e14 01F0      		breq .+2
 13720 4e16 00C0      		rjmp .L888
 13721 4e18 00C0      		rjmp .L918
 13722               	.L936:
 13723 4e1a 2035      		cpi r18,80
 13724 4e1c 43E5      		ldi r20,83
 13725 4e1e 3407      		cpc r19,r20
 13726 4e20 01F4      		brne .+2
 13727 4e22 00C0      		rjmp .L924
 13728 4e24 04F4      		brge .L939
 13729 4e26 2434      		cpi r18,68
 13730 4e28 F3E5      		ldi r31,83
 13731 4e2a 3F07      		cpc r19,r31
 13732 4e2c 01F0      		breq .L921
 13733 4e2e 04F0      		brlt .L920
 13734 4e30 2534      		cpi r18,69
 13735 4e32 E3E5      		ldi r30,83
 13736 4e34 3E07      		cpc r19,r30
 13737 4e36 01F0      		breq .L922
 13738 4e38 2F34      		cpi r18,79
 13739 4e3a 3345      		sbci r19,83
 13740 4e3c 01F0      		breq .+2
 13741 4e3e 00C0      		rjmp .L888
 13742 4e40 00C0      		rjmp .L923
 13743               	.L939:
 13744 4e42 2735      		cpi r18,87
 13745 4e44 43E5      		ldi r20,83
 13746 4e46 3407      		cpc r19,r20
 13747 4e48 01F4      		brne .+2
 13748 4e4a 00C0      		rjmp .L926
 13749 4e4c 04F4      		brge .L940
 13750 4e4e 2335      		cpi r18,83
 13751 4e50 3345      		sbci r19,83
 13752 4e52 01F0      		breq .+2
 13753 4e54 00C0      		rjmp .L888
 13754 4e56 00C0      		rjmp .L925
 13755               	.L940:
 13756 4e58 2934      		cpi r18,73
 13757 4e5a 44E5      		ldi r20,84
 13758 4e5c 3407      		cpc r19,r20
 13759 4e5e 01F0      		breq .L927
 13760 4e60 2C34      		cpi r18,76
 13761 4e62 3445      		sbci r19,84
 13762 4e64 01F0      		breq .+2
 13763 4e66 00C0      		rjmp .L888
 13764 4e68 00C0      		rjmp .L928
 13765               	.L927:
 275:switcherator.c ****             setClock(commandReceived);
 13766               		.loc 1 275 0
 13767 4e6a 0C94 0000 		jmp setClock
 13768               	.LVL1185:
 13769               	.L901:
 278:switcherator.c ****             setDaylightSavings(commandReceived);
 13770               		.loc 1 278 0
 13771 4e6e 0C94 0000 		jmp setDaylightSavings
 13772               	.LVL1186:
 13773               	.L928:
 281:switcherator.c ****             setTimeLimits(commandReceived);
 13774               		.loc 1 281 0
 13775 4e72 0C94 0000 		jmp setTimeLimits
 13776               	.LVL1187:
 13777               	.L907:
 284:switcherator.c ****             setNewSwitch(commandReceived);
 13778               		.loc 1 284 0
 13779 4e76 0C94 0000 		jmp setNewSwitch
 13780               	.LVL1188:
 13781               	.L920:
 287:switcherator.c ****             switchClear(commandReceived);
 13782               		.loc 1 287 0
 13783 4e7a 0C94 0000 		jmp switchClear
 13784               	.LVL1189:
 13785               	.L921:
 290:switcherator.c ****             switchDisplay(commandReceived);
 13786               		.loc 1 290 0
 13787 4e7e 0C94 0000 		jmp switchDisplay
 13788               	.LVL1190:
 13789               	.L912:
 293:switcherator.c ****             pwmSetup(commandReceived);
 13790               		.loc 1 293 0
 13791 4e82 0C94 0000 		jmp pwmSetup
 13792               	.LVL1191:
 13793               	.L895:
 296:switcherator.c ****             cycleHue(commandReceived);
 13794               		.loc 1 296 0
 13795 4e86 0C94 0000 		jmp cycleHue
 13796               	.LVL1192:
 13797               	.L904:
 299:switcherator.c ****             setHueSpeed(commandReceived);
 13798               		.loc 1 299 0
 13799 4e8a 0C94 0000 		jmp setHueSpeed
 13800               	.LVL1193:
 13801               	.L914:
 302:switcherator.c ****             pwmValueSet(commandReceived);
 13802               		.loc 1 302 0
 13803 4e8e 0C94 0000 		jmp pwmValueSet
 13804               	.LVL1194:
 13805               	.L906:
 305:switcherator.c ****             newProgram(commandReceived);
 13806               		.loc 1 305 0
 13807 4e92 0C94 0000 		jmp newProgram
 13808               	.LVL1195:
 13809               	.L898:
 308:switcherator.c ****             clearProgram(commandReceived);
 13810               		.loc 1 308 0
 13811 4e96 0C94 0000 		jmp clearProgram
 13812               	.LVL1196:
 13813               	.L908:
 311:switcherator.c ****             programAddSwitch(commandReceived);
 13814               		.loc 1 311 0
 13815 4e9a 0C94 0000 		jmp programAddSwitch
 13816               	.LVL1197:
 13817               	.L909:
 314:switcherator.c ****             programSetDays(commandReceived);
 13818               		.loc 1 314 0
 13819 4e9e 0C94 0000 		jmp programSetDays
 13820               	.LVL1198:
 13821               	.L913:
 317:switcherator.c ****             programSetTime(commandReceived);
 13822               		.loc 1 317 0
 13823 4ea2 0C94 0000 		jmp programSetTime
 13824               	.LVL1199:
 13825               	.L910:
 320:switcherator.c ****             programDisplay(commandReceived);
 13826               		.loc 1 320 0
 13827 4ea6 0C94 0000 		jmp programDisplay
 13828               	.LVL1200:
 13829               	.L925:
 323:switcherator.c ****             startSwitch(commandReceived);
 13830               		.loc 1 323 0
 13831 4eaa 0C94 0000 		jmp startSwitch
 13832               	.LVL1201:
 13833               	.L924:
 326:switcherator.c ****             startProgram(commandReceived);
 13834               		.loc 1 326 0
 13835 4eae 0C94 0000 		jmp startProgram
 13836               	.LVL1202:
 13837               	.L922:
 329:switcherator.c ****             serialNumber(commandReceived);
 13838               		.loc 1 329 0
 13839 4eb2 0C94 0000 		jmp serialNumber
 13840               	.LVL1203:
 13841               	.L918:
 332:switcherator.c ****             saveToEEPROM();
 13842               		.loc 1 332 0
 13843 4eb6 0C94 0000 		jmp saveToEEPROM
 13844               	.LVL1204:
 13845               	.L897:
 335:switcherator.c ****             clearToEEPROM();
 13846               		.loc 1 335 0
 13847 4eba 0C94 0000 		jmp clearToEEPROM
 13848               	.LVL1205:
 13849               	.L917:
 338:switcherator.c ****             radioDisplayAddress(commandReceived);
 13850               		.loc 1 338 0
 13851 4ebe 0C94 0000 		jmp radioDisplayAddress
 13852               	.LVL1206:
 13853               	.L916:
 341:switcherator.c ****             radioChangeAddress(commandReceived);
 13854               		.loc 1 341 0
 13855 4ec2 0C94 0000 		jmp radioChangeAddress
 13856               	.LVL1207:
 13857               	.L892:
 344:switcherator.c ****             setAnalogInput(commandReceived);
 13858               		.loc 1 344 0
 13859 4ec6 0C94 0000 		jmp setAnalogInput
 13860               	.LVL1208:
 13861               	.L900:
 347:switcherator.c ****             setDigitalInput(commandReceived);
 13862               		.loc 1 347 0
 13863 4eca 0C94 0000 		jmp setDigitalInput
 13864               	.LVL1209:
 13865               	.L896:
 350:switcherator.c ****             clearInput(commandReceived);
 13866               		.loc 1 350 0
 13867 4ece 0C94 0000 		jmp clearInput
 13868               	.LVL1210:
 13869               	.L899:
 353:switcherator.c ****             clockTweak(commandReceived);
 13870               		.loc 1 353 0
 13871 4ed2 0C94 0000 		jmp clockTweak
 13872               	.LVL1211:
 13873               	.L915:
 356:switcherator.c ****             pwmSummary();
 13874               		.loc 1 356 0
 13875 4ed6 0C94 0000 		jmp pwmSummary
 13876               	.LVL1212:
 13877               	.L903:
 362:switcherator.c ****             generalStatus(commandReceived);
 13878               		.loc 1 362 0
 13879 4eda 0C94 0000 		jmp generalStatus
 13880               	.LVL1213:
 13881               	.L894:
 368:switcherator.c ****             colorChangeSet(commandReceived);
 13882               		.loc 1 368 0
 13883 4ede 0C94 0000 		jmp colorChangeSet
 13884               	.LVL1214:
 13885               	.L919:
 371:switcherator.c ****             switchBrightness(commandReceived);
 13886               		.loc 1 371 0
 13887 4ee2 0C94 0000 		jmp switchBrightness
 13888               	.LVL1215:
 13889               	.L893:
 374:switcherator.c ****             brightnessSet(commandReceived);
 13890               		.loc 1 374 0
 13891 4ee6 0C94 0000 		jmp brightnessSet
 13892               	.LVL1216:
 13893               	.L902:
 377:switcherator.c ****             generalInformation();
 13894               		.loc 1 377 0
 13895 4eea 0C94 0000 		jmp generalInformation
 13896               	.LVL1217:
 13897               	.L911:
 380:switcherator.c ****             programsProgrammed();
 13898               		.loc 1 380 0
 13899 4eee 0C94 0000 		jmp programsProgrammed
 13900               	.LVL1218:
 13901               	.L926:
 383:switcherator.c ****             switchesProgrammed();
 13902               		.loc 1 383 0
 13903 4ef2 0C94 0000 		jmp switchesProgrammed
 13904               	.LVL1219:
 13905               	.L905:
 386:switcherator.c ****             inputsProgrammed();
 13906               		.loc 1 386 0
 13907 4ef6 0C94 0000 		jmp inputsProgrammed
 13908               	.LVL1220:
 13909               	.L923:
 389:switcherator.c ****             switchesOn();
 13910               		.loc 1 389 0
 13911 4efa 0C94 0000 		jmp switchesOn
 13912               	.LVL1221:
 13913               	.L888:
 13914 4efe 0895      		ret
 13915               	.LFE8:
 13917               		.section	.rodata.str1.1
 13918               	.LC76:
 13919 0177 6773 7100 		.string	"gsq"
 13920               	.LC77:
 13921 017b 5345 00   		.string	"SE"
 13922               	.LC78:
 13923 017e 7365 00   		.string	"se"
 13924               	.LC75:
 13925 0181 3030 3030 		.string	"000000"
 13925      3030 00
 13926               		.section	.text.startup,"ax",@progbits
 13927               	.global	main
 13929               	main:
 13930               	.LFB7:
 124:switcherator.c **** int main(void) {
 13931               		.loc 1 124 0
 13932 0000 CF93      		push r28
 13933               	.LCFI379:
 13934 0002 DF93      		push r29
 13935               	.LCFI380:
 13936 0004 CDB7      		in r28,__SP_L__
 13937 0006 DEB7      		in r29,__SP_H__
 13938               	.LCFI381:
 13939 0008 A797      		sbiw r28,39
 13940               	.LCFI382:
 13941 000a 0FB6      		in __tmp_reg__,__SREG__
 13942 000c F894      		cli
 13943 000e DEBF      		out __SP_H__,r29
 13944 0010 0FBE      		out __SREG__,__tmp_reg__
 13945 0012 CDBF      		out __SP_L__,r28
 13946               	/* prologue: function */
 13947               	/* frame size = 39 */
 13948               	/* stack size = 41 */
 13949               	.L__stack_usage = 41
 125:switcherator.c ****     receiveBuffer[0] = 0;
 13950               		.loc 1 125 0
 13951 0014 1092 0000 		sts receiveBuffer,__zero_reg__
 126:switcherator.c ****     radioReceiveBuffer[0] = 0;
 13952               		.loc 1 126 0
 13953 0018 1092 0000 		sts radioReceiveBuffer,__zero_reg__
 13954               	.LVL1222:
 129:switcherator.c ****     INDICATOR_DDR |= INDICATOR_PIN;
 13955               		.loc 1 129 0
 13956 001c 529A      		sbi 0xa,2
 13957 001e 84E0      		ldi r24,lo8(4)
 13958 0020 90E0      		ldi r25,0
 13959               	.LVL1223:
 13960               	.L942:
 131:switcherator.c ****         INDICATOR_PORT |= INDICATOR_PIN;
 13961               		.loc 1 131 0 discriminator 2
 13962 0022 5A9A      		sbi 0xb,2
 13963               	.LVL1224:
 13964               	.LBB30:
 13965               	.LBB31:
 164:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 13966               		.loc 2 164 0 discriminator 2
 13967 0024 2FEF      		ldi r18,lo8(159999)
 13968 0026 30E7      		ldi r19,hi8(159999)
 13969 0028 42E0      		ldi r20,hlo8(159999)
 13970 002a 2150      		1: subi r18,1
 13971 002c 3040      		sbci r19,0
 13972 002e 4040      		sbci r20,0
 13973 0030 01F4      		brne 1b
 13974 0032 00C0      		rjmp .
 13975 0034 0000      		nop
 13976               	.LBE31:
 13977               	.LBE30:
 133:switcherator.c ****         INDICATOR_PORT &= ~(INDICATOR_PIN);
 13978               		.loc 1 133 0 discriminator 2
 13979 0036 5A98      		cbi 0xb,2
 13980               	.LVL1225:
 13981               	.LBB32:
 13982               	.LBB33:
 164:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 13983               		.loc 2 164 0 discriminator 2
 13984 0038 5FEF      		ldi r21,lo8(319999)
 13985 003a A1EE      		ldi r26,hi8(319999)
 13986 003c B4E0      		ldi r27,hlo8(319999)
 13987 003e 5150      		1: subi r21,1
 13988 0040 A040      		sbci r26,0
 13989 0042 B040      		sbci r27,0
 13990 0044 01F4      		brne 1b
 13991 0046 00C0      		rjmp .
 13992 0048 0000      		nop
 13993 004a 0197      		sbiw r24,1
 13994               	.LBE33:
 13995               	.LBE32:
 130:switcherator.c ****     for (x = 0; x < 4; x++) {
 13996               		.loc 1 130 0 discriminator 2
 13997 004c 01F4      		brne .L942
 136:switcherator.c ****     INDICATOR_PORT |= INDICATOR_PIN;
 13998               		.loc 1 136 0
 13999 004e 5A9A      		sbi 0xb,2
 14000               	.LVL1226:
 14001 0050 E0E0      		ldi r30,lo8(colorChanges+2)
 14002 0052 F0E0      		ldi r31,hi8(colorChanges+2)
 142:switcherator.c ****         colorChanges[x][1] = 1;
 14003               		.loc 1 142 0
 14004 0054 81E0      		ldi r24,lo8(1)
 14005               	.LVL1227:
 14006               	.L943:
 124:switcherator.c **** int main(void) {
 14007               		.loc 1 124 0 discriminator 2
 14008 0056 DF01      		movw r26,r30
 14009 0058 1297      		sbiw r26,2
 141:switcherator.c ****         colorChanges[x][0] = 0;
 14010               		.loc 1 141 0 discriminator 2
 14011 005a 1C92      		st X,__zero_reg__
 124:switcherator.c **** int main(void) {
 14012               		.loc 1 124 0 discriminator 2
 14013 005c DF01      		movw r26,r30
 14014 005e 1197      		sbiw r26,1
 142:switcherator.c ****         colorChanges[x][1] = 1;
 14015               		.loc 1 142 0 discriminator 2
 14016 0060 8C93      		st X,r24
 143:switcherator.c ****         colorChanges[x][2] = 0;
 14017               		.loc 1 143 0 discriminator 2
 14018 0062 1082      		st Z,__zero_reg__
 14019 0064 3396      		adiw r30,3
 140:switcherator.c ****     for (x = 0; x < NUM_COLOR_CHANGES; x++) {
 14020               		.loc 1 140 0 discriminator 2
 14021 0066 20E0      		ldi r18,hi8(colorChanges+20)
 14022 0068 E030      		cpi r30,lo8(colorChanges+20)
 14023 006a F207      		cpc r31,r18
 14024 006c 01F4      		brne .L943
 147:switcherator.c ****     globalYear = globalMonth = globalDay = globalHour = globalMinute = globalSecond = dow = 0;
 14025               		.loc 1 147 0
 14026 006e 1092 0000 		sts dow+1,__zero_reg__
 14027 0072 1092 0000 		sts dow,__zero_reg__
 14028 0076 1092 0000 		sts globalSecond+1,__zero_reg__
 14029 007a 1092 0000 		sts globalSecond,__zero_reg__
 14030 007e 1092 0000 		sts globalMinute+1,__zero_reg__
 14031 0082 1092 0000 		sts globalMinute,__zero_reg__
 14032 0086 1092 0000 		sts globalHour+1,__zero_reg__
 14033 008a 1092 0000 		sts globalHour,__zero_reg__
 14034 008e 1092 0000 		sts globalDay+1,__zero_reg__
 14035 0092 1092 0000 		sts globalDay,__zero_reg__
 14036 0096 1092 0000 		sts globalMonth+1,__zero_reg__
 14037 009a 1092 0000 		sts globalMonth,__zero_reg__
 14038 009e 1092 0000 		sts globalYear+1,__zero_reg__
 14039 00a2 1092 0000 		sts globalYear,__zero_reg__
 14040               	.LVL1228:
 14041 00a6 E0E0      		ldi r30,lo8(switchStatus)
 14042 00a8 F0E0      		ldi r31,hi8(switchStatus)
 14043 00aa 80E0      		ldi r24,lo8(switchStuff)
 14044 00ac 90E0      		ldi r25,hi8(switchStuff)
 14045 00ae 60E0      		ldi r22,lo8(switchBright)
 14046 00b0 70E0      		ldi r23,hi8(switchBright)
 150:switcherator.c ****         switchStuff[x] = 255;
 14047               		.loc 1 150 0
 14048 00b2 4FEF      		ldi r20,lo8(-1)
 151:switcherator.c ****         switchBright[x] = 16;
 14049               		.loc 1 151 0
 14050 00b4 30E1      		ldi r19,lo8(16)
 14051               	.LVL1229:
 14052               	.L944:
 149:switcherator.c ****         switchStatus[x] = 0;
 14053               		.loc 1 149 0 discriminator 2
 14054 00b6 1192      		st Z+,__zero_reg__
 14055 00b8 1192      		st Z+,__zero_reg__
 14056 00ba 1192      		st Z+,__zero_reg__
 14057 00bc 1192      		st Z+,__zero_reg__
 150:switcherator.c ****         switchStuff[x] = 255;
 14058               		.loc 1 150 0 discriminator 2
 14059 00be 2FEF      		ldi r18,lo8(-1)
 14060 00c0 DC01      		movw r26,r24
 14061 00c2 4D93      		st X+,r20
 14062 00c4 CD01      		movw r24,r26
 151:switcherator.c ****         switchBright[x] = 16;
 14063               		.loc 1 151 0 discriminator 2
 14064 00c6 DB01      		movw r26,r22
 14065 00c8 3D93      		st X+,r19
 14066 00ca BD01      		movw r22,r26
 148:switcherator.c ****     for (x = 0; x < NUM_SWITCHES; x++) {
 14067               		.loc 1 148 0 discriminator 2
 14068 00cc B0E0      		ldi r27,hi8(switchStatus+64)
 14069 00ce E030      		cpi r30,lo8(switchStatus+64)
 14070 00d0 FB07      		cpc r31,r27
 14071 00d2 01F4      		brne .L944
 14072               	.LVL1230:
 154:switcherator.c ****         inputs[x][0] = 255;
 14073               		.loc 1 154 0 discriminator 1
 14074 00d4 2093 0000 		sts inputs,r18
 14075               	.LVL1231:
 14076 00d8 2093 0000 		sts inputs+8,r18
 14077               	.LVL1232:
 14078 00dc 2093 0000 		sts inputs+16,r18
 14079               	.LVL1233:
 14080 00e0 2093 0000 		sts inputs+24,r18
 14081               	.LVL1234:
 156:switcherator.c ****     sei();
 14082               		.loc 1 156 0 discriminator 1
 14083               	/* #APP */
 14084               	 ;  156 "switcherator.c" 1
 14085 00e4 7894      		sei
 14086               	 ;  0 "" 2
 14087               	.LVL1235:
 159:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 14088               		.loc 1 159 0 discriminator 1
 14089               	/* #NOAPP */
 14090 00e6 00E0      		ldi r16,0
 14091 00e8 10E0      		ldi r17,0
 14092               	.LVL1236:
 14093               	.L945:
 160:switcherator.c ****         clearTheProgram(x);
 14094               		.loc 1 160 0 discriminator 2
 14095 00ea C801      		movw r24,r16
 14096 00ec 0E94 0000 		call clearTheProgram
 14097               	.LVL1237:
 159:switcherator.c ****     for (x = 0; x < MAX_PROGRAM; x++) {
 14098               		.loc 1 159 0 discriminator 2
 14099 00f0 0F5F      		subi r16,-1
 14100 00f2 1F4F      		sbci r17,-1
 14101               	.LVL1238:
 14102 00f4 0A30      		cpi r16,10
 14103 00f6 1105      		cpc r17,__zero_reg__
 14104 00f8 01F4      		brne .L945
 165:switcherator.c ****     clockInit();
 14105               		.loc 1 165 0
 14106 00fa 0E94 0000 		call clockInit
 14107               	.LVL1239:
 166:switcherator.c ****     radioInit();
 14108               		.loc 1 166 0
 14109 00fe 0E94 0000 		call radioInit
 14110               	.LVL1240:
 167:switcherator.c ****     startRx();
 14111               		.loc 1 167 0
 14112 0102 0E94 0000 		call startRx
 14113               	.LVL1241:
 169:switcherator.c ****     generalInit();
 14114               		.loc 1 169 0
 14115 0106 0E94 0000 		call generalInit
 14116               	.LVL1242:
 170:switcherator.c ****     startClock();
 14117               		.loc 1 170 0
 14118 010a 0E94 0000 		call startClock
 14119               	.LVL1243:
 176:switcherator.c ****     radioCommand[0] = 0;
 14120               		.loc 1 176 0
 14121 010e 1982      		std Y+1,__zero_reg__
 177:switcherator.c ****     char tempRadioSerialIn[] = "000000";
 14122               		.loc 1 177 0
 14123 0110 87E0      		ldi r24,lo8(7)
 14124 0112 E0E0      		ldi r30,lo8(.LC75)
 14125 0114 F0E0      		ldi r31,hi8(.LC75)
 14126 0116 DE01      		movw r26,r28
 14127 0118 9196      		adiw r26,33
 14128               		0:
 14129 011a 0190      		ld r0,Z+
 14130 011c 0D92      		st X+,r0
 14131 011e 8A95      		dec r24
 14132 0120 01F4      		brne 0b
 14133               	.LVL1244:
 14134               	.L987:
 184:switcherator.c ****         if (newSecond == 1) {
 14135               		.loc 1 184 0
 14136 0122 8091 0000 		lds r24,newSecond
 14137 0126 8130      		cpi r24,lo8(1)
 14138 0128 01F4      		brne .L946
 185:switcherator.c ****             newSecond = 0;
 14139               		.loc 1 185 0
 14140 012a 1092 0000 		sts newSecond,__zero_reg__
 186:switcherator.c ****             timerCheck();
 14141               		.loc 1 186 0
 14142 012e 0E94 0000 		call timerCheck
 14143               	.LVL1245:
 187:switcherator.c ****             inputCheck();
 14144               		.loc 1 187 0
 14145 0132 0E94 0000 		call inputCheck
 14146               	.LVL1246:
 14147               	.L946:
 190:switcherator.c ****         if (switchChanged == 1) {
 14148               		.loc 1 190 0
 14149 0136 8091 0000 		lds r24,switchChanged
 14150 013a 8130      		cpi r24,lo8(1)
 14151 013c 01F4      		brne .L947
 191:switcherator.c ****             switchChanged = 0;
 14152               		.loc 1 191 0
 14153 013e 1092 0000 		sts switchChanged,__zero_reg__
 192:switcherator.c ****             switchOnOff();
 14154               		.loc 1 192 0
 14155 0142 0E94 0000 		call switchOnOff
 14156               	.LVL1247:
 14157               	.L947:
 194:switcherator.c ****         if (runHue == 1) {
 14158               		.loc 1 194 0
 14159 0146 8091 0000 		lds r24,runHue
 14160 014a 8130      		cpi r24,lo8(1)
 14161 014c 01F4      		brne .L948
 195:switcherator.c ****             runHueFunction();
 14162               		.loc 1 195 0
 14163 014e 0E94 0000 		call runHueFunction
 14164               	.LVL1248:
 14165               	.L948:
 197:switcherator.c ****         if (runColorChanges == 1) {
 14166               		.loc 1 197 0
 14167 0152 1091 0000 		lds r17,runColorChanges
 14168 0156 1130      		cpi r17,lo8(1)
 14169 0158 01F4      		brne .L949
 198:switcherator.c ****             runColorFunction();
 14170               		.loc 1 198 0
 14171 015a 0E94 0000 		call runColorFunction
 14172               	.LVL1249:
 14173               	.L949:
 200:switcherator.c ****         if (tenthFlag == 1) {
 14174               		.loc 1 200 0
 14175 015e 8091 0000 		lds r24,tenthFlag
 14176 0162 8130      		cpi r24,lo8(1)
 14177 0164 01F4      		brne .L951
 201:switcherator.c ****             tenthFlag = 0;
 14178               		.loc 1 201 0
 14179 0166 1092 0000 		sts tenthFlag,__zero_reg__
 202:switcherator.c ****             inputTenthCheck();
 14180               		.loc 1 202 0
 14181 016a 0E94 0000 		call inputTenthCheck
 14182               	.LVL1250:
 203:switcherator.c ****             if (failCondition > 0) {
 14183               		.loc 1 203 0
 14184 016e 8091 0000 		lds r24,failCondition
 14185 0172 8111      		cpse r24,__zero_reg__
 204:switcherator.c ****                 flashFail();
 14186               		.loc 1 204 0
 14187 0174 0E94 0000 		call flashFail
 14188               	.LVL1251:
 14189               	.L952:
 206:switcherator.c ****             if (runColorChanges == 1) {
 14190               		.loc 1 206 0
 14191 0178 1130      		cpi r17,lo8(1)
 14192 017a 01F4      		brne .L951
 207:switcherator.c ****                 runColorFunction();
 14193               		.loc 1 207 0
 14194 017c 0E94 0000 		call runColorFunction
 14195               	.LVL1252:
 14196               	.L951:
 210:switcherator.c ****         if (newMinute == 1) {
 14197               		.loc 1 210 0
 14198 0180 8091 0000 		lds r24,newMinute
 14199 0184 8130      		cpi r24,lo8(1)
 14200 0186 01F4      		brne .L954
 211:switcherator.c ****             newMinute = 0;
 14201               		.loc 1 211 0
 14202 0188 1092 0000 		sts newMinute,__zero_reg__
 212:switcherator.c ****             if (panicMyClockIsNotSet == 1) {
 14203               		.loc 1 212 0
 14204 018c 8091 0000 		lds r24,panicMyClockIsNotSet
 14205 0190 8130      		cpi r24,lo8(1)
 14206 0192 01F4      		brne .L955
 213:switcherator.c ****                 generalStatus("gsq");
 14207               		.loc 1 213 0
 14208 0194 80E0      		ldi r24,lo8(.LC76)
 14209 0196 90E0      		ldi r25,hi8(.LC76)
 14210 0198 0E94 0000 		call generalStatus
 14211               	.LVL1253:
 14212               	.L955:
 215:switcherator.c ****             radioTest();
 14213               		.loc 1 215 0
 14214 019c 0E94 0000 		call radioTest
 14215               	.LVL1254:
 14216               	.L954:
 218:switcherator.c ****         payloadLength = dynReceive(radioReceiveBuffer);
 14217               		.loc 1 218 0
 14218 01a0 80E0      		ldi r24,lo8(radioReceiveBuffer)
 14219 01a2 90E0      		ldi r25,hi8(radioReceiveBuffer)
 14220 01a4 0E94 0000 		call dynReceive
 14221               	.LVL1255:
 14222 01a8 082F      		mov r16,r24
 14223 01aa 10E0      		ldi r17,0
 14224               	.LVL1256:
 219:switcherator.c ****         if (payloadLength > 2) {
 14225               		.loc 1 219 0
 14226 01ac 0330      		cpi r16,3
 14227 01ae 1105      		cpc r17,__zero_reg__
 14228 01b0 04F4      		brge .+2
 14229 01b2 00C0      		rjmp .L987
 14230               	.LVL1257:
 14231               	.LBB34:
 14232               	.LBB35:
 164:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 14233               		.loc 2 164 0
 14234 01b4 2FEF      		ldi r18,lo8(287999)
 14235 01b6 34E6      		ldi r19,hi8(287999)
 14236 01b8 44E0      		ldi r20,hlo8(287999)
 14237 01ba 2150      		1: subi r18,1
 14238 01bc 3040      		sbci r19,0
 14239 01be 4040      		sbci r20,0
 14240 01c0 01F4      		brne 1b
 14241 01c2 00C0      		rjmp .
 14242 01c4 0000      		nop
 14243               	.LBE35:
 14244               	.LBE34:
 223:switcherator.c ****             if (radioReceiveBuffer[0] == 'z') {
 14245               		.loc 1 223 0
 14246 01c6 8091 0000 		lds r24,radioReceiveBuffer
 14247 01ca 8A37      		cpi r24,lo8(122)
 14248 01cc 01F4      		brne .L957
 14249 01ce E0E0      		ldi r30,lo8(radioReceiveBuffer+1)
 14250 01d0 F0E0      		ldi r31,hi8(radioReceiveBuffer+1)
 14251 01d2 DE01      		movw r26,r28
 14252 01d4 9196      		adiw r26,33
 14253               	.L958:
 226:switcherator.c ****                     tempRadioSerialIn[x] = radioReceiveBuffer[(x + 1)];
 14254               		.loc 1 226 0 discriminator 2
 14255 01d6 8191      		ld r24,Z+
 14256 01d8 8D93      		st X+,r24
 225:switcherator.c ****                 for (x = 0; x < 6; x++) {
 14257               		.loc 1 225 0 discriminator 2
 14258 01da 50E0      		ldi r21,hi8(radioReceiveBuffer+7)
 14259 01dc E030      		cpi r30,lo8(radioReceiveBuffer+7)
 14260 01de F507      		cpc r31,r21
 14261 01e0 01F4      		brne .L958
 229:switcherator.c ****                 if (strcmp(tempRadioSerialIn, stringSerial) == 0) {
 14262               		.loc 1 229 0
 14263 01e2 60E0      		ldi r22,lo8(stringSerial)
 14264 01e4 70E0      		ldi r23,hi8(stringSerial)
 14265 01e6 CE01      		movw r24,r28
 14266 01e8 8196      		adiw r24,33
 14267 01ea 0E94 0000 		call strcmp
 14268               	.LVL1258:
 14269 01ee 0097      		sbiw r24,0
 14270 01f0 01F4      		brne .L960
 14271 01f2 E0E0      		ldi r30,lo8(radioReceiveBuffer+7)
 14272 01f4 F0E0      		ldi r31,hi8(radioReceiveBuffer+7)
 14273 01f6 DE01      		movw r26,r28
 14274 01f8 1196      		adiw r26,1
 14275 01fa 00C0      		rjmp .L961
 14276               	.L962:
 231:switcherator.c ****                         radioCommand[(x - 7)] = radioReceiveBuffer[x];
 14277               		.loc 1 231 0 discriminator 2
 14278 01fc 8191      		ld r24,Z+
 14279 01fe 8D93      		st X+,r24
 14280               	.L961:
 124:switcherator.c **** int main(void) {
 14281               		.loc 1 124 0 discriminator 1
 14282 0200 CF01      		movw r24,r30
 14283 0202 8050      		subi r24,lo8(radioReceiveBuffer)
 14284 0204 9040      		sbci r25,hi8(radioReceiveBuffer)
 230:switcherator.c ****                     for (x = 7; x < payloadLength; x++) {
 14285               		.loc 1 230 0 discriminator 1
 14286 0206 8017      		cp r24,r16
 14287 0208 9107      		cpc r25,r17
 14288 020a 04F0      		brlt .L962
 14289               	.L967:
 234:switcherator.c ****                     checkCommand(radioCommand);
 14290               		.loc 1 234 0
 14291 020c CE01      		movw r24,r28
 14292 020e 0196      		adiw r24,1
 14293 0210 0E94 0000 		call checkCommand
 14294               	.LVL1259:
 14295               	.L960:
 14296 0214 E0E0      		ldi r30,lo8(radioReceiveBuffer)
 14297 0216 F0E0      		ldi r31,hi8(radioReceiveBuffer)
 14298 0218 80E0      		ldi r24,lo8(receiveBuffer)
 14299 021a 90E0      		ldi r25,hi8(receiveBuffer)
 14300 021c AE01      		movw r20,r28
 14301 021e 4F5F      		subi r20,-1
 14302 0220 5F4F      		sbci r21,-1
 14303 0222 00C0      		rjmp .L963
 14304               	.LVL1260:
 14305               	.L957:
 236:switcherator.c ****             } else if (radioReceiveBuffer[0] == 'b') { // radio isn't sending a serial number b=bro
 14306               		.loc 1 236 0
 14307 0224 8236      		cpi r24,lo8(98)
 14308 0226 01F4      		brne .L960
 14309 0228 E0E0      		ldi r30,lo8(radioReceiveBuffer+1)
 14310 022a F0E0      		ldi r31,hi8(radioReceiveBuffer+1)
 14311 022c DE01      		movw r26,r28
 14312 022e 1196      		adiw r26,1
 14313               	.L965:
 238:switcherator.c ****                     radioCommand[(x - 1)] = radioReceiveBuffer[x];
 14314               		.loc 1 238 0 discriminator 2
 14315 0230 8191      		ld r24,Z+
 14316 0232 8D93      		st X+,r24
 124:switcherator.c **** int main(void) {
 14317               		.loc 1 124 0 discriminator 2
 14318 0234 CF01      		movw r24,r30
 14319 0236 8050      		subi r24,lo8(radioReceiveBuffer)
 14320 0238 9040      		sbci r25,hi8(radioReceiveBuffer)
 237:switcherator.c ****                 for (x = 1; x < payloadLength; x++) {
 14321               		.loc 1 237 0 discriminator 2
 14322 023a 8017      		cp r24,r16
 14323 023c 9107      		cpc r25,r17
 14324 023e 04F0      		brlt .L965
 241:switcherator.c ****                 if (strncmp(radioCommand, "SE", 2) == 0 || strncmp(radioCommand, "se", 2) == 0) {
 14325               		.loc 1 241 0
 14326 0240 42E0      		ldi r20,lo8(2)
 14327 0242 50E0      		ldi r21,0
 14328 0244 60E0      		ldi r22,lo8(.LC77)
 14329 0246 70E0      		ldi r23,hi8(.LC77)
 14330 0248 CE01      		movw r24,r28
 14331 024a 0196      		adiw r24,1
 14332 024c 0E94 0000 		call strncmp
 14333               	.LVL1261:
 14334 0250 0097      		sbiw r24,0
 14335 0252 01F0      		breq .L966
 241:switcherator.c ****                 if (strncmp(radioCommand, "SE", 2) == 0 || strncmp(radioCommand, "se", 2) == 0) {
 14336               		.loc 1 241 0 is_stmt 0 discriminator 1
 14337 0254 42E0      		ldi r20,lo8(2)
 14338 0256 50E0      		ldi r21,0
 14339 0258 60E0      		ldi r22,lo8(.LC78)
 14340 025a 70E0      		ldi r23,hi8(.LC78)
 14341 025c CE01      		movw r24,r28
 14342 025e 0196      		adiw r24,1
 14343 0260 0E94 0000 		call strncmp
 14344               	.LVL1262:
 14345 0264 0097      		sbiw r24,0
 14346 0266 01F4      		brne .L967
 14347               	.L966:
 242:switcherator.c ****                     if (serial == 0) {
 14348               		.loc 1 242 0 is_stmt 1
 14349 0268 8091 0000 		lds r24,serial
 14350 026c 9091 0000 		lds r25,serial+1
 14351 0270 A091 0000 		lds r26,serial+2
 14352 0274 B091 0000 		lds r27,serial+3
 14353 0278 892B      		or r24,r25
 14354 027a 8A2B      		or r24,r26
 14355 027c 8B2B      		or r24,r27
 14356 027e 01F4      		brne .L960
 14357 0280 00C0      		rjmp .L967
 14358               	.L963:
 251:switcherator.c ****                 radioReceiveBuffer[x] = 0;
 14359               		.loc 1 251 0 discriminator 2
 14360 0282 1192      		st Z+,__zero_reg__
 252:switcherator.c ****                 receiveBuffer[x] = 0;
 14361               		.loc 1 252 0 discriminator 2
 14362 0284 DC01      		movw r26,r24
 14363 0286 1D92      		st X+,__zero_reg__
 14364 0288 CD01      		movw r24,r26
 253:switcherator.c ****                 radioCommand[x] = 0;
 14365               		.loc 1 253 0 discriminator 2
 14366 028a DA01      		movw r26,r20
 14367 028c 1D92      		st X+,__zero_reg__
 14368 028e AD01      		movw r20,r26
 250:switcherator.c ****             for (x = 0; x < 30; x++) {
 14369               		.loc 1 250 0 discriminator 2
 14370 0290 B0E0      		ldi r27,hi8(radioReceiveBuffer+30)
 14371 0292 E030      		cpi r30,lo8(radioReceiveBuffer+30)
 14372 0294 FB07      		cpc r31,r27
 14373 0296 01F4      		brne .L963
 14374 0298 00C0      		rjmp .L987
 14375               	.LFE7:
 14377               		.text
 14378               	.global	__vector_11
 14380               	__vector_11:
 14381               	.LFB86:
3786:switcherator.c **** }
3787:switcherator.c **** 
3788:switcherator.c **** ISR(TIMER1_COMPA_vect) {
 14382               		.loc 1 3788 0
 14383 4f00 1F92      		push r1
 14384               	.LCFI383:
 14385 4f02 0F92      		push r0
 14386               	.LCFI384:
 14387 4f04 0FB6      		in r0,__SREG__
 14388 4f06 0F92      		push r0
 14389 4f08 1124      		clr __zero_reg__
 14390 4f0a 2F93      		push r18
 14391               	.LCFI385:
 14392 4f0c 3F93      		push r19
 14393               	.LCFI386:
 14394 4f0e 4F93      		push r20
 14395               	.LCFI387:
 14396 4f10 5F93      		push r21
 14397               	.LCFI388:
 14398 4f12 6F93      		push r22
 14399               	.LCFI389:
 14400 4f14 7F93      		push r23
 14401               	.LCFI390:
 14402 4f16 8F93      		push r24
 14403               	.LCFI391:
 14404 4f18 9F93      		push r25
 14405               	.LCFI392:
 14406 4f1a AF93      		push r26
 14407               	.LCFI393:
 14408 4f1c BF93      		push r27
 14409               	.LCFI394:
 14410 4f1e EF93      		push r30
 14411               	.LCFI395:
 14412 4f20 FF93      		push r31
 14413               	.LCFI396:
 14414               	/* prologue: Signal */
 14415               	/* frame size = 0 */
 14416               	/* stack size = 15 */
 14417               	.L__stack_usage = 15
3789:switcherator.c ****     int tenthTicks;
3790:switcherator.c ****     ticks++;
 14418               		.loc 1 3790 0
 14419 4f22 4091 0000 		lds r20,ticks
 14420 4f26 5091 0000 		lds r21,ticks+1
 14421 4f2a 4F5F      		subi r20,-1
 14422 4f2c 5F4F      		sbci r21,-1
 14423 4f2e 5093 0000 		sts ticks+1,r21
 14424 4f32 4093 0000 		sts ticks,r20
3791:switcherator.c ****     // if its been a second
3792:switcherator.c ****     if (ticks >= tweakTimer) {
 14425               		.loc 1 3792 0
 14426 4f36 60E0      		ldi r22,0
 14427 4f38 70E0      		ldi r23,0
 14428 4f3a 8091 0000 		lds r24,tweakTimer
 14429 4f3e 9091 0000 		lds r25,tweakTimer+1
 14430 4f42 A091 0000 		lds r26,tweakTimer+2
 14431 4f46 B091 0000 		lds r27,tweakTimer+3
 14432 4f4a 4817      		cp r20,r24
 14433 4f4c 5907      		cpc r21,r25
 14434 4f4e 6A07      		cpc r22,r26
 14435 4f50 7B07      		cpc r23,r27
 14436 4f52 04F4      		brge .+2
 14437 4f54 00C0      		rjmp .L990
3793:switcherator.c ****         ticks = 0;
 14438               		.loc 1 3793 0
 14439 4f56 1092 0000 		sts ticks+1,__zero_reg__
 14440 4f5a 1092 0000 		sts ticks,__zero_reg__
3794:switcherator.c ****         globalSecond++;
 14441               		.loc 1 3794 0
 14442 4f5e 2091 0000 		lds r18,globalSecond
 14443 4f62 3091 0000 		lds r19,globalSecond+1
 14444 4f66 2F5F      		subi r18,-1
 14445 4f68 3F4F      		sbci r19,-1
 14446 4f6a 3093 0000 		sts globalSecond+1,r19
 14447 4f6e 2093 0000 		sts globalSecond,r18
3795:switcherator.c ****         weeklySeconds++;
 14448               		.loc 1 3795 0
 14449 4f72 8091 0000 		lds r24,weeklySeconds
 14450 4f76 9091 0000 		lds r25,weeklySeconds+1
 14451 4f7a A091 0000 		lds r26,weeklySeconds+2
 14452 4f7e B091 0000 		lds r27,weeklySeconds+3
 14453 4f82 0196      		adiw r24,1
 14454 4f84 A11D      		adc r26,__zero_reg__
 14455 4f86 B11D      		adc r27,__zero_reg__
 14456 4f88 8093 0000 		sts weeklySeconds,r24
 14457 4f8c 9093 0000 		sts weeklySeconds+1,r25
 14458 4f90 A093 0000 		sts weeklySeconds+2,r26
 14459 4f94 B093 0000 		sts weeklySeconds+3,r27
3796:switcherator.c ****         newSecond = 1;
 14460               		.loc 1 3796 0
 14461 4f98 41E0      		ldi r20,lo8(1)
 14462 4f9a 4093 0000 		sts newSecond,r20
3797:switcherator.c ****         if (globalSecond == 60) {
 14463               		.loc 1 3797 0
 14464 4f9e 2C33      		cpi r18,60
 14465 4fa0 3105      		cpc r19,__zero_reg__
 14466 4fa2 01F4      		brne .L990
3798:switcherator.c ****             globalMinute++;
 14467               		.loc 1 3798 0
 14468 4fa4 8091 0000 		lds r24,globalMinute
 14469 4fa8 9091 0000 		lds r25,globalMinute+1
 14470 4fac 0196      		adiw r24,1
 14471 4fae 9093 0000 		sts globalMinute+1,r25
 14472 4fb2 8093 0000 		sts globalMinute,r24
3799:switcherator.c ****             globalSecond = 0;
 14473               		.loc 1 3799 0
 14474 4fb6 1092 0000 		sts globalSecond+1,__zero_reg__
 14475 4fba 1092 0000 		sts globalSecond,__zero_reg__
3800:switcherator.c ****             newMinute = 1;
 14476               		.loc 1 3800 0
 14477 4fbe 4093 0000 		sts newMinute,r20
3801:switcherator.c ****             if (globalMinute == 60) {
 14478               		.loc 1 3801 0
 14479 4fc2 CC97      		sbiw r24,60
 14480 4fc4 01F4      		brne .L990
3802:switcherator.c ****                 globalHour++;
 14481               		.loc 1 3802 0
 14482 4fc6 8091 0000 		lds r24,globalHour
 14483 4fca 9091 0000 		lds r25,globalHour+1
 14484 4fce 0196      		adiw r24,1
 14485 4fd0 9093 0000 		sts globalHour+1,r25
 14486 4fd4 8093 0000 		sts globalHour,r24
3803:switcherator.c ****                 globalMinute = 0;
 14487               		.loc 1 3803 0
 14488 4fd8 1092 0000 		sts globalMinute+1,__zero_reg__
 14489 4fdc 1092 0000 		sts globalMinute,__zero_reg__
3804:switcherator.c ****                 // daylight savings is always at 3am
3805:switcherator.c ****                 if (globalHour == 3)
 14490               		.loc 1 3805 0
 14491 4fe0 0397      		sbiw r24,3
 14492 4fe2 01F4      		brne .L992
3806:switcherator.c ****                     checkDaylightSavings();
 14493               		.loc 1 3806 0
 14494 4fe4 0E94 0000 		call checkDaylightSavings
 14495               	.LVL1263:
 14496               	.L992:
3807:switcherator.c ****                 if (globalHour == 24) {
 14497               		.loc 1 3807 0
 14498 4fe8 8091 0000 		lds r24,globalHour
 14499 4fec 9091 0000 		lds r25,globalHour+1
 14500 4ff0 4897      		sbiw r24,24
 14501 4ff2 01F4      		brne .L990
3808:switcherator.c ****                     globalHour = 0;
 14502               		.loc 1 3808 0
 14503 4ff4 1092 0000 		sts globalHour+1,__zero_reg__
 14504 4ff8 1092 0000 		sts globalHour,__zero_reg__
3809:switcherator.c ****                     advanceDay();
 14505               		.loc 1 3809 0
 14506 4ffc 0E94 0000 		call advanceDay
 14507               	.LVL1264:
 14508               	.L990:
3810:switcherator.c ****                 }
3811:switcherator.c ****             }
3812:switcherator.c ****         }
3813:switcherator.c ****     }
3814:switcherator.c ****     tenthTicks = ticks % TIMER_TENTH;
 14509               		.loc 1 3814 0
 14510 5000 8091 0000 		lds r24,ticks
 14511 5004 9091 0000 		lds r25,ticks+1
 14512 5008 68E1      		ldi r22,lo8(24)
 14513 500a 76E0      		ldi r23,lo8(6)
 14514 500c 0E94 0000 		call __udivmodhi4
 14515               	.LVL1265:
3815:switcherator.c ****     if (tenthTicks == 0) {
 14516               		.loc 1 3815 0
 14517 5010 892B      		or r24,r25
 14518 5012 01F4      		brne .L988
3816:switcherator.c ****         tenthFlag = 1;
 14519               		.loc 1 3816 0
 14520 5014 81E0      		ldi r24,lo8(1)
 14521               	.LVL1266:
 14522 5016 8093 0000 		sts tenthFlag,r24
 14523               	.L988:
 14524               	/* epilogue start */
3817:switcherator.c ****         // set flags for whatever functions we want to do every 10th of a second here
3818:switcherator.c ****     }
3819:switcherator.c **** }
 14525               		.loc 1 3819 0
 14526 501a FF91      		pop r31
 14527 501c EF91      		pop r30
 14528 501e BF91      		pop r27
 14529 5020 AF91      		pop r26
 14530 5022 9F91      		pop r25
 14531 5024 8F91      		pop r24
 14532 5026 7F91      		pop r23
 14533 5028 6F91      		pop r22
 14534 502a 5F91      		pop r21
 14535 502c 4F91      		pop r20
 14536 502e 3F91      		pop r19
 14537 5030 2F91      		pop r18
 14538 5032 0F90      		pop r0
 14539 5034 0FBE      		out __SREG__,r0
 14540 5036 0F90      		pop r0
 14541 5038 1F90      		pop r1
 14542 503a 1895      		reti
 14543               	.LFE86:
 14545               		.local	receiveBuffer
 14546               		.comm	receiveBuffer,30,1
 14547               		.local	radioReceiveBuffer
 14548               		.comm	radioReceiveBuffer,30,1
 14549               		.local	colorChanges
 14550               		.comm	colorChanges,18,1
 14551               		.local	dow
 14552               		.comm	dow,2,1
 14553               		.local	globalSecond
 14554               		.comm	globalSecond,2,1
 14555               		.local	globalMinute
 14556               		.comm	globalMinute,2,1
 14557               		.local	globalHour
 14558               		.comm	globalHour,2,1
 14559               		.local	globalDay
 14560               		.comm	globalDay,2,1
 14561               		.local	globalMonth
 14562               		.comm	globalMonth,2,1
 14563               		.local	globalYear
 14564               		.comm	globalYear,2,1
 14565               		.local	switchStatus
 14566               		.comm	switchStatus,64,1
 14567               		.local	switchStuff
 14568               		.comm	switchStuff,16,1
 14569               		.local	switchBright
 14570               		.comm	switchBright,16,1
 14571               		.local	inputs
 14572               		.comm	inputs,32,1
 14573               		.local	newSecond
 14574               		.comm	newSecond,1,1
 14575               		.local	switchChanged
 14576               		.comm	switchChanged,1,1
 14577               		.local	runHue
 14578               		.comm	runHue,1,1
 14579               		.local	runColorChanges
 14580               		.comm	runColorChanges,1,1
 14581               		.local	tenthFlag
 14582               		.comm	tenthFlag,1,1
 14583               		.data
 14586               	failCondition:
 14587 0000 03        		.byte	3
 14588               		.local	newMinute
 14589               		.comm	newMinute,1,1
 14592               	panicMyClockIsNotSet:
 14593 0001 01        		.byte	1
 14596               	stringSerial:
 14597 0002 3030 3030 		.string	"000000"
 14597      3030 00
 14598               		.local	serial
 14599               		.comm	serial,4,1
 14600               		.local	statusMsg
 14601               		.comm	statusMsg,32,1
 14604               	tempIntString:
 14605 0009 3030 00   		.string	"00"
 14608               	tempHugeString:
 14609 000c 3030 3030 		.string	"000000"
 14609      3030 00
 14610               		.local	weeklySeconds
 14611               		.comm	weeklySeconds,4,1
 14612               		.local	pwmValues
 14613               		.comm	pwmValues,3,1
 14614               		.local	red
 14615               		.comm	red,2,1
 14616               		.local	green
 14617               		.comm	green,2,1
 14618               		.local	blue
 14619               		.comm	blue,2,1
 14622               	bright:
 14623 0013 1000      		.word	16
 14624               		.local	pwmdir
 14625               		.comm	pwmdir,1,1
 14628               	oldBright:
 14629 0015 10        		.byte	16
 14632               	tempLongString:
 14633 0016 3030 3030 		.string	"0000"
 14633      00
 14636               	colorChangeSpeed:
 14637 001b 0A00      		.word	10
 14640               	hueSpeed:
 14641 001d 1000      		.word	16
 14642               		.local	colorChangeCount
 14643               		.comm	colorChangeCount,2,1
 14644               		.local	currentColor
 14645               		.comm	currentColor,1,1
 14646               		.local	littleCount
 14647               		.comm	littleCount,1,1
 14648               		.local	hueCount
 14649               		.comm	hueCount,2,1
 14650               		.local	currentHue
 14651               		.comm	currentHue,2,1
 14652               		.local	weeklyProgram
 14653               		.comm	weeklyProgram,100,1
 14654               		.local	tx_addr
 14655               		.comm	tx_addr,8,1
 14656               		.local	rx_addr_p0
 14657               		.comm	rx_addr_p0,8,1
 14658               		.local	rx_addr_p1
 14659               		.comm	rx_addr_p1,8,1
 14660               		.local	rx_addr_p2
 14661               		.comm	rx_addr_p2,8,1
 14662               		.local	rx_addr_p3
 14663               		.comm	rx_addr_p3,8,1
 14664               		.local	rx_addr_p4
 14665               		.comm	rx_addr_p4,8,1
 14666               		.local	rx_addr_p5
 14667               		.comm	rx_addr_p5,8,1
 14670               	tweakTimer:
 14671 001f 09        		.byte	9
 14672 0020 3D        		.byte	61
 14673 0021 00        		.byte	0
 14674 0022 00        		.byte	0
 14675               		.local	daylightSavings
 14676               		.comm	daylightSavings,8,1
 14677               		.local	timeLimits
 14678               		.comm	timeLimits,48,1
 14679               		.local	wasDaylightSavings
 14680               		.comm	wasDaylightSavings,1,1
 14681               		.local	failTimer
 14682               		.comm	failTimer,1,1
 14683               		.local	ticks
 14684               		.comm	ticks,2,1
 17645               	.Letext0:
 17646               		.file 3 "/usr/lib/gcc/avr/4.7.2/include/stddef.h"
 17647               		.file 4 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/stdint.h"
 17648               		.file 5 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/stdlib.h"
 17649               		.file 6 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/eeprom.h"
 17650               		.file 7 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/string.h"
 17651               		.file 8 "../myavrnrflib/nrf.h"
DEFINED SYMBOLS
                            *ABS*:00000000 switcherator.c
     /tmp/ccD64DoY.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccD64DoY.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccD64DoY.s:4      *ABS*:0000003f __SREG__
     /tmp/ccD64DoY.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccD64DoY.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccD64DoY.s:11     .text:00000000 drawInterface
     /tmp/ccD64DoY.s:24     .text:00000002 getSwitchNumber
     /tmp/ccD64DoY.s:14604  .data:00000009 tempIntString
     /tmp/ccD64DoY.s:49     .text:00000018 getPort
     /tmp/ccD64DoY.s:14566  .bss:0000009c switchStuff
     /tmp/ccD64DoY.s:208    .text:000000bc pwmClear
     /tmp/ccD64DoY.s:14628  .data:00000015 oldBright
     /tmp/ccD64DoY.s:14622  .data:00000013 bright
     /tmp/ccD64DoY.s:14576  .bss:000000de runHue
     /tmp/ccD64DoY.s:14578  .bss:000000df runColorChanges
     /tmp/ccD64DoY.s:257    .text:000000f8 clearTheSwitch
     /tmp/ccD64DoY.s:413    .text:000001be runColorFunction
     /tmp/ccD64DoY.s:14625  .bss:00000114 colorChangeCount
     /tmp/ccD64DoY.s:14636  .data:0000001b colorChangeSpeed
     /tmp/ccD64DoY.s:14643  .bss:00000116 currentColor
     /tmp/ccD64DoY.s:14548  .bss:0000003c colorChanges
     /tmp/ccD64DoY.s:14613  .bss:0000010d red
     /tmp/ccD64DoY.s:14615  .bss:0000010f green
     /tmp/ccD64DoY.s:14617  .bss:00000111 blue
     /tmp/ccD64DoY.s:555    .text:000002ae runHueFunction
     /tmp/ccD64DoY.s:14645  .bss:00000117 littleCount
     /tmp/ccD64DoY.s:14647  .bss:00000118 hueCount
     /tmp/ccD64DoY.s:14640  .data:0000001d hueSpeed
     /tmp/ccD64DoY.s:14649  .bss:0000011a currentHue
     /tmp/ccD64DoY.s:792    .text:00000492 clearTheProgram
     /tmp/ccD64DoY.s:14651  .bss:0000011c weeklyProgram
     /tmp/ccD64DoY.s:838    .text:000004be findOpenSwitch
     /tmp/ccD64DoY.s:889    .text:000004f2 programGetSwitches
     /tmp/ccD64DoY.s:973    .text:00000552 startTheProgram
     /tmp/ccD64DoY.s:14601  .bss:00000106 weeklySeconds
     /tmp/ccD64DoY.s:14564  .bss:0000005c switchStatus
     /tmp/ccD64DoY.s:14574  .bss:000000dd switchChanged
     /tmp/ccD64DoY.s:1148   .text:0000064e readEEPROM
     /tmp/ccD64DoY.s:1238   .text:000006aa writeEEPROM
     /tmp/ccD64DoY.s:1277   .text:000006ca clearEEPROM
     /tmp/ccD64DoY.s:1294   .text:000006d2 clockInit
     /tmp/ccD64DoY.s:1317   .text:000006ec startClock
     /tmp/ccD64DoY.s:1340   .text:00000704 stopClock
     /tmp/ccD64DoY.s:1358   .text:00000710 getWeekday
     /tmp/ccD64DoY.s:14562  .bss:0000005a globalYear
     /tmp/ccD64DoY.s:1469   .text:000007a4 getDayofYear
     /tmp/ccD64DoY.s:1557   .text:0000080a checkDaylightSavings
     /tmp/ccD64DoY.s:14678  .bss:000001f0 wasDaylightSavings
     /tmp/ccD64DoY.s:14560  .bss:00000058 globalMonth
     /tmp/ccD64DoY.s:14667  .bss:000001b8 daylightSavings
     /tmp/ccD64DoY.s:14558  .bss:00000056 globalDay
     /tmp/ccD64DoY.s:14556  .bss:00000054 globalHour
     /tmp/ccD64DoY.s:1623   .text:0000088e advanceDay
     /tmp/ccD64DoY.s:14550  .bss:0000004e dow
     /tmp/ccD64DoY.s:1810   .text:000009da timerCheck
     /tmp/ccD64DoY.s:2050   .text:00000b42 switchOnOff
     /tmp/ccD64DoY.s:14611  .bss:0000010a pwmValues
     /tmp/ccD64DoY.s:14568  .bss:000000ac switchBright
     /tmp/ccD64DoY.s:2404   .text:00000d40 returnInt
     /tmp/ccD64DoY.s:14608  .data:0000000c tempHugeString
     /tmp/ccD64DoY.s:2468   .text:00000d7c clockString
     /tmp/ccD64DoY.s:14599  .bss:000000e6 statusMsg
     /tmp/ccD64DoY.s:14554  .bss:00000052 globalMinute
     /tmp/ccD64DoY.s:14552  .bss:00000050 globalSecond
     /tmp/ccD64DoY.s:2613   .text:00000e74 returnHex
     /tmp/ccD64DoY.s:2692   .text:00000ed0 returnHexWithout
     /tmp/ccD64DoY.s:2755   .text:00000f16 formatAddress
     /tmp/ccD64DoY.s:2815   .text:00000f50 generalInit
     /tmp/ccD64DoY.s:14653  .bss:00000180 tx_addr
     /tmp/ccD64DoY.s:14655  .bss:00000188 rx_addr_p0
     /tmp/ccD64DoY.s:14657  .bss:00000190 rx_addr_p1
     /tmp/ccD64DoY.s:14659  .bss:00000198 rx_addr_p2
     /tmp/ccD64DoY.s:14661  .bss:000001a0 rx_addr_p3
     /tmp/ccD64DoY.s:14663  .bss:000001a8 rx_addr_p4
     /tmp/ccD64DoY.s:14665  .bss:000001b0 rx_addr_p5
     /tmp/ccD64DoY.s:14670  .data:0000001f tweakTimer
     /tmp/ccD64DoY.s:14589  .bss:000000e2 serial
     /tmp/ccD64DoY.s:14596  .data:00000002 stringSerial
     /tmp/ccD64DoY.s:14570  .bss:000000bc inputs
     /tmp/ccD64DoY.s:14676  .bss:000001c0 timeLimits
     /tmp/ccD64DoY.s:14619  .bss:00000113 pwmdir
     /tmp/ccD64DoY.s:3630   .text:000014b2 unformatAddress
     /tmp/ccD64DoY.s:3678   .text:000014da getInput
     /tmp/ccD64DoY.s:4682   .text:00001aca inputTenthCheck
     /tmp/ccD64DoY.s:4742   .text:00001b08 inputCheck
     /tmp/ccD64DoY.s:4821   .text:00001b6a flashFail
     /tmp/ccD64DoY.s:14680  .bss:000001f1 failTimer
     /tmp/ccD64DoY.s:14586  .data:00000000 failCondition
     /tmp/ccD64DoY.s:4932   .text:00001be8 clearFail
     /tmp/ccD64DoY.s:4950   .text:00001bf2 sendMessage
     /tmp/ccD64DoY.s:5032   .text:00001c4e serialNumber
     /tmp/ccD64DoY.s:5187   .text:00001d0c radioChangeAddress
     /tmp/ccD64DoY.s:14632  .data:00000016 tempLongString
     /tmp/ccD64DoY.s:5639   .text:0000201c radioDisplayAddress
     /tmp/ccD64DoY.s:5895   .text:000021fc switchesOn
     /tmp/ccD64DoY.s:5984   .text:0000226a inputsProgrammed
     /tmp/ccD64DoY.s:6069   .text:000022d0 switchesProgrammed
     /tmp/ccD64DoY.s:6153   .text:00002334 programsProgrammed
     /tmp/ccD64DoY.s:6251   .text:000023a0 generalInformation
     /tmp/ccD64DoY.s:6600   .text:0000259a generalStatus
     /tmp/ccD64DoY.s:14592  .data:00000001 panicMyClockIsNotSet
     /tmp/ccD64DoY.s:6883   .text:00002728 programDisplay
     /tmp/ccD64DoY.s:7396   .text:000029fe pwmSummary
     /tmp/ccD64DoY.s:7728   .text:00002bd4 switchDisplay
     /tmp/ccD64DoY.s:7881   .text:00002ca2 ok
     /tmp/ccD64DoY.s:7897   .text:00002caa clearInput
     /tmp/ccD64DoY.s:8006   .text:00002d28 setDaylightSavings
     /tmp/ccD64DoY.s:8113   .text:00002dba clearToEEPROM
     /tmp/ccD64DoY.s:8279   .text:00002eba saveToEEPROM
     /tmp/ccD64DoY.s:8967   .text:00003370 pwmValueSet
     /tmp/ccD64DoY.s:9076   .text:00003406 setHueSpeed
     /tmp/ccD64DoY.s:9113   .text:0000342e cycleHue
     /tmp/ccD64DoY.s:9156   .text:00003462 switchClear
     /tmp/ccD64DoY.s:9181   .text:0000346e clockTweak
     /tmp/ccD64DoY.s:9275   .text:00003500 brightnessSet
     /tmp/ccD64DoY.s:9380   .text:0000359e fail
     /tmp/ccD64DoY.s:9431   .text:000035d6 setDigitalInput
     /tmp/ccD64DoY.s:9831   .text:000037de setAnalogInput
     /tmp/ccD64DoY.s:10307  .text:00003aa0 startProgram
     /tmp/ccD64DoY.s:10403  .text:00003b1a programSetTime
     /tmp/ccD64DoY.s:10663  .text:00003c6a programSetDays
     /tmp/ccD64DoY.s:10848  .text:00003d6c programAddSwitch
     /tmp/ccD64DoY.s:11154  .text:00003f0a clearProgram
     /tmp/ccD64DoY.s:11232  .text:00003f5c colorChangeSet
     /tmp/ccD64DoY.s:11354  .text:00004008 pwmSetup
     /tmp/ccD64DoY.s:11519  .text:000040d6 startSwitch
     /tmp/ccD64DoY.s:11848  .text:000042c4 setNewSwitch
     /tmp/ccD64DoY.s:12136  .text:00004426 setTimeLimits
     /tmp/ccD64DoY.s:12624  .text:00004710 newProgram
     /tmp/ccD64DoY.s:12896  .text:00004874 switchBrightness
     /tmp/ccD64DoY.s:13041  .text:00004928 radioTest
     /tmp/ccD64DoY.s:13119  .text:00004996 radioInit
     /tmp/ccD64DoY.s:13281  .text:00004b28 setClock
     /tmp/ccD64DoY.s:13524  .text:00004cca checkCommand
     /tmp/ccD64DoY.s:13929  .text.startup:00000000 main
                             .bss:00000000 receiveBuffer
     /tmp/ccD64DoY.s:14546  .bss:0000001e radioReceiveBuffer
     /tmp/ccD64DoY.s:14572  .bss:000000dc newSecond
     /tmp/ccD64DoY.s:14580  .bss:000000e0 tenthFlag
     /tmp/ccD64DoY.s:14582  .bss:000000e1 newMinute
     /tmp/ccD64DoY.s:14380  .text:00004f00 __vector_11
     /tmp/ccD64DoY.s:14682  .bss:000001f2 ticks

UNDEFINED SYMBOLS
atoi
__eerd_word_m328
__eerd_block_m328
__eeupd_block_m328
__eeupd_word_m328
__divmodhi4
__muluhisi3
itoa
strcat
__ashldi3
writeAddr
atol
ltoa
__lshrdi3
__mulsi3
__umulhisi3
__divmodsi4
__udivmodsi4
stopRx
transmit
startRx
strtol
__udivmodhi4
__cmpdi2_s8
__usmulhisi3
readAddr
__cmpdi2
nrfInit
writeReg
startRadio
dynReceive
strcmp
strncmp
__do_copy_data
__do_clear_bss
